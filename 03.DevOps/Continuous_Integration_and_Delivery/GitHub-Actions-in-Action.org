#+TITLE: GitHub Actions in Action
#+SUBTITLE: Continuous integration and delivery for DevOps
#+AUTHOR: Michael Kaufmann, Rob Bos, Marcel de Vries
#+FOREWORD BY: Scott Hanselman
#+VERSION: 2025
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

** foreword - xii
** preface - xiii
** acknowledgments - xiv
** about this book - xv
** about the authors - xviii
** about the cover illustration - xx

* Part 1 Action fundamentals - 1
** 1 Introduction to GitHub Actions - 3
*** 1.1 An introduction to the GitHub universe - 4
*** 1.2 What are GitHub Actions and workflows? - 6
*** 1.3 GitHub Actions: More than CI/CD pipelines - 8
*** 1.4 Hosting and pricing for GitHub and GitHub Actions - 8
**** GitHub Enterprise Cloud - 9
**** GitHub Enterprise Server - 9
**** GitHub pricing - 10
**** GitHub Actions pricing - 10

*** 1.5 Conclusion - 12

** 2 Hands-on: My first Actions workflow - 13
*** 2.1 Creating a new workflow - 14
*** 2.2 Using the workflow editor - 16
*** 2.3 Using actions from the marketplace - 18
*** 2.4 Running the workflow - 20
*** 2.5 Conclusion - 23

** 3 Workflows - 24
*** 3.1 YAML - 25
**** YAML basics - 25
**** Data types - 25

*** 3.2 The workflow syntax - 27
*** 3.3 Events and triggers - 27
**** Webhook triggers - 27
**** Scheduled triggers - 28
**** Manual triggers - 29

*** 3.4 Workflow jobs and steps - 33
**** Workflow jobs - 33
**** Workflow steps - 34
**** Using GitHub actions - 35
**** The matrix strategy - 36

*** 3.5 Expressions and contexts - 37
*** 3.6 Workflow commands - 39
**** Writing a debug message - 40
**** Creating error or warning messages - 40
**** Passing an output to subsequent steps and jobs - 42
**** Environment files - 42
**** Job summaries - 43

*** 3.7 Secrets and variables - 45
*** 3.8 Workflow permissions - 47
*** 3.9 Authoring and debugging workflows - 48
*** 3.10 Conclusion - 50

** 4 GitHub Actions - 53
*** 4.1 Types of actions - 52
**** Docker container actions - 53
**** JavaScript actions - 54
**** Composite actions - 54

*** 4.2 Authoring actions - 55
**** Getting started - 56
**** Storing actions in GitHub - 56
**** Compatibility with GitHub Enterprise Server - 57
**** Release management - 57

*** 4.3 Hands-on lab: My first Docker container action - 58
**** Using the template to create a new repository - 58
**** Creating the Dockerfile for the action - 59
**** Creating the action.yml file - 60
**** Creating the entrypoint.sh script - 60
**** Create a workflow to test the container - 60

*** 4.4 Sharing actions - 62
**** Sharing actions in your organization - 62
**** Sharing actions publicly - 63

*** 4.5 Advanced action development - 68
*** 4.6 Best practices - 69
*** 4.7 Conclusion - 70

* Part 2 Workflow runtime - 71
** 5 Runners - 74
*** 5.1 Targeting a runner - 73
*** 5.2 Queuing jobs - 74
*** 5.3 The runner application - 75
*** 5.4 GitHub-hosted runners - 75
*** 5.5 Hosted operating systems - 77
*** 5.6 Installed software - 78
*** 5.7 Default shells - 80
*** 5.8 Installing extra software - 80
*** 5.9 Location and hardware specifications of the hosted runners - 81
*** 5.10 Concurrent jobs - 81
*** 5.11 Larger GitHub-hosted runners - 82
*** 5.12 GitHub-hosted runners in your own Azure Virtual Network - 83
*** 5.13 Billing GitHub-hosted runners - 84
*** 5.14 Analyzing the usage of GitHub-hosted runners - 86
*** 5.15 Self-hosted runners - 88

** 6 Self-hosted runners - 90
*** 6.1 Setting up self-hosted runners - 89
**** Runner communication - 94
**** Queued jobs - 97
**** Updating self-hosted runners - 97
**** Available runners - 98
**** Downloading actions and source code - 98
**** Runner capabilities - 100
**** Selfhosted runner behind a proxy - 101
**** Usage limits of self-hosted runners - 101
**** Installing extra software - 101
**** Runner service account - 103
**** Pre- and post-job scripts - 103
**** Adding extra information to your logs - 104
**** Customizing the containers during a job - 105

*** 6.2 Security risks of self-hosted runners - 106
*** 6.3 Single-use runners - 107
**** Ephemeral runners - 108
**** Just-in-time runners - 108

*** 6.4 Disabling self-hosted runner creation - 109
*** 6.5 Autoscaling options - 110
**** Autoscaling with Actions Runner Controller - 111
**** Communication in ARC - 112
**** ARC monitoring - 112

** 7 Managing your self-hosted runners - 114
*** 7.1 Runner groups - 114
**** Assigning a runner to a runner group - 117

*** 7.2 Monitoring your runners - 118
**** What to monitor - 120
**** Monitoring available runners using GitHub Actions - 121
**** Building a custom solution - 122
**** Using a monitoring solution - 123

*** 7.3 Runner utilization and capacity needs - 124
*** 7.4 Monitoring network access - 126
**** Monitor and limit network access - 126
**** Recommended setup - 128

*** 7.5 Internal billing for action usage - 128

* Part 3 CI/CD with GitHub Actions - 131
** 8 Continuous integration - 134
*** 8.1 GloboTicket: A sample application - 133
*** 8.2 Why continuous integration? - 135
*** 8.3 Types of CI - 136
**** Using a branching strategy: GitHub Flow - 136
**** CI for integration - 137
**** CI for quality control - 138
**** CI for security testing - 138
**** CI for packaging - 138

*** 8.4 Generic CI workflow steps - 139
**** Getting the sources - 139
**** Building the sources into artifacts - 139
**** Testing the artifacts - 141
**** Test result reporting - 141
**** Using containers for jobs - 142
**** Multiple workflows vs. multiple jobs: Which to choose? - 143
**** Parallel execution of jobs - 144

*** 8.5 Preparing for deployment - 145
**** Traceability of source to artifacts - 145
**** Ensuring delivery integrity: The software bill of materials - 147
**** Versioning 148 Testing for security with container scanning - 150
**** Using GitHub package management and container registry - 150
**** Using the upload/download capability to store artifacts - 154
**** Preparing deployment artifacts - 156
**** Creating a release - 158

*** 8.6 The CI workflows for GloboTicket - 161
**** The integration CI for APIs and frontends - 161
**** CI workflows for quality control - 162
**** The CI workflow for security testing - 163
**** The CI workflows for container image creation and publishing - 167
**** Creating a release - 167

*** 8.7 Conclusion - 167

** 9 Continuous delivery - 170
*** 9.1 CD workflow steps - 169
**** Steps to deploy our GloboTicket application - 170
**** Triggering the deployment - 171
**** Getting the deployment artifacts - 171
**** Deployment - 172
**** Verifying the deployment - 173

*** 9.2 Using environments - 174
**** What is an environment? - 175
**** Manual approval - 175
**** Environment variables - 176
**** Dealing with secrets - 177

*** 9.3 Deployment strategies - 178
**** Deploying on premises - 178
**** Deploying to cloud - 178
**** OpenID Connect (OIDC) - 178
**** Using health endpoints - 182
**** Deployment vs. release - 183
**** Zero-downtime deployments - 184
**** Redâ€“green deployments - 185
**** Ring-based deployments - 189

** 10 Security - 193
*** 10.1 Preventing pwn requests - 192
*** 10.2 Managing untrusted input - 196
*** 10.3 GitHub Actions security- 199
**** The principle of least privileged - 200
**** Referencing actions - 201

*** 10.4 Supply chain security - 203
**** Dependabot version updates for actions - 204
**** Code scanning actions - 205

** 11 Compliance - 208
*** 11.1 How to ensure traceability of work - 207
**** How to ensure commits are traceable - 208

*** 11.2 How to enforce the four-eyes principle - 211
**** Enforcing segregation of duties with CODEOWNERS file - 212
**** Showing end-to-end traceability - 212

*** 11.3 Mandatory workflows - 213
**** Summary - 215

** 12 Improving workflow performance and costs - 216
*** 12.1 Dealing with high-volume builds - 217
**** Concurrency groups - 217
**** Merge queues - 218

*** 12.2 Reducing the costs of maintaining artifacts - 219
*** 12.3 Improving performance - 220
**** Using a sparse checkout - 220
**** Adding caching 220 Detecting a cache hit and skipping the work - 223
**** Selecting other runners - 224

*** 12.4 Optimizing your jobs - 225

* index - 227
