#+TITLE: Pro Git
#+AUTHOR: Scott Chacon, Ben Straub
#+Version: Version 2.1.327-2-ge65fe47, 2021-08-15 -> Version 2.1.447, 2025-04-10
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Licence - 1
* Preface by Scoot Chacon - 2
* Preface by Ben Straub - 3
* Dedications - 4
* Contributors - 5
* Introduction - 8
* DONE 1. Getting Started - 10
CLOSED: [2019-05-21 Tue 11:50]
** TODO 1.1 About Version Control - 10
*** TODO Local Version Control Systems - 10
*** TODO Centralized Version Control Systems - 11
*** TODO Distributed Version Control Systems - 12

** DONE 1.2 A Short History of Git - 14
CLOSED: [2017-07-14 Fri 05:26]
Birth in 2005

** DONE 1.3 What is Git? - 14
CLOSED: [2019-08-17 Sat 21:41]
*** DONE Snapshots, Not Differences - 14
CLOSED: [2017-07-14 Fri 04:18]
- /The other VCS/ (/Subversion/ and friends included) store info as a list of
  file-based changes.

  These systems (CVS, Subversion, Perforce, Bazaar, and so on) think of the
  info they keep as a set of files and the changes made to each file over
  time.

- /Git/ thinks about its data more like a _stream of snapshots_.
  NO-change files won't be save again, only create a link to it.

*** DONE Nearly Every Operation Is Local - 15
CLOSED: [2017-07-14 Fri 04:21]
This is also the main difference between /Git/ and the other VCS's.

*** DONE Git Has Integrity - 16
CLOSED: [2017-07-14 Fri 04:37]
- Everything in Git is _check-summed_ before it is stored and is then
  referred to by that /checksum/ -- impossible to make change without Git
  knowing about it.

- Git uses SHA-1 hash for this checksumming (40-character hex).

*** DONE Git Generally Only Adds Data - 16
CLOSED: [2017-07-14 Fri 04:42]
As in any VCS, you can lose or mess up changes you haven't committed yet;
but after you commit a snapshot into Git, it is very difficult to lose.

=TODO= Any exception.

*** DONE The Three States - 16
CLOSED: [2017-07-14 Fri 05:05]
Git has _THREE_ main states that your file can reside in:
- /committed/ :: the data is safely stored in your local database.
- /modified/ :: file(s) has/have been changed but _NOT_ committed.
- /staged/ :: marked a /modified/ file in its current version to go
              into your next commit snapshot.

See Figure 1-6. (page 8)

This leads us to the three main sections of a Git project:
- the =.git= directory (Repository):
  _where_ Git stores the metadata and object database for your project.
  This is _the most important part_ of Git, and it is what is copied when you
  clone a repository from another computer.

- the working directory:
  a single checkout of one version of the project.
  These files are pulled out of the compressed database in the Git directory
  and placed on disk for you to use or modify.

- the staging area:
  a file, generally contained in your =.git= directory, that stores
  information about what will go into your next commit. It's sometimes
  referred to as the "index", but it's also common to refer to it as the
  staging area.

** DONE 1.4 The Command Line - 18
CLOSED: [2017-07-14 Fri 05:10]
For this book, we will be using Git on the command line.

** DONE 1.5 Installing Git - 18
CLOSED: [2017-07-14 Fri 05:10]
This book was written using Git version 2.0.0.
Any version after 2.0 should work just fine.

*** Installing on Linux - 18
*** Installing on macOS - 19
*** Installing on Windows - 19
*** Installing from Source - 20

** DONE 1.6 First-Time Git Setup - 21
CLOSED: [2017-07-14 Fri 05:21]
*** DONE Your Identity - 22
CLOSED: [2017-07-14 Fri 05:15]
#+BEGIN_SRC bash
  git config --global user.name "John Doe"
  git config --global user.email johndoe@example.com
#+END_SRC

Run with ~--global~ to override the ~config~ in a local project.

*** DONE Your Editor - 22
CLOSED: [2017-07-14 Fri 05:20]
#+BEGIN_SRC bash
  git config --global core.editor emacs
  # or
  git config --global core.editor vim
#+END_SRC
=Me= I think no one needd a local editor setting.

*** TODO Your default branch name - 23
*** DONE Checking Your Settings - 23
CLOSED: [2017-07-14 Fri 05:21]
#+BEGIN_SRC bash
  git config --list
  # user.name=John Doe
  # user.email=johndoe@example.com
  # color.status=auto
  # color.branch=auto
  # color.interactive=auto
  # color.diff=auto
  # ...

  git config user.name
  # John Doe
#+END_SRC

** DONE 1.7 Getting Help - 24
CLOSED: [2017-07-14 Fri 05:13]
#+BEGIN_SRC bash
  git help <verb>
  git <verb> --help
  man git-<verb>
#+END_SRC

You can also try the =#git= or =#github= channel on the Freenode IRC server
(irc. freenode.net).

** DONE 1.8 Summary - 25
CLOSED: [2017-07-14 Fri 05:14]

* DONE 2. Git Basics - 26
CLOSED: [2021-04-15 Thu 22:13]
If you can read only one chapter to get going with Git, this is it.

- By the end of the chapter, you should be able to:
  * configure and initialize a repository
  * begin and stop tracking files
  * stage and commit changes
  * set up Git to ignore certain files and file patterns
  * undo mistakes quickly and easily
  * browse the history of your project and view changes between commits
  * push and pull from remote repositories

** DONE 2.1 Getting a Git Repository - 26
CLOSED: [2017-07-15 Sat 14:07]
Two main approaches:
1. The first takes an existing project or directory and imports it into Git.
2. The second clones an existing Git repository from another server.

*** DONE Initializing a Repository in an Existing Directory - 26
CLOSED: [2017-07-15 Sat 14:07]
- ~git init~
  TODO What files are in the =.git= folder.

- Add and commit:
  #+BEGIN_SRC bash
    git add *.c
    git add LICENSE
    git commit -m 'initial project version'
  #+END_SRC

*** DONE Cloning an Existing Repository - 27
CLOSED: [2017-07-15 Sat 14:07]
~git clone <from> [<to>]~

** DONE 2.2 Recording Changes to the Repository - 28
CLOSED: [2019-08-19 Mon 00:21]
- Each file in your working directory can be in one of two states:
  * tracked
  * untracked

- _Tracked files_ are files that were in the last snapshot;
  They can be
  * unmodified
  * modified
  * staged.

- _Untracked files_ are everything else -- any files in your working directory
  that were
  * NOT in your last snapshot
  * NOT in your staging area

- Figure 2-1. The lifecycle of the status of your files
  _Untracked_ ------> _Unmodified_ ------> _Modified_ -------> _Staged_
      |--add the file-------------------------------------------->|
      |                    |--Edit the file-->|                   |
      |                    |                  |--Stage the file-->|
      |<--Remove the file--|                  |                   |
      |                    |<--------------------commit-----------|

*** DONE Checking the Status of Your Files - 28
CLOSED: [2017-07-16 Sun 22:58]
~git status~

*** DONE Tracking New Files - 29
CLOSED: [2017-07-16 Sun 22:58]
~git add [<filename(s)> | <directory>]~
~git add~ works recursively.

*** DONE Staging Modified Files - 30
CLOSED: [2017-07-16 Sun 23:10]
- ~git add~ is a multipurpose command -- you use it
  * to begin tracking new files
  * to stage files
  * to do other things like marking merge-conflicted files as resolved. =TODO=

- It may be helpful to think of it
  _more as_ "add this content to the next commit"
  _rather than_ "add this file to the project".

- A file can be /staged/ and /unstaged/ simutaneously:
  If you staged a change in a file and modified this file again before
  committing, then this file is marked as /staged/ and /unstaged/, which
  actually means some change is /staged/ and some change is /unstaged/.

*** DONE Short Status - 31
CLOSED: [2019-05-21 Tue 15:53]
- Command:
  ~git status --short~ or ~git status -s~

- Case study:
  #+BEGIN_SRC text
     M README
    MM Rakefile
    A  lib/git.rb
    M  lib/simplegit.rb
    ?? LICENSE.txt
  #+END_SRC
  * _??_ : _untracked_ file
  * _A _: new files that have been added to the staging area have an A,
  * M: modified files have an M and so on.
       There are _TWO columns_ to the output --
    + left column: the file is staged
    + right column: the file is modified

- So for example in that output,
  * =README=
    is _modified_ in the working directory but _not yet staged_,

  * =lib/simplegit.rb=:
    is _modified_ and _staged_.

  * =Rakefile=:
    was _modified_, _staged_ and then _modified again_, so there are
    changes to it that are _BOTH staged and unstaged_.

*** DONE Ignoring Files - 32
CLOSED: [2019-05-21 Tue 16:59]
Use =.gitignore= file to tell git the files you don't want to track or even
show.

- You usually don't want to see some automatically

- The _rules for the patterns_ you can put in the =.gitignore= file are as follows:
  * Blank lines or lines starting with # are ignored.

  * Standard glob patterns =???= work, and will be applied _recursively throughout
    the entire working tree_.

  * You can _start_ patterns with a forward slash (/) to *AVOID recursivity*.

  * You can _end_ patterns with a forward slash (/) to _specify a directory_.

  * You can _negate_ a pattern by _starting_ it with an exclamation point (~!~).

- Glob patterns are LIKE _simplified regular expressions_ that shells use.
  * ~*~ matches zero or more characters

  * ~[abc]~ matches any character inside the brackets (in this case ~a~, ~b~,
    or ~c~)

  * ~?~ matches a single character

  * Patterns like ~[0-9]~ matches any character between them _inclusively_

  * ~**~ matches _nested directories_.
    For instance, ~a/**/z~ would match ~a/z~, ~a/b/z~, ~a/b/c/z~, and so on.

- Case Study:
  #+begin_src gitignore
    # ignore all .a files
    ,*.a

    # but do track lib.a, even though you're ignoring .a files above
    !lib.a

    # only ignore the TODO file in the current directory, not subdir/TODO
    /TODO

    # ignore all files in any directory named build
    build/

    # ignore doc/notes.txt, but not doc/server/arch.txt
    doc/*.txt

    # ignore all .pdf files in the doc/ directory and any of its subdirectories
    doc/**/*.pdf
  #+end_src

- *Tips*
   GitHub maintains a fairly comprehensive list of good =.gitignore= file
   examples for dozens of projects and languages at
  https://github.com/github/gitignore.
  _Pick one at the start point of your project._

- *CAUTION*
  You can have only one =.gitignore= in the root of your simple project.
  However, it is also possible to have _ADDITIONAL_ =.gitignore= files in
  subdirectories.
    The rules in these nested =.gitignore= files apply only to the files
  under the directory where they are located.

  Use ~man gitignore~ for the details.

*** DONE Viewing Your Staged and Unstaged Changes - 33
CLOSED: [2019-08-19 Mon 00:20]
~git diff~ show more details than ~git status~.
- ~git diff~ shows you the exact lines added and removed -- the patch, as it
  were.

- You probably use ~git diff~ most often to answer two questions:
  * Q :: What have you changed but not yet staged? --
         =from Jian= compare _not staged changes_ with branch head.

  * Q :: What have you staged that you are about to commit? --
         =from Jian= compare _staged changes_ with branch head.

- For example,
  _edited and staged_ =README= and _edited_ =CONTRIBUTING.md=
  * ~git diff~ compare =CONTRIBUTING.md= with branch head
  * ~git diff --staged~ compare =README= with branch head

- *Git Diff in an External Tool*
  * If you want to view the differences in diff viewing program, use ~git
    difftool~ instead.

  * Run ~git difftool --tool-help~ to see what is available on your system.

*** DONE Committing Your Changes - 36
CLOSED: [2019-05-21 Tue 17:11]
- Command:
  * ~git commit~:
    usually open the editor ~git config --global core.editor~, and you can
    type the commit message inside it. You will see it automatically put the
    change info in the comment. You can keep it or delete it.

  * ~git commit -v~:
    Just like the command above, but in verbose mode -- the comment includes
    more info like the diff result.

  * ~git commit -m~:
    Do not open editor, and provide a inline message that follows the ~-m~
    parameter.

- After committing, you'll see an SHA-1 checksum.
  =TODO= SHA-1???

*** DONE Skipping the Staging Area - 37
CLOSED: [2019-05-21 Tue 17:23]
You can use a ~-a~ option when you work with ~git commit~ command, and
_AUTOMATICALLY /stage/ EVERY file that is already tracked_ before doing the
commit.
For instance, ~git commit -a -m 'added new benchmarks~

This is convenient, but it can also mass up your commit if you don't pay
enough attension or overuse it.

*** DONE Removing Files - 38
CLOSED: [2019-08-18 Sun 00:11]
~git rm~
- If you delete a file with using ~git rm~,
  ~git stauts~ will tell you =Changes not staged for commit=
  * To stage it, you need use ~git rm <filename>~ again, even if you can't
    see the deleted file(s) in your repo.

  * If you use ~git rm~ from the very beginning, you need need to run
    ~rm <filename>~ followed by ~git rm <filename>~.

- After running ~git rm <filename>~, the next time you commit, the file will
  be gone and no longer tracked.

- ~git rm -f~
  If you _modified the file_ or _had already added it to the staging area_,
  you *MUST FORCE* the removal with the ~-f~ option.
  * Rationale:
    This is a *safety feature* to PREVENT
    _accidental removal of data that hasn't yet been recorded in a snapshot
    and that can't be recovered from Git._

- ~git rm --cached~ remove file(s) from your /staging area/ but keep the file(s)
  in your working tree -- no longer track it.
  * This is particularly useful if you forgot to add something to your
    =.gitignore= file and accidentally staged it.

- With file-glob patterns:
  ~git rm log/\*.log~
  The backslash (~\~) here is used to escape the ~*~ to stop doing shell
  expansion, and pass ~*~ to git, who has its own expansion.
  * =from Jian=
    Shell expansion also works. However, since I don't know the differences,
    and I believe let git to all the operations it can do is good for
    version control.

*** DONE Moving Files - 39
CLOSED: [2019-08-17 Sat 22:01]
- _UNLIKE_ many other VCS systems,
  Git does *NOT explicitly track* file movement.

- If you rename a file in Git, no metadata is stored in Git that tells it you
  renamed the file.
    However, _Git is pretty smart about figuring that out after the fact_ --
  TODO we'll deal with detecting file movement a bit later.

- Git has a ~mv~ command. For example,
  #+begin_src bash
    git mv README.md README
  #+end_src
  Then, run ~git status~ and you'll see:
  #+begin_src text
    On branch master
    Your branch is up-to-date with 'origin/master'.
    Changes to be committed:
      (use "git reset HEAD <file>..." to unstage)

        renamed:    README.md -> README
  #+end_src

- Git has a ~mv~ command (e.g. ~git mv README.md README~), which is equivalent
  to running something like:
  #+begin_src bash
    mv README.md README  # Or any other ways, like in GUI, you can use to rename a file
    git rm README.md
    git add README
  #+end_src
  * _The only real difference is that ~git mv~ is one command instead of three._

  * The three commands way is still useful:
    you can use any tool you like to rename (shell's ~mv~, GUI, etc.) a file,
    and address the add/rm (~git add~ and ~git rm~) later, before you commit.

** DONE 2.3 Viewing the Commit History - 40
CLOSED: [2019-11-23 Sat 18:27]
- ~git log~

- ~git log -p~ / ~git log --patch~
  Use ~-<number>~ to limit the number of commits you want to log
  Display in patch-like view

- ~git log --stat~
  Like ~--patch~, but only one statics line per file, without details of
  difference

- ~git log --pretty=<format>~
  * ~oneline~

  * ~format:<format-string>~
    Example: ~git log --pretty=format:"%h - %an, %ar : %s"~

  * Table1. Useful options for ~git log --pretty=format~
    TODO TODO TODO

- Distinguish /author/ and /committer/:
  * Author :: the person who originally wrote the work,
  * Committer :: the person who last applied the work.

- So, if you send in a patch to a project and one of the core members applies
  the patch, both of you get credit — _you as the /author/, and the core
  member as the /committer/._

- Another useful option ~--graph~

- Table 2. Common options to ~git log~
  TODO TODO TODO

*** DONE Limiting Log Output - 44
CLOSED: [2019-11-23 Sat 18:27]
- ~-<n>~

- ~--since~ and ~--until~
  Example: ~git log --since=2.weeks~
  These options can work with lots of formats like ~"2018-01-15"~ or
  ~"2 years 1 day 3 minutes ago"~

- Use ~--author~ to filter on a specific /author/.
  Use ~--committer~ to filter on a specific /comitter/.

- Use ~--grep~ to search for keywords in the commit messages.

- Use ~--all-match~ option to further limit the output to just those commits
  that match *all* ~--grep~ patterns.

- ~-S~ only show commits adding or removing code match the string.
  For example, ~git log -S function_name~
  * *CAUTION* TODO TODO TODO
    This is _ALWAYS_ the last option and is generally preceded by double
    dashes (~--~) to _separate the paths from the options_.

- *Preventing the display of merge commits*
  Use ~--no-merges~

** DONE 2.4 Undoing Things - 46
CLOSED: [2019-11-23 Sat 18:55]
- *CAUTION*:
  Sometimes, undoing things can be _DANGEOUS_ -- you *can't* always undo some
  of these undos!
  *This is the one of the few areas in Git where you may lose some work if
  you do it wrong*

- ~git commit --amend~
  * If you use this command, the latest commit will be replaced --
    it looks like the commit before _amend_ never happened.

  * Only amend commits that are still local and have not been pushed somewhere.
    + =TODO=
      For more on what happens when you do this and how to recover if you’re
      on the receiving end READ *The Perils of Rebasing.*

  * =from Jian= =IMPORTANT= *I think it's better not do this*
    + A better way:
      1. Create more commits
      2. Later, combine them and re-commit.
         - Combine n commits by using ~rebase -i HEAD~n~.

    + Use this way, you can have more time to do a fully consideration before
      combining and re-committing.

    + Mostly, I prefer to only do two things with ~git commit --amend~:
      - Only fix or improve the latest commit message.
      - Add new changes to the latest commit only when you are 120% sure you
        are right.

*** DONE Unstaging a Staged File - 47
CLOSED: [2021-04-01 Thu 02:57]
- Unstage a file with ~git reset HEAD <file>~
  Acutally, after staging files with ~git add~, when you run ~git status~,
  there will be a hint message that =(use "git reset HEAD <file> ...") to unstage)=.
  * From Git 2.23.0 on,
    the hint message =(use "git reset HEAD <file> ...") to unstage)=
    becomes =(use "git restore --staged <file>..." to unstage)=
    + =from Jian=
      Since ~git restore~ is dangerous, though ~git restore --staged~ is safe,
      _I prefer to create an /alias/ ~git unstage~ for ~git restore --staged~._
      =IMPORTANT=

- *TIPS*
  It's true that ~git reset~ _CAN BE a *dangerous* command_, especially if you
  provide the ~--hard~ flag.
    _HOWEVER_, in the scenario described above, the file in your working
  directory is not touched (=from Jian= change the staged status of a file
  won't touch its content), so it's relatively safe.

*** DONE Unmodifying a Modified File - 48
CLOSED: [2021-04-01 Thu 03:05]
- ~git checkout -- <file>~

- ~git status~ can also give hits about this like:
  After doing some changes to a repo, and run ~git status~
  #+begin_src text
    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git checkout -- <file>..." to discard changes in working directory)
  #+end_src

- *CAUTION*:
  ~git checkout -- <file>~ is *DANGEROUS*.
  Any local changes you made to that file are gone -- _Git just replaced that
  file with the most recently-committed version._
  *Don't ever use this command unless you absolutely know that you don't want
  those unsaved local changes.*

  * =from Jian= To avoid this,
    + Solution 1:
      Add a hook for this command with reminder

    + Solution 2: =from Jian= I prefer this!!!
      Add a hook for this command without reminder, but implicitly
      create a branch with snapshot before this command.

    + Solution 3:
      Manually create a branch with snapshot before this command, and then
      switch back and run this command.

  * =from Jian=
    I prefer Solution 2, and we should add hooks to all the dangerous
    commands!!! =TODO= =TODO= =TODO=

- *Remember*: =IMPORTANT=
  * _Anything that is committed in Git can almost always be recovered._
    Even commits that were on branches that were deleted or commits that
    were overwritten with an ~--amend~ commit can be recovered (see Data
    Recovery for data recovery). =TODO= _HOWTO ???_ =TODO=

  * However, _anything you lose that was never committed is likely never to be
    seen again._

*** DONE Undoing things with ~git restore~ - 49
CLOSED: [2021-04-01 Thu 03:15]
For Git version 2.23.0+.

- ~git restore~ is an alternative to ~git reset~.
  Should use ~git restore~ instead of ~git reset~ for many undo operations.

**** DONE Unstaging a Staged File with ~git restore~ - 49
CLOSED: [2021-04-01 Thu 03:10]
When you use _Git version 2.23.0+_, ~git status~ can hint you when to use
~git restore~ (here it is actually ~git restore --staged~, which is used to
*unstage* files). This new hint message replaced the old one that tells
you to use ~git reset HEAD~.

**** DONE Unmodifying a Modified File with ~git restore~ - 50
CLOSED: [2021-04-01 Thu 03:15]
~git restore~ can be an alternative to ~git checkout -- <file>~.

- *CAUTION*
  ~git restore -- <file>~ is a dangerous command, just like
  ~git checkout -- <file>~, though ~git restore --staged~ is safe.

** DONE 2.5 Working with Remotes - 50
CLOSED: [2021-04-09 Fri 03:20]
To be able to _collaborate on any Git project_, you need to know how to manage
your /remote repositories/.

- You can have _several_ of them, with the permission read-only or read/write.

- Managing /remote repositories/ includes knowing HOW TO
  * *add* /remote repositories/
  * *remove* /remote repositories/
  * *manage* various /remote branches/ and
    *define* them as being tracked or not
  * and more

- NOTE:
  *Remote repositories can be on your local machine.*
  =HOW TO create a LOCAL remote repositories???=

*** DONE Showing Your Remotes - 51
CLOSED: [2021-04-08 Thu 10:56]
- Use ~git remote~ to show which _remote servers_ you have configured.

- If you've cloned your repository, you should at least see /origin/ — that
  is *the default name Git gives to the server you cloned from*.
  #+begin_src bash
    git remote
    # origin
  #+end_src

- Use ~git remote -v~ to show which _remote servers_ you have configured,
  with their URLs.
  * One remote:
    #+begin_src bash
      git remote -v
      # origin https://github.com/schacon/ticgit (fetch)
      # origin https://github.com/schacon/ticgit (push)
    #+end_src

  * Multiple remotes:
    #+begin_src bash
      git remote -v
      # bakkdoor https://github.com/bakkdoor/grit (fetch)
      # bakkdoor https://github.com/bakkdoor/grit (push)
      # cho45 https://github.com/cho45/grit (fetch)
      # cho45 https://github.com/cho45/grit (push)
      # defunkt https://github.com/defunkt/grit (fetch)
      # defunkt https://github.com/defunkt/grit (push)
      # koke git://github.com/koke/grit.git (fetch)
      # koke git://github.com/koke/grit.git (push)
      # origin git@github.com:mojombo/grit.git (fetch)
      # origin git@github.com:mojombo/grit.git (push)
    #+end_src
    + Notice that these remotes use a VARIETY of _protocols_;
      =TODO= we’ll cover more about this in _Getting Git on a Server_.

*** DONE Adding Remote Repositories - 52
CLOSED: [2021-04-08 Thu 11:07]
- ~git clone~ command implicitly adds the =origin= remote for you.

- To add a new remote use the command pattern:
  ~git remote add <shortname> <url>~

*** DONE Fetching and Pulling from Your Remotes - 52
CLOSED: [2021-04-09 Fri 02:47]
After *adding* a /remote/, you can then use ~git fetch <remote>~ to fetch the
info of the =<remote>=.

- ~git fetch <remote>~
  1. goes out to that =remote= project and *pulls* down all the data
     from that remote project _that you don't have yet._
  2. After you do this,
     _you should have references to all the branches from that =remote=,
     which you can merge in or inspect at any time._

- If you clone a repository, the command automatically adds that /remote
  repository/ under the name *“origin”*.

- ~git fetch origin~ fetches any new work that has been pushed to that
  server _since_ you cloned (or last fetched from) it.

- The ~git fetch~ command only downloads data to your local repository --
  it *doesn't automatically merge it* with any of your work or modify what
  you're currently working on.
  * There is a way to make this merge automatic (with ~git pull~)
    Set up to *track* a /remote branch/.
    + CAUTION:
      merge may fail if there is confliction.

- If your _CURRENT branch_ is set up to *track* a /remote branch/ (=TODO= see
  the next section and _Git Branching_ for more information), you can use the
  ~git pull~ command to automatically *fetch and then merge* that /remote
  branch/ into your _CURRENT branch_.
  * By default,
    the ~git clone~ command *automatically sets up* your _LOCAL MASTER branch_
    to *track* the _remote MASTER branch_ (or whatever the DEFAULT BRANCH is
    called) on the server you cloned from.

- NOTE:
  _From git version 2.27 onward_,
  ~git pull~ will give a warning if the ~pull.rebase~ variable is not set.

  * ~git~ will keep warning you until you set the variable.

  * If you want the default behavior of git:
    ~git config --global pull.rebase "false"~

  * If you want to rebase when pulling:
    ~git config --global pull.rebase "true"~

  * =from Jian=
    =TODO=
    =TODO=
    =TODO=
    I'm not sure the relationship, but
    I usually set ~git config pull.ff only~.

*** DONE Pushing to Your Remotes - 53
CLOSED: [2021-04-09 Fri 02:54]
~git push <remote> <branch>~

- For example,
  push your ~master~ branch to your ~origin~ server with
  ~git push origin master~. Of course, you must have the write permission.
  * You can do this directly becase the tracking is already set up.
    =from Jian=
    If not,
    for example, you have a local branch that is never pushed to the remote
    repository, and assume the remote here is ~origin~,
    you need to do something similar to
    ~git push --set-upstream origin <branch>~.

- If you and someone else clone at the same time and they push upstream and
  then you push upstream, your push will rightly be rejected.
    You'll have to fetch their work first and incorporate it into yours
  before you'll be allowed to push.
  =TODO= See _Git Branching_ for more detailed info on how to push to remote
  servers.

- =TODO=
  =IMPORTANT=
  =from Jian=
  Need a hook to forbid pushing to remote ~master~ directly.

*** DONE Inspecting a Remote - 53
CLOSED: [2021-04-09 Fri 03:18]
~git remote show <remote>~

- Simple Example:
  #+begin_src bash
    git remote show origin
    # * remote origin
    # Fetch URL: https://github.com/schacon/ticgit
    # Push  URL: https://github.com/schacon/ticgit
    # HEAD branch: master
    # Remote branches:
    #   master                              tracked
    #   dev-branch                          tracked
    # Local branch configured for 'git pull':
    #   master merges with remote master
    # Local ref configured for 'git push':
    #   master pushes to master (up to date)
  #+end_src
  * It lists
    + _the URL for the remote repository_ as well as
    + _the tracking branch information_.
      - Which local branch(es) is/are tracked.
      - Your current branch, and
        when ~git pull~ and ~git push~ in your current branch, what will
        happen.

- Example:
  #+begin_src bash
    git remote show origin
    # * remote origin
    # URL: https://github.com/my-org/complex-project
    # Fetch URL: https://github.com/my-org/complex-project
    # Push  URL: https://github.com/my-org/complex-project
    # HEAD branch: master
    # Remote branches:
    #   master                           tracked
    #   dev-branch                       tracked
    #   markdown-strip                   tracked
    #   issue-43                         new (next fetch will store in remotes/origin)
    #   issue-45                         new (next fetch will store in remotes/origin)
    #   refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)
    # Local branches configured for 'git pull':
    #   dev-branch merges with remote dev-branch
    #   master     merges with remote master
    # Local refs configured for 'git push':
    #   dev-branch                     pushes to dev-branch (up to date)
    #   markdown-strip                 pushes to markdown-strip (up to date)
    #   master                         pushes to master (up to date)
  #+end_src
  This is a example you may see similar in you day to day developemnt.
  It includes more info, and you can see:
  * Some branches (the _new_ ones) are only in your local, and they are never
    pushed to remote.

  * One branch (the _stale_) that was in remote, but it is already remove
    from remote .
    It also tell you how to remove that branch also from you local.
    + =from Jian=
      From the official document of _git-remote_:
      ~git remote prune~ may also remove tags that are never pushed to remote.
      Delete not pushed tags or not depends on configurations.

  * Multiple _local branches_ that are able to merge automatically with their
    _remote-tracking branch_ when you run ~git pull~.

*** DONE Renaming and Removing Remotes - 54
CLOSED: [2021-04-09 Fri 03:02]
- Rename:
  For example,
  #+begin_src bash
    git remote rename pb paul

    git remote
    # origin
    # paul
  #+end_src
  It's worth mentioning that this *changes* all your _remote-tracking branch
  names_, too. What used to be referenced at ~pb/master~ is now at ~paul/master~.
  =from Jian= This change is very reasonable!!!

- Remove:
  For example,
  #+begin_src bash
    git remote remove paul  # or use `rm` for short, instead of `remove`

    git remote
    # origin
  #+end_src
  Once you delete the _reference to a remote_ this way,
  *all*
  /remote-tracking branches/ and
  _configuration settings associated with that remote_
  are also deleted.

** DONE 2.6 Tagging - 55
CLOSED: [2021-04-15 Thu 22:13]
Like most VCSs, Git has the ability to _tag specific points in a repository's
history_ as being important.

- Typically, people use this functionality to *MARK* /release points/
  (v1.0, v2.0 and so on).

- In this section, you'll learn
  * how to *list* existing tags,
  * how to *create* and *delete* tags, and
  * what the _different types_ of tags are.

*** DONE Listing Your Tags - 55
CLOSED: [2021-04-14 Wed 13:43]
- List all tags in alphabetical order with
  ~git tag~, ~git tag -l~, and ~git tag --list~.

- List tags with a specific pattern.
  For example, ~git tag -l "v1.8.5*~

*** DONE Creating Tags - 56
CLOSED: [2021-04-14 Wed 13:56]
- Git supports _TWO_ types of /tags/:
  * ligtweight:
    it much like a /branch/ that doesn't change -- it's just a pointer to a
    specific commit.


  * annotated:
    + it is stored AS *full objects* in the Git database.
      They're
      - checksummed;
      - contain the tagger name, email, and date;
      - have a tagging message; and
      - can be signed and verified with GNU Privacy Guard (GPG).

    + *It's generally recommended that you create /annotated tags/*
      so you can have all this information;

    + _BUT_ if
      you want a temporary tag or
      for some reason don't want to keep the other information,
      /lightweight tags/ are available too.

*** DONE Annotated Tags - 56
CLOSED: [2021-04-14 Wed 14:29]
~git tag -a v1.4 -m "my version 1.4"~

- It's like ~git commit~, if no ~-m~, an editor will be launched.

- You can see the _tag data_ along with the commit that was tagged by using the
  ~git show~ command.
  * For example,
    ~git show v1.4~
    #+begin_src text
      tag v1.4
      Tagger: Ben Straub <ben@straub.cc>
      Date:   Sat May 3 20:19:12 2014 -0700

      my version 1.4

      commit ca82a6dff817ec66f44342007202690a93763949
      Author: Scott Chacon <schacon@gee-mail.com>
      Date:   Mon Mar 17 21:52:11 2008 -0700

          Change version number
    #+end_src
    This shows
    + the tagger information,
    + the date the commit was tagged, and
    + the annotation message *before* showing the commit information.

*** DONE Lightweight Tags - 57
CLOSED: [2021-04-14 Wed 15:37]
~git tag v1.4-lw~
This is basically the commit checksum stored in a file.

- Output:
  ~git show v1.4-lw~
  #+begin_src text
    commit ca82a6dff817ec66f44342007202690a93763949
    Author: Scott Chacon <schacon@gee-mail.com>
    Date:   Mon Mar 17 21:52:11 2008 -0700

        Change version number
  #+end_src

*** DONE Tagging Later - 57
CLOSED: [2021-04-14 Wed 15:50]
You can also *tag* commits *AFTER* you've moved past them.

- Suppose your commit history looks like this:
  #+begin_src bash
    git log --pretty=oneline
    # 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'
    # a6b4c97498bd301d84096da251c98a07c7723e65 Create write support
    # 0d52aaab4479697da7686c15f77a3d64d9165190 One more thing
    # 6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'
    # 0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc Add commit function
    # 4682c3261057305bdd616e23b64b0857d832627b Add todo file
    # 166ae0c4d3f420721acbb115cc33848dfcc2121a Create write support
    # 9fceb02d0ae598e95dc970b74767f19372d61af8 Update rakefile
    # 964f16d36dfccde844893cac5b347e7b3d44abbc Commit the todo
    # 8a5cbc430f1a9c3d00faaeffd07798508422908a Update readme
  #+end_src

- Add the _v1.2_ to the commit ="Update rakefile"=:
  ~git tag -a v1.2 9fceb02~

*** DONE Sharing Tags - 58
CLOSED: [2021-04-15 Thu 12:59]
*By default*, the ~git push~ command doesn't transfer /tags/ to _remote
servers_.

- You will have to *explicitly push* /tags/.
    This process is just like sharing _remote branches_ — you can run
  ~git push origin <tagname>~.

- If you have _a lot of_ /tags/ that you _want to push up AT ONCE_,
  you can also use the ~--tags~ option to the ~git push~ command.
  This will _transfer all of your /tags/ to the remote server that are not
  already there._
  ~git push origin --tags~

- Tips:
  ~git push~ pushes _both types of tags_.
  * ~git push <remote> --tags~ will push BOTH /lightweight and annotated tags/
  * There is currently *no option* to push _ONLY_ /lightweight tags/
  * Use ~git push <remote> --follow-tags~ _ONLY_ /annotated tags/ will be
    pushed to the remote.

*** DONE Deleting Tags - 59
CLOSED: [2021-04-15 Thu 22:12]
- Delete a /tag/ in local:
  ~git tag -d <tag-name>~
  This does *NOT* remove the /tag/ from any _remote servers_.

- _TWO_ common variations for deleting a /tag/ from a _remote server_:
  * ~git push origin :refs/tags/v1.4-w~
    Interpret the above is to read it as the null value _before_ the colon
    is being pushed to the _remote tag_ name, effectively deleting it.

  * ~git push origin --delete v1.4-w~
    This is a more intuitive one.

*** DONE Checking out Tags - 60
CLOSED: [2021-04-14 Wed 16:29]
If you want to view the versions of files a tag is pointing to, you can do a
~git checkout~ of that tag.

- Simply, ~git checkout <tag>~ will puts your repository in “detached HEAD”
  state, which has some *ill side effects*:
  #+begin_src bash
    git checkout v2.0.0
    # Note: switching to 'v2.0.0'.
    #
    # You are in 'detached HEAD' state. You can look around, make experimental
    # changes and commit them, and you can discard any commits you make in this
    # state without impacting any branches by performing another checkout.
    #
    # If you want to create a new branch to retain commits you create, you may
    # do so (now or later) by using -c with the switch command. Example:
    #
    #   git switch -c <new-branch-name>
    #
    # Or undo this operation with:
    #
    #    git switch -
    #
    #    Turn off this advice by setting config variable advice.detachedHead to false
    #
    #    HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final

    git checkout v2.0-beta-0.1
    # Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendixfinal
    # HEAD is now at df3f601... Add atlas.json and cover image
  #+end_src

- In “detached HEAD” state,
  IF you _make changes_ and then _create a commit_, the *tag will stay the SAME*,
  BUT your new commit *won't belong to any branch* and
  *will be unreachable, EXCEPT by the exact commit hash.*
  * Thus, if you need to make changes — say you're fixing a bug on an older
    version, for instance — you will generally want to *create a branch*:
    #+begin_src bash
      git switch -c version2 v2.0.0
      # Switched to a new branch 'version2'
    #+end_src
    + If you edit a file, commit, and then ~git log~, you'll see
      =Example code from Jian=
      #+begin_src text
        * c9f1b37 - (HEAD -> version1) Edit based on tag v2.0.0 (4 seconds ago) <Lan, Jian>
        * efed8c6 - (tag: v2.0.0) 2 (3 minutes ago) <Lan, Jian>
        * efed8c6 - 1 (5 minutes ago) <Lan, Jian>
        * 8c3a469 - 0 (6 minutes ago) <Lan, Jian>
        * fda1e5e - init (11 minutes ago) <Lan, Jian>
      #+end_src
      The tag stay still, and it won't follow the HEAD of the current branch.

** DONE 2.7 Git Aliases - 60
CLOSED: [2019-08-19 Mon 02:11]
- Create shorter name alias for exist commands
  * Command:
    #+begin_src shell
      $ git config --global alias.co checkout
      $ git config --global alias.br branch
      $ git config --global alias.ci commit
      $ git config --global alias.st status
    #+end_src

  * =.gitconfig= file:
    #+begin_src text
      [alias]
        co = checkout
        br = branch
        ci = commit
        st = status
    #+end_src

- Create alias for commands with options
  ~git config --global alias.unstage 'reset HEAD --'~

- A useful command -- show the lastest commit log:
  ~git config --global alias.last 'log -1 HEAD'~

- Create a alias for external command -- prefix with ~!~:
  ~git config --global alias.visual '!gitk'~
  * Usage:
    ~git visual~

  * Actual external command:
    ~gitk~

** DONE 2.8 Summary - 62
CLOSED: [2019-08-19 Mon 01:59]

* TODO 3. Git Branching - 63
- Nearly every VCS has some form of branching support.

- _Many of their /branching/ is EXPENSIVE._

- One of the "killer feature" of Git is that it branches is incredibly
  _lightweight_.

- Git *ENOURAGES* workflows that /branch/ and /merge/ *often*.

** TODO 3.1 Branches in a Nutshell - 63 - =RE-READ= =NOTE=
   - Review _how Git stores its data_ (in the "What is Git?" section):
     Git *doesn't* store data as a series of changesets or _differences_,
     *BUT instead* as a series of _snapshots_.

   - When you make a /commit/, Git *stores* a /commit object/ that contains a
     pointer to the snapshot of the content you staged.
     * This object also contains the
       + _author's name_
       + _email address_
       + _the message that you typed_
       + _pointers to the commit or commits_ that directly came before this commit
         (its parent or parents):
         _ZERO parents_ for the initial commit, =FIXME= should be _zero parent_
         _ONE parent_ for a normal commit, and
         _MULTIPLE parents_ for a commit that results from a merge of two or
         more branches.

   - To visualize this, let’s assume that you have a directory containing three
     files, and you stage them all and commit. Staging the files computes a checksum
     for each one (the SHA-1 hash we mentioned in What is Git?), stores that version
     of the file in the Git repository (Git refers to them as blobs), and adds
     that checksum to the staging area:
     #+begin_src bash
       git add READ test.rb LICENSE
       git commit -m 'Initial commit'
     #+end_src

   - =TODO= NOTE
   - =TODO= NOTE
   - =TODO= NOTE
   - =TODO= NOTE
   - =TODO= NOTE
   - =TODO= NOTE
   - =TODO= NOTE

*** DONE Creating a New Branch - 65
    CLOSED: [2021-04-15 Thu 23:05]
    ~git branch <branch-name>~

    - Q :: How does Git know what /branch/ *you're currently on*?
    - A :: It keeps a special pointer called ~HEAD~.

    - Assume you are on ~master~ ~HEAD~, and run ~git branch testing~.
      Then
      * you have a new branch ~testing~.
      * you are still on ~master~, and the ~HEAD~ point on the latest commit of
        ~master~.

    - ~--decorate~
      =from Jian=
      I think we don't need to add this.
      It seems _by default_ the ~--decorate=short~ is already there.

*** DONE Switching Branches - 66
    CLOSED: [2021-04-15 Thu 23:42]
    ~git checkout <branch-name>~ or (experimental) ~git switch <branch-name>~.

    - Run the switch branch command, and after then the ~HEAD~ points to the
      corresponding branch's latest commit.

    - ~git log~ does _NOT_ show all the branches all the time
      * Run ~git checkout master~, and then run ~git log~, you can't see the
        ~testing~ branch.

      * Git just doesn't know that you're interested in that /branch/ and it is
        trying to show you what it thinks you're interested in.
        + In other words, _BY DEFAULT_,
          ~git log~ will only show commit history *below* the /branch/ you've
          checked out.

      * To show commit history for the _desired_ /branch/ you have to explicitly
        specify it: ~git log testing~.

      * To show all of the /branches/, add ~--all~ to your ~git log~ command.

    - That command did _two_ things --
      * it moved the ~HEAD~ pointer back to point to the ~master~ /branch/, and

      * it reverted the files in your _working directory_ back to the snapshot
        that ~master~ points to.

    - If Git cannot switch it cleanly, it will not let you switch at all.
      * For example,
        if a file need to be reverted in this switch, but it is edited and not
        commited. Then this switch can't be performed.

    - If you run ~git log --oneline --decorate --graph --all~ it will
      print out the history of your commits, showing
      #+begin_src bash
        git log --oneline --decorate --graph --all
        # * c2b9e (HEAD, master) Made other changes
        # | * 87ab2 (testing) Made a change
        # |/
        # * f30ab Add feature #32 - ability to add new formats to the central interface
        # * 34ac2 Fix bug #1328 - stack overflow under certain conditions
        # * 98ca9 initial commit of my project
      #+end_src
      * WHERE your /branch/ pointers are and
      * HOW your history has _diverged_.

    - _BECAUSE_ a /branch/ in Git is actually _a simple file that contains the 40
      character SHA-1 checksum of the commit it points to_, /branches/ are cheap
      to create and destroy.
      * Creating a NEW /branch/
        is AS QUICK AND SIMPLE AS
        *writing 41 bytes to a file (40 characters and a newline).*

    - This is in sharp contrast to the way most older VCS tools branch, which
      involves copying all of the project’s files into a second directory.

      * Also, because we're recording the parents when we commit, finding a
        proper merge base for merging is automatically done for us and is
        generally very easy to do.

      * These features help _ENCOURAGE_ developers to
        *create* and *use* /branches/ often.

    - *Creating a new branch and switching to it at the same time*
      ~git checkout -b <newbranchname>~.

    - *From Git version 2.23 onwards you can use ~git switch~ instead of
       ~git checkout~ to:*
      * Switch to an existing branch: ~git switch testing-branch~.

      * Create a new branch and switch to it: ~git switch -c new-branch~.
        The ~-c~ flag stands for _create_, you can also use the full flag:
        ~--create~.

      * Return to your *previously* checked out branch: ~git switch -~.

** TODO 3.2 Basic Branching and Merging - 70
*** TODO Basic Branching - 70 - =NOTE=
*** TODO Basic Merging - 75 - =NOTE=
*** TODO Basic Merge Conflicts - 76

** DONE 3.3 Branch Management - 79
   CLOSED: [2021-04-17 Sat 00:34]
   Already learned how to _create_, _merged_, and _delete_ /branches/.
   Now let's look at some *branch-management tools*.

   - ~git branch~
     #+begin_src text
         iss53
       * master
         testing
     #+end_src

   - ~git branch -v~
     #+begin_src text
         iss53 93b412c Fix javascript issue
       * master 7a98805 Merge branch 'iss53'
         testing 782fd34 Add scott to the author list in the readme
     #+end_src

   - If apply ~git branch -d <branch-name>~ to a _not merged branch_,
     it will fail. Use ~-D~ can delete it, which is acutally ~--delete --force~.

   - TIPs:
     ~git branch --merged~ and ~git branch --no-merged~
     can be used to filter and list corresponding branches.

     * If no given _commit_ or _branch name_ as an argument,
       it will show you what is, respectively, _merged_ or _not merged_ into your
       _CURRENT branch_.

     * You can always provide an additional argument to ask about the _merge state_
       with respect to some other /branch/ *without checking* that other /branch/
       out first, as in, what is not merged into the ~master~ branch.
       #+begin_src bash
         git checkout testing
         git branch --no-merged master
         # topicA
         # featureB
       #+end_src

*** DONE Changing a branch name - 80
    CLOSED: [2021-04-17 Sat 00:34]
    - *CAUTION*
      * _Do not_ rename branches that are still in use by other collaborators.

      * _Do not_ rename a branch like ~master~ / ~main~ / ~mainline~ without
        having read _the section "Changing the master branch name"._
        =TODO=

    - Rename a local branch:
      ~git branch --move <bad-branch-name> <correct-branch-name>~

    - Rename a local branch and push it to remote:
      1. ~git branch --move <bad-branch-name> <correct-branch-name>~
      2. ~git push --set-upstream origin <correct-branch-name>~
      3. ~git push origin --delete <bad-branch-name>~

**** DONE Changing the ~master~ branch name - 83
     CLOSED: [2021-04-17 Sat 00:34]
     - *CAUTION*
       Changing the name of a branch like ~master~ / ~main~ / ~mainline~ / ~default~
       will *break* the _integrations_, _services_, _helper utilities_ and
       _build/release scripts_ that your repository uses.
         Before you do this, make sure you consult with your collaborators.
       Also, make sure you do a thorough search through your repo and update any
       references to the old branch name in your code and scripts.

     - Rename your local ~master~ branch into ~main~ with the following command:
       1. ~git branch --move master main~

       2. ~git push --set-upstream origin main~ if required to push to remote

       3. Check the current branches:
          #+begin_src bash
            git branch --all
            # * main
            #   remotes/origin/HEAD -> origin/master
            #   remotes/origin/main
            #   remotes/origin/master
          #+end_src

       4. Before delete the remote ~master~, you need to check
          * Any projects that depend on this one will need to update their code
            and/or configuration.
          * Update any test-runner configuration files.
          * Adjust build and release scripts.
          * Redirect settings on your repo host for things like the repo's
            default branch, merge rules, and other things that match branch names.
          * Update references to the old branch in documentation.
          * Close or merge any pull requests that target the old branch.

       5. Finally,
          ~git push origin --delete mastr~

** TODO 3.4 Branching Workflows - 82
*** TODO Long-Running Branches - 83
*** TODO Topic Branches - 84

** TODO 3.5 Remote Branches - 85
*** TODO Pushing - 91
*** TODO Tracking Branches - 92
*** TODO Pulling - 94
*** TODO Deleting Remote Branches - 94

** TODO 3.6 Rebasing - 95
*** TODO The Basic Rebase - 95
*** TODO More Interesting Rebases - 97
*** TODO The Perils of Rebasing - 100
*** TODO Rebase When You Rebase - 102
*** TODO Rebase vs. Merge - 103

** TODO 3.7 Summary - 104

* ^^^^^^^^^^^^ PAGE NUMBER UPDATED -------
* TODO 4. Git on the Server - 105
** TODO 4.1 The Protocols - 107
*** TODO Local Protocol - 107
**** The Pros - 108
**** The Cons - 108

*** TODO The HTTP Protocol - 109
**** Smart HTTP - 109
**** Dumb HTTP - 109
***** The Pros - 110
***** The Cons - 110

*** TODO The SSH Protocol - 110
**** The Pros - 111
**** The Cons - 111

*** TODO The Git Protocol - 111
**** The Pros - 111
**** The Cons - 111

** TODO 4.2 Getting Git on a Server - 112
*** TODO Putting the Bare Repository on a Server - 112
*** TODO Small Setups - 113
**** TODO SSH Access - 113

** TODO 4.3 Generating Your SSH Public Key - 114
** TODO 4.4 Setting Up the Server - 115
** TODO 4.5 Git Daemon - 118
** TODO 4.6 Smart HTTP - 119
** TODO 4.7 GitWeb - 121
** TODO 4.8 GitLab - 123
*** TODO Installation - 123
*** TODO Administration - 123
**** TODO Users - 124
**** TODO Groups - 124
**** TODO Projects - 125
**** TODO Hooks - 125

*** TODO Basic Usage - 125
*** TODO Working Together - 126

** TODO 4.9 Third Party Hosted Options - 126
** TODO 4.10 Summary - 127

* TODO 5. Distributed Git - 126
** TODO 5.1 Distributed Workflows - 128
*** TODO Centralized Workflow - 128
*** TODO Integration-Manager Workflow - 129
*** TODO Dictator and Lieutenants Workflow - 130
*** TODO Patterns for Managing Source Code Branches - 130
*** TODO Workflows Summary - 131

** TODO 5.2 Contributing to a Project - 131
*** TODO Commit Guidelines - 132
*** TODO Private Small Team - 133
*** TODO Private Managed Team - 140
*** TODO Forked Public Project - 146
*** TODO Public Project over Email - 150
*** TODO Summary - 153

** TODO 5.3 Maintaining a Project - 153
*** TODO Working in Topic Branches - 154
*** TODO Applying Patches from Email - 154
**** Applying a Patch with ~apply~ - 154
**** Applying a Patch with ~am~ - 155

*** TODO Checking Out Remote Branches - 157
*** TODO Determining What Is Introduced - 158
*** TODO Integrating Contributed Work - 159
**** Merging Workflows - 160
**** Large-Merging Workflows - 162
**** Rebasing and Cherry-Picking Workflows - 163
**** Rerere - 165

*** TODO Tagging Your Releases - 165
*** TODO Generating a Build Number - 166
*** TODO Preparing a Release - 167
*** TODO The Shortlog - 167

** TODO 5.4 Summary - 168

* TODO 6. GitHub - 166
** TODO 6.1 Account Setup and Configuration - 169
*** TODO SSH Access - 170
*** TODO Your Avatar - 171
*** TODO Your Email Address - 173
*** TODO Two Factor Authentication - 173

** TODO 6.2 Contributing to a Project - 174
*** TODO Forking Projects - 174
*** TODO The GitHub Flow - 175
**** TODO Creating a Pull Request - 175
**** TODO Iterating on a Pull Request - 179

*** TODO Advanced Pull Requests - 183
**** Pull Requests as Patches - 183
**** Keeping up with Upstream - 183
**** References - 186
**** GitHub Flavored Markdown - 188
***** Task Lists - 189
***** Code Snippets - 190
***** Quoting - 190
***** Emoji - 191
***** Images - 192

**** Keep your GitHub public repository up-to-date - 193

** TODO 6.3 Maintaining a Project - 194
*** TODO Creating a New Repository - 194
*** TODO Adding Collaborators - 196
*** TODO Managing Pull Requests - 197
**** Email Notifications - 198
**** Collaborating on the Pull Request - 199
**** Pull Request Refs - 200
**** Pull Requests on Pull Requests - 202

*** TODO Mentions and Notifications - 203
**** The Notifications Page - 204
***** Web Notifications - 205
***** Email Notifications - 206

*** TODO Special Files - 206
**** README - 207
**** CONTRIBUTING - 207

*** TODO Project Administration - 207
**** Changing the Default Branch - 208
**** Transferring a Project - 208

** TODO 6.4 Managing an organization - 209
*** TODO Organization Basics - 209
*** TODO Teams - 209
*** TODO Audit Log - 211

** TODO 6.5 Scripting GitHub - 212
*** TODO Services and Hooks - 212
**** Services - 213
**** Hooks - 214

*** TODO The GitHub API - 216
**** Basic Usage - 217
**** Commenting on an Issue - 218
**** Changing the Status of a Pull Request - 219

*** TODO Octokit - 221

** TODO 6.6 Summary - 221

* vvvvvvvvvvvv PAGE NUMBER UPDATED -------
* TODO 7. Git Tools - 218
** DONE 7.1 Revision Selection - 218 - =TODO: NOTE=
CLOSED: [2024-11-06 Wed 19:49]
*** Single Revisions - 218
*** Short SHA-1 - 218
*** Branch References - 220
*** RefLog Shortnames - 220
*** Ancestry References - 222
*** Commit Ranges - 224
**** Double Dot - 224
**** Multiple Points - 225
**** Triple Dot - 225

** DONE 7.2 Interactive Staging - 226 - =TODO: NOTE=
CLOSED: [2024-11-06 Wed 19:59]
*** Staging and Unstaging Files - 226
*** Staging Patches - 228

** TODO 7.3 Stashing and Cleaning - 230
*** Stashing Your Work - 230
*** Creative Stashing - 232
*** Creating a Branch from a Stash - 233
*** Cleaning Your Working Directory - 234

** TODO 7.4 Signing Your Work - 236
*** GPG Introduction - 236
*** Signing Tags - 236
*** Verifying Tags - 237
*** Signing Commits - 238
*** Everyone Must Sign - 239

** TODO 7.5 Searching - 239
*** Git Grep - 240
*** Git Log Searching - 241
**** Line Log Search - 242

** TODO 7.6 Rewriting History - 243
*** Changing the Last Commit - 243
*** Changing Multiple Commit Messages - 244
*** Reordering Commits - 246
*** Squashing Commits - 247
*** Splitting a Commit - 248
*** Deleting a Commit - 249
*** The Nuclear Option: filter-branch - 249
**** Removing a File from Every Commit - 250
**** Making a Subdirectory the New Root - 250
**** Changing EMail Addresses Globally - 250

** TODO 7.7 Reset Demystified - 251
*** The Three Trees - 251
**** The HEAD - 251
**** The Index - 252
**** The Working Directory - 252

*** The Workflow - 253
*** The Role of Reset - 259
**** Step 1: Move HEAD - 260
**** Step 2: Updating the Index (--mixed) - 261
**** Step 3: Updating the Working Directory (--hard) - 262
**** Recap - 263

*** Reset with a Path - 264
*** Squashing - 266
*** Check It Out - 269
**** Without Paths - 269
**** With Paths - 271

*** Summary - 271

** TODO 7.8 Advanced Merging - 271
*** TODO Merge Conflicts - 278
**** TODO Aborting a Merge - 273
**** TODO Ignoring Whitespace - 274
**** TODO Manual File Re-merging - 274
**** TODO Checking Out Conflicts - 277
**** TODO Merge Log - 279
**** TODO Combined Diff Format - 280

*** TODO Undoing Merges - 282
**** Fix the references - 282
**** Reverse the commit - 283

*** TODO Other Types of Merges - 285
**** Our or Theirs Preference - 285
**** Subtree Merging - 286

** TODO 7.9 Rerere - 288
** TODO 7.10 Debugging with Git - 295
*** TODO File Annotation - 295
*** TODO Binary Search - 296

** TODO 7.11 Submodules - 298
*** Starting with Submodules - 298
*** Cloning a Project with Submodules - 300
*** Working on a Project with Submodules - 302
**** Pulling in Upstream Changes from the Submodule Remote - 302
**** Pulling in Upstream Changes from the Project Remote - 305
**** Working on a Submodule - 307
**** Publishing Submodule Changes - 309
**** Merging Submodule Changes - 310

*** Submodule Tips - 313
**** Submodule Foreach - 313
**** Useful Aliases - 315

*** Issues with Submodules - 315
**** Switching branches - 315
**** Switching from subdirectories to submodules - 317

** TODO 7.12 Bundling - 318
** TODO 7.13 Replace - 322
** TODO 7.14 Credential Storage - 330
*** TODO Under the Hood - 331
*** TODO A Custom Credential Cache - 333

** TODO 7.15 Summary - 335

* TODO 8. Customizing Git - 336 - PAGE NUMBER UPDATED
In this chapter, we'll see
HOW you can make Git operate in a more customized fashion,
BY introducing several important _configuration settings_ and _the hooks
system_.

** TODO 8.1 Git Configuration - 336
*** TODO Basic Client Configuration - 336
**** ~core.editor~
**** ~commit.template~
**** ~core.pager~
**** ~user.signingkey~
**** ~core.excludesfile~
**** ~help.autocorrect~

*** TODO Colors in Git - 339
**** ~color.ui~
**** ~color.*~

*** TODO External Merge and Diff Tools - 340
*** TODO Formatting and Whitespace - 343
**** ~core.autocrlf~
**** ~core.whitespace~

*** TODO Server Configuration - 345
**** ~receive.fsckObjects~
**** ~receive.denyNonFastForwards~
**** ~receive.denyDeletes~

** TODO 8.2 Git Attributes - 346
*** Binary Files - 346
**** Indentifying Binary Files - 346
**** Diffing Binary Files - 347

*** Keyword Expansion - 349
*** Exporting Your Repository - 352
**** ~export-ignore~
**** ~export-subst~

*** Merge Strategies - 354

** TODO 8.3 Git Hooks - 354
Like many other Version Control Systems,
Git has a way to fire off custom scripts _WHEN certain important actions occur._

- There are _TWO_ groups of these hooks: _client-side_ and _server-side_.
  * /Clientside hooks/ are triggered by operations such as _committing_ and _merging_,

  * /Server-side hooks/ run on network operations such as receiving pushed commits.

  You can use these hooks for all sorts of reasons.

*** Installing a Hook - 354
*** Client-Side Hooks - 355
**** Committing-Workflow Hooks - 355
**** Email Workflow Hooks - 355
**** Other Client Hooks - 356

*** Server-Side Hooks - 356
**** ~pre-receive~
**** ~update~
**** ~post-receive~

** TODO 8.4 An Example Git-Enforced Policy - 357
*** Server-Side Hook - 357
**** Enforcing a Specific Commit-Message Format - 358
**** Enforcing a User-Based ACL System - 359
**** Testing It Out - 362

*** Client-Side Hooks - 363

** TODO 8.5 Summary - 366

* TODO 9. Git and Other Systems - 367 - _NOT-IMPORTANT_
** TODO 9.1 Git as a Client - 367
*** TODO Git and Subversion - 377
**** ~git svn~
**** Setting Up
**** Getting Started
**** Committing Back to Subversion
**** Pulling in New Changes
**** Git Branching Issues
**** Subversion Branching
***** Creating a New SVN Branch
***** Switching Active Branches

**** Subversion Commands
***** SVN Style History
***** SVN Annotation
***** SVN Server Information
***** Ignoring What Subversion Ignores

**** Git-Svn Summary

*** TODO Git and Mercurial - 388
**** ~git-remote-hg~
**** Getting Started
**** Workflow
**** Branches and Bookmarks
**** Mercurial Summary

*** TODO Git and Bazaar - 395
**** Create a Git repository from a Bazaar repository
**** Bazaar branches
**** Ignore what is ignored with =.bzrignore=
**** Fetch the change of the remote repository
**** Push your work on the remote repository
**** Caveats
**** Summary

*** TODO Git and Perforce - 398
**** Git Fusion
***** Setting Up
***** Fusion Configuration
***** Workflow
***** Git-Fusion Summary

**** Git-p4
***** Setting Up
***** Getting Started
***** Workflow
***** Branching

**** Git and Perforce Summary

** TODO 9.2 Migrating to Git - 399
*** TODO Subversion - 414
*** TODO Mercurial - 416
*** TODO Bazaar - 420
**** Getting the bzr-fastimport plugin - 420
**** Project with a single branch - 421
**** Case of a project with a main branch and a working branch - 421
**** Synchronizing the staging area - 422
**** Ignoring the files that were ignored with =.bzrignore= - 422
**** Sending your repository to the server - 422

*** TODO Perforce - 423
**** TODO Perforce Git Fusion - 423
**** TODO Git-p4 - 423

*** TODO A Custom Importer - 424

** TODO 9.3 Summary - 413

* TODO 10. Git Internals - 414
** TODO 10.1 Plumbing and Porcelain - 414
** TODO 10.2 Git Objects - 415
*** TODO Tree Objects - 417
*** TODO Commit Objects - 420
*** TODO Object Storage - 423

** TODO 10.3 Git References - 425
*** TODO The HEAD - 426
*** TODO Tags - 427
*** TODO Remotes - 428

** TODO 10.4 Packfiles - 429
** TODO 10.5 The Refspec - 432
*** TODO Pushing Refspecs - 434
*** TODO Deleting References - 434

** TODO 10.6 Transfer Protocols - 435
*** TODO The Dumb Protocol - 435
*** TODO The Smart Protocol - 437
**** TODO Uploading Data - 437
***** TODO SSH - 437
***** TODO HTTP(S) - 438

**** TODO Downloading Data - 439
***** TODO SSH - 439
***** TODO HTTP(S) - 439

*** TODO Protocol Summary - 440

** TODO 10.7 Maintenance and Data Recovery - 440
*** TODO Maintenance - 440
*** TODO Data Recovery - 441
*** TODO Removing Objects - 443

** TODO 10.8 Environment Variables - 447
*** TODO Global Behavior - 447
*** TODO Repository Locations - 447
*** TODO Pathspecs - 448
*** TODO Committing - 448
*** TODO Networking - 448
*** TODO Diffing and Merging - 449
*** TODO Debugging - 449
*** TODO Miscellaneous - 451

** TODO 10.9 Summary - 452

* TODO Appendix A: Git in Other Environments - 453
** TODO Graphical Interfaces - 453
*** TODO =gitk= and =git-gui= - 453
*** TODO GitHub for macOS and Windows - 455
**** TODO Installation - 457
**** TODO Recommended Workflow - 457
**** TODO Summary - 458

*** TODO Other GUIs - 458

** TODO Git in Visual Studio - 458
** TODO Git in Visual Studio Code - 459
** TODO Git in IntelliJ / PyCharm / WebStorm / PhpStorm / RubyMine - 459
** TODO Git in Sublime Text - 460
** TODO Git in Bash - 460
** TODO Git in Zsh - 461
** TODO Git in Powershell - 463
*** Installation - 463
**** Prerequisites (Windows only) - 463
**** PowerShell Gallery - 464
**** Update PowerShell Prompt - 464
**** From Source - 465

** TODO Summary - 465

* TODO Appendix B: Embedding Git in your Applications - 466
** TODO Command-line Git - 466
** TODO Libgit2 - 466
*** TODO Advanced Functionality - 468
*** TODO Other Bindings - 470
**** LibGit2Sharp - 470
**** objective-git - 471
**** pygit2 - 471

*** TODO Further Reading - 471

** TODO JGit - 471
*** Getting Set Up - 471
*** Plumbing - 472
*** Porcelain - 474
*** Further Reading - 475

** TODO go-git - 475
*** Advanced Functionality - 475
*** Further Reading - 475

** TODO Dulwich - 476
*** TODO Further Reading - 477

* TODO Appendix C: Git Commands - 478
** TODO Setup and Config - 478
*** TODO ~git config~ - 478
*** TODO ~git config core.editor~ commands - 478
*** TODO ~git help~ - 479

** TODO Getting and Creating Projects - 480
*** TODO ~git init~ - 480
*** TODO ~git clone~ - 480

** TODO Basic Snapshotting - 481
*** TODO ~git add~ - 481
*** TODO ~git status~ - 481
*** TODO ~git diff~ - 481
*** TODO ~git difftool~ - 482
*** TODO ~git commit~ - 482
*** TODO ~git reset~ - 482
*** TODO ~git rm~ - 483
*** TODO ~git mv~ - 483
*** TODO ~git clean~ - 483

** TODO Branching and Merging - 483
*** TODO ~git branch~ - 483
*** TODO ~git checkout~ - 484
*** TODO ~git merge~ - 484
*** TODO ~git mergetool~ - 484
*** TODO ~git log~ - 484
*** TODO ~git stash~ - 485
*** TODO ~git tag~ - 485

** TODO Sharing and Updating Projects - 485
*** TODO ~git fetch~ - 486
*** TODO ~git pull~ - 486
*** TODO ~git push~ - 486
*** TODO ~git remote~ - 487
*** TODO ~git archive~ - 487
*** TODO ~git submodule~ - 487

** TODO Inspection and Comparison - 487
*** TODO ~git show~ - 487
*** TODO ~git shortlog~ - 488
*** TODO ~git describe~ - 488

** TODO Debugging - 488
*** TODO ~git bisect~ - 488
*** TODO ~git blame~ - 488
*** TODO ~git grep~ - 488

** TODO Patching - 489
*** TODO ~git cherry-pick~ - 489
*** TODO ~git rebase~ - 489
*** TODO ~git revert~ - 489

** TODO Email - 489
*** TODO ~git apply~ - 489
*** TODO ~git am~ - 490
*** TODO ~git format-patch~ - 490
*** TODO ~git imap-send~ - 490
*** TODO ~git send-email~ - 490
*** TODO ~git request-pull~ - 490

** TODO External Systems - 491
*** TODO ~git svn~ - 491
*** TODO ~git fast-import~ - 491

** TODO Administration - 491
*** TODO ~git gc~ - 491
*** TODO ~git fsck~ - 491
*** TODO ~git reflog~ - 491
*** TODO ~git filter-branch~ - 492

** TODO Plumbing Commands - 492

* Index - 493
