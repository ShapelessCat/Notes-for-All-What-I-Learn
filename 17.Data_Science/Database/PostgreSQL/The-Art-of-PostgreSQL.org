#+TITLE: The Art of PostgreSQL
#+SUBTITLE: Turn Thousands of Lines of Code into Simple Queries
#+AUTHOR: Dimitri Fontaine
#+EDITION: 2nd
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* I Preface - xi
* About.. - xiii
** 1 About the Book - xiii
** 2 About the Author - xiv
** 3 Acknowledgements - xiv
** 4 About the organisation of the book - xv

* II Introduction - 1
** 1 Structured Query Language - 2
*** 1.1 Some of the Code is Written in SQL - 3
*** 1.2 A First Use Case - 4
*** 1.3 Loading the Data Set - 4
*** 1.4 Application Code and SQL - 5
*** 1.5 A Word about SQL Injection - 9
*** 1.6 PostgreSQL protocol: server-side prepared statements - 10
*** 1.7 Back to Discovering SQL - 12
*** 1.8 Computing Weekly Changes - 15

** 2 Software Architecture - 18
*** 2.1 Why PostgreSQL? - 20
*** 2.2 The PostgreSQL Documentation - 22

** 3 Getting Ready to read this Book - 23

* III Writing Sql Queries - 25
** 4 Business Logic - 27
*** 4.1 Every SQL query embeds some business logic - 27
*** 4.2 Business Logic Applies to Use Cases - 29
*** 4.3 Correctness - 32
*** 4.4 Efficiency - 34
*** 4.5 Stored Procedures — a Data Access API - 36
*** 4.6 Procedural Code and Stored Procedures - 38
*** 4.7 Where to Implement Business Logic? - 39

** 5 A Small Application - 40
*** 5.1 Readme First Driven Development - 40
*** 5.2 Loading the Dataset - 40
*** 5.3 Chinook Database - 42
*** 5.4 Music Catalog - 44
*** 5.5 Albums by Artist - 45
*** 5.6 Top-N Artists by Genre - 45

** 6 The SQL REPL — An Interactive Setup - 51
*** 6.1 Intro to psql - 51
*** 6.2 The psqlrc Setup - 52
*** 6.3 Transactions and psql Behavior - 53
*** 6.4 A Reporting Tool - 55
*** 6.5 Discovering a Schema - 56
*** 6.6 Interactive Query Editor - 57

** 7 SQL is Code - 58
*** 7.1 SQL style guidelines - 58
*** 7.2 Comments - 62
*** 7.3 Unit Tests - 63
*** 7.4 Regression Tests - 66
*** 7.5 A Closer Look - 67

** 8 Indexing Strategy - 69
*** 8.1 Indexing for Constraints - 70
*** 8.2 Indexing for Queries - 71
*** 8.3 Cost of Index Maintenance - 71
*** 8.4 Choosing Queries to Optimize - 72
*** 8.5 PostgreSQL Index Access Methods - 72
*** 8.6 Advanced Indexing - 75
*** 8.7 Adding Indexes - 75

** 9 An Interview with Yohann Gabory - 79

* IV SQL Toolbox - 84
** 10 Get Some Data - 86
** 11 Structured Query Language - 87
** 12 Queries, DML, DDL, TCL, DCL - 89
** 13 Select, From, Where - 91
*** 13.1 Anatomy of a Select Statement - 91
*** 13.2 Projection (output): Select - 91
*** 13.3 Data sources: From - 97
*** 13.4 Understanding Joins - 98
*** 13.5 Restrictions: Where - 100

** 14 Order By, Limit, No Offset - 103
*** 14.1 Ordering with Order By - 103
*** 14.2 kNN Ordering and GiST indexes - 105
*** 14.3 Top-N sorts: Limit - 107
*** 14.4 No Offset, and how to implement pagination - 109

** 15 Group By, Having, With, Union All - 112
*** 15.1 Aggregates (aka Map/Reduce): Group By - 112
*** 15.2 Aggregates Without a Group By - 115
*** 15.3 Restrict Selected Groups: Having - 116
*** 15.4 Grouping Sets - 117
*** 15.5 Common Table Expressions: With - 120
*** 15.6 Distinct On - 124
*** 15.7 Result Sets Operations - 125

** 16 Understanding Nulls - 129
*** 16.1 Three-Valued Logic - 129
*** 16.2 Not Null Constraints - 131
*** 16.3 Outer Joins Introducing Nulls - 132
*** 16.4 Using Null in Applications - 133

** 17 Understanding Window Functions - 135
*** 17.1 Windows and Frames - 135
*** 17.2 Partitioning into Different Frames - 137
*** 17.3 Available Window Functions - 138
*** 17.4 When to Use Window Functions - 140

** 18 Understanding Relations and Joins - 141
*** 18.1 Relations - 141
*** 18.2 SQL Join Types - 143

** 19 An Interview with Markus Winand - 146

* V Data Types - 150
** 20 Serialization and Deserialization - 152
** 21 Some Relational Theory - 154
*** 21.1 Attribute Values, Data Domains and Data Types - 155
*** 21.2 Consistency and Data Type Behavior - 156

** 22 PostgreSQL Data Types - 160
*** 22.1 Boolean - 161
*** 22.2 Character and Text - 163
*** 22.3 Server Encoding and Client Encoding - 168
*** 22.4 Numbers - 170
*** 22.5 Floating Point Numbers - 172
*** 22.6 Sequences and the Serial Pseudo Data Type - 172
*** 22.7 Universally Unique Identifier: UUID - 174
*** 22.8 Bytea and Bitstring - 175
*** 22.9 Date/Time and Time Zones - 175
*** 22.10 Time Intervals - 179
*** 22.11 Date/Time Processing and Querying - 181
*** 22.12 Network Address Types - 185
*** 22.13 Ranges - 188

** 23 Denormalized Data Types - 192
*** 23.1 Arrays - 192
*** 23.2 Composite Types - 198
*** 23.3 XML - 199
*** 23.4 JSON - 201
*** 23.5 Enum - 203

** 24 PostgreSQL Extensions - 205
** 25 An interview with Grégoire Hubert - 207

* VI Data Modeling - 210
** 26 Object Relational Mapping - 212
** 27 Tooling for Database Modeling - 214
*** 27.1 How to Write a Database Model - 215
*** 27.2 Generating Random Data - 218
*** 27.3 Modeling Example - 220

** 28 Normalization - 226
*** 28.1 Data Structures and Algorithms - 226
*** 28.2 Normal Forms - 229
*** 28.3 Database Anomalies - 230
*** 28.4 Modeling an Address Field - 231
*** 28.5 Primary Keys - 233
*** 28.6 Surrogate Keys - 233
*** 28.7 Foreign Keys Constraints - 236
*** 28.8 Not Null Constraints - 236
*** 28.9 Check Constraints and Domains - 237
*** 28.10 Exclusion Constraints - 238

** 29 Practical Use Case: Geonames - 239
*** 29.1 Features - 242
*** 29.2 Countries - 243
*** 29.3 Administrative Zoning - 247
*** 29.4 Geolocation Data - 250
*** 29.5 Geolocation GiST Indexing - 253
*** 29.6 A Sampling of Countries - 255

** 30 Modelization Anti-Patterns - 257
*** 30.1 Entity Attribute Values - 257
*** 30.2 Multiple Values per Column - 260
*** 30.3 UUIDs - 262

** 31 Denormalization - 264
*** 31.1 Premature Optimization - 265
*** 31.2 Functional Dependency Trade-Offs - 265
*** 31.3 Denormalization with PostgreSQL - 266
*** 31.4 Materialized Views - 267
*** 31.5 History Tables and Audit Trails - 269
*** 31.6 Validity Period as a Range - 271
*** 31.7 Pre-Computed Values - 272
*** 31.8 Enumerated Types - 272
*** 31.9 Multiple Values per Attribute - 273
*** 31.10 The Spare Matrix Model - 273
*** 31.11 Partitioning - 273
*** 31.12 Other Denormalization Tools - 274
*** 31.13 Denormalize with Care - 275

** 32 Not Only SQL - 276
*** 32.1 Schemaless Design in PostgreSQL - 277
*** 32.2 Durability Trade-Offs - 280
*** 32.3 Scaling Out - 282

** 33 An interview with Álvaro Hernández Tortosa - 284

* VII Data Manipulation and Concurrency Control - 289
** 34 Another Small Application - 291
** 35 Insert, Update, Delete - 295
*** 35.1 Insert Into - 295
*** 35.2 Insert Into … Select - 296
*** 35.3 Update - 298
*** 35.4 Inserting Some Tweets - 301
*** 35.5 Delete - 303
*** 35.6 Tuples and Rows - 305
*** 35.7 Deleting All the Rows: Truncate - 305
*** 35.8 Delete but Keep a Few Rows - 305

** 36 Isolation and Locking - 307
*** 36.1 Transactions and Isolation - 308
*** 36.2 About SSI - 309
*** 36.3 Concurrent Updates and Isolation - 309
*** 36.4 Modeling for Concurrency - 311
*** 36.5 Putting Concurrency to the Test - 313

** 37 Computing and Caching in SQL - 317
*** 37.1 Views - 318
*** 37.2 Materialized Views - 319

** 38 Triggers - 322
*** 38.1 Transactional Event Driven Processing - 323
*** 38.2 Trigger and Counters Anti-Pattern - 325
*** 38.3 Fixing the Behavior - 326
*** 38.4 Event Triggers - 328

** 39 Listen and Notify - 329
*** 39.1 PostgreSQL Notifications - 329
*** 39.2 PostgreSQL Event Publication System - 330
*** 39.3 Notifications and Cache Maintenance - 332
*** 39.4 Limitations of Listen and Notify - 337
*** 39.5 Listen and Notify Support in Drivers - 337

** 40 Batch Update, MoMA Collection - 339
*** 40.1 Updating the Data - 340
*** 40.2 Concurrency Patterns - 342
*** 40.3 On Conflict Do Nothing - 343

** 41 An Interview with Kris Jenkins - 345

* VIII PostgreSQL Extensions - 349
** 42 What’s a PostgreSQL Extension? - 351
*** 42.1 Inside PostgreSQL Extensions - 353
*** 42.2 Installing and Using PostgreSQL Extensions - 354
*** 42.3 Finding PostgreSQL Extensions - 355
*** 42.4 A Primer on Authoring PostgreSQL Extensions - 356
*** 42.5 A Short List of Noteworthy Extensions - 356

** 43 Auditing Changes with hstore - 362
*** 43.1 Introduction to hstore - 362
*** 43.2 Comparing hstores - 363
*** 43.3 Auditing Changes with a Trigger - 363
*** 43.4 Testing the Audit Trigger - 365
*** 43.5 From hstore Back to a Regular Record - 367

** 44 Last.fm Million Song Dataset - 369
** 45 Using Trigrams For Typos - 376
*** 45.1 The pg_trgm PostgreSQL Extension - 376
*** 45.2 Trigrams, Similarity and Searches - 377
*** 45.3 Complete and Suggest Song Titles - 381
*** 45.4 Trigram Indexing - 382

** 46 Denormalizing Tags with intarray - 384
*** 46.1 Advanced Tag Indexing - 384
*** 46.2 Searches - 385
*** 46.3 User-Defined Tags Made Easy - 388

** 47 The Most Popular Pub Names - 390
*** 47.1 A Pub Names Database - 390
*** 47.2 Normalizing the Data - 392
*** 47.3 Geolocating the Nearest Pub (k-NN search) - 393
*** 47.4 Indexing kNN Search - 394

** 48 How far is the nearest pub? - 396
*** 48.1 The earthdistance PostgreSQL contrib - 396
*** 48.2 Pubs and Cities - 397
*** 48.3 The Most Popular Pub Names by City - 400

** 49 Geolocation with PostgreSQL - 403
*** 49.1 Geolocation Data Loading - 403
*** 49.2 Finding an IP Address in the Ranges - 407
*** 49.3 Geolocation Metadata - 408
*** 49.4 Emergency Pub - 409

** 50 Counting Distinct Users with HyperLogLog - 411
*** 50.1 HyperLogLog - 411
*** 50.2 Installing postgresql-hll - 412
*** 50.3 Counting Unique Tweet Visitors - 413
*** 50.4 Lossy Unique Count with HLL - 416
*** 50.5 Getting the Visits into Unique Counts - 417
*** 50.6 Scheduling Estimates Computations - 420
*** 50.7 Combining Unique Visitors - 422

** 51 An Interview with Craig Kerstiens - 423

* IX Closing Thoughts - 426
* X Index - 428
