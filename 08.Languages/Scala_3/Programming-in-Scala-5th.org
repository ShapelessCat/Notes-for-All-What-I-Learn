#+TITLE: Programming in Scala
#+SUBTITLE: A comprehensive step-by-step guide - Updated for Scala 3.0
#+VERSION: 5th
#+AUTHOR: Martin Odersky, Lex Spoon, Bill Venners, Frank Sommers
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Contents - xi
* List of Figures - xix
* List of Tables - xxi
* List of Listings - xxiii
* TODO Foreword - xxix - _TAKE NOTES_
- New programming languages are created for many reasons:
  * a personal desire to scratch a niggling itch,
  * a profound academic insight,
  * technical debt, or
  * the benefit of hindsight of other compiler architectures --
  * even politics.

  _Scala 3 is a combination of some of these._

- =TODO= NOTE

* TODO Acknowledgments - xxxiii
* DONE Introduction - xxxvi
CLOSED: [2025-04-14 Mon 16:20]
Our goal: by reading this book, you can learn everything you need to be a
productive Scala programmer.

- *Who should read this book*
  - Programmers how want to learn to program in Scala.
  - Programmers wishing to expand their horizons by learning new concepts.

  - We believe learning about Scala, and the ideas behind it, can help you
    become a better progammer in general.

  - REREQUISITE:
    _General programming knowledge is ASSUMED._
    * While Scala is a fine _FIRST programming language,_ this is NOT the book
      to use to learn programming.

  - No specific knowledge of programming languages is required.
    Not presume you know anything about Java.
    _HOWEVER_,
    we EXPECT many readers to be familiar with Java, and
    so we sometimes compare Scala to Java to help such readers understand the
    differences.

** How to use this book
Read this book is in chapter order, from front to back.

After you have read the book once, it should also serve as a language
reference.

There is a formal specification of the Scala language, but the language
specification tries for precision at the expense of readability.

** How to learn Scala
You will learn a lot about Scala simply by reading this book from cover to
cover. You can learn Scala faster and more thoroughly, though, if you do a few
extra things:
1. Type the example code in this book in yourself,
   force your mind through each line of code.

   Trying variations to make sure you really understand how they work.

2. keep in touch with the numerous online forums.

3. Take on a programming project of your own.

Work on a small program from scratch or develop an add-in to a larger
program. _You can only go so far by reading._

** EBook features
** Typographic conventions
** Content overview
- Chapter 12, “Packages and Imports,”
  =FIXME= title (about export)
  =FIXME= content (about export)

- Chapter 19, “Enums and ADTs,” introduces twin constructs that supportyou
  when writing regular, non-encapsulated data structures.
  =FIXME= Order!!!
  =FIXME= description here copied the first sentent of Chapter 12!

- Chapter 23, “Typeclasses,” yet to be written,
  =FIXME= already done!!! This is not a pre-print version!

- =from Jian= Already submitted a errata!

** Resources
- https://www.scalalang.org
- https://booksites.artima.com/programming_in_scala_5ed

** Source code
https://booksites.artima.com/programming_in_scala_5ed

** Errata - =TODO: Review periodically=
https://booksites.artima.com/programming_in_scala_5ed/errata

* TODO 1 A Scalable Language - 43
** DONE 1.1 A language that grows on you - 44
CLOSED: [2025-04-15 Tue 12:41]
- Scala is easy to get into. It runs on the standard _Java_ and _JavaScript_
  platforms and interoperates seamlessly with all platform libraries.
  * =from Jian= Still not mention Scala Native

- Technically, Scala is a blend of /object-oriented/ and /functional
  programming/ concepts in a /statically typed/ language.
  =IMPORTANT=

  * The two programming styles have *COMPLEMENTARY strengths* when it comes
    to scalability.
    + Scala's functional programming constructs make it easy to build
      interesting things quickly from simple parts.

    + Scala's object-oriented constructs make it easy to structure larger
      systems and adapt them to new demands.

  * The combination of both styles in Scala
    + makes it possible to express new kinds of programming patterns and
      component abstractions.

    + It also leads to a legible and concise programming style.

    + And because it is so malleable, programming in Scala can be a lot of fun.

- This initial chapter answers the question, “Why Scala?” It gives a highlevel
  view of Scala's design and the reasoning behind it.

  * After reading the chapter you should have
    a basic feel
    + for what Scala is and
    + what kinds of tasks it might help you accomplish.

*** Growing new types - 45
So the approach of attempting to provide everything in one language doesn't
scale very well. _Instead_, Scala allows users to grow and adapt the language in
the directions they need by defining easy-to-use libraries that feel like native
language support.

*** Growing new control constructs - 46
You can “grow” the Scala language in new directions even as specialized as
software testing.
To be sure, you need experienced architects and programmers to do this.
BUT the crucial thing is that it is *feasible* -- you can design and implement
abstractions in Scala that address radically new application domains, yet still
_feel like native language support when used._

** TODO 1.2 What makes Scala scalable? - 47
- _Scalability_ is influenced by many factors, ranging from syntax details to
  component abstraction constructs. If we were forced to name just one aspect of
  Scala that helps scalability, though, we'd pick its combination of
  _object-oriented_ and _functional programming_ (well, we cheated, that's
  really two aspects, but they are intertwined).

- Scala goes further than all other well-known languages in fusing
  object-oriented and functional programming into a uniform language design.

  * For instance, where other languages might have /objects/ and /functions/ as
    two different concepts, *in Scala a /function value/ is an /object/.*

    /Function types/ are /classes/ that can be inherited by /subclasses/. This
    might seem nothing more than an academic nicety, but it has deep
    consequences for scalability.

    This section gives an overview of Scala's way of blending object-oriented
    and functional concepts.

*** Scala is object-oriented - 48
- Object-oriented programming has been immensely successful. Starting from
  Simula in the mid-60s and Smalltalk in the 70s, it is now available in more
  languages than not. In some domains, objects have taken over completely. While
  there is not a precise definition of what object-oriented means, there is
  clearly something about objects that appeals to programmers.

- In principle, the motivation for object-oriented programming is very
  simple: all but the most trivial programs need some sort of structure. The
  most straightforward way to do this is to put data and operations into some
  form of containers. The great idea of object-oriented programming is to make
  these containers fully general, so that they can contain operations as well
  as data, and that they are themselves values that can be stored in other
  containers, or passed as parameters to operations. Such containers are called
  objects. Alan Kay, the inventor of Smalltalk, remarked that in this way the
  simplest object has the same construction principle as a full computer: it
  combines data with operations under a formalized interface.7 So objects have
  a lot to do with language scalability: the same techniques apply to the
  construction of small as well as large programs.

- Even though object-oriented programming has been mainstream for along time,
  there are relatively few languages that have followed Smalltalkin pushing
  this construction principle to its logical conclusion. For instance,many
  languages admit values that are not objects, such as the primitive valuesin
  Java. Or they allow static fields and methods that are not membersof any
  object. These deviations from the pure idea of object-oriented
  programminglook quite harmless at first, but they have an annoying
  tendencyto complicate things and limit scalability.

*** Scala is functional - 49

** TODO 1.3 Why Scala? - 51
We have found that there are actually many reasons besides scalability to like
programming in Scala.
FOUR of the most important aspects will be discussed in this section:
- compatibility
- brevity
- high-level abstractions, and
- advanced static typing.

*** Scala is compatible - 51
- Scala *doesn't require* you to leap backwards off the Java platform to step
  forward from the Java language.
  It allows you to add value to existing code -- to build on what you already
  have -- because it was designed for seamless interoperability with Java.

- Another aspect of full interoperability is that Scala heavily re-uses
  Javatypes. Scala’s Ints are represented as Java primitive integers of type
  int,Floats are represented as floats, Booleans as booleans, and so on.
  Scalaarrays are mapped to Java arrays. Scala also re-uses many of the
  standardJava library types. For instance, the type of a string literal "abc"
  inScala is java.lang.String, and a thrown exception must be a subclass
  ofjava.lang.Throwable.

- Scala not only re-uses Java’s types, but also “dresses them up” to makethem
  nicer. For instance, Scala’s strings support methods like toInt ortoFloat,
  which convert the string to an integer or floating-point number.So you can
  write str.toInt instead of Integer.parseInt(str). Howcan this be achieved
  without breaking interoperability? Java’s String classcertainly has no toInt
  method! In fact, Scala has a very general solutionto solve this tension
  between advanced library design and interoperability.Scala lets you define
  rich extensions, which are always applied when non-existing members are
  selected.10 In the case above, when looking for atoInt method on a string,
  the Scala compiler will find no such memberof class String, but it will find
  an implicit conversion that converts a JavaString to an instance of the
  Scala class StringOps, which does define sucha member. The conversion will
  then be applied implicitly before performingthe toInt operation.

- Scala code can also be invoked from Java code. This is sometimes a bitmore
  subtle, because Scala is a richer language than Java, so some of Scala’smore
  advanced features need to be encoded before they can be mapped toJava. The
  details will be explained in Advanced Programming in Scala.

*** Scala is concise - 52
*** Scala is high-level - 53
*** Scala is statically typed - 55

** TODO 1.4 Scala's roots - 58
** TODO 1.5 Conclusion - 59

* DONE 2 First Steps in Scala - 61
CLOSED: [2025-04-17 Thu 01:22]
- This page describes several ways to _install or try_ Scala.

- Everything will be explained in a less “fire hose” fashion in later chapters.

  In addition, we inserted quite a few footnotes in these next two chapters to
  point you

- =from Jian=
  Use _coursier_ (command ~cs setup~) to install all related tools, including
  * ammonite
  * cs
  * coursier
  * scala
  * scalac
  * scala-cli
  * sbt
  * sbtn
  * scalafmt

** DONE Step 1. Learn to use the Scala REPL - 61
CLOSED: [2025-04-16 Wed 22:52]
=from Jian= Current version use Scala 3.0, and from Scala 3.5.0 on, =scala=
command refer to =scala-cli=, which is not covered by this book because of the
Scala version used when writing this book.

** DONE Step 2. Define some variables - 63
CLOSED: [2025-04-16 Wed 23:27]
- If you realize you have typed something wrong, but the REPL is still waiting
  for more input, you can use the arrow keys to move up, down, left, or right to
  fix the mistakes.

- If you want to abort your entry completely, you can escape by pressing enter
  twice:
  #+begin_src text
    scala> val oops =
         |
         |
    You typed two blank lines. Starting a new command.
    scala>
  #+end_src
  =FIXME= Not an always work way!!!
  =from Jian=
  =IMPORTANT=
  New Scala REPL is backed by _JLine_, and *NOT all JLine version support* this
  way to abort current input. Usually, _JLine_ by default enable Emacs shortcuts,
  therefore _CTRL + G_ works.

** DONE Step 3. Define some functions - 65
CLOSED: [2025-04-17 Thu 00:48]
- footnote 7:
  * In Java, the type of the value returned from a method is its /return type/.
  * In Scala, that same concept is called /result type/.
  =from Jian= This is reasonable, because Scala rarely use ~return~, call it
  /return type/ in Scala is weird.
  =IMPORTANT=

- Sometimes the Scala compiler will require you to specify the /result type/ of a
  function.
  * If a function is /recursive/, for example, you *must explicitly specify* its
    /result type/.

  * If a function consists of just _one statement_,
    you can optionally write the function entirely on one line.
    + =from Jian= Yes, this should be mentioned, because now brace-less
      indentation-based syntax is used.

  * footnote 8:
    Nevertheless, it is often a good idea to indicate function result types
    explicitly, even when the compiler doesn't require it.

    =IMPORTANT=
    Such /type annotations/ can make the code easier to read,
    BECAUSE the reader need not study the function body to figure out the
    /inferred result type/.
    =from Jian=
    Types in general is also like a kind of document when reading code, we can
    let them be inferred by compiler, but always write _some of them that at
    interface positions_ down explicitly, which is good for read.
    Function /result type/ is at, this function's, interface positions.
    + I create and use this term "interface positions", not a formal term.

- Every ~void~-returning method in Java is mapped to a ~Unit~-returning method
  in Scala.

- Use ~:quit~ in REPL to exit the REPL.

** DONE Step 4. Write some Scala scripts - 67
CLOSED: [2025-04-17 Thu 00:58]
- Write a script in Scala and run it:
  1. Put this code in file =hello.scala=
     #+begin_src scala
       @main def m() = println("Hello, world, from a script!")
     #+end_src

  2. Run it in command line:
     ~scala hello.scala~

  3. Output:
     =Hello, world, from a script!=

- Write a script in Scala that can accept command line arguments, and then run
  it:
  1. Put this code in file =helloarg.scala=
     #+begin_src scala
       @main def m(args: String*) =
         // Say hello to the first argument
         println("Hello, " + args(0) + "!")
     #+end_src

  2. Run it in command line:
     ~scala helloarg.scala planet~

  3. Output:
     =Hello, planet!=

** DONE Step 5. Loop with ~while~; decide with ~if~ - 68
CLOSED: [2025-04-17 Thu 01:08]
- *Note*
  Although the examples in this section help explain ~while~ loops,
  they *DO NOT demonstrate the best Scala style.*
    In the next section, you'll see better approaches that avoid iterating
  through sequences with indexes.

- Write a script in Scala and run it:
  1. Put this code in file =printargs.scala=
     #+begin_src scala
       @main def m(args: String*) =
         var i = 0
         while i < args.length do
           println(args(i))
           i += 1
     #+end_src

  2. Run it:
     ~scala printargs.scala Scala is fun~

  3. Output:
     #+begin_src text
       Scala
       is
       fun
     #+end_src

- Write a script in Scala and run it:
  1. Put this code in file =echoargs.scala=
     #+begin_src scala
       @main def m(args: String*) =
         var i = 0
         while i < args.length do
           if i != 0 then
             print(" ")
           print(args(i))
           i += 1
         println()
     #+end_src

  2. Run it:
     ~scala echoargs.scala Scala is even more fun~

  3. Output:
     #+begin_src text
       Scala is even more fun
     #+end_src

- As of Scala 3, the /indentation-based style/, called *"quiet syntax,"* is
  recommended over the /curly brace style/.

- Scala 3 also introduced /end markers/, to make it easier to see where larger
  indented regions end.
  * /End markers/ consist of the keyword ~end~ followed by a /specifier token/,
    which is either an /identifier/ or a /keyword/.
    =NEXT=
    An example is shown in Listing 10.9.

** DONE Step 6. Iterate with ~foreach~ and ~for-do~ - 71
CLOSED: [2025-04-17 Thu 01:22]
- In the last step, we see a imperative way that uses ~while~ loops.

- Another (far more concise) way to print each command line argument is:
  #+begin_src scala
    @main def m(args: String*) =
      args.foreach(arg => println(arg))
  #+end_src
  This is more functional -- passing a /function literal/ to ~foreach~.

  Run it: ~scala pa.scala Concise is nice~ and see output:
  #+begin_src text
    Concise
    is
    nice
  #+end_src
  * More conciseness:
    #+begin_src scala
      @main def m(args: String*) =
        args.foreach(println)
    #+end_src

- Use ~for~ expression:
  #+begin_src scala
    @main def m(args: String*) =
      for arg <- args do
        println(arg)
  #+end_src
  * ~arg~ is always a ~val~ and that's why this syntax ignore that. It can be
    easily proved that you can't reassign it inside the body of the ~for~
    expression.
    * For each element of the ~args~ array, a *new* ~arg~ will be created and
      initialized to the element value, and the body of the ~for~ will be
      executed.

- More on ~for~ expressions in Step 12, Chapter 3, Section 7.3, and in
  _Advanced Programming in Scala_.

- footnote 12:
  You can say "in" for the ~<-~ symbol.
  You'd read ~for arg <- args do~, therefore, as _"for arg in args do."_

** DONE Conclusion - 73
CLOSED: [2025-04-17 Thu 01:09]

* TODO Learn more about scala-cli, the scala command since Scala 3.5
* TODO 3 Next Steps in Scala - 74
** TODO Step 7. Parameterize arrays with types - 74
** TODO Step 8. Use lists - 78
** TODO Step 9. Use tuples - 83
** TODO Step 10. Use sets and maps - 84
** TODO Step 11. Learn to recognize the functional style - 88
** TODO Step 12. Transform with ~map~ and ~for-yield~ - 91
** TODO Conclusion - 94

* TODO 4 Classes and Objects - 95
** 4.1 Classes, fields, and methods - 95
** 4.2 Semicolon inference - 99
** 4.3 Singleton objects - 100
** 4.4 Case classes - 103
** 4.5 A Scala application - 105
** 4.6 Conclusion - 107

* TODO 5 Basic Types and Operations - 108
** 5.1 Some basic types - 108
** 5.2 Literals - 109
** 5.3 String interpolation - 114
** 5.4 Operators are methods - 116
** 5.5 Arithmetic operations - 119
** 5.6 Relational and logical operations - 120
** 5.7 Bitwise operations - 121
** 5.8 Object equality - 122
** 5.9 Operator precedence and associativity - 124
** 5.10 Rich operations - 127
** 5.11 Conclusion - 127

* TODO 6 Functional Objects - 129
** 6.1 A specification for class ~Rational~ - 129
** 6.2 Constructing a ~Rational~ - 130
** 6.3 Reimplementing the ~toString~ method - 132
** 6.4 Checking preconditions - 133
** 6.5 Adding fields - 134
** 6.6 Self references - 136
** 6.7 Auxiliary constructors - 136
** 6.8 Private fields and methods - 138
** 6.9 Defining operators - 139
** 6.10 Identifiers in Scala - 141
** 6.11 Method overloading - 144
** 6.12 Extension methods - 146
** 6.13 A word of caution - 147
** 6.14 Conclusion - 147

* TODO 7 Built-in Control Structures - 149
** 7.1 If expressions - 150
** 7.2 While loops - 151
** 7.3 For expressions - 154
** 7.4 Exception handling with ~try~ expressions - 159
** 7.5 Match expressions - 163
** 7.6 Living without ~break~ and ~continue~ - 164
** 7.7 Variable scope - 166
** 7.8 Refactoring imperative-style code - 169
** 7.9 Conclusion - 171

* TODO 8 Functions and Closures - 172
** 8.1 Methods - 172
** 8.2 Local functions - 173
** 8.3 First-class functions - 175
** 8.4 Short forms of function literals - 176
** 8.5 Placeholder syntax - 177
** 8.6 Partially applied functions - 178
** 8.7 Closures - 181
** 8.8 Special function call forms - 183
** 8.9 “SAM” types - 186
** 8.10 Tail recursion - 188
** 8.11 Conclusion - 191

* TODO 9 Control Abstraction - 192
** 9.1 Reducing code duplication - 192
** 9.2 Simplifying client code - 196
** 9.3 Currying - 198
** 9.4 Writing new control structures - 199
** 9.5 By-name parameters - 202
** 9.6 Conclusion - 204

* TODO 10 Composition and Inheritance - 206
** 10.1 A two-dimensional layout library - 206
** 10.2 Abstract classes - 207
** 10.3 Defining parameterless methods - 208
** 10.4 Extending classes - 211
** 10.5 Overriding methods and fields - 213
** 10.6 Defining parametric fields - 214
** 10.7 Invoking superclass constructors - 216
** 10.8 Using ~override~ modifiers - 217
** 10.9 Polymorphism and dynamic binding - 219
** 10.10 Declaring ~final~ members - 221
** 10.11 Using composition and inheritance - 222
** 10.12 Implementing ~above~, ~beside~, and ~toString~ - 224
** 10.13 Defining a factory object - 226
** 10.14 Heighten and widen - 228
** 10.15 Putting it all together - 230
** 10.16 Conclusion - 233

* TODO 11 Traits - 234
  - /Traits/ are a _fundamental unit_ of code *reuse* in Scala.

  - A /trait/ encapsulates /method/ and /field/ definitions,
    which can then be reused by *mixing* them *into* /classes/.

  - This chapter shows you
    * how traits work
    * TWO of the most common ways they are useful:
      + widening thin interfaces to rich ones
      + defining stackable modifications

  - It also shows
    * *how to use* the ~Ordered~ /trait/
    * *compares* /traits/ to the /multiple inheritance/ of other languages.

** DONE 11.1 How traits work - 234
CLOSED: [2022-05-21 Sat 00:54]
- A /trait definition/ looks just LIKE a /class definition/
  EXCEPT that it uses the keyword ~trait~.

- If a /trait/ doesn't decllare a /superclass/, like a /class/,
  it has the _default superclass_ of ~AnyRef~.

- Once a /trait/ is defined,
  it can be *mixed in* to a /class/ using
  * either the keyword ~extends~
  * or the keyword ~with~,
  * or a comma.

- Scala programmers *“mix in”* /traits/ _RATHER THAN_ *inherit* from them,
  BECAUSE mixing in a /trait/ has *IMPORTANT DIFFERENCES* from the ~multiple
  inheritance~ found in many other languages. This issue is discussed in
  Section 11.4.
  =TODO=
  =TODO=
  =TODO=
  =TODO=
  =TODO=

- At this point you might philosophize that
  /traits/ are *like* /Java interfaces/ with /default methods/,
  BUT they can actually do much more -- /traits/ can, for example,
  * declare fields and maintain state.

- =IMPORTANT=
  You can do anything in a /trait definition/ that you can do in a
  /class definition/, and the syntax, except the keyword, looks
  _exactly the same_.

- =IMPORTANT=
  * The *KEY DIFFERENCE* between /classes/ and /traits/:
    + whereas in /classes/, ~super~ calls are _statically bound_,
    + in /traits/, they are _dynamically bound_.

  * For example,
    + if you write ~super.toString~ in a /class/, you know exactly which
      _method implementation_ will be invoked.

    + When you write the same thing in a /trait/,
      however, the method implementation to invoke for the ~super~ call
      _is *undefined* WHEN you define the /trait/._

      RATHER, *the implementation to invoke will be DETERMINED anew each time
      the /trait/ is mixed into a /CONCRETE class/.*

    =TODO=
    This curious behavior of ~super~ is key to allowing /traits/ to work as
    /stackable modifications/, which will be described in _Section 11.3_.
    =TODO=
    The rules for resolving ~super~ calls will be given in _Section 11.4_.

** 11.2 Thin versus rich interfaces - 237
- One major use of /traits/:
  automatically add /methods/ to a /class/ in terms of /methods/ the /class/
  _already has_ -- that is, /traits/ can enrich a *THIN interface*, making it
  into a *RICH interface*.

- *Thin* versus *rich* /interfaces/ represents a commonly faced trade-off in
  object-oriented design.

    The trade-off is BETWEEN _the implementers_ AND _the clients of an interface_.
  * A /rich interface/ has many /methods/, which make it convenient for the caller.
    Clients can pick a method that exactly matches the functionality they need.

  * A /thin interface/, on the other hand, has *fewer* /methods/, and thus is
    easier on _the implementers_.


 * Clients calling into a /thin interface/, however, have to write more code.
   Given the smaller selection of methods to call, they may have to choose a
   less than perfect match for their needs and write extra code to use it.

** 11.3 Traits as stackable modifications - 239
** 11.4 Why not multiple inheritance? - 243
** 11.5 Trait parameters - 248
** 11.6 Conclusion - 250
   

** ===========================
** DONE 12 Traits - 257
 CLOSED: [2018-03-21 Wed 23:51]
** ---------------------------
** DONE 12.2 Thin versus rich interfaces - 260
   CLOSED: [2017-10-12 Thu 03:17]
   =From Jian= Except the phase /Java interface/, *interface* by itself in this
   section is used to represent its general meaning, NOT something for a
   specific language.

   - One major use of /traits/ is to automatically add (concrete) /methods/ to a
     /class/ that extends it.

   - Thin vs Rich:
     Consider the trade-off between the _implementers_ and the _clients_ of an
     interface.

     + A *rich* interface
       has _MANY_ /methods/, which make it convenient for the _callers (clients)_
       -- they have more chance to find /methods/ that can fit their requirement
       exactly.

     + A *thin* interface,
       on the other hand, has _FEWER_ /methods/, and thus
       * it is easier for the _implementers_ whoes load is light.

       * more work are left for the _clients (clients)_, who call into a *thin*
         interface, however, have to write more code -- comparing the the *rich*
         interface, they have less chance to find /methods/ that can fit their
         requirement exactly -- they can choose to implement the thin interface
         required methods, or write a more fittable one -- either of them require
         their own coding.

   - Unlike in Java, adding a /concrete method/ to a /Scala trait/ is a *one-time
     effort* -- you only need to implement the /method/ once, in the /trait/
     itself, instead of needing to reimplement it for every /class/ that mixes in
     the /trait/.

     Thus, *rich* interfaces are _less_ work to provide in Scala than in a
     language without /traits/.

   - =From Jian=
     The discussion above about "Thin vs Rich" is a discussion in general.
     For Scala, even the /rich interface (trait)/ doesn't add load to the
     _implementer_, a reasonable ~trait~

     + has a *STILL* _small number_ of /abstract methods/ --
       the part the implementer need to finish -- the coding load is still light.

       This is _the (still) thin part_ of the trait's interface

       and

     - defines a potentially _large number_ of /concrete methods/,
       *ALL _implemented in terms of_ the /abstract methods/.*

     - then you can mix the enrichment /trait/ into a /class/, *implement the thin
       portion of the interface*, and end up with a /class/ that has all of the
       rich interface available.

** DONE 12.3 Example: Rectangular objects - 261
   CLOSED: [2017-10-12 Thu 01:21]
** DONE 12.4 The ~Ordered~ trait - 264
   CLOSED: [2017-10-12 Thu 01:38]
   Do comparison manually:

   footnote 1: This example is based on the ~Rational~ class shown in Listing 6.5
   on page 151, with ~equals~, ~hashCode~, and modifications to ensure a
   _positive_ ~denom~ added.
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) {
       def < (that: Rational) =
         this.numer * that.denom < that.numer * this.denom

       def > (that: Rational) = that < this

       def <= (that: Rational) = (this < that) || (this == that)

       def >= (that: Rational) = (this > that) || (this == that)
     }
   #+END_SRC

   Use the ~Ordered~ trait
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) extends Ordered[Rational] {
       //...
       def compare(that: Rational) =
         (this.numer * that.denom) - (that.numer * this.denom)
     }
   #+END_SRC

** DONE 12.5 Traits as stackable modifications - 266 =Re-Read=
   CLOSED: [2017-10-12 Thu 03:04]
   - One major use of traits:
     turning a thin interface into a rich one.

   - Now turn to a second major use of traits:
     providing stackable modifications to classes.

   - Traits let you modify the methods of a class, and they do so in a way that
     allows you to stack those modifications with each other (order matters).

   - As an example,
     _consider stacking modifications to a queue of integers_.

     + Two basic operations to the queue (FIFO):
       * ~put~
       * ~get~

     + Code:
       #+BEGIN_SRC scala
         abstract class IntQueue {
           def get(): Int
           def put(x: Int)
         }

         import scala.collection.mutable.ArrayBuffer

         class BasicIntQueue extends IntQueue {
           private val buf = new ArrayBuffer[Int]
           def get() = buf.remove(0)
           def put(x: Int) = { buf += x }
         }
       #+END_SRC

     + Given a class that implements such a queue, you could define traits to
       perform modifications such as these:
       * ~Doubling~: double all integers that are put in the queue
       * ~Incrementing~: increment all integers that are put in the queue
       * ~Filtering~: filter out negative integers from a queue

       These THREE traits represent /modifications/, because they modify the
       behavior of an underlying queue class rather than defining a full queue
       class themselves.

       The three are also /stackable/ -- you can select any of the three you
       like, mix them into a class, and obtain a new class that has all of the
       modifications you chose.

     + The implementations of three traits.
       #+BEGIN_SRC scala
         trait Doubling extends IntQueue {
           abstract override def put(x: Int) = { super.put(2 * x) }
         }

         trait Incrementing extends IntQueue {
           abstract override def put(x: Int) = { super.put(x + 1) }
         }

         trait Filtering extends IntQueue {
           abstract override def put(x: Int) = {
             if (x >= 0) super.put(x)
           }
         }
       #+END_SRC

       * If a /trait/ extends a class A, _ONLY_ classes that extends A can mix in
         this /trait/. For instance, you can mix ~Doubling~ into ~BasicIntQueue~,
         but NOT into ~Rational~.

       * If a /trait/ can have ~super~ call on a method declared ~abstract~.
         =TODO= =???=
         - Such calls are illegal for normal /classes/ because they will
           certainly fail at run time.
           =From Jian= since the current method ~m~ is ~abstract~, the ~m~
           method of the superclass is also ~abstract~.

         - For a trait, however, since ~super~ calls is dynamically bound, such a
           call can actually succeed.

         In this example the ~super~ call in ~trait Doubling~ will work so long
         as _the trait is mixed in after another trait or class that gives a
         concrete definition to the method_.

         This arrangement is frequently needed with traits that implement stackable
         modifications. To tell the compiler you are doing this on purpose, you
         must mark such methods as ~abstract override~. _This combination of
         modifiers is only allowed for members of traits, not classes_, and it
         means that the trait must be mixed into some class that has a concrete
         definition of the method in question.

     + Run and check the result:
       * Non-stacked
         #+BEGIN_SRC scala
           class MyQueue extends BasicIntQueue with Doubling

           val queue = new MyQueue
           // OR //
           // Use anonymous class `val queue = new BasicIntQueue with Doubling`

           queue.put(10)
           queue.get()
           // 20
         #+END_SRC

       * Stacked
         #+BEGIN_SRC scala
           val queue = (new BasicIntQueue
                            with Incrementing with Filtering)
           queue.put(-1)
           queue.put(0)
           queue.put(1)

           queue.get()
           // Int = 1
           queue.get()
           // Int = 2
         #+END_SRC

       * Stacked (different order)
         #+BEGIN_SRC scala
           val queue = (new BasicIntQueue
                            with Filtering with Incrementing)
           queue.put(-1)
           queue.put(0)
           queue.put(1)

           queue.get()
           // Int = 0
           queue.get()
           // Int = 1
           queue.get()
           // Int = 2
         #+END_SRC

     + Rules (roughly): =TODO= see the next section for details
       + traits further to the right take effect first.
         When you call a method on a class with mixins, the method in the trait
         furthest to the right is called first.

       + If that method calls ~super~, it invokes the method in the next trait to
         its left, and so on.

   - Since _the order of traits is significant_,
     you must keep eyes open for opportunities to arrange code as stackable
     modifications.

   - mixin :: a /trait/ that is _mixed into_ a /class/ (from footnote 2).

** DONE 12.6 Why not multiple inheritance? - 270
   CLOSED: [2018-03-21 Wed 23:13]
   /Traits/ are a way to inherit from multiple class-like constructs, but they
   *differ* in important ways from the /multiple inheritance/ present in many
   languages.

   - One _DIFFERENCE_ is especially important:
     the *interpretation* of ~super~.

   - The precise order of the /linearization/ is described in the *language
     specification*.

   - Example:
     #+BEGIN_SRC scala
       class Animal
       trait Furry extends Animal
       trait HasLegs extends Animal
       trait FourLegged extends HasLegs
       class Cat extends Animal with Furry with FourLegged
     #+END_SRC

     Left to Right:
     1. ~Animal~: ~Animal~ --> ~AnyRef~ --> ~Any~

     2. ~Furry~: ~Furry~ ===> ~Animal~ --> ~AnyRef~ --> ~Any~

     3. ~FourLegged~: ~FourLegged~ --> ~HasLegs~ ===> ~Furry~ ===> ~Animal~ --> ~AnyRef~ --> ~Any~

** DONE 12.7 To trait or not to trait? - 274 =IMPORTANT=
   CLOSED: [2018-03-21 Wed 23:50]
   There is *NO* firm rules about the choice of using /trait/ or /abstract class/
   for a specific use case. ONLY guidelines:

   - If the behavior will _NOT be reused_, then make it a /concrete class/. It
     is not reusable behavior after all.

   - If it might be reused in _multiple, *unrelated* classes_, make it a /trait/.
     Only traits can be mixed into different parts of the class hierarchy.

   - If you want to _inherit from it in Java code_, use an /abstract class/.
     Since traits with code do not have a close Java analog, it tends to be
     *AWKWARD* to _inherit from a trait in a Java class_.

     =TODO= Learn the conversion rules from Scala /trait/ to Java code!!! =TODO=

     Inheriting from a Scala class, meanwhile, is exactly like inheriting from a
     Java class.

     *As one EXCEPTION*,
     _a /Scala trait/ with only abstract members translates directly to a /Java
     interface/_, so you should feel free to define such /traits/ even if you
     expect Java code to inherit from it.
     =TODO= =IMPORTANT=
     See Chapter 31 for more information on working with Java and Scala together.

   - If you plan to _distribute it in compiled form_, and you expect outside groups
     to write classes inheriting from it, you might lean towards using an
     /abstract class/.

     The issue is that when a trait gains or loses a member, any classes that
     inherit from it must be recompiled, even if they have not changed.

     If outside clients will only call into the behavior, instead of inheriting
     from it, then using a trait is fine.

   - *Default Choice* if NOT used in Java code:
     If you _still do not know, after considering the above_,
     then START BY making it as a /trait/.

     You can always change it later, and in general using a /trait/ _keeps more
     options open_.

** DONE 12.8 Conclusion - 275
   CLOSED: [2017-10-12 Thu 03:39]
   _Mix in multiple traits_ are similar to /multiple inheritance/.
   But because /traits/ interpret ~super~ using /linearization/, they both
   + _AVOID_ some of the difficulties of traditional multiple inheritance
     and
   + _ALLOW_ you to stack behaviors.

* TODO 12 Packages, Imports, and Exports - 251 - _READING_
- When working on a program, especially a large one, it is important to
  *minimize* /coupling/ -- the extent to which the various parts of the program
  rely on the other parts. _LOW coupling_ *reduces* the risk that a small,
  seemingly innocuous change in one part of the program will have devastating
  consequences in another part.

- *One way to minimize coupling is to write in a modular style*:
  You divide the program into a number of smaller modules, each of which has an
  *inside* and an *outside*.
  * When working on the inside of a module -- its implementation -- you need
    only coordinate with other programmers working on that very same module.

  * Only when you must change the outside of a module -- its interface -- is it
    necessary to coordinate with developers working on other modules.

- *This chapter shows several constructs that help you program in a /modular style/.*
  It shows
  1. how to place things in packages,
  2. make names visible through imports, and
  3. control the visibility of definitions through access modifiers.

  The constructs are _similar in spirit to_ constructs in Java,
  _BUT_ there are some differences -- _usually ways that are more consistent_ --
  so it's worth reading this chapter even if you already know Java.
  =from Jian=
  Add more details

** DONE 12.1 Putting code in packages - 251
CLOSED: [2025-04-16 Wed 11:47]
Scala code resides in _the Java platform's global hierarchy of packages._

- The example code you've seen so far in this book has been in the /unnamed
  package/.

- =IMPORTANT=
  It is recommended to follow Java's reverse-domain-name convention for Scala
  packages that you release to the public.

  * Here, we (=from Jian= the book) use a shorter form in the following
    examples. A better name is like ~com.bobsrockets.navigation~.

- You can place code into /named packages/ in Scala in _TWO_ ways:
  1. =from Jian= *The Java way!*
     You can place the contents of an *ENTIRE file* into a /package/
     _BY_
     putting a /package clause/ at the top of the file, as shown in _Listing
     12.1_:
     #+begin_src scala
       package bobsrockets.navigation

       class Navigator
       // ...
     #+end_src
     Listing 12.1 · Placing the contents of an entire file into a package.

  2. The other way you can place code into /packages/ in Scala is more LIKE /C#
     namespaces/: follow a /package clause/ by a _colon_ and an _indented_
     section of code containing the definitions that go into the /package/.

     =from Jian= Current book emphasize brace-less syntax. The syntax with
     braces in Scala 2 is the *same* as the syntax in C#, *not just like.*

     *This syntax is called a /packaging/.*
     =FIXME= Remove a???

     _Listing 12.2_ has the same effect as the code in _Listing 12.1_:
     #+begin_src scala
       package bobsrockets.navigation:
         class Navigator
     #+end_src
     Listing 12.2 · Long form of a simple package declaration.

- Usage:
  * For such simple examples, you might as well use the /syntactic sugar/ shown in
    Listing 12.1.
    =FIXME=
    =from Jian= Before this line, the book doesn't mention the second form is
    the /syntactic sugar/ of the first form.

  * However, one use of _the *more general* notation_ is to have different parts
    of _A_ file in different /packages/.
    + For example, if you want to email or post to a discussion forum a snippet
      of Scala code that involves SEVERAL /packages/, you can use /packaging/,
      as shown in Listing 12.3.
    #+begin_src scala
      package bobsrockets:
        package navigation:
          // In package bobsrockets.navigation
          class Navigator
          package launch:
            // In package bobsrockets.navigation.launch
            class Booster

          class Navigator2 // Added by me, Jian Lan, just for this note
    #+end_src
    Listing 12.3 · Multiple packages in the same file.

    + =IMPORTANT=
      =from Jian=
      This syntax has an _VARIANT_, which is simpler -- no colons and
      indentations, but has one *limitation*. It is called /chained package
      clauses/, which is mentioned in the next section.

      Here is a rewritten of Listing 12.3 code in /chained package clauses/
      syntax, and ~Navigator~ and ~Navigator2~ can't show up in the old place!
      #+begin_src scala
        package bobsrockets
        package navigation
        package launch

        // In package bobsrockets.navigation.launch
        class Booster
      #+end_src

** DONE 12.2 Concise access to related code - 252
CLOSED: [2025-04-16 Wed 12:37]
- When code is divided into a /package hierarchy/,
  * it doesn't just help people browse through the code.
  * It also tells the compiler that code in the SAME /package/ is related in
    some way to each other.

- Scala takes advantage of this relatedness by allowing _short, unqualified
  names_ when accessing code that is in the SAME /package/ -- =from Jian= only
  when not using the _One package per file_ way.

  * Different ways of packaging affect the way of using names outside _CURRENT_
    package:
    + If you use _one package per file_ way, the name outside current package must be
      imported before using.
      - =from Jian=
        Same as in Java! This rule very simple but may result in redundant code
        in some scenarios.

    + *Explicitly* nest the packagings:
      #+begin_src scala
        package bobsrockets:
          package navigation:
            class Navigator:
              // No need to say bobsrockets.navigation.StarMap
              val map = new StarMap

            class StarMap

          class Ship:
            // No need to say bobsrockets.navigation.Navigator
            val nav = new navigation.Navigator

          package fleets:
            class Fleet:
              // No need to say bobsrockets.Ship
              def addShip = new Ship
      #+end_src
      Listing 12.4 · Concise access to classes and packages.

      _Inner packages_ can see names in the _same package_ and in its _packages
      that wrap it_.

      - A variant:
        the /chained package clauses/ syntax.

    + *NOT Explicitly* nest the packagings:
      #+begin_src scala
        package bobsrockets:
          class Ship

        package bobsrockets.fleets:
          class Fleet:
            // Doesn't compile! Ship is not in scope.
            def addShip = new Ship
      #+end_src
      Listing 12.5 · Symbols in enclosing packages not automatically available.

      =from Jian=
      Logically, one package include another one, but not in actual code.
      A name in the "outside" pcakge is not automatically visible by the "inner"
      package. _For visibility, only "logically nested" is NOT enough._

  * ~_root_~:
    Scala must handle /package name hiding issue/ because of the support to
    package organization not in the form of _one package per file_:
    #+begin_src scala
      // In file launch.scala
      package launch:
        class Booster3

      // In file bobsrockets.scala
      package bobsrockets:
        package launch:
          class Booster2

        package navigation:
          package launch:
            class Booster1

          class MissionControl:
            val booster1 = new launch.Booster1
            val booster2 = new bobsrockets.launch.Booster2
            val booster3 = new _root_.launch.Booster3
    #+end_src
    If no ~_root_~, there is no way to express ~booster3~ value.

** DONE 12.3 Imports - 256
CLOSED: [2025-04-16 Wed 13:10]
- Simple imports that you can find their counterparts in Java:
  #+begin_src scala
    // easy access to Fruit
    import bobsdelights.Fruit

    // easy access to all members of bobsdelights
    import bobsdelights.*

    // easy access to all members of Fruits
    import bobsdelights.Fruits.*
  #+end_src
  Coresponds to Java's
  1. single type import
  2. on-demand imports
  3. import of static class fields

- _Scala's flexible imports_
  Scala's ~import~ clauses are quite a bit more flexible than Java's. There are
  three principal differences. In Scala, imports:
  * may appear anywhere
  * may refer to objects (singleton or regular) in addition to packages
  * let you rename and hide some of the imported members

- *Scala can import any value memebers!*
  #+begin_src scala
    val fruit = Fruit(..)

    def showFurit(fruit: Fruit) =
      import fruit.*
      s"${name}s are $color"
  #+end_src

- /import selector clause/ examples:
  * ~import Fruits.{Apple, Orange}~

  * ~import Fruits.{Apple as McIntosh, Orange}~
    ~import java.sql.Date as SDate~
    with renaming.

  * ~import Fruits.{Apple as _, *}~
    Import everything except ~Apple~
    + =from Jian=
      =IMPORTANT=
      =IMPORTANT=
      =IMPORTANT=
      I think this syntax is not good, it can create a import clause like:
      ~import Fruits.{Apple as _, Orange}~ which hiding is useless!

      How about introduce a syntax like (need a new soft keyword ~except~):
      ~import Fruits.* except Apple~
      ~import Fruits.* except {Apple, Orange}~

      and make the linter warns the programmer that try to use this syntax
      instead of the ~as _~ one or just deprecate the ~as _~ import syntax?!

** DONE 12.4 Implicit imports - 259
CLOSED: [2025-04-16 Wed 14:05]
Scala adds some imports _implicitly_ to _every_ program.
In essence, it is as if
the following three import clauses had been added to the top of every source
file with extension ".scala":

#+begin_src scala
  import java.lang.* // everything in the java.lang package
  import scala.*     // everything in the scala package
  import Predef.*    // everything in the Predef object
#+end_src
- The ~java.lang~ package contains standard Java classes.

- As you have no doubt realized by now, the ~scala~ package contains the
  standard Scala library, with many common classes and objects.

- The ~Predef~ object contains many definitions of
  * /type aliases/,
  * /methods/, and
  * /conversions/
  that are commonly used on Scala programs.

These _THREE_ import clauses are treated *a bit specially* in that later imports
_overshadow_ earlier ones.

- For instance,
  the ~StringBuilder~ class is defined _BOTH in package ~scala~ and ~java.lang~._
  Because the scala import *overshadows* the ~java.lang~ import, the simple name
  ~StringBuilder~ will refer to ~scala.StringBuilder~, *NOT*
  ~java.lang.StringBuilder~.

** TODO 12.5 Access modifiers - 260 - = =RE-READ: Scope of protection=
Access modifiers ~private~ and ~protected~.

Scala's treatment of /access modifiers/ roughly follows Java's
_BUT_ there are *some important differences* which are explained in this
section.

*** Private members - 260
A member labeled ~private~ is visible only inside the /class/ or /object/ that
contains the member definition.

DIFFERENCES between Scala and Java:

- In Scala, inner class private members only belongs to itself, its host /class/
  or /object/ *CANNOT* access them.

  #+begin_src scala
    class Outer:
      class Inner:
        private def f = "f"
        class InnerMost:
          f // OK

      (new Inner).f // error: f is not accessible
  #+end_src
  Listing 12.10 · How private access differs in Scala and Java.

- In Java, inner class private members can be accessed.
  (If the code above is in Java) Java would permit *BOTH accesses* because it
  lets an _outer class_ access private members of its _inner classes_.

*** Protected members - 261
Access to /protected members/ in Scala is also a bit *more restrictive* than in
Java.

#+begin_src scala
  package p:
    class Super:
      protected def f = "f"

    class Sub extends Super:
      f

    class Other:
        (new Super).f // error: f is not accessible
#+end_src
Listing 12.11 · How protected access differs in Scala and Java.

DIFFERENCES between Scala and Java:

- In Scala,
  a /protected member/ is ONLY accessible from /subclasses/ of the /class/ in
  which the member is defined.

- In Java
  such accesses are also possible _from other /classes/ in the *same*
  /package/._
  * In Scala, there is another way to achieve this effect.

*** Public members - 262
Scala has _no explicit modifier_ for /public members/: Any member not labeled
~private~ or ~protected~ is _public_. /Public members/ can be accessed from
anywhere.

*** Scope of protection - 262
/Access modifiers/ in Scala can be *AUGMENTED* with qualifiers.

- A modifier of the form ~private[X]~ or ~protected[X]~ means
  access is _private_ or _protected_ "up to" ~X~, where ~X~ designates some
  enclosing package, class or singleton object.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  /Qualified access modifiers/ give you very _fine-grained control_ over
  /visibility/.

  * In particular they enable you to express Java's accessibility notions,
    such as
    + package private,
    + package protected, or
    + private up to outermost class,

    which are _not directly expressible_ with simple modifiers in Scala.
    But they also let you express accessibility rules that cannot be expressed
    in Java.

- Listing 12.12 · Flexible scope of protection with access qualifiers.
  #+begin_src scala
    package bobsrockets

    package navigation:
      private[bobsrockets] class Navigator:
        protected[navigation] def useStarChart() = {}
        class LegOfJourney:
          private[Navigator] val distance = 100

    package launch:
      import navigation.*
      object Vehicle:
        private[launch] val guide = new Navigator
  #+end_src
  * ~class Navigator~ is labeled ~private[bobsrockets]~.
    This means that
    this /class/ is visible in all /classes/ and /objects/ that are *contained
    in package ~bobsrockets~.*

    + This is why ~object Vehicle~ can access to ~Navigator~.

- This technique is quite useful in large projects that span several packages.
  It allows you to define things that are visible in several sub-packages of
  your project but that remain hidden from clients external to your project.

- Of course, the qualifier of a ~private~ may also be the /directly enclosing
  package/. An example is the access modifier of ~guide~ in ~object Vehicle~ in
  Listing 12.12. Such an /access modifier/ is equivalent to /Java's package
  private access/.

- All qualifiers can also be applied to ~protected~, with the same meaning as
  ~private~.

  * ~protected[X]~ in a ~class C~ allows access to the labeled definition in all
    /subclasses/ of ~C~ and also within _the ENCLOSING /package/, /class/, or
    /object/ ~X~._

    For instance,
    the ~useStarChart~ method in Listing 12.12 is accessible in all /subclasses/
    of ~Navigator~ and also in all code contained in the /enclosing package/
    ~navigation~.

    It thus corresponds _exactly to the meaning of ~protected~ in Java._

- The qualifiers of ~private~ can also refer to _an ENCLOSING /class/ or
  /object/._

  For instance the ~distance~ variable in class ~LegOfJourney~ in Listing 12.12
  is labeled ~private[Navigator]~, so it is visible from everywhere in class
  ~Navigator~.

  *This gives the SAME ACCESS capabilities as for
  _private members of inner classes in Java_.*

  A ~private[C]~ where ~C~ is the _outermost enclosing class_ is the same as
  _just ~private~ in Java._

- To summarize, Table 12.1 on page 263 lists the effects of /private
  qualifiers/. Each line shows a /qualified private modifier/ and what it would
  mean if such a modifier were attached to the ~distance~ variable declared in
  ~class LegOfJourney~ in Listing 12.12.

  Table 12.1 · Effects of private qualifiers on ~LegOfJourney.distance~
  | no access modifier      | public access                      |
  |-------------------------+------------------------------------|
  | ~private[bobsrockets]~  | access within outer package        |
  | ~private[navigation]~   | same as package visibility in Java |
  | ~private[Navigator]~    | same as ~private~ in Java          |
  | ~private[LegOfJourney]~ | same as ~private~ in Scala         |

*** Visibility and companion objects - 264
Listing 12.13: Accessing _private members_ of /companion classes and objects/.
#+begin_src scala
  class Rocket:
    import Rocket.fuel
    private def canGoHomeAgain = fuel > 20

  object Rocket:
    private def fuel = 10
    def chooseStrategy(rocket: Rocket) =
      if rocket.canGoHomeAgain then
        goHome()
      else
        pickAStar()

    def goHome() = {}
    def pickAStar() = {}
#+end_src

- Scala's access rules privilege companion objects and classes when it comes to
  ~private~ or ~protected~ accesses.

  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  _A /class/ *shares all its access rights* with its /companion object/ and vice
  versa._

- One *EXCEPTION* where the similarity between Scala and Java breaks down concerns
  ~protected static~ members.
  * In Java, _a ~protected static~ member_ of a Java ~class C~ can be accessed in
    ALL /subclasses/ of ~C~.

  * By contrast,
    a ~protected~ member in a /companion object/ *makes no sense*, as singleton objects
    *don't have any* /subclasses/.
    + =from Jian= a ~protected~ member in a /companion object/ is always static!

    + =from Jian=
      =IMPORTANT=
      _NOT DISCUSSED IN DETAILS IN THE BOOK, HERE IS MY THINKING!_
      I guess here *makes no sense* means *makes no sense to consider
      its subclasses accessibility* Since Scala doesn't forbid it, it might be
      useful by itself.

      - Q :: Then why do Scala still allow /protected memebers/ in companion objects
             in syntax?
      - A :: In Scala, any ~object~ can extends /classes/ or /traits/, which can have
             /protected memebers/ that, of course, can be *overrided*.

             This is the reason in syntax:
             #+begin_src scala
               class X:
                 def bar(): Unit =
                   X.foo()

               class XX:
                 protected def foo(): Unit =
                   println("Here is XX!")

               object X extends XX:
                 override protected def foo(): Unit =
                   super.foo()
                   println("Here is the `X` companion object, a subclass of `XX`!")
             #+end_src

             Since the ~protected~ must be overrided by a ~protected~, there is
             no way to forbid ~protected~ from /companion object/'s or any other
             /object/'s.

** DONE 12.6 Top-level definitions - 265
CLOSED: [2025-04-16 Wed 16:26]
*Any* kind of definition that you can put inside a /class/ can also be at the
top level of a /package/.

- Top-level definitions are frequently used to hold
  * /package-wide helper functions/ (mentioned in the last paragraph, and =Jian=
    move it to here)
  * /package-wide type aliases/ (Chapter 20)
  * /extension methods/ (Chapter 22).

- The ~scala~ package includes top-level definitions, which are available to all
  Scala code.

- =from Jian=
  /package object/ in Scala 2 is no longer needed.

** DONE 12.7 Exports - 266
CLOSED: [2025-04-16 Wed 20:34]
- In Section 10.11 we recommended that
  you should _PREFER /composition/ OVER /inheritance/,_
  * ESPECIALLY when your primary goal is *code reuse*.

- _PREFER /composition/ OVER /inheritance/_ is an application of /the principle
  of least power/:
  /Composition/ treats components as blackboxes
  whereas
  /inheritance/ can affect the internal workings of components through
  /overriding/.

  * Sometimes the _tight coupling_ implied by /inheritance/ is the best solution
    for a problem,
    _BUT_ where this is not necessary the /looser coupling/ of /composition/ is
    better.
    (=from Jian= more than 90% use cases)

- In most popular object-oriented programming languages it is easier to use
  /inheritance/ than /composition/. =from Jian= This is BAD!

  In Scala 2, for example,
  /inheritance/ only required an ~extends~ clause
  whereas /composition/ required _a verbose elaboration of a sequence of
  forwarders_.

  * =IMPORTANT=
    _CONCLUSION_:
    Most object-oriented languages have, therefore, been pushing programmers to
    a solution that is often too powerful.

- /Exports/, a new feature introduced in Scala 3, aim to redress this imbalance.
  * /Exports/ make /composition relationships/ *as concise and easy to express as*
    /inheritance relationships/.
    + =from Jian=
      If there a way that can make /composition relationships/ more easier, it
      will be a perfect solution. =HowTo???=

  * /Exports/ also offer _more flexibility than_ ~extends~ clauses,
    since members can be *renamed* or *omitted*.

- Example:
  #+begin_src scala
    case class PosInt(value: Int):
      require(value > 0)
      export value.{<< as shl, >> as shr, >>> as _, *}
  #+end_src
  ~PosInt~ has almost all methods of ~Int~ but not ~>>>~.
  Renames renames << and >>, and drop their symbolic names.

** DONE 12.8 Conclusion - 269
CLOSED: [2025-04-16 Wed 20:50]
- In this chapter, you saw the basic constructs for dividing a program into
  /packages/.

  This gives you a simple and useful kind of /modularity/,
  so that
  you can work with very large bodies of code without different parts of the
  code trampling on each other.

- Scala's (=FIXME= packages instead of system) system is _the same in spirit_ as
  Java's packages, but there are _some differences_ where Scala chooses to be
  more consistent or more general.

- New feature: /exports/.
  It aims to make /composition/ as convenient as /inheritance/ for code reuse.

- =???=
  =TODO=
  =IMPORTANT=
  Looking ahead, Advanced Programming in Scala describes a more flexible module
  system than division into packages.

  * In addition to letting you separate code into several namespaces, that
    approach allows modules to be /parameterized/ and /inherit/ from each other.

- =NEXT=
  In the next chapter, we'll turn our attention to /pattern matching/.

* TODO 13 Pattern Matching - 270
** TODO 13.1 A simple example - 270
*** Case classes - 271
*** Pattern matching - 272
*** ~match~ compared to ~switch~ - 274

** TODO 13.2 Kinds of patterns - 274
*** Wildcard patterns - 275
*** Constant patterns - 275
*** Variable patterns - 276
*** Constructor patterns - 278
*** Sequence patterns - 279
*** Tuple patterns - 279
*** Typed patterns - 280
*** Variable binding - 284
- =from Jian=
  =IMPORTANT=
  Should add a string interploation-like variable binding form added in some
  version of Scala 2.12 or 2.13.
  #+begin_src scala
    "x y x" match {
      case s"x $y x" => y
      case _ => "z"
    }
    // y
  #+end_src

** TODO 13.3 Pattern guards - 284
** TODO 13.4 Pattern overlaps - 285
** TODO 13.5 Sealed classes - 287
** TODO 13.6 Pattern matching ~Option~'s - 289
** TODO 13.7 Patterns everywhere - 291
*** Patterns in variable definitions - 291
*** Case sequences as partial functions - 291
*** Patterns in for expressions - 294

** TODO 13.8 A larger example - 295
** TODO 13.9 Conclusion - 303

* TODO 14 Working with Lists - 304
** TODO 14.1 List literals - 304
** TODO 14.2 The ~List~ type - 305
** TODO 14.3 Constructing lists - 305
** TODO 14.4 Basic operations on lists - 306
** TODO 14.5 List patterns - 307
** TODO 14.6 First-order methods on class ~List~ - 309
*** Concatenating two lists - 309
*** The Divide and Conquer principle - 310
*** Taking the length of a list: ~length~ - 311
*** Accessing the end of a list: ~init~ and ~last~ - 312
*** Reversing lists: ~reverse~ - 312
*** Prefixes and suffixes: ~drop~, ~take~, and ~splitAt~ - 314
*** Element selection: ~apply~ and ~indices~ - 314
*** Flattening a list of lists: ~flatten~ - 315
*** Zipping lists: ~zip~ and ~unzip~ - 315
*** Displaying lists: ~toString~ and ~mkString~ - 316
*** Converting lists: ~iterator~, ~toArray~, ~copyToArray~ - 317
*** Example: Merge sort - 318

** TODO 14.7 Higher-order methods on class ~List~ - 320
*** Mapping over lists: ~map~, ~flatMap~ and ~foreach~ - 320
*** Filtering lists: ~filter~, ~partition~, ~find~, ~takeWhile~, ~dropWhile~, and ~span~ - 322
*** Predicates over lists: ~forall~ and ~exists~ - 323
*** Folding lists: ~foldLeft~ and ~foldRight~ - 324
*** Example: List reversal using ~fold~ - 326
*** Sorting lists: ~sortWith~ - 327

** TODO 14.8 Methods of the ~List~ object - 327
*** Creating lists from their elements: ~List.apply~ - 328
*** Creating a range of numbers: ~List.range~ - 328
*** Creating uniform lists: ~List.fill~ - 328
*** Tabulating a function: ~List.tabulate~ - 329
*** Concatenating multiple lists: ~List.concat~ - 329

** TODO 14.9 Processing multiple lists together - 329
** TODO 14.10 Understanding Scala's type inference algorithm - 331
** TODO 14.11 Conclusion - 334

* TODO 15 Working with Other Collections - 335
** 15.1 Sequences - 335
*** Lists - 335
*** Arrays - 336
*** List buffers - 337
*** Array buffers - 337
*** Strings (via ~StringOps~) - 338

** 15.2 Sets and maps - 339
*** Using sets - 340
*** Using maps - 342
*** Default sets and maps - 344
*** Sorted sets and maps - 345

** 15.3 Selecting mutable versus immutable collections - 346
** 15.4 Initializing collections - 348
*** Converting to array or list - 350
*** Converting between mutable and immutable sets and maps - 351

** 15.5 Tuples - 351
** 15.6 Conclusion - 353

* TODO 16 Mutable Objects - 355
** 16.1 What makes an object mutable? - 355
** 16.2 Reassignable variables and properties - 357
** 16.3 Case study: Discrete event simulation - 361
** 16.4 A language for digital circuits - 362
** 16.5 The ~Simulation~ API - 365
** 16.6 Circuit Simulation - 369
*** The ~Wire~ class - 369
*** The ~inverter~ method - 372
*** The ~andGate~ and ~orGate~ methods - 373
*** Simulation output - 374
*** Running the simulator - 374

** 16.7 Conclusion - 376

* TODO 17 Scala's Hierarchy - 378
** 17.1 Scala’s class hierarchy - 378
** 17.2 How primitives are implemented - 382
** 17.3 Bottom types - 384
** 17.4 Defining your own value classes - 385
*** Avoiding a types monoculture - 386

** 17.5 Intersection types - 388
** 17.6 Union types - 389
** 17.7 Transparent traits - 392
** 17.8 Conclusion - 393

* TODO 18 Type Parameterization - 394
** 18.1 Functional queues - 394
** 18.2 Information hiding - 397
*** Private constructors and factory methods - 398
*** An alternative: private classes - 399

** 18.3 Variance annotations - 400
*** Variance and arrays - 403

** 18.4 Checking variance annotations - 405
** 18.5 Lower bounds - 408
** 18.6 Contravariance - 409
** 18.7 Upper bounds - 413
** 18.8 Conclusion - 415

* TODO 19 Enums - 416
Scala 3 introduced the ~enum~ construct to make the definition of
/sealed case class/ hierachies _more concise_.

- /Enums/ can be used to define both /enums/ (enumerated data types) in
  mainstream OO languages, and /enums/ (ADT) in FP languages.

** DONE 19.1 Enumerated data types - 416
CLOSED: [2021-03-02 Tue 23:02]
- =from Jian=:
  In this book, we call the /enumerated data type/ *EDT*, to distinguish it
  from *ADT*'s.

- An enumerated data type, or “EDT,”1 is useful when you want a type that’s
  restricted to a finite set of named values. These named values are called
  the cases of the EDT.
  =RE-NOTE= =DUPLICATION=

- Example:
  #+begin_src scala
    enum Direction:
      case North, East, South, West

    import Direction.{North, South, East, West}

    def invert(dir: Direction): Direction =
      dir match
        case North => South
        case East  => West
        case South => North
        case West  => East
  #+end_src

- ~enum~'s build-in methods:
  * ~ordinal~: start at 0 and increases by one for each case, in the order the
    cases are defined in the /enum/.
    + The REASON why /Enumerated data types/ are called "enumerated":
      the compiler associates an ~Int~ /ordinal/ to each /case/.


  * ~values~: ~Array[YourEnumType]~

  * ~valueOf~: Convert a string, which is exactly the same as an enum case name,
    to that enum value.

- Give an EDT value parameter(s):
  #+begin_src scala
    enum Direction(val degrees: Int):
      case North extends Direction(0)
      case East  extends Direction(90)
      case South extends Direction(180)
      case West  extends Direction(270)
  #+end_src

- You can define a /method/ inside a /enum/:
  #+begin_src scala
    enum Direction(val degrees: Int):
      case North extends Direction(0)
      case East  extends Direction(90)
      case South extends Direction(180)
      case West  extends Direction(270)

      def invert: Direction =
        this match
          case North => South
          case East  => West
          case South => North
          case West  => East
  #+end_src
  * =TODO= NOTE

- =TODO= NOTE
  * You can only define /methods/ for a whole /enum/, not for some SPECIFIC
    /enum case(s)/.

  * *footnote*:
    Of course, you COULD define /extension methods/ for the case types, but it
    might be better in that situation to just write out the /sealed case
    class hierarchy/ by hand.

- *Integration with Java enums*
  #+begin_src scala
    enum Direction extends java.lang.Enum[Direction]:
      case North, East, South, West
  #+end_src

  Then you can all /Java enums/ /methods/ on these values. For instance,
  ~Direction.East.compareTo(Direction.South)  // -1~

** DONE 19.2 Algebraic data types - 420
CLOSED: [2021-03-03 Wed 00:53]
- Algebraic Data Type (ADT) :: a data type composed of a finite set of cases.

- In Scala, a _sealed_ family of /case classes/ forms an /ADT/
  so long as *AT LEAST _ONE_ of the cases take parameters.*
  * footnote:
    By comparison,
    an EDT is a _sealed_ family of /case classes/ in which *NONE of the cases
    take parameters.*

- When you create a case of an /ADT/ by using its /factory method/ (=from Jian=
  the ~apply~ /method/), the compiler will *widen* its type to the more general
  ~enum~ type.
  * If you want the more specific type, use the constructor (~new~ it).

- /ADT/'s can be *recursive*.
  * =from Jian=
    /EDT/'s can never be recursive, because *NONE of the cases take parameters.*

- Example:
  #+begin_src scala
    enum Seinfeld[+E]:
      def ::[E2 >: E](o: E2): Seinfeld[E2] = Yada(o, this)

      case Yada(head: E, tail: Seinfeld[E])
      case Nada

    val xs = 1 :: 2 :: 3 :: Nada
    // val xs = Yada(1, Yada(2, Yada(3, Nada)))
  #+end_src

** DONE 19.3 Generalized ADTs - 422
CLOSED: [2021-03-03 Wed 01:44]
- Generalized Algebraic Data Types (GADTs) :: ADTs in which the sealed trait
  takes a /type parameter/ that is filled in by the cases.

- Example:
  #+begin_src scala
    enum Literal[T]:
      case IntLit(value: Int)         extends Literal[Int]
      case LongLit(value: Long)       extends Literal[Long]
      case CharLit(value: Char)       extends Literal[Char]
      case FloatLit(value: Float)     extends Literal[Float]
      case DoubleLit(value: Double)   extends Literal[Double]
      case BooleanLit(value: Boolean) extends Literal[Boolean]
      case StringLit(value: String)   extends Literal[String]
  #+end_src
  The ~Literal~ /enum/ represents a /GADT/ because it takes a /type parameter/
  ~T~, which is specified by EACH of its cases in their _extends clauses_.

- =IMPORTANT=
  This kind of /sealed type heirarchy/ is given the special name "generalized ADT"
  because it presents *SPECIAL CHALLENGES to /type checking and inference/.*
  * Here's an illustrative example:
    #+begin_src scala
      import Literal.*

      def valueOfLiteral[T](lit: Literal[T]): T =
        lit match
          case IntLit(n)     => n
          case LongLit(m)    => m
          case CharLit(c)    => c
          case FloatLit(f)   => f
          case DoubleLit(d)  => d
          case BooleanLit(b) => b
          case StringLit(s)  => s
    #+end_src
    The ~valueOfLiteral~ /method/ passes the /type checker/, despite none of
    it match alternatives resulting in the required result type, ~T~.
    + For example,
      =FIXME= IntList => IntLit
      the ~case IntLit(n)~ alternative results in ~n~, which has type ~Int~.
      The challenge is that ~Int~ is not type ~T~, nor is ~Int~ a /subtype/ of ~T~.
        This /type checks/ only because the compiler notices that for the
      ~IntLit~ case, ~T~ can be none other than ~Int~.
        Moreover, this _MORE SPECIFIC_ /type/ is propagated back to the caller.
      #+begin_src scala
        valueOfLiteral(BooleanLit(true))  // true: Boolean
        valueOfLiteral(IntLit(42))        // 42: Int
      #+end_src

** 19.4 What makes ADTs algebraic - 423 - =RE-READ= =NOTE=
** 19.5 Conclusion - 427

* TODO 20 Abstract Members - 428
** 20.1 A quick tour of abstract members - 428
** 20.2 Type members - 429
** 20.3 Abstract ~val~'s - 430
** 20.4 Abstract ~var~'s - 430
** 20.5 Initializing abstract ~val~'s - 432
*** Trait parametric fields - 434
*** Lazy vals - 435

** 20.6 Abstract types - 439
** 20.7 Path-dependent types - 441
** 20.8 Refinement types - 444
** 20.9 Case study: Currencies - 445
** 20.10 Conclusion - 453

* TODO 21 Givens - 455
** 21.1 How it works - 455
** 21.2 Parameterized given types - 459
** 21.3 Anonymous givens - 464
** 21.4 Parameterized givens as typeclasses - 465
** 21.5 Given imports - 468
** 21.6 Rules for context parameters - 469
*** Naming a given - 471

** 21.7 When multiple givens apply - 472
** 21.8 Debugging givens - 474
** 21.9 Conclusion - 476

* TODO 22 Extension Methods - 477
** 22.1 The basics - 477
** 22.2 Generic extensions - 480
** 22.3 Collective extensions - 481
** 22.4 Using a typeclass - 484
** 22.5 Extension methods for givens - 486
** 22.6 Where Scala looks for extension methods - 490
** 22.7 Conclusion - 491

* TODO 23 Typeclasses - 493
** 23.1 Why typeclasses? - 493
** 23.2 Context bounds - 498
** 23.3 Main methods - 501
** 23.4 Multiversal equality - 505
** 23.5 Implicit conversions - 511
** 23.6 Typeclass case study: JSON serialization - 514
*** Importing an extension method - 516
*** Serializing domain objects - 517
*** Serializing lists - 519
*** Putting it all together - 521

** 23.7 Conclusion - 523

* TODO 24 Collections in Depth - 525
** 24.1 Mutable and immutable collections - 526
** 24.2 Collections consistency - 528
** 24.3 Trait ~Iterable~ - 530
** 24.4 The sequence traits ~Seq~, ~IndexedSeq~, and ~LinearSeq~ - 537
** 24.5 Sets - 544
** 24.6 Maps - 548
** 24.7 Concrete immutable collection classes - 552
** 24.8 Concrete mutable collection classes - 559
** 24.9 Arrays - 564
** 24.10 Strings - 568
** 24.11 Performance characteristics - 569
** 24.12 Equality - 571
** 24.13 Views - 572
** 24.14 Iterators - 576
** 24.15 Creating collections from scratch - 584
** 24.16 Conversions between Java and Scala collections - 586
** 24.17 Conclusion - 588

* TODO 25 Assertions and Tests - 589
** 25.1 Assertions - 589
** 25.2 Testing in Scala - 591
** 25.3 Informative failure reports - 592
** 25.4 Tests as specifications - 594
** 25.5 Property-based testing - 597
** 25.6 Organizing and running tests - 599
** 25.7 Conclusion - 600

* Glossary - 601
* Bibliography - 617
* About the Authors - 621
* Index - 622
