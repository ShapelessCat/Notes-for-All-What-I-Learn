#+TITLE: Programming in Scala
#+SUBTITLE: A comprehensive step-by-step guide - Updated for Scala 3.0
#+VERSION: 5th
#+AUTHOR: Martin Odersky, Lex Spoon, Bill Venners, Frank Sommers
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Contents - xi
* List of Figures - xix
* List of Tables - xxi
* List of Listings - xxiii
* TODO Foreword - xxix - _TAKE NOTES_
- New programming languages are created for many reasons:
  * a personal desire to scratch a niggling itch,
  * a profound academic insight,
  * technical debt, or
  * the benefit of hindsight of other compiler architectures --
  * even politics.

  _Scala 3 is a combination of some of these._

- =TODO= NOTE

* TODO Acknowledgments - xxxiii
* DONE Introduction - xxxvi
CLOSED: [2025-04-14 Mon 16:20]
Our goal: by reading this book, you can learn everything you need to be a
productive Scala programmer.

- *Who should read this book*
  - Programmers how want to learn to program in Scala.
  - Programmers wishing to expand their horizons by learning new concepts.

  - We believe learning about Scala, and the ideas behind it, can help you
    become a better progammer in general.

  - REREQUISITE:
    _General programming knowledge is ASSUMED._
    * While Scala is a fine _FIRST programming language,_ this is NOT the book
      to use to learn programming.

  - No specific knowledge of programming languages is required.
    Not presume you know anything about Java.
    _HOWEVER_,
    we EXPECT many readers to be familiar with Java, and
    so we sometimes compare Scala to Java to help such readers understand the
    differences.

** How to use this book
Read this book is in chapter order, from front to back.

After you have read the book once, it should also serve as a language
reference.

There is a formal specification of the Scala language, but the language
specification tries for precision at the expense of readability.

** How to learn Scala
You will learn a lot about Scala simply by reading this book from cover to
cover. You can learn Scala faster and more thoroughly, though, if you do a few
extra things:
1. Type the example code in this book in yourself,
   force your mind through each line of code.

   Trying variations to make sure you really understand how they work.

2. keep in touch with the numerous online forums.

3. Take on a programming project of your own.

Work on a small program from scratch or develop an add-in to a larger
program. _You can only go so far by reading._

** EBook features
** Typographic conventions
** Content overview
- Chapter 12, “Packages and Imports,”
  =FIXME= title (about export)
  =FIXME= content (about export)

- Chapter 19, “Enums and ADTs,” introduces twin constructs that supportyou
  when writing regular, non-encapsulated data structures.
  =FIXME= Order!!!
  =FIXME= description here copied the first sentent of Chapter 12!

- Chapter 23, “Typeclasses,” yet to be written,
  =FIXME= already done!!! This is not a pre-print version!

- =from Jian= Already submitted a errata!

** Resources
- https://www.scalalang.org
- https://booksites.artima.com/programming_in_scala_5ed

** Source code
https://booksites.artima.com/programming_in_scala_5ed

** Errata - =TODO: Review periodically=
https://booksites.artima.com/programming_in_scala_5ed/errata

* TODO 1 A Scalable Language - 43
** DONE 1.1 A language that grows on you - 44
CLOSED: [2025-04-15 Tue 12:41]
- Scala is easy to get into. It runs on the standard _Java_ and _JavaScript_
  platforms and interoperates seamlessly with all platform libraries.
  * =from Jian= Still not mention Scala Native

- Technically, Scala is a blend of /object-oriented/ and /functional
  programming/ concepts in a /statically typed/ language.
  =IMPORTANT=

  * The two programming styles have *COMPLEMENTARY strengths* when it comes
    to scalability.
    + Scala's functional programming constructs make it easy to build
      interesting things quickly from simple parts.

    + Scala's object-oriented constructs make it easy to structure larger
      systems and adapt them to new demands.

  * The combination of both styles in Scala
    + makes it possible to express new kinds of programming patterns and
      component abstractions.

    + It also leads to a legible and concise programming style.

    + And because it is so malleable, programming in Scala can be a lot of fun.

- This initial chapter answers the question, “Why Scala?” It gives a highlevel
  view of Scala's design and the reasoning behind it.

  * After reading the chapter you should have
    a basic feel
    + for what Scala is and
    + what kinds of tasks it might help you accomplish.

*** Growing new types - 45
So the approach of attempting to provide everything in one language doesn't
scale very well. _Instead_, Scala allows users to grow and adapt the language in
the directions they need by defining easy-to-use libraries that feel like native
language support.

*** Growing new control constructs - 46
You can “grow” the Scala language in new directions even as specialized as
software testing.
To be sure, you need experienced architects and programmers to do this.
BUT the crucial thing is that it is *feasible* -- you can design and implement
abstractions in Scala that address radically new application domains, yet still
_feel like native language support when used._

** TODO 1.2 What makes Scala scalable? - 47
- _Scalability_ is influenced by many factors, ranging from syntax details to
  component abstraction constructs. If we were forced to name just one aspect of
  Scala that helps scalability, though, we'd pick its combination of
  _object-oriented_ and _functional programming_ (well, we cheated, that's
  really two aspects, but they are intertwined).

- Scala goes further than all other well-known languages in fusing
  object-oriented and functional programming into a uniform language design.

  * For instance, where other languages might have /objects/ and /functions/ as
    two different concepts, *in Scala a /function value/ is an /object/.*

    /Function types/ are /classes/ that can be inherited by /subclasses/. This
    might seem nothing more than an academic nicety, but it has deep
    consequences for scalability.

    This section gives an overview of Scala's way of blending object-oriented
    and functional concepts.

*** Scala is object-oriented - 48
- Object-oriented programming has been immensely successful. Starting from
  Simula in the mid-60s and Smalltalk in the 70s, it is now available in more
  languages than not. In some domains, objects have taken over completely. While
  there is not a precise definition of what object-oriented means, there is
  clearly something about objects that appeals to programmers.

- In principle, the motivation for object-oriented programming is very
  simple: all but the most trivial programs need some sort of structure. The
  most straightforward way to do this is to put data and operations into some
  form of containers. The great idea of object-oriented programming is to make
  these containers fully general, so that they can contain operations as well
  as data, and that they are themselves values that can be stored in other
  containers, or passed as parameters to operations. Such containers are called
  objects. Alan Kay, the inventor of Smalltalk, remarked that in this way the
  simplest object has the same construction principle as a full computer: it
  combines data with operations under a formalized interface.7 So objects have
  a lot to do with language scalability: the same techniques apply to the
  construction of small as well as large programs.

- Even though object-oriented programming has been mainstream for along time,
  there are relatively few languages that have followed Smalltalkin pushing
  this construction principle to its logical conclusion. For instance,many
  languages admit values that are not objects, such as the primitive valuesin
  Java. Or they allow static fields and methods that are not membersof any
  object. These deviations from the pure idea of object-oriented
  programminglook quite harmless at first, but they have an annoying
  tendencyto complicate things and limit scalability.

*** Scala is functional - 49

** TODO 1.3 Why Scala? - 51
We have found that there are actually many reasons besides scalability to like
programming in Scala.
FOUR of the most important aspects will be discussed in this section:
- compatibility
- brevity
- high-level abstractions, and
- advanced static typing.

*** Scala is compatible - 51
- Scala *doesn't require* you to leap backwards off the Java platform to step
  forward from the Java language.
  It allows you to add value to existing code -- to build on what you already
  have -- because it was designed for seamless interoperability with Java.

- Another aspect of full interoperability is that Scala heavily re-uses
  Javatypes. Scala’s Ints are represented as Java primitive integers of type
  int,Floats are represented as floats, Booleans as booleans, and so on.
  Scalaarrays are mapped to Java arrays. Scala also re-uses many of the
  standardJava library types. For instance, the type of a string literal "abc"
  inScala is java.lang.String, and a thrown exception must be a subclass
  ofjava.lang.Throwable.

- Scala not only re-uses Java’s types, but also “dresses them up” to makethem
  nicer. For instance, Scala’s strings support methods like toInt ortoFloat,
  which convert the string to an integer or floating-point number.So you can
  write str.toInt instead of Integer.parseInt(str). Howcan this be achieved
  without breaking interoperability? Java’s String classcertainly has no toInt
  method! In fact, Scala has a very general solutionto solve this tension
  between advanced library design and interoperability.Scala lets you define
  rich extensions, which are always applied when non-existing members are
  selected.10 In the case above, when looking for atoInt method on a string,
  the Scala compiler will find no such memberof class String, but it will find
  an implicit conversion that converts a JavaString to an instance of the
  Scala class StringOps, which does define sucha member. The conversion will
  then be applied implicitly before performingthe toInt operation.

- Scala code can also be invoked from Java code. This is sometimes a bitmore
  subtle, because Scala is a richer language than Java, so some of Scala’smore
  advanced features need to be encoded before they can be mapped toJava. The
  details will be explained in Advanced Programming in Scala.

*** Scala is concise - 52
*** Scala is high-level - 53
*** Scala is statically typed - 55

** TODO 1.4 Scala's roots - 58
** TODO 1.5 Conclusion - 59

* DONE 2 First Steps in Scala - 61
CLOSED: [2025-04-17 Thu 01:22]
- This page describes several ways to _install or try_ Scala.

- Everything will be explained in a less “fire hose” fashion in later chapters.

  In addition, we inserted quite a few footnotes in these next two chapters to
  point you

- =from Jian=
  Use _coursier_ (command ~cs setup~) to install all related tools, including
  * ammonite
  * cs
  * coursier
  * scala
  * scalac
  * scala-cli
  * sbt
  * sbtn
  * scalafmt

** DONE Step 1. Learn to use the Scala REPL - 61
CLOSED: [2025-04-16 Wed 22:52]
=from Jian= Current version use Scala 3.0, and from Scala 3.5.0 on, =scala=
command refer to =scala-cli=, which is not covered by this book because of the
Scala version used when writing this book.

** DONE Step 2. Define some variables - 63
CLOSED: [2025-04-16 Wed 23:27]
- If you realize you have typed something wrong, but the REPL is still waiting
  for more input, you can use the arrow keys to move up, down, left, or right to
  fix the mistakes.

- If you want to abort your entry completely, you can escape by pressing enter
  twice:
  #+begin_src text
    scala> val oops =
         |
         |
    You typed two blank lines. Starting a new command.
    scala>
  #+end_src
  =FIXME= Not an always work way!!!
  =from Jian=
  =IMPORTANT=
  New Scala REPL is backed by _JLine_, and *NOT all JLine version support* this
  way to abort current input. Usually, _JLine_ by default enable Emacs shortcuts,
  therefore _CTRL + G_ works.

** DONE Step 3. Define some functions - 65
CLOSED: [2025-04-17 Thu 00:48]
- footnote 7:
  * In Java, the type of the value returned from a method is its /return type/.
  * In Scala, that same concept is called /result type/.
  =from Jian= This is reasonable, because Scala rarely use ~return~, call it
  /return type/ in Scala is weird.
  =IMPORTANT=

- Sometimes the Scala compiler will require you to specify the /result type/ of a
  function.
  * If a function is /recursive/, for example, you *must explicitly specify* its
    /result type/.

  * If a function consists of just _one statement_,
    you can optionally write the function entirely on one line.
    + =from Jian= Yes, this should be mentioned, because now brace-less
      indentation-based syntax is used.

  * footnote 8:
    Nevertheless, it is often a good idea to indicate function result types
    explicitly, even when the compiler doesn't require it.

    =IMPORTANT=
    Such /type annotations/ can make the code easier to read,
    BECAUSE the reader need not study the function body to figure out the
    /inferred result type/.
    =from Jian=
    Types in general is also like a kind of document when reading code, we can
    let them be inferred by compiler, but always write _some of them that at
    interface positions_ down explicitly, which is good for read.
    Function /result type/ is at, this function's, interface positions.
    + I create and use this term "interface positions", not a formal term.

- Every ~void~-returning method in Java is mapped to a ~Unit~-returning method
  in Scala.

- Use ~:quit~ in REPL to exit the REPL.

** DONE Step 4. Write some Scala scripts - 67
CLOSED: [2025-04-17 Thu 00:58]
- script :: just a Scala source file that includes a top-level function
  annotated as ~@main~.
  * Example:
    Put the code below in file =hello.scala=:
    #+begin_src scala
      @main def m() =
        println("Hello, world, from a script!")
    #+end_src
    + Run it:
      #+begin_src shell
        scala hello.scala
      #+end_src

- Write a script in Scala and run it:
  1. Put this code in file =hello.scala=
     #+begin_src scala
       @main def m() = println("Hello, world, from a script!")
     #+end_src

  2. Run it in command line:
     ~scala hello.scala~

  3. Output:
     =Hello, world, from a script!=

- Write a script in Scala that can accept command line arguments, and then run
  it:
  1. Put this code in file =helloarg.scala=
     #+begin_src scala
       @main def m(args: String*) =
         // Say hello to the first argument
         println("Hello, " + args(0) + "!")
     #+end_src

  2. Run it in command line:
     ~scala helloarg.scala planet~

  3. Output:
     =Hello, planet!=

** DONE Step 5. Loop with ~while~; decide with ~if~ - 68
CLOSED: [2025-04-17 Thu 01:08]
- *Note*
  Although the examples in this section help explain ~while~ loops,
  they *DO NOT demonstrate the best Scala style.*
    In the next section, you'll see better approaches that avoid iterating
  through sequences with indexes.

- Write a script in Scala and run it:
  1. Put this code in file =printargs.scala=
     #+begin_src scala
       @main def m(args: String*) =
         var i = 0
         while i < args.length do
           println(args(i))
           i += 1
     #+end_src

  2. Run it:
     ~scala printargs.scala Scala is fun~

  3. Output:
     #+begin_src text
       Scala
       is
       fun
     #+end_src

- Write a script in Scala and run it:
  1. Put this code in file =echoargs.scala=
     #+begin_src scala
       @main def m(args: String*) =
         var i = 0
         while i < args.length do
           if i != 0 then
             print(" ")
           print(args(i))
           i += 1
         println()
     #+end_src

  2. Run it:
     ~scala echoargs.scala Scala is even more fun~

  3. Output:
     #+begin_src text
       Scala is even more fun
     #+end_src

- As of Scala 3, the /indentation-based style/, called *"quiet syntax,"* is
  recommended over the /curly brace style/.

- Scala 3 also introduced /end markers/, to make it easier to see where larger
  indented regions end.
  * /End markers/ consist of the keyword ~end~ followed by a /specifier token/,
    which is either an /identifier/ or a /keyword/.
    =NEXT=
    An example is shown in Listing 10.9.

** DONE Step 6. Iterate with ~foreach~ and ~for-do~ - 71
CLOSED: [2025-04-17 Thu 01:22]
- In the last step, we see a imperative way that uses ~while~ loops.

- Another (far more concise) way to print each command line argument is:
  #+begin_src scala
    @main def m(args: String*) =
      args.foreach(arg => println(arg))
  #+end_src
  This is more functional -- passing a /function literal/ to ~foreach~.

  Run it: ~scala pa.scala Concise is nice~ and see output:
  #+begin_src text
    Concise
    is
    nice
  #+end_src
  * More conciseness:
    #+begin_src scala
      @main def m(args: String*) =
        args.foreach(println)
    #+end_src

- Use ~for~ expression:
  #+begin_src scala
    @main def m(args: String*) =
      for arg <- args do
        println(arg)
  #+end_src
  * ~arg~ is always a ~val~ and that's why this syntax ignore that. It can be
    easily proved that you can't reassign it inside the body of the ~for~
    expression.
    * For each element of the ~args~ array, a *new* ~arg~ will be created and
      initialized to the element value, and the body of the ~for~ will be
      executed.

- More on ~for~ expressions in Step 12, Chapter 3, Section 7.3, and in
  _Advanced Programming in Scala_.

- footnote 12:
  You can say "in" for the ~<-~ symbol.
  You'd read ~for arg <- args do~, therefore, as _"for arg in args do."_

** DONE Conclusion - 73
CLOSED: [2025-04-17 Thu 01:09]

* DONE 3 Next Steps in Scala - 74 - _NOTE_
CLOSED: [2025-04-22 Tue 20:01]
This chapter continues the previous chapter's introduction to Scala.
In this chapter, we'll introduce some _more advanced_ features.

When you complete this chapter, you should have _enough knowledge_ to ENABLE you
to _start writing useful scripts in Scala_.

** DONE Step 7. Parameterize arrays with types - 74
CLOSED: [2025-04-19 Sat 02:14]
- In Scala, you can *instantiate* /objects/, or /class instances/, using ~new~.

  * When you *instantiate* an /object/ in Scala, you can /parameterize/ it with
    /values/ and /types/.

  * Parameterization :: "configuring" an /instance/ when you create it.

  * You /parameterize/ an /instance/ with /values/
    BY _passing /objects/ to a /constructor/ in parentheses_.
    Example:
    #+begin_src scala
      val big = new java.math.BigInteger("12345")
    #+end_src

  * You /parameterize/ an /instance/ with /types/
    BY _specifying one or more /types/ in square brackets._

  * When you /parameterize/ an /instance/ with BOTH /types/ and /values/,
    + the /types/ come first in its _square brackets_,
    + followed by the /value/ in _parentheses_.

- Listing 3.1 · Parameterizing an array with a type.
  #+begin_src scala
    val greetStrings = new Array[String](3)

    greetStrings(0) = "Hello"
    greetStrings(1) = ", "
    greetStrings(2) = "world!\n"

    for i <- 0 to 2 do
      print(greetStrings(i))
  #+end_src
  * *NOT* the best way to initialize an ~Array~.
    See Listing 3.2 on page 78 for a better way.

  * Declare a variable with ~val~ means this variable _can't be reassigned_.
    It _has nothing to do with_ the if the bound object itself is mutable or
    not!

  * If a /method/ takes _only one parameter_, and when the /receiver/ is
    explicitly specified, you can call it *WITHOUT* a _dot_ or _parentheses_.
    ~0 to 2~ in Listing 3.1 is an example, witch is equivalent to ~0.to(2)~.

  * =IMPORTANT=
    Scala *doesn't technically have* /operator overloading/,
    BECAUSE it doesn't actually have /operators/ in the traditional sense.

    Instead, characters such as +, -, *, and / can be used in /method names/.

  * =IMPORTANT=
    _Scala has *FEWER* SPECIAL CASES than Java._

    1. ~Array~'s are simply /instances of classes/ _LIKE ANY OTHER_ /class/ in
       Scala.
       - Indexing operation ~greetStrings(i)~ will be translated into
         ~greetStrings.apply(i)~

       - Array member assignment (by index) ~greetStrings(0) = "Hello"~ will be
         transformed into ~greetStrings.update(0, "Hello")~

    2. These transformation by compiler can happen
       IF ~apply~ and ~update~ methods exist in /types/.

    After compiler transformations mentioned here, the code is like:
    #+begin_src scala
      val greetStrings = new Array[String](3)

      greetStrings.update(0, "Hello")
      greetStrings.update(1, ", ")
      greetStrings.update(2, "world!\n")

      for i <- 0.to(2) do
        print(greetStrings.apply(i))
    #+end_src

- =IMPORTANT=
  Scala achieves a *conceptual simplicity* by treating everything, from arrays
  to expressions, as /objects/ with /methods/.

  * You don't have to remember special cases (like in Java).

  * Moreover, this _uniformity does NOT incur a SIGNIFICANT performance cost._
    The Scala compiler uses /Java arrays/, /primitive types/, and /native
    arithmetic/ *where possible in the compiled code.*

- Scala provides a *more concise way* to _create and initialize_ arrays that you
  would normally use (see Listing 3.2).
  #+begin_src scala
    val numNames = Array("zero", "one", "two")
  #+end_src
  Listing 3.2 · Creating and initializing an array.

  This will be transformed into
  #+begin_src scala
    val numNames = Array.apply("zero", "one", "two")
  #+end_src
  calling a /factory method/ ~apply~ from the /companion object/ of ~Array~.

- footnote 2:
  =IMPORTANT=
  =CONCEPT=
  /Variable-length argument lists/ \equiv /repeated parameters/

** DONE Step 8. Use lists - 78
CLOSED: [2025-04-22 Tue 19:22]
- One of the big ideas of the /functional style of programming/:
  _/methods/ should *NOT have* /side effects/._

  * Some benefits gained when you take this approach are that methods become
    less entangled, and therefore more reliable and reusable.

  * Another benefit (in a statically typed language) is that everything that
    goes into and out of a method is checked by a type checker, so logic errors
    are more likely to manifest themselves as type errors.

  Applying this functional philosophy to the world of objects means making
  objects *immutable*.

- Scala's ~List~ class:
  An *immutable* *sequence* of objects that share the *SAME* /type/.

- More generally, Scala's ~List~ is designed to _ENABLE_ a /functional style of
  programming/.

- List concatenation: ~:::~.

- If a method name ends in a *colon*, it is right associative!

** DONE Step 9. Use tuples - 83
CLOSED: [2025-04-22 Tue 19:25]
=from Jian= Not mention the operators ~*:~ and ~:*~ (Scala version 3.0 have it
or not???).

- _footnote 5:_ The Scala compiler uses a /syntactic sugar/ form for /tuple types/
  that looks *LIKE a tuple of types.*
  * For example,
    ~Tuple2[Int, String]~ is represented as ~(Int, String)~.
- In Scala 3, use the ~.apply~ method to extract an element in a tuple at a
  given index, *like using other indexible collections*.

  * _footnote 6:_ prior to Scala 3, you _accessed the elements of a tuple_ using
    /one-based field names/, such as ~_1~ or ~_2~.
    =Not deprecated till v3.6.4=

- _footnote 7:_ As of Scala 3, you can create tuples of any length.

** DONE Step 10. Use sets and maps - 84
CLOSED: [2025-04-22 Tue 19:32]
*Mutable* sets/maps and *immutable* sets/maps.

** DONE Step 11. Learn to recognize the functional style - 88
CLOSED: [2025-04-22 Tue 19:55]
As mentioned in Chapter 1, Scala
_ALLOWS_ you to program in an /imperative style/,
but _ENCOURAGES_ you to adopt a more /functional style/.

- If you come from an imperative background, we believe that learning to program
  in a functional style will not only make you a better Scala programmer, it
  will expand your horizons and make you a better programmer in general.

- The _FIRST_ step:
  recognize the difference between the two styles in code.
  * if code contains any ~var~'s, it is probably in an /imperative style/.
  * Similarly, if only ~val~'s, it is probably in an /functional style/.

- The *REASON* Scala encourages a /functional style/ is that it can help you
  write code that is
  * _more understandable,_
  * _less error-prone._

  Example:
  1. Imperative style:
     #+begin_src scala
       def printArgs(args: List[String]): Unit =
         var i = 0
         while i <- args.length do
           println(args(i))
           i += 1
     #+end_src

  2. Functional style:
     #+begin_src scala
       def printArgs(args: List[String]): Unit =
         for arg <- args do
           println(args(i))
     #+end_src

     or this:

     #+begin_src scala
       def printArgs(args: List[String]): Unit =
         args.foreach(println)
     #+end_src

- After the _FIRST_ step, go even further:
  The refactored ~printArgs~ method is *NOT* purely functional because of side effects.
  * ~Unit~ /result type/ is the telltale.

  We can move the side-effect free code to its own function:
  #+begin_src scala
    def formatArgs(args: List[String]) =
      args.mkString("\n")
  #+end_src

  and then the ~printArgs~ method body becomes:
  #+begin_src scala
    println(formatArgs(args))
  #+end_src

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =CRITICAL=
  Every useful program is likely to have /side effects/ of some form;
  otherwise, it wouldn't be able to _provide value to the outside world_.

  =from Jian=
  =IMPORTANT=
  It is not a single function, it is a program. There is no reason to write a
  program that can't provide value to the outside world.

  * =IMPORTANT=
    METHODOLOGY:
    _Preferring /methods/ *without* /side effects/_
    ENCOURAGES you to

    _design programs where /side-effecting code/ is *MINIMIZED*._

    + One benefit of this approach is that it can help make your programs
      *easier to test*.

      For example,
      For example, to test any of the three ~printArgs~ methods shown earlier in
      this section, you'd need to *redefine* ~println~, capture the output
      passed to it, and make sure it is what you expect.

      _BY CONTRAST,_
      you could test the ~formatArgs~ function simply by checking its result!
      =from Jian=
      Because body of ~printArgs~ which calls ~formatArgs~ is just a ~println~
      function call, and test ~formatArgs~ is enough to test ~printArgs~!

- =IMPORTANT=
  *A balanced attitude for Scala programmers*
  1. PREFER ~val~'s, /immutable objects/, and /methods WITHOUT side effects/.
     Reach for them first.

  2. Use ~var~'s, /mutable objects/, and /methods with side effects/
     WHEN you have a specific _NEED and JUSTIFICATION_ for them.

** DONE Step 12. Transform with ~map~ and ~for-yield~ - 91
CLOSED: [2025-04-22 Tue 20:01]
- =IMPORTANT=
  * When programming in an /imperative style/,
    you *MUTATE* data structures *in place* UNTIL you achieve the goal of the
    algorithm.

  * In a /functional style/,
    you *TRANSFORM* /IMMUTABLE data structures/ *into* NEW ones to achieve the
    goal.

- "defined" option :: If the ~Option~ is a ~Some~.
  =CONCEPT=
  =IMPORTANT=

** DONE Conclusion - 94
CLOSED: [2025-04-22 Tue 20:01]

* DONE 4 Classes and Objects - 95
CLOSED: [2025-04-22 Tue 18:00]
** DONE 4.1 Classes, fields, and methods - 95
CLOSED: [2025-04-21 Mon 22:09]
- A /class/ is a *blueprint* for /objects/.
  * Create /objects/ from /classes/ with the keyword ~new~.
    =from Jian=
    Scala 3 reduces the explicit ~new~ usages by design.
    =TODO= =???=
    I don't remember the details, try to find the document or PR about this!

- Inside a /class definition/, you place /fields/ and /methods/, which are
  collectively called /members/.
  * /Fields/ are /variables/ that refer to /objects/.
    + The /fields/ hold the
      - state
      - data
      of their host object.

  * /Methods/ contain executable code.
    + The /methods/ can use that data to do the computational work of the
      /object/.

- =TODO= _One way to check if your code is right!_
  One important way to pursue _ROBUSTNESS_ of an /object/ is to ensure that the
  /object's state/ -- the values of its /instance variables/ -- *remains VALID
  during its entire lifetime.*
  * One way to achieve this is to prevent outsiders from accessing the /fields/
    DIRECTLY by making the /fields/ ~private~.

- procedure :: A method that is executed only for its /side effects/.

** DONE 4.2 Semicolon inference - 99
CLOSED: [2025-04-21 Mon 22:17]
- *The rules of semicolon inference*
  The precise rules for statement separation are surprisingly simple for how
  well they work.

  In short, _a line ending is treated as a semicolon_
  *UNLESS* one of the following conditions is true:

  1. The line in question ends in a word that would _NOT be legal as the end of
     a statement_, such as a /period/ or an /infix operator/.

  2. The next line begins with a word that _CANNOT start a statement_.

  3. The line ends while inside parentheses ~(...)~ or brackets ~[...]~, because
     these _CANNOT contain multiple statements anyway_.

** DONE 4.3 Singleton objects - 100
CLOSED: [2025-04-21 Mon 22:34]
- A /singleton object definition/ looks like a /class definition/,
  EXCEPT instead of the keyword ~class~ you use the keyword ~object~.

- (class's) companion object :: when a /singleton object/ shares the _SAME name_
  with a /class/.
  * A /class/ and its /companion object/ must be in the SAME source file.
  * The /class/ is called the /companion class/ of the singleton object.
  * =IMPORTANT=
    A /class/ and its /companion object/ can access each other's ~private~
    memebers.

- A eample: Listing 4.2 · Companion object for class ChecksumAccumulator.
  * footnote 3:
    Might use a /weak map/, such as ~WeakHashMap~ in ~scala.collection.mutable~,
    so that entries in the cache
    could be _garbage collected IF memory becomes *scarce*._
    =TODO=
    =from Jian= Learn more about /weak map/!!!

- /Singleton objects/ extend a /superclass/ and can *mix* in /traits/.

- EACH /singleton object/ is implemented as an instance of a /synthetic class/
  referenced from a /static variable/, so they have the
  _SAME /initialization semantics/ as /Java statics/._
  =IMPORTANT=
  * In particular, a /singleton object/ is initialized the first time some code
    accesses it.
    =from Jian= A lazy initialization.

- standalone object :: A /singleton object/ that does not share the same name
  with a /companion class/.

  You can use /standalone objects/ for many purposes, including
  * collecting related utility methods together or
  * defining an _entry point_ to a Scala application.
    =NEXT=
    This use case is shown in the next section.

** DONE 4.4 Case classes - 103
CLOSED: [2025-04-21 Mon 22:50]
- _PROBLEM_:
  Often when you write a /class/, you need implementations of /methods/ such as
  ~equals~, ~hashCode~, ~toString~, /accessor methods/, or /factory methods/.
  _These can be *time-consuming* and *error-prone* to write._

- _SOLUTION_:
  =IMPORTANT=
  Scala offers *"case classes,"* which can
  *GENERATE* implementations of several methods based on the values passed to its
  /primary constructor/.

- Example:
  #+begin_src scala
    case class Person(name: String, age: Int)
  #+end_src

- With the addition of the ~case~ modifier, the compiler will generate
  several useful methods for you:

  The compiler will
  1. *CREATE* a /companion object/ and
     *PLACE* a /factory method/ in it named ~apply~.
     * Code ~Person("Sally", 30)~ will rewritten to ~Person.apply("Sally", 30)~.

  2. *STORE* all /class parameters/ *IN* /fields/ and
     *GENERATE* /accessor methods/ with the SAME name as the parameter.

  3. *PROVIDE* an implementation of ~toString~ for you.

  4. *GENERATE* an implementation of ~hashCode~ and ~equals~ for your /class/.
     * These /methods/ will base their result on the parameters passed to the
       /constructor/.

     =IMPORTANT=
  5. *NOT generate* any /method/ that you implement yourself.
     It will use your implementation.

  6. *ADDS* a ~copy~ method to your /class/ and an ~unapply~ method to the companion.
     =TODO=
     These will be described in Chapter 13.

- _SUMMARY_:
  All these conventions *ADD a lot of convenience -- AT a small price.*

** DONE 4.5 A Scala application - 105 - =I updated some content=
CLOSED: [2025-04-22 Tue 17:59]
=OUTDATED!!!=

- Need an entry point /main method/ in a standalone singleton object.
  * Can be the standard ~main~ method, or
  * Any function with the ~@main~ annotation, from _footnote 8_.

- Scala doesn't force the name of a source file,
  BUT it is *recommended style* to _name files *after* the /classes/ they
  CONTAIN_ as is done in Java,
  =IMPORTANT=
  so that programmers can more easily locate classes by looking at file names.

- =from Jian=
  This section mentioned script, and it said
  "NEITHER =ChecksumAccumulator.scala= NOR =Summer.scala= are scripts, BECAUSE they
  end in a definition. A script, by contrast, *must END in a result /expression/.*"
  =TODO=
  It should explain more about the /script/ concept in the context of Scala.

  =from Jian=
  I found the =scala= can run =.sc= that ends with an expression directly, but
  when using it to run the same content file with the =.scala= extension,
  #+begin_src text
    Illegal start of toplevel definition
  #+end_src

  Thus, even though here is exact definition of /script/, it seems in practice
  /script/ in the Scala context and can run with the =scala= command
  1. Must have =.sc= extension. Only with this extension, =scala= won't consider
     top level expression wrong!

  2. Make sure =.sc= content ends with a result /expression/.
     Without it, the /script/ is legal, but useless!!!

*** =from Jian= Update for Scala 3.5+
- Run from from the script(s): =.scala= or =.sc=
  1. Add a /using directive/ to the source file: =Summer.scala=.
     Assume its dependency =ChecksumAccumulator.scala= is in the same folder.
     #+begin_src scala
       //> using file ChecksumAccumulator.scala
     #+end_src

  2. Run in with the command:
     #+begin_src shell
       scala Summer.scala -- of love
     #+end_src

- Q :: How to run the compiled result =.class=?
- A :: From Scala 3.5 on,
  #+begin_src shell
    scalac ChecksumAccumulator.scala Summer.scala

    scala run -classpath . --main-class Summer -- of love
  #+end_src
  * NOT like before that uses ~scala Summer of love~.

  * Additional, if ~@main~ is used,
    the command becomes
    #+begin_src shell
      scala run -classpath . --main-class main -- of love
    #+end_src
    because a =main.class= is generated.

** DONE 4.6 Conclusion - 107
CLOSED: [2025-04-22 Tue 18:00]
This chapter has
- given you the basics of /classes/ and /objects/ in Scala, and
- shown you how to _compile_ and _run_ applications. =OUTDATED since Scala 3.5=

In the next chapter, you'll learn about Scala's basic types and how to use them.

* TODO 5 Basic Types and Operations - 108
** 5.1 Some basic types - 108
** 5.2 Literals - 109
** 5.3 String interpolation - 114
** 5.4 Operators are methods - 116
** 5.5 Arithmetic operations - 119
** 5.6 Relational and logical operations - 120
** 5.7 Bitwise operations - 121
** 5.8 Object equality - 122
** 5.9 Operator precedence and associativity - 124
** 5.10 Rich operations - 127
** 5.11 Conclusion - 127

* TODO 6 Functional Objects - 129
** 6.1 A specification for class ~Rational~ - 129
** 6.2 Constructing a ~Rational~ - 130
** 6.3 Reimplementing the ~toString~ method - 132
** 6.4 Checking preconditions - 133
** 6.5 Adding fields - 134
** 6.6 Self references - 136
** 6.7 Auxiliary constructors - 136
** 6.8 Private fields and methods - 138
** 6.9 Defining operators - 139
** 6.10 Identifiers in Scala - 141
** 6.11 Method overloading - 144
** 6.12 Extension methods - 146
** 6.13 A word of caution - 147
** 6.14 Conclusion - 147

* TODO 7 Built-in Control Structures - 149
** 7.1 If expressions - 150
** 7.2 While loops - 151
** 7.3 For expressions - 154
** 7.4 Exception handling with ~try~ expressions - 159
** 7.5 Match expressions - 163
** 7.6 Living without ~break~ and ~continue~ - 164
** 7.7 Variable scope - 166
** 7.8 Refactoring imperative-style code - 169
** 7.9 Conclusion - 171

* TODO 8 Functions and Closures - 172
** 8.1 Methods - 172
** 8.2 Local functions - 173
** 8.3 First-class functions - 175
** 8.4 Short forms of function literals - 176
** 8.5 Placeholder syntax - 177
** 8.6 Partially applied functions - 178
** 8.7 Closures - 181
** 8.8 Special function call forms - 183
** 8.9 “SAM” types - 186
** 8.10 Tail recursion - 188
** 8.11 Conclusion - 191

* TODO 9 Control Abstraction - 192
** 9.1 Reducing code duplication - 192
** 9.2 Simplifying client code - 196
** 9.3 Currying - 198
** 9.4 Writing new control structures - 199
** 9.5 By-name parameters - 202
** 9.6 Conclusion - 204

* TODO 10 Composition and Inheritance - 206
** 10.1 A two-dimensional layout library - 206
** 10.2 Abstract classes - 207
** 10.3 Defining parameterless methods - 208
** 10.4 Extending classes - 211
** 10.5 Overriding methods and fields - 213
** 10.6 Defining parametric fields - 214
** 10.7 Invoking superclass constructors - 216
** 10.8 Using ~override~ modifiers - 217
** 10.9 Polymorphism and dynamic binding - 219
** 10.10 Declaring ~final~ members - 221
** 10.11 Using composition and inheritance - 222
** 10.12 Implementing ~above~, ~beside~, and ~toString~ - 224
** 10.13 Defining a factory object - 226
** 10.14 Heighten and widen - 228
** 10.15 Putting it all together - 230
** 10.16 Conclusion - 233

* TODO 11 Traits - 234 - =READING=
  - /Traits/ are a _fundamental unit_ of code *reuse* in Scala.

  - A /trait/ encapsulates /method/ and /field/ definitions,
    which can then be reused by *mixing* them *into* /classes/.

  - This chapter shows you
    * how traits work
    * TWO of the most common ways they are useful:
      + widening thin interfaces to rich ones
      + defining stackable modifications

  - It also shows
    * *how to use* the ~Ordered~ /trait/
    * *compares* /traits/ to the /multiple inheritance/ of other languages.

** DONE 11.1 How traits work - 234
CLOSED: [2022-05-21 Sat 00:54]
- A /trait definition/ looks just LIKE a /class definition/
  EXCEPT that it uses the keyword ~trait~.

- If a /trait/ doesn't decllare a /superclass/, like a /class/,
  it has the _default superclass_ of ~AnyRef~.

- Once a /trait/ is defined,
  it can be *mixed in* to a /class/ using
  * either the keyword ~extends~
  * or the keyword ~with~,
  * or a comma.

- Scala programmers *“mix in”* /traits/ _RATHER THAN_ *inherit* from them,
  BECAUSE mixing in a /trait/ has *IMPORTANT DIFFERENCES* from the ~multiple
  inheritance~ found in many other languages. This issue is discussed in
  Section 11.4.
  =TODO=
  =TODO=
  =TODO=
  =TODO=
  =TODO=

- At this point you might philosophize that
  /traits/ are *like* /Java interfaces/ with /default methods/,
  BUT they can actually do much more -- /traits/ can, for example,
  * declare fields and maintain state.

- =IMPORTANT=
  You can do anything in a /trait definition/ that you can do in a
  /class definition/, and the syntax, except the keyword, looks
  _exactly the same_.

- =IMPORTANT=
  * The *KEY DIFFERENCE* between /classes/ and /traits/:
    + whereas in /classes/, ~super~ calls are _statically bound_,
    + in /traits/, they are _dynamically bound_.

  * For example,
    + if you write ~super.toString~ in a /class/, you know exactly which
      _method implementation_ will be invoked.

    + When you write the same thing in a /trait/,
      however, the method implementation to invoke for the ~super~ call
      _is *undefined* WHEN you define the /trait/._

      RATHER, *the implementation to invoke will be DETERMINED anew each time
      the /trait/ is mixed into a /CONCRETE class/.*

    =TODO=
    This curious behavior of ~super~ is key to allowing /traits/ to work as
    /stackable modifications/, which will be described in _Section 11.3_.
    =TODO=
    The rules for resolving ~super~ calls will be given in _Section 11.4_.

** 11.2 Thin versus rich interfaces - 237
- One major use of /traits/:
  automatically add /methods/ to a /class/ in terms of /methods/ the /class/
  _already has_ -- that is, /traits/ can enrich a *THIN interface*, making it
  into a *RICH interface*.

- *Thin* versus *rich* /interfaces/ represents a commonly faced trade-off in
  object-oriented design.

    The trade-off is BETWEEN _the implementers_ AND _the clients of an interface_.
  * A /rich interface/ has many /methods/, which make it convenient for the caller.
    Clients can pick a method that exactly matches the functionality they need.

  * A /thin interface/, on the other hand, has *fewer* /methods/, and thus is
    easier on _the implementers_.


 * Clients calling into a /thin interface/, however, have to write more code.
   Given the smaller selection of methods to call, they may have to choose a
   less than perfect match for their needs and write extra code to use it.

CLOSED: [2017-10-12 Thu 03:17]
=From Jian= Except the phase /Java interface/, *interface* by itself in this
section is used to represent its general meaning, NOT something for a
specific language.

- One major use of /traits/ is to automatically add (concrete) /methods/ to a
  /class/ that extends it.

- Thin vs Rich:
  Consider the trade-off between the _implementers_ and the _clients_ of an
  interface.

  + A *rich* interface
    has _MANY_ /methods/, which make it convenient for the _callers (clients)_
    -- they have more chance to find /methods/ that can fit their requirement
    exactly.

  + A *thin* interface,
    on the other hand, has _FEWER_ /methods/, and thus
    * it is easier for the _implementers_ whoes load is light.

    * more work are left for the _clients (clients)_, who call into a *thin*
      interface, however, have to write more code -- comparing the the *rich*
      interface, they have less chance to find /methods/ that can fit their
      requirement exactly -- they can choose to implement the thin interface
      required methods, or write a more fittable one -- either of them require
      their own coding.

- Unlike in Java, adding a /concrete method/ to a /Scala trait/ is a *one-time
  effort* -- you only need to implement the /method/ once, in the /trait/
  itself, instead of needing to reimplement it for every /class/ that mixes in
  the /trait/.

  Thus, *rich* interfaces are _less_ work to provide in Scala than in a
  language without /traits/.

- =From Jian=
  The discussion above about "Thin vs Rich" is a discussion in general.
  For Scala, even the /rich interface (trait)/ doesn't add load to the
  _implementer_, a reasonable ~trait~

  + has a *STILL* _small number_ of /abstract methods/ --
    the part the implementer need to finish -- the coding load is still light.

    This is _the (still) thin part_ of the trait's interface

    and

  - defines a potentially _large number_ of /concrete methods/,
    *ALL _implemented in terms of_ the /abstract methods/.*

  - then you can mix the enrichment /trait/ into a /class/, *implement the thin
    portion of the interface*, and end up with a /class/ that has all of the
    rich interface available.

** 11.3 Traits as stackable modifications - 239 =Re-Read=
CLOSED: [2017-10-12 Thu 03:04]
- One major use of traits:
  turning a thin interface into a rich one.

- Now turn to a second major use of traits:
  providing stackable modifications to classes.

- Traits let you modify the methods of a class, and they do so in a way that
  allows you to stack those modifications with each other (order matters).

- As an example,
  _consider stacking modifications to a queue of integers_.

  + Two basic operations to the queue (FIFO):
    * ~put~
    * ~get~

  + Code:
    #+BEGIN_SRC scala
      abstract class IntQueue {
        def get(): Int
        def put(x: Int)
      }

      import scala.collection.mutable.ArrayBuffer

      class BasicIntQueue extends IntQueue {
        private val buf = new ArrayBuffer[Int]
        def get() = buf.remove(0)
        def put(x: Int) = { buf += x }
      }
    #+END_SRC

  + Given a class that implements such a queue, you could define traits to
    perform modifications such as these:
    * ~Doubling~: double all integers that are put in the queue
    * ~Incrementing~: increment all integers that are put in the queue
    * ~Filtering~: filter out negative integers from a queue

    These THREE traits represent /modifications/, because they modify the
    behavior of an underlying queue class rather than defining a full queue
    class themselves.

    The three are also /stackable/ -- you can select any of the three you
    like, mix them into a class, and obtain a new class that has all of the
    modifications you chose.

  + The implementations of three traits.
    #+BEGIN_SRC scala
      trait Doubling extends IntQueue {
        abstract override def put(x: Int) = { super.put(2 * x) }
      }

      trait Incrementing extends IntQueue {
        abstract override def put(x: Int) = { super.put(x + 1) }
      }

      trait Filtering extends IntQueue {
        abstract override def put(x: Int) = {
          if (x >= 0) super.put(x)
        }
      }
    #+END_SRC

    * If a /trait/ extends a class A, _ONLY_ classes that extends A can mix in
      this /trait/. For instance, you can mix ~Doubling~ into ~BasicIntQueue~,
      but NOT into ~Rational~.

    * If a /trait/ can have ~super~ call on a method declared ~abstract~.
      =TODO= =???=
      - Such calls are illegal for normal /classes/ because they will
        certainly fail at run time.
        =From Jian= since the current method ~m~ is ~abstract~, the ~m~
        method of the superclass is also ~abstract~.

      - For a trait, however, since ~super~ calls is dynamically bound, such a
        call can actually succeed.

      In this example the ~super~ call in ~trait Doubling~ will work so long
      as _the trait is mixed in after another trait or class that gives a
      concrete definition to the method_.

      This arrangement is frequently needed with traits that implement stackable
      modifications. To tell the compiler you are doing this on purpose, you
      must mark such methods as ~abstract override~. _This combination of
      modifiers is only allowed for members of traits, not classes_, and it
      means that the trait must be mixed into some class that has a concrete
      definition of the method in question.

  + Run and check the result:
    * Non-stacked
      #+BEGIN_SRC scala
        class MyQueue extends BasicIntQueue with Doubling

        val queue = new MyQueue
        // OR //
        // Use anonymous class `val queue = new BasicIntQueue with Doubling`

        queue.put(10)
        queue.get()
        // 20
      #+END_SRC

    * Stacked
      #+BEGIN_SRC scala
        val queue = (new BasicIntQueue
                         with Incrementing with Filtering)
        queue.put(-1)
        queue.put(0)
        queue.put(1)

        queue.get()
        // Int = 1
        queue.get()
        // Int = 2
      #+END_SRC

    * Stacked (different order)
      #+BEGIN_SRC scala
        val queue = (new BasicIntQueue
                         with Filtering with Incrementing)
        queue.put(-1)
        queue.put(0)
        queue.put(1)

        queue.get()
        // Int = 0
        queue.get()
        // Int = 1
        queue.get()
        // Int = 2
      #+END_SRC

  + Rules (roughly): =TODO= see the next section for details
    + traits further to the right take effect first.
      When you call a method on a class with mixins, the method in the trait
      furthest to the right is called first.

    + If that method calls ~super~, it invokes the method in the next trait to
      its left, and so on.

- Since _the order of traits is significant_,
  you must keep eyes open for opportunities to arrange code as stackable
  modifications.

- mixin :: a /trait/ that is _mixed into_ a /class/ (from footnote 2).

** 11.4 Why not multiple inheritance? - 243
CLOSED: [2018-03-21 Wed 23:13]
/Traits/ are a way to inherit from multiple class-like constructs, but they
*differ* in important ways from the /multiple inheritance/ present in many
languages.

- One _DIFFERENCE_ is especially important:
  the *interpretation* of ~super~.

- The precise order of the /linearization/ is described in the *language
  specification*.

- Example:
  #+BEGIN_SRC scala
    class Animal
    trait Furry extends Animal
    trait HasLegs extends Animal
    trait FourLegged extends HasLegs
    class Cat extends Animal with Furry with FourLegged
  #+END_SRC

  Left to Right:
  1. ~Animal~: ~Animal~ --> ~AnyRef~ --> ~Any~

  2. ~Furry~: ~Furry~ ===> ~Animal~ --> ~AnyRef~ --> ~Any~

  3. ~FourLegged~: ~FourLegged~ --> ~HasLegs~ ===> ~Furry~ ===> ~Animal~ --> ~AnyRef~ --> ~Any~

** 11.5 Trait parameters - 248
** 11.6 Conclusion - 250
   

** ===========================
** DONE 12 Traits - 257
 CLOSED: [2018-03-21 Wed 23:51]
** ---------------------------
** DONE 12.3 Example: Rectangular objects - 261
CLOSED: [2017-10-12 Thu 01:21]

** DONE 12.4 The ~Ordered~ trait - 264
CLOSED: [2017-10-12 Thu 01:38]
Do comparison manually:

footnote 1: This example is based on the ~Rational~ class shown in Listing 6.5
on page 151, with ~equals~, ~hashCode~, and modifications to ensure a
_positive_ ~denom~ added.
#+BEGIN_SRC scala
  class Rational(n: Int, d: Int) {
    def < (that: Rational) =
      this.numer * that.denom < that.numer * this.denom

    def > (that: Rational) = that < this

    def <= (that: Rational) = (this < that) || (this == that)

    def >= (that: Rational) = (this > that) || (this == that)
  }
#+END_SRC

Use the ~Ordered~ trait
#+BEGIN_SRC scala
  class Rational(n: Int, d: Int) extends Ordered[Rational] {
    //...
    def compare(that: Rational) =
      (this.numer * that.denom) - (that.numer * this.denom)
  }
#+END_SRC

** DONE 12.7 To trait or not to trait? - 274 =IMPORTANT=
CLOSED: [2018-03-21 Wed 23:50]
There is *NO* firm rules about the choice of using /trait/ or /abstract class/
for a specific use case. ONLY guidelines:

- If the behavior will _NOT be reused_, then make it a /concrete class/. It
  is not reusable behavior after all.

- If it might be reused in _multiple, *unrelated* classes_, make it a /trait/.
  Only traits can be mixed into different parts of the class hierarchy.

- If you want to _inherit from it in Java code_, use an /abstract class/.
  Since traits with code do not have a close Java analog, it tends to be
  *AWKWARD* to _inherit from a trait in a Java class_.

  =TODO= Learn the conversion rules from Scala /trait/ to Java code!!! =TODO=

  Inheriting from a Scala class, meanwhile, is exactly like inheriting from a
  Java class.

  *As one EXCEPTION*,
  _a /Scala trait/ with only abstract members translates directly to a /Java
  interface/_, so you should feel free to define such /traits/ even if you
  expect Java code to inherit from it.
  =TODO= =IMPORTANT=
  See Chapter 31 for more information on working with Java and Scala together.

- If you plan to _distribute it in compiled form_, and you expect outside groups
  to write classes inheriting from it, you might lean towards using an
  /abstract class/.

  The issue is that when a trait gains or loses a member, any classes that
  inherit from it must be recompiled, even if they have not changed.

  If outside clients will only call into the behavior, instead of inheriting
  from it, then using a trait is fine.

- *Default Choice* if NOT used in Java code:
  If you _still do not know, after considering the above_,
  then START BY making it as a /trait/.

  You can always change it later, and in general using a /trait/ _keeps more
  options open_.

** DONE 12.8 Conclusion - 275
CLOSED: [2017-10-12 Thu 03:39]
_Mix in multiple traits_ are similar to /multiple inheritance/.
But because /traits/ interpret ~super~ using /linearization/, they both
- _AVOID_ some of the difficulties of traditional multiple inheritance
  and
- _ALLOW_ you to stack behaviors.

* DONE 12 Packages, Imports, and Exports - 251
CLOSED: [2025-04-17 Thu 10:49]
- When working on a program, especially a large one, it is important to
  *minimize* /coupling/ -- the extent to which the various parts of the program
  rely on the other parts. _LOW coupling_ *reduces* the risk that a small,
  seemingly innocuous change in one part of the program will have devastating
  consequences in another part.

- *One way to minimize coupling is to write in a modular style*:
  You divide the program into a number of smaller modules, each of which has an
  *inside* and an *outside*.
  * When working on the inside of a module -- its implementation -- you need
    only coordinate with other programmers working on that very same module.

  * Only when you must change the outside of a module -- its interface -- is it
    necessary to coordinate with developers working on other modules.

- *This chapter shows several constructs that help you program in a /modular style/.*
  It shows
  1. how to place things in packages,
  2. make names visible through imports, and
  3. control the visibility of definitions through access modifiers.

  The constructs are _similar in spirit to_ constructs in Java,
  _BUT_ there are some differences -- _usually ways that are more consistent_ --
  so it's worth reading this chapter even if you already know Java.
  =from Jian=
  Add more details

** DONE 12.1 Putting code in packages - 251
CLOSED: [2025-04-16 Wed 11:47]
Scala code resides in _the Java platform's global hierarchy of packages._

- The example code you've seen so far in this book has been in the /unnamed
  package/.

- =IMPORTANT=
  It is recommended to follow Java's reverse-domain-name convention for Scala
  packages that you release to the public.

  * Here, we (=from Jian= the book) use a shorter form in the following
    examples. A better name is like ~com.bobsrockets.navigation~.

- You can place code into /named packages/ in Scala in _TWO_ ways:
  1. =from Jian= *The Java way!*
     You can place the contents of an *ENTIRE file* into a /package/
     _BY_
     putting a /package clause/ at the top of the file, as shown in _Listing
     12.1_:
     #+begin_src scala
       package bobsrockets.navigation

       class Navigator
       // ...
     #+end_src
     Listing 12.1 · Placing the contents of an entire file into a package.

  2. The other way you can place code into /packages/ in Scala is more LIKE /C#
     namespaces/: follow a /package clause/ by a _colon_ and an _indented_
     section of code containing the definitions that go into the /package/.

     =from Jian= Current book emphasize brace-less syntax. The syntax with
     braces in Scala 2 is the *same* as the syntax in C#, *not just like.*

     *This syntax is called a /packaging/.*
     =FIXME= Remove a???

     _Listing 12.2_ has the same effect as the code in _Listing 12.1_:
     #+begin_src scala
       package bobsrockets.navigation:
         class Navigator
     #+end_src
     Listing 12.2 · Long form of a simple package declaration.

- Usage:
  * For such simple examples, you might as well use the /syntactic sugar/ shown in
    Listing 12.1.
    =FIXME=
    =from Jian= Before this line, the book doesn't mention the second form is
    the /syntactic sugar/ of the first form.

  * However, one use of _the *more general* notation_ is to have different parts
    of _A_ file in different /packages/.
    + For example, if you want to email or post to a discussion forum a snippet
      of Scala code that involves SEVERAL /packages/, you can use /packaging/,
      as shown in Listing 12.3.
    #+begin_src scala
      package bobsrockets:
        package navigation:
          // In package bobsrockets.navigation
          class Navigator
          package launch:
            // In package bobsrockets.navigation.launch
            class Booster

          class Navigator2 // Added by me, Jian Lan, just for this note
    #+end_src
    Listing 12.3 · Multiple packages in the same file.

    + =IMPORTANT=
      =from Jian=
      This syntax has an _VARIANT_, which is simpler -- no colons and
      indentations, but has one *limitation*. It is called /chained package
      clauses/, which is mentioned in the next section.

      Here is a rewritten of Listing 12.3 code in /chained package clauses/
      syntax, and ~Navigator~ and ~Navigator2~ can't show up in the old place!
      #+begin_src scala
        package bobsrockets
        package navigation
        package launch

        // In package bobsrockets.navigation.launch
        class Booster
      #+end_src

** DONE 12.2 Concise access to related code - 252
CLOSED: [2025-04-16 Wed 12:37]
- When code is divided into a /package hierarchy/,
  * it doesn't just help people browse through the code.
  * It also tells the compiler that code in the SAME /package/ is related in
    some way to each other.

- Scala takes advantage of this relatedness by allowing _short, unqualified
  names_ when accessing code that is in the SAME /package/ -- =from Jian= only
  when not using the _One package per file_ way.

  * Different ways of packaging affect the way of using names outside _CURRENT_
    package:
    + If you use _one package per file_ way, the name outside current package must be
      imported before using.
      - =from Jian=
        Same as in Java! This rule very simple but may result in redundant code
        in some scenarios.

    + *Explicitly* nest the packagings:
      #+begin_src scala
        package bobsrockets:
          package navigation:
            class Navigator:
              // No need to say bobsrockets.navigation.StarMap
              val map = new StarMap

            class StarMap

          class Ship:
            // No need to say bobsrockets.navigation.Navigator
            val nav = new navigation.Navigator

          package fleets:
            class Fleet:
              // No need to say bobsrockets.Ship
              def addShip = new Ship
      #+end_src
      Listing 12.4 · Concise access to classes and packages.

      _Inner packages_ can see names in the _same package_ and in its _packages
      that wrap it_.

      - A variant:
        the /chained package clauses/ syntax.

    + *NOT Explicitly* nest the packagings:
      #+begin_src scala
        package bobsrockets:
          class Ship

        package bobsrockets.fleets:
          class Fleet:
            // Doesn't compile! Ship is not in scope.
            def addShip = new Ship
      #+end_src
      Listing 12.5 · Symbols in enclosing packages not automatically available.

      =from Jian=
      Logically, one package include another one, but not in actual code.
      A name in the "outside" pcakge is not automatically visible by the "inner"
      package. _For visibility, only "logically nested" is NOT enough._

  * ~_root_~:
    Scala must handle /package name hiding issue/ because of the support to
    package organization not in the form of _one package per file_:
    #+begin_src scala
      // In file launch.scala
      package launch:
        class Booster3

      // In file bobsrockets.scala
      package bobsrockets:
        package launch:
          class Booster2

        package navigation:
          package launch:
            class Booster1

          class MissionControl:
            val booster1 = new launch.Booster1
            val booster2 = new bobsrockets.launch.Booster2
            val booster3 = new _root_.launch.Booster3
    #+end_src
    If no ~_root_~, there is no way to express ~booster3~ value.

** DONE 12.3 Imports - 256
CLOSED: [2025-04-16 Wed 13:10]
- Simple imports that you can find their counterparts in Java:
  #+begin_src scala
    // easy access to Fruit
    import bobsdelights.Fruit

    // easy access to all members of bobsdelights
    import bobsdelights.*

    // easy access to all members of Fruits
    import bobsdelights.Fruits.*
  #+end_src
  Coresponds to Java's
  1. single type import
  2. on-demand imports
  3. import of static class fields

- _Scala's flexible imports_
  Scala's ~import~ clauses are quite a bit more flexible than Java's. There are
  three principal differences. In Scala, imports:
  * may appear anywhere
  * may refer to objects (singleton or regular) in addition to packages
  * let you rename and hide some of the imported members

- *Scala can import any value memebers!*
  #+begin_src scala
    val fruit = Fruit(..)

    def showFurit(fruit: Fruit) =
      import fruit.*
      s"${name}s are $color"
  #+end_src

- /import selector clause/ examples:
  * ~import Fruits.{Apple, Orange}~

  * ~import Fruits.{Apple as McIntosh, Orange}~
    ~import java.sql.Date as SDate~
    with renaming.

  * ~import Fruits.{Apple as _, *}~
    Import everything except ~Apple~
    + =from Jian=
      =IMPORTANT=
      =IMPORTANT=
      =IMPORTANT=
      I think this syntax is not good, it can create a import clause like:
      ~import Fruits.{Apple as _, Orange}~ which hiding is useless!

      How about introduce a syntax like (need a new soft keyword ~except~):
      ~import Fruits.* except Apple~
      ~import Fruits.* except {Apple, Orange}~

      and make the linter warns the programmer that try to use this syntax
      instead of the ~as _~ one or just deprecate the ~as _~ import syntax?!

** DONE 12.4 Implicit imports - 259
CLOSED: [2025-04-16 Wed 14:05]
Scala adds some imports _implicitly_ to _every_ program.
In essence, it is as if
the following three import clauses had been added to the top of every source
file with extension ".scala":

#+begin_src scala
  import java.lang.* // everything in the java.lang package
  import scala.*     // everything in the scala package
  import Predef.*    // everything in the Predef object
#+end_src
- The ~java.lang~ package contains standard Java classes.

- As you have no doubt realized by now, the ~scala~ package contains the
  standard Scala library, with many common classes and objects.

- The ~Predef~ object contains many definitions of
  * /type aliases/,
  * /methods/, and
  * /conversions/
  that are commonly used on Scala programs.

These _THREE_ import clauses are treated *a bit specially* in that later imports
_overshadow_ earlier ones.

- For instance,
  the ~StringBuilder~ class is defined _BOTH in package ~scala~ and ~java.lang~._
  Because the scala import *overshadows* the ~java.lang~ import, the simple name
  ~StringBuilder~ will refer to ~scala.StringBuilder~, *NOT*
  ~java.lang.StringBuilder~.

** TODO 12.5 Access modifiers - 260 - = =RE-READ: Scope of protection=
Access modifiers ~private~ and ~protected~.

Scala's treatment of /access modifiers/ roughly follows Java's
_BUT_ there are *some important differences* which are explained in this
section.

*** Private members - 260
A member labeled ~private~ is visible only inside the /class/ or /object/ that
contains the member definition.

DIFFERENCES between Scala and Java:

- In Scala, inner class private members only belongs to itself, its host /class/
  or /object/ *CANNOT* access them.

  #+begin_src scala
    class Outer:
      class Inner:
        private def f = "f"
        class InnerMost:
          f // OK

      (new Inner).f // error: f is not accessible
  #+end_src
  Listing 12.10 · How private access differs in Scala and Java.

- In Java, inner class private members can be accessed.
  (If the code above is in Java) Java would permit *BOTH accesses* because it
  lets an _outer class_ access private members of its _inner classes_.

*** Protected members - 261
Access to /protected members/ in Scala is also a bit *more restrictive* than in
Java.

#+begin_src scala
  package p:
    class Super:
      protected def f = "f"

    class Sub extends Super:
      f

    class Other:
        (new Super).f // error: f is not accessible
#+end_src
Listing 12.11 · How protected access differs in Scala and Java.

DIFFERENCES between Scala and Java:

- In Scala,
  a /protected member/ is ONLY accessible from /subclasses/ of the /class/ in
  which the member is defined.

- In Java
  such accesses are also possible _from other /classes/ in the *same*
  /package/._
  * In Scala, there is another way to achieve this effect.

*** Public members - 262
Scala has _no explicit modifier_ for /public members/: Any member not labeled
~private~ or ~protected~ is _public_. /Public members/ can be accessed from
anywhere.

*** Scope of protection - 262
/Access modifiers/ in Scala can be *AUGMENTED* with qualifiers.

- A modifier of the form ~private[X]~ or ~protected[X]~ means
  access is _private_ or _protected_ "up to" ~X~, where ~X~ designates some
  enclosing package, class or singleton object.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  /Qualified access modifiers/ give you very _fine-grained control_ over
  /visibility/.

  * In particular they enable you to express Java's accessibility notions,
    such as
    + package private,
    + package protected, or
    + private up to outermost class,

    which are _not directly expressible_ with simple modifiers in Scala.
    But they also let you express accessibility rules that cannot be expressed
    in Java.

- Listing 12.12 · Flexible scope of protection with access qualifiers.
  #+begin_src scala
    package bobsrockets

    package navigation:
      private[bobsrockets] class Navigator:
        protected[navigation] def useStarChart() = {}
        class LegOfJourney:
          private[Navigator] val distance = 100

    package launch:
      import navigation.*
      object Vehicle:
        private[launch] val guide = new Navigator
  #+end_src
  * ~class Navigator~ is labeled ~private[bobsrockets]~.
    This means that
    this /class/ is visible in all /classes/ and /objects/ that are *contained
    in package ~bobsrockets~.*

    + This is why ~object Vehicle~ can access to ~Navigator~.

- This technique is quite useful in large projects that span several packages.
  It allows you to define things that are visible in several sub-packages of
  your project but that remain hidden from clients external to your project.

- Of course, the qualifier of a ~private~ may also be the /directly enclosing
  package/. An example is the access modifier of ~guide~ in ~object Vehicle~ in
  Listing 12.12. Such an /access modifier/ is equivalent to /Java's package
  private access/.

- All qualifiers can also be applied to ~protected~, with the same meaning as
  ~private~.

  * ~protected[X]~ in a ~class C~ allows access to the labeled definition in all
    /subclasses/ of ~C~ and also within _the ENCLOSING /package/, /class/, or
    /object/ ~X~._

    For instance,
    the ~useStarChart~ method in Listing 12.12 is accessible in all /subclasses/
    of ~Navigator~ and also in all code contained in the /enclosing package/
    ~navigation~.

    It thus corresponds _exactly to the meaning of ~protected~ in Java._

- The qualifiers of ~private~ can also refer to _an ENCLOSING /class/ or
  /object/._

  For instance the ~distance~ variable in class ~LegOfJourney~ in Listing 12.12
  is labeled ~private[Navigator]~, so it is visible from everywhere in class
  ~Navigator~.

  *This gives the SAME ACCESS capabilities as for
  _private members of inner classes in Java_.*

  A ~private[C]~ where ~C~ is the _outermost enclosing class_ is the same as
  _just ~private~ in Java._

- To summarize, Table 12.1 on page 263 lists the effects of /private
  qualifiers/. Each line shows a /qualified private modifier/ and what it would
  mean if such a modifier were attached to the ~distance~ variable declared in
  ~class LegOfJourney~ in Listing 12.12.

  Table 12.1 · Effects of private qualifiers on ~LegOfJourney.distance~
  | no access modifier      | public access                      |
  |-------------------------+------------------------------------|
  | ~private[bobsrockets]~  | access within outer package        |
  | ~private[navigation]~   | same as package visibility in Java |
  | ~private[Navigator]~    | same as ~private~ in Java          |
  | ~private[LegOfJourney]~ | same as ~private~ in Scala         |

*** Visibility and companion objects - 264
Listing 12.13: Accessing _private members_ of /companion classes and objects/.
#+begin_src scala
  class Rocket:
    import Rocket.fuel
    private def canGoHomeAgain = fuel > 20

  object Rocket:
    private def fuel = 10
    def chooseStrategy(rocket: Rocket) =
      if rocket.canGoHomeAgain then
        goHome()
      else
        pickAStar()

    def goHome() = {}
    def pickAStar() = {}
#+end_src

- Scala's access rules privilege companion objects and classes when it comes to
  ~private~ or ~protected~ accesses.

  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  _A /class/ *shares all its access rights* with its /companion object/ and vice
  versa._

- One *EXCEPTION* where the similarity between Scala and Java breaks down concerns
  ~protected static~ members.
  * In Java, _a ~protected static~ member_ of a Java ~class C~ can be accessed in
    ALL /subclasses/ of ~C~.

  * By contrast,
    a ~protected~ member in a /companion object/ *makes no sense*, as singleton objects
    *don't have any* /subclasses/.
    + =from Jian= a ~protected~ member in a /companion object/ is always static!

    + =from Jian=
      =IMPORTANT=
      _NOT DISCUSSED IN DETAILS IN THE BOOK, HERE IS MY THINKING!_
      I guess here *makes no sense* means *makes no sense to consider
      its subclasses accessibility* Since Scala doesn't forbid it, it might be
      useful by itself.

      - Q :: Then why do Scala still allow /protected memebers/ in companion objects
             in syntax?
      - A :: In Scala, any ~object~ can extends /classes/ or /traits/, which can have
             /protected memebers/ that, of course, can be *overrided*.

             This is the reason in syntax:
             #+begin_src scala
               class X:
                 def bar(): Unit =
                   X.foo()

               class XX:
                 protected def foo(): Unit =
                   println("Here is XX!")

               object X extends XX:
                 override protected def foo(): Unit =
                   super.foo()
                   println("Here is the `X` companion object, a subclass of `XX`!")
             #+end_src

             Since the ~protected~ must be overrided by a ~protected~, there is
             no way to forbid ~protected~ from /companion object/'s or any other
             /object/'s.

** DONE 12.6 Top-level definitions - 265
CLOSED: [2025-04-16 Wed 16:26]
*Any* kind of definition that you can put inside a /class/ can also be at the
top level of a /package/.

- Top-level definitions are frequently used to hold
  * /package-wide helper functions/ (mentioned in the last paragraph, and =Jian=
    move it to here)
  * /package-wide type aliases/ (Chapter 20)
  * /extension methods/ (Chapter 22).

- The ~scala~ package includes top-level definitions, which are available to all
  Scala code.

- =from Jian=
  /package object/ in Scala 2 is no longer needed.

** DONE 12.7 Exports - 266
CLOSED: [2025-04-16 Wed 20:34]
- In Section 10.11 we recommended that
  you should _PREFER /composition/ OVER /inheritance/,_
  * ESPECIALLY when your primary goal is *code reuse*.

- _PREFER /composition/ OVER /inheritance/_ is an application of /the principle
  of least power/:
  /Composition/ treats components as blackboxes
  whereas
  /inheritance/ can affect the internal workings of components through
  /overriding/.

  * Sometimes the _tight coupling_ implied by /inheritance/ is the best solution
    for a problem,
    _BUT_ where this is not necessary the /looser coupling/ of /composition/ is
    better.
    (=from Jian= more than 90% use cases)

- In most popular object-oriented programming languages it is easier to use
  /inheritance/ than /composition/. =from Jian= This is BAD!

  In Scala 2, for example,
  /inheritance/ only required an ~extends~ clause
  whereas /composition/ required _a verbose elaboration of a sequence of
  forwarders_.

  * =IMPORTANT=
    _CONCLUSION_:
    Most object-oriented languages have, therefore, been pushing programmers to
    a solution that is often too powerful.

- /Exports/, a new feature introduced in Scala 3, aim to redress this imbalance.
  * /Exports/ make /composition relationships/ *as concise and easy to express as*
    /inheritance relationships/.
    + =from Jian=
      If there a way that can make /composition relationships/ more easier, it
      will be a perfect solution. =HowTo???=

  * /Exports/ also offer _more flexibility than_ ~extends~ clauses,
    since members can be *renamed* or *omitted*.

- Example:
  #+begin_src scala
    case class PosInt(value: Int):
      require(value > 0)
      export value.{<< as shl, >> as shr, >>> as _, *}
  #+end_src
  ~PosInt~ has almost all methods of ~Int~ but not ~>>>~.
  Renames renames << and >>, and drop their symbolic names.

** DONE 12.8 Conclusion - 269
CLOSED: [2025-04-16 Wed 20:50]
- In this chapter, you saw the basic constructs for dividing a program into
  /packages/.

  This gives you a simple and useful kind of /modularity/,
  so that
  you can work with very large bodies of code without different parts of the
  code trampling on each other.

- Scala's (=FIXME= packages instead of system) system is _the same in spirit_ as
  Java's packages, but there are _some differences_ where Scala chooses to be
  more consistent or more general.

- New feature: /exports/.
  It aims to make /composition/ as convenient as /inheritance/ for code reuse.

- =???=
  =TODO=
  =IMPORTANT=
  Looking ahead, Advanced Programming in Scala describes a more flexible module
  system than division into packages.

  * In addition to letting you separate code into several namespaces, that
    approach allows modules to be /parameterized/ and /inherit/ from each other.

- =NEXT=
  In the next chapter, we'll turn our attention to /pattern matching/.

* DONE 13 Pattern Matching - 270
CLOSED: [2025-04-17 Thu 19:13]
- This chapter describes
  * /case classes/ and
  * /pattern matching/,
  constructs support you when writing _regular, non-encapsulated data structures._

- These two constructs are particularly helpful for _tree-like recursive data_.

- /Case classes/ are Scala's way to allow /pattern matching/ on objects
  _WITHOUT_ requiring a large amount of boilerplate.

- This chapter
  1. starts with an example of case classes and pattern matching.
  2. It then goes through all of the kinds of _patterns_ that are supported,
  3. talks about the role of /sealed classes/,
  4. discusses /enums/, ~Option~'s, and
  5. shows some _NON-OBVIOUS places_ in the language where /pattern matching/ is used.
  6. Finally, a larger, more realistic example of /pattern matching/ is shown.

** DONE 13.1 A simple example - 270
CLOSED: [2025-04-17 Thu 11:25]
#+begin_src scala
  trait Expr
  case class Var(name: String) extends Expr
  case class Num(number: Double) extends Expr
  case class UnOp(operator: String, arg: Expr) extends Expr
  case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
#+end_src
Listing 13.1 · Defining case classes.

*** Case classes - 271
- The ~case~ modifier makes the Scala compiler _ADD_ some syntactic conveniences
  to your /class/.
  * Adds a /factory method/ with the name of the /class/.
    Use a noiseless way to construct a new object, especially when nesting them:
    #+begin_src scala
      val v = Var("x")

      val op = BinOp("+", Num(1), v)
    #+end_src

  * The parameter of a /case class/ implicitly get a ~val~ prefix.

  * The compiler adds "natural" implementations of methods ~toString~,
    ~hashCode~, and ~equals~ to your /class/.
    + Since ~==~ in Scala always delegates to ~equals~, this means that elements
      of /case classes/ are always compared structurally.

  * Finally, the compiler adds a ~copy~ method to your /class/ for making
    modified copies.
    #+begin_src scala
      op.copy(operator = "-") // BinOp("-", Num(1.0), Var("x"))
    #+end_src

- All these conventions add a lot of convenience -- at a small price.

  You have to write the ~case~ modifier, and your /classes/ and /objects/
  _become a bit LARGER._

  * They are _LARGER_
    BECAUSE
    + additional methods are generated and
    + an /implicit field/ is added for each /constructor parameter/.

  However, the biggest advantage of case classes is that they support pattern
  matching.

*** Pattern matching - 272
- Example:
  #+begin_src scala
    def simplifyTop(expr: Expr): Expr =
      expr match
        case UnOp("-", UnOp("-", e)) => e // Double negation
        case BinOp("+", e, Num(0)) => e // Adding zero
        case BinOp("*", e, Num(1)) => e // Multiplying by one
        case _ => expr
  #+end_src
  Listing 13.2 · The simplifyTop function, which does a pattern match.

- Imagine trying to implement this same functionality using the /visitor design/
  pattern!
  =TODO=
  =IMPORTANT=

  Almost as awkward, imagine implementing it as a long sequence of ~if~
  statements, _type tests_, and _type casts_.

*** ~match~ compared to ~switch~ - 274
- /Match expressions/ can be seen as a *generalization* of /Java-style switches/.

- A /Java-style switch/ can be _naturally expressed_ as a /match expression/,
  where each /pattern/ is a constant and the last pattern may be a wildcard (which
  represents the default case of the switch).

- However, there are *THREE differences* to keep in mind:
  1. ~match~ is an /expression/ in Scala (i.e., it always results in a value).
  2. Scala's alternative expressions *NEVER "fall through"* into the next
     ~case~.
  3. If none of the patterns match, an exception named ~MatchError~ is thrown.

** DONE 13.2 Kinds of patterns - 274
CLOSED: [2025-04-17 Thu 13:56]
*** Wildcard patterns - 275
The ~_~ pattern.

*** Constant patterns - 275
A /constant pattern/ matches only itself.
Any /literal/ may be used as a constant.

*** Variable patterns - 276
- Q :: How does the Scala compiler know that a symbol, like ~Pi~ (from
       ~scala.math~), is a constant?

- A :: Scala uses a simple lexical rule for disambiguation:
  * a _simple name_ starting with a *lowercase letter* is taken to be a /pattern
    variable/;
  * all other references are taken to be /constants/.
    + You can still use a name starting with a lowercase letter for a /pattern
      constant/, if you need to, by using one of two tricks (~`~).

    + Or if it is a member of an object, like ~this.pi~ (if this is a constant),
      it can be considered as a /pattern constant/ even if it starts with a
      lowercase letter.

- A SUMMARY (till now) about the usage of _back-tick syntax_:
  As you can see, the back-tick syntax for /identifiers/ is used for two
  different purposes in Scala (=from Jian= both of them are used to) *help you
  code your way out of unusual circumstances*.

  * Here you can see
    it can be used to *treat a lowercase identifier as a constant* in a /pattern
    match/.

  * Earlier on, in Section 6.10, you saw that
    it can also be used to *treat a keyword as an _ordinary identifier_,* e.g.,
    writing ~Thread.`yield`()~ treats ~yield~ as an /identifier/ rather than a
    /keyword/.

*** Constructor patterns - 278
The most commonly used patterns.

*** Sequence patterns - 279
~case List(0, _, _)~
~case List(0, _*)~

*** Tuple patterns - 279
*** Typed patterns - 280 - =REVIEW=
#+begin_src scala
  def generalSize(x: Any) =
    x match
      case s: String => s.length
      case m: Map[_, _] => m.size
      case _ => 1
#+end_src

- =IMPORTANT=
  As you will have noted by now, writing /type tests and casts/ is RATHER
  VERBOSE in Scala.

  _That's INTENTIONAL_ because *it is NOT ENCOURAGED practice.*

  *You are usually BETTER OFF using a /pattern match/ with a /typed pattern/.*
  That's *particularly true* if you need to do both a /type test/ and a /type
  cast/, because both operations are then rolled into a single pattern match.

- *Type ascription*
  * *Casts are inherently unsafe.*
    It can compile but fail at runtime!

  * An ALTERNATIVE to /casts/ that is *always safe* is /type ascription/: any
    invalid ascription will give you a compiler error, not a runtime exception.
    #+begin_src scala
      3: String

      // 1 |3: String
      //   |^
      //   |Found:    (3 : Int)
      //   |Required: String
    #+end_src

    + A /type ascription/ will compile in only TWO cases:
      1. you can use a /type ascription/ to *widen* a type to one of its
         /supertypes/. For example:
         #+begin_src scala
           // In REPL

           Var("x"): Expr // Expr is a supertype of Var
           // val res0: Expr = Var(x)
         #+end_src

      2. you can use a /type ascription/ to *implicitly convert* one type
         to another, such as implicitly converting an ~Int~ to ~Long~:
         #+begin_src scala
           // In REPL

           3: Long
           // val res1: Long = 3
         #+end_src

- /Type erasure/
  * You *cannot* simple check if a map with specific element types because of
    /type erasure/.
    #+begin_src scala
      def isIntIntMap(x: Any) =
        x match
          case m: Map[Int, Int] => true
          case _ => false
    #+end_src
    + Compilation warning:
      #+begin_src text
        def isIntIntMap(x: Any): Boolean
        3 | case m: Map[Int, Int] => true
          |      ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆ
          |      the type test for Map[Int, Int] cannot be
          |      checked at runtime
      #+end_src

    + This can show the "cannot be checked at runtime" fact:
      #+begin_src scala
        isIntIntMap(Map(1 > 1))         // true
        isIntIntMap(Map("abc" > "abc")) // true
      #+end_src

  * The Only EXCEPTION:
    _The only exception to the erasure rule is arrays,_
    BECAUSE _they are *handled specially* in Java as well as in Scala._
    *The /element type/ of an ARRAY is _stored with the array value_,*
    so you can pattern match on it. Here's an example:
    #+begin_src scala
      def isStringArray(x: Any) =
        x match
          case a: Array[String] => "yes"
          case _ => "no"

      isStringArray(Array("abc"))   // yes
      isStringArray(Array(1, 2, 3)) // no
    #+end_src

- =IMPORTANT=
  =from Jian=
  The bellow is NOT mentioned here in this chapter.

  To address the /type erasure/ issue, Scala 2 use ~ClassTag~, and Scala 3
  introduces ~TypeTest~. Since ~ClassTag~ is unsound and ~TypeTest~ fixes it.
  Should use ~TypeTest~ if in Scala 3!!!

  * Learn more about ~TypeTest~:
    https://docs.scala-lang.org/scala3/reference/other-new-features/type-test.html
    =TODO=
    =TODO=
    =TODO=

*** Variable binding - 284
- Use ~@~
  Example:
  #+begin_src scala
    expr match
      case UnOp("abs", e @ UnOp("abs", _)) => e
      case _ =>
  #+end_src
  Listing 13.13 · A pattern with a variable binding (via the ~@~ sign).

- Anoter /variable binding/ (in general) without using ~@~:
  =from Jian=
  =IMPORTANT=
  Should add a string interploation-like variable binding form added in some
  version of Scala 2.12 or 2.13.
  #+begin_src scala
    "x y x" match {
      case s"x $y x" => y
      case _ => "z"
    }
    // y
  #+end_src

** DONE 13.3 Pattern guards - 284
CLOSED: [2025-04-17 Thu 14:00]
Scala restricts patterns to be /linear/:
a /pattern variable/ may only appear *once* in a pattern.

Use /pattern guard/ to do further check.

You can't write a match case like:
~case BinOp("+", x, x) => ..~

You should write it with /pattern guard/:
~case BinOp("+", x, y) if x == y => ..~

** DONE 13.4 Pattern overlaps - 285
CLOSED: [2025-04-17 Thu 18:41]
The order of cases matters.

** DONE 13.5 Sealed classes - 287
CLOSED: [2025-04-17 Thu 18:48]
Make the /superclass/ of your /case classes/ *sealed*,
and then the compiler can do /exhaustivity checking/ when applying pattern
matching.

- The ~sealed~ keyword, therefore, is often a license to /pattern match/.

- Use ~@unchecked~ to suppress /exhaustivity checking/ for /pattern matching/.

** DONE 13.6 Pattern matching ~Option~'s - 289
CLOSED: [2025-04-17 Thu 18:49]

Talk about ~Option~'s in Scala and ~null~ in Java, and why ~Option~ is good.
People often handle ~Option~'s with /pattern matching/.

** DONE 13.7 Patterns everywhere - 291
CLOSED: [2025-04-17 Thu 19:11]
=IMPORTANT=
/Patterns/ are allowed in many parts of Scala, not just in standalone
~match~ expressions. Take a look at some other places you can use patterns.

*** Patterns in variable definitions - 291
#+begin_src scala
  // scala>
  val myTuple = (123, "abc")
  // val myTuple: (Int, String) = (123,abc)

  // scala>
  val (number, string) = myTuple
  // val number: Int = 123
  // val string: String = abc
#+end_src

*** Case sequences as partial functions - 291
_A sequence of ~case~'s (i.e., alternatives) in curly braces_ can be used
anywhere a /function literal/ can be used.
=FIXME=

=from Jian=
_A sequence of ~case~'s (i.e., alternatives) their own code block_ can be used
anywhere a /function literal/ can be used.

- Example:
  #+begin_src scala
    val withDefault: Option[Int] => Int =
      case Some(x) => x
      case None => 0
  #+end_src

- Partial function :: a function that doesn't covers all values of its input
  type, represented by a sequence of cases in Scala.
  * If you apply such a function on a value it does NOT SUPPORT, it will
    generate a _run-time exception_.

- Partial function type: ~PartialFunction[I, O]~
  * It has method ~isDefinedAt~.

- This facility is quite useful for the Akka actors library, because it allows
  its ~receive~ method to be defined as a series of cases:
  #+begin_src scala
    var sum = 0

    def receive =
      case Data(byte) =>
        sum += byte

      case GetChecksum(requester) =>
        val checksum = ~(sum & 0xFF) + 1
        requester ! checksum
  #+end_src

- A /function literal/, for instance,
  #+begin_src scala
    { case x :: y :: _ => y }
  #+end_src

  gets translated to the following /partial function value/:

  #+begin_src scala
    new PartialFunction[List[Int], Int]:

      def apply(xs: List[Int]) =
        xs match
          case x :: y :: _ => y

      def isDefinedAt(xs: List[Int]) =
        xs match
          case x :: y :: _ => true
          case _ => false
  #+end_src

- _IN GENERAL_, you should try to work with /complete functions/ *whenever
  possible*, because using /partial functions/ _allows for runtime errors_ that
  the compiler cannot help you with.

- _SOMETIMES_ /partial functions/ are really helpful though. You might be sure that
  an unhandled value will never be supplied.

  ALTERNATIVELY, you might be using a framework that expects /partial functions/
  and so will always check ~isDefinedAt~ before calling the function.

  * An example of the latter is the ~receive~ method given previously, where the
    result is a /partially defined function/, defined precisely for those
    messages that the caller wants to handle.

*** Patterns in ~for~ expressions - 294
#+begin_src scala
  for (country, city) <- capitals yield
    s"The capital of $country is $city"
  //
  // List(The capital of France is Paris,
  // The capital of Japan is Tokyo)
#+end_src
Listing 13.18 · A for expression with a tuple pattern.

- If pattern may not match some values, the ~for~ expression will drop the
  values not matched, and only process the matched values:
  #+begin_src scala
    val results = List(Some("apple"), None, Some("orange"))
    for Some(fruit) <- results yield fruit
    // List(apple, orange)
  #+end_src
  Listing 13.19 · Picking elements of a list that match a pattern.

** TODO 13.8 A larger example - 295 - =TODO: Small- Project=
** DONE 13.9 Conclusion - 303
CLOSED: [2025-04-17 Thu 19:13]

* DONE 14 Working with Lists - 304
CLOSED: [2025-04-19 Sat 15:24]
~List~'s are probably the _most commonly used_ /data structure/ in Scala
programs.

This chapter
- Explains lists in DETAIL.
- We will present many common operations that can be performed on lists.
- We'll also cover some important design principles for programs working on lists.

** DONE 14.1 List literals - 304
CLOSED: [2025-04-19 Sat 11:41]
/Lists/ are QUITE SIMILAR to /arrays/, but there are _TWO important
differences_:
1. /lists/ are *immutable*.
2. /lists/ have a /recursive structure/ (i.e., a linked list), whereas /arrays/
   are _flat_.

** DONE 14.2 The ~List~ type - 305
CLOSED: [2025-04-19 Sat 11:41]
- Like /arrays/, /lists/ are _HOMOGENEOUS_: the elements of a list all have the
  same type.

- The ~List~ type in Scala is /covariant/.
- Note the _empty list_ has type ~List[Nothing]~

** DONE 14.3 Constructing lists - 305
CLOSED: [2025-04-19 Sat 11:42]
- ~::~ (pronounced "cons").
  * associates to the right

- ~Nil~

** DONE 14.4 Basic operations on lists - 306
CLOSED: [2025-04-19 Sat 11:44]
- Example:
  Insertion sort algorithm
  #+begin_src scala
    def isort(xs: List[Int]): List[Int] =
      if xs.isEmpty then Nil
      else insert(xs.head, isort(xs.tail))

    def insert(x: Int, xs: List[Int]): List[Int] =
      if xs.isEmpty || x <= xs.head then x :: xs
      else xs.head :: insert(x, xs.tail)
  #+end_src

** DONE 14.5 List patterns - 307 - =TODO: Re-READ=
CLOSED: [2025-04-19 Sat 13:13]
- *About pattern matching on Lists*
  * If you review the possible forms of patterns explained in Chapter 13, you
    might find that _NEITHER ~List(...)~ NOR ~::~ look like it fits the kinds of
    patterns defined there._

    In fact, ~List(...)~ is an instance of a *library-defined* /extractor pattern/.
    =TODO= Such patterns will be discussed in Advanced Programming in Scala.

  * The /"cons" pattern/ ~x \colon{}\colon{} xs~ is a special case of an /infix operation pattern/.
    + As an /expression/, an /infix operation/ _is equivalent to_ a /method call/.
    + For /patterns/, the rules are different:
      As a pattern, an /infix operation/ such as ~p op q~ is equivalent to ~op(p, q)~.
      That is, the /infix operator/ ~op~ is treated as a /constructor pattern/.
      In particular, a /cons pattern/ such as ~x :: xs~ is treated as ~::(x, xs)~.

  * This hints that _there should be a /class/ named ~::~ that corresponds to
    the /pattern constructor/._

    Indeed, ~::~ is exactly the /class/ that builds non-empty lists.

    =INTERESTING=
    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    So ~::~ exists *TWICE* in Scala, once as a name of a /class/ and again as a
    /method/ in /class/ ~List~.

    The effect of the /method/ ~::~ is to produce an /instance/ of the ~class
    scala.:~:.

    =TODO=
    =NEXT=
    You can find out more details about how the ~List~ /class/ is implemented in
    _Advanced Programming in Scala_.

- Here's /insertion sort/ again (=from Jian= See example code in previous
  section), this time written with /pattern matching/:
  #+begin_src scala
    def isort(xs: List[Int]): List[Int] =
      xs match
        case List() => List()
        case x :: xs1 => insert(x, isort(xs1))

    def insert(x: Int, xs: List[Int]): List[Int] =
      xs match
        case List() => List(x)
        case y :: ys => if x <= y then x :: xs
                        else y :: insert(x, ys)
  #+end_src
  Often, /pattern matching/ over lists is *clearer* than _decomposing them with
  /methods/,_

** DONE 14.6 First-order methods on class ~List~ - 309
CLOSED: [2025-04-19 Sat 13:17]
*** Concatenating two lists - 309
~:::~

*** The Divide and Conquer principle - 310
*** Taking the length of a list: ~length~ - 311
*** Accessing the end of a list: ~init~ and ~last~ - 312
*** Reversing lists: ~reverse~ - 312
- The reverse, init, and last operations satisfy some laws that can be used for
  reasoning about computations and for simplifying programs.
  1. ~reverse~ is its own _inverse_:
     xs.reverse.reverse equals xs

  2. ~reverse~ turns
     ~init~ to ~tail~ and
     ~last~ to ~head~,
     EXCEPT that the elements are _reversed_:
     ~xs.reverse.init equals xs.tail.reverse~
     ~xs.reverse.tail equals xs.init.reverse~
     ~xs.reverse.head equals xs.last~
     ~xs.reverse.last equals xs.head~


- The current implementation (in this chapter) of ~rev~ is not the best
  implementation possible.

  =IMPORTANT=
  =TODO=
  In the example starting on page 326, you will see how to speed it up.

*** Prefixes and suffixes: ~drop~, ~take~, and ~splitAt~ - 314
~xs.splitAt(n)~ equals ~(xs.take(n), xs.drop(n))~

*** Element selection: ~apply~ and ~indices~ - 314
~xs.apply(n)~ equals ~(xs.drop(n)).head~

*** Flattening a list of lists: ~flatten~ - 315
*** Zipping lists: ~zip~ and ~unzip~ - 315
*** Displaying lists: ~toString~ and ~mkString~ - 316
- ~xs.mkString(sep)~ equals ~xs.mkString("", sep, "")~

- ~xs.mkString~ equals ~xs.mkString("")~

- =IMPORTANT=
  =Often forget this=
  There are also /variants/ of the ~mkString~ methods called ~addString~ which
  append the constructed string to a ~scala.StringBuilder~ object, rather than
  returning them as a result:
  #+begin_src scala
    val abcde = List('a', 'b', 'c', 'd', 'e')
    val buf = new StringBuilder
    abcde.addString(buf, "(", ";", ")")
  #+end_src

*** Converting lists: ~iterator~, ~toArray~, ~copyToArray~ - 317
- ~xs.copyToArray(arr, start~), where ~start~ is the start index of ~arr~.
  =IMPORTANT=
  You must ensure that the destination array ~arr~ is large enough to hold the
  list in full.

*** TODO Example: Merge sort - 318

** DONE 14.7 Higher-order methods on class ~List~ - 320
CLOSED: [2025-04-19 Sat 14:22]
*** Mapping over lists: ~map~, ~flatMap~ and ~foreach~ - 320
- ~List.range(1, 5)~

*** Filtering lists: ~filter~, ~partition~, ~find~, ~takeWhile~, ~dropWhile~, and ~span~ - 322
~xs span p~ equals ~(xs takeWhile p, xs dropWhile p)~

*** Predicates over lists: ~forall~ and ~exists~ - 323
*** Folding lists: ~foldLeft~ and ~foldRight~ - 324 - =TODO: RE-READ=
- ~List(a, b, c).foldLeft(z)(op)~ equals ~op(op(op(z, a), b), c)~
- ~List(a, b, c).foldRight(z)(op)~ equals ~op(a, op(b, op(c, z)))~

- For /associative operations/, /fold left/ and /fold right/ are _EQUIVALENT_,
  but there might be a *difference in efficiency*.

- One Scala /type inference/ LIMITATION can be seen when applying
  ~foldLeft~ and ~foldRight~

*** Example: List reversal using ~fold~ - 326 - =TODO: RE-READ=
*** Sorting lists: ~sortWith~ - 327

** DONE 14.8 Methods of the ~List~ object - 327
CLOSED: [2025-04-19 Sat 14:49]
*** Creating lists from their elements: ~List.apply~ - 328
*** Creating a range of numbers: ~List.range~ - 328
~List.range(9, 1, -3)~
The third parameter is the _step_.

*** Creating uniform lists: ~List.fill~ - 328
- ~List.fill(5)('a')~

- ~List.fill(2, 3)('b'~)
  2 entries and 3 elements per entry.

*** Tabulating a function: ~List.tabulate~ - 329
- ~val squares = List.tabulate(5)(n => n * n)~

- ~val multiplication = List.tabulate(5, 5)(_ * _)~
  5 entries and 5 elements per entry.

*** Concatenating multiple lists: ~List.concat~ - 329
- ~List.concat(List('a', 'b'), List('c'))~'s result is ~List('a', 'b', 'c')~

- ~List.concat()~'s result is ~Nil~

** DONE 14.9 Processing multiple lists together - 329
CLOSED: [2025-04-19 Sat 15:03]
- Example:
  #+begin_src scala
    (List(10, 20).zip(List(3, 4, 5))).map { (x, y) => x * y }
    // List(30, 80)
  #+end_src
  * *Note*: =IMPORTANT=
    The final ~map~ takes advantage of a _Scala 3 feature_ called /parameter
    untupling/.

  * parameter untupling :: in which a /function literal/ with two or more
    parameters will be *untupled AUTOMATICALLY* if the expected type is a function
    that accepts _one parameter of a /tuple type/._

    + For example,
      the ~map~ call in the previous expression means the same as:
      ~map { case (x, y) => x * y }~.
      =from Jian= In Scala 2, ~case~ must be written out.

- When applying ~zip~,
  any extra elements on the end are discarded.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  Creating an intermediate list with ~zip~ can have an *important cost*
  if the lists have a lot of elements. The ~lazyZip~ (=from Jian= since Scala
  2.13) method solves this issue. Its syntax is similar to the ~zip~ method:
  #+begin_src scala
    (List(10, 20).lazyZip(List(3, 4, 5))).map(_ * _) // List(30, 80)
  #+end_src
  =IMPORTANT=
  In the above example, you can see that the ~map~ method takes as parameter a
  function that takes *two parameters (as opposed to one pair)*, allowing the
  usage of the placeholder syntax.

- There are also /lazy zip/ analogs to ~exists~ and ~forall~.
  #+begin_src scala
    (List("abc", "de").lazyZip(List(3, 2))).forall(_.length == _) // true
    (List("abc", "de").lazyZip(List(3, 2))).exists(_.length != _) // false
  #+end_src

** DONE 14.10 Understanding Scala's type inference algorithm - 331 - =TODO: Review=
CLOSED: [2025-04-19 Sat 15:24]
- One difference between the previous uses of ~sortWith~ and ~msort~ concerns
  the admissible syntactic forms of the comparison function.

  * Compare:
    #+begin_src scala
      msort((x: Char, y: Char) => x > y)(abcde) // List(e, d, c, b, a)
    #+end_src

    with

    #+begin_src scala
      abcde.sortWith(_ > _) // List(e, d, c, b, a)
    #+end_src

- /Type inference in Scala/ is *flow based*.

- This inference scheme suggests the following library design principle:
  When designing a /polymorphic method/ that takes some non-function arguments and
  a function argument,
  *place the function argument last* in a /curried parameter list/ on its own.

  That way,
  1. the method's *correct* /instance type/ can be _inferred from_ the
     _non-function arguments_, and that type can in turn be used to /type check/
     the /function argument/.

  2. The net effect:
     users of the method will be able to
     give *LESS* /type information/ and
     write /function literals/ *in more compact ways*.

- =IMPORTANT=
  This example highlights some LIMITATIONS of
  _the /local, flow-based type inference scheme/ of Scala._

  It is *NOT present* in /the more global Hindley-Milner style of type
  inference/ used in functional languages, such as ML or Haskell.

  * HOWEVER, /Scala's local type inference/ *deals much more gracefully* with
    /object-oriented subtyping/ than the /Hindley-Milner style/ does.

  * Fortunately,
    the limitations show up only in some corner cases, and are usually easily
    _FIXED BY_ adding an /EXPLICIT type annotation/.

- Adding /type annotations/ is also a useful _debugging technique_
  WHEN you get confused by type error messages related to /polymorphic methods/.

** DONE 14.11 Conclusion - 334
CLOSED: [2025-04-19 Sat 15:07]
- Now you have seen many ways to work with lists.

- Along the way, you learned _a bit_ about
  HOW Scala's /type inference/ works.

* TODO 15 Working with Other Collections - 335
** 15.1 Sequences - 335
*** Lists - 335
*** Arrays - 336
*** List buffers - 337
*** Array buffers - 337
*** Strings (via ~StringOps~) - 338

** 15.2 Sets and maps - 339
*** Using sets - 340
*** Using maps - 342
*** Default sets and maps - 344
*** Sorted sets and maps - 345

** 15.3 Selecting mutable versus immutable collections - 346
** 15.4 Initializing collections - 348
*** Converting to array or list - 350
*** Converting between mutable and immutable sets and maps - 351

** 15.5 Tuples - 351
** 15.6 Conclusion - 353

* TODO 16 Mutable Objects - 355
** 16.1 What makes an object mutable? - 355
** 16.2 Reassignable variables and properties - 357
** 16.3 Case study: Discrete event simulation - 361
** 16.4 A language for digital circuits - 362
** 16.5 The ~Simulation~ API - 365
** 16.6 Circuit Simulation - 369
*** The ~Wire~ class - 369
*** The ~inverter~ method - 372
*** The ~andGate~ and ~orGate~ methods - 373
*** Simulation output - 374
*** Running the simulator - 374

** 16.7 Conclusion - 376

* DONE 17 Scala's Hierarchy - 378
CLOSED: [2025-04-18 Fri 15:54]
This chapter will look at /Scala's class hierarchy/ as a whole.

- In Scala, EVERY /class/ *inherits* from a _COMMON_ /superclass/ named ~Any~.

- Because EVERY /class/ is a /subclass/ of ~Any~, the /methods/ defined in ~Any~
  are /"universal" methods/: *they may be invoked on ANY object.*

- Scala also defines some interesting /classes/ at the /bottom of the
  hierarchy/, ~Null~ and ~Nothing~, which essentially act as _COMMON_
  /subclasses/.

- ~Any~ is a /superclass/ of EVERY OTHER /class/
- ~Nothing~ is a /subclass/ of EVERY OTHER /class/.

- In this chapter, we'll give you a tour of Scala's class hierarchy.

** DONE 17.1 Scala's class hierarchy - 378
CLOSED: [2025-04-18 Fri 12:39]
- Figure 17.1 shows an outline of Scala's class hierarchy.
  =from Jian=
  =FIXME???=
  Should mention ~Matchable~, with or without its exact name. Just say this
  figure doesn't include one fundamental trait, and it will be explain in
  Advanced Programming in Scala. At least, in a footnote.

- At the *TOP* of the hierarchy is /class/ ~Any~, which defines /methods/ that
  include the following:
  #+begin_src scala
    final def ==(that: Any): Boolean = this equals that
    final def != (that: Any): Boolean = !(this == that)
    final def ##: Int
    def equals(that: Any): Boolean
    def hashCode: Int
    def toString: String
  #+end_src
  * =FIXME=
    ~##~ should be ~final~!!!

  * =from Jian=
    =IMPORTANT=
    I read the source code of ~Any~, and I found that
    the bodies of /final methods/ are in the form of ~sys.error(...)~.
    + Methods of ~Any~ in this form:
      - ~##~
      - ~isInstanceOf~
      - ~asInstanceOf~

    The Scala compiler special-cases these methods and emits _optimized
    bytecode_ for it, bypassing the ~sys.error~ definition.

  * Since ~final def ==(that: Any): Boolean = this equals that~ and ~!=~ is
    always the NEGATION of ~equals~.
    =IMPORTANT=
    So individual /classes/ can tailor what ~==~ or ~!=~ means by _overriding the
    ~equals~ method_.

  * Page 379
    footnote 1:
    =from Jian= Summary: All below are about the inconsistency in Java. Scala
    doesn't have those issues.

    + The *ONLY case* where ~==~ does not directly call ~equals~ is for /Java's
      boxed numeric classes/, such as ~Integer~ or ~Long~.
      =IMPORTANT=

      - Reason:
        In Java, a ~new Integer(1)~ does *NOT equal* (=from Jian= Java's ~equals~)
        a ~new Long(1)~ even though for /primitive values/ 1 == 1L.

        * =from Jian=
          Here the book *on purpose* keep using ~new~ instead of the ~.valueOf~
          methods.
          + Use ~new~ for /boxed numeric types/ is _deprecated_ since Java 9.
          + Should use ~.valueOf~ methods on these types, which is cache friendly.
          + Use ~new~ always create new instances of objects in /boxed numeric
            types/. This usage "still works but strongly discouraged; may be
            removed later" in Java 17+.

      - Conclusion:
        =IMPORTANT=
        Since Scala is a more regular language than Java, it was necessary to
        *correct* this discrepancy by special-casing the ~==~ method for these
        /classes/.

    + Likewise, the ~##~ method provides a Scala version of hashing that is the
      same as Java's ~hashCode~, _EXCEPT_ for /boxed numeric types/, where _it
      works CONSISTENTLY with ~==~ in Scala._

      - For instance ~new Integer(1)~ and ~new Long(1)~ hash the same with ~##~
        even though their Java ~hashCode~'s are DIFFERENT. =???=
        * =from Jian=
          =FIXME=
          =???=
          =???=
          When using JDK 17, their ~hashCode~'s are the same!

      - =from Jian=
        ~.##~ can be called from ~null~, and ~.hashCode~ can't be.

- *Multiversal equality*
  Scala 3 introduced "multiversal equality," which can give you a _compiler
  error_ for uses of ~==~ and ~=~ that represent likely bugs, such as comparing
  a ~String~ and an ~Int~ for equality.
  * =TODO= This mechanism will be described in Chapter 23.

- The /root class/ ~Any~ has TWO /subclasses/: ~AnyVal~ and ~AnyRef~.

  * ~AnyVal~ :: the /parent class/ of /value classes/ in Scala.
    + While you can _define your own_ /value classes/ (see _Section 17.4_),

    + there are NINE /value classes/ _built into Scala_:
      - ~Byte~
      - ~Short~
      - ~Char~
      - ~Int~
      - ~Long~
      - ~Float~
      - ~Double~
      - ~Boolean~
      - ~Unit~

    + The first eight of these CORRESPOND TO _Java's primitive types_, and their
      values are represented at run time as _Java's primitive values_.

      - The /instances/ of these /classes/ are all written as /literals/ in Scala.

      - =IMPORTANT=
        You *CANNOT* create /instances/ of these /classes/ using ~new~.
        =from Jian= Useful trick!
        This is enforced by the "trick" that /value classes/ are all defined to be
        both ~abstract~ and ~final~.

    + The other /value class/, ~Unit~, corresponds roughly to /Java's ~void~
      type/.

  * Note that the /value class/ space is *flat*;
    all /value classes/ are (=from Jian= DIRECT) /subtypes/ of ~scala.AnyVal~,
    but *NO* subclass relation betwhen each other.
    + Instead there are /implicit conversions/ between different /value class
      types/.

  * As mentioned in Section 5.10, /implicit conversions/ are also used to add more
    functionality to /value types/.
    For example, many methods can be called from ~Int~ comes from
    ~scala.runtime.RichInt~, and there is an /implicit conversion/ from ~Int~ to
    ~RichInt~.

- ~AnyRef~ :: _in fact_ just an alias for ~class java.lang.Object~.

  So _classes written in Java_, as well as _classes written in Scala_,
  *ALL* inherit from ~AnyRef~.

  * One way to think of ~java.lang.Object~, therefore, is as the way ~AnyRef~ is
    implemented on the Java platform.

    Thus, although you *CAN* use ~Object~ and ~AnyRef~ *INTERCHANGEABLY* in
    Scala programs on the Java platform, _the *RECOMMENDED* style is to use
    ~AnyRef~ everywhere._

  * footnote:
    One reason the ~AnyRef~ alias exists, instead of just using the name
    ~java.lang.Object~, is because Scala was originally designed to work on both
    the Java and .NET platforms.
    + On .NET, ~AnyRef~ was an alias for ~System.Object~.

** DONE 17.2 How primitives are implemented - 382
CLOSED: [2025-04-18 Fri 14:15]
- Q :: How is all this implemented?

- A :: In fact, Scala stores integers in the same way as Java -- as 32-bit words.
       This is important for efficiency on the JVM and also for interoperability
       with Java libraries.

  * Standard operations like addition or multiplication are implemented as
    primitive operations.

  * However, Scala uses the “backup” class ~java.lang.Integer~ whenever an
    integer needs to be seen AS a /(Java) object/.

    + This happens FOR INSTANCE when
      - invoking the ~toString~ method on an integer number or
      - when assigning an integer to a variable of type ~Any~.

      Integers of type ~Int~ are converted *TRANSPARENTLY* to "boxed integers"
      of type ~java.lang.Integer~ _whenever necessary_.

- All this sounds a lot like _/auto-boxing/ in Java_ and it is indeed _quite
  SIMILAR_.

  There's one crucial difference though: _/Boxing/ in Scala_ is *much less
  visible* than _/boxing/ in Java_.

  * For example,
    The equality operation ~==~ in Scala is designed to be *TRANSPARENT* with
    respect to the /type's representation/. For /value types/, it is the
    _NATURAL (numeric or boolean) equality_.

- ~eq~: reference equality check. Its negation is ~ne~.

  For example:
  #+begin_src scala
    val x = new String("abc") // abc
    val y = new String("abc") // abc
    x == y // true
    x eq y // false
    x ne y // true
  #+end_src

** DONE 17.3 Bottom types - 384
CLOSED: [2025-04-18 Fri 14:15]
- At the *BOTTOM* of the /type hierarchy/ in Figure 17.1 you see the TWO /classes/:
  * ~scala.Null~
  * ~scala.Nothing~

  These are _special types_ that handle some *"corner cases"* of /Scala's type
  system/ *in a uniform way.*

- ~Null~
  is the type of the ~null~ /reference/; it is a /subclass/ of EVERY /reference
  class/ (i.e., EVERY /class/ that itself _inherits_ from ~AnyRef~).

  * ~Null~ is *NOT compatible* with /value types/.
    For example,
    #+begin_src scala
      // scala>
      val i: Int = null
      1 |val i: Int = null
        |             ^^^^
        |             Found: Null
        |             Required: Int
    #+end_src

  * footnote 5:
    Scala 3 includes an _option_, ~-Yexplicit-nulls~, which _ENABLES_ an
    EXPERIMENTAL ALTERNATE treatment of ~null~ that aims to track which variables
    *can and cannot be* ~null~.

    + This option be described in Advanced Programming in Scala.
      =TODO=
      =IMPORTANT=

- ~Nothing~
  is at *the VERY bottom* of /Scala's class hierarchy/; it is a /subtype/ of
  EVERY other type.

  * However, there exist *no values* of this type whatsoever.
    + Q :: Why does it make sense to have a type without values?

    + A :: As discussed in Section 7.4,
           one use of ~Nothing~ is that _it signals abnormal termination._

      - For instance, there's the ~error~ method in the ~sys~ object of Scala's
        standard library:
        #+begin_src scala
          def error(message: String): Nothing =
            throw new RuntimeException(message)
        #+end_src

** DONE 17.4 Defining your own value classes - 385
CLOSED: [2025-04-18 Fri 14:49]
See https://docs.scala-lang.org/overviews/core/value-classes.html

Define your own /value classes/ to augment the ones that are built in.

- Like the /built-in value classes/,
  1. an /instance/ of your /value class/ will usually compile to /Java bytecode/
     that does *NOT use* the /wrapper class/.

  2. In contexts where a _wrapper_ is needed, such as with generic code, the
     value will get /boxed/ and /unboxed/ *AUTOMATICALLY*.

- footnote 6:
  Scala 3 also offers /opaque types/, which is more restrictive but guarantees the
  value will *NEVER be boxed*.
  * =NEXT= /Opaque types/ will be described in Advanced Programming in Scala.
    =from Jian=
    The /Opaque types/ chapter explains when to use /value classes/ and when to
    use /opaque types/, and the reason.

- _Only certain_ /classes/ can be made into /value classes/.

  For a /class/ to be a /value class/,
  * it must have *EXACTLY ONE parameter* and
    =from Jian=
    Future JVM may relax this restriction, and support /multiple-value value
    classes/.

  * it must have *nothing inside it except ~def~'s*.

  Furthermore,
  * *no* other /class/ can extend a /value class/, and
    =IMPORTANT= often forget this restriction!
  * a value class *cannot* redefine ~equals~ or ~hashCode~.

- To define a /value class/, make it a /subclass/ of ~AnyVal~, and put ~val~
  before the one parameter. Here is an example /value class/:
  #+begin_src scala
    class Dollars(val amount: Int) extends AnyVal:
      override def toString = "$" + amount
  #+end_src

  #+begin_src scala
    val money = new Dollars(1_000_000)
    money.amount // 1000000
  #+end_src
  * ~money~, refers to an instance of the /value class/,
    + is of type ~Dollars~ _in Scala source code_,
    + BUT the compiled _Java bytecode_ will use type ~Int~ directly.

*** Avoiding a types monoculture - 386
=FIXME=
=from Jian=
Update this use case and use /value clasess/ built from /primitive types/.

If not using /primitive types/, mostly using /opaque types/ is a better
solution.

- =from the Internet=
  =IMPORTANT=
  In programming, "type monoculture" generally refers to a situation where a
  codebase or system relies heavily on a single, dominant type for data or
  logic, potentially leading to reduced flexibility, maintainability, and
  scalability. This is analogous to monoculture in agriculture where a single
  crop is grown, leading to reduced biodiversity and vulnerabilities.

- Replace
  #+begin_src scala
    def title(text: String, anchor: String, style: String): String =
      s"<a id='$anchor'><h1 class='$style'>$text</h1></a>"
  #+end_src

  with
  #+begin_src scala
    class Anchor(val value: String) extends AnyVal
    class Style(val value: String) extends AnyVal
    class Text(val value: String) extends AnyVal
    class Html(val value: String) extends AnyVal

    def title(text: Text, anchor: Anchor, style: Style): Html =
      Html(
        s"<a id='${anchor.value}'>" +
          s"<h1 class='${style.value}'>" +
          text.value +
          "</h1></a>"
      )
  #+end_src

** DONE 17.5 Intersection types - 388
CLOSED: [2025-04-18 Fri 14:53]
- An /intersection type/ is a /subtype/ of all combinations of its constituent
  /types/.
  * For example,
    type ~B & I & F~ is a /subtype/ of
    + ~B~
    + ~I~
    + ~F~
    + ~B & I~
    + ~B & F~
    + ~I & F~
    + (reflexively of) ~B & I & F~ itself.

- =IMPORTANT=
  /intersection types/ are *COMMUTATIVE*, the order of appearance of types in an
  /intersection type/ *does NOT matter*.

** TODO 17.6 Union types - 389 - =NOTE=
- Scala offers a DUAL to /intersection types/ called /union types/, which
  consist of two or more types joined by pipe (~|~) characters, such as ~Plum |
  Apricot~.

- A /union type/ indicates that an object is an /instance/ of *at least one*
  mentioned /type/.
  * For example,
    an object of type ~Plum | Apricot~ is either an /instance/ of
    + Plum, or
    + Apricot, or
    + both. =from Jian= some type may ~extends Plum with Apricot~

- =IMPORTANT=
  Like /intersection types/, /union types/ are *commutative*.

- Dually to /intersection types/, a /union type/ is a /supertype/ of all
  combinations of its constituent types.
  * *Importantly*, a /union type/ is its constituent types /nearest common
    supertype/, or /least upper bound/.

- The addition of /union and intersection types/ to Scala 3
  _ENSURES_ that
  */Scala's type system/ forms a /mathematical lattice/.*

  * A /lattice/ is a /partial order/ in which any two types have both a unique least
    upper bound, or LUB,and a unique greatest lower bound. In Scala 3, the least
    upper bound of anytwo types is their union; the greatest lower bound is
    their intersection. Forexample, the least upper bound of Plum and Apricot is
    Plum | Apricot.Their greatest lower bound is Plum & Apricot.

- /Union types/ have important implications for the specification and
  implementation of /type inference/ and /type checking/ in Scala. Whereas in
  Scala2, the type inference algorithm had to settle on an approximation of
  the leastupper bound of some pairs of types, whose actual least upper bound
  was thelimit of an infinite series, Scala 3 can simply form a union of those
  types.

- To visualize this, consider the following hierarchy:
  #+begin_src scala
    trait Fruit
    trait Plum extends Fruit
    trait Apricot extends Fruit
    trait Pluot extends Plum, Apricot
  #+end_src
  These four types yield the hierarchy shown in Figure 17.2. Fruit isa
  supertype to both Plum and Apricot, but it is not the nearest
  commonsupertype. Rather, the union type Plum | Apricot is the nearest common
  supertype, or least upper bound, of Plum and Apricot. As shown in
  Figure17.2, this implies that the Plum | Apricot union type is a subtype
  ofFruit. And this is indeed the case, as illustrated here:
  #+begin_src scala
    val plumOrApricot: Plum | Apricot = new Plum {}
    // This compiles fine, because Plum | Apricot <: Fruit
    val fruit: Fruit = plumOrApricot
    // But you cannot use a Fruit where Plum | Apricot is needed

    // scala>
    val doesNotCompile: Plum | Apricot = fruit
    1 |val doesNotCompile: Plum | Apricot = fruit
      |                                     ˆˆˆˆˆ
      |                                Found: (fruit : Fruit)
      |                                Required: Plum | Apricot
  #+end_src

- Dually Pluot is a subtype to both Plum and Apricot, but it is not thenearest
  common subtype. Rather, the intersection type Plum & Apricot isthe nearest
  common subtype, or greatest lower bound, of Plum and Apricot.As shown in
  Figure 17.2, this implies that the Plum & Apricot intersectiontype is a
  supertype of Pluot. And this is indeed the case:
  #+begin_src scala
    val pluot: Pluot = new Pluot {}

    // This compiles fine, because Pluot <: Plum & Apricot
    val plumAndApricot: Plum & Apricot = pluot

    // But you cannot use a Plum & Apricot where Pluot is needed
    // scala>
    val doesNotCompile: Pluot = plumAndApricot
    1 |val doesNotCompile: Pluot = plumAndApricot
      |                            ˆˆˆˆˆˆˆˆˆˆˆˆˆˆ
      |                Found:    (plumAndApricot : Plum & Apricot)
      |                Required: Pluot
  #+end_src

- You can invoke any method or access any field defined on any of the
  constituenttypes of an intersection type. On an instance of Plum & Apricot,
  forexample, you can invoke any methods defined in either Plum or
  Apricot.By contrast, on a union type, you can only access members of
  supertypesthat are common to the constituent types. On an instance of Plum |
  Apricot,therefore, you can access the members of Fruit (including members it
  inheritsfrom AnyRef and Any), but you cannot access any members added
  ineither Plum or Apricot. To access such members, you must perform a
  patternmatch to determine the actual class of the value at runtime. Here’s
  anexample of such a pattern match:
  #+begin_src scala
    def errorMessage(msg: Int | String): String =
      msg match
        case n: Int => s"Error number: ${n.abs}"
        case s: String => s + "!"
  #+end_src
  The errorMessage method’s msg parameter has type Int | String.You could,
  therefore, directly invoke on msg only methods declared on Any,the sole
  common supertype of Int and String. You could not directlyinvoke any other
  methods defined on either Int or String. To access,for example, the abs
  method of Int, or the string concatenation operator(+) of String, you must
  perform a pattern match on msg, as shown in the errorMessage method body. Here
  are some examples of using theerrorMessage method:
  #+begin_src scala
    errorMessage("Oops") // "Oops!"
    errorMessage(-42)    // "Error number: 42"
  #+end_src

** DONE 17.7 Transparent traits - 392
CLOSED: [2025-04-18 Fri 15:50]
- Traits have two main uses:
  * They allow you to define /classes/ through /mixin composition/, and
  * they define /types/.

- Q :: WHY do we need REQUIREMENT?

- A :: Sometimes you may intend a /trait/ to be used
  * primarily as a /mixin/, and
  * *NOT* as a /type/.

  This means sometime you *don't want* _the name of a trait_ to *appear* in
  /inferred types/.

- SOLUTION:
  Declare the /traits/ you only want to use them as /mixins/ with ~transparent~.

- The ~transparent~ modifier ONLY AFFECTS /type inference/.
  You can still _use /transparent traits/ as types_ if you write them out
  *explicitly*.

- In addition to traits _marked EXPLICITLY as ~transparent~,_ Scala 3 will
  treat
  * ~scala.Product~,
  * ~java.lang.Serializable~, and
  * ~java.lang.Comparable~ as ~transparent~ as well.

  Because these /types/ will *never be inferred* in Scala 3, if you really want to
  _use them as types_, you will need to do so through _EXPLICIT /type annotations
  or ascriptions/._

** DONE 17.8 Conclusion - 393
CLOSED: [2025-04-18 Fri 15:54]
In this chapter we showed you
1. The /classes/ at the /top/ and /bottom/ of /Scala's class hierarchy/.

2. HOW to create your own /value classes/, including how to use them
   for "tiny types."

3. /Intersection and union types/, and saw how they turn /Scala's
   type hierarchy/ into a /lattice/.

4. Lastly, how to use the ~transparent~ modifier to prevent Scala's /type
   inference/ algorithm from using _/traits/ designed primarily as /mixins/_ as
   /types/.

=NEXT=
In the next chapter, you'll learn about /type parameterization/.

* TODO 18 Type Parameterization - 394 - =READING=
** 18.1 Functional queues - 394
** 18.2 Information hiding - 397
*** Private constructors and factory methods - 398
*** An alternative: private classes - 399

** 18.3 Variance annotations - 400
*** Variance and arrays - 403

** 18.4 Checking variance annotations - 405
** 18.5 Lower bounds - 408
** 18.6 Contravariance - 409
** 18.7 Upper bounds - 413
** 18.8 Conclusion - 415

* DONE 19 Enums - 416
CLOSED: [2025-04-17 Thu 21:44]
Scala 3 introduced the ~enum~ construct to make the definition of
/sealed case class hierachies/ _more concise_.

- /Enums/ can be used to define both /enums/ (enumerated data types) in
  mainstream OO languages, and /enums/ (algebraic data types) in FP languages.

** DONE 19.1 Enumerated data types - 416
CLOSED: [2025-04-17 Thu 19:53]
- footnote 1:
  Although "enum" is a more common short name for /enumerated data types/, we
  will use /EDT/ in this book because the /enum construct in Scala/ is also used
  to define /algebraic data types/, which are called /ADTs/.

- An /enumerated data type (EDT)/ is useful when you want a type that's
  _restricted to_ a _FINITE set of /named values/._

  These named values are called _the cases of the EDT._
  #+begin_src scala
    enum Direction:
      case North, East, South, West
  #+end_src
  * =from Jian=
    I'd like to use the term _enum variants_ instead of _enum cases_.

  * This simple ~enum~ will generate a ~sealed class~ named ~Direction~ with a
    /companion object/ containing the four values declared as ~val~'s.
    The ~val~'s, named ~North~, ~East~, ~South~, and ~West~, will have /type/
    ~Direction~. Given this definition, you could, for example, define a method
    to ~invert~ a compass direction using a /pattern match/, as shown here:
    #+begin_src scala
      import Direction.{North, South, East, West}

      def invert(dir: Direction): Direction =
        dir match
          case North => South
          case East => West
          case South => North
          case West => East
    #+end_src

- footnote 2: The /sealed class/ is called the "enum type."

- /Enumerated data types/ are called _"enumerated"_ because the compiler
  *associates* an ~Int~ /ordinal/ to each case.

  * The /ordinal/ starts at ~0~ and increases by one for each case,
    in the order the cases are defined in the enum. You can access the /ordinal/
    via a method named ~ordinal~, which the *compiler generates for each EDT.*
    For example:

- ~enum~'s build-in methods:
  * ~ordinal~: start at 0 and increases by one for each case, in the order the
    cases are defined in the /enum/.
    + The REASON why /Enumerated data types/ are called "enumerated":
      the compiler associates an ~Int~ /ordinal/ to each /case/ of /EDT/.

    #+begin_src scala
      North.ordinal // 0
      East.ordinal  // 1
      South.ordinal // 2
      West.ordinal  // 3
    #+end_src

  * ~values~: returns an ~Array[YourEnumType]~ containing all of the /EDT/'s
    cases, in declaration order.

  * ~valueOf~: Convert a /string/, which is *exactly* the same as an enum case
    name, to that /enum value/.

- Give an EDT value parameter(s):
  #+begin_src scala
    enum Direction(val degrees: Int):
      case North extends Direction(0)
      case East  extends Direction(90)
      case South extends Direction(180)
      case West  extends Direction(270)
  #+end_src

- You can define a /method/ inside a /enum/:
  #+begin_src scala
    enum Direction(val degrees: Int):
      case North extends Direction(0)
      case East  extends Direction(90)
      case South extends Direction(180)
      case West  extends Direction(270)

      def invert: Direction =
        this match
          case North => South
          case East  => West
          case South => North
          case West  => East
  #+end_src
  * =TODO= NOTE

- _One *restriction* of enums:_
  _CANNOT_ define /methods/ for the /individual cases/.

  Instead, you must declare any methods as members of _the /enum type/ ITSELF_,
  which will make those methods _available on all of the enum's cases._

  * footnote 3:
    You could define /extension methods/ for the /case types/,
    _BUT_
    it might be better in that situation to just write out the /sealed case class
    hierarchy/ *BY HAND*.

- *Integration with Java enums*
  #+begin_src scala
    enum Direction extends java.lang.Enum[Direction]:
      case North, East, South, West
  #+end_src

  Then you can all /Java enums methods/ on these values. For instance,
  #+begin_src scala
    Direction.East.compareTo(Direction.South) // -1
  #+end_src

** DONE 19.2 Algebraic data types - 420
CLOSED: [2021-03-03 Wed 00:53]
- Algebraic Data Type (ADT) :: a data type composed of a finite set of cases.

- =IMPORTANT=
  /ADTs/ are
  a natural way to express /domain models/ in which you model the data case by
  case.
    Each case represents one "data constructor," a particular way to construct
  an instance of the type.

- In Scala, a sealed family of case classes forms an ADT so long as *at least one
  of the cases takes parameters.*
  * footnote 4:
    _BY COMPARISON_,
    an /EDT/ is a sealed family of case classes in which none of the cases take
    parameters

- An ADT example:
  #+begin_src scala
    enum Eastwood[+G, +B]:
      def map[G2](f: G => G2): Eastwood[G2, B] =
        this match
          case Good(g) => Good(f(g))
          case Bad(b) => Bad(b)
          case Ugly(ex) => Ugly(ex)

      case Good(g: G)
      case Bad(b: B)
      case Ugly(ex: Throwable)
  #+end_src

- Algebraic Data Type (ADT) :: a data type composed of a finite set of cases.

- In Scala, a _sealed_ family of /case classes/ forms an /ADT/
  so long as *AT LEAST _ONE_ of the cases take parameters.*
  * footnote:
    By comparison,
    an EDT is a _sealed_ family of /case classes/ in which *NONE of the cases
    take parameters.*

- When you create a case of an /ADT/ by using its /factory method/ (=from Jian=
  the ~apply~ /method/), the compiler will *widen* its type to the more general
  ~enum~ type.
  * If you want the more specific type, use the constructor (~new~ it).

- /ADT/'s can be *recursive*.
  * =from Jian=
    /EDT/'s can never be recursive, because *NONE of the cases take parameters.*

- Example:
  #+begin_src scala
    enum Seinfeld[+E]:
      def ::[E2 >: E](o: E2): Seinfeld[E2] = Yada(o, this)

      case Yada(head: E, tail: Seinfeld[E])
      case Nada

    val xs = 1 :: 2 :: 3 :: Nada
    // val xs = Yada(1, Yada(2, Yada(3, Nada)))
  #+end_src

  The compiler will generate a /case class/ in the /companion object/ of the
  /enum type/. =from Jian= Remember? /EDT/ generate values.
  #+begin_src scala
    // Generated sealed trait (the "enum type")
    sealed trait Eastwood[+G, +B]

    object Eastwood: // Generated companion object
      // Generated case classes
      case class Good[+G, +B](g: G) extends Eastwood[G, B]
      case class Bad[+G, +B](b: B) extends Eastwood[G, B]
      case class Ugly[+G, +B](ex: Throwable) extends Eastwood[G, B]
  #+end_src
  * =IMPORTANT=
    Although the /result type/ of the /factory method/ created by the /case
    classes/ will be the SPECIFIC /case class types/, _the compiler will *widen*
    those to the more general enum type._

    + =IMPORTANT=
      If you need the _more specific type_ for a /case/, you can construct
      an instance with ~new~ instead of the generated /factory method/.
      #+begin_src scala
        Good(42) // val res0: Eastwood[Int, Nothing] = Good(42)

        new Good(1) // val res1: Good[Int, Nothing]
      #+end_src

- =IMPORTANT=
  */ADTs/ can be /recursive/*.
  * An example (linked list):
    #+begin_src scala
      enum Seinfeld[+E]:
        def ::[E2 >: E](o: E2): Seinfeld[E2] = Yada(o, this)
        case Yada(head: E, tail: Seinfeld[E])
        case Nada
    #+end_src

** DONE 19.3 Generalized ADTs - 422
CLOSED: [2025-04-17 Thu 20:32]
- Generalized Algebraic Data Types (GADTs) :: /ADTs/ in which the /sealed trait/
  takes a /type parameter/ that is filled in by the cases.

- Example:
  #+begin_src scala
    enum Literal[T]:
      case IntLit(value: Int)         extends Literal[Int]
      case LongLit(value: Long)       extends Literal[Long]
      case CharLit(value: Char)       extends Literal[Char]
      case FloatLit(value: Float)     extends Literal[Float]
      case DoubleLit(value: Double)   extends Literal[Double]
      case BooleanLit(value: Boolean) extends Literal[Boolean]
      case StringLit(value: String)   extends Literal[String]
  #+end_src
  The ~Literal~ /enum/ represents a /GADT/ because it takes a /type parameter/
  ~T~, which is specified by EACH of its cases in their _extends clauses_.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =from Jian: This is why GADT, as a kind of /ADT/ special cases, need this
              specific section to describe!=
  This kind of /sealed type heirarchy/ is given the special name "generalized ADT"
  _BECAUSE_
  _it presents *SPECIAL CHALLENGES to /type checking and inference/*._

- Here's an illustrative example:
  #+begin_src scala
    import Literal.*

    def valueOfLiteral[T](lit: Literal[T]): T =
      lit match
        case IntLit(n)     => n
        case LongLit(m)    => m
        case CharLit(c)    => c
        case FloatLit(f)   => f
        case DoubleLit(d)  => d
        case BooleanLit(b) => b
        case StringLit(s)  => s
  #+end_src
  The ~valueOfLiteral~ /method/ passes the /type checker/, despite none of
  it /match alternatives/ resulting in _the REQUIRED /result type/,_ ~T~.
  * For example,
    the ~case IntLit(n)~ alternative results in ~n~, which has type ~Int~.
    The challenge is that ~Int~ is not type ~T~, nor is ~Int~ a /subtype/ of ~T~.
      This /type checks/ only because the compiler notices that for the
    ~IntLit~ case, ~T~ can be none other than ~Int~.

  * Moreover, this _MORE SPECIFIC_ /type/ is propagated back to the caller.
    #+begin_src scala
      valueOfLiteral(BooleanLit(true))  // true: Boolean
      valueOfLiteral(IntLit(42))        // 42: Int
    #+end_src

** DONE 19.4 What makes ADTs algebraic - 423 - =IMPORTANT=
CLOSED: [2025-04-17 Thu 21:44]
/ADTs/ are called "algebraic" because they represent an application of
_algebraic theory to /types/._

- One way to observe this connection with mathematics is
  BY _mapping each /type/ to its /cardinality/.
  * cardinality :: a count of the inhabitants of that /type/.

- If you think of /types/ as _representing sets of values,_
  then
  the /cardinality of a type/ is the /cardinality (the number of elements) of
  that corresponding set of values/.

  * For example,
    + The /cardinality/ of ~Boolean~: 2 (2 values: ~true~ and ~false~)
    + The /cardinality/ of ~Unit~: 1 (1 value: ~()~)

- The /cardinality/ of /sum types/:
  SUM /cardinalities/ of each cases (variants).
  * Example:
    #+begin_src scala
      enum Hope[+T]:
        case Glad(o: T)
        case Sad
    #+end_src
    If ~T~ is ~Boolean~, the /cardinality/ of ~Hope[Boolean]~ is 3, which comes
    from 2 (/cardinality/ of ~Glad[Boolean]~) + 1 (/cardinality/ of ~Sad~).

  * More examples:
    Table 19.1 · The cardinality of ~Hope~

- The /cardinality/ of /product types/:
  MULTIPLY /cardinalities/ of each cases (variants).
  * Example:
    #+begin_src scala
      case class Both[A, B](a: A, b: B)
    #+end_src
    If ~A~ is ~Boolean~ and ~B~ is ~Unit~, the /cardinality/ of
    ~Both[Boolean, Unit]~ is 2, which comes from 2 (/cardinality/ of
    ~Boolean~) * 1 (/cardinality/ of ~Unit~).

  * More examples:
    Table 19.2 · The cardinality of ~Both~

- =IMPORTANT=
  Generally, /algebraic data types/ represent
  */sums/ of /products/*,

  * An /EDT/ is a special case of /ADT/
    where *each /product type/ is a /singleton/.*

- One of the benefits of understanding the _algebraic properties_ of your data
  structures:
  you can RELY ON the relevant _mathematical laws_ to *prove properties about your
  code.*

  * For example,
    you might be able to prove that certain refactorings will preserve the
    meaning of your program.

- /ADT cardinalities/ _obey laws_ regulating /addition/ and /multiplication/,
  such as /identity/, /commutativity/, /associativity/, and /distributivity/.

  * =IMPORTANT=
    In general, /functional programming/ often offers opportunities for you to
    *gain insight into your code from branches of mathematics.*

** DONE 19.5 Conclusion - 427
CLOSED: [2025-04-17 Thu 20:45]
- In this chapter,
  1. You learned about /Scala's enums/, _a concise way to define /sealed case
     class hierarchies/ that form /enumerated and algebraic data types/._

  2. You
     * learned that in Scala, /EDTs/ and /ADTs/ form two ends of the same
       spectrum, and
     * looked at the _algebra of algebraic data types_.

- /Scala's enum construct/
  * makes A COMMON IDIOM for _functional data modeling_ CONCISE, and
  * indicates that /EDTs/ and /ADTs/ are _IMPORTANT patterns_.

* TODO 20 Abstract Members - 428
** 20.1 A quick tour of abstract members - 428
** 20.2 Type members - 429
** 20.3 Abstract ~val~'s - 430
** 20.4 Abstract ~var~'s - 430
** 20.5 Initializing abstract ~val~'s - 432
*** Trait parametric fields - 434
*** Lazy vals - 435

** 20.6 Abstract types - 439
** 20.7 Path-dependent types - 441
** 20.8 Refinement types - 444
** 20.9 Case study: Currencies - 445
** 20.10 Conclusion - 453

* TODO 21 Givens - 455
** 21.1 How it works - 455
** 21.2 Parameterized given types - 459
** 21.3 Anonymous givens - 464
** 21.4 Parameterized givens as typeclasses - 465
** 21.5 Given imports - 468
** 21.6 Rules for context parameters - 469
*** Naming a given - 471

** 21.7 When multiple givens apply - 472
** 21.8 Debugging givens - 474
** 21.9 Conclusion - 476

* TODO 22 Extension Methods - 477
** 22.1 The basics - 477
** 22.2 Generic extensions - 480
** 22.3 Collective extensions - 481
** 22.4 Using a typeclass - 484
** 22.5 Extension methods for givens - 486
** 22.6 Where Scala looks for extension methods - 490
** 22.7 Conclusion - 491

* TODO 23 Typeclasses - 493
- If you need to write a function that implements behavior useful for some types
  but not others, you have a few options in Scala.

  * Define /overloaded methods/.

  * Require that the /class/ of ANY /instance/ _passed to your function_ mixes
    in a PARTICULAR /trait/.
    =???=

  * _MORE FLEXIBLE_
    Define a /typeclass/ and
    write your function
    to work with /types/ for which _a /given instance/ of the /typeclass trait/
    is defined_.

- This chapter will
  1. _compare and contrast_ these different approaches,
  2. then dive deeply into /typeclasses/.

     We will
     1) introduce the /context bound syntax/ for /typeclasses/ and
     2) give several examples of /typeclasses/ from the standard library -
        for
        * /numeric literals/,
        * /multiversal equality/,
        * /implicit conversions/, and
        * main methods. =???= =TODO=

     3) We'll wrap up with an example that illustrates the use of a /typeclass/
        for _JSON serialization_.

** DONE 23.1 Why typeclasses? - 493
CLOSED: [2025-04-21 Mon 13:19]
- typeclass :: a grouping or set of /types/.

- /typeclasses/ support /ad hoc polymorphism/ :: functions can be used with a
  particular, enumerated set of /types/.

  _As mentioned in Section 21.4_

  Any attempt to use such a function with
  a /type/ *NOT in* its enumerated set
  will *NOT compile*.

- _ORIGINALLY_,
  /ad hoc polymorphism/ was first used to describe the way that operators, such
  as ~+~ or ~-~, can be used with certain types but not others in many
  programming languages.
  * footnote 1:
    Strachey, "Fundamental Concepts in Programming Languages."

  * In Scala, this is achieved by /overloading methods/.
    The /interface/ of ~scala.Int~, for instance, includes seven /overloaded abstract
    methods/ named minus (~-~):
    #+begin_src scala
      def -(x: Double): Double
      def -(x: Float): Float
      def -(x: Long): Long
      def -(x: Int): Int
      def -(x: Char): Int
      def -(x: Short): Int
      def -(x: Byte): Int
    #+end_src

  * _Another way_ to achieve /ad hoc polymorphism/ in Scala is with a /class
    hierarchy/. Here's an example that uses a /sealed trait/ to define a family
    of colors:
    #+begin_src scala
      sealed trait RainbowColor

      class Red extends RainbowColor
      class Orange extends RainbowColor
      class Yellow extends RainbowColor
      class Green extends RainbowColor
      class Blue extends RainbowColor
      class Indigo extends RainbowColor
      class Violet extends RainbowColor

      def paint(rc: RainbowColor): Unit
    #+end_src
    Because ~RainbowColor~ is ~sealed~, the paint method can be passed *only*
    arguments having one of the eight types. It won't compile for any other
    type.

  * Although this approach could be viewed as /ad hoc polymorphism/, it is
    referred to as /subtyping polymorphism/ to highlight an important *DIFFERENCE*:
    + the classes of all the instances passed to the paint method must mix in
      trait RainbowColor and adhere any constraints established by its
      interface.

    + By contrast,
      the types accepted by ~Int~'s minus (~-~) method, shown in Figure 23.1,
      _need NOT ADHERE TO any COMMON /interface/ other than that of /Scala's top
      type/, ~Any~._

  * In short,
    + /subtyping/ enables polymorphism of *RELATED types*, whereas
    + /ad hoc polymorphism/ approaches such as /overloading/ and /typeclasses/
      enable polymorphism of *UNRELATED types*.

  * Different /polymorphism/ as solutions for different problems:

    + Because of the interface constraints, /subtyping/
      *WORKS BEST*
      WHEN
      /class hierarchies/ define _SMALL families of types_ focused on a *single
      concept*.

      _/Sealed hierarchies/ and /enums/ are great examples._

      =IMPORTANT=
      In such /self-contained families of types/ it is straightforward to ensure
      the compatibility of interfaces.

    + /Subtyping/ can also be used to model _LARGER, unsealed families_ that are
      focused on a *single concept*.
      - A good example is _the Scala collections library_.

    + However, when used to model behavior that is widely applicable to otherwise
      *UNRELATED types*, such as /serialization/ or /ordering/, _the /subtyping/
      approach becomes more cumbersome._

      - As an example,
        Scala's ~Ordered~ trait vs. ~Ordering~ /typeclass/ (also a ~trait~ in
        syntax):
        * /Subtyping polymorphism/:
          - One potential problem is the /class/ into which you mix ~Ordered~
            could _ALREADY define_ /methods/ whose names or contracts *conflict* with
            those in ~Ordered~.

          - Another potential problem is _/variance/ conflicts_.
            * ~Ordered~ is *invariant*.

          - One more potential problem with /subtyping polymorphism/ is
            /pre-existing interfaces/ that are *incompatible*.

            Another, more common problem is /pre-existing compatible interfaces/
            that you *can't change*.

            * Example:
              The ~orderedMergeSort~ shown in Listing 18.11 can't sort ~List[Int]~,
              because ~Int~ does *NOT* extend ~Ordered[Int]~ -- and you can't
              change that fact.

        * /Typeclasses/ solve this problem by defining a *SEPARATE* hierarchy
          focused on the _GENERAL concept_,
          *using a /type parameter/ to SPECIFY the /type/ for which a service is
          being provided.*

          + Because this *SEPARATE* hierarchy is focused on just one concept,
            such as /serialization/ or /ordering/,
            _it is STRAIGHTFORWARD to ENSURE the *compatibility* of /interfaces/._

          + Because a /typeclass instance/ uses a /type parameter/ to indicate
            the /type/ for which it is providing a service, you *need NOT change
            a /type/* to provide the service for that /type/.
            - _footnote 2_:
              Using a /type parameter/ in this way is referred to as /universal
              polymorphism/.

        * Example:
          #+begin_src scala
            import org.stairwaybook.enums_and_adts.hope.Hope

            object HopeUtils:
              given hopeOrdering[T](using ord: Ordering[T]): Ordering[Hope[T]] with
                def compare(lh: Hope[T], rh: Hope[T]): Int =
                  import Hope.{Glad, Sad}
                  (lh, rh) match
                    case (Sad, Sad) => 0
                    case (Sad, _) => -1
                    case (_, Sad) => +1
                    case (Glad(lhv), Glad(rhv)) => ord.compare(lhv, rhv)
          #+end_src
          Listing 23.1 · A given ~Ordering~ instance for ~Hope[T]~.

        * /Typeclasses/ support /ad hoc polymorphism/,
          BECAUSE
          you can write functions that can be used
          *ONLY with /types/ for which /given instances/ of a particular
          /typeclass/ exists.*

          + Any attempt to use such a function with a /type/ that LACKS a /given
            instance/ of the required /typeclass/ will *NOT compile*.

          =from Jian=
          This description can fit into the defintion of /ad hoc polymorphism/.

** DONE 23.2 Context bounds - 498
CLOSED: [2025-04-21 Mon 14:11]
Because /typeclasses/ are such an important pattern in Scala, the language
provides a shorthand syntax for them called /context bounds/.

#+begin_src scala
  def maxList[T](elements: List[T])
        (using ordering: Ordering[T]): T =
    elements match
      case List() => throw new IllegalArgumentException("empty list!")
      case List(x) => x
      case x :: rest =>
        // val maxRest = maxList(rest)(using ordering)
        val maxRest = maxList(rest)
        if ordering.gt(x, maxRest)
        then x
        else maxRest
#+end_src
Listing 23.2 · A function with a using parameter.


- Q :: Why /context parameter(s)/ don't need to be passed explicitly.
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=

- A ::
  Use the ~maxList~ as an illustration:

  The ~maxList~ function is an example of /a ~using~ parameter/ used to provide
  more information about _a /type/ mentioned *explicitly* in an *earlier*
  parameter list._

  Because elements must always be provided explicitly in any invocation of
  ~maxList~, the compiler will know ~T~ at /compile time/ and can therefore
  determine whether /a ~given~ definition/ of /type/ ~Ordering[T]~ is available.
  If so, it can pass in the second parameter list, ~ordering~, *implicitly*.

- From the compiler point of view (operational):
  When the compiler see the invocation ~maxList(rest)~, it knows one of two
  argumetns is missing. Since that /a ~using~ parameter/ is in the definition,
  the compiler *DOESN'T give up* /type checking/, and search for required ~given~.

- Use ~def summon[T](using t: T) = t~ and the /context bounds/ syntax:
  #+begin_src scala
    def maxList[T: Ordering](elements: List[T]): T =
      elements match
        case List() => throw new IllegalArgumentException("empty list!")
        case List(x) => x
        case x :: rest =>
          // val maxRest = maxList(rest)(using ordering)
          val maxRest = maxList(rest)
          if summon[Ordering[T]].gt(x, maxRest)
          then x
          else maxRest
  #+end_src
  * /Context bounds/ are essentially /syntactic sugar/ for /typeclasses/.

- Compare two syntax:
  * ~[T <: Ordered[T]]~: ~T~ is an ~Ordered[T]~.

  * ~[T <: Ordered[T]]~: Nothing about ~T~ itself, just some form of ordering
    associated with ~T~.

** DONE 23.3 Main methods - 501
CLOSED: [2025-04-21 Mon 15:00]
- In Scala, /main methods/ can actually accept
  *ANY* _number_ and _types_ of arguments.
  * Q :: How can it know how to do some type conversion when reading command
         line arguments that in string type as the expected arguments of a
         /main method/.

  * A :: Use the ~scala.util.CommandLineParser.FromString~.
    + The Scala standard library defines /given/ ~FromString~ /instances/ for
      several common types, including ~String~ and ~Int~ in the ~FromString~
      /companion object/.

    + If you want to write a /main method/ that takes a _CUSTOM type,_
      you can do so by declaring a /given instance/ of the ~FromString~
      /typeclass/ _for the custom type._

- Example:
  * Listing 23.8 · A main method that takes a custom type.
    #+begin_src scala
      // In file moody.scala
      val errmsg =
        "Please enter a word, a positive integer count, and\n" +
          "a mood (one of 'angry', 'surprised', or 'neutral')"

      @main def repeat(word: String, count: Int, mood: Mood) =
        val msg =
          if count <= 0 then
            errmsg
          else
            val words = List.fill(count)(word.trim)
            val punc =
              mood match
                case Mood.Angry => "!"
                case Mood.Surprised => "?"
                case Mood.Neutral => ""
          end if
        println(msg)
    #+end_src

  * Listing 23.9 · A given ~FromString~ instance for ~Mood~.

- A typeclass-based design is a good choice for command line argument parsers
  for /main methods/

  BECAUSE
  this service is needed *only for certain types,*
  which are otherwise *unrelated* to each other.

** TODO 23.4 Multiversal equality - 505
** DONE 23.5 Implicit conversions - 511
CLOSED: [2025-04-21 Mon 15:58]
- Their purpose of /implicit conversions/ was to help make code more clear and
  concise _by *removing* BOILERPLATE type conversions._

- Scala 3 /implicit conversion/ syntax:
  #+begin_src scala
    given streetToString: Conversion[Street, String] = _.value
  #+end_src

  This can be done is because ~Conversion~ is a /SAM/ with definition:
  #+begin_src scala
    abstract class Conversion[-T, +U] extends (T => U):
      def apply(x: T): U
  #+end_src

- Switch on /implicit conversion/:
  * goblally with the compiler option: ~-language:implicitConversions~

  * Per file by ~import~'s:
    #+begin_src scala
      import scala.language.implicitConversions
    #+end_src

- If you do _DEFINE /implicit conversions/,_ make sure the conversion will
  always be appropriate.

  * For example,
    converting ~Double~'s to ~Int~'s _implicitly_ would raise some eyebrows,
    BECAUSE
    it's a dubious idea to have something that causes a loss in precision happen
    invisibly.


    + It makes much more sense to go the other way,
      from some more constrained type to a more general one.

      For instance, from ~Int~ to ~Double~. It, and similar reasonable /implicit
      conversions/, exists the ~scala.Predef~ object, which is implicitly
      imported into every Scala program.

** TODO 23.6 Typeclass case study: JSON serialization - 514
*** Importing an extension method - 516
*** Serializing domain objects - 517
*** Serializing lists - 519
*** Putting it all together - 521

** 23.7 Conclusion - 523

* TODO 24 Collections in Depth - 525
** 24.1 Mutable and immutable collections - 526
** 24.2 Collections consistency - 528
** 24.3 Trait ~Iterable~ - 530
** 24.4 The sequence traits ~Seq~, ~IndexedSeq~, and ~LinearSeq~ - 537
** 24.5 Sets - 544
** 24.6 Maps - 548
** 24.7 Concrete immutable collection classes - 552
** 24.8 Concrete mutable collection classes - 559
** 24.9 Arrays - 564
** 24.10 Strings - 568
** 24.11 Performance characteristics - 569
** 24.12 Equality - 571
** TODO 24.13 Views - 572 - =READING=
** 24.14 Iterators - 576
** 24.15 Creating collections from scratch - 584
** 24.16 Conversions between Java and Scala collections - 586
** 24.17 Conclusion - 588

* TODO 25 Assertions and Tests - 589
** 25.1 Assertions - 589
** 25.2 Testing in Scala - 591
** 25.3 Informative failure reports - 592
** 25.4 Tests as specifications - 594
** 25.5 Property-based testing - 597
** 25.6 Organizing and running tests - 599
** 25.7 Conclusion - 600

* Glossary - 601
* Bibliography - 617
* About the Authors - 621
* Index - 622
