#+TITLE: Programming in Scala
#+SUBTITLE: A comprehensive step-by-step guide - Updated for Scala 3.0
#+VERSION: 5th
#+AUTHOR: Martin Odersky, Lex Spoon, Bill Venners, Frank Sommers
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Contents - xi
* List of Figures - xix
* List of Tables - xxi
* List of Listings - xxiii
* TODO Foreword - xxix - _TAKE NOTES_
Heather Miller
Lausanne, Switzerland
June 1, 2021

- New programming languages are created for many reasons:
  * a personal desire to scratch a niggling itch,
  * a profound academic insight,
  * technical debt, or
  * the benefit of hindsight of other compiler architectures --
  * even politics.

  _Scala 3 is a combination of some of these._

- =TODO= NOTE

* DONE Acknowledgments - xxxiii
CLOSED: [2025-05-16 Fri 11:29]
* DONE Introduction - xxxvi
CLOSED: [2025-04-14 Mon 16:20]
Our goal: by reading this book, you can learn everything you need to be a
productive Scala programmer.

- *Who should read this book*
  - Programmers how want to learn to program in Scala.
  - Programmers wishing to expand their horizons by learning new concepts.

  - We believe learning about Scala, and the ideas behind it, can help you
    become a better progammer in general.

  - REREQUISITE:
    _General programming knowledge is ASSUMED._
    * While Scala is a fine _FIRST programming language,_ this is NOT the book
      to use to learn programming.

  - No specific knowledge of programming languages is required.
    Not presume you know anything about Java.
    _HOWEVER_,
    we EXPECT many readers to be familiar with Java, and
    so we sometimes compare Scala to Java to help such readers understand the
    differences.

** How to use this book
Read this book is in chapter order, from front to back.

After you have read the book once, it should also serve as a language
reference.

There is a formal specification of the Scala language, but the language
specification tries for precision at the expense of readability.

** How to learn Scala
You will learn a lot about Scala simply by reading this book from cover to
cover. You can learn Scala faster and more thoroughly, though, if you do a few
extra things:
1. Type the example code in this book in yourself,
   force your mind through each line of code.

   Trying variations to make sure you really understand how they work.

2. keep in touch with the numerous online forums.

3. Take on a programming project of your own.

Work on a small program from scratch or develop an add-in to a larger
program. _You can only go so far by reading._

** EBook features
** Typographic conventions
** Content overview
- Chapter 12, “Packages and Imports,”
  =FIXME= title (about export)
  =FIXME= content (about export)

- Chapter 19, “Enums and ADTs,” introduces twin constructs that supportyou
  when writing regular, non-encapsulated data structures.
  =FIXME= Order!!!
  =FIXME= description here copied the first sentent of Chapter 12!

- Chapter 23, “Typeclasses,” yet to be written,
  =FIXME= already done!!! This is not a pre-print version!

- =from Jian= Already submitted a errata!

** Resources
- https://www.scalalang.org
- https://booksites.artima.com/programming_in_scala_5ed

** Source code
https://booksites.artima.com/programming_in_scala_5ed

** Errata - =TODO: Review periodically=
https://booksites.artima.com/programming_in_scala_5ed/errata

* TODO 1 A Scalable Language - 43
** DONE 1.1 A language that grows on you - 44
CLOSED: [2025-04-15 Tue 12:41]
- Scala is easy to get into. It runs on the standard _Java_ and _JavaScript_
  platforms and interoperates seamlessly with all platform libraries.
  * =from Jian= Still not mention Scala Native

- Technically, Scala is a blend of /object-oriented/ and /functional
  programming/ concepts in a /statically typed/ language.
  =IMPORTANT=

  * The two programming styles have *COMPLEMENTARY strengths* when it comes
    to scalability.
    + Scala's functional programming constructs make it easy to build
      interesting things quickly from simple parts.

    + Scala's object-oriented constructs make it easy to structure larger
      systems and adapt them to new demands.

  * The combination of both styles in Scala
    + makes it possible to express new kinds of programming patterns and
      component abstractions.

    + It also leads to a legible and concise programming style.

    + And because it is so malleable, programming in Scala can be a lot of fun.

- This initial chapter answers the question, “Why Scala?” It gives a highlevel
  view of Scala's design and the reasoning behind it.

  * After reading the chapter you should have
    a basic feel
    + for what Scala is and
    + what kinds of tasks it might help you accomplish.

*** Growing new types - 45
So the approach of attempting to provide everything in one language doesn't
scale very well. _Instead_, Scala allows users to grow and adapt the language in
the directions they need by defining easy-to-use libraries that feel like native
language support.

*** Growing new control constructs - 46
You can “grow” the Scala language in new directions even as specialized as
software testing.
To be sure, you need experienced architects and programmers to do this.
BUT the crucial thing is that it is *feasible* -- you can design and implement
abstractions in Scala that address radically new application domains, yet still
_feel like native language support when used._

** TODO 1.2 What makes Scala scalable? - 47
- _Scalability_ is influenced by many factors, ranging from syntax details to
  component abstraction constructs. If we were forced to name just one aspect of
  Scala that helps scalability, though, we'd pick its combination of
  _object-oriented_ and _functional programming_ (well, we cheated, that's
  really two aspects, but they are intertwined).

- Scala goes further than all other well-known languages in fusing
  object-oriented and functional programming into a uniform language design.

  * For instance, where other languages might have /objects/ and /functions/ as
    two different concepts, *in Scala a /function value/ is an /object/.*

    /Function types/ are /classes/ that can be inherited by /subclasses/. This
    might seem nothing more than an academic nicety, but it has deep
    consequences for scalability.

    This section gives an overview of Scala's way of blending object-oriented
    and functional concepts.

*** Scala is object-oriented - 48
- Object-oriented programming has been immensely successful. Starting from
  Simula in the mid-60s and Smalltalk in the 70s, it is now available in more
  languages than not. In some domains, objects have taken over completely. While
  there is not a precise definition of what object-oriented means, there is
  clearly something about objects that appeals to programmers.

- In principle, the motivation for object-oriented programming is very
  simple: all but the most trivial programs need some sort of structure. The
  most straightforward way to do this is to put data and operations into some
  form of containers. The great idea of object-oriented programming is to make
  these containers fully general, so that they can contain operations as well
  as data, and that they are themselves values that can be stored in other
  containers, or passed as parameters to operations. Such containers are called
  objects. Alan Kay, the inventor of Smalltalk, remarked that in this way the
  simplest object has the same construction principle as a full computer: it
  combines data with operations under a formalized interface.7 So objects have
  a lot to do with language scalability: the same techniques apply to the
  construction of small as well as large programs.

- Even though object-oriented programming has been mainstream for along time,
  there are relatively few languages that have followed Smalltalkin pushing
  this construction principle to its logical conclusion. For instance,many
  languages admit values that are not objects, such as the primitive valuesin
  Java. Or they allow static fields and methods that are not membersof any
  object. These deviations from the pure idea of object-oriented
  programminglook quite harmless at first, but they have an annoying
  tendencyto complicate things and limit scalability.

*** Scala is functional - 49

** TODO 1.3 Why Scala? - 51
We have found that there are actually many reasons besides scalability to like
programming in Scala.
FOUR of the most important aspects will be discussed in this section:
- compatibility
- brevity
- high-level abstractions, and
- advanced static typing.

*** Scala is compatible - 51
- Scala *doesn't require* you to leap backwards off the Java platform to step
  forward from the Java language.
  It allows you to add value to existing code -- to build on what you already
  have -- because it was designed for seamless interoperability with Java.

- Another aspect of full interoperability is that Scala heavily re-uses
  Javatypes. Scala’s Ints are represented as Java primitive integers of type
  int,Floats are represented as floats, Booleans as booleans, and so on.
  Scalaarrays are mapped to Java arrays. Scala also re-uses many of the
  standardJava library types. For instance, the type of a string literal "abc"
  inScala is java.lang.String, and a thrown exception must be a subclass
  ofjava.lang.Throwable.

- Scala not only re-uses Java’s types, but also “dresses them up” to makethem
  nicer. For instance, Scala’s strings support methods like toInt ortoFloat,
  which convert the string to an integer or floating-point number.So you can
  write str.toInt instead of Integer.parseInt(str). Howcan this be achieved
  without breaking interoperability? Java’s String classcertainly has no toInt
  method! In fact, Scala has a very general solutionto solve this tension
  between advanced library design and interoperability.Scala lets you define
  rich extensions, which are always applied when non-existing members are
  selected.10 In the case above, when looking for atoInt method on a string,
  the Scala compiler will find no such memberof class String, but it will find
  an implicit conversion that converts a JavaString to an instance of the
  Scala class StringOps, which does define sucha member. The conversion will
  then be applied implicitly before performingthe toInt operation.

- Scala code can also be invoked from Java code. This is sometimes a bitmore
  subtle, because Scala is a richer language than Java, so some of Scala’smore
  advanced features need to be encoded before they can be mapped toJava. The
  details will be explained in Advanced Programming in Scala.

*** Scala is concise - 52
*** Scala is high-level - 53
*** Scala is statically typed - 55

** TODO 1.4 Scala's roots - 58
** TODO 1.5 Conclusion - 59

* DONE 2 First Steps in Scala - 61
CLOSED: [2025-04-17 Thu 01:22]
- This page describes several ways to _install or try_ Scala.

- Everything will be explained in a less “fire hose” fashion in later chapters.

  In addition, we inserted quite a few footnotes in these next two chapters to
  point you

- =from Jian=
  Use _coursier_ (command ~cs setup~) to install all related tools, including
  * ammonite
  * cs
  * coursier
  * scala
  * scalac
  * scala-cli
  * sbt
  * sbtn
  * scalafmt

** DONE Step 1. Learn to use the Scala REPL - 61
CLOSED: [2025-04-16 Wed 22:52]
=from Jian= Current version use Scala 3.0, and from Scala 3.5.0 on, =scala=
command refer to =scala-cli=, which is not covered by this book because of the
Scala version used when writing this book.

** DONE Step 2. Define some variables - 63
CLOSED: [2025-04-16 Wed 23:27]
- If you realize you have typed something wrong, but the REPL is still waiting
  for more input, you can use the arrow keys to move up, down, left, or right to
  fix the mistakes.

- If you want to abort your entry completely, you can escape by pressing enter
  twice:
  #+begin_src text
    scala> val oops =
         |
         |
    You typed two blank lines. Starting a new command.
    scala>
  #+end_src
  =FIXME= Not an always work way!!!
  =from Jian=
  =IMPORTANT=
  New Scala REPL is backed by _JLine_, and *NOT all JLine version support* this
  way to abort current input. Usually, _JLine_ by default enable Emacs shortcuts,
  therefore _CTRL + G_ works.

** DONE Step 3. Define some functions - 65
CLOSED: [2025-04-17 Thu 00:48]
- footnote 7:
  * In Java, the type of the value returned from a method is its /return type/.
  * In Scala, that same concept is called /result type/.
  =from Jian= This is reasonable, because Scala rarely use ~return~, call it
  /return type/ in Scala is weird.
  =IMPORTANT=

- Sometimes the Scala compiler will require you to specify the /result type/ of a
  function.
  * If a function is /recursive/, for example, you *must explicitly specify* its
    /result type/.

  * If a function consists of just _one statement_,
    you can optionally write the function entirely on one line.
    + =from Jian= Yes, this should be mentioned, because now brace-less
      indentation-based syntax is used.

  * footnote 8:
    Nevertheless, it is often a good idea to indicate function result types
    explicitly, even when the compiler doesn't require it.

    =IMPORTANT=
    Such /type annotations/ can make the code easier to read,
    BECAUSE the reader need not study the function body to figure out the
    /inferred result type/.
    =from Jian=
    Types in general is also like a kind of document when reading code, we can
    let them be inferred by compiler, but always write _some of them that at
    interface positions_ down explicitly, which is good for read.
    Function /result type/ is at, this function's, interface positions.
    + I create and use this term "interface positions", not a formal term.

- Every ~void~-returning method in Java is mapped to a ~Unit~-returning method
  in Scala.

- Use ~:quit~ in REPL to exit the REPL.

** DONE Step 4. Write some Scala scripts - 67
CLOSED: [2025-04-17 Thu 00:58]
- script :: just a Scala source file that includes a top-level function
  annotated as ~@main~.
  * Example:
    Put the code below in file =hello.scala=:
    #+begin_src scala
      @main def m() =
        println("Hello, world, from a script!")
    #+end_src
    + Run it:
      #+begin_src shell
        scala hello.scala
      #+end_src

- Write a script in Scala and run it:
  1. Put this code in file =hello.scala=
     #+begin_src scala
       @main def m() = println("Hello, world, from a script!")
     #+end_src

  2. Run it in command line:
     ~scala hello.scala~

  3. Output:
     =Hello, world, from a script!=

- Write a script in Scala that can accept command line arguments, and then run
  it:
  1. Put this code in file =helloarg.scala=
     #+begin_src scala
       @main def m(args: String*) =
         // Say hello to the first argument
         println("Hello, " + args(0) + "!")
     #+end_src

  2. Run it in command line:
     ~scala helloarg.scala planet~

  3. Output:
     =Hello, planet!=

** DONE Step 5. Loop with ~while~; decide with ~if~ - 68
CLOSED: [2025-04-17 Thu 01:08]
- *Note*
  Although the examples in this section help explain ~while~ loops,
  they *DO NOT demonstrate the best Scala style.*
    In the next section, you'll see better approaches that avoid iterating
  through sequences with indexes.

- Write a script in Scala and run it:
  1. Put this code in file =printargs.scala=
     #+begin_src scala
       @main def m(args: String*) =
         var i = 0
         while i < args.length do
           println(args(i))
           i += 1
     #+end_src

  2. Run it:
     ~scala printargs.scala Scala is fun~

  3. Output:
     #+begin_src text
       Scala
       is
       fun
     #+end_src

- Write a script in Scala and run it:
  1. Put this code in file =echoargs.scala=
     #+begin_src scala
       @main def m(args: String*) =
         var i = 0
         while i < args.length do
           if i != 0 then
             print(" ")
           print(args(i))
           i += 1
         println()
     #+end_src

  2. Run it:
     ~scala echoargs.scala Scala is even more fun~

  3. Output:
     #+begin_src text
       Scala is even more fun
     #+end_src

- As of Scala 3, the /indentation-based style/, called *"quiet syntax,"* is
  recommended over the /curly brace style/.

- Scala 3 also introduced /end markers/, to make it easier to see where larger
  indented regions end.
  * /End markers/ consist of the keyword ~end~ followed by a /specifier token/,
    which is either an /identifier/ or a /keyword/.
    =NEXT=
    An example is shown in Listing 10.9.

** DONE Step 6. Iterate with ~foreach~ and ~for-do~ - 71
CLOSED: [2025-04-17 Thu 01:22]
- In the last step, we see a imperative way that uses ~while~ loops.

- Another (far more concise) way to print each command line argument is:
  #+begin_src scala
    @main def m(args: String*) =
      args.foreach(arg => println(arg))
  #+end_src
  This is more functional -- passing a /function literal/ to ~foreach~.

  Run it: ~scala pa.scala Concise is nice~ and see output:
  #+begin_src text
    Concise
    is
    nice
  #+end_src
  * More conciseness:
    #+begin_src scala
      @main def m(args: String*) =
        args.foreach(println)
    #+end_src

- Use ~for~ expression:
  #+begin_src scala
    @main def m(args: String*) =
      for arg <- args do
        println(arg)
  #+end_src
  * ~arg~ is always a ~val~ and that's why this syntax ignore that. It can be
    easily proved that you can't reassign it inside the body of the ~for~
    expression.
    * For each element of the ~args~ array, a *new* ~arg~ will be created and
      initialized to the element value, and the body of the ~for~ will be
      executed.

- More on ~for~ expressions in Step 12, Chapter 3, Section 7.3, and in
  _Advanced Programming in Scala_.

- footnote 12:
  You can say "in" for the ~<-~ symbol.
  You'd read ~for arg <- args do~, therefore, as _"for arg in args do."_

** DONE Conclusion - 73
CLOSED: [2025-04-17 Thu 01:09]

* DONE 3 Next Steps in Scala - 74 - _NOTE_
CLOSED: [2025-04-22 Tue 20:01]
This chapter continues the previous chapter's introduction to Scala.
In this chapter, we'll introduce some _more advanced_ features.

When you complete this chapter, you should have _enough knowledge_ to ENABLE you
to _start writing useful scripts in Scala_.

** DONE Step 7. Parameterize arrays with types - 74
CLOSED: [2025-04-19 Sat 02:14]
- In Scala, you can *instantiate* /objects/, or /class instances/, using ~new~.

  * When you *instantiate* an /object/ in Scala, you can /parameterize/ it with
    /values/ and /types/.

  * Parameterization :: "configuring" an /instance/ when you create it.

  * You /parameterize/ an /instance/ with /values/
    BY _passing /objects/ to a /constructor/ in parentheses_.
    Example:
    #+begin_src scala
      val big = new java.math.BigInteger("12345")
    #+end_src

  * You /parameterize/ an /instance/ with /types/
    BY _specifying one or more /types/ in square brackets._

  * When you /parameterize/ an /instance/ with BOTH /types/ and /values/,
    + the /types/ come first in its _square brackets_,
    + followed by the /value/ in _parentheses_.

- Listing 3.1 · Parameterizing an array with a type.
  #+begin_src scala
    val greetStrings = new Array[String](3)

    greetStrings(0) = "Hello"
    greetStrings(1) = ", "
    greetStrings(2) = "world!\n"

    for i <- 0 to 2 do
      print(greetStrings(i))
  #+end_src
  * *NOT* the best way to initialize an ~Array~.
    See Listing 3.2 on page 78 for a better way.

  * Declare a variable with ~val~ means this variable _can't be reassigned_.
    It _has nothing to do with_ the if the bound object itself is mutable or
    not!

  * If a /method/ takes _only one parameter_, and when the /receiver/ is
    explicitly specified, you can call it *WITHOUT* a _dot_ or _parentheses_.
    ~0 to 2~ in Listing 3.1 is an example, witch is equivalent to ~0.to(2)~.

  * =IMPORTANT=
    Scala *doesn't technically have* /operator overloading/,
    BECAUSE it doesn't actually have /operators/ in the traditional sense.

    Instead, characters such as +, -, *, and / can be used in /method names/.

  * =IMPORTANT=
    _Scala has *FEWER* SPECIAL CASES than Java._

    1. ~Array~'s are simply /instances of classes/ _LIKE ANY OTHER_ /class/ in
       Scala.
       - Indexing operation ~greetStrings(i)~ will be translated into
         ~greetStrings.apply(i)~

       - Array member assignment (by index) ~greetStrings(0) = "Hello"~ will be
         transformed into ~greetStrings.update(0, "Hello")~

    2. These transformation by compiler can happen
       IF ~apply~ and ~update~ methods exist in /types/.

    After compiler transformations mentioned here, the code is like:
    #+begin_src scala
      val greetStrings = new Array[String](3)

      greetStrings.update(0, "Hello")
      greetStrings.update(1, ", ")
      greetStrings.update(2, "world!\n")

      for i <- 0.to(2) do
        print(greetStrings.apply(i))
    #+end_src

- =IMPORTANT=
  Scala achieves a *conceptual simplicity* by treating everything, from arrays
  to expressions, as /objects/ with /methods/.

  * You don't have to remember special cases (like in Java).

  * Moreover, this _uniformity does NOT incur a SIGNIFICANT performance cost._
    The Scala compiler uses /Java arrays/, /primitive types/, and /native
    arithmetic/ *where possible in the compiled code.*

- Scala provides a *more concise way* to _create and initialize_ arrays that you
  would normally use (see Listing 3.2).
  #+begin_src scala
    val numNames = Array("zero", "one", "two")
  #+end_src
  Listing 3.2 · Creating and initializing an array.

  This will be transformed into
  #+begin_src scala
    val numNames = Array.apply("zero", "one", "two")
  #+end_src
  calling a /factory method/ ~apply~ from the /companion object/ of ~Array~.

- footnote 2:
  =IMPORTANT=
  =CONCEPT=
  /Variable-length argument lists/ \equiv /repeated parameters/

** DONE Step 8. Use lists - 78
CLOSED: [2025-04-22 Tue 19:22]
- One of the big ideas of the /functional style of programming/:
  _/methods/ should *NOT have* /side effects/._

  * Some benefits gained when you take this approach are that methods become
    less entangled, and therefore more reliable and reusable.

  * Another benefit (in a statically typed language) is that everything that
    goes into and out of a method is checked by a type checker, so logic errors
    are more likely to manifest themselves as type errors.

  Applying this functional philosophy to the world of objects means making
  objects *immutable*.

- Scala's ~List~ class:
  An *immutable* *sequence* of objects that share the *SAME* /type/.

- More generally, Scala's ~List~ is designed to _ENABLE_ a /functional style of
  programming/.

- List concatenation: ~:::~.

- If a method name ends in a *colon*, it is right associative!

** DONE Step 9. Use tuples - 83
CLOSED: [2025-04-22 Tue 19:25]
=from Jian= Not mention the operators ~*:~ and ~:*~ (Scala version 3.0 have it
or not???).

- _footnote 5:_ The Scala compiler uses a /syntactic sugar/ form for /tuple types/
  that looks *LIKE a tuple of types.*
  * For example,
    ~Tuple2[Int, String]~ is represented as ~(Int, String)~.
- In Scala 3, use the ~.apply~ method to extract an element in a tuple at a
  given index, *like using other indexible collections*.

  * _footnote 6:_ prior to Scala 3, you _accessed the elements of a tuple_ using
    /one-based field names/, such as ~_1~ or ~_2~.
    =Not deprecated till v3.6.4=

- _footnote 7:_ As of Scala 3, you can create tuples of any length.

** DONE Step 10. Use sets and maps - 84
CLOSED: [2025-04-22 Tue 19:32]
*Mutable* sets/maps and *immutable* sets/maps.

** DONE Step 11. Learn to recognize the functional style - 88
CLOSED: [2025-04-22 Tue 19:55]
As mentioned in Chapter 1, Scala
_ALLOWS_ you to program in an /imperative style/,
but _ENCOURAGES_ you to adopt a more /functional style/.

- If you come from an imperative background, we believe that learning to program
  in a functional style will not only make you a better Scala programmer, it
  will expand your horizons and make you a better programmer in general.

- The _FIRST_ step:
  recognize the difference between the two styles in code.
  * if code contains any ~var~'s, it is probably in an /imperative style/.
  * Similarly, if only ~val~'s, it is probably in an /functional style/.

- The *REASON* Scala encourages a /functional style/ is that it can help you
  write code that is
  * _more understandable,_
  * _less error-prone._

  Example:
  1. Imperative style:
     #+begin_src scala
       def printArgs(args: List[String]): Unit =
         var i = 0
         while i <- args.length do
           println(args(i))
           i += 1
     #+end_src

  2. Functional style:
     #+begin_src scala
       def printArgs(args: List[String]): Unit =
         for arg <- args do
           println(args(i))
     #+end_src

     or this:

     #+begin_src scala
       def printArgs(args: List[String]): Unit =
         args.foreach(println)
     #+end_src

- After the _FIRST_ step, go even further:
  The refactored ~printArgs~ method is *NOT* purely functional because of side effects.
  * ~Unit~ /result type/ is the telltale.

  We can move the side-effect free code to its own function:
  #+begin_src scala
    def formatArgs(args: List[String]) =
      args.mkString("\n")
  #+end_src

  and then the ~printArgs~ method body becomes:
  #+begin_src scala
    println(formatArgs(args))
  #+end_src

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =CRITICAL=
  Every useful program is likely to have /side effects/ of some form;
  otherwise, it wouldn't be able to _provide value to the outside world_.

  =from Jian=
  =IMPORTANT=
  It is not a single function, it is a program. There is no reason to write a
  program that can't provide value to the outside world.

  * =IMPORTANT=
    METHODOLOGY:
    _Preferring /methods/ *without* /side effects/_
    ENCOURAGES you to

    _design programs where /side-effecting code/ is *MINIMIZED*._

    + One benefit of this approach is that it can help make your programs
      *easier to test*.

      For example,
      For example, to test any of the three ~printArgs~ methods shown earlier in
      this section, you'd need to *redefine* ~println~, capture the output
      passed to it, and make sure it is what you expect.

      _BY CONTRAST,_
      you could test the ~formatArgs~ function simply by checking its result!
      =from Jian=
      Because body of ~printArgs~ which calls ~formatArgs~ is just a ~println~
      function call, and test ~formatArgs~ is enough to test ~printArgs~!

- =IMPORTANT=
  *A balanced attitude for Scala programmers*
  1. PREFER ~val~'s, /immutable objects/, and /methods WITHOUT side effects/.
     Reach for them first.

  2. Use ~var~'s, /mutable objects/, and /methods with side effects/
     WHEN you have a specific _NEED and JUSTIFICATION_ for them.

** DONE Step 12. Transform with ~map~ and ~for-yield~ - 91
CLOSED: [2025-04-22 Tue 20:01]
- =IMPORTANT=
  * When programming in an /imperative style/,
    you *MUTATE* data structures *in place* UNTIL you achieve the goal of the
    algorithm.

  * In a /functional style/,
    you *TRANSFORM* /IMMUTABLE data structures/ *into* NEW ones to achieve the
    goal.

- "defined" option :: If the ~Option~ is a ~Some~.
  =CONCEPT=
  =IMPORTANT=

** DONE Conclusion - 94
CLOSED: [2025-04-22 Tue 20:01]

* DONE 4 Classes and Objects - 95
CLOSED: [2025-04-22 Tue 18:00]
** DONE 4.1 Classes, fields, and methods - 95
CLOSED: [2025-04-21 Mon 22:09]
- A /class/ is a *blueprint* for /objects/.
  * Create /objects/ from /classes/ with the keyword ~new~.
    =from Jian=
    Scala 3 reduces the explicit ~new~ usages by design.
    =TODO= =???=
    I don't remember the details, try to find the document or PR about this!

- Inside a /class definition/, you place /fields/ and /methods/, which are
  collectively called /members/.
  * /Fields/ are /variables/ that refer to /objects/.
    + The /fields/ hold the
      - state
      - data
      of their host object.

  * /Methods/ contain executable code.
    + The /methods/ can use that data to do the computational work of the
      /object/.

- =TODO= _One way to check if your code is right!_
  One important way to pursue _ROBUSTNESS_ of an /object/ is to ensure that the
  /object's state/ -- the values of its /instance variables/ -- *remains VALID
  during its entire lifetime.*
  * One way to achieve this is to prevent outsiders from accessing the /fields/
    DIRECTLY by making the /fields/ ~private~.

- procedure :: A method that is executed only for its /side effects/.

** DONE 4.2 Semicolon inference - 99
CLOSED: [2025-04-21 Mon 22:17]
- *The rules of semicolon inference*
  The precise rules for statement separation are surprisingly simple for how
  well they work.

  In short, _a line ending is treated as a semicolon_
  *UNLESS* one of the following conditions is true:

  1. The line in question ends in a word that would _NOT be legal as the end of
     a statement_, such as a /period/ or an /infix operator/.

  2. The next line begins with a word that _CANNOT start a statement_.

  3. The line ends while inside parentheses ~(...)~ or brackets ~[...]~, because
     these _CANNOT contain multiple statements anyway_.

** DONE 4.3 Singleton objects - 100
CLOSED: [2025-04-21 Mon 22:34]
- A /singleton object definition/ looks like a /class definition/,
  EXCEPT instead of the keyword ~class~ you use the keyword ~object~.

- (class's) companion object :: when a /singleton object/ shares the _SAME name_
  with a /class/.
  * A /class/ and its /companion object/ must be in the SAME source file.
  * The /class/ is called the /companion class/ of the singleton object.
  * =IMPORTANT=
    A /class/ and its /companion object/ can access each other's ~private~
    memebers.

- A eample: Listing 4.2 · Companion object for class ChecksumAccumulator.
  * footnote 3:
    Might use a /weak map/, such as ~WeakHashMap~ in ~scala.collection.mutable~,
    so that entries in the cache
    could be _garbage collected IF memory becomes *scarce*._
    =TODO=
    =from Jian= Learn more about /weak map/!!!

- /Singleton objects/ extend a /superclass/ and can *mix* in /traits/.

- EACH /singleton object/ is implemented as an instance of a /synthetic class/
  referenced from a /static variable/, so they have the
  _SAME /initialization semantics/ as /Java statics/._
  =IMPORTANT=
  * In particular, a /singleton object/ is initialized the first time some code
    accesses it.
    =from Jian= A lazy initialization.

- standalone object :: A /singleton object/ that does not share the same name
  with a /companion class/.

  You can use /standalone objects/ for many purposes, including
  * collecting related utility methods together or
  * defining an _entry point_ to a Scala application.
    =NEXT=
    This use case is shown in the next section.

** DONE 4.4 Case classes - 103
CLOSED: [2025-04-21 Mon 22:50]
- _PROBLEM_:
  Often when you write a /class/, you need implementations of /methods/ such as
  ~equals~, ~hashCode~, ~toString~, /accessor methods/, or /factory methods/.
  _These can be *time-consuming* and *error-prone* to write._

- _SOLUTION_:
  =IMPORTANT=
  Scala offers *"case classes,"* which can
  *GENERATE* implementations of several methods based on the values passed to its
  /primary constructor/.

- Example:
  #+begin_src scala
    case class Person(name: String, age: Int)
  #+end_src

- With the addition of the ~case~ modifier, the compiler will generate
  several useful methods for you:

  The compiler will
  1. *CREATE* a /companion object/ and
     *PLACE* a /factory method/ in it named ~apply~.
     * Code ~Person("Sally", 30)~ will rewritten to ~Person.apply("Sally", 30)~.

  2. *STORE* all /class parameters/ *IN* /fields/ and
     *GENERATE* /accessor methods/ with the SAME name as the parameter.

  3. *PROVIDE* an implementation of ~toString~ for you.

  4. *GENERATE* an implementation of ~hashCode~ and ~equals~ for your /class/.
     * These /methods/ will base their result on the parameters passed to the
       /constructor/.

     =IMPORTANT=
  5. *NOT generate* any /method/ that you implement yourself.
     It will use your implementation.

  6. *ADDS* a ~copy~ method to your /class/ and an ~unapply~ method to the companion.
     =TODO=
     These will be described in Chapter 13.

- _SUMMARY_:
  All these conventions *ADD a lot of convenience -- AT a small price.*

** DONE 4.5 A Scala application - 105 - =I updated some content=
CLOSED: [2025-04-22 Tue 17:59]
=OUTDATED!!!=

- Need an entry point /main method/ in a standalone singleton object.
  * Can be the standard ~main~ method, or
  * Any function with the ~@main~ annotation, from _footnote 8_.

- Scala doesn't force the name of a source file,
  BUT it is *recommended style* to _name files *after* the /classes/ they
  CONTAIN_ as is done in Java,
  =IMPORTANT=
  so that programmers can more easily locate classes by looking at file names.

- =from Jian=
  This section mentioned script, and it said
  "NEITHER =ChecksumAccumulator.scala= NOR =Summer.scala= are scripts, BECAUSE they
  end in a definition. A script, by contrast, *must END in a result /expression/.*"
  =TODO=
  It should explain more about the /script/ concept in the context of Scala.

  =from Jian=
  I found the =scala= can run =.sc= that ends with an expression directly, but
  when using it to run the same content file with the =.scala= extension,
  #+begin_src text
    Illegal start of toplevel definition
  #+end_src

  Thus, even though here is exact definition of /script/, it seems in practice
  /script/ in the Scala context and can run with the =scala= command
  1. Must have =.sc= extension. Only with this extension, =scala= won't consider
     top level expression wrong!

  2. Make sure =.sc= content ends with a result /expression/.
     Without it, the /script/ is legal, but useless!!!

*** =from Jian= Update for Scala 3.5+
- Run from from the script(s): =.scala= or =.sc=
  1. Add a /using directive/ to the source file: =Summer.scala=.
     Assume its dependency =ChecksumAccumulator.scala= is in the same folder.
     #+begin_src scala
       //> using file ChecksumAccumulator.scala
     #+end_src

  2. Run in with the command:
     #+begin_src shell
       scala Summer.scala -- of love
     #+end_src

- Q :: How to run the compiled result =.class=?
- A :: From Scala 3.5 on,
  #+begin_src shell
    scalac ChecksumAccumulator.scala Summer.scala

    scala run -classpath . --main-class Summer -- of love
  #+end_src
  * NOT like before that uses ~scala Summer of love~.

  * Additional, if ~@main~ is used,
    the command becomes
    #+begin_src shell
      scala run -classpath . --main-class main -- of love
    #+end_src
    because a =main.class= is generated.

** DONE 4.6 Conclusion - 107
CLOSED: [2025-04-22 Tue 18:00]
This chapter has
- given you the basics of /classes/ and /objects/ in Scala, and
- shown you how to _compile_ and _run_ applications. =OUTDATED since Scala 3.5=

In the next chapter, you'll learn about Scala's basic types and how to use them.

* DONE 5 Basic Types and Operations - 108
CLOSED: [2025-04-27 Sun 11:20]
- In this chapter:
  * You'll get an overview of /Scala's basic types/, including:
    + ~String~'s and
    + the value types
      - ~Int~
      - ~Long~
      - ~Short~
      - ~Byte~
      - ~Float~
      - ~Double~
      - ~Char~
      - ~Boolean~

  * You'll learn the operations you can perform on these types, including
    + how /operator precedence/ works in Scala expressions.
    + how Scala *"enriches"* these /basic types/, giving you additional
      operations beyond those supported by Java.

** DONE 5.1 Some basic types - 108
CLOSED: [2025-04-27 Sun 00:14]
- integral types ::
  + ~Byte~
  + ~Short~
  + ~Int~
  + ~Long~
  + ~Char~

- numeric types :: /integral types/ + ~Float~ + ~Double~

- For the /basic types/,
  _other than_ ~String~, which resides in /package/ ~java.lang~,
  all of the types shown in Table 5.1 are members of /package/ ~scala~.

- Scala's /numeric types/ have the *EXACT same ranges* as the corresponding
  types in Java. This enables the Scala compiler to _TRANSFORM_ instances of
  /Scala value types/, _DOWN TO_ /Java primitive types/ in the /bytecodes/ it
  produces.
  =FIXME=
  Replace /Scala's basic types/ with /Scala's numeric types/, because only them
  have *range*!!!

** DONE 5.2 Literals - 109
CLOSED: [2025-04-27 Sun 00:33]
- All of the /basic types/ listed in _Table 5.1_ can be written with /literals/.

- *Fast track for Java programmers*
  Special in Scala:
  * /raw strings/ page 112
  * /string interpolation/ page 114
  * Scala doesn't support /octal literals/, while Java support it.
    Integer-literal-like ~031~, can't compile in Scala!!!
    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=

*** Integer Literals - 110
*** Floating point literals - 111
*** Larger numberic literals - 111
In Scala 3 includes an *experimental feature* that _eliminates size limits
for /numeric literals/ and allows them be used to initialize ARBITRARY types._

You can enable the feature with this language import:
~import scala.language.experimental.genericNumberLiterals~

- Here are two examples from the standard library:
  #+begin_src scala
    val invoice: BigInt = 1_000_000_000_000_000_000_000
    val pi: BigDecimal = 3.1415926535897932384626433833
  #+end_src

*** Character literals - 112
Any Unicode character.

*** String literals - 112
- raw strings ::
  It is *awkward* for writing strings that contain a lot of escape sequences or
  strings that span multiple lines in traditional Java-like string syntax.

  Scala includes a _special syntax_ for /raw strings/.

  * Example:
    #+begin_src scala
      println("""Welcome to Ultamix 3000.
                 Type "HELP" for help.""")

      // Welcome to Ultamix 3000.
      //            Type "HELP" for help.
    #+end_src
    + Fix this usually unwanted indentation with:
      #+begin_src scala
        println("""|Welcome to Ultamix 3000.
                   |Type "HELP" for help.""".stripMargin)

        // Welcome to Ultamix 3000.
        // Type "HELP" for help.
      #+end_src

*** Boolean literals - 114

** DONE 5.3 String interpolation - 114
CLOSED: [2025-04-27 Sun 00:41]
- ~s~ string interpolator:
  The expression, ~s"Hello, $name!"~ is a /processed string literal/.
  * The ~s~ interpolator will
    1. EVALUATE each _embedded expression_,
    2. INVOKE ~toString~ on each result, and
    3. REPLACE the _embedded expressions_ in the literal WITH those results.

- ~raw~ string interpolator:
  it does *NOT* recognize /character literal escape sequences/
  #+begin_src scala
    println(raw"No\\\\escape!") // prints: No\\\\escape!
  #+end_src

- ~f~ string interpolator:
  Allows you to attach *printf-style formatting instructions* to
  _embedded expressions_.
  * Example:
    #+begin_src scala
      f"${math.Pi}%.5f"
      // 3.14159
    #+end_src

- =TODO=
  The ~s~, ~f~, and ~raw~ /string interpolators/ are implemented via this
  *GENERAL mechanism*.
  Libraries and users *CAN define* other /string interpolators/ for other
  purposes.

** DONE 5.4 Operators are methods - 116
CLOSED: [2025-04-27 Sun 00:56]
- ~1 + 2~ \equiv{} ~1.+(2)~

- ~Int~ contains *SEVERAL* _overloaded ~+~ methods_.

- footnote 4:
  In future versions of Scala, methods with non-symbolic names will only be
  allowed as operators if they are declared with the ~infix~ modifier.
  =IMPORTANT=

- =IMPORTANT=
  In /Scala operators/ are *NOT special* _language syntax_;
  *ANY* /method/ that accepts a _SINGLE parameter_ can be an /operator/.

- /prefix operators/ and /postfix operators/.
  * They are /unary/.
  * ~unary_-~ method is one can be used to implement the unary ~-~ for your
    types. Scala tranfsform the expression ~-2.0~ into the /method invocation/
    ~(2.0).unary_-~.

  * The *ONLY* identifiers that can be used as /prefix operators/ are
    + ~+~
    + ~-~
    + ~!~
    + ~~~

  * You can define your method with name ~unary_*~, but it won't be handled by
    the compiler as a /prefix operator/.

  * If a method that requires no arguments, you can alternatively
    _leave off the dot and use postfix operator notation._

    However,
    the compiler will require that you ~import scala.language.postfixOps~ before
    you call a method in /postfix notation/
    =IMPORTANT=

    + =from Jian= Don't use /postfix operators/. I don't like it. It is often
      confusing!

** DONE 5.5 Arithmetic operations - 119
CLOSED: [2025-04-27 Sun 01:02]
- =IMPORTANT=
  =from Jian= =TRICKY=
  #+begin_src scala
    11.0f / 4.0f // 2.75: Float
    11.0 % 4.0 // 3.0: Double
  #+end_src
  =!!!=
  The /floating-point remainder/ you get with ~%~ is *NOT* the one defined by
  the IEEE 754 standard.

  The *IEEE 754* remainder uses /rounding division/, *not* /truncating
  division/, in calculating the /remainder/, so it is *quite different from* the
  /integer remainder operation/. If you really want an /IEEE 754 remainder/, you
  can call ~IEEEremainder~ on ~scala.math~, as in:
  #+begin_src scala
    math.IEEEremainder(11.0, 4.0) // -1.0: Double
  #+end_src

** DONE 5.6 Relational and logical operations - 120 - =REVIEW=
CLOSED: [2025-04-27 Sun 01:06]
- ~&&~: logical-and with short circuit
- ~||~: logical-or with short circuit
- ~&~ : logical-and NO short-circuit =Often forget about this=
- ~|~ : logical-or NO short-circuit =Often forget about this=

** DONE 5.7 Bitwise operations - 121
CLOSED: [2025-04-27 Sun 01:10]
- Bitwise methods :: operations on individual bits of integer types.
  * bitwise-and: ~&~
  * bitwise-or: ~|~
  * bitwise-xor: ~^~
  * bitwise-complement: ~

- ~<<~
- ~>>~
- ~>>>~

** DONE 5.8 Object equality - 122 - =REVIEW=
CLOSED: [2025-04-27 Sun 11:19]
- ~==~ first check the left side for ~null~. If it is not ~null~, calls the
  ~equals~ method.
  * =IMPORTANT=
    Since there is an _automatic ~null~ check_, you do *NOT have to* do the
    check yourself.
    =Often forget about this=

- *How Scala's ~==~ differs from Java's*
  * In Java,
    ~==~ between /primitive types/ compares *value equality*.
    ~==~ between /reference types/ compares *reference equality*.

  * In Scala,
    ~==~ is always intended for *value equality*.
    *reference equality* check if left for ~eq~ (and its opposite ~ne~).

** DONE 5.9 Operator precedence and associativity - 124 - =REVIEW=
CLOSED: [2025-04-27 Sun 11:19]
- *Scala doesn't have operators*, per se, just a way to use methods in operator
  notation.
  * =from Jian=
    This means Scala can't have rules for a limited number symbols about their
    precedence.

  * Q :: How /operator precedence/ works in Scala.
    + Or say: How /operator-like method precedence/ works in Scala.

  * A ::
    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    Consider the first character of an operator-like method.
    + =IMPORTANT=
      One exception!!! See below.

- Table 5.3 · Operator precedence
  1. (all other special characters)
  2. *, /,  %
  3. +, -
  4. :
  5. <, >
  6. =, !
  7. &
  8. ˆ
  9. |
  10. (all letters)
  11. (all assignment operators)

- The one *EXCEPTION* to the _precedence rule_, alluded to earlier,
  concerns *assignment operators*, which end in an equals character.

  If
  1. an operator *ends* in an equals character (~=~), and
  2. the operator is *NOT* one of the comparison operators
     * <=
     * >=
     * ==
     * !=
  then the precedence of the operator is the same as that of simple assignment
  (~=~).

  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =from Jian=
  SUMMARY:
  /Operator precedence/ always consider the first character, except operators
  ends with ~=~ (excluding ~<=~, ~>=~, ~==~, and ~!=~, which still use the first
  character rule).

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  No matter what /associativity/ an operator has,
  however, *its operands are always evaluated _left to right_.*

  So if a is an expression that is not just a simple reference to an immutable
  value, then ~a ::: b~ is more precisely treated as the following block:
  #+begin_src scala
    { val x = a; b.:::(x) }
  #+end_src

  instead of simply ~b.:::(a)~.

  * =IMPORTANT=
    This is extremely important especially when ~a~ or ~b~ evaluations include
    /side effects/.

- Operator precedence is part of the Scala language.
  You needn't be afraid to use it.

** DONE 5.10 Rich operations - 127
CLOSED: [2025-04-27 Sun 01:21]
=from Jian=
=IMPORTANT=
=IMPORTANT=
=IMPORTANT=
*MISLEADING*:
*MISLEADING*:
*MISLEADING*:
"these methods are available via implicit conversions, a deprecated technique"

/implicit conversion/ is not a deprecated technique!
Use /implicit conversion/ to add rich operations is a deprecated technique,
which should be replaced by /extension methods/.

- It seems this can be clarified in a new added footnote for this part!

- Currently, still use the old way, with /implicit conversions/.
  The rich wrapper classes:

  Table 5.5 · Rich wrapper classes

  | Basic type | Rich wrapper                |
  |------------+-----------------------------|
  | ~Byte~     | ~scala.runtime.RichByte~    |
  | ~Short~    | ~scala.runtime.RichShort~   |
  | ~Int~      | ~scala.runtime.RichInt~     |
  | ~Long~     | ~scala.runtime.RichLong~    |
  | ~Char~     | ~scala.runtime.RichChar~    |
  | ~Float~    | ~scala.runtime.RichFloat~   |
  | ~Double~   | ~scala.runtime.RichDouble~  |
  | ~Boolean~  | ~scala.runtime.RichBoolean~ |
  | ~String~   | ~scala.runtime.RichString~  |

** DONE 5.11 Conclusion - 127
CLOSED: [2025-04-27 Sun 11:20]

* DONE 6 Functional Objects - 129
CLOSED: [2025-04-28 Mon 22:36]
- In this chapter, the emphasis is on /classes/ that define /functional objects/.
  * functional objects :: objects that do _NOT have any /mutable state/._

- As a running example, we'll create _SEVERAL_ variants of a /class/ that models
  _rational numbers_ as /immutable objects/.

- Along the way, we'll show you more aspects of _object-oriented programming in
  Scala_:
  1. class parameters and constructors
  2. /methods/ and operators
  3. private members
  4. /overriding/
  5. checking preconditions
  6. /overloading/
  7. /self references/

** DONE 6.1 A specification for class ~Rational~ - 129
CLOSED: [2025-04-28 Mon 11:43]
- rational numbers :: numbers that can be expressed as a ratio n / d , where n
  and d are integers, except that d cannot be zero.
  * Compared to /floating-point numbers/, /rational numbers/ have the advantage
    that _fractions are represented EXACTLY, without rounding or approximation._

- Illustration example for this chapter: /rational number/.
  The class we'll design in this chapter must
  MODEL the _arithmetic behavior of rational numbers_,
  including allowing them to be _added_, _subtracted_, _multiplied_, and
  _divided_.
  * No mutable state in the _arithmetic behavior of rational numbers_ in
    mathematics.

** DONE 6.2 Constructing a ~Rational~ - 130
CLOSED: [2025-04-28 Mon 13:14]
- A good place to _START_ designing class ~Rational~ is to
  _consider how client programmers will create a new Rational object._

  _Given_ we've decided to make Rational objects immutable,
  we'll require that clients provide all data needed by an instance (in this
  case, a numerator and a denominator) WHEN they construct the instance.
  =from Jian= rather than later.
  #+begin_src scala
    class Rational(n: Int, d: Int)
  #+end_src
  =IMPORTANT=
  =IMPORTANT=
  =THIS IS WHY Scala CONSTRUCTOR SYNTAX IS MUCH CONCISER THAN Java=
  * The Scala compiler will
    1) GATHER up these two /class parameters/ and
    2) CREATE a /primary constructor/ that takes the same two parameters.

  * NoteThis initial Rational example highlights a difference between Java
    andScala. In Java, classes have constructors, which can take
    parameters;whereas in Scala, classes can take parameters directly. The
    Scala notationis more concise—class parameters can be used directly in the
    body of theclass; there’s no need to define fields and write assignments
    that copyconstructor parameters into fields. This can yield substantial
    savings inboilerplate code, especially for small classes.

- *Immutable object trade-offs*
  =TODO= =NOTE=

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =from Jian=: The way how does Scala compiler create the /primary constructor/:
  The Scala compiler will compile any code you place in the _class body_,
  which is *NOT* part of a /field/ or a /method definition/,
  into the /primary constructor/.
  * Example:
    Print a debug message when constructing a ~Rational~
    #+begin_src scala
      class Rational(n: Int, d: Int):
        println("Created " + n + "/" + d)
    #+end_src

- Universal ~apply~ Method :: when INSTANTIATING _classes that take parameters_,
  you can optionally leave off the ~new~ keyword.
  * ~Rational(1, 2)~ \equiv{} ~new Rational(1, 2)~

  =from Jian= This feature comes with Scala 3.

** DONE 6.3 Reimplementing the ~toString~ method - 132
CLOSED: [2025-04-28 Mon 13:18]
- The default string representation if no ~toString~ reimplmentation:
  ~className~ followed by ~@~ followed by _a hexadecimal number_

- Reimplementation
  #+begin_src scala
    class Rational(n: Int, d: Int):
      override def toString = s"$n/$d"
  #+end_src

** DONE 6.4 Checking preconditions - 133
CLOSED: [2025-04-28 Mon 13:32]
Given that a zero denominator is an _invalid state_ for a ~Rational~ number, you
should not let a ~Rational~ be constructed if a zero is passed in the d
parameter.

- *Problem*: The implementation before this section can't refuse the _zero denominator_.

- *Solution*: The best way to approach this problem is to define as a
  /precondition/ of the /primary constructor/ that _d must be non-zero_.
  #+begin_src scala
    class Rational(n: Int, d: Int):
      require(d != 0)
      override def toString = s"$n/$d"
  #+end_src
  ~require~ comes from ~Predef~.

** DONE 6.5 Adding fields - 134
CLOSED: [2025-04-28 Mon 16:54]
Make the class parameters as fields
=from Jian= the *NAIVE* way that we rarely use:
#+begin_src scala
  class Rational(n: Int, d: Int):
    require(d != 0)
    val numer: Int = n
    val denom: Int = d
    override def toString = s"$numer/$denom"
    def add(that: Rational): Rational =
      Rational(
        numer * that.denom + that.numer * denom,
        denom * that.denom
      )
#+end_src

footnote 3: In Section 10.6, you'll find the *shorthand* that we'll always use.

** DONE 6.6 Self references - 136
CLOSED: [2025-04-28 Mon 16:58]
~this~

** DONE 6.7 Auxiliary constructors - 136
CLOSED: [2025-04-28 Mon 17:17]
- auxiliary constructors :: constructors other than the /primary constructor/.

- Example use case:
  A /rational number/ with a denominator of 1 can be written more succinctly as
  simply the numerator (with an /auxiliary constructors/).

- /Auxiliary constructors/ in Scala start with ~def this(...)~,
  The body of ~Rational~'s /auxiliary constructor/ merely invokes the /primary
  constructor/.
  #+begin_src scala
    class Rational(n: Int, d: Int):
      require(d != 0)
      val numer: Int = n
      val denom: Int = d
      def this(n: Int) = this(n, 1) // auxiliary constructor
      override def toString = s"$numer/$denom"
      def add(that: Rational): Rational =
        Rational(
          numer * that.denom + that.numer * denom,
          denom * that.denom
        )
  #+end_src

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =RULE=
  In Scala, _EVERY_ /auxiliary constructor/ *MUST invoke* _ANOTHER_ /constructor/ of
  the _SAME_ /class/ as its first action -- in other words, the _first statement_ in
  every /auxiliary constructor/ in every Scala class will have the form ~this(...)~.

  Since the net effect of this rule is that _EVERY_ /constructor/ invocation in
  Scala will end up eventually calling the /primary constructor/ of the /class/.
  The /primary constructor/ is thus _the *single point of entry* of a /class/._

- *NOTE*
  * Q :: Why Scala's rules for /constructors/ are a bit *more restrictive than*
    Java's.

  * A ::
    + In Java,
      a /constructor/ *must, as its first action*,
      - either invoke another constructor of _the SAME /class/,_
      - or directly invoke a constructor of the /superclass/,

    + In a Scala class,
      *ONLY* the /primary constructor/ can invoke a /superclass constructor/.

    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    =???=
    =Learn more=
    The increased restriction in Scala is really a design trade-off that needed
    to be paid in exchange for the greater conciseness and simplicity of Scala's
    constructors compared to Java's.

    Superclasses and the details of how constructor invocation and inheritance
    interact will be explained in Chapter 10.

** DONE 6.8 Private fields and methods - 138
CLOSED: [2025-04-28 Mon 17:31]
- In the previous version of Rational, we simply initialized ~numer~ with ~n~
  and ~denom~ with ~d~, directly.
  #+begin_src scala
    Rational(66, 42) // 66/42
  #+end_src

- When binding values to fields ~numer~ and ~denom~, we can *normalize* them,
  and save smaller numbers to ~numer~ and ~denom~.
  #+begin_src scala
    class Rational(n: Int, d: Int):
      require(d != 0)
      private val g = gcd(n.abs, d.abs)
      val numer = n / g
      val denom = d / g
      def this(n: Int) = this(n, 1)
      def add(that: Rational): Rational =
        Rational(
          numer * that.denom + that.numer * denom,
          denom * that.denom
        )
      override def toString = s"$numer/$denom"
      private def gcd(a: Int, b: Int): Int =
        if b == 0 then a else gcd(b, a % b)
  #+end_src

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  The Scala compiler will
  _PLACE_ the code for the /initializers/ of ~Rational~'s THREE /fields/
  _into_ the /primary constructor/
         *in the order in which they appear in the source code.*

  Thus, ~g~'s /initializer/, ~gcd(n.abs, d.abs)~, will execute *before* the
  other two, because it appears first in the source.

** DONE 6.9 Defining operators - 139
CLOSED: [2025-04-28 Mon 18:13]
- =from Jian=
  When implement /symbolic unary operators/, _you *must compromise* on the
  language parser!_

  Not like other definitions, you *must add a space* between _function name_ and
  /method result type annotation/: ~: TypeXXX~.

** DONE 6.10 Identifiers in Scala - 141 - =REVIEW=
CLOSED: [2025-04-28 Mon 20:06]
- alphanumeric identifier :: Just C-style identifier. The only difference is, in
  Scala, $ also counts as a letter.
  * _CAUTION_:
    Don't use $ in your code. It is reserved for identifiers generated by the
    Scala compiler. If you use it, you may create /name clashes/.

  * *Note*:
    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    One consequence of using a /trailing underscore/ in an identifier is that
    if you attempt, for example, to write a declaration like this,
    ~val name_: Int = 1~, you'll get a *compiler error* -- the compiler will
    think you are trying to declare a val named ~name_:~.

    To get this to compile, you would need to *insert an extra space before the
    colon*, as in: ~val name_ : Int = 1~

- =IMPORTANT=
  Different from Java naming convention:
  Scala use Pascal case, also known as UpperCamelCase, as the name of constants.

- operator identifiers :: identifiers consists of one or more /operator characters/.
  * /Operator characters/ are printable ASCII characters
    SUCH AS
    + +
    + :
    + ?
    + ~
    + #

  * Here are some examples of /operator identifiers/:
    + +
    + ++
    + :::
    + <?>
    + :->

  * The Scala compiler will
    INTERNALLY
    *"mangle"* operator identifiers
    *to* turn them into /legal Java identifiers/ with embedded ~$~ characters.
    + For instance,
      the identifier :> would be REPRESENTED INTERNALLY AS $colon$minus$greater.

    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    + If you ever wanted to access this identifier _from Java code_,
      you'd need to use this internal representation.

  * =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    =TRICKY= but not a problem in practice
    =TRICKY=
    =TRICKY=
    Because operator identifiers in Scala *can become arbitrarily long*,
    there is a _small *difference* between Java and Scala._

    + In Java, the input x<-y would be parsed as *four* lexical symbols,
      so it would _be equivalent to_ x < - y.

    + In Scala, <- would be parsed as a _SINGLE_ identifier, giving x <- y.
      =IMPORTANT=

    If you want the first interpretation (like in Java) in Scala, you need to
    manually separate the < and - the characters by a space.

    This is *UNLIKELY to be a problem in practice*, as very few people would
    write x<-y in Java without inserting spaces or parentheses between the
    operators.

- mixed identifier :: consists of
  * an _alphanumeric identifier_, which is *followed by*
  * _an_ _underscore_ *and* (=from Jian= a single character!)
  * an /operator identifier/.

- /mixed identifier/ examples:
  * ~unary_-~
  * ~myvar_=~, more in Chapter 16 -- porperties (here, a /setter/ for ~myvar~).
    =TODO=
    =TODO=
    =TODO=

- literal identifier :: an aribitrary string enclosed in back ticks (`...`).
  * Examples:
    + `x`
    + `<clinit>`
    + `yield`

  * The idea is that
    you can put *any string* that's _accepted by the runtime_ (=from Jian= I
    guess this means, in short, legal Scala string) as an identifier between
    back ticks. The result is always a /Scala identifier/.

** DONE 6.11 Method overloading - 144
CLOSED: [2025-04-28 Mon 20:08]
#+begin_src scala
  // Inside `class Rational` definition:

  def +(that: Rational): Rational =
    Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )

  def +(i: Int): Rational =
    Rational(numer + i * denom, denom)
#+end_src

** DONE 6.12 Extension methods - 146
CLOSED: [2025-04-28 Mon 20:13]
- Problem:
  Now ~Rational~ ~r~ can do ~r * 2~, but ~2 * r~ doesn't work.

- Solution:
  Of course, you can't change ~Int~, but you can add /extension methods/ to it.
  #+begin_src scala
    extension (x: Int)
      def +(y: Rational) = Rational(x) + y
      def -(y: Rational) = Rational(x) - y
      def *(y: Rational) = Rational(x) * y
      def /(y: Rational) = Rational(x) / y
  #+end_src

- For /extension methods/ to work, they need to be *in scope*.

  * If you place the /extension method definitions/ inside ~class Rational~,
    it *WON'T be in scope* in the REPL.

    For now, you'll need to define it directly in the REPL.

** DONE 6.13 A word of caution - 147 - =REVIEW=
CLOSED: [2025-04-28 Mon 20:25]
- If *used unartfully*, both /operator methods/ and /extension methods/ can give
  rise to client code that is _hard to read and understand._
  * Because /extension methods/ are *applied implicitly* by the compiler,
    it can be *non-obvious to client programmers* what /extension methods/ are
    being applied.
    =from Jian= If the design is good, this application should be what those
    programmers expected.

  * And although /operator methods/ will usually make client code _more concise_,
    they will only make it _more readable_ *to the extent client programmers will
    be able to recognize and remember the meaning of each operator.*

- _SUMMARY_:
  * The _GOAL_ you should keep in mind as you design libraries is
    + not merely enabling _concise_ client code,
    + but _readable_, _understandable_ client code.

  * _Conciseness_ will OFTEN be a big part of that readability,
    *BUT* you can _take conciseness *too far*._

  * By designing libraries that enable tastefully concise and at the same time
    understandable client code, you can help those client programmers work
    productively.

** DONE 6.14 Conclusion - 147
CLOSED: [2025-04-28 Mon 22:36]
- ~Rational~ can be improved further.
  It will be revisited and improved later in the book:
  * In Chapter 8, override ~equals~ and ~hashcode~ to allow Rationals to behave
    better when compared with == or placed into hash tables.

  * In Chapter 22, you'll learn how to place /extension method definitions/ in a
    /companion object/ for ~Rational~, so they can be _more easily placed into
    /scope/_ when client programmers are working with ~Rational~'s.

* DONE 7 Built-in Control Structures - 149
CLOSED: [2025-05-16 Fri 20:14]
- Scala has only a handful of built-in control structures.
  The _only control structures_ are
  * ~if~
  * ~while~
  * ~for~
  * ~try~
  * ~match~
  * function calls

- The reason Scala has so few:
  it has included /function literals/ since its inception.

  Instead of accumulating one higher-level control structure after another in
  the base syntax, Scala accumulates them in libraries.
  * =TODO= Learn more about how to do this from Chapter 9.

- =???=
  In other words, Scala's if can result in a value. Scala then continues this
  trend by having for, try, and match also result in values.

- Overall, Scala’s basic control structures, minimal as they are, provide all of
  the essentials from imperative languages. Further, they allow you to shorten
  your code by consistently having result values. To show you how this works,
  we’ll take a closer look at each of Scala’s basic control structures.

- =TODO=
  Missing =NOTE=

** DONE 7.1 If expressions - 150
CLOSED: [2025-04-27 Sun 11:48]
- Imperative way (don't use this way in Scala when possible):
  #+begin_src scala
    var filename = "default.txt"
    if !args.isEmpty then
      filename = args(0)
  #+end_src
  * In most imperative languages, ~if~ is not an expression, and you have to use
    this way.

- Functional way (recommended):
  #+begin_src scala
    val filename =
      if !args.isEmpty then args(0)
      else "default.txt"
  #+end_src
  * In most languages not in functional paradigm, if you want to write code in
    such a concise way, you may need a /ternary operator/.

- =FIXME=
  Why do we use the old style ~if~ syntax in this expression???
  ~println(if (!args.isEmpty) args(0) else "default.txt")~

** DONE 7.2 While loops - 151
CLOSED: [2025-04-27 Sun 12:13]
The ~while~ construct is called a "loop," *NOT an expression*, because it
doesn't result in an interesting value. The type of the result is ~Unit~.

- =from Jian=
  Syntactically, ~while~ is still an expression, because it result in ~Unit~.
  However, since we use ~while~ for /side effect/, not for values, we prefer to
  call it *while loops*, not while expression.

- As of Scala 3, Scala no longer offers a ~do-while~ loop.

- Example:
  =from Jian=
  You can see we put mutiple expressions in the _condition_ position:
  #+begin_src scala
    import scala.io.StdIn.readLine

    while
      val line = readLine()
      println(s"Read: $line")
      line != ""
    do ()
  #+end_src

  * Assignment in Scala doesn't return the value being assigned,
    write code like this is *NOT compilable*:
    #+begin_src scala
      var line = "" // This doesn't compile!
      while (line = scala.io.StdIn.readLine()) != "" do
        println(s"Read: $line")
    #+end_src

- Since ~while~ is often used in companion with ~var~,
  in general, we recommend you challenge /while loops/ in your code in the same
  way you challenge ~var~'s.

** DONE 7.3 For expressions - 154
CLOSED: [2025-04-27 Sun 12:39]
*** Iteration through collections - 154
#+begin_src scala
  val filesHere = (new java.io.File(".")).listFiles
  for file <- filesHere do
     println(file)
#+end_src

- ~file <- filesHere~ syntax is called a /generator/.

- The ~for~ expression syntax works for *any kind of collection*.
  * footnote:
    To be precise, the expression to the right of the ~<-~ symbol in a ~for~
    expression can be any type that has certain methods (in the above case
    ~foreach~) with appropriate signatures.

    =TODO=
    =TODO=
    =TODO=
    Details on how the Scala compiler processes for expressions are described in
    Chapter 2.

*** Filtering - 156
#+begin_src scala
  val filesHere = (new java.io.File(".")).listFiles
  for file <- filesHere if file.getName.endsWith(".scala") do
    println(file)
#+end_src

- An alternative:
  #+begin_src scala
    val filesHere = (new java.io.File(".")).listFiles
    for file <- filesHere do
      if file.getName.endsWith(".scala") then
        println(file)
  #+end_src
  * They are the same for current usage.
  * Sometimes, only the former one works -- I mean when using ~for-yield~.

- Multiple filters:
  #+begin_src scala
    for
      file <- filesHere
      if file.isFile
      if file.getName.endsWith(".scala")
    do println(file)
  #+end_src

*** Nested iteration - 157
If you add multiple ~<-~ clauses, you will get *nested "loops."*

- Example:
  #+begin_src scala
    def fileLines(file: java.io.File) =
      scala.io.Source.fromFile(file).getLines().toArray


    def grep(pattern: String) =
      for
        file <- filesHere
        if file.getName.endsWith(".scala")
        line <- fileLines(file)
        if line.trim.matches(pattern)
      do println(s"$file: ${line.trim}")

    grep(".*gcd.*")
  #+end_src

*** Mid-stream variable bindings - 157
Improve the example code in the last section, and _ONLY do ~line.trim~ once._
#+begin_src scala
  def grep(pattern: String) =
    for
      file <- filesHere if file.getName.endsWith(".scala")
      line <- fileLines(file)
      trimmed = line.trim
      if trimmed.matches(pattern)
  do println(s"$file: $trimmed")

  grep(".*gcd.*")
#+end_src

*** Producing a new collection
With ~yield~.
#+begin_src scala
  def scalaFiles =
    for
      file <- filesHere
      if file.getName.endsWith(".scala")
    yield file
#+end_src

** DONE 7.4 Exception handling with ~try~ expressions - 159
CLOSED: [2025-04-27 Sun 13:11]
Scala's exceptions behave just like in many other languages.

- The /exception/ propagates in this way,
  unwinding the /call stack/,
  until _a method handles it_ OR _there are no more methods left_.

*** Throwing exceptions - 159
Example: ~throw new IllegalArgumentException~

=IMPORTANT=
Technically, an /exception throw/ has type ~Nothing~.

*** Catching exceptions - 160
Scala ~catch~ /exceptions/ with /pattern matching/.

#+begin_src scala
  import java.io.FileReader
  import java.io.FileNotFoundException
  import java.io.IOException

  try
    val f = new FileReader("input.txt")
    // Use and close file
  catch
    case ex: FileNotFoundException => // Handle missing file
    case ex: IOException => // Handle other I/O error
#+end_src

- *Note*
  =IMPORTANT=
  One difference you'll quickly notice in Scala is that, *unlike Java*,
  * Scala does *NOT* require you to
    + catch /checked exceptions/ or
    + declare them in a /throws clause/.

  * You can declare a /throws clause/ if you wish with the ~@throws~ annotation,
    but it is not required.

    =TODO=
    =IMPORTANT=
    =IMPORTANT=
    See Section 9.2 for more information on ~@throws~.

*** The ~finally~ clause - 161
- You can guard an expression with a ~finally~ clause
  IF you want to cause some code to _execute no matter how the expression
  completes._
  #+begin_src scala
    import java.io.FileReader

    val file = new FileReader("input.txt")
    try
      println(file.read()) // Use the file
    finally
      file.close() // Be sure to close the file
  #+end_src
  Listing 7.12 · A ~try-finally~ clause in Scala.

- *Note*
  * Listing 7.12 shows the /idiomatic way/ to ensure a *non-memory resource*,
    such as a file, socket, or database connection, is closed.
    1. Acquire the resource;
    2. Start a ~try~ block in which you use the resource;
    3. Close the resource in a ~finally~ block.

  * _ALTERNATIVELY_,
    in Scala you can employ a technique called the /loan pattern/ to achieve the
    same goal more concisely.

    =TODO=
    =IMPORTANT=
    The /loan pattern/ will be described in Section 9.4.

*** Yielding a value - 162 - =TRICKY=
As with most other Scala control structures,
*try-catch-finally results in a value.*

- _IF_ an exception is thrown but *not caught*,
  the expression has no result at all.

  The value computed in the ~finally~ clause, if there is one, is *DROPPED*.

- =IMPORTANT=
  =TRICKY=
  =TRICKY=
  If you're familiar with Java, it's worth noting that Scala's behavior differs
  from Java only because Java's ~try-finally~ does NOT result in a value.
  * As in Java,
    if a ~finally~ clause includes an EXPLICIT ~return~ statement, or throws an
    exception, that /return value/ or /exception/ will *"overrule"* any previous
    one that originated in the try block or one of its ~catch~ clauses.

  * Given this, rather contrived, function defintion:
    #+begin_src scala
      // From Jian: same as in Java
      def f(): Int = try return 1 finally return 2
    #+end_src
    calling ~f()~ results in 2.

    By contrast, given:

    #+begin_src scala
      def g(): Int = try 1 finally 2
    #+end_src
    calling ~g()~ results in 1.

- =IMPORTANT=
  SUMMARY:
  *it's usually best to avoid returning values from ~finally~ clauses.*

  * The best way to think of ~finally~ clauses is
    as a way to _ENSURE_ *some side effect happens*, such as closing an open
    file.

** DONE 7.5 Match expressions - 163
CLOSED: [2025-04-27 Sun 13:19]
** DONE 7.6 Living without ~break~ and ~continue~ - 164 - =REVIEW=
CLOSED: [2025-05-16 Fri 20:03]
Scala LEAVES OUT *break* and *continue*
_BECAUSE_ they do not mesh well with /function literals/, a feature described in
the next chapter.

- Q :: It is clear what /continue/ means inside a while loop,
  but what would it mean inside a /function literal/?

- WHILE Scala supports BOTH /imperative style/ and /functional style/ of
  programming,
  in this case it _leans slightly towards_ /functional programming/ in exchange
  for simplifying the language.

  Do not worry, though.
  There are many ways to program without /break/ and /continue/, and if you take
  advantage of /function literals/, those alternatives can often be *SHORTER than*
  the original code.

- =IMPORtANT=
  The simplest approach is to
  * replace every /continue/ by an ~if~.
  * replace every /break/ by a /boolean variable/.

- Example:
  Translate a Java program with ~continue~ and ~break~ into Scala code:
  1. Java code:
     #+begin_src java
       int i = 0;                // This is Java
       boolean foundIt = false;
       while (i < args.length) {
           if (args[i].startsWith("-")) {
               i = i + 1;
               continue;
           }
           if (args[i].endsWith(".scala")) {
               foundIt = true;
               break;
           }
           i = i + 1;
       }
     #+end_src

  2. Scala code:
     Listing 7.16 · Looping without break or continue.
     #+begin_src scala
       var i = 0
       var foundIt = false

       while i < args.length && !foundIt do
         if !args(i).startsWith("-") then
           if args(i).endsWith(".scala") then
             foundIt = true
           else
             i = i + 1
         else
           i = i + 1
     #+end_src
     BUT with ~var~'s.

  3. Get rid of ~var~'s by using recursion form:
     #+begin_src scala
       def searchFrom(i: Int): Int =
         if i >= args.length then -1
         else if args(i).startsWith("-") then searchFrom(i + 1)
         else if args(i).endsWith(".scala") then i
         else searchFrom(i + 1)

       val i = searchFrom(0)
     #+end_src
     Many people find this style of programming _easier to understand_,
     *ONCE* they get used to the /recursion/.

- Note:
  The Scala compiler will *NOT actually emit a recursive function* for the code
  shown in Listing 7.17.

  BECAUSE _ALL_ of the /recursive calls/ are in /tail-call/ position, the
  compiler will generate *code similar to a while loop* -- each /recursive call/
  will be implemented as a jump back to the beginning of the function.

  /Tail-call optimization/ is discussed in Section 8.10.

- =from Jian=
  See ~scala.util.control.Break~

** DONE 7.7 Variable scope - 166
CLOSED: [2025-04-27 Sun 13:37]
- *Fast track for Java programmers*
  If you're a Java programmer, you'll find that Scala's scoping rules
  are *almost identical to Java's.*
  * _One difference_:
    Scala ALLOWS you to define variables of the same name in nested scopes.

- Keep in mind that shadowing can be very confusing to readers, because variable
  names adopt new meanings in nested scopes.

  It is usually better to choose a new, meaningful variable name rather than to
  shadow an outer variable.
  * =from Jian=
    This is why I don't like the name shadowing feature in Rust.
    In Rust, you can shadow names defined before some point, even they are in
    the same scope level -- the new variable take effect since its definition
    line.

    + The only scenario I think is not confusing and useful is shadow a variable
      that has the same meaning by different type.
      For example, a input ~number~ is in ~String~ type, and in your function
      body you want to parse it as a integer number and use. In this case, not
      pick a new name is convenient and not confusing (at least for me)!

** DONE 7.8 Refactoring imperative-style code - 169
CLOSED: [2025-05-16 Fri 20:12]
Listing 7.18 · Variable scoping when printing a multiplication table.

|
|
v

Listing 7.19 · A functional way to create a multiplication table.

=from Jian=
We Chinese use nine-nine multiplication table, while here is ten-ten
multiplication table.

** DONE 7.9 Conclusion - 171
CLOSED: [2025-04-27 Sun 13:40]
=IMPORTANT=
Just as important, /Scala's built-in control structures/ *are careful in what
they omit* (=from Jian= keywords ~break~ and ~continue~), thus leaving room for
one of Scala's most powerful features, the /function literal/, which will be
described in the next chapter.

* DONE 8 Functions and Closures - 172
CLOSED: [2025-04-30 Wed 21:53]
When programs get larger, you need some way to divide them into smaller, more
manageable pieces.

- For dividing up /control flow/, Scala offers an approach familiar to all
  experienced programmers:
  divide the code into /functions/.

- In fact, Scala offers _SEVERAL WAYS_ to *define functions* that are _NOT
  PRESENT in Java_:
  * Besides /methods/, which are functions that are members of some object,
  * there are also
    + /functions nested within functions/,
    + /function literals/, and
    + /function values/.

- This chapter takes you on a tour through all of these flavors of functions in
  Scala.

** DONE 8.1 Methods - 172
CLOSED: [2025-04-28 Mon 22:57]
Example:
#+begin_src scala
  object Padding:
    def padLines(text: String, minWidth: Int): String =
      val paddedLines =
        for line <- text.linesIterator yield
          padLine(line, minWidth)
      paddedLines.mkString("\n")

    private def padLine(line: String, minWidth: Int): String =
      if line.length >= minWidth then line
      else line + " " * (minWidth - line.length)
#+end_src

** DONE 8.2 Local functions - 173
CLOSED: [2025-04-28 Mon 23:04]
- =from Jian=
  This section first explained why support /local functions/?
  =IMPORTANT=

- An IMPORTANT _design principle_ of the /functional programming style/:
  programs should be decomposed into many small functions that each do
  a well-defined task.

  Individual functions are often quite small.

  * _The advantage of this style:_
    + It gives a programmer many building blocks that can be flexibly composed
      to do more difficult things.

    + Each building block should be simple enough to be understood individually.

  * _One problem with this approach:_
    all the helper function names can *pollute* the /program namespace/.

    + Solution from Java: /private method/ -- not a perfect solution.

    + Scala offers an additonal approach:
      define functions inside other functions.
      - A /local function/ has a limited scope as expected.
      - A /local function/ can use its enclosing function's parameters directly,
        because it is in a scope that can reach those parameters.

** DONE 8.3 First-class functions - 175
CLOSED: [2025-04-29 Tue 00:15]
- first-class functions ::
  1. You can expression functions in /function literal/ syntax,
  2. that functions can be represented by /objects/, which are called /function
     values/.

- =from Jian=
  /first-class functions/ given by the book Glossary is not the concept,
  but the implementation overview of /first-class functions/ in Scala.

  The *CONCEPT* should be (from _Wikipedia_):
  /first-class functions/ if it treats /functions/ as /first-class citizens/.
  This means the language supports
  * *passing* functions as arguments to other functions,
  * *returning* them as the values from other functions, and
  * *assigning* them to variables or storing them in data structures.

- A /function literal/ is compiled into a /Java method handle/ that, when
  _instantiated at runtime_, is a /function value/.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  Thus the *DISTINCTION* between /function literals/ and /function values/:
  * /function literals/ exist _in the source code,_
  * whereas /function values/ exist _as /objects/ at runtime._

  This *DISTINCTION* is much like that between /classes/ (source code) and
  /objects/ (runtime).

- A simple example of a /function literal/:
  ~(x: Int) => x + 1~

- /function values/ are /objects/, so you can _store them in_ /variables/ if you
  like.
  Example:
  #+begin_src scala
    val increase = (x: Int) => x + 1
    increase(10) // 11
  #+end_src

  * More than one line /function literal/ body:
    #+begin_src scala
      val addTwo = (x: Int) =>
        val increment = 2
        x + increment

      addTwo(10) // 12
    #+end_src

- =from Jian=
  In Scala, _NOT ALL_ function-like things are _first-class citizens_.
  /Local functions/ and /methods/ are *NOT* _first-class citizens_ in Scala.

  HOWEVER,
  because of /eta-expansion/, it is easy to convert /Local functions/ and
  /methods/ into /function values/, which are first-class citizens.
  Also, Scala 3 can do a lot, if not all, of /automatic eta-expansion/, which
  blurs the line.

** DONE 8.4 Short forms of function literals - 176 - =REVIEW= - =RE-READ=
CLOSED: [2025-04-29 Tue 00:22]
Scala provides a number of ways to
_leave out redundant information_ and
_write /function literals/ *more briefly*._

- One way to make a /function literal/ more brief is to
  *LEAVE OFF the /parameter types/.*

- target typing :: the targeted usage of an /expression/ (in this case, an
  argument to ~someNumbers.filter()~) is allowed to influence the
  _typing of that expression_ (in this case to determine the type of the ~x~
  parameter).
  * The precise details of /target typing/ are not important.

- _Methodology in practice:_
  You can simply start by writing a /function literal/ WITHOUT the /argument
  type/, and if the compiler gets CONFUSED, add in the type.
    Over time you'll get a feel for which situations the compiler can and cannot
  puzzle out.

** DONE 8.5 Placeholder syntax - 177
CLOSED: [2025-04-28 Mon 23:21]
** DONE 8.6 Partially applied functions - 178 - =REVIEW=
CLOSED: [2025-04-30 Wed 21:53]
- In Scala, when you _invoke a function,_ _passing in any needed arguments,_
  you *apply* that function *to* the arguments.

- partially applied function :: an expression in which you don't supply all of
  the arguments needed by the function.
  * Syntax:
    Use placeholder syntax where each _underscore_ is used to
    *forward* a /parameter/ *to* a /method/.

- =from Jian=
  Later you'll learn another concept that is similar in name with this
  /partially applied function/ -- /partial function/.
  * *THEY ARE TOTALLY DIFFERENT!!!*

- Explain the *mechanism* use the example below:
  #+begin_src scala
    def sum(a: Int, b: Int, c: Int) = a + b + c

    val a = sum(_, _, _) // `a` has type (Int, Int, Int) => Int
    a(1, 2, 3) // 6
  #+end_src

  * The _variable named_ ~a~ refers to a /function value object/.

  * This /function value/ is an /instance of a class/ *generated automatically*
    by the Scala compiler from ~sum(_, _, _)~, the /partially applied function
    expression/.

    The /class/ *generated by* the compiler has an ~apply~ method that takes
    three arguments -- footnote 3: The GENERATED /class/ extends ~trait
    Function3~, which declares a three-arg ~apply~ method.

  * The Scala compiler *translates* the expression ~a(1, 2, 3)~ *into* an
    invocation of the /function value/'s ~apply~ method, passing in the three
    arguments 1, 2, and 3.

    Thus, ~a(1, 2, 3)~ is a short form for: ~a.apply(1, 2, 3)~.

- =FIXME=
  Another way to think about this kind of expression, in which an underscore is
  used to represent an entire parameter list, is as a way to transform a def
  into a function value.

  "an underscore is used to represent an entire parameter list" triggers a
  warning in Scala 3. this book is about Scala 3, and we should remove this
  sentence, and mention
  1. /local functions/ and /methods/ are not first-class citizens in Scala.
  2. /function value/ is first-class citizens in Scala.
  3. /automatic eta expansion/ exists in Scala 3, and Scala 3 blurs the line by
     auto-converting /local functions/ and /methods/ to /function values/ in
     most cases.

  =from Jian= Convert to first class citizens.
  Although you can't assign a method or nested function to a variable, or pass
  it as an argument to another function (because of /automatic eta expansion/ in
  Scala 3, syntactically, you actually can do this), you can do these things if
  you wrap the method or nested function in a /function value/.

- eta expansion :: A process that Create a /function value/ with the _SAME
  signature_ as the /method/ that wraps the /method call/.

** DONE 8.7 Closures - 181 - =REVIEW=
CLOSED: [2025-04-30 Wed 13:59]
- _SO FAR_ in this chapter,
  all the examples of /function literals/ have referred *only* to _passed
  parameters_.

  You can, however, refer to variables defined elsewhere:
  #+begin_src scala
    (x: Int) => x + more  // how much more
  #+end_src
  * free variable :: a variable show up in a /function literal/ that is not
    passed through as the /parameter/ of this /function literal/ -- the
    /function literal/ doesn't itself give a  meaning to it.
    + In the above example, ~more~ is a /free variable/.

  * bound variable :: a variable that does have a meaning in the context of the
    function -- it is defined as one of the funtion's parameter.
    + In the above example, ~x~ is a /bound variable/.

- The /function value (the object)/ that's _created at runtime_ from this
  /function literal/ is called a /closure/.
  * *ORIGIN*:
    The name arises from the act of *"closing"* the /function literal/ by
    *"capturing"* _the bindings of its /free variables/._

  * closed term :: A /function literal/ with *no free variables*,
    such as ~(x: Int) => x + 1~.
    + term :: a bit of source code.

    + Thus a /function value/ created at runtime from this /function literal/ is
      *NOT* a /closure/ _in the STRICTEST sense,_
      BECAUSE ~(x: Int) => x + 1~ is *ALREADY CLOSED as written*.

    + open term :: ANY /function literal/ with /free variables/, such as
      ~(x: Int) => x + more~.

      - Therefore, ANY /function value/ created at runtime from
        ~(x: Int) => x + more~ will, by definition, require that a /binding/ for
        its /free variable/, ~more~, *be captured*.

        The resulting /function value/, which will contain _a reference to the
        CAPTURED ~more~ variable_, is called a /closure/
        BECAUSE
        the /function value/ is the end product of the act of *closing the /open
        term/,* ~(x: Int) => x + more~.

- Intuitively, /Scala's closures/ capture *variables themselves*, *NOT the value*
  to which /variables/ refer.
  * footnote 4:
    By contrast, /Java's lambdas/
    *do not allow* you to access /local variables/ in surrounding scopes
    *UNLESS* they are ~final~ or /effectively final/,
    so there is *NO difference* between _capturing a variable_ and _capturing its
    currently held value_.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  If a /closure/ is created through a function like
  #+begin_src scala
    def makeIncreaser(more: Int) = (x: Int) => x + more
  #+end_src
  as we know after the a call to ~makeIncreaser~ is done, the argument passed to it
  should be ready for GC, if no /capturing/.
  * Q :: What will happen when /capturing/ exist -- /closure/ creation exist?
  * A :: It makes no difference that the ~more~ in this case is a /parameter/ to a
         /method call/ that _has already returned._

         The Scala compiler _REARRANGES things_ in cases like these
         so that the /captured parameter/ *lives out on the /heap/,*
         _INSTEAD of the /stack/,_ and thus can *outlive* the /method call/ that
         created it.

         This *rearrangement* is _all taken care of AUTOMATICALLY,_ so you don't
         have to worry about it. *Capture any variable* you like: ~val~, ~var~,
         or ~parameter~.

** DONE 8.8 Special function call forms - 183
CLOSED: [2025-04-30 Wed 11:03]
*** Repeated parameters - 183
- Variable length argument lists that has repeated parameters:
  * syntax illustrated by example:
    #+begin_src scala
      def echo(args: String*) =
        for arg <- args do println(arg)
    #+end_src

- vararg splice :: the syntax of passing a sequence of values as /repeated
  parameters/.
  #+begin_src scala
    val seq = Seq("What's", "up", "doc?")
    echo(seq*)
  #+end_src

*** Named parameters - 185
- It is also possible to *MIX* /positional arguments/ and /named arguments/.
  In that case, the /positional arguments/ *come first*.

- /Named arguments/ are most frequently used _in combination with_ /default
  parameter values/.
  =NEXT section=

*** Default parameters values - 185
- =from Jian=
  With /default parameters values/, we can save some code for the definitions of
  *explicit* /auxiliary constructor/ -- though this is not a noraml function
  call, but instance construction from /class(s)/.
  =TODO=
  I guess the compiler will use /default parameters values/ and *implicitly*
  generate /auxiliary constructor(s)/ for us. =TODO= Verify this!!!

** DONE 8.9 "SAM" types - 186
CLOSED: [2025-04-30 Wed 11:10]
- In Java, a /lambda expression/ can be used _ANYWHERE_ an /instance/ of a
  /class/ or /interface/ that contains just a /single abstract method (SAM)/ is
  required.

- Scala enables a /function literal/ to be used in this case, because as in Java,
  Scala will _ALLOW_ a /function type/ to be used where _an /instance of a class or
  trait/ declaring a /single abstract method (SAM)/ is required._

  *This will work with ANY /SAM/.*

  #+begin_src scala
    trait Increaser:
      def increase(i: Int): Int

    def increaseOne(increaser: Increaser): Int =
      increaser.increase(1)

    increaseOne(
      new Increaser:
          def increase(i: Int): Int = i + 7
    )
  #+end_src

- In Scala versions 2.12 and greater, however, you could alternatively just use a
  function literal, because ~Increaser~ is a /SAM type/:
  #+begin_src scala
    increaseOne(i => i + 7) // Scala
  #+end_src

** DONE 8.10 Tail recursion - 188
CLOSED: [2025-04-30 Wed 11:30]
- tail recursive :: a function call themselves as their last action.
  * The Scala compiler detects /tail recursion/ and
    *replaces* it *with* a jump back to the beginning of the function,
    AFTER updating the function parameters with the new values.

- If the solution is /tail recursive/,
  *there won't be any runtime overhead to be paid.*

*** Tracing tail recursive functions - 189
A tail-recursive function will *NOT build a new* /stack frame/ for each call;
all calls will execute in a *single* frame.

- Add ~@tailrec~ to the function you think it should be a /tail recursion/, if
  the optimization _cannot be performed_, you will then get a _compiler error_
  that indicates why the method is *NOT* /tail recursive/.

- *Tail call optimization*

*** Limits of tail recursion - 190 - =IMPORTANT=
The use of /tail recursion/ in Scala is fairly limited because the JVM
instruction set makes implementing more advanced forms of tail recursion
very difficult.

- Scala can *only* optimize *directly* recusive calls back to the same function
  making the call.

- *CANNOT OPTIMIZE*:
  If the recursion is *indirect*, Scala *can't* apply /tail-call optimization/:
  * As in the following example of two /mutually recursive functions/, _no
    optimization_ is possible:
    #+begin_src scala
      def isEven(x: Int): Boolean =
        if x == 0 then true else isOdd(x - 1)

      def isOdd(x: Int): Boolean =
        if x == 0 then false else isEven(x - 1)
    #+end_src

  * You also *won't* get a /tail-call optimization/ if the final call goes to a
    /function value/. Consider for instance the following recursive code:
    #+begin_src scala
      val funValue = nestedFun
      def nestedFun(x: Int): Unit =
        if x != 0 then
          println(x)
          funValue(x 1)
    #+end_src
    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    /Tail-call optimization/ is limited to situations where a method or nested
    function calls itself *directly* as its last operation,
    *without* going through a /function value/ or /some other intermediary/.

- =FIXME=
  This section mix the usage of terms "tail recursion optimization" and "tail
  call optimization". I think they have differences, and should be clarified!

- =FIXME=
  Remove
  "(If you don’t fully understand tail recursion yet, see Section 8.10)."
  because this section is already 8.10!!!

** DONE 8.11 Conclusion - 191
CLOSED: [2025-04-30 Wed 11:35]

* DONE 9 Control Abstraction - 192
CLOSED: [2025-05-01 Thu 00:12]
- In this chapter, we'll show you
  HOW to apply /function values/ to *create* _new control abstractions_.

- Along the way, you'll also learn about
  * /currying/ and
  * /by-name parameters/

** DONE 9.1 Reducing code duplication - 192
CLOSED: [2025-04-30 Wed 22:25]
- Every function is separated into
  * a COMMON part:
    same in every invocation of a function -- /the body of the function/.

  * a NON-COMMON part:
    may vary from one function invocation to the next -- this is supplied via
    /arguments/.

- =IMPORTANT=
  When you use a /function value/ as an /argument/,
  the _non-common part_ of the algorithm is *itself some OTHER algorithm!*

- higher-order function ::
  * a function that take functions as parameters or
  * a function that can return a function as its result.
  give you extra opportunities to _condense_ and _simplify_ code.

- =IMPORTANT=
  One benefit of /higher-order functions/ is they ENABLE you to *create*
  /control abstractions/ that allow you to _REDUCE code duplication_.

- Example

** DONE 9.2 Simplifying client code - 196
CLOSED: [2025-04-30 Wed 22:35]
Another important use of /higher-order functions/ is to _put them in an API itself_
TO *make _client code_ MORE CONCISE.*

The ~exists~ method from collections.

- With it, implement functions like ~containsNeg~ and ~containsOdd~ can
  eliminate boilerplate code.

** DONE 9.3 Currying - 198
CLOSED: [2025-04-30 Wed 22:38]
With /currying/, /control abstractions/ feel more like language extensions.

** DONE 9.4 Writing new control structures - 199
CLOSED: [2025-05-01 Thu 00:06]
In languages with /first-class functions/, you can effectively MAKE _new control
structures_ even though the syntax of the language is fixed -- all you need to do
is _CREATE /methods/ that TAKE FUNCTIONS AS ARGUMENTs._

- Any time you find a control pattern repeated in multiple parts of your code,
  you should think about implementing it as a new control structure.

- Load pattern ::
  Opens a resource and "loans" it to a function. When the function completes, it
  signals that it no longer needs the "borrowed" resource. The resource is then
  closed in a ~finally~ block, to ensure it is indeed closed, _REGARDLESS OF_
  whether the function completes by returning normally or throwing an exception.
  * =from Jian=
    The ~Using~ from the standard library when Scala version is 2.13+.

  * Example:
    #+begin_src scala
      def withPrintWriter(file: File, op: PrintWriter => Unit) =
        val writer = new PrintWriter(file)
        try op(writer)
        finally writer.close()

      // Given such a method, you can use it like this:

      withPrintWriter(
        new File("date.txt"),
        writer => writer.println(new java.util.Date)
      )
    #+end_src

- One way in which you can make the client code _look a bit more like a built-in
  control structure_ is to use _curly braces_ instead of parentheses to
  surround the argument list.
  #+begin_src scala
    def withPrintWriter(file: File)(op: PrintWriter => Unit) =
      val writer = new PrintWriter(file)
      try op(writer)
      finally writer.close()

    val file = new File("date.txt")
    withPrintWriter(file) { writer =>
      writer.println(new java.util.Date)
    }
  #+end_src

  This _curly braces technique_ will work, however, *only if* you're passing in
  *ONE* argument.

** DONE 9.5 By-name parameters - 202
CLOSED: [2025-05-01 Thu 00:12]
- Q :: what if you want to implement something more like ~if~ or ~while~, where
  there is no value to pass into the body?

- A :: To help with such situations, Scala provides /by-name parameters/.

** DONE 9.6 Conclusion - 204
CLOSED: [2025-05-01 Thu 00:12]

* DONE 10 Composition and Inheritance - 206
CLOSED: [2025-05-02 Fri 21:05]
- Chapter 6 introduced some BASIC object-oriented aspects of Scala.
  This chapter
  * PICKS UP where Chapter 6 left off and
  * DIVES INTO _Scala's support for object-oriented programming in much greater
    detail._

- We'll _COMPARE_ two fundamental relationships between classes:
  /composition/ and /inheritance/.

  * /Composition/ means one class *holds* a reference to another, using the
    referenced class to help it fulfill its mission.

  * /Inheritance/ is _the superclass/subclass relationship._

- In addition to these topics, we'll discuss
  * /abstract classes/,
  * /parameterless methods/,
  * extending /classes/,
  * overriding /methods/ and /fields/,
  * /parametric field/s,
  * invoking /superclass constructors/,
  * /polymorphism/ and /dynamic binding/,
  * ~final~ /members/ and /classes/, and
  * /factory objects/ and /factory methods/.

** DONE 10.1 A two-dimensional layout library - 206
CLOSED: [2025-05-01 Thu 19:07]
Create a library for *building* and *rendering* /two-dimensional layout
elements/.

- Requirements:
  * Each element will represent a _rectangle_ _filled with text_.
    #+begin_src scala
      elem(s: String): Element
    #+end_src

  * Factory methods named ~elem~ that _CONSTRUCT new elements FROM passed data._
    #+begin_src scala
      val column1 = elem("hello") above elem("***")
      val column2 = elem("***") above elem("world")
      column1 beside column2

      // hello ***
      //  *** world
    #+end_src

- Layout elements are a _GOOD EXAMPLE_ of a system in which objects can be
  constructed from simple parts with the aid of /composing operators/.

- In this chapter, we'll define /classes/ that ENABLE element objects to be
  CONSTRUCTED FROM
  * vectors,
  * lines, and
  * rectangles.

  These basic element objects will be the simple parts.
  We'll also define /composing operators/ ~above~ and ~beside~.

  =IMPORTANT= /combinators/
  Such /composing operators/ are also often called /combinators/ because they
  combine elements of some domain into new elements.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  *Thinking in terms of /combinators/ is generally a good way to approach library
  design*: it pays to think about the fundamental ways to construct objects in an
  application domain.

  * What are the simple objects?
  * In what ways can more interesting objects be constructed out of simpler ones?
  * How do combinators hang together?
  * What are the most general combinations?
  * Do they satisfy any interesting laws?

  If you have good answers to these questions, your library design is on track.

** DONE 10.2 Abstract classes - 207
CLOSED: [2025-05-01 Thu 23:22]
- Layout elements interface:
  #+begin_src scala
    abstract class Element:
      def contents: Vector[String]
  #+end_src

- Later in this chapter, you'll see how to create /subclasses/ of /(abstract)
  class/ ~Element~.

- /declaration/ vs /definition/

- =from Jian=
  It has no problem if replacing ~abstract class~ with ~trait~.
  The /abstract class/ is just a legacy thing from Java.

** DONE 10.3 Defining parameterless methods - 208 - =REVIEW=
CLOSED: [2025-05-01 Thu 23:50]
#+begin_src scala
  abstract class Element:
    def contents: Vector[String]
    def height: Int = contents.length
    def width: Int = if height == 0 then 0 else contents(0).length
#+end_src

- /uniform access principle/

- Use ~val~ instead of ~def~:
  #+begin_src scala
  abstract class Element:
    def contents: Vector[String]
    val height: Int = contents.length
    val width: Int = if height == 0 then 0 else contents(0).length
  #+end_src

- The two pairs of definitions are *completely equivalent*
  _FROM a client's point of view._

- For parameterless function, add empty parameter list only when /side effect/
  exists.

- =IMPORTANT=
  * Scala 3 is *very liberal*
    WHEN it comes to mixing parameterless and empty-paren methods defined in Java
    or Scala 2.

  * Scala 3 is *very strict* for code from Scala 3!
    The compiler requires that you invoke
    + /parameterless methods/ defined in Scala 3 _without empty parentheses_ and
    + /empty-parens methods/ defined in Scala 3 _with empty parentheses_.

** DONE 10.4 Extending classes - 211
CLOSED: [2025-05-02 Fri 00:05]
One ~Element~ implementation:
#+begin_src scala
  class VectorElement(conts: Vector[String]) extends Element:
    def contents: Vector[String] = conts
#+end_src
- footnote 3:
  _One flaw_ with this design is that we aren't currently ensuring that every
  ~String~ element of the contents vector has the same length.

  This could be solved by
  1. CHECKING the /precondition/ in the /primary constructor/ and
  2. THROWING an /exception/ if it is VIOLATED.

- If you leave out an ~extends~ clause, the Scala compiler implicitly assumes
  your /class/ ~extends~ from ~scala.AnyRef~, which on the Java platform is the
  same as ~class java.lang.Object~.

- Inheritance :: all members of the /superclass/ are also members of the
  /subclass/, with _TWO exceptions_:
  1. /private members/ of the /superclass/ are *NOT inherited* in a /subclass/.
  2. a member of a /superclass/ is *not inherited* if a member with the same
     name and parameters is *already implemented* in the /subclass/.

     * =IMPORTANT=
       (In general) In that case we say the member of the /subclass/ *overrides*
       the member of the /superclass/.

       + If the member in the /subclass/ is _concrete_ and the member of the
         /superclass/ is _abstract_,

         we ALSO say that the _concrete_ member *implements* the _abstract_ one.

- The /composition relationship/ that exists between ~VectorElement~ and
  ~Vector[String]~.

  This relationship is called /composition/
  BECAUSE
  class ~VectorElement~ is "composed of" a ~Vector[String]~, in that the Scala
  compiler will place into the binary class it generates for ~VectorElement~ a
  /field/ that _HOLDS a /reference/ to the passed ~conts~ vector._

** DONE 10.5 Overriding methods and fields - 213
CLOSED: [2025-05-02 Fri 00:23]
- The /uniform access principle/ is just
  * _one aspect_ where Scala treats /fields/ and /methods/ *more uniformly than
    Java.*
  * _Another difference_ is that in Scala, /fields/ and /methods/ belong to the
    *SAME* /namespace/. This makes it possible for a /field/ to *override* a
    /parameterless method/.

- On the other hand, in Scala
  it is *FORBIDDEN* to define a /field/ and /method/ with the *SAME name* in the
  *SAME class*, whereas this is allowed in Java.
  =from Jian=
  =TODO=
  How to use a Java class that contains same name /method(s)/ and /field(s)/?

- Generally, Scala has just *two* /namespaces/ for definitions in place of
  Java's *four*.
  * Java's *four* /namespaces/ are
    + fields
    + methods
    + types
    + packages

  * By contrast,
    Scala's *two* /namespaces/ are:
    + values (fields, methods, packages, and singleton objects)
    + types (class and trait names)

- =IMPORTANT=
  The _REASON_ Scala places /fields/ and /methods/ into the *SAME* /namespace/ is
  precisely so you can
  /override/ a /parameterless method/ with a ~val~, something you can't do with Java.
  * footnote 6:
    The reason that /packages/ share the *SAME* /namespace/ as /fields/ and
    /methods/ in Scala is to *ENABLE you to* import
    + /packages/ (in addition to just the names of types) and
    + the /fields/ and /methods/ of /singleton objects/.

    This is also something you can't do in Java.
    =NEXT= It will be described in Section 12.3.

- footnote 5:
  =IMPORTANT=
  For more perspective on the difference between /subclass/ and /subtype/, see the
  glossary entry for /subtype/.

** DONE 10.6 Defining parametric fields - 214
CLOSED: [2025-05-02 Fri 00:30]
In Scala, you cana combine /parameter/ and the /field/ in a single /parametric
field/ defintion:
#+begin_src scala
  // Extends Element shown in Listing 10.2
  class VectorElement(
    val contents: Vector[String]
  ) extends Element
#+end_src

- You can use ~val~ or ~var~. Pick the one good for the design requirement of
  your use cases.

- It is possible to add /modifiers/, such as ~private~, ~protected~, or
  ~override~ to these /parametric fields/, just AS you can for any other /class
  member/.

- Example:
  #+begin_src scala
    class Cat:
      val dangerous = false

    class Tiger(
      override val dangerous: Boolean,
      private var age: Int
    ) extends Cat
  #+end_src

** DONE 10.7 Invoking superclass constructors - 216
CLOSED: [2025-05-02 Fri 00:34]
#+begin_src scala
  class LineElement(s: String) extends VectorElement(Vector(s)):
    override def width = s.length
    override def height = 1
#+end_src

** DONE 10.8 Using ~override~ modifiers - 217
CLOSED: [2025-05-02 Fri 21:05]
Not like Java's ~@Override~, Scala's ~override~ is required.

- "fragile base class" problem:
  the problem is that if you add new members to /base classes/ (which we usually
  call /superclasses/) in a class hierarchy, _you RISK *breaking* client code._
  * Scala _CANNOT COMPLETELY solve_ the /fragile base class problem/,
    BUT it _IMPROVES_ on the situation compared to Java.

** DONE 10.9 Polymorphism and dynamic binding - 219
CLOSED: [2025-05-02 Fri 17:30]
- polymorphism :: it means "many shapes" or "many forms".
  * For example, ~Element~ has many forms.
    + footnote 9:
      This kind of /polymorphism/ is called /subtyping polymorphism/.
      Other kinds of /polymorphism/ in Scala are discussed in later chapters,
      - =TODO= /universal polymorphism/ in Chapter 18 and
      - =TODO= /ad hoc polymorphism/ in Chapters 21 and 23.

- Example:
  #+begin_src scala
    abstract class Element:
      def demo = "Element's implementation invoked"

    class VectorElement extends Element:
      override def demo = "VectorElement's implementation invoked"

    class LineElement extends VectorElement:
      override def demo = "LineElement's implementation invoked"

    // UniformElement inherits Element's demo
    class UniformElement extends Element

    def invokeDemo(e: Element) = e.demo

    invokeDemo(new VectorElement)  // VectorElement's implementation invoked
    invokeDemo(new LineElement)    // LineElement's implementation invoked
    invokeDemo(new UniformElement) // Element's implementation invoked
  #+end_src

- /Method invocations/ on /variables/ and /expressions/ are *dynamically bound*.

- This means that the actualmethod implementation invoked is determined at run
  time based on the class of the object, not the type of the variable or
  expression.

** DONE 10.10 Declaring ~final~ members - 221
CLOSED: [2025-05-02 Fri 17:33]
Add ~final~ on /members/ or /class (as a whole)/, and then they *can't be
overridden*.

** DONE 10.11 Using composition and inheritance - 222
CLOSED: [2025-05-02 Fri 17:50]
- =IMPORTANT=
  /Composition/ and /inheritance/ are two ways to
  _DEFINE_ a new /class/ _IN TERMS OF_ another existing /class/.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  If what you're after is primarily *code reuse*,
  you should in general *prefer /composition/ to /inheritance/.*

  Only /inheritance/ suffers from the fragile base class problem,
  in which you can inadvertently *break /subclasses/ by changing a /superclass/.*

- inheritance relationship: is-a relationship

- If you ask these questions about the /inheritance relationships/ shown
  in Figure 10.3,
  * Q :: Do any of the relationships seem suspicious?
  * Q :: In particular, does it seem obvious to you that a ~LineElement~ is-a
    ~VectorElement~?
  * Q :: Do you think clients would ever need to use a ~LineElement~ as a
    ~VectorElement~?

- A :: Revised ~LineElement~ -- inherit from ~Element~ instead of
  ~VectorElement~:
  #+begin_src scala
    class LineElement(s: String) extends Element:
      val contents = Vector(s)
      override def width = s.length
      override def height = 1
  #+end_src

  * In the previous version, ~LineElement~ had an /inheritance relationship/
    with ~VectorElement~, from which it inherited contents.

    It now has a /composition relationship/ with ~Vector~:
    it holds a /reference/ to a _vector of strings_ from its own ~contents~ field.

** DONE 10.12 Implementing ~above~, ~beside~, and ~toString~ - 224
CLOSED: [2025-05-02 Fri 18:02]
#+begin_src scala
  abstract class Element:
    def contents: Vector[String]

    def width: Int =
      if height == 0 then 0 else contents(0).length

    def height: Int = contents.length

    // Not a comprehensive solution -- not consider the case of different width.
    // Will be refined in 10.14
    def above(that: Element): Element =
      VectorElement(this.contents ++ that.contents)

    // Not a comprehensive solution -- not consider the case of different height.
    // Will be refined in 10.14
    def beside(that: Element): Element =
      VectorElement(
        for (line1, line2) <- this.contents.zip(that.contents)
        yield line1 + line2
      )
    override def toString = contents.mkString("\n")
  end Element
#+end_src

** DONE 10.13 Defining a factory object - 226
CLOSED: [2025-05-02 Fri 19:30]
You now have a hierarchy of classes for layout elements.
This hierarchy could be presented to your clients “as is,”
but you might also choose to
_HIDE the hierarchy BEHIND a /factory object/._

- Overview:
  A /factory object/ contains /methods/ that construct other objects.
  _Clients would then use these /factory methods/ to construct objects,_
  RATHER THAN constructing the objects directly via their constructors.

  * Advantage of this approach:
    + _object creation_ can be _CENTRALIZED_ and
    + _THE DETAILS_ of how objects are represented with classes _CAN BE HIDDEN_.

  * This hiding will both
    + make your library simpler for clients to _UNDERSTAND_,
      because less detail is exposed, and
    + provide you with _more opportunities to change your library's
      implementation later_ *without breaking* client code.

- Code:
  #+begin_src scala
    object Element:
      def elem(contents: Vector[String]): Element =
        VectorElement(contents)

      def elem(chr: Char, width: Int, height: Int): Element =
        UniformElement(chr, width, height)

      def elem(line: String): Element =
        LineElement(line)
  #+end_src
  Listing 10.10 · A factory object with factory methods.

  #+begin_src scala
    abstract class Element:
      import Element.elem

      def contents: Vector[String]

      def width: Int =
        if height == 0 then 0 else contents(0).length

      def height: Int = contents.length

      def above(that: Element): Element =
        elem(this.contents ++ that.contents)

      def beside(that: Element): Element =
        elem(for (line1, line2) <- this.contents.zip(that.contents)
             yield line1 + line2)

      override def toString = contents.mkString("\n")
    end Element
  #+end_src
  Listing 10.11 · Class Element refactored to use factory methods.

  - In Scala, you can define /classes/ and /singleton objects/ *inside* other
    /classes/ and /singleton objects/.

  - In addition, given the /factory methods/, the /subclasses/, ~VectorElement~,
    ~LineElement~, and ~UniformElement~, *could now be PRIVATE* because they no
    longer need to be accessed directly by clients.

    One way to make the ~Element~ /subclasses/ ~private~ is to place them inside the
    ~Element~ /singleton object/ and declare them ~private~ there.
    #+begin_src scala
      object Element:
        private class VectorElement(
          val contents: Vector[String]
        ) extends Element

        private class LineElement(s: String) extends Element:
          val contents = Vector(s)
          override def width = s.length
          override def height = 1

        private class UniformElement(
          ch: Char,
          override val width: Int,
          override val height: Int
        ) extends Element:
          private val line = ch.toString * width
          def contents = Vector.fill(height)(line)
          def elem(contents: Vector[String]): Element =
            VectorElement(contents)
          def elem(chr: Char, width: Int, height: Int): Element =
            UniformElement(chr, width, height)
          def elem(line: String): Element =
            LineElement(line)
      end Element
    #+end_src
    Listing 10.12 · Hiding implementation with private classes.

** DONE 10.14 Heighten and widen - 228
CLOSED: [2025-05-02 Fri 19:38]
- One last enhancement. Solve:
  The version of Element shown in Listing 10.11 is not quite sufficient because
  it does _NOT allow_ clients to
  * place elements of different widths on top of each other, or
  * place elements of different heights beside each other.

- Solution:
  Add two methods ~widen~ and ~heighten~.

** DONE 10.15 Putting it all together - 230 - =TODO: Understand `Spiral`=
CLOSED: [2025-05-02 Fri 20:57]
Listing 10.13 · Element with widen and heighten methods.
#+begin_src scala
  import Element.elem

  abstract class Element:
    def contents: Vector[String]
    def width: Int =
      if height == 0 then 0 else contents(0).length
    def height: Int = contents.length
    def above(that: Element): Element =
      val this1 = this.widen(that.width)
      val that1 = that.widen(this.width)
      elem(this1.contents ++ that1.contents)

    def beside(that: Element): Element =
      val this1 = this.heighten(that.height)
      val that1 = that.heighten(this.height)
      elem(
        for (line1, line2) <- this1.contents.zip(that1.contents)
        yield line1 + line2
      )

    def widen(w: Int): Element =
      if w <= width then this
      else
        val left = elem(' ', (w - width) / 2, height)
        val right = elem(' ', w - width - left.width, height)
        left beside this beside right

    def heighten(h: Int): Element =
      if h <= height then this
      else
        val top = elem(' ', width, (h - height) / 2)
        val bot = elem(' ', width, h - height - top.height)
        top above this above bot

    override def toString = contents.mkString("\n")
  end Element
#+end_src

- Create ~Spiral~ with the created library:
  #+begin_src scala
    import Element.elem

    object Spiral:
      val space = elem(" ")
      val corner = elem("+")
      def spiral(nEdges: Int, direction: Int): Element =
        if nEdges == 1 then
          elem("+")
        else
          val sp = spiral(nEdges - 1, (direction + 3) % 4)
          def verticalBar = elem('|', 1, sp.height)
          def horizontalBar = elem('-', sp.width, 1)
          if direction == 0 then
            (corner beside horizontalBar) above (sp beside space)
          else if direction == 1 then
            (sp above space) beside (corner above verticalBar)
          else if direction == 2 then
            (space beside sp) above (horizontalBar beside corner)
          else
            (verticalBar above corner) beside (space above sp)

      def main(args: Array[String]) =
        val nSides = args(0).toInt
        println(spiral(nSides, 0))
    end Spiral
  #+end_src

** DONE 10.16 Conclusion - 233
CLOSED: [2025-05-02 Fri 20:59]
In this section, you saw more concepts related to object-oriented programming in
Scala.

- Among others, you encountered
  * /abstract classes/,
  * /inheritance/ and /subtyping/,
  * /class hierarchies/,
  * /parametric fields/, and
  * /method overriding/.

- You should have developed a feel for constructing a non-trivial class
  hierarchy in Scala.

- We'll work with the layout library again in Chapter 25.

* DONE 11 Traits - 234
CLOSED: [2025-05-06 Tue 01:27]
- /Traits/ are a _fundamental unit_ of code *reuse* in Scala.

- A /trait/ encapsulates
  * /method/ declarations/definitions (=FIXME?=) and
  * /field/  declarations/definitions (=FIXME?=),
  which can then be reused by *mixing* them *into* /classes/.

- UNLIKE /class inheritance/, in which each /class/ must inherit from just one
  /superclass/,

  a /class/ can mix in *ANY NUMBER* of /traits/.

  * =from Jian=
    =???=
    Should we use only /traits/ and /classes/, and consider /abstract classes/
    as a legacy components and only use it when required to interact with /Java
    abstract classes/.

- This chapter shows you
  * HOW traits work.
  * TWO of the most common ways they are useful: =NEXT=
    + widening thin interfaces to rich ones;
    + defining stackable modifications.

  * *how to use* the ~Ordered~ /trait/.
  * *compares* /traits/ to the /multiple inheritance/ of other languages.

** DONE 11.1 How traits work - 234
CLOSED: [2025-05-05 Mon 20:13]
- A /trait definition/ looks just LIKE a /class definition/
  EXCEPT that it uses the keyword ~trait~.
  * Listing 11.1 · The definition of trait Philosophical.
    #+begin_src scala
      trait Philosophical:
        def philosophize = "I consume memory, therefore I am!"
    #+end_src

- If a /trait/ doesn't declare a /superclass/, so like a /class/,
  it has the _default superclass_ of ~AnyRef~.

- Once a /trait/ is defined,
  it can be *mixed in* to a /class/ using
  * either the keyword ~extends~
  * or the keyword ~with~,
  * or a comma.

- Scala programmers *“mix in”* /traits/ _RATHER THAN_ *inherit* from them,
  BECAUSE mixing in a /trait/ has *IMPORTANT DIFFERENCES* from the ~multiple
  inheritance~ found in many other languages. This issue is discussed in
  Section 11.4.
  =TODO=
  =TODO=
  =TODO=
  =TODO=
  =TODO=

- At this point you might philosophize that
  /traits/ are *like* /Java interfaces/ with /default methods/,
  *BUT* they can actually do much more -- /traits/ can, for example,
  _declare fields_ and _maintain state_.

  * =IMPORTANT=
    You can
    _do anything in a /trait definition/ that you can do in a /class
    definition/,_
    and
    _the syntax, except the keyword, looks *exactly the same*._

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  * The *KEY DIFFERENCE* between /classes/ and /traits/:
    + whereas in /classes/, ~super~ calls are _statically bound_,
    + in /traits/, they are _dynamically bound_.

  * For example,
    + if you write ~super.toString~ in a /class/, you know exactly which
      _method implementation_ will be invoked.

    + When you write the same thing in a /trait/,
      however, the method implementation to invoke for the ~super~ call
      _is *undefined* WHEN you define the /trait/._

      RATHER, *the implementation to invoke will be DETERMINED ANEW EACH TIME
      the /trait/ is mixed into a /CONCRETE class/.*

  * =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    This curious behavior of ~super~ is key to allowing /traits/ to work as
    /stackable modifications/, which will be described in _Section 11.3_.
    =TODO=
    =TODO=
    =TODO=
    The rules for resolving ~super~ calls will be given in _Section 11.4_.

** DONE 11.2 Thin versus rich interfaces - 237
CLOSED: [2025-05-05 Mon 20:31]
- One major use of /traits/:
  AUTOMATICALLY add /methods/ to a /class/ in terms of /methods/ the /class/
  *ALREADY has* -- that is, /traits/ can enrich a *THIN interface*, making it
  into a *RICH interface*.

- *Thin* versus *rich* /interfaces/ represents a commonly faced *trade-off* in
  /object-oriented design/.

  The trade-off is BETWEEN _the implementers_ AND _the clients of an interface_.

  * A /rich interface/ has many /methods/, which make it *CONVENIENT for the
    caller.*

    _Clients_ can pick a method that exactly matches the functionality they
    need.

    + =from Jian=
      _implementers_ need to more work for creating this /rich interface/.

  * A /thin interface/, on the other hand, has *fewer* /methods/, and thus
    *is easier on the implementers.*

    + _Clients_ calling into a /thin interface/, however, have to write more
      code.

      Given the _smaller selection of methods to call,_
      they may have to choose a less than perfect match for their needs and
      write extra code to use it.

- Adding a _CONCRETE method_ to a /trait/ tilts the _thin-rich trade-off_
  heavily towards /rich interfaces/, because it is is a _one-time effort_.

- To ENRICH an /interface/ using /traits/,
  1. simply define a /trait/ with a small number of /abstract methods/ -- the
     thin part of the trait's interface -- and

  2. a potentially large number of /concrete methods/, all implemented in terms
     of the /abstract methods/.

  3. Then you can
     1) _MIX_ the /enrichment trait/ _INTO_ a /class/,
     2) implement the thin portion of the interface, and
     *END UP WITH* a /class/ that has all of the rich interface available.

- A good example:
  ~Ordered~
  All other methods, ~>~, ~<~, ~<=~, and ~>~, in it use a single ~compare~
  method.

  This, trait ~Ordered~ allows you to enrich a class with comparison methods by
  implementing only one method, ~compare~.

  * Example:
    #+begin_src scala
      class Rational(n: Int, d: Int) extends Ordered[Rational]:
        // ...
        def compare(that: Rational) =
          (this.numer * that.denom) - (that.numer * this.denom)
    #+end_src

- _BEWARE_:
  the ~Ordered~ /trait/ does *NOT* define ~equals~ for you,
  because it is unable to do so.

  The problem is that implementing ~equals~ in terms of ~compare~
  _REQUIRES_ checking the type of the passed object, and

  * BECAUSE of /type erasure/,
    ~Ordered~ itself CANNOT do this test.

  Thus, you need to define ~equals~ yourself, even if you inherit ~Ordered~.
  =TODO=
  =TODO=
  =TODO=
  You can find out how to go about this in _Advanced Programming in Scala._

** DONE 11.3 Traits as stackable modifications - 239 =REVIEW=
CLOSED: [2025-05-06 Tue 01:27]
One major use of /traits/:
_TURNING_ a /THIN interface/
_INTO_ a /RICH interface/.

Now turn to a second major use of /traits/:
PROVIDING /stackable modifications/ to /classes/.

- /Traits/ let you _MODIFY_ the /methods/ of a /class/, and they do so in a way
  that allows you to *stack those modifications with each other (order
  matters)*.

- As an example,
  _consider stacking modifications to a queue of integers_.

  * Two basic operations to the queue (FIFO):
    + ~put~
    + ~get~

  * Code:
    #+BEGIN_SRC scala
      abstract class IntQueue {
        def get(): Int
        def put(x: Int)
      }

      import scala.collection.mutable

      class BasicIntQueue extends IntQueue {
        private val buf = new mutable.ArrayBuffer[Int]
        def get() = buf.remove(0)
        def put(x: Int) = { buf += x }
      }
    #+END_SRC

  * Given a /class/ that implements such a queue, you could define /traits/ to
    perform modifications such as these:
    + ~Doubling~: double all integers that are put in the queue
    + ~Incrementing~: increment all integers that are put in the queue
    + ~Filtering~: filter out negative integers from a queue

    #+BEGIN_SRC scala
      trait Doubling extends IntQueue {
        abstract override def put(x: Int) = { super.put(2 * x) }
      }

      trait Incrementing extends IntQueue {
        abstract override def put(x: Int) = { super.put(x + 1) }
      }

      trait Filtering extends IntQueue {
        abstract override def put(x: Int) = {
          if (x >= 0) super.put(x)
        }
      }
    #+END_SRC
    - These THREE /trait/ can only be _mixed into_ a /class/ that also _extends_
      ~IntQueue~.

    - These THREE /traits/ represent _MODIFICATIONS_,
      BECAUSE
        they modify the behavior of an underlying queue /class/
        RATHER THAN defining a full queue /class/ themselves.

    - These THREE /traits/ are /stackable/ -- you can select any of the three
      you like, mix them into a /class/, and obtain a new /class/ that has all
      of the modifications you chose.

  * The _second_ funny thing is that the /trait/, for instance, the ~Doubling~,
    has a ~super~ call on a /method/ declared ~abstract~.
    + Such calls are *illegal* for NORMAL /classes/
      BECAUSE they will _CERTAINLY fail at run time._

    + =IMPORTANT=
      =IMPORTANT=
      =IMPORTANT=
      For a /trait/, however, such a call can actually succeed.
      Since ~super~ calls in a /trait/ are *dynamically bound*, the ~super~ call
      in /trait/ ~Doubling~ will work SO LONG AS the /trait/ is _mixed in_
      *after* another /trait/ or /class/ that gives a /concrete definition/ to
      the /method/.

  * To tell the compiler you are doing this on purpose, you must mark such
    methods as ~abstract override~. _This combination of modifiers_ is
    *only allowed* for /members/ of /traits/,
    *NOT classes*, and it means that
    =IMPORTANT=
    the /trait/ *MUST* be _mixed into_ some /class/ that _has a *CONCRETE
    definition* of the /method/ in question._

  * Run and check the result:
    + Non-stacked
      #+BEGIN_SRC scala
        class MyQueue extends BasicIntQueue with Doubling

        val queue = new MyQueue
        // OR //
        // Use anonymous class `val queue = new BasicIntQueue with Doubling`

        queue.put(10)
        queue.get()
        // 20
      #+END_SRC

    + Stacked
      #+BEGIN_SRC scala
        val queue = new BasicIntQueue with Incrementing with Filtering
        queue.put(-1)
        queue.put(0)
        queue.put(1)

        queue.get()
        // Int = 1
        queue.get()
        // Int = 2
      #+END_SRC

    + Stacked (different order)
      #+BEGIN_SRC scala
        val queue = new BasicIntQueue with Filtering with Incrementing
        queue.put(-1)
        queue.put(0)
        queue.put(1)

        queue.get()
        // Int = 0
        queue.get()
        // Int = 1
        queue.get()
        // Int = 2
      #+END_SRC

  * *The order of traits is significant*.
    The precise rules depends on /the linearization rule/.

    Roughly speaking
    1. /traits/ _further to the right_ take effect first.
      WHEN you call a /method/ on a /class/ with /mixins/,
      the /method/ in the /trait/ _furthest to the right_ is called first.

    2. If that method calls ~super~, it invokes the /method/ in the NEXT /trait/
       _to its left_, and so on.

- Overall, code written in this style gives you a great deal of flexibility.
  You can define _sixteen_ (=from Jian= 3 + 6 + 6 + 1) DIFFERENT /classes/ by
  mixing in these THREE /traits/ in different combinations and orders.

  That's a lot of flexibility for a small amount of code, so you should keep
  your eyes open for opportunities to arrange code as stackable modifications.

- Since it is very flexible,
  you must keep eyes open for opportunities to arrange code as _stackable
  modifications_.

- footnote 3: (=from Jian=) rephrased
  * mixin :: a /trait/ that is _mixed into_ a /class/ (from footnote 3).

** DONE 11.4 Why not multiple inheritance? - 243
CLOSED: [2025-05-05 Mon 20:54]
/Traits/ are a way to _inherit from_ MULTIPLE _class-like constructs_,
BUT
they *differ* in important ways from the /multiple inheritance/ present in many
languages.

- One _DIFFERENCE_ is especially important:
  the *interpretation* of ~super~.

  * With /multiple inheritance/,
    the /method/ called by a ~super~ call can _be DETERMINED right where the call
    appears._

  * With /traits/,
    the /method/ called _is determined by a /linearization/ of the /classes/ and
    /traits/ that are MIXED INTO a /class/._

  =IMPORTANT=
  This is the difference that _ENABLES_ the /stacking of modifications/
  described in the previous section.

- The precise order of the /linearization/ is described in the *language
  specification*.

- Example:
  #+BEGIN_SRC scala
    class Animal
    trait Furry extends Animal
    trait HasLegs extends Animal
    trait FourLegged extends HasLegs
    class Cat extends Animal with Furry with FourLegged
  #+END_SRC

  Left to Right:
  1. ~Animal~: ~Animal~ --> ~AnyRef~ --> ~Any~

  2. ~Furry~: ~Furry~ ===> ~Animal~ --> ~AnyRef~ --> ~Any~

  3. ~FourLegged~: ~FourLegged~ --> ~HasLegs~ ===> ~Furry~ ===> ~Animal~ --> ~AnyRef~ --> ~Any~

** DONE 11.5 Trait parameters - 248
CLOSED: [2025-05-05 Mon 22:18]
_As of Scala 3, traits can take value parameters._

- Listing 11.10 · Defining a trait parameter.
  #+begin_src scala
    trait Philosophical(message: String):
      def philosophize = message
  #+end_src

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  You *MUST specify* a /trait's parameter value/
  WHEN DEFINING a /class/ that mixes in the /trait/.

- /Trait parameters/ are evaluated immediately before the _trait initializes_.
  * =TODO= =???=
    footnote 5:
    /Trait parameters/ in Scala 3 _REPLACES_ /early initializers/ in Scala 2.

- As you use /parameterized traits/, you may notice that the rules for
  /trait parameters/ are *slightly DIFFERENT than* for /class parameters/.

  * In both cases, you can only initialize once.

  * _HOWEVER_,
    ALTHOUGH
    EACH /class/ _CAN ONLY_ be extended by _ONE_ /subclass/ in a hierarchy,
    a /trait/ can be MIXED IN _by MULTIPLE /subclasses/._

    In that case, you must initialize the /trait/
    WHEN defining the /class/ that MIXES IN the /trait/ *highest up in the
    hierarchy*.

    + Illustrate this by an example:

      - Listing 11.11 · Supplying a trait parameter.
        #+begin_src scala
          class ProfoundAnimal extends Animal,
            Philosophical("In the beginning was the deed.")
        #+end_src

      - Listing 11.12 · Not supplying a trait parameter.
        #+begin_src scala
          class Frog extends ProfoundAnimal, Philosophical
        #+end_src

      - A /trait/ *cannot* _pass parameters to_ its /parent traits/.
        For example, consider /trait/ ~PhilosophicalAnimal~ that extends /trait/
        ~Philosophical~:
        #+begin_src scala
          trait PhilosophicalAnimal extends Animal with Philosophical
        #+end_src

      - *DOSE NOT compile*
        #+begin_src scala
          class Frog extends PhilosophicalAnimal("I croak, therefore I am!")
        #+end_src

        * RIGHT WAYS:
          #+begin_src scala
            class Frog extends
              Philosophical("I croak, therefore I am!"),
              PhilosophicalAnimal
          #+end_src

          OR

          #+begin_src scala
            class Frog extends
              PhilosophicalAnimal,
              Philosophical("I croak, therefore I am!")
          #+end_src

** DONE 11.6 Conclusion - 250 - =IMPORTANT=
CLOSED: [2025-05-05 Mon 22:34]
- This chapter has shown you
  * _HOW /traits/ work and
    HOW to use them in several common idioms._

    + You saw that /traits/ are _SIMILAR TO_ /multiple inheritance/.
      _BUT_
      because /traits/ interpret ~super~ using /linearization/,
      they both
      - _AVOID_ some of the difficulties of traditional /multiple inheritance/ and
      - _ALLOW_ you to *stack behaviors*.

    + You also saw the ~Ordered~ trait and learned how to write your own
      enrichment traits.

- Now that you have seen all of these facets, it is worth stepping back
  and taking another look at /traits/ as a whole:

  * /Traits/ do not merely support the idioms described in this chapter;
    they are a _fundamental unit_ of code that *is REUSABLE through
    /inheritance/.*

    + As such, many experienced Scala programmers start with /traits/ when they
      are at the early stages of implementation.

    + Each /trait/ can hold *less than* an entire concept, a mere FRAGMENT of a
      concept.

      As the design solidifies, the fragments can be combined into more complete
      concepts through /trait mixin/.

** ===========================
** DONE _FROM OLD VERSION BOOK_ - 12.7 To trait or not to trait? - 274 =IMPORTANT= - =REVIEW=
CLOSED: [2018-03-21 Wed 23:50]
There is *NO* firm rules about the choice of using /trait/ or /abstract class/
for a specific use case. ONLY guidelines:

- If the behavior will _NOT be reused_, then make it a /concrete class/. It
  is not reusable behavior after all.

- If it might be reused in _multiple, *unrelated* classes_, make it a /trait/.
  Only traits can be mixed into different parts of the class hierarchy.

- If you want to _inherit from it in Java code_, use an /abstract class/.
  Since traits with code do not have a close Java analog, it tends to be
  *AWKWARD* to _inherit from a trait in a Java class_.

  =TODO= Learn the conversion rules from Scala /trait/ to Java code!!! =TODO=

  Inheriting from a Scala class, meanwhile, is exactly like inheriting from a
  Java class.

  *As one EXCEPTION*,
  _a /Scala trait/ with only abstract members translates directly to a /Java
  interface/_, so you should feel free to define such /traits/ even if you
  expect Java code to inherit from it.
  =TODO= =IMPORTANT=
  See Chapter 31 for more information on working with Java and Scala together.

- If you plan to _distribute it in compiled form_, and you expect outside groups
  to write classes inheriting from it, you might lean towards using an
  /abstract class/.

  The issue is that when a trait gains or loses a member, any classes that
  inherit from it must be recompiled, even if they have not changed.

  If outside clients will only call into the behavior, instead of inheriting
  from it, then using a trait is fine.

- *Default Choice* if NOT used in Java code:
  If you _still do not know, after considering the above_,
  then START BY making it as a /trait/.

  You can always change it later, and in general using a /trait/ _keeps more
  options open_.

* DONE 12 Packages, Imports, and Exports - 251
CLOSED: [2025-04-17 Thu 10:49]
- When working on a program, especially a large one, it is important to
  *minimize* /coupling/ -- the extent to which the various parts of the program
  rely on the other parts. _LOW coupling_ *reduces* the risk that a small,
  seemingly innocuous change in one part of the program will have devastating
  consequences in another part.

- *One way to minimize coupling is to write in a modular style*:
  You divide the program into a number of smaller modules, each of which has an
  *inside* and an *outside*.
  * When working on the inside of a module -- its implementation -- you need
    only coordinate with other programmers working on that very same module.

  * Only when you must change the outside of a module -- its interface -- is it
    necessary to coordinate with developers working on other modules.

- *This chapter shows several constructs that help you program in a /modular style/.*
  It shows
  1. how to place things in packages,
  2. make names visible through imports, and
  3. control the visibility of definitions through access modifiers.

  The constructs are _similar in spirit to_ constructs in Java,
  _BUT_ there are some differences -- _usually ways that are more consistent_ --
  so it's worth reading this chapter even if you already know Java.
  =from Jian=
  Add more details

** DONE 12.1 Putting code in packages - 251
CLOSED: [2025-04-16 Wed 11:47]
Scala code resides in _the Java platform's global hierarchy of packages._

- The example code you've seen so far in this book has been in the /unnamed
  package/.

- =IMPORTANT=
  It is recommended to follow Java's reverse-domain-name convention for Scala
  packages that you release to the public.

  * Here, we (=from Jian= the book) use a shorter form in the following
    examples. A better name is like ~com.bobsrockets.navigation~.

- You can place code into /named packages/ in Scala in _TWO_ ways:
  1. =from Jian= *The Java way!*
     You can place the contents of an *ENTIRE file* into a /package/
     _BY_
     putting a /package clause/ at the top of the file, as shown in _Listing
     12.1_:
     #+begin_src scala
       package bobsrockets.navigation

       class Navigator
       // ...
     #+end_src
     Listing 12.1 · Placing the contents of an entire file into a package.

  2. The other way you can place code into /packages/ in Scala is more LIKE /C#
     namespaces/: follow a /package clause/ by a _colon_ and an _indented_
     section of code containing the definitions that go into the /package/.

     =from Jian= Current book emphasize brace-less syntax. The syntax with
     braces in Scala 2 is the *same* as the syntax in C#, *not just like.*

     *This syntax is called a /packaging/.*
     =FIXME= Remove a???

     _Listing 12.2_ has the same effect as the code in _Listing 12.1_:
     #+begin_src scala
       package bobsrockets.navigation:
         class Navigator
     #+end_src
     Listing 12.2 · Long form of a simple package declaration.

- Usage:
  * For such simple examples, you might as well use the /syntactic sugar/ shown in
    Listing 12.1.
    =FIXME=
    =from Jian= Before this line, the book doesn't mention the second form is
    the /syntactic sugar/ of the first form.

  * However, one use of _the *more general* notation_ is to have different parts
    of _A_ file in different /packages/.
    + For example, if you want to email or post to a discussion forum a snippet
      of Scala code that involves SEVERAL /packages/, you can use /packaging/,
      as shown in Listing 12.3.
    #+begin_src scala
      package bobsrockets:
        package navigation:
          // In package bobsrockets.navigation
          class Navigator
          package launch:
            // In package bobsrockets.navigation.launch
            class Booster

          class Navigator2 // Added by me, Jian Lan, just for this note
    #+end_src
    Listing 12.3 · Multiple packages in the same file.

    + =IMPORTANT=
      =from Jian=
      This syntax has an _VARIANT_, which is simpler -- no colons and
      indentations, but has one *limitation*. It is called /chained package
      clauses/, which is mentioned in the next section.

      Here is a rewritten of Listing 12.3 code in /chained package clauses/
      syntax, and ~Navigator~ and ~Navigator2~ can't show up in the old place!
      #+begin_src scala
        package bobsrockets
        package navigation
        package launch

        // In package bobsrockets.navigation.launch
        class Booster
      #+end_src

** DONE 12.2 Concise access to related code - 252
CLOSED: [2025-04-16 Wed 12:37]
- When code is divided into a /package hierarchy/,
  * it doesn't just help people browse through the code.
  * It also tells the compiler that code in the SAME /package/ is related in
    some way to each other.

- Scala takes advantage of this relatedness by allowing _short, unqualified
  names_ when accessing code that is in the SAME /package/ -- =from Jian= only
  when not using the _One package per file_ way.

  * Different ways of packaging affect the way of using names outside _CURRENT_
    package:
    + If you use _one package per file_ way, the name outside current package must be
      imported before using.
      - =from Jian=
        Same as in Java! This rule very simple but may result in redundant code
        in some scenarios.

    + *Explicitly* nest the packagings:
      #+begin_src scala
        package bobsrockets:
          package navigation:
            class Navigator:
              // No need to say bobsrockets.navigation.StarMap
              val map = new StarMap

            class StarMap

          class Ship:
            // No need to say bobsrockets.navigation.Navigator
            val nav = new navigation.Navigator

          package fleets:
            class Fleet:
              // No need to say bobsrockets.Ship
              def addShip = new Ship
      #+end_src
      Listing 12.4 · Concise access to classes and packages.

      _Inner packages_ can see names in the _same package_ and in its _packages
      that wrap it_.

      - A variant:
        the /chained package clauses/ syntax.

    + *NOT Explicitly* nest the packagings:
      #+begin_src scala
        package bobsrockets:
          class Ship

        package bobsrockets.fleets:
          class Fleet:
            // Doesn't compile! Ship is not in scope.
            def addShip = new Ship
      #+end_src
      Listing 12.5 · Symbols in enclosing packages not automatically available.

      =from Jian=
      Logically, one package include another one, but not in actual code.
      A name in the "outside" pcakge is not automatically visible by the "inner"
      package. _For visibility, only "logically nested" is NOT enough._

  * ~_root_~:
    Scala must handle /package name hiding issue/ because of the support to
    package organization not in the form of _one package per file_:
    #+begin_src scala
      // In file launch.scala
      package launch:
        class Booster3

      // In file bobsrockets.scala
      package bobsrockets:
        package launch:
          class Booster2

        package navigation:
          package launch:
            class Booster1

          class MissionControl:
            val booster1 = new launch.Booster1
            val booster2 = new bobsrockets.launch.Booster2
            val booster3 = new _root_.launch.Booster3
    #+end_src
    If no ~_root_~, there is no way to express ~booster3~ value.

** DONE 12.3 Imports - 256
CLOSED: [2025-04-16 Wed 13:10]
- Simple imports that you can find their counterparts in Java:
  #+begin_src scala
    // easy access to Fruit
    import bobsdelights.Fruit

    // easy access to all members of bobsdelights
    import bobsdelights.*

    // easy access to all members of Fruits
    import bobsdelights.Fruits.*
  #+end_src
  Coresponds to Java's
  1. single type import
  2. on-demand imports
  3. import of static class fields

- _Scala's flexible imports_
  Scala's ~import~ clauses are quite a bit more flexible than Java's. There are
  three principal differences. In Scala, imports:
  * may appear anywhere
  * may refer to objects (singleton or regular) in addition to packages
  * let you rename and hide some of the imported members

- *Scala can import any value memebers!*
  #+begin_src scala
    val fruit = Fruit(..)

    def showFurit(fruit: Fruit) =
      import fruit.*
      s"${name}s are $color"
  #+end_src

- /import selector clause/ examples:
  * ~import Fruits.{Apple, Orange}~

  * ~import Fruits.{Apple as McIntosh, Orange}~
    ~import java.sql.Date as SDate~
    with renaming.

  * ~import Fruits.{Apple as _, *}~
    Import everything except ~Apple~
    + =from Jian=
      =IMPORTANT=
      =IMPORTANT=
      =IMPORTANT=
      I think this syntax is not good, it can create a import clause like:
      ~import Fruits.{Apple as _, Orange}~ which hiding is useless!

      How about introduce a syntax like (need a new soft keyword ~except~):
      ~import Fruits.* except Apple~
      ~import Fruits.* except {Apple, Orange}~

      and make the linter warns the programmer that try to use this syntax
      instead of the ~as _~ one or just deprecate the ~as _~ import syntax?!

** DONE 12.4 Implicit imports - 259
CLOSED: [2025-04-16 Wed 14:05]
Scala adds some imports _implicitly_ to _every_ program.
In essence, it is as if
the following three import clauses had been added to the top of every source
file with extension ".scala":

#+begin_src scala
  import java.lang.* // everything in the java.lang package
  import scala.*     // everything in the scala package
  import Predef.*    // everything in the Predef object
#+end_src
- The ~java.lang~ package contains standard Java classes.

- As you have no doubt realized by now, the ~scala~ package contains the
  standard Scala library, with many common classes and objects.

- The ~Predef~ object contains many definitions of
  * /type aliases/,
  * /methods/, and
  * /conversions/
  that are commonly used on Scala programs.

These _THREE_ import clauses are treated *a bit specially* in that later imports
_overshadow_ earlier ones.

- For instance,
  the ~StringBuilder~ class is defined _BOTH in package ~scala~ and ~java.lang~._
  Because the scala import *overshadows* the ~java.lang~ import, the simple name
  ~StringBuilder~ will refer to ~scala.StringBuilder~, *NOT*
  ~java.lang.StringBuilder~.

** TODO 12.5 Access modifiers - 260 - = =RE-READ: Scope of protection=
Access modifiers ~private~ and ~protected~.

Scala's treatment of /access modifiers/ roughly follows Java's
_BUT_ there are *some important differences* which are explained in this
section.

*** Private members - 260
A member labeled ~private~ is visible only inside the /class/ or /object/ that
contains the member definition.

DIFFERENCES between Scala and Java:

- In Scala, inner class private members only belongs to itself, its host /class/
  or /object/ *CANNOT* access them.

  #+begin_src scala
    class Outer:
      class Inner:
        private def f = "f"
        class InnerMost:
          f // OK

      (new Inner).f // error: f is not accessible
  #+end_src
  Listing 12.10 · How private access differs in Scala and Java.

- In Java, inner class private members can be accessed.
  (If the code above is in Java) Java would permit *BOTH accesses* because it
  lets an _outer class_ access private members of its _inner classes_.

*** Protected members - 261
Access to /protected members/ in Scala is also a bit *more restrictive* than in
Java.

#+begin_src scala
  package p:
    class Super:
      protected def f = "f"

    class Sub extends Super:
      f

    class Other:
        (new Super).f // error: f is not accessible
#+end_src
Listing 12.11 · How protected access differs in Scala and Java.

DIFFERENCES between Scala and Java:

- In Scala,
  a /protected member/ is ONLY accessible from /subclasses/ of the /class/ in
  which the member is defined.

- In Java
  such accesses are also possible _from other /classes/ in the *same*
  /package/._
  * In Scala, there is another way to achieve this effect.

*** Public members - 262
Scala has _no explicit modifier_ for /public members/: Any member not labeled
~private~ or ~protected~ is _public_. /Public members/ can be accessed from
anywhere.

*** Scope of protection - 262
/Access modifiers/ in Scala can be *AUGMENTED* with qualifiers.

- A modifier of the form ~private[X]~ or ~protected[X]~ means
  access is _private_ or _protected_ "up to" ~X~, where ~X~ designates some
  enclosing package, class or singleton object.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  /Qualified access modifiers/ give you very _fine-grained control_ over
  /visibility/.

  * In particular they enable you to express Java's accessibility notions,
    such as
    + package private,
    + package protected, or
    + private up to outermost class,

    which are _not directly expressible_ with simple modifiers in Scala.
    But they also let you express accessibility rules that cannot be expressed
    in Java.

- Listing 12.12 · Flexible scope of protection with access qualifiers.
  #+begin_src scala
    package bobsrockets

    package navigation:
      private[bobsrockets] class Navigator:
        protected[navigation] def useStarChart() = {}
        class LegOfJourney:
          private[Navigator] val distance = 100

    package launch:
      import navigation.*
      object Vehicle:
        private[launch] val guide = new Navigator
  #+end_src
  * ~class Navigator~ is labeled ~private[bobsrockets]~.
    This means that
    this /class/ is visible in all /classes/ and /objects/ that are *contained
    in package ~bobsrockets~.*

    + This is why ~object Vehicle~ can access to ~Navigator~.

- This technique is quite useful in large projects that span several packages.
  It allows you to define things that are visible in several sub-packages of
  your project but that remain hidden from clients external to your project.

- Of course, the qualifier of a ~private~ may also be the /directly enclosing
  package/. An example is the access modifier of ~guide~ in ~object Vehicle~ in
  Listing 12.12. Such an /access modifier/ is equivalent to /Java's package
  private access/.

- All qualifiers can also be applied to ~protected~, with the same meaning as
  ~private~.

  * ~protected[X]~ in a ~class C~ allows access to the labeled definition in all
    /subclasses/ of ~C~ and also within _the ENCLOSING /package/, /class/, or
    /object/ ~X~._

    For instance,
    the ~useStarChart~ method in Listing 12.12 is accessible in all /subclasses/
    of ~Navigator~ and also in all code contained in the /enclosing package/
    ~navigation~.

    It thus corresponds _exactly to the meaning of ~protected~ in Java._

- The qualifiers of ~private~ can also refer to _an ENCLOSING /class/ or
  /object/._

  For instance the ~distance~ variable in class ~LegOfJourney~ in Listing 12.12
  is labeled ~private[Navigator]~, so it is visible from everywhere in class
  ~Navigator~.

  *This gives the SAME ACCESS capabilities as for
  _private members of inner classes in Java_.*

  A ~private[C]~ where ~C~ is the _outermost enclosing class_ is the same as
  _just ~private~ in Java._

- To summarize, Table 12.1 on page 263 lists the effects of /private
  qualifiers/. Each line shows a /qualified private modifier/ and what it would
  mean if such a modifier were attached to the ~distance~ variable declared in
  ~class LegOfJourney~ in Listing 12.12.

  Table 12.1 · Effects of private qualifiers on ~LegOfJourney.distance~
  | no access modifier      | public access                      |
  |-------------------------+------------------------------------|
  | ~private[bobsrockets]~  | access within outer package        |
  | ~private[navigation]~   | same as package visibility in Java |
  | ~private[Navigator]~    | same as ~private~ in Java          |
  | ~private[LegOfJourney]~ | same as ~private~ in Scala         |

*** Visibility and companion objects - 264
Listing 12.13: Accessing _private members_ of /companion classes and objects/.
#+begin_src scala
  class Rocket:
    import Rocket.fuel
    private def canGoHomeAgain = fuel > 20

  object Rocket:
    private def fuel = 10
    def chooseStrategy(rocket: Rocket) =
      if rocket.canGoHomeAgain then
        goHome()
      else
        pickAStar()

    def goHome() = {}
    def pickAStar() = {}
#+end_src

- Scala's access rules privilege companion objects and classes when it comes to
  ~private~ or ~protected~ accesses.

  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  _A /class/ *shares all its access rights* with its /companion object/ and vice
  versa._

- One *EXCEPTION* where the similarity between Scala and Java breaks down concerns
  ~protected static~ members.
  * In Java, _a ~protected static~ member_ of a Java ~class C~ can be accessed in
    ALL /subclasses/ of ~C~.

  * By contrast,
    a ~protected~ member in a /companion object/ *makes no sense*, as singleton objects
    *don't have any* /subclasses/.
    + =from Jian= a ~protected~ member in a /companion object/ is always static!

    + =from Jian=
      =IMPORTANT=
      _NOT DISCUSSED IN DETAILS IN THE BOOK, HERE IS MY THINKING!_
      I guess here *makes no sense* means *makes no sense to consider
      its subclasses accessibility* Since Scala doesn't forbid it, it might be
      useful by itself.

      - Q :: Then why do Scala still allow /protected memebers/ in companion objects
             in syntax?
      - A :: In Scala, any ~object~ can extends /classes/ or /traits/, which can have
             /protected memebers/ that, of course, can be *overrided*.

             This is the reason in syntax:
             #+begin_src scala
               class X:
                 def bar(): Unit =
                   X.foo()

               class XX:
                 protected def foo(): Unit =
                   println("Here is XX!")

               object X extends XX:
                 override protected def foo(): Unit =
                   super.foo()
                   println("Here is the `X` companion object, a subclass of `XX`!")
             #+end_src

             Since the ~protected~ must be overrided by a ~protected~, there is
             no way to forbid ~protected~ from /companion object/'s or any other
             /object/'s.

** DONE 12.6 Top-level definitions - 265
CLOSED: [2025-04-16 Wed 16:26]
*Any* kind of definition that you can put inside a /class/ can also be at the
top level of a /package/.

- Top-level definitions are frequently used to hold
  * /package-wide helper functions/ (mentioned in the last paragraph, and =Jian=
    move it to here)
  * /package-wide type aliases/ (Chapter 20)
  * /extension methods/ (Chapter 22).

- The ~scala~ package includes top-level definitions, which are available to all
  Scala code.

- =from Jian=
  /package object/ in Scala 2 is no longer needed.

** DONE 12.7 Exports - 266
CLOSED: [2025-04-16 Wed 20:34]
- In Section 10.11 we recommended that
  you should _PREFER /composition/ OVER /inheritance/,_
  * ESPECIALLY when your primary goal is *code reuse*.

- _PREFER /composition/ OVER /inheritance/_ is an application of /the principle
  of least power/:
  /Composition/ treats components as blackboxes
  whereas
  /inheritance/ can affect the internal workings of components through
  /overriding/.

  * Sometimes the _tight coupling_ implied by /inheritance/ is the best solution
    for a problem,
    _BUT_ where this is not necessary the /looser coupling/ of /composition/ is
    better.
    (=from Jian= more than 90% use cases)

- In most popular object-oriented programming languages it is easier to use
  /inheritance/ than /composition/. =from Jian= This is BAD!

  In Scala 2, for example,
  /inheritance/ only required an ~extends~ clause
  whereas /composition/ required _a verbose elaboration of a sequence of
  forwarders_.

  * =IMPORTANT=
    _CONCLUSION_:
    Most object-oriented languages have, therefore, been pushing programmers to
    a solution that is often too powerful.

- /Exports/, a new feature introduced in Scala 3, aim to redress this imbalance.
  * /Exports/ make /composition relationships/ *as concise and easy to express as*
    /inheritance relationships/.
    + =from Jian=
      If there a way that can make /composition relationships/ more easier, it
      will be a perfect solution. =HowTo???=

  * /Exports/ also offer _more flexibility than_ ~extends~ clauses,
    since members can be *renamed* or *omitted*.

- Example:
  #+begin_src scala
    case class PosInt(value: Int):
      require(value > 0)
      export value.{<< as shl, >> as shr, >>> as _, *}
  #+end_src
  ~PosInt~ has almost all methods of ~Int~ but not ~>>>~.
  Renames renames << and >>, and drop their symbolic names.

** DONE 12.8 Conclusion - 269
CLOSED: [2025-04-16 Wed 20:50]
- In this chapter, you saw the basic constructs for dividing a program into
  /packages/.

  This gives you a simple and useful kind of /modularity/,
  so that
  you can work with very large bodies of code without different parts of the
  code trampling on each other.

- Scala's (=FIXME= packages instead of system) system is _the same in spirit_ as
  Java's packages, but there are _some differences_ where Scala chooses to be
  more consistent or more general.

- New feature: /exports/.
  It aims to make /composition/ as convenient as /inheritance/ for code reuse.

- =???=
  =TODO=
  =IMPORTANT=
  Looking ahead, Advanced Programming in Scala describes a more flexible module
  system than division into packages.

  * In addition to letting you separate code into several namespaces, that
    approach allows modules to be /parameterized/ and /inherit/ from each other.

- =NEXT=
  In the next chapter, we'll turn our attention to /pattern matching/.

* DONE 13 Pattern Matching - 270
CLOSED: [2025-04-17 Thu 19:13]
- This chapter describes
  * /case classes/ and
  * /pattern matching/,
  constructs support you when writing _regular, non-encapsulated data structures._

- These two constructs are particularly helpful for _tree-like recursive data_.

- /Case classes/ are Scala's way to allow /pattern matching/ on objects
  _WITHOUT_ requiring a large amount of boilerplate.

- This chapter
  1. starts with an example of case classes and pattern matching.
  2. It then goes through all of the kinds of _patterns_ that are supported,
  3. talks about the role of /sealed classes/,
  4. discusses /enums/, ~Option~'s, and
  5. shows some _NON-OBVIOUS places_ in the language where /pattern matching/ is used.
  6. Finally, a larger, more realistic example of /pattern matching/ is shown.

** DONE 13.1 A simple example - 270
CLOSED: [2025-04-17 Thu 11:25]
#+begin_src scala
  trait Expr
  case class Var(name: String) extends Expr
  case class Num(number: Double) extends Expr
  case class UnOp(operator: String, arg: Expr) extends Expr
  case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
#+end_src
Listing 13.1 · Defining case classes.

*** Case classes - 271
- The ~case~ modifier makes the Scala compiler _ADD_ some syntactic conveniences
  to your /class/.
  * Adds a /factory method/ with the name of the /class/.
    Use a noiseless way to construct a new object, especially when nesting them:
    #+begin_src scala
      val v = Var("x")

      val op = BinOp("+", Num(1), v)
    #+end_src

  * The parameter of a /case class/ implicitly get a ~val~ prefix.

  * The compiler adds "natural" implementations of methods ~toString~,
    ~hashCode~, and ~equals~ to your /class/.
    + Since ~==~ in Scala always delegates to ~equals~, this means that elements
      of /case classes/ are always compared structurally.

  * Finally, the compiler adds a ~copy~ method to your /class/ for making
    modified copies.
    #+begin_src scala
      op.copy(operator = "-") // BinOp("-", Num(1.0), Var("x"))
    #+end_src

- All these conventions add a lot of convenience -- at a small price.

  You have to write the ~case~ modifier, and your /classes/ and /objects/
  _become a bit LARGER._

  * They are _LARGER_
    BECAUSE
    + additional methods are generated and
    + an /implicit field/ is added for each /constructor parameter/.

  However, the biggest advantage of case classes is that they support pattern
  matching.

*** Pattern matching - 272
- Example:
  #+begin_src scala
    def simplifyTop(expr: Expr): Expr =
      expr match
        case UnOp("-", UnOp("-", e)) => e // Double negation
        case BinOp("+", e, Num(0)) => e // Adding zero
        case BinOp("*", e, Num(1)) => e // Multiplying by one
        case _ => expr
  #+end_src
  Listing 13.2 · The simplifyTop function, which does a pattern match.

- Imagine trying to implement this same functionality using the /visitor design/
  pattern!
  =TODO=
  =IMPORTANT=

  Almost as awkward, imagine implementing it as a long sequence of ~if~
  statements, _type tests_, and _type casts_.

*** ~match~ compared to ~switch~ - 274
- /Match expressions/ can be seen as a *generalization* of /Java-style switches/.

- A /Java-style switch/ can be _naturally expressed_ as a /match expression/,
  where each /pattern/ is a constant and the last pattern may be a wildcard (which
  represents the default case of the switch).

- However, there are *THREE differences* to keep in mind:
  1. ~match~ is an /expression/ in Scala (i.e., it always results in a value).
  2. Scala's alternative expressions *NEVER "fall through"* into the next
     ~case~.
  3. If none of the patterns match, an exception named ~MatchError~ is thrown.

** DONE 13.2 Kinds of patterns - 274
CLOSED: [2025-04-17 Thu 13:56]
*** Wildcard patterns - 275
The ~_~ pattern.

*** Constant patterns - 275
A /constant pattern/ matches only itself.
Any /literal/ may be used as a constant.

*** Variable patterns - 276
- Q :: How does the Scala compiler know that a symbol, like ~Pi~ (from
       ~scala.math~), is a constant?

- A :: Scala uses a simple lexical rule for disambiguation:
  * a _simple name_ starting with a *lowercase letter* is taken to be a /pattern
    variable/;
  * all other references are taken to be /constants/.
    + You can still use a name starting with a lowercase letter for a /pattern
      constant/, if you need to, by using one of two tricks (~`~).

    + Or if it is a member of an object, like ~this.pi~ (if this is a constant),
      it can be considered as a /pattern constant/ even if it starts with a
      lowercase letter.

- A SUMMARY (till now) about the usage of _back-tick syntax_:
  As you can see, the back-tick syntax for /identifiers/ is used for two
  different purposes in Scala (=from Jian= both of them are used to) *help you
  code your way out of unusual circumstances*.

  * Here you can see
    it can be used to *treat a lowercase identifier as a constant* in a /pattern
    match/.

  * Earlier on, in Section 6.10, you saw that
    it can also be used to *treat a keyword as an _ordinary identifier_,* e.g.,
    writing ~Thread.`yield`()~ treats ~yield~ as an /identifier/ rather than a
    /keyword/.

*** Constructor patterns - 278
The most commonly used patterns.

*** Sequence patterns - 279
~case List(0, _, _)~
~case List(0, _*)~

*** Tuple patterns - 279
*** Typed patterns - 280 - =REVIEW=
#+begin_src scala
  def generalSize(x: Any) =
    x match
      case s: String => s.length
      case m: Map[_, _] => m.size
      case _ => 1
#+end_src

- =IMPORTANT=
  As you will have noted by now, writing /type tests and casts/ is RATHER
  VERBOSE in Scala.

  _That's INTENTIONAL_ because *it is NOT ENCOURAGED practice.*

  *You are usually BETTER OFF using a /pattern match/ with a /typed pattern/.*
  That's *particularly true* if you need to do both a /type test/ and a /type
  cast/, because both operations are then rolled into a single pattern match.

- *Type ascription*
  * *Casts are inherently unsafe.*
    It can compile but fail at runtime!

  * An ALTERNATIVE to /casts/ that is *always safe* is /type ascription/: any
    invalid ascription will give you a compiler error, not a runtime exception.
    #+begin_src scala
      3: String

      // 1 |3: String
      //   |^
      //   |Found:    (3 : Int)
      //   |Required: String
    #+end_src

    + A /type ascription/ will compile in only TWO cases:
      1. you can use a /type ascription/ to *widen* a type to one of its
         /supertypes/. For example:
         #+begin_src scala
           // In REPL

           Var("x"): Expr // Expr is a supertype of Var
           // val res0: Expr = Var(x)
         #+end_src

      2. you can use a /type ascription/ to *implicitly convert* one type
         to another, such as implicitly converting an ~Int~ to ~Long~:
         #+begin_src scala
           // In REPL

           3: Long
           // val res1: Long = 3
         #+end_src

- /Type erasure/
  * You *cannot* simple check if a map with specific element types because of
    /type erasure/.
    #+begin_src scala
      def isIntIntMap(x: Any) =
        x match
          case m: Map[Int, Int] => true
          case _ => false
    #+end_src
    + Compilation warning:
      #+begin_src text
        def isIntIntMap(x: Any): Boolean
        3 | case m: Map[Int, Int] => true
          |      ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆ
          |      the type test for Map[Int, Int] cannot be
          |      checked at runtime
      #+end_src

    + This can show the "cannot be checked at runtime" fact:
      #+begin_src scala
        isIntIntMap(Map(1 > 1))         // true
        isIntIntMap(Map("abc" > "abc")) // true
      #+end_src

  * The Only EXCEPTION:
    _The only exception to the erasure rule is arrays,_
    BECAUSE _they are *handled specially* in Java as well as in Scala._
    *The /element type/ of an ARRAY is _stored with the array value_,*
    so you can pattern match on it. Here's an example:
    #+begin_src scala
      def isStringArray(x: Any) =
        x match
          case a: Array[String] => "yes"
          case _ => "no"

      isStringArray(Array("abc"))   // yes
      isStringArray(Array(1, 2, 3)) // no
    #+end_src

- =IMPORTANT=
  =from Jian=
  The bellow is NOT mentioned here in this chapter.

  To address the /type erasure/ issue, Scala 2 use ~ClassTag~, and Scala 3
  introduces ~TypeTest~. Since ~ClassTag~ is unsound and ~TypeTest~ fixes it.
  Should use ~TypeTest~ if in Scala 3!!!

  * Learn more about ~TypeTest~:
    https://docs.scala-lang.org/scala3/reference/other-new-features/type-test.html
    =TODO=
    =TODO=
    =TODO=

*** Variable binding - 284
- Use ~@~
  Example:
  #+begin_src scala
    expr match
      case UnOp("abs", e @ UnOp("abs", _)) => e
      case _ =>
  #+end_src
  Listing 13.13 · A pattern with a variable binding (via the ~@~ sign).

- Anoter /variable binding/ (in general) without using ~@~:
  =from Jian=
  =IMPORTANT=
  Should add a string interploation-like variable binding form added in some
  version of Scala 2.12 or 2.13.
  #+begin_src scala
    "x y x" match {
      case s"x $y x" => y
      case _ => "z"
    }
    // y
  #+end_src

** DONE 13.3 Pattern guards - 284
CLOSED: [2025-04-17 Thu 14:00]
Scala restricts patterns to be /linear/:
a /pattern variable/ may only appear *once* in a pattern.

Use /pattern guard/ to do further check.

You can't write a match case like:
~case BinOp("+", x, x) => ..~

You should write it with /pattern guard/:
~case BinOp("+", x, y) if x == y => ..~

** DONE 13.4 Pattern overlaps - 285
CLOSED: [2025-04-17 Thu 18:41]
The order of cases matters.

** DONE 13.5 Sealed classes - 287
CLOSED: [2025-04-17 Thu 18:48]
Make the /superclass/ of your /case classes/ *sealed*,
and then the compiler can do /exhaustivity checking/ when applying pattern
matching.

- The ~sealed~ keyword, therefore, is often a license to /pattern match/.

- Use ~@unchecked~ to suppress /exhaustivity checking/ for /pattern matching/.

** DONE 13.6 Pattern matching ~Option~'s - 289
CLOSED: [2025-04-17 Thu 18:49]

Talk about ~Option~'s in Scala and ~null~ in Java, and why ~Option~ is good.
People often handle ~Option~'s with /pattern matching/.

** DONE 13.7 Patterns everywhere - 291
CLOSED: [2025-04-17 Thu 19:11]
=IMPORTANT=
/Patterns/ are allowed in many parts of Scala, not just in standalone
~match~ expressions. Take a look at some other places you can use patterns.

*** Patterns in variable definitions - 291
#+begin_src scala
  // scala>
  val myTuple = (123, "abc")
  // val myTuple: (Int, String) = (123,abc)

  // scala>
  val (number, string) = myTuple
  // val number: Int = 123
  // val string: String = abc
#+end_src

*** Case sequences as partial functions - 291
_A sequence of ~case~'s (i.e., alternatives) in curly braces_ can be used
anywhere a /function literal/ can be used.
=FIXME=

=from Jian=
_A sequence of ~case~'s (i.e., alternatives) their own code block_ can be used
anywhere a /function literal/ can be used.

- Example:
  #+begin_src scala
    val withDefault: Option[Int] => Int =
      case Some(x) => x
      case None => 0
  #+end_src

- Partial function :: a function that doesn't covers all values of its input
  type, represented by a sequence of cases in Scala.
  * If you apply such a function on a value it does NOT SUPPORT, it will
    generate a _run-time exception_.

- Partial function type: ~PartialFunction[I, O]~
  * It has method ~isDefinedAt~.

- This facility is quite useful for the Akka actors library, because it allows
  its ~receive~ method to be defined as a series of cases:
  #+begin_src scala
    var sum = 0

    def receive =
      case Data(byte) =>
        sum += byte

      case GetChecksum(requester) =>
        val checksum = ~(sum & 0xFF) + 1
        requester ! checksum
  #+end_src

- A /function literal/, for instance,
  #+begin_src scala
    { case x :: y :: _ => y }
  #+end_src

  gets translated to the following /partial function value/:

  #+begin_src scala
    new PartialFunction[List[Int], Int]:

      def apply(xs: List[Int]) =
        xs match
          case x :: y :: _ => y

      def isDefinedAt(xs: List[Int]) =
        xs match
          case x :: y :: _ => true
          case _ => false
  #+end_src

- _IN GENERAL_, you should try to work with /complete functions/ *whenever
  possible*, because using /partial functions/ _allows for runtime errors_ that
  the compiler cannot help you with.

- _SOMETIMES_ /partial functions/ are really helpful though. You might be sure that
  an unhandled value will never be supplied.

  ALTERNATIVELY, you might be using a framework that expects /partial functions/
  and so will always check ~isDefinedAt~ before calling the function.

  * An example of the latter is the ~receive~ method given previously, where the
    result is a /partially defined function/, defined precisely for those
    messages that the caller wants to handle.

*** Patterns in ~for~ expressions - 294
#+begin_src scala
  for (country, city) <- capitals yield
    s"The capital of $country is $city"
  //
  // List(The capital of France is Paris,
  // The capital of Japan is Tokyo)
#+end_src
Listing 13.18 · A for expression with a tuple pattern.

- If pattern may not match some values, the ~for~ expression will drop the
  values not matched, and only process the matched values:
  #+begin_src scala
    val results = List(Some("apple"), None, Some("orange"))
    for Some(fruit) <- results yield fruit
    // List(apple, orange)
  #+end_src
  Listing 13.19 · Picking elements of a list that match a pattern.

** TODO 13.8 A larger example - 295 - =TODO: Small- Project=
** DONE 13.9 Conclusion - 303
CLOSED: [2025-04-17 Thu 19:13]

* DONE 14 Working with Lists - 304
CLOSED: [2025-04-19 Sat 15:24]
~List~'s are probably the _most commonly used_ /data structure/ in Scala
programs.

This chapter
- Explains lists in DETAIL.
- We will present many common operations that can be performed on lists.
- We'll also cover some important design principles for programs working on lists.

** DONE 14.1 List literals - 304
CLOSED: [2025-04-19 Sat 11:41]
/Lists/ are QUITE SIMILAR to /arrays/, but there are _TWO important
differences_:
1. /lists/ are *immutable*.
2. /lists/ have a /recursive structure/ (i.e., a linked list), whereas /arrays/
   are _flat_.

** DONE 14.2 The ~List~ type - 305
CLOSED: [2025-04-19 Sat 11:41]
- Like /arrays/, /lists/ are _HOMOGENEOUS_: the elements of a list all have the
  same type.

- The ~List~ type in Scala is /covariant/.
- Note the _empty list_ has type ~List[Nothing]~

** DONE 14.3 Constructing lists - 305
CLOSED: [2025-04-19 Sat 11:42]
- ~::~ (pronounced "cons").
  * associates to the right

- ~Nil~

** DONE 14.4 Basic operations on lists - 306
CLOSED: [2025-04-19 Sat 11:44]
- Example:
  Insertion sort algorithm
  #+begin_src scala
    def isort(xs: List[Int]): List[Int] =
      if xs.isEmpty then Nil
      else insert(xs.head, isort(xs.tail))

    def insert(x: Int, xs: List[Int]): List[Int] =
      if xs.isEmpty || x <= xs.head then x :: xs
      else xs.head :: insert(x, xs.tail)
  #+end_src

** DONE 14.5 List patterns - 307 - =TODO: Re-READ=
CLOSED: [2025-04-19 Sat 13:13]
- *About pattern matching on Lists*
  * If you review the possible forms of patterns explained in Chapter 13, you
    might find that _NEITHER ~List(...)~ NOR ~::~ look like it fits the kinds of
    patterns defined there._

    In fact, ~List(...)~ is an instance of a *library-defined* /extractor pattern/.
    =TODO= Such patterns will be discussed in Advanced Programming in Scala.

  * The /"cons" pattern/ ~x \colon{}\colon{} xs~ is a special case of an /infix operation pattern/.
    + As an /expression/, an /infix operation/ _is equivalent to_ a /method call/.
    + For /patterns/, the rules are different:
      As a pattern, an /infix operation/ such as ~p op q~ is equivalent to ~op(p, q)~.
      That is, the /infix operator/ ~op~ is treated as a /constructor pattern/.
      In particular, a /cons pattern/ such as ~x :: xs~ is treated as ~::(x, xs)~.

  * This hints that _there should be a /class/ named ~::~ that corresponds to
    the /pattern constructor/._

    Indeed, ~::~ is exactly the /class/ that builds non-empty lists.

    =INTERESTING=
    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    So ~::~ exists *TWICE* in Scala, once as a name of a /class/ and again as a
    /method/ in /class/ ~List~.

    The effect of the /method/ ~::~ is to produce an /instance/ of the ~class
    scala.:~:.

    =TODO=
    =NEXT=
    You can find out more details about how the ~List~ /class/ is implemented in
    _Advanced Programming in Scala_.

- Here's /insertion sort/ again (=from Jian= See example code in previous
  section), this time written with /pattern matching/:
  #+begin_src scala
    def isort(xs: List[Int]): List[Int] =
      xs match
        case List() => List()
        case x :: xs1 => insert(x, isort(xs1))

    def insert(x: Int, xs: List[Int]): List[Int] =
      xs match
        case List() => List(x)
        case y :: ys => if x <= y then x :: xs
                        else y :: insert(x, ys)
  #+end_src
  Often, /pattern matching/ over lists is *clearer* than _decomposing them with
  /methods/,_

** DONE 14.6 First-order methods on class ~List~ - 309
CLOSED: [2025-04-19 Sat 13:17]
*** Concatenating two lists - 309
~:::~

*** The Divide and Conquer principle - 310
*** Taking the length of a list: ~length~ - 311
*** Accessing the end of a list: ~init~ and ~last~ - 312
*** Reversing lists: ~reverse~ - 312
- The reverse, init, and last operations satisfy some laws that can be used for
  reasoning about computations and for simplifying programs.
  1. ~reverse~ is its own _inverse_:
     xs.reverse.reverse equals xs

  2. ~reverse~ turns
     ~init~ to ~tail~ and
     ~last~ to ~head~,
     EXCEPT that the elements are _reversed_:
     ~xs.reverse.init equals xs.tail.reverse~
     ~xs.reverse.tail equals xs.init.reverse~
     ~xs.reverse.head equals xs.last~
     ~xs.reverse.last equals xs.head~


- The current implementation (in this chapter) of ~rev~ is not the best
  implementation possible.

  =IMPORTANT=
  =TODO=
  In the example starting on page 326, you will see how to speed it up.

*** Prefixes and suffixes: ~drop~, ~take~, and ~splitAt~ - 314
~xs.splitAt(n)~ equals ~(xs.take(n), xs.drop(n))~

*** Element selection: ~apply~ and ~indices~ - 314
~xs.apply(n)~ equals ~(xs.drop(n)).head~

*** Flattening a list of lists: ~flatten~ - 315
*** Zipping lists: ~zip~ and ~unzip~ - 315
*** Displaying lists: ~toString~ and ~mkString~ - 316
- ~xs.mkString(sep)~ equals ~xs.mkString("", sep, "")~

- ~xs.mkString~ equals ~xs.mkString("")~

- =IMPORTANT=
  =Often forget this=
  There are also /variants/ of the ~mkString~ methods called ~addString~ which
  append the constructed string to a ~scala.StringBuilder~ object, rather than
  returning them as a result:
  #+begin_src scala
    val abcde = List('a', 'b', 'c', 'd', 'e')
    val buf = new StringBuilder
    abcde.addString(buf, "(", ";", ")")
  #+end_src

*** Converting lists: ~iterator~, ~toArray~, ~copyToArray~ - 317
- ~xs.copyToArray(arr, start~), where ~start~ is the start index of ~arr~.
  =IMPORTANT=
  You must ensure that the destination array ~arr~ is large enough to hold the
  list in full.

*** TODO Example: Merge sort - 318

** DONE 14.7 Higher-order methods on class ~List~ - 320
CLOSED: [2025-04-19 Sat 14:22]
*** Mapping over lists: ~map~, ~flatMap~ and ~foreach~ - 320
- ~List.range(1, 5)~

*** Filtering lists: ~filter~, ~partition~, ~find~, ~takeWhile~, ~dropWhile~, and ~span~ - 322
~xs span p~ equals ~(xs takeWhile p, xs dropWhile p)~

*** Predicates over lists: ~forall~ and ~exists~ - 323
*** Folding lists: ~foldLeft~ and ~foldRight~ - 324 - =TODO: RE-READ=
- ~List(a, b, c).foldLeft(z)(op)~ equals ~op(op(op(z, a), b), c)~
- ~List(a, b, c).foldRight(z)(op)~ equals ~op(a, op(b, op(c, z)))~

- For /associative operations/, /fold left/ and /fold right/ are _EQUIVALENT_,
  but there might be a *difference in efficiency*.

- One Scala /type inference/ LIMITATION can be seen when applying
  ~foldLeft~ and ~foldRight~

*** Example: List reversal using ~fold~ - 326 - =TODO: RE-READ=
*** Sorting lists: ~sortWith~ - 327

** DONE 14.8 Methods of the ~List~ object - 327
CLOSED: [2025-04-19 Sat 14:49]
*** Creating lists from their elements: ~List.apply~ - 328
*** Creating a range of numbers: ~List.range~ - 328
~List.range(9, 1, -3)~
The third parameter is the _step_.

*** Creating uniform lists: ~List.fill~ - 328
- ~List.fill(5)('a')~

- ~List.fill(2, 3)('b'~)
  2 entries and 3 elements per entry.

*** Tabulating a function: ~List.tabulate~ - 329
- ~val squares = List.tabulate(5)(n => n * n)~

- ~val multiplication = List.tabulate(5, 5)(_ * _)~
  5 entries and 5 elements per entry.

*** Concatenating multiple lists: ~List.concat~ - 329
- ~List.concat(List('a', 'b'), List('c'))~'s result is ~List('a', 'b', 'c')~

- ~List.concat()~'s result is ~Nil~

** DONE 14.9 Processing multiple lists together - 329
CLOSED: [2025-04-19 Sat 15:03]
- Example:
  #+begin_src scala
    (List(10, 20).zip(List(3, 4, 5))).map { (x, y) => x * y }
    // List(30, 80)
  #+end_src
  * *Note*: =IMPORTANT=
    The final ~map~ takes advantage of a _Scala 3 feature_ called /parameter
    untupling/.

  * parameter untupling :: in which a /function literal/ with two or more
    parameters will be *untupled AUTOMATICALLY* if the expected type is a function
    that accepts _one parameter of a /tuple type/._

    + For example,
      the ~map~ call in the previous expression means the same as:
      ~map { case (x, y) => x * y }~.
      =from Jian= In Scala 2, ~case~ must be written out.

- When applying ~zip~,
  any extra elements on the end are discarded.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  Creating an intermediate list with ~zip~ can have an *important cost*
  if the lists have a lot of elements. The ~lazyZip~ (=from Jian= since Scala
  2.13) method solves this issue. Its syntax is similar to the ~zip~ method:
  #+begin_src scala
    (List(10, 20).lazyZip(List(3, 4, 5))).map(_ * _) // List(30, 80)
  #+end_src
  =IMPORTANT=
  In the above example, you can see that the ~map~ method takes as parameter a
  function that takes *two parameters (as opposed to one pair)*, allowing the
  usage of the placeholder syntax.

- There are also /lazy zip/ analogs to ~exists~ and ~forall~.
  #+begin_src scala
    (List("abc", "de").lazyZip(List(3, 2))).forall(_.length == _) // true
    (List("abc", "de").lazyZip(List(3, 2))).exists(_.length != _) // false
  #+end_src

** DONE 14.10 Understanding Scala's type inference algorithm - 331 - =TODO: Review=
CLOSED: [2025-04-19 Sat 15:24]
- One difference between the previous uses of ~sortWith~ and ~msort~ concerns
  the admissible syntactic forms of the comparison function.

  * Compare:
    #+begin_src scala
      msort((x: Char, y: Char) => x > y)(abcde) // List(e, d, c, b, a)
    #+end_src

    with

    #+begin_src scala
      abcde.sortWith(_ > _) // List(e, d, c, b, a)
    #+end_src

- /Type inference in Scala/ is *flow based*.

- This inference scheme suggests the following library design principle:
  When designing a /polymorphic method/ that takes some non-function arguments and
  a function argument,
  *place the function argument last* in a /curried parameter list/ on its own.

  That way,
  1. the method's *correct* /instance type/ can be _inferred from_ the
     _non-function arguments_, and that type can in turn be used to /type check/
     the /function argument/.

  2. The net effect:
     users of the method will be able to
     give *LESS* /type information/ and
     write /function literals/ *in more compact ways*.

- =IMPORTANT=
  This example highlights some LIMITATIONS of
  _the /local, flow-based type inference scheme/ of Scala._

  It is *NOT present* in /the more global Hindley-Milner style of type
  inference/ used in functional languages, such as ML or Haskell.

  * HOWEVER, /Scala's local type inference/ *deals much more gracefully* with
    /object-oriented subtyping/ than the /Hindley-Milner style/ does.

  * Fortunately,
    the limitations show up only in some corner cases, and are usually easily
    _FIXED BY_ adding an /EXPLICIT type annotation/.

- Adding /type annotations/ is also a useful _debugging technique_
  WHEN you get confused by type error messages related to /polymorphic methods/.

** DONE 14.11 Conclusion - 334
CLOSED: [2025-04-19 Sat 15:07]
- Now you have seen many ways to work with lists.

- Along the way, you learned _a bit_ about
  HOW Scala's /type inference/ works.

* DONE 15 Working with Other Collections - 335
CLOSED: [2025-05-06 Tue 23:35]
Scala has a rich collection library. This chapter gives you a tour of the _most
commonly used_ *collection types and operations*, showing just the parts you
will use most frequently.

- =TODO=
  _Advanced Programming in Scala_ will
  * provide a more comprehensive tour of what's available and
  * show how Scala's composition constructs are used to provide such a rich API.

** DONE 15.1 Sequences - 335
CLOSED: [2025-05-02 Fri 22:17]
/Sequence types/ let you work with groups of data _lined up IN ORDER_.

*** Lists - 335
- /Lists/ will also be discussed in _Advanced Programming in Scala_, which
  provides insight into how lists are implemented in Scala.

*** Arrays - 336
*** List buffers - 337
- ~mutable.ListBuffer~ provides constant time /append/ and /prepend/ operations.
  * ~append~ operator: +=
  * ~prepend~ operator: +=:

*** Array buffers - 337
- An ~mutable.ArrayBuffer~ is like an array, except that you can ADDITIONALLY
  _ADD and REMOVE elements from the BEGINNING and END of the sequence._

  * All Array operations are available, though they are a _little slower_ due to
    a layer of wrapping in the implementation.

  * The new _addition_ and _removal_ operations are *constant time on average*.
    + =from Jian= amortized

*** Strings (via ~StringOps~) - 338

** DONE 15.2 Sets and maps - 339
CLOSED: [2025-05-02 Fri 22:58]
- =IMPORTANT=
  By default when you write ~Set~ or ~Map~ you get an *immutable* object.

*** Using sets - 340
*** Using maps - 342
*** Default sets and maps - 344 - =REVIEW= =BENCHMARK=
- The ~scala.collection.mutable.Set()~ /factory method/ returns a
  ~scala.collection.mutable.HashSet~.

- The ~scala.collection.mutable.HashMap()~ /factory method/ returns a
  ~scala.collection.mutable.HashMap~.

- The story for /immutable sets and maps/ is a bit *more involved*.
  * The class returned by the ~scala.collection.immutable.Set()~ /factory method/,
    for example, _depends on_ *how many elements you pass to it*, as shown in

    Table 15.3 · Default immutable set implementations
    |--------------------+---------------------------------------|
    | Number of elements | Implementation                        |
    |--------------------+---------------------------------------|
    |                  0 | ~scala.collection.immutable.EmptySet~ |
    |                  1 | ~scala.collection.immutable.Set1~     |
    |                  2 | ~scala.collection.immutable.Set2~     |
    |                  3 | ~scala.collection.immutable.Set3~     |
    |                  4 | ~scala.collection.immutable.Set4~     |
    |          5 or more | ~scala.collection.immutable.HashSet~  |

  * Similarly, the ~scala.collection.immutable.Map()~ /factory method/ will return
    a different class _depending on_ *how many key-value pairs you pass to it,* as
    shown in Table 15.4.

    Table 15.4 · Default immutable map implementations
    |--------------------+---------------------------------------|
    | Number of elements | Implementation                        |
    |--------------------+---------------------------------------|
    |                  0 | ~scala.collection.immutable.EmptyMap~ |
    |                  1 | ~scala.collection.immutable.Map1~     |
    |                  2 | ~scala.collection.immutable.Map2~     |
    |                  3 | ~scala.collection.immutable.Map3~     |
    |                  4 | ~scala.collection.immutable.Map4~     |
    |          5 or more | ~scala.collection.immutable.HashMap~  |

*** Sorted sets and maps - 345
~TreeSet~ and ~TreeMap~

The order is determined by the ~Ordering~ trait, an implicit instance of which
must be defined for the _element type_.

** DONE 15.3 Selecting mutable versus immutable collections - 346
CLOSED: [2025-05-06 Tue 20:57]
- When in doubt,
  it is better to _start with_ an /immutable collection/ and
  change it later, if you need to,
  BECAUSE
  /immutable collections/ can be *easier to reason about than* /mutable ones/.

- BESIDES _being potentially easier to reason about,_

  /immutable collections/ can usually be *stored more compactly than* /mutable
  ones/
  IF the number of elements stored in the collection is _SMALL_.

  * For instance
    an EMPTY /mutable map/ in its default representation of ~HashMap~ takes up
    about _80 bytes_, and about _16 more_ are added for each entry that's added
    to it.

    An empty /immutable Map/ is a single object that's shared between all
    references, so referring to it essentially *costs* just a _single pointer
    field_.

- For *SMALL* /maps/ and /sets/, the _immutable_ versions are *much more COMPACT
  than* the /mutable ones/.
  * Given that
    _many collections are *small*,_
    switching them to be _immutable_ can bring IMPORTANT
    + _space savings_ and
    + _performance advantages_.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  * GOAL :: To make it easier to switch from immutable to mutable collections,
    and vice versa,

  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  * SOLUTION :: Scala provides some /syntactic sugar/:
    EVEN THOUGH /immutable sets and maps/ do *NOT support* a true ~+=~ method,
    Scala gives a useful *alternate interpretation* to ~+=~ --
    whenever you write ~a += b~, and ~a~ does *NOT support* a method named ~+=~,
    Scala will try interpreting it as ~a = a + b~.
    + Of course, ~a~ must be ~var~ if you want this _alternative interpretation_.

    + Same for ~-=~ and ~++=~.

- CONCLUSION:
  Not all examples are quite that easy to convert, but the special treatment of
  /methods/ _ending in an equals sign_ will often *REDUCE the amount of code that
  needs changing.*

** DONE 15.4 Initializing collections - 348 - =REVIEW=
CLOSED: [2025-05-06 Tue 22:28]
- Pass the initial elements to a /factory method/ on the /companion object/ of
  your chosen collection -- ~apply~.

- Another special situation is if you want to
  _initialize a collection with another collection._
  #+begin_src scala
    import scala.collection.immutable.TreeSet

    val treeSet = colors to TreeSet
  #+end_src
  The ~to~ /method/ _takes as parameter a /companion object/ of a /collection/._
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  You can use it to _convert_ *ANY* collection _to_ another.

*** DONE Converting to array or list - 350
CLOSED: [2025-05-06 Tue 22:25]
- There are more specific than ~to~ /methods/ like:
  ~treeSet.toList~ and ~treeSet.toArray~

- When you invoke ~toList~ or ~toArray~ on a collection, the /order/ of the
  elements in the resulting list or array will be the _SAME as the /order/ of
  elements produced by an /iterator/ on that collection._

- Q :: The difference between ~xs to List~ and ~xs.toList~?

- A :: the implementation of ~toList~ may be /overridden/ by the /concrete
  collection type/ of ~xs~ to provide
  a *MORE EFFICIENT way* to convert its elements to a list _THAN_
  the /default implementation/, which *copies* all the elements of the collection.
  * For instance, the ~ListBuffer~ collection does override its ~toList~ method
    with an implementation that runs in _constant time and space._

- *KEEP IN MIND*,
  * however, that conversion to lists or arrays _USUALLY_ *requires _COPYING all
    of the elements_ of the collection*, and thus may be *slow* for large
    collections.

  * Further, many collections only have a few elements anyway, in which case
    there is _ONLY a small speed penalty._

*** DONE Converting between mutable and immutable sets and maps - 351
CLOSED: [2025-05-06 Tue 22:28]
#+begin_src scala
  import scala.collection.mutable

  treeSet                              // TreeSet(blue, green, red, yellow)
  val mutaSet = treeSet to mutable.Set // mutable.HashSet(red, blue, green, yellow)
  val immutaSet = mutaSet to Set       // Set(red, blue, green, yellow)
#+end_src

** DONE 15.5 Tuples - 351
CLOSED: [2025-05-06 Tue 23:33]
- Because tuples can combine objects of different types, tuples do not
  inherit from Iterable.

- This syntax gives multiple definitions of the same expression.
  #+begin_src scala
    val word, idx = longest
    val word: (String, Int) = (quick,1)
    val idx: (String, Int) = (quick,1)
  #+end_src
  Each /variable/ is _initialized with_ *its own evaluation of the expression*
  on the right-hand side.

  * =TODO=
    =NEXT=
    See Chapter 16 for some examples where /multiple definitions/ are
    convenient.

- As a note of WARNING, _tuples are almost too easy to use._
  * Tuples are great when you combine data that has no meaning beyond “an A and
    a B.”

** DONE 15.6 Conclusion - 353
CLOSED: [2025-05-06 Tue 23:35]

* DONE 16 Mutable Objects - 355 - =TODO: Case study=
CLOSED: [2025-05-07 Wed 12:09]
/Mutable objects/ often come up naturally
WHEN you want to MODEL _objects in the real world that change over time._

- This chapter
  * EXPLAINS
    + what /mutable objects/ are and
    + what Scala provides in terms of syntax to express them.

  * INTRODUCE
    _a larger case study_ on discrete event simulation, which involves /mutable
    objects/, as well as _building an internal DSL for defining digital circuits
    to simulate._

** DONE 16.1 What makes an object mutable? - 355
CLOSED: [2025-05-07 Wed 10:59]
- When you _invoke a method_ or _dereference a field_ on some /purely functional
  object/, you will always get the *SAME result*.

- For a /mutable object/, on the other hand, the result of a _method call_ or
  _field access_ may *depend on*
  what operations were previously performed on the object.
  * A GOOD EXAMPLE of a /mutable object/ is a _bank account_.
    + Listing 16.1 · A mutable bank account class.
      #+begin_src scala
        class BankAccount:
          private var bal: Int = 0

          def balance: Int = bal

          def deposit(amount: Int): Unit =
            require(amount > 0)
            bal += amount

          def withdraw(amount: Int): Boolean =
            if amount > bal then false
            else
              bal = amount
              true
      #+end_src

- /Mutation/ and ~var~'s usually go hand in hand, but things are *NOT ALWAYS so clear cut*.
  * Operations can be forwarded to other objects that have /mutable state/.

  * The reverse is also possible:
    A /class/ might contain ~var~'s and still be _purely functional_.
    + Example:
      a /class/ that *caches* the result of an expensive operation in a /field/
      _for optimization purposes_.

      - Except for this speed gain, the one with or without /cache/ are exactly
        the same.

** DONE 16.2 Reassignable variables and properties - 357
CLOSED: [2025-05-07 Wed 12:08]
- You can perform _TWO fundamental operations_ on a /reassignable variable/:
  * get its value or
  * set it to a new value.

- In Scala,
  _EVERY ~var~ that is a /non-private member/ of some object_
  *implicitly defines* a /getter/ and a /setter/ method with it.
  * The name of the getter of ~var x~ is ~x~.
  * The name of the setter of ~var x~ is ~x_=~.

- The _accessibility_ of /getter/ and /setter/ of a /field/ is the *SAME* as the
  _accessibility_ of this /field/.

- Some languages have a _special syntactic construct_ for these /variable-like
  quantities/ that are _NOT plain variables_ in that their /getter/ or /setter/
  can be redefined.
  * For instance, C# has /properties/, which fulfill this role.

  * _Scala's convention_ of always interpreting a /variable/ as a pair of
    /setter/ and /getter/ methods gives you the SAME capabilities as C#
    properties *without requiring special syntax.*
    =from Jian= and much less boilerplate!!!

- =IMPORTANT=
  /Properties/ can serve many different purposes.
  * Examples:
    + In the example shown in Listing 16.4, _the /setters/ enforced an /invariant/,_
      thus *PROTECTING* the variable *FROM* being assigned ILLEGAL VALUES.

    + You could also use a /property/ to *log* all accesses to /getters/ or
      /setters/ of a variable.

    + Or you could *integrate* variables *with* events,
      for instance by _NOTIFYING_ some _subscriber methods_ *each time a
      variable is modified*.

- A /getter/ and a /setter/ *without* an ASSOCIATED /field/ is allowed!
  * Example:
    Listing 16.5 · Defining a getter and setter without an associated field.
    #+begin_src scala
      import scala.compiletime.uninitialized

      class Thermometer:
        var celsius: Float = uninitialized
        def fahrenheit = celsius * 9 / 5 + 32
        def fahrenheit_=(f: Float) =
          celsius = (f - 32) * 5 / 9
        override def toString = s"${fahrenheit}F/${celsius}C"
    #+end_src
    + ~uninitialized~ is used to set a default value, a /zero value/.
      *The /zero value/ depends on the /field's type/*.

** TODO 16.3 Case study: Discrete event simulation - 361
** TODO 16.4 A language for digital circuits - 362
** TODO 16.5 The ~Simulation~ API - 365
** TODO 16.6 Circuit Simulation - 369
*** The ~Wire~ class - 369
*** The ~inverter~ method - 372
*** The ~andGate~ and ~orGate~ methods - 373
*** Simulation output - 374
*** Running the simulator - 374

** TODO 16.7 Conclusion - 376

* DONE 17 Scala's Hierarchy - 378 - =REVIEW=
CLOSED: [2025-04-18 Fri 15:54]
This chapter will look at /Scala's class hierarchy/ as a whole.

- In Scala, EVERY /class/ *inherits* from a _COMMON_ /superclass/ named ~Any~.

- Because EVERY /class/ is a /subclass/ of ~Any~, the /methods/ defined in ~Any~
  are /"universal" methods/: *they may be invoked on ANY object.*

- Scala also defines some interesting /classes/ at the /bottom of the
  hierarchy/, ~Null~ and ~Nothing~, which essentially act as _COMMON_
  /subclasses/.

- ~Any~ is a /superclass/ of EVERY OTHER /class/
- ~Nothing~ is a /subclass/ of EVERY OTHER /class/.

- In this chapter, we'll give you a tour of Scala's class hierarchy.

** DONE 17.1 Scala's class hierarchy - 378
CLOSED: [2025-04-18 Fri 12:39]
- Figure 17.1 shows an outline of Scala's class hierarchy.
  =from Jian=
  =FIXME???=
  Should mention ~Matchable~, with or without its exact name. Just say this
  figure doesn't include one fundamental trait, and it will be explain in
  Advanced Programming in Scala. At least, in a footnote.

- At the *TOP* of the hierarchy is /class/ ~Any~, which defines /methods/ that
  include the following:
  #+begin_src scala
    final def ==(that: Any): Boolean = this equals that
    final def != (that: Any): Boolean = !(this == that)
    final def ##: Int
    def equals(that: Any): Boolean
    def hashCode: Int
    def toString: String
  #+end_src
  * =FIXME=
    ~##~ should be ~final~!!!

  * =from Jian=
    =IMPORTANT=
    I read the source code of ~Any~, and I found that
    the bodies of /final methods/ are in the form of ~sys.error(...)~.
    + Methods of ~Any~ in this form:
      - ~##~
      - ~isInstanceOf~
      - ~asInstanceOf~

    The Scala compiler special-cases these methods and emits _optimized
    bytecode_ for it, bypassing the ~sys.error~ definition.

  * Since ~final def ==(that: Any): Boolean = this equals that~ and ~!=~ is
    always the NEGATION of ~equals~.
    =IMPORTANT=
    So individual /classes/ can tailor what ~==~ or ~!=~ means by _overriding the
    ~equals~ method_.

  * Page 379
    footnote 1:
    =from Jian= Summary: All below are about the inconsistency in Java. Scala
    doesn't have those issues.

    + The *ONLY case* where ~==~ does not directly call ~equals~ is for /Java's
      boxed numeric classes/, such as ~Integer~ or ~Long~.
      =IMPORTANT=

      - Reason:
        In Java, a ~new Integer(1)~ does *NOT equal* (=from Jian= Java's ~equals~)
        a ~new Long(1)~ even though for /primitive values/ 1 == 1L.

        * =from Jian=
          Here the book *on purpose* keep using ~new~ instead of the ~.valueOf~
          methods.
          + Use ~new~ for /boxed numeric types/ is _deprecated_ since Java 9.
          + Should use ~.valueOf~ methods on these types, which is cache friendly.
          + Use ~new~ always create new instances of objects in /boxed numeric
            types/. This usage "still works but strongly discouraged; may be
            removed later" in Java 17+.

      - Conclusion:
        =IMPORTANT=
        Since Scala is a more regular language than Java, it was necessary to
        *correct* this discrepancy by special-casing the ~==~ method for these
        /classes/.

    + Likewise, the ~##~ method provides a Scala version of hashing that is the
      same as Java's ~hashCode~, _EXCEPT_ for /boxed numeric types/, where _it
      works CONSISTENTLY with ~==~ in Scala._

      - For instance ~new Integer(1)~ and ~new Long(1)~ hash the same with ~##~
        even though their Java ~hashCode~'s are DIFFERENT. =???=
        * =from Jian=
          =FIXME=
          =???=
          =???=
          When using JDK 17, their ~hashCode~'s are the same!

      - =from Jian=
        ~.##~ can be called from ~null~, and ~.hashCode~ can't be.

- *Multiversal equality*
  Scala 3 introduced "multiversal equality," which can give you a _compiler
  error_ for uses of ~==~ and ~=~ that represent likely bugs, such as comparing
  a ~String~ and an ~Int~ for equality.
  * =TODO= This mechanism will be described in Chapter 23.

- The /root class/ ~Any~ has TWO /subclasses/: ~AnyVal~ and ~AnyRef~.

  * ~AnyVal~ :: the /parent class/ of /value classes/ in Scala.
    + While you can _define your own_ /value classes/ (see _Section 17.4_),

    + there are NINE /value classes/ _built into Scala_:
      - ~Byte~
      - ~Short~
      - ~Char~
      - ~Int~
      - ~Long~
      - ~Float~
      - ~Double~
      - ~Boolean~
      - ~Unit~

    + The first eight of these CORRESPOND TO _Java's primitive types_, and their
      values are represented at run time as _Java's primitive values_.

      - The /instances/ of these /classes/ are all written as /literals/ in Scala.

      - =IMPORTANT=
        You *CANNOT* create /instances/ of these /classes/ using ~new~.
        =from Jian= Useful trick!
        This is enforced by the "trick" that /value classes/ are all defined to be
        both ~abstract~ and ~final~.

    + The other /value class/, ~Unit~, corresponds roughly to /Java's ~void~
      type/.

  * Note that the /value class/ space is *flat*;
    all /value classes/ are (=from Jian= DIRECT) /subtypes/ of ~scala.AnyVal~,
    but *NO* subclass relation betwhen each other.
    + Instead there are /implicit conversions/ between different /value class
      types/.

  * As mentioned in Section 5.10, /implicit conversions/ are also used to add more
    functionality to /value types/.
    For example, many methods can be called from ~Int~ comes from
    ~scala.runtime.RichInt~, and there is an /implicit conversion/ from ~Int~ to
    ~RichInt~.

- ~AnyRef~ :: _in fact_ just an alias for ~class java.lang.Object~.

  So _classes written in Java_, as well as _classes written in Scala_,
  *ALL* inherit from ~AnyRef~.

  * One way to think of ~java.lang.Object~, therefore, is as the way ~AnyRef~ is
    implemented on the Java platform.

    Thus, although you *CAN* use ~Object~ and ~AnyRef~ *INTERCHANGEABLY* in
    Scala programs on the Java platform, _the *RECOMMENDED* style is to use
    ~AnyRef~ everywhere._

  * footnote:
    One reason the ~AnyRef~ alias exists, instead of just using the name
    ~java.lang.Object~, is because Scala was originally designed to work on both
    the Java and .NET platforms.
    + On .NET, ~AnyRef~ was an alias for ~System.Object~.

** DONE 17.2 How primitives are implemented - 382
CLOSED: [2025-04-18 Fri 14:15]
- Q :: How is all this implemented?

- A :: In fact, Scala stores integers in the same way as Java -- as 32-bit words.
       This is important for efficiency on the JVM and also for interoperability
       with Java libraries.

  * Standard operations like addition or multiplication are implemented as
    primitive operations.

  * However, Scala uses the “backup” class ~java.lang.Integer~ whenever an
    integer needs to be seen AS a /(Java) object/.

    + This happens FOR INSTANCE when
      - invoking the ~toString~ method on an integer number or
      - when assigning an integer to a variable of type ~Any~.

      Integers of type ~Int~ are converted *TRANSPARENTLY* to "boxed integers"
      of type ~java.lang.Integer~ _whenever necessary_.

- All this sounds a lot like _/auto-boxing/ in Java_ and it is indeed _quite
  SIMILAR_.

  There's one crucial difference though: _/Boxing/ in Scala_ is *much less
  visible* than _/boxing/ in Java_.

  * For example,
    The equality operation ~==~ in Scala is designed to be *TRANSPARENT* with
    respect to the /type's representation/. For /value types/, it is the
    _NATURAL (numeric or boolean) equality_.

- ~eq~: reference equality check. Its negation is ~ne~.

  For example:
  #+begin_src scala
    val x = new String("abc") // abc
    val y = new String("abc") // abc
    x == y // true
    x eq y // false
    x ne y // true
  #+end_src

** DONE 17.3 Bottom types - 384
CLOSED: [2025-04-18 Fri 14:15]
- At the *BOTTOM* of the /type hierarchy/ in Figure 17.1 you see the TWO /classes/:
  * ~scala.Null~
  * ~scala.Nothing~

  These are _special types_ that handle some *"corner cases"* of /Scala's type
  system/ *in a uniform way.*

- ~Null~
  is the type of the ~null~ /reference/; it is a /subclass/ of EVERY /reference
  class/ (i.e., EVERY /class/ that itself _inherits_ from ~AnyRef~).

  * ~Null~ is *NOT compatible* with /value types/.
    For example,
    #+begin_src scala
      // scala>
      val i: Int = null
      1 |val i: Int = null
        |             ^^^^
        |             Found: Null
        |             Required: Int
    #+end_src

  * footnote 5:
    Scala 3 includes an _option_, ~-Yexplicit-nulls~, which _ENABLES_ an
    EXPERIMENTAL ALTERNATE treatment of ~null~ that aims to track which variables
    *can and cannot be* ~null~.

    + This option be described in Advanced Programming in Scala.
      =TODO=
      =IMPORTANT=

- ~Nothing~
  is at *the VERY bottom* of /Scala's class hierarchy/; it is a /subtype/ of
  EVERY other type.

  * However, there exist *no values* of this type whatsoever.
    + Q :: Why does it make sense to have a type without values?

    + A :: As discussed in Section 7.4,
           one use of ~Nothing~ is that _it signals abnormal termination._

      - For instance, there's the ~error~ method in the ~sys~ object of Scala's
        standard library:
        #+begin_src scala
          def error(message: String): Nothing =
            throw new RuntimeException(message)
        #+end_src

** DONE 17.4 Defining your own value classes - 385
CLOSED: [2025-08-18 Mon 17:18]
=from Jian= See https://docs.scala-lang.org/overviews/core/value-classes.html

=from Jian= This section *DOESN'T mention /universal traits/*.
            See _Advanced Programming in Scala (PrePrint)_ _Section 1.3 The
            AnyVal approach_ for this concept.

Define your own /value classes/ to augment the ones that are built in.

- Like the /built-in value classes/,
  1. an /instance/ of your /value class/ will usually compile to /Java bytecode/
     that does *NOT use* the /wrapper class/.

  2. In contexts where a _wrapper_ is needed, such as with generic code, the
     value will get /boxed/ and /unboxed/ *AUTOMATICALLY*.

- footnote 6:
  Scala 3 also offers /opaque types/, which is more restrictive
  _BUT guarantees the value will *NEVER be boxed*._
  * =NEXT= /Opaque types/ will be described in Advanced Programming in Scala.
    =from Jian=
    The /Opaque types/ chapter explains when to use /value classes/ and when to
    use /opaque types/, and the reason.

- _Only certain_ /classes/ can be made into /value classes/.

  For a /class/ to be a /value class/,
  * it _MUST_ have *EXACTLY ONE parameter* and
    =from Jian=
    Future JVM may relax this restriction, and support /multiple-value value
    classes/.

  * it _MUST_ have *nothing inside it except ~def~'s*.

  Furthermore,
  * *no* other /class/ can extend a /value class/ (they are *implicitly final*),
    and
  * =IMPORTANT= often forget this restriction!
    a /value class/ *CANNOT redefine* ~equals~ or ~hashCode~.

- To define a /value class/, make it a /subclass/ of ~AnyVal~, and put ~val~
  before the one parameter. Here is an example /value class/:
  #+begin_src scala
    class Dollars(val amount: Int) extends AnyVal:
      override def toString = "$" + amount
  #+end_src

  #+begin_src scala
    val money = new Dollars(1_000_000)
    money.amount // 1000000
  #+end_src
  * ~money~, refers to an instance of the /value class/,
    + is of type ~Dollars~ _in Scala source code_,
    + BUT _the compiled Java bytecode_ will use type ~Int~ directly.

*** Avoiding a types monoculture - 386
=FIXME=
=from Jian=
Update this use case and use /value clasess/ built from /primitive types/.

If not using /primitive types/, mostly using /opaque types/ is a better
solution.

- =from the Internet=
  =IMPORTANT=
  In programming, "type monoculture" generally refers to a situation where a
  codebase or system relies heavily on a single, dominant type for data or
  logic, potentially leading to reduced flexibility, maintainability, and
  scalability. This is analogous to monoculture in agriculture where a single
  crop is grown, leading to reduced biodiversity and vulnerabilities.

- Q :: _To get the most benefit from the Scala class hierarchy,_

- A :: try to define a /new class/ for EACH /domain concept/,
  _EVEN WHEN_
    it would be POSSIBLE to reuse the same class for different purposes.
  _EVEN IF_
    such a /class/ is a so-called /tiny type/ *with no methods or fields,*
    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    *defining the additional class is a way to help the compiler be helpful to
    you.*

- Replace
  #+begin_src scala
    def title(text: String, anchor: String, style: String): String =
      s"<a id='$anchor'><h1 class='$style'>$text</h1></a>"
  #+end_src

  with
  #+begin_src scala
    class Anchor(val value: String) extends AnyVal
    class Style(val value: String) extends AnyVal
    class Text(val value: String) extends AnyVal
    class Html(val value: String) extends AnyVal

    def title(text: Text, anchor: Anchor, style: Style): Html =
      Html(
        s"<a id='${anchor.value}'>" +
          s"<h1 class='${style.value}'>" +
          text.value +
          "</h1></a>"
      )
  #+end_src

** DONE 17.5 Intersection types - 388
CLOSED: [2025-04-18 Fri 14:53]
- An /intersection type/ is a /subtype/ of all combinations of its constituent
  /types/.
  * For example,
    type ~B & I & F~ is a /subtype/ of
    + ~B~
    + ~I~
    + ~F~
    + ~B & I~
    + ~B & F~
    + ~I & F~
    + (reflexively of) ~B & I & F~ itself.

- =IMPORTANT=
  /intersection types/ are *COMMUTATIVE*, the order of appearance of types in an
  /intersection type/ *does NOT matter*.

** TODO 17.6 Union types - 389 - =NOTE=
- Scala offers a DUAL to /intersection types/ called /union types/, which
  consist of two or more types joined by pipe (~|~) characters, such as ~Plum |
  Apricot~.

- A /union type/ indicates that an object is an /instance/ of *at least one*
  mentioned /type/.
  * For example,
    an object of type ~Plum | Apricot~ is either an /instance/ of
    + Plum, or
    + Apricot, or
    + both. =from Jian= some type may ~extends Plum with Apricot~

- =IMPORTANT=
  Like /intersection types/, /union types/ are *commutative*.

- Dually to /intersection types/, a /union type/ is a /supertype/ of all
  combinations of its constituent types.
  * *Importantly*, a /union type/ is its constituent types /nearest common
    supertype/, or /least upper bound/.

- The addition of /union and intersection types/ to Scala 3
  _ENSURES_ that
  */Scala's type system/ forms a /mathematical lattice/.*

  * A /lattice/ is a /partial order/ in which any two types have both a unique least
    upper bound, or LUB,and a unique greatest lower bound. In Scala 3, the least
    upper bound of anytwo types is their union; the greatest lower bound is
    their intersection. Forexample, the least upper bound of Plum and Apricot is
    Plum | Apricot.Their greatest lower bound is Plum & Apricot.

- /Union types/ have important implications for the specification and
  implementation of /type inference/ and /type checking/ in Scala. Whereas in
  Scala2, the type inference algorithm had to settle on an approximation of
  the leastupper bound of some pairs of types, whose actual least upper bound
  was thelimit of an infinite series, Scala 3 can simply form a union of those
  types.

- To visualize this, consider the following hierarchy:
  #+begin_src scala
    trait Fruit
    trait Plum extends Fruit
    trait Apricot extends Fruit
    trait Pluot extends Plum, Apricot
  #+end_src
  These four types yield the hierarchy shown in Figure 17.2. Fruit isa
  supertype to both Plum and Apricot, but it is not the nearest
  commonsupertype. Rather, the union type Plum | Apricot is the nearest common
  supertype, or least upper bound, of Plum and Apricot. As shown in
  Figure17.2, this implies that the Plum | Apricot union type is a subtype
  ofFruit. And this is indeed the case, as illustrated here:
  #+begin_src scala
    val plumOrApricot: Plum | Apricot = new Plum {}
    // This compiles fine, because Plum | Apricot <: Fruit
    val fruit: Fruit = plumOrApricot
    // But you cannot use a Fruit where Plum | Apricot is needed

    // scala>
    val doesNotCompile: Plum | Apricot = fruit
    1 |val doesNotCompile: Plum | Apricot = fruit
      |                                     ˆˆˆˆˆ
      |                                Found: (fruit : Fruit)
      |                                Required: Plum | Apricot
  #+end_src

- Dually Pluot is a subtype to both Plum and Apricot, but it is not thenearest
  common subtype. Rather, the intersection type Plum & Apricot isthe nearest
  common subtype, or greatest lower bound, of Plum and Apricot.As shown in
  Figure 17.2, this implies that the Plum & Apricot intersectiontype is a
  supertype of Pluot. And this is indeed the case:
  #+begin_src scala
    val pluot: Pluot = new Pluot {}

    // This compiles fine, because Pluot <: Plum & Apricot
    val plumAndApricot: Plum & Apricot = pluot

    // But you cannot use a Plum & Apricot where Pluot is needed
    // scala>
    val doesNotCompile: Pluot = plumAndApricot
    1 |val doesNotCompile: Pluot = plumAndApricot
      |                            ˆˆˆˆˆˆˆˆˆˆˆˆˆˆ
      |                Found:    (plumAndApricot : Plum & Apricot)
      |                Required: Pluot
  #+end_src

- You can invoke any method or access any field defined on any of the
  constituenttypes of an intersection type. On an instance of Plum & Apricot,
  forexample, you can invoke any methods defined in either Plum or
  Apricot.By contrast, on a union type, you can only access members of
  supertypesthat are common to the constituent types. On an instance of Plum |
  Apricot,therefore, you can access the members of Fruit (including members it
  inheritsfrom AnyRef and Any), but you cannot access any members added
  ineither Plum or Apricot. To access such members, you must perform a
  patternmatch to determine the actual class of the value at runtime. Here’s
  anexample of such a pattern match:
  #+begin_src scala
    def errorMessage(msg: Int | String): String =
      msg match
        case n: Int => s"Error number: ${n.abs}"
        case s: String => s + "!"
  #+end_src
  The errorMessage method’s msg parameter has type Int | String.You could,
  therefore, directly invoke on msg only methods declared on Any,the sole
  common supertype of Int and String. You could not directlyinvoke any other
  methods defined on either Int or String. To access,for example, the abs
  method of Int, or the string concatenation operator(+) of String, you must
  perform a pattern match on msg, as shown in the errorMessage method body. Here
  are some examples of using theerrorMessage method:
  #+begin_src scala
    errorMessage("Oops") // "Oops!"
    errorMessage(-42)    // "Error number: 42"
  #+end_src

** DONE 17.7 Transparent traits - 392
CLOSED: [2025-04-18 Fri 15:50]
- Traits have two main uses:
  * They allow you to define /classes/ through /mixin composition/, and
  * they define /types/.

- Q :: WHY do we need REQUIREMENT?

- A :: Sometimes you may intend a /trait/ to be used
  * primarily as a /mixin/, and
  * *NOT* as a /type/.

  This means sometime you *don't want* _the name of a trait_ to *appear* in
  /inferred types/.

- SOLUTION:
  Declare the /traits/ you only want to use them as /mixins/ with ~transparent~.

- The ~transparent~ modifier ONLY AFFECTS /type inference/.
  You can still _use /transparent traits/ as types_ if you write them out
  *explicitly*.

- In addition to traits _marked EXPLICITLY as ~transparent~,_ Scala 3 will
  treat
  * ~scala.Product~,
  * ~java.lang.Serializable~, and
  * ~java.lang.Comparable~ as ~transparent~ as well.

  Because these /types/ will *never be inferred* in Scala 3, if you really want to
  _use them as types_, you will need to do so through _EXPLICIT /type annotations
  or ascriptions/._

** DONE 17.8 Conclusion - 393
CLOSED: [2025-04-18 Fri 15:54]
In this chapter we showed you
1. The /classes/ at the /top/ and /bottom/ of /Scala's class hierarchy/.

2. HOW to create your own /value classes/, including how to use them
   for "tiny types."

3. /Intersection and union types/, and saw how they turn /Scala's
   type hierarchy/ into a /lattice/.

4. Lastly, how to use the ~transparent~ modifier to prevent Scala's /type
   inference/ algorithm from using _/traits/ designed primarily as /mixins/_ as
   /types/.

=NEXT=
In the next chapter, you'll learn about /type parameterization/.

* TODO 18 Type Parameterization - 394 - =READING=
- In this chapter, we'll
  * Explain the details of /type parameterization/ in Scala.
  * Along the way
    we'll _DEMONSTRATE_ some of the techniques for information hiding introduced
    in Chapter 12 by using a concrete example: _the design of a /class/ for
    *purely functional queues*._

- /Type parameterization/ allows you to
  _write *generic* /classes/ and /traits/._

- Java, for the compatibility reason, allows /raw types/.
  By contrast, Scala supports /type parameters/ from its very beginning and no
  need to support /raw types/.

- /Variance/ defines _inheritance relationships_ of /parameterized types/.

- The chapter contains _THREE parts_:
  1. DEVELOPS
     a data structure for /purely functional queues/.

  2. DEVELOPS
     techniques to *hide* internal representation details of this structure.

  * EXPLAINS
    + /variance of type parameters/ and
    + how it *interacts with* /information hiding/. =TODO: ???=

** DONE 18.1 Functional queues - 394
CLOSED: [2025-07-30 Wed 12:29]
- A /functional queue/ is a data structure with _THREE operations_:
  * ~head~ returns the first element of the queue
  * ~tail~ returns a queue without its first element
  * ~enqueue~ returns a _NEW_ queue with a given element appended at the end

- A /functional queue/ *does NOT change* its contents when an element is appended,
  just return a *new* queue.

- Fully persistent data structures :: old versions remain available even after
  extensions or modifications.

- ONE GOAL:
  * Q :: How can this be implemented efficiently?
  * A :: Ideally, a /functional (immutable) queue/ should _NOT_ have a
         fundamentally higher overhead than an /imperative (mutable) one/.

         That is, all three operations, ~head~, ~tail~, and ~enqueue~, should
         operate in *constant time*.

- Two inspiring but inefficient implementations:
  * backed by an enqueue-order ~List~
    #+begin_src scala
      class SlowAppendQueue[T](elems: List[T]): // Not efficient
        def head = elems.head // constant time
        def tail = new SlowAppendQueue(elems.tail) // constant time
        def enqueue(x: T) = SlowAppendQueue(elems ::: List(x)) // proportional to the number of elements
    #+end_src

  * backed by an reversed-enqueue-order ~List~
    #+begin_src scala
      class SlowHeadQueue[T](smele: List[T]): // Not efficient
        // smele is elems reversed
        def head = smele.last // proportional to the number of elements
        def tail = new SlowHeadQueue(smele.init) // proportional to the number of elements
        def enqueue(x: T) = SlowHeadQueue(x :: smele) // constant time
    #+end_src

- Combine the two inefficient implementations, and split elements in two
  ~List~'s -- ~leading~ and ~trailing~, and the contents of the whole queue are
  at each instant equal to ~leading ::: trailing.reverse~.

  * Listing 18.1 · A basic functional queue.
    #+begin_src scala
      class Queue[T](
        private val leading: List[T],
        private val trailing: List[T]
      ):
        private def mirror =
          if leading.isEmpty then
            new Queue(trailing.reverse, Nil)
          else
            this

        def head = mirror.leading.head

        def tail =
          val q = mirror
          new Queue(q.leading.tail, q.trailing)

        def enqueue(x: T) =
          new Queue(leading, x :: trailing)
    #+end_src
    + The longer the queue gets, the less often ~mirror~ is called.
    + Assuming that ~head~, ~tail~, and ~enqueue~ operations appear with about
      the same frequency, the /amortized complexity/ is hence *constant* for
      each operation. So functional queues are *asymptotically just as efficient
      as mutable ones*.

- Now, there are some *CAVEATS* that need to be attached to this argument.
  1. the discussion was _only about /asymptotic behavior/;_
     the constant factors might well be somewhat different.

  2. the argument rested on the fact that ~head~, ~tail~ and ~enqueue~ are
     called with about the *same frequency* -- FOR INSTANCE, if ~head~ is called
     much more often than the other two operations, the argument is not valid,
     as each call to head might involve a costly re-organization of the list
     with ~mirror~.

     =TODO=
     =IMPORTANT=
     =NEXT=
     The second caveat can be avoided; it is possible to design functional
     queues so that in a sequence of successive ~head~ operations only the first
     one might require a re-organization. You will find out at the end of this
     chapter how this is done.

** DONE 18.2 Information hiding - 397
CLOSED: [2025-07-30 Wed 13:06]
The implementation of ~Queue~ shown in Listing 18.1 is now quite good _with
regards to efficiency._

- Current problems:
  needed is a way to hide this /constructor/ from client code.

*** Private constructors and factory methods - 398
Listing 18.2 · Hiding a primary constructor by making it private.
#+begin_src scala
  class Queue[T] private (
    private val leading: List[T],
    private val trailing: List[T]
  )
#+end_src

and then

use /auxiliary constructor:
#+begin_src scala
  def this() = this(Nil, Nil)

  def this(elems: T*) = this(elems.toList, Nil)
#+end_src

Listing 18.3 · An apply factory method in a companion object.
#+begin_src scala
  object Queue:
    // constructs a queue with initial elements ‘xs'
    def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
#+end_src

*** An alternative: private classes - 399 - =REVIEW=
=IMPORTANT=
=IMPORTANT=
=IMPORTANT=
This exposes to clients the same information as before, but using a different
technique.

_INSTEAD OF_ hiding individual constructors and methods,
this version *hides the WHOLE implementation /class/.*

Listing 18.4 · Type abstraction for functional queues.
#+begin_src scala
  trait Queue[T]:
    def head: T
    def tail: Queue[T]
    def enqueue(x: T): Queue[T]

  object Queue:
    def apply[T](xs: T*): Queue[T] =
      QueueImpl[T](xs.toList, Nil)

    private class QueueImpl[T](
      private val leading: List[T],
      private val trailing: List[T]
    ) extends Queue[T]:
      def mirror =
        if leading.isEmpty then
          QueueImpl(trailing.reverse, Nil)
        else
          this

      def head: T = mirror.leading.head

      def tail: QueueImpl[T] =
        val q = mirror
        QueueImpl(q.leading.tail, q.trailing)

      def enqueue(x: T) =
        QueueImpl(leading, x :: trailing)
#+end_src

** DONE 18.3 Variance annotations - 400
CLOSED: [2025-05-15 Thu 12:42]
- ~Queue~ is a /type constructor/, or called /higher kinded type/ or /generic
  trait/.

- /Classes/ and /traits/ that take /type parameters/ are *generic*, _BUT_ the
  /types/ they generate are *parameterized*, NOT *generic*. =IMPORTANT=
  * The term _"generic"_ means that you are defining many specific /types/ with
    one _generically written_ /class/ or /trait/.

- The COMBINATION of /type parameters/ and /subtyping/ poses some interesting
  questions.
  * For example,
    + Q :: if ~S~ is a /subtype/ of /type/ ~T~, then should ~Queue[S]~ be
      considered a /subtype/ of ~Queue[T]~?

    + A :: If so, you could say that
      - /trait/ ~Queue~ is /covariant/ in its /type parameter/ ~T~.
      - Or, since it just has one /type parameter/, you could say simply that
        ~Queue~'s are /covariant/.

- In Scala, /generic types/ have _by default_ *nonvariant* (or "rigid")
  /subtyping/.

- Prefixing a /formal type parameter/ with a ~+~ indicates that /subtyping/ is
  /covariant/ _in that parameter_.
  #+begin_src scala
    trait Queue[+T] { ... }
  #+end_src
  * The _compiler_ will *check* that ~Queue~ is defined in a way that
    _this /subtyping/ is /sound/._

- /cotravariant subtyping/

- variance :: whether a /type parameter/ is /covariant/, /contravariant/, or
  /nonvariant/.

- variance annotations :: the + and - symbols you can place next to /type
  parameters/.

- =STARTING HERE=
  In a purely functional world, many types are naturally /convariant/.
  =from Jian= Of course, you need the /variance annotations/.
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  _However, the situation changes once you introduce *mutable* data._

  * Example:
    Listing 18.5 · A nonvariant (rigid) ~Cell~ class.
    #+begin_src scala
      class Cell[T](init: T):
        private var current = init
        def get = current
        def set(x: T) =
          current = x
    #+end_src
    + Assume we can mark the ~Cell~ /covariant/ on ~T~.
      _Actually, *CANNOT COMPILE*!!_!

      If this is workable, the following *PROBLEMATIC* statement sequence:
      #+begin_src scala
        val c1 = new Cell[String]("abc")
        val c2: Cell[Any] = c1
        c2.set(1)
        val s: String = c1.get
      #+end_src
      1. Every line by itself look good.
      2. _BUT_ taken together, there four lines end up assigning the integer ~1~
         to the string ~s~. _This is clearly a violation of /type soundness/._

    + Q :: Which operation is to blame for the runtime fault?
    + A :: _It must be the second one, which uses /covariant subtyping/._
      The other statements are too simple and fundamental.

      Thus, a ~Cell~ of ~String~ is *NOT* also a ~Cell~ of ~Any~,
      _BECAUSE_
      there are things
        you can do with a ~Cell~ of ~Any~
      that
        you cannot do with a ~Cell~ of ~String~:
        You *cannot* use ~set~ with an ~Int~ argument on a ~Cell~ of ~String~,
      for example.
      * In fact, were you to pass the covariant version of ~Cell~ to the Scala
        compiler, you would get a compile-time error:
        #+begin_src scala

        #+end_src
        #+begin_src text
          4 |    def set(x: T) =
            |            ˆˆˆˆ
            |    covariant type T occurs in contravariant position
            |    in type T of value x
        #+end_src

*** Variance and arrays - 403 - =REVIEW=
=IMPORTANT=
=IMPORTANT=
=IMPORTANT=
- /Arrays/ are treated as /covariant/ in _Java_.
  * some operations can compile but lead to runtime error.

- Q :: Why Java uses this /covariant/ design for /arrays/?
- A :: James Gosling, the principal inventor of the Java language, answered that
  they wanted to have a simple means to _treat arrays generically_ (=from Jian=
  before /generics/ was introduced).
  * For instance,
    #+begin_src java
      void sort(Object[] a, Comparator cmp) { ... }
    #+end_src
    /Covariance/ of _arrays_ was needed
    SO THAT
    _arrays_ of ARBITRARY /reference types/ could be passed to this ~sort~
    method.
    + With /generics/, the implementation of this menthod doesn't need
      /covariance/. *For compatibility reasons,* thought, it has persisted in
      Java to this day.

- Scala treat its /arrays/ as /nonvariant (rigid)/, which is different from
  /Java's arrays/.
  * It should be rare, but sometimes it is necessary to interact with _legacy
    methods_ in Java that use an ~Object~ array as a means to emulate a /generic
    array/. You can do
    #+begin_src scala
      val a1 = Array("abc")

      // val a2: Array[Any] = a1
      /// 1 |val a2: Array[Any] = a1
      ///   |                     ˆˆ
      ///   |                     Found: (a1 : Array[String])
      ///   |                     Required: Array[Any]

      val a2: Array[Object] = a1.asInstanceOf[Array[Object]]
    #+end_src

    The /cast/ is _always legal at compile-time,_ and
    =from Jian= because no restriction to this kind of /cast/.

    it will _always succeed at runtime_
    BECAUSE *the JVM's underlying run-time model treats _arrays_ as /covariant/*,
    just as Java the language does.

    + But you might get ~ArrayStore~ /exceptions/ afterwards, again _just as you
      would in Java._

    =from Jian= This is a good INTERVIEW QUESTION!!!
    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=

** TODO 18.4 Checking variance annotations - 405
- So far, all _VIOLATIONS_ of /type soundness/ involved some _reassignable
  field_ or array element.
  * _HOWEVER_,
    _reassignable fields_ are a _SPECIAL CASE_ of the rule that
    DISALLOWS /type parameters/ annotated with + from being used as /method
    parameter types/.

- *The fast track*
  Below are the details. If you don't care, just skip it. The compiler can help
  you.
  =from Jian=
  However, these details are useful for library developers!!!

- =IMPORTANT=
  To
  _VERIFY correctness of variance annotations,_
  the Scala compiler classifies all positions in _a class or trait body_ as
  * positive
  * negative
  * neutral

** TODO 18.5 Lower bounds - 408
** TODO 18.6 Contravariance - 409
** DONE 18.7 Upper bounds - 413
CLOSED: [2025-05-15 Thu 23:59]
Listing 18.11 · A merge sort function with an upper bound.
#+begin_src scala
  def orderedMergeSort[T <: Ordered[T]](xs: List[T]): List[T] =
    def merge(xs: List[T], ys: List[T]): List[T] =
      (xs, ys) match
        case (Nil, _) => ys
        case (_, Nil) => xs
        case (x :: xs1, y :: ys1) =>
          if x < y then x :: merge(xs1, ys)
          else y :: merge(xs, ys1)

    val n = xs.length / 2
    if n == 0 then xs
    else
      val (ys, zs) = xs.splitAt(n)
      merge(orderedMergeSort(ys), orderedMergeSort(zs))
#+end_src

This works, but not the most general way in Scala to design a sort function.
It can't sort ~Int~, which is not a /subtype/ of ~Ordered[Int]~.

=NEXT=
Section 21.4 uses the /given parameters/ and /typeclasses/ way.

** DONE 18.8 Conclusion - 415 - =REIVEW= =DOUBLE CHECK=
CLOSED: [2025-05-16 Fri 00:04]
In this chapter you saw several _TECHNIQUES_ for /information hiding/:
- /private constructors/,
- /factory methods/,
- /type abstraction/, and
- /object private members/.

You ALSO learned
1. how to specify data /type variance/ and
2. what it implies _for /class/ implementation_.
3. Finally, you saw a TECHNIQUE that helps in OBTAINING _FLEXIBLE /variance/
   annotations_: /lower bounds/ for method /type parameters/.
   * =from Jian=
     =TODO=
     =REVIEW=
     For /method parameters/, which are at the negative position, to make
     methods general on the /method parameters/ types, ONLY /lower bounds/ need
     to be considered!

=NEXT= In the next chapter, we'll turn our attention to enums.

* DONE 19 Enums - 416 - =REVIEW=
CLOSED: [2025-04-17 Thu 21:44]
Scala 3 introduced the ~enum~ construct to make the definition of
/sealed case class hierachies/ _more concise_.

- /Enums/ can be used to define both /enums/ (enumerated data types) in
  mainstream OO languages, and /enums/ (algebraic data types) in FP languages.

** DONE 19.1 Enumerated data types - 416
CLOSED: [2025-04-17 Thu 19:53]
- footnote 1:
  Although "enum" is a more common short name for /enumerated data types/, we
  will use /EDT/ in this book because the /enum construct in Scala/ is also used
  to define /algebraic data types/, which are called /ADTs/.

- An /enumerated data type (EDT)/ is useful when you want a type that's
  _restricted to_ a _FINITE set of /named values/._

  These named values are called _the cases of the EDT._
  #+begin_src scala
    enum Direction:
      case North, East, South, West
  #+end_src
  * =from Jian=
    I'd like to use the term _enum variants_ instead of _enum cases_.

  * This simple ~enum~ will generate a ~sealed class~ named ~Direction~ with a
    /companion object/ containing the four values declared as ~val~'s.
    The ~val~'s, named ~North~, ~East~, ~South~, and ~West~, will have /type/
    ~Direction~. Given this definition, you could, for example, define a method
    to ~invert~ a compass direction using a /pattern match/, as shown here:
    #+begin_src scala
      import Direction.{North, South, East, West}

      def invert(dir: Direction): Direction =
        dir match
          case North => South
          case East => West
          case South => North
          case West => East
    #+end_src

- footnote 2: The /sealed class/ is called the "enum type."

- /Enumerated data types/ are called _"enumerated"_ because the compiler
  *associates* an ~Int~ /ordinal/ to each case.

  * The /ordinal/ starts at ~0~ and increases by one for each case,
    in the order the cases are defined in the enum. You can access the /ordinal/
    via a method named ~ordinal~, which the *compiler generates for each EDT.*
    For example:

- ~enum~'s build-in methods:
  * ~ordinal~: start at 0 and increases by one for each case, in the order the
    cases are defined in the /enum/.
    + The REASON why /Enumerated data types/ are called "enumerated":
      the compiler associates an ~Int~ /ordinal/ to each /case/ of /EDT/.

    #+begin_src scala
      North.ordinal // 0
      East.ordinal  // 1
      South.ordinal // 2
      West.ordinal  // 3
    #+end_src

  * ~values~: returns an ~Array[YourEnumType]~ containing all of the /EDT/'s
    cases, in declaration order.

  * ~valueOf~: Convert a /string/, which is *exactly* the same as an enum case
    name, to that /enum value/.

- Give an EDT value parameter(s):
  #+begin_src scala
    enum Direction(val degrees: Int):
      case North extends Direction(0)
      case East  extends Direction(90)
      case South extends Direction(180)
      case West  extends Direction(270)
  #+end_src

- You can define a /method/ inside a /enum/:
  #+begin_src scala
    enum Direction(val degrees: Int):
      case North extends Direction(0)
      case East  extends Direction(90)
      case South extends Direction(180)
      case West  extends Direction(270)

      def invert: Direction =
        this match
          case North => South
          case East  => West
          case South => North
          case West  => East
  #+end_src
  * =TODO= NOTE

- _One *restriction* of enums:_
  _CANNOT_ define /methods/ for the /individual cases/.

  Instead, you must declare any methods as members of _the /enum type/ ITSELF_,
  which will make those methods _available on all of the enum's cases._

  * footnote 3:
    You could define /extension methods/ for the /case types/,
    _BUT_
    it might be better in that situation to just write out the /sealed case class
    hierarchy/ *BY HAND*.

- *Integration with Java enums*
  #+begin_src scala
    enum Direction extends java.lang.Enum[Direction]:
      case North, East, South, West
  #+end_src

  Then you can all /Java enums methods/ on these values. For instance,
  #+begin_src scala
    Direction.East.compareTo(Direction.South) // -1
  #+end_src

** DONE 19.2 Algebraic data types - 420
CLOSED: [2021-03-03 Wed 00:53]
- Algebraic Data Type (ADT) :: a data type composed of a finite set of cases.

- =IMPORTANT=
  /ADTs/ are
  a natural way to express /domain models/ in which you model the data case by
  case.
    Each case represents one "data constructor," a particular way to construct
  an instance of the type.

- In Scala, a sealed family of case classes forms an ADT so long as *at least one
  of the cases takes parameters.*
  * footnote 4:
    _BY COMPARISON_,
    an /EDT/ is a sealed family of case classes in which none of the cases take
    parameters

- An ADT example:
  #+begin_src scala
    enum Eastwood[+G, +B]:
      def map[G2](f: G => G2): Eastwood[G2, B] =
        this match
          case Good(g) => Good(f(g))
          case Bad(b) => Bad(b)
          case Ugly(ex) => Ugly(ex)

      case Good(g: G)
      case Bad(b: B)
      case Ugly(ex: Throwable)
  #+end_src

- Algebraic Data Type (ADT) :: a data type composed of a finite set of cases.

- In Scala, a _sealed_ family of /case classes/ forms an /ADT/
  so long as *AT LEAST _ONE_ of the cases take parameters.*
  * footnote:
    By comparison,
    an EDT is a _sealed_ family of /case classes/ in which *NONE of the cases
    take parameters.*

- When you create a case of an /ADT/ by using its /factory method/ (=from Jian=
  the ~apply~ /method/), the compiler will *widen* its type to the more general
  ~enum~ type.
  * If you want the more specific type, use the constructor (~new~ it).

- /ADT/'s can be *recursive*.
  * =from Jian=
    /EDT/'s can never be recursive, because *NONE of the cases take parameters.*

- Example:
  #+begin_src scala
    enum Seinfeld[+E]:
      def ::[E2 >: E](o: E2): Seinfeld[E2] = Yada(o, this)

      case Yada(head: E, tail: Seinfeld[E])
      case Nada

    val xs = 1 :: 2 :: 3 :: Nada
    // val xs = Yada(1, Yada(2, Yada(3, Nada)))
  #+end_src

  The compiler will generate a /case class/ in the /companion object/ of the
  /enum type/. =from Jian= Remember? /EDT/ generate values.
  #+begin_src scala
    // Generated sealed trait (the "enum type")
    sealed trait Eastwood[+G, +B]

    object Eastwood: // Generated companion object
      // Generated case classes
      case class Good[+G, +B](g: G) extends Eastwood[G, B]
      case class Bad[+G, +B](b: B) extends Eastwood[G, B]
      case class Ugly[+G, +B](ex: Throwable) extends Eastwood[G, B]
  #+end_src
  * =IMPORTANT=
    Although the /result type/ of the /factory method/ created by the /case
    classes/ will be the SPECIFIC /case class types/, _the compiler will *widen*
    those to the more general enum type._

    + =IMPORTANT=
      If you need the _more specific type_ for a /case/, you can construct
      an instance with ~new~ instead of the generated /factory method/.
      #+begin_src scala
        Good(42) // val res0: Eastwood[Int, Nothing] = Good(42)

        new Good(1) // val res1: Good[Int, Nothing]
      #+end_src

- =IMPORTANT=
  */ADTs/ can be /recursive/*.
  * An example (linked list):
    #+begin_src scala
      enum Seinfeld[+E]:
        def ::[E2 >: E](o: E2): Seinfeld[E2] = Yada(o, this)
        case Yada(head: E, tail: Seinfeld[E])
        case Nada
    #+end_src

** DONE 19.3 Generalized ADTs - 422
CLOSED: [2025-04-17 Thu 20:32]
- Generalized Algebraic Data Types (GADTs) :: /ADTs/ in which the /sealed trait/
  takes a /type parameter/ that is filled in by the cases.

- Example:
  #+begin_src scala
    enum Literal[T]:
      case IntLit(value: Int)         extends Literal[Int]
      case LongLit(value: Long)       extends Literal[Long]
      case CharLit(value: Char)       extends Literal[Char]
      case FloatLit(value: Float)     extends Literal[Float]
      case DoubleLit(value: Double)   extends Literal[Double]
      case BooleanLit(value: Boolean) extends Literal[Boolean]
      case StringLit(value: String)   extends Literal[String]
  #+end_src
  The ~Literal~ /enum/ represents a /GADT/ because it takes a /type parameter/
  ~T~, which is specified by EACH of its cases in their _extends clauses_.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =from Jian: This is why GADT, as a kind of /ADT/ special cases, need this
              specific section to describe!=
  This kind of /sealed type heirarchy/ is given the special name "generalized ADT"
  _BECAUSE_
  _it presents *SPECIAL CHALLENGES to /type checking and inference/*._

- Here's an illustrative example:
  #+begin_src scala
    import Literal.*

    def valueOfLiteral[T](lit: Literal[T]): T =
      lit match
        case IntLit(n)     => n
        case LongLit(m)    => m
        case CharLit(c)    => c
        case FloatLit(f)   => f
        case DoubleLit(d)  => d
        case BooleanLit(b) => b
        case StringLit(s)  => s
  #+end_src
  The ~valueOfLiteral~ /method/ passes the /type checker/, despite none of
  it /match alternatives/ resulting in _the REQUIRED /result type/,_ ~T~.
  * For example,
    the ~case IntLit(n)~ alternative results in ~n~, which has type ~Int~.
    The challenge is that ~Int~ is not type ~T~, nor is ~Int~ a /subtype/ of ~T~.
      This /type checks/ only because the compiler notices that for the
    ~IntLit~ case, ~T~ can be none other than ~Int~.

  * Moreover, this _MORE SPECIFIC_ /type/ is propagated back to the caller.
    #+begin_src scala
      valueOfLiteral(BooleanLit(true))  // true: Boolean
      valueOfLiteral(IntLit(42))        // 42: Int
    #+end_src

** DONE 19.4 What makes ADTs algebraic - 423 - =IMPORTANT=
CLOSED: [2025-04-17 Thu 21:44]
/ADTs/ are called "algebraic" because they represent an application of
_algebraic theory to /types/._

- One way to observe this connection with mathematics is
  BY _mapping each /type/ to its /cardinality/.
  * cardinality :: a count of the inhabitants of that /type/.

- If you think of /types/ as _representing sets of values,_
  then
  the /cardinality of a type/ is the /cardinality (the number of elements) of
  that corresponding set of values/.

  * For example,
    + The /cardinality/ of ~Boolean~: 2 (2 values: ~true~ and ~false~)
    + The /cardinality/ of ~Unit~: 1 (1 value: ~()~)

- The /cardinality/ of /sum types/:
  SUM /cardinalities/ of each cases (variants).
  * Example:
    #+begin_src scala
      enum Hope[+T]:
        case Glad(o: T)
        case Sad
    #+end_src
    If ~T~ is ~Boolean~, the /cardinality/ of ~Hope[Boolean]~ is 3, which comes
    from 2 (/cardinality/ of ~Glad[Boolean]~) + 1 (/cardinality/ of ~Sad~).

  * More examples:
    Table 19.1 · The cardinality of ~Hope~

- The /cardinality/ of /product types/:
  MULTIPLY /cardinalities/ of each cases (variants).
  * Example:
    #+begin_src scala
      case class Both[A, B](a: A, b: B)
    #+end_src
    If ~A~ is ~Boolean~ and ~B~ is ~Unit~, the /cardinality/ of
    ~Both[Boolean, Unit]~ is 2, which comes from 2 (/cardinality/ of
    ~Boolean~) * 1 (/cardinality/ of ~Unit~).

  * More examples:
    Table 19.2 · The cardinality of ~Both~

- =IMPORTANT=
  Generally, /algebraic data types/ represent
  */sums/ of /products/*,

  * An /EDT/ is a special case of /ADT/
    where *each /product type/ is a /singleton/.*

- One of the benefits of understanding the _algebraic properties_ of your data
  structures:
  you can RELY ON the relevant _mathematical laws_ to *prove properties about your
  code.*

  * For example,
    you might be able to prove that certain refactorings will preserve the
    meaning of your program.

- /ADT cardinalities/ _obey laws_ regulating /addition/ and /multiplication/,
  such as /identity/, /commutativity/, /associativity/, and /distributivity/.

  * =IMPORTANT=
    In general, /functional programming/ often offers opportunities for you to
    *gain insight into your code from branches of mathematics.*

** DONE 19.5 Conclusion - 427
CLOSED: [2025-04-17 Thu 20:45]
- In this chapter,
  1. You learned about /Scala's enums/, _a concise way to define /sealed case
     class hierarchies/ that form /enumerated and algebraic data types/._

  2. You
     * learned that in Scala, /EDTs/ and /ADTs/ form two ends of the same
       spectrum, and
     * looked at the _algebra of algebraic data types_.

- /Scala's enum construct/
  * makes A COMMON IDIOM for _functional data modeling_ CONCISE, and
  * indicates that /EDTs/ and /ADTs/ are _IMPORTANT patterns_.

* DONE 20 Abstract Members - 428 - =REVIEW= =CASE-STUDY= =NOTE=
CLOSED: [2025-05-07 Wed 15:12]
- A /member/ of a /class/ or /trait/ is *abstract*
  IF the /member/ does _NOT have a complete definition_ in the /class/ or
  /trait/.

  * /Abstract members/ are intended to be implemented in /subclasses/ of the
    /class/ in which they are declared.

    This idea is found in many object-oriented languages.

- For instance,
  1. _Java_ lets you declare /abstract methods/.

  2. _Scala_ goes beyond that and implements the idea in its full generality:
     Besides methods, you can declare /abstract fields/ and even /abstract
     types/ as members of /classes/ and /traits/.

- In this chapter we'll describe all four kinds of abstract member:
  * ~val~'s
  * ~var~'s
  * ~method~'s
  * ~type~'s

  Along the way we'll discuss
  * /trait parametric fields/
  * ~lazy val~'s
  * /path-dependent types/

** DONE 20.1 A quick tour of abstract members - 428
CLOSED: [2025-05-07 Wed 13:03]
Example:
#+begin_src scala
  trait Abstract:
    type T
    def transform(x: T): T
    val initial: T
    var current: T
#+end_src

** DONE 20.2 Type members - 429
CLOSED: [2025-05-07 Wed 13:12]
=from Jian= I think this can be improved!

- Possible reasons of using a /type member/:
  * define a short, descriptive _alias_ for a /type/ whose real name is more verbose,
    or less obvious in meaning, than the alias.

  * declare /abstract types/ that must be defined in /subclasses/.
    =TODO=
    This use, which was demonstrated in the previous section, will be described
    in detail later in this chapter.

- =from Jian=
  Should compare /abstract type members/ with class/trait /type parameters/.

** DONE 20.3 Abstract ~val~'s - 430
CLOSED: [2025-05-07 Wed 13:33]
- =from Jian=
  =FIXME= The book should have an overview like this:

  "Scala has *NO restriction* like "you can implement an abstract member only by
  its same type of concrete members." Of course, you can't do whatever you want
  in all scenarios. See below for discussion and explanation."

  Or else, cognitive inertia can make people confused!

- Code:
  #+begin_src scala
    val initial: String
  #+end_src

  or
  #+begin_src scala
    def initial: String
  #+end_src
  Client code would refer to both the ~val~ and the /method/ in exactly the same
  way. _HOWEVER_,
  * if ~initial~ is an ~abstract val~,
    the client is guaranteed that ~obj.initial~ will yield the *SAME value EVERY
    time it is referenced.*

  * if ~initial~ were an ~abstract method~, that guarantee would *NOT HOLD*
    because, in that case, ~initial~ could be implemented by a /concrete method/
    that _returns a DIFFERENT value every time it's called._

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  From the explanation above, you know
  * ~abstract val~ can only be implemented with concrete ~val~ definitions.

  * ~abstract def~ can be implemented by both /concrete method definitions/ and
    concrete ~val~ definitions.

** DONE 20.4 Abstract ~var~'s - 430
CLOSED: [2025-05-07 Wed 14:14]
- Illustration example:
  Listing 20.2 · Declaring abstract vars.
  #+begin_src scala
    trait AbstractTime:
      var hour: Int
      var minute: Int
  #+end_src

- =IMPORTANT=
  ~var~'s declared as members of /classes/ come equipped with /getter/ and
  /setter/ methods. *This holds for ~abstract var~'s as well*.

  The code above is equivalent to
  #+begin_src scala
    trait AbstractTime:
      def hour: Int
      def hour_=(x: Int): Unit
      def minute: Int
      def minute_=(x: Int): Unit
  #+end_src

  This means when implementing it, it is not necessary for us to define to ~var~'s.
  There are multiple ways to fulfill the requirement of this /trait/.
  Here is a legal implementation:
  #+begin_src scala
    import scala.compiletime.uninitialized

    class Time:
      var h: Int = uninitialized
      var minute: Int = uninitialized

      def hour: Int = h
      def hour_=(x: Int): Unit =
        h = x
  #+end_src

** TODO 20.5 Initializing abstract ~val~'s - 432 - =REVIEW= =NOTE=
*** DONE Trait parametric fields - 434
CLOSED: [2025-05-07 Wed 14:40]
/Trait parametric fields/, lets you compute _values for fields_ of a /trait/
_BEFORE_
the /trait/ itself is initialized.

- =from Jian= Learn more from _the Chapter 11 Traits_.

*** TODO Lazy vals - 435

** DONE 20.6 Abstract types - 439
CLOSED: [2025-05-07 Wed 15:00]
- The rest of this chapter DISCUSSES
  * what such an /abstract type declaration/ means and
  * what it's good for.

- Example:
  #+begin_src scala
    class Food

    abstract class Animal:
      def eat(food: Food): Unit
  #+end_src

  * You can't
    #+begin_src scala
      class Grass extends Food

      class Cow extends Animal:
        override def eat(food: Grass) = {} // This won't compile
    #+end_src
    + If you can, code pass typechecker but can have logic error can be built
      like:
      #+begin_src scala
        class Food
        abstract class Animal:
          def eat(food: Food): Unit

        class Grass extends Food
        class Cow extends Animal
          override def eat(food: Grass) = {} // This won't compile,
                                             // but if it did,...

        class Fish extends Food
        val bessy: Animal = new Cow
        bessy.eat(new Fish)      // ...you could feed fish to cows.
      #+end_src

  * The right way (use /abstract type/):
    #+begin_src scala
      class Food
      abstract class Animal:
        type SuitableFood <: Food
        def eat(food: SuitableFood): Unit

      class Grass extends Food
      class Cow extends Animal:
        type SuitableFood = Grass
        override def eat(food: Grass) = {}
    #+end_src
    + Now you can't feed ~Fish~ to ~Cow~ as expected!

** TODO 20.7 Path-dependent types - 441 - =REVIEW= =NOTE=
** TODO 20.8 Refinement types - 444
** TODO 20.9 Case study: Currencies - 445
** TODO 20.10 Conclusion - 453

* DONE 21 Givens - 455 - =NOTE=
CLOSED: [2025-05-07 Wed 20:57]
- OFTEN
  the behavior of a function _depends on the context_ in which the function
  is called.

  * For example,
    a function's behavior may _DEPEND ON contextual data_
    such as
    system properties,
    security permissions,
    an authenticated user,
    a database transaction, or
    a configured timeout.

- A function may also _DEPEND ON_ contextual behavior -- an algorithm that makes
  sense in the context where the function is called.

  * For example,
    a sort function may rely on a _comparison algorithm_ to determine how to order
    elements while sorting.
    DIFFERENT /contexts/ may call for DIFFERENT /comparison algorithms/.

- Many techniques exist for getting such contextual information and behavior to
  a function, but functional programming has traditionally had one answer: pass
  everything as parameters.

  * *UNFORTUNATELY*,
    passing everything in as parameters can quickly
    _LEAD TO_
    repetitive, boilerplate code.

- This chapter describes /context parameters/, which are often simply called
  /givens/.

** DONE 21.1 How it works - 455
CLOSED: [2025-05-07 Wed 15:42]
=IMPORTANT=
Because the compiler selects /context parameters/ *by matching types of
parameters* against /types/ of /given instances/,
/context parameters/ should have *"rare" or "special" enough types* that
accidental matches are unlikely.

** DONE 21.2 Parameterized given types - 459
CLOSED: [2025-05-07 Wed 16:04]
=FIXME=
type classes => typeclasses

/Context parameters/ are perhaps _MOST OFTEN used to_ provide information about
a /type/ mentioned explicitly in an _earlier parameter list_, similar to the
/typeclasses/ of Haskell.

This is an important way to achieve /ad hoc polymorphism/ when writing functions
in Scala.

- =IMPORTANT=
  A good _HOME_ for "natural" givens:
  the /companion object/ of _an "involved" type_.

  =TODO=
  =REPHRASE=
  * For example,
    a good home for a natural given instance of ~Ord[Int]~ would be the
    /companion object/ for either ~Ord~ or ~Int~, the two types that are
    _"involved" in type ~Ord[Int]~._

    + IF the compiler does not find a ~given Ord[Int]~ in /lexical scope/,
      it will as a second step look in those two /companion objects/.

      Since you _can't change_ the ~Int~ /companion/, the best home is in the
      ~Ord~ /companion/.

- Alias given ::
  #+begin_src scala
    given intOrd: Ord[Int] =
      new Ord[Int]:
        def compare(x: Int, y: Int) =
          if x == y then 0 else if x > y then 1 else 1
  #+end_src

  shorthand:
  #+begin_src scala
    given intOrd: Ord[Int] with
      def compare(x: Int, y: Int) =
        if x == y then 0 else if x > y then 1 else 1
  #+end_src

- =TODO= Learn more details about the Scala compiler transformation behavior!!!

  * If a given declaration does _not take value parameters_:
    then that /given/ is initialized the first time it's accessed, similar to a
    ~lazy val~. That initialization is performed *in a thread-safe manner*.

  * If a /given/ _does take parameters_:
    then a *new* /given/ is created on _EVERY access_, much like how a ~def~
    behaves.

  Indeed, the Scala compiler
  _TRANSFORMS_ /givens/ _TO_ ~lazy val~'s or ~def~'s, additionally marking them
  as being available for /using parameters/.

** DONE 21.3 Anonymous givens - 464
CLOSED: [2025-05-07 Wed 16:16]
Although you can think of a /given declaration/ as a special kind of ~lazy val~
or ~def~, /givens/ *differ from* these _in an important aspect._

- In code ~val age = 42~,
  you provide a /term/, ~age~, and, based the value, the compiler inferred the
  /type/ of that /term/, ~Int~.

- With /context parameters/, it _goes the other way_:
  You provide a /type/, and the compiler *synthesizes* a /term/ for you to
  represent that /type/, based on the available /givens/, and uses that /term/
  implicitly when the /type/ is required.

  That is referred to as /term inference/, to distinguish it from /type
  inference/.

  * Because mostly we care about the /term/ of /givens/ instead of its name,
    syntax for /anonymous givens/ is provided:
    #+begin_src scala
      given Ord[Int] with
        def compare(x: Int, y: Int) =
          if x == y then 0 else if x > y then -1 else 1
    #+end_src

** TODO 21.4 Parameterized givens as typeclasses - 465 - =TODO= =NOTE=
- Add =NOTE=

- anonymous parameter :: xxx

** DONE 21.5 Given imports - 468
CLOSED: [2025-05-07 Wed 20:06]
Providing /given values/ in the /companion object/ of a /class/ means that those
/givens/ will be available for lookup.

That is a good practice for _reasonable default behavior_ for a /given/ that
users would likely *ALWAYS want,* such as providing a /natural ordering/ for a
/type/.

=IMPORTANT=
Otherwise, it is good practice to place /givens/ in /singleton objects/ that
_will NOT BE FOUND AUTOMATICALLY,_ thereby requiring users to invite these
/givens/ in with an ~import~ when they want them.

_To make it easier to discern where /givens/ are coming from, Scala provides a
*special import syntax* for /givens/._

- /Regular wildcard import/ does _NOT_ import /givens/.

- Import /givens/:
  * import by the names of /givens/: ~import TomsPrefs.prompt~
  * /wildcard given import/: ~import TomsPrefs.given~
  * import by /types/: ~import TomsPrefs.{given PreferredDrink}~
  * import both ~prefPromptOrd~ and ~prefDrinkOrd~ by type:
    #+begin_src scala
      import TomsPrefs.{given Ordering[PreferredPrompt],
        given Ordering[PreferredDrink]}
    #+end_src

    or

    #+begin_src scala
      import TomsPrefs.{given Ordering[?]}
    #+end_src

** DONE 21.6 Rules for context parameters - 469
CLOSED: [2025-05-07 Wed 20:27]
- /Context parameters/ are governed by the following general rules:

  * *Marking rule*: Only definitions marked ~given~ are available.

  * *Visibility rule*: An inserted /given instance/ must be *in scope* as a
    *SINGLE* identifier, or _be associated with a type_ that is involved in the
    /parameter type/*
    + The *visibility rule* helps with /modular reasoning/.

      When you read code in a file, the _ONLY_ things you need to consider from
      other files are those that are EITHER /imported/ OR are _explicitly
      referenced_ through a fully qualified name.

  * *Explicits-first rule*: Whenever code type checks as it is written, no
    /givens/ are attempted.

*** Naming a given - 471

** DONE 21.7 When multiple givens apply - 472
CLOSED: [2025-05-07 Wed 20:45]
=IMPORTANT=
=IMPORTANT=
=IMPORTANT=

- Whenever _MULTIPLE_ /givens/ could be applied, the compiler will REFUSE to
  choose between them -- _UNLESS_ one is *more specific* than the other.
  * Just like /method overloading/.
  * The idea is that whenever there is a reason to believe a programmer would
    always choose one of the givens over the others, don't require the
    programmer to write it explicitly.

- To be more precise, one /given/ is *more specific* than another if one of the
  following applies:
  * The /type/ of the former is a /subtype/ of the latter's.
  * The /enclosing class/ of the former ~extends~ the /enclosing class/ of the
    latter.

- If you have _TWO_ /givens/ that could be AMBIGUOUS,
  BUT
  for which there is an obvious first and second choice,
  you can place the second choice in /a "LowPriority" trait/ and the first
  choice in a /subclass/ or /sub-object/ of that /trait/.

  * The first choice will be taken by the compiler if it is applicable,
    even if the _lower priority choice_ would otherwise be ambiguous.

  * If the /higher priority given/ is not applicable, but the /lower priority
    given/ is, the compiler will use the /lower priority given/.

- =from Jian=
  =TODO=
  =TODO=
  =TODO=
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  NEED more examples!!!
  Do experiments!!!
  Learn from the standard library /low priority traits/.

** DONE 21.8 Debugging givens - 474
CLOSED: [2025-05-07 Wed 20:53]
=IMPORTANT=
=IMPORTANT=
=IMPORTANT=

- When you are debugging a program, it can sometimes help to see what /givens/
  the compiler is inserting. The ~-Xprint:typer~ option to the compiler is
  useful for this.
  * If you run ~scalac~ with this option, the compiler will
    *show you what your code looks like*
    AFTER ALL /givens/ have been added by the /type checker/.

- You can also use the above compiler option in scala REPL,
  and then you'll see an enormous amount of boilerplate surrounding the meat of
  your code.

  * footnote 7:
    IDEs such as _IntelliJ_ and _Metals_ have options to show inserted /givens/.

** DONE 21.9 Conclusion - 476
CLOSED: [2025-05-07 Wed 20:55]
- =NEXT=
  * In the next chapter, you will learn how /typeclasses/ can be used with
    /extension methods/, and

  * in Chapter 23 you will see several examples of using /givens/ for /typeclasses/.

* DONE 22 Extension Methods - 477
CLOSED: [2025-05-08 Thu 17:08]
Scala provides a _MECHANISM_ for making it appear as if a function is defined as
a /method/ on a /class/, when it is really defined _OUTSIDE_ the /class/.

- Scala 3 introduced a new mechanism for this, /extension methods/, which
  _REPLACES the /implicit classes/ approach of Scala 2._

- This chapter will show you
  * how to CREATE your own /extension methods/ and
  * how to USE the /extension methods/ provided by others.

** DONE 22.1 The basics - 477
CLOSED: [2025-05-08 Thu 10:29]
- Listing 22.1 · An /extension method/ for ~String~'s.
  #+begin_src scala
    extension (s: String)
      def singleSpace: String =
        s.trim.split("\\s+").mkString(" ")
  #+end_src
  * receiver :: the object referenced by the variable after ~extension~.
  * applications :: uses of an /extension method/.

- /Extension method definitions/ are rewritten *in place* to /methods/ that take
  the /receiver/ directly as a parameter. If you paste the above definition in
  the REPL, you'll see it tells you ~def singleSpace(s: String): String~.
  * The only special thing about the rewritten method is that the compiler gives
    it an _internal marker_ identifying it as an /extension method/.

- The /extension methods/ approach, not like the /implicit class/ approach in
  Scala 2, doesn't introduce /unecessary boxing/.
  * It is guaranteed that call a /extension method/ from a /receiver/ give you
    the *same performance* as passing the /receiver/ to a corresponding
    non-extension method.

** DONE 22.2 Generic extensions - 480
CLOSED: [2025-05-08 Thu 10:31]
Listing 22.3 · A generic extension method.
#+begin_src scala
  extension [T](xs: List[T])
    def tailOption: Option[List[T]] =
      if xs.nonEmpty then Some(xs.tail) else None
#+end_src

** DONE 22.3 Collective extensions - 481
CLOSED: [2025-05-08 Thu 10:38]
Listing 22.5 · Invoking a sibling extension method.
#+begin_src scala
  extension (n: Int)
    def isMinValue: Boolean = n == Int.MinValue

    def absOption: Option[Int] =
      if !isMinValue then Some(n.abs) else None

    def negateOption: Option[Int] =
      if !isMinValue then Some(-n) else None
#+end_src
- sibling methods :: The /methods/ defined together in a /collective extension/.

** DONE 22.4 Using a typeclass - 484
CLOSED: [2025-05-08 Thu 11:07]
- It is worth
  looking in the _standard library_ to see if an APPROPRIATE /typeclass trait/
  _already exists._ Here are some candidates:
  * ~Numeric~: too general,
    BECAUSE /given instances/ are provided for /types/ such as ~Double~ and
    ~Float~ that are *NOT based on* /twos-complement arithmetic/.

  * ~Integral~: too general,
    BECAUSE
    * although *NO* /given instances/ are provided for ~Float~ and ~Double~, (=from Jian= expected)
    * a /given instance/ is provided for ~BigInt~, which does not overflow. (=from Jian= not expected)

  Thus your best option is to define a _NEW_ /typeclass trait/ specifically for
  /twos-complement integral types/

  =TODO=
  =TODO=
  =TODO=
  =from Jian= Look into the details of ~Numeric~ and ~Integral~, and try to
  understand their designs!!!

- Use one example to show the pattern:
  * Listing 22.7 · A typeclass for twos-complement numbers.
    #+begin_src scala
      trait TwosComplement[N]:
        def equalsMinValue(n: N): Boolean
        def absOf(n: N): N
        def negationOf(n: N): N

      object TwosComplement:
        given tcOfByte: TwosComplement[Byte] with
          def equalsMinValue(n: Byte) = n == Byte.MinValue
          def absOf(n: Byte) = n.abs
          def negationOf(n: Byte) = (-n).toByte

        given tcOfShort: TwosComplement[Short] with
          def equalsMinValue(n: Short) = n == Short.MinValue
          def absOf(n: Short) = n.abs
          def negationOf(n: Short) = (-n).toShort

        given tcOfInt: TwosComplement[Int] with
          def equalsMinValue(n: Int) = n == Int.MinValue
          def absOf(n: Int) = n.abs
          def negationOf(n: Int) = -n

        given tcOfLong: TwosComplement[Long] with
          def equalsMinValue(n: Long) = n == Long.MinValue
          def absOf(n: Long) = n.abs
          def negationOf(n: Long) = -n
    #+end_src

  * Listing 22.8 · Using a typeclass in an extension.
    #+begin_src scala
      extension [N](n: N)(using tc: TwosComplement[N])
        def isMinValue: Boolean = tc.equalsMinValue(n)
        def absOption: Option[N] =
          if !isMinValue then Some(tc.absOf(n)) else None
        def negateOption: Option[N] =
          if !isMinValue then Some(tc.negationOf(n)) else None
    #+end_src

  * Applications:
    #+begin_src scala
      Byte.MaxValue.negateOption // Some(127)
      Byte.MinValue.negateOption // None
      Long.MaxValue.negateOption // 9223372036854775807
      Long.MinValue.negateOption // None
    #+end_src

** DONE 22.5 Extension methods for givens - 486 - =REIVEW=
CLOSED: [2025-05-08 Thu 16:39]
- BECAUSE
  the main goal of the use cases like ~TwosComplement~ is to offer /extension
  methods/ for users,
  _it should be easy for users to decide when and if to enable them._

  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  In such design scenarios, the *best place* for your extension is a /singleton
  object/.

  Listing 22.9 · Placing extension methods in a singleton.
  #+begin_src scala
    object TwosComplementOps:
      extension [N](n: N)(using tc: TwosComplement[N])
        def isMinValue: Boolean = tc.equalsMinValue(n)
        def absOption: Option[N] =
          if !isMinValue then Some(tc.absOf(n)) else None
        def negateOption: Option[N] =
          if !isMinValue then Some(tc.negationOf(n)) else None
  #+end_src

  Then the users can *import* the /extension methods/ to bring them into
  /lexical scope/ (~import TwosComplementOps.*~), which will make them
  applicable.

- =IMPORTANT=
  * In the ~TwosComplementOps~ case,
    + The /extension methods/ represent the *main design goal* and
    + the /typeclass/ plays a supporting role.

  * But often it is the other way around:
    + The /typeclass/ is the *main goal* and
    + the /extension methods/ play a supporting role of _making the /typeclass/
      easier to use_.

    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    In such situations, the *best home* for the /extension methods/ is in the
    /typeclass trait/ itself.

- Use case for illustration:
  1. BACKGROUND:
     in Chapter 21 an ~Ord~ /typeclass/ is defined for the purpose of making an
     insertion sort method, ~isort~, more general.

  2. Achievement:
     the ~isort~ method can be used with any type ~T~ for which a /given
     instance/ of ~Ord[T]~ is available.

  3. New GOAL:
     the addition of a few /extension methods/ would make the ~Ord~ /typeclass/
     more pleasant to use.

     - The existing code from Listing 21.1:
       #+begin_src scala
         def insert[T](x: T, xs: List[T])(using ord: Ord[T]): List[T] =
           if xs.isEmpty || ord.lteq(x, xs.head) then x :: xs
           else xs.head :: insert(x, xs.tail)
       #+end_src
       1) Use ~x <= xs.head~ instead of ~ord.lteq(x, xs.head)~ to make code more
          natural and clearer:
          Listing 22.10 · Placing extensions for ~Ord~ in a singleton.
          #+begin_src scala
            // (Not yet the best design)
            object OrdOps:
              extension [T](lhs: T)(using ord: Ord[T])
                def < (rhs: T): Boolean = ord.lt(lhs, rhs)
                def <= (rhs: T): Boolean = ord.lteq(lhs, rhs)
                def > (rhs: T): Boolean = ord.gt(lhs, rhs)
                def >= (rhs: T): Boolean = ord.gteq(lhs, rhs)
          #+end_src

       2) Rewrite the ~insert~ method with ~OrdOps~:
          #+begin_src scala
            def insert[T](x: T, xs: List[T])(using Ord[T]): List[T] =
              import OrdOps.*
              if xs.isEmpty || x <= xs.head then x :: xs
              else xs.head :: insert(x, xs.tail)
          #+end_src
          Because the explicit usage or the context parameter disappear, we can
          make it anonymous.

       3) This approach works,
          BUT
          this /syntactic sugar/ would be nice to have _WHENEVER an instance of
          ~Ord~ is available._

          =IMPORTANT=
          The *best home* of these /extension methods/ is not in a singleton
          object like ~OrdOps~, but _in the ~Ord~ /typeclass trait/ itself._
          This is also the place Scala searches /given instances/.

          #+begin_src scala
            trait Ord[T]:
              def compare(x: T, y: T): Int
              def lt(x: T, y: T): Boolean = compare(x, y) < 0
              def lteq(x: T, y: T): Boolean = compare(x, y) <= 0
              def gt(x: T, y: T): Boolean = compare(x, y) > 0
              def gteq(x: T, y: T): Boolean = compare(x, y) >= 0

              // (This is the best design)
              extension (lhs: T)
                def < (rhs: T): Boolean = lt(lhs, rhs)
                def <= (rhs: T): Boolean = lteq(lhs, rhs)
                def > (rhs: T): Boolean = gt(lhs, rhs)
                def >= (rhs: T): Boolean = gteq(lhs, rhs)
          #+end_src
          * The implementation of these /extension methods/ are _simplified_ --
            ~[T]~ and ~(using Ord[T])~ are removed,
            BECAUSE ~T~ and /comparison methods/ are already in scope.

       4) Rewrite the ~insert~ again, with the help of modified ~Ord~:
          Listing 22.12 · Using an extension defined in a typeclass trait.
          #+begin_src scala
            def insert[T](x: T, xs: List[T])(using Ord[T]): List[T] =
              if xs.isEmpty || x <= xs.head then x :: xs
              else xs.head :: insert(x, xs.tail)
          #+end_src

** DONE 22.6 Where Scala looks for extension methods - 490 - =REIVEW=
CLOSED: [2025-05-08 Thu 17:08]
- When the compiler sees you are attempting to INVOKE a /method/ on an /object
  reference/,

  1. it first checks to see if that method is defined on the object's class
     itself. Selects that method and does not look for an /extension method/.
     * =IMPORTANT=
       =IMPORTANT=
       =IMPORTANT=
       footnote 6:
       This is a general rule: If any fragment of code compiles as is, the Scala
       compiler will not rewrite it to something else.

  2. Otherwise, the _method call_ is a *candidate compiler error*.

     Before reporting an error, however, the compiler will *search* for an
     /extension method/ or /implicit conversion/ that will *heal* the /candidate
     error/.

     The compiler will *REPORT AN ERROR*
     _ONLY IF_ it *FAILS TO FIND* an /extension method/ or /implicit conversion/
     that it can apply to heal the candidate error.

     * Scala divides /extension method/ search into *TWO phases*.

       1) In the _first phase_ the compiler looks in /lexical scope/.

       2) In the _second phase_ it looks in *THREE* places:
          1. at the members of /given instances/ in /lexical scope/;
          2. at the members of the /companion objects/ of the
             1) /receiver's class/
             2) /receiver's superclasses and supertraits/
          3. at the members of /given instances/ in those SAME /companion objects/. =???= =TODO=

       It also TRIES _TRANSFORMING_ /the type of the receiver/ WITH an /implicit
       conversion/ as part of *phase two*.

     * If the compiler finds _more than one_ applicable /extension method/ in
       either phase, it will choose one that is *more specific*, similar to the
       way it chooses an /overloaded method/ among alternatives.

     * If it finds _two or more_ applicable /extension methods/ *at the same
       level of specificity*, it will give a *compiler error* that includes a
       list of the /ambiguous extensions/.

- A definition can appear in /lexical scope/ in one of *THREE* ways:
  It can be being
  * defined directly
  * imported
  * inherited

- For example,

  * The ~absOption~ /extension method/ is _imported_:
    #+begin_src scala
      import TwosComplementOps.absOption
      88.absOption // Some(88)
    #+end_src
    Thus the /extension method/ search for ~absOption~ is resolved *in phase one*.

  * By contrast,
    the search triggered by the use of ~<=~ in Listing 22.12 is resolved
    *in phase two*.

    The /extension method/ applied is the ~<=~ method shown in Listing 22.11. It
    is invoked on the ~given Ord[T]~ passed as a /using parameter/.

** DONE 22.7 Conclusion - 491
CLOSED: [2025-05-08 Thu 17:08]

* DONE 23 Typeclasses - 493
CLOSED: [2025-05-10 Sat 21:21]
- If you need to write a function that implements behavior useful for some types
  but not others, you have a few options in Scala.

  * Define /overloaded methods/.

  * Require that the /class/ of ANY /instance/ _passed to your function_ mixes
    in a PARTICULAR /trait/.
    =???=

  * _MORE FLEXIBLE_
    Define a /typeclass/ and
    write your function
    to work with /types/ for which _a /given instance/ of the /typeclass trait/
    is defined_.

- This chapter will
  1. _compare and contrast_ these different approaches,
  2. then dive deeply into /typeclasses/.

     We will
     1) introduce the /context bound syntax/ for /typeclasses/ and
     2) give several examples of /typeclasses/ from the standard library -
        for
        * /numeric literals/,
        * /multiversal equality/,
        * /implicit conversions/, and
        * main methods. =???= =TODO=

     3) We'll wrap up with an example that illustrates the use of a /typeclass/
        for _JSON serialization_.

** DONE 23.1 Why typeclasses? - 493
CLOSED: [2025-04-21 Mon 13:19]
- typeclass :: a grouping or set of /types/.

- /typeclasses/ support /ad hoc polymorphism/ :: functions can be used with a
  particular, enumerated set of /types/.

  _As mentioned in Section 21.4_

  Any attempt to use such a function with
  a /type/ *NOT in* its enumerated set
  will *NOT compile*.

- _ORIGINALLY_,
  /ad hoc polymorphism/ was first used to describe the way that operators, such
  as ~+~ or ~-~, can be used with certain types but not others in many
  programming languages.
  * footnote 1:
    Strachey, "Fundamental Concepts in Programming Languages."

  * In Scala, this is achieved by /overloading methods/.
    The /interface/ of ~scala.Int~, for instance, includes seven /overloaded abstract
    methods/ named minus (~-~):
    #+begin_src scala
      def -(x: Double): Double
      def -(x: Float): Float
      def -(x: Long): Long
      def -(x: Int): Int
      def -(x: Char): Int
      def -(x: Short): Int
      def -(x: Byte): Int
    #+end_src

  * _Another way_ to achieve /ad hoc polymorphism/ in Scala is with a /class
    hierarchy/. Here's an example that uses a /sealed trait/ to define a family
    of colors:
    #+begin_src scala
      sealed trait RainbowColor

      class Red extends RainbowColor
      class Orange extends RainbowColor
      class Yellow extends RainbowColor
      class Green extends RainbowColor
      class Blue extends RainbowColor
      class Indigo extends RainbowColor
      class Violet extends RainbowColor

      def paint(rc: RainbowColor): Unit
    #+end_src
    Because ~RainbowColor~ is ~sealed~, the paint method can be passed *only*
    arguments having one of the eight types. It won't compile for any other
    type.

  * Although this approach could be viewed as /ad hoc polymorphism/, it is
    referred to as /subtyping polymorphism/ to highlight an important *DIFFERENCE*:
    + the classes of all the instances passed to the paint method must mix in
      trait RainbowColor and adhere any constraints established by its
      interface.

    + By contrast,
      the types accepted by ~Int~'s minus (~-~) method, shown in Figure 23.1,
      _need NOT ADHERE TO any COMMON /interface/ other than that of /Scala's top
      type/, ~Any~._

  * In short,
    + /subtyping/ enables polymorphism of *RELATED types*, whereas
    + /ad hoc polymorphism/ approaches such as /overloading/ and /typeclasses/
      enable polymorphism of *UNRELATED types*.

  * Different /polymorphism/ as solutions for different problems:

    + Because of the interface constraints, /subtyping/
      *WORKS BEST*
      WHEN
      /class hierarchies/ define _SMALL families of types_ focused on a *single
      concept*.

      _/Sealed hierarchies/ and /enums/ are great examples._

      =IMPORTANT=
      In such /self-contained families of types/ it is straightforward to ensure
      the compatibility of interfaces.

    + /Subtyping/ can also be used to model _LARGER, unsealed families_ that are
      focused on a *single concept*.
      - A good example is _the Scala collections library_.

    + However, when used to model behavior that is widely applicable to otherwise
      *UNRELATED types*, such as /serialization/ or /ordering/, _the /subtyping/
      approach becomes more cumbersome._

      - As an example,
        Scala's ~Ordered~ trait vs. ~Ordering~ /typeclass/ (also a ~trait~ in
        syntax):
        * /Subtyping polymorphism/:
          - One potential problem is the /class/ into which you mix ~Ordered~
            could _ALREADY define_ /methods/ whose names or contracts *conflict* with
            those in ~Ordered~.

          - Another potential problem is _/variance/ conflicts_.
            * ~Ordered~ is *invariant*.

          - One more potential problem with /subtyping polymorphism/ is
            /pre-existing interfaces/ that are *incompatible*.

            Another, more common problem is /pre-existing compatible interfaces/
            that you *can't change*.

            * Example:
              The ~orderedMergeSort~ shown in Listing 18.11 can't sort ~List[Int]~,
              because ~Int~ does *NOT* extend ~Ordered[Int]~ -- and you can't
              change that fact.

        * /Typeclasses/ solve this problem by defining a *SEPARATE* hierarchy
          focused on the _GENERAL concept_,
          *using a /type parameter/ to SPECIFY the /type/ for which a service is
          being provided.*

          + Because this *SEPARATE* hierarchy is focused on just one concept,
            such as /serialization/ or /ordering/,
            _it is STRAIGHTFORWARD to ENSURE the *compatibility* of /interfaces/._

          + Because a /typeclass instance/ uses a /type parameter/ to indicate
            the /type/ for which it is providing a service, you *need NOT change
            a /type/* to provide the service for that /type/.
            - _footnote 2_:
              Using a /type parameter/ in this way is referred to as /universal
              polymorphism/.

        * Example:
          #+begin_src scala
            import org.stairwaybook.enums_and_adts.hope.Hope

            object HopeUtils:
              given hopeOrdering[T](using ord: Ordering[T]): Ordering[Hope[T]] with
                def compare(lh: Hope[T], rh: Hope[T]): Int =
                  import Hope.{Glad, Sad}
                  (lh, rh) match
                    case (Sad, Sad) => 0
                    case (Sad, _) => -1
                    case (_, Sad) => +1
                    case (Glad(lhv), Glad(rhv)) => ord.compare(lhv, rhv)
          #+end_src
          Listing 23.1 · A given ~Ordering~ instance for ~Hope[T]~.

        * /Typeclasses/ support /ad hoc polymorphism/,
          BECAUSE
          you can write functions that can be used
          *ONLY with /types/ for which /given instances/ of a particular
          /typeclass/ exists.*

          + Any attempt to use such a function with a /type/ that LACKS a /given
            instance/ of the required /typeclass/ will *NOT compile*.

          =from Jian=
          This description can fit into the defintion of /ad hoc polymorphism/.

** DONE 23.2 Context bounds - 498
CLOSED: [2025-04-21 Mon 14:11]
Because /typeclasses/ are such an important pattern in Scala, the language
provides a shorthand syntax for them called /context bounds/.

#+begin_src scala
  def maxList[T](elements: List[T])
        (using ordering: Ordering[T]): T =
    elements match
      case List() => throw new IllegalArgumentException("empty list!")
      case List(x) => x
      case x :: rest =>
        // val maxRest = maxList(rest)(using ordering)
        val maxRest = maxList(rest)
        if ordering.gt(x, maxRest)
        then x
        else maxRest
#+end_src
Listing 23.2 · A function with a using parameter.


- Q :: Why /context parameter(s)/ don't need to be passed explicitly.
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=

- A ::
  Use the ~maxList~ as an illustration:

  The ~maxList~ function is an example of /a ~using~ parameter/ used to provide
  more information about _a /type/ mentioned *explicitly* in an *earlier*
  parameter list._

  Because elements must always be provided explicitly in any invocation of
  ~maxList~, the compiler will know ~T~ at /compile time/ and can therefore
  determine whether /a ~given~ definition/ of /type/ ~Ordering[T]~ is available.
  If so, it can pass in the second parameter list, ~ordering~, *implicitly*.

- From the compiler point of view (operational):
  When the compiler see the invocation ~maxList(rest)~, it knows one of two
  argumetns is missing. Since that /a ~using~ parameter/ is in the definition,
  the compiler *DOESN'T give up* /type checking/, and search for required ~given~.

- Use ~def summon[T](using t: T) = t~ and the /context bounds/ syntax:
  #+begin_src scala
    def maxList[T: Ordering](elements: List[T]): T =
      elements match
        case List() => throw new IllegalArgumentException("empty list!")
        case List(x) => x
        case x :: rest =>
          // val maxRest = maxList(rest)(using ordering)
          val maxRest = maxList(rest)
          if summon[Ordering[T]].gt(x, maxRest)
          then x
          else maxRest
  #+end_src
  * /Context bounds/ are essentially /syntactic sugar/ for /typeclasses/.

- Compare two syntax:
  * ~[T <: Ordered[T]]~: ~T~ is an ~Ordered[T]~.

  * ~[T <: Ordered[T]]~: Nothing about ~T~ itself, just some form of ordering
    associated with ~T~.

** DONE 23.3 Main methods - 501
CLOSED: [2025-04-21 Mon 15:00]
- In Scala, /main methods/ can actually accept
  *ANY* _number_ and _types_ of arguments.
  * Q :: How can it know how to do some type conversion when reading command
         line arguments that in string type as the expected arguments of a
         /main method/.

  * A :: Use the ~scala.util.CommandLineParser.FromString~.
    + The Scala standard library defines /given/ ~FromString~ /instances/ for
      several common types, including ~String~ and ~Int~ in the ~FromString~
      /companion object/.

    + If you want to write a /main method/ that takes a _CUSTOM type,_
      you can do so by declaring a /given instance/ of the ~FromString~
      /typeclass/ _for the custom type._

- Example:
  * Listing 23.8 · A main method that takes a custom type.
    #+begin_src scala
      // In file moody.scala
      val errmsg =
        "Please enter a word, a positive integer count, and\n" +
          "a mood (one of 'angry', 'surprised', or 'neutral')"

      @main def repeat(word: String, count: Int, mood: Mood) =
        val msg =
          if count <= 0 then
            errmsg
          else
            val words = List.fill(count)(word.trim)
            val punc =
              mood match
                case Mood.Angry => "!"
                case Mood.Surprised => "?"
                case Mood.Neutral => ""
          end if
        println(msg)
    #+end_src

  * Listing 23.9 · A given ~FromString~ instance for ~Mood~.

- A typeclass-based design is a good choice for command line argument parsers
  for /main methods/

  BECAUSE
  this service is needed *only for certain types,*
  which are otherwise *unrelated* to each other.

** DONE 23.4 Multiversal equality - 505 - =REVIEW=
CLOSED: [2025-05-10 Sat 18:41]
- universal equality :: the equality that can be checked between any ~Object~'s.
  * /universal equality/ had one big _downside_: it masked bugs.
    + This approach also _enabled_ Scala 2 to support /cooperative equality/,
      whereby *different types* compare themselves for equality with other
      /cooperating types/.
      * For example, compare ~Int~ and ~Long~ without an explicit conversion.

    + You may accidentally compare values of two different types that they are
      always can't be equal.
      Of course, you won't do comparison like ~"hello" == Option("hello")~ on
      purpose, but if the RHS value was saved to a /variable/, you may not
      notice you are doing a always-false equality check.
      - Scala 2 compiler can't catch this issue.
      - Scala 3 compiler can give you an error _at compile time_ with the help
        of /multiversal equality/.

- Scala 3 achieves this improvement in safety through a new feature called
  /multiversal equality/.

  * /Multiversal equality/ is a Scala 3 enhancement to the special compiler
    treatment given to the ~==~ and ~!=~ methods in Scala 2:
    1. The definitions of ~==~ and ~!=~, shown in Listing 23.10, are the same in
       Scala 3 as in Scala 2.

    2. ONLY the _compiler treatment_ of ~==~ and ~!=~ was changed in Scala 3 to
       transform universal equality into /multiversal equality/.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  To understand /multiversal equality/ in Scala 3,
  it is helpful to _understand the details of how Scala 2 implemented /universal
  equality/._

  * Here is how it worked on the JVM:
    When the Scala 2 compiler encountered an invocation of ~==~ or ~!=~, it
    1. Checked whether the types being compared were Java primitive types.

    2. If so, the compiler emitted _SPECIAL Java bytecodes_ for EFFICIENT
       _equality comparisons BETWEEN those /primitive types/._

       Otherwise, if one side was a /primitive type/ but the other side was not,
       it emitted code to *box* the /primitive value/. Now both operands were
       /reference types/.

    3. Next, the compiler emitted code that
       first determined whether the left operand was ~null~.
       + If so, the emitted code checked the right operand for ~null~ to determine
         a ~Boolean~ result, ensuring that invocations of ~==~ or ~!=~ could
         *never throw* ~NullPointerException~.

       + Otherwise, the emitted code called ~equals~ on the left operand, which at
         this point was known to be non-null, passing in the right operand.

  * The Scala 3 compiler performs the *exact same* steps as Scala 2 --
    *after*
    making sure the comparison should be allowed by looking for a /given
    instance/ of a /typeclass/ named ~CanEqual~.
    #+begin_src scala
      sealed trait CanEqual[-L, -R]
    #+end_src
    _Rather than_ offering an equality comparison service for types ~L~ and ~R~,
    as you would normally expect from a /typeclass/,

    ~CanEqual~ *just gives permission* to use ~==~ and ~!=~ for an equality
    comparison of types ~L~ and ~R~.

- *For /backwards compatibility/,*
  the _Scala 3 compiler by default_ *ALLOWS* some /equality comparisons/,
  even if a /given ~CanEqual~ instance/ of the required type is _NOT available_.

  For an /equality comparison/ between TWO /types/ ~L~ and ~R~, if the compiler
  finds no /given instance/ of type ~CanEqual[L, R]~ it will still allow the
  comparison if any of the following conditions are true:

  1. ~L~ and ~R~ are the SAME /type/.

  2. Either ~L~ or ~R~ is a /subtype/ of the other, after being /lifted/.
     * _footnote 4:_
       To *lift* a /type/, the compiler
       + REPLACES
           references to /abstract types/ in /covariant positions/ of the /type/
         BY
           their /upper bound/ and

       + REPLACES
           /refinement types/ in /contravariant positions/ of the /type/
         BY
           their parent.

  3. *No* /given reflexive ~CanEqual~ instance/ exists for either /type/ ~L~ or
     ~R~, WHERE a /reflexive instance/ is one that *permits* a type to be
     compared with itself, such as ~CanEqual[L, L]~.

- Scala 3 provides /given instances/ for several /standard library types/,
  INCLUDING a /reflexive instance/ for /strings/.
  * This is why an equality comparison between ~String~ and ~Option[String]~ is
    disallowed by default.

- =IMPORTANT=
  To get _full sanity checking_ of *ALL* equality comparisons in Scala 3,
  even if NO /reflexive instances/ have been defined for the involved types,
  you can *enable "strict equality."*
  * compiler option: ~-language:strictEquality~
  * Per source file: ~import scala.language.strictEquality~

- Implement a /given reflective ~CanEqual~ instance/ for a type ~Apple~:
  1. Manually:
     #+begin_src scala
       case class Apple(size: Int)
       object Apple:
         given canEq: CanEqual[Apple, Apple] = CanEqual.derived
     #+end_src

  2. /typeclass derivation/:
     #+begin_src scala
       case class Apple(size: Int) derives CanEqual // idiomatic
     #+end_src

** DONE 23.5 Implicit conversions - 511
CLOSED: [2025-04-21 Mon 15:58]
- Their purpose of /implicit conversions/ was to help make code more clear and
  concise _by *removing* BOILERPLATE type conversions._

- Scala 3 /implicit conversion/ syntax:
  #+begin_src scala
    given streetToString: Conversion[Street, String] = _.value
  #+end_src

  This can be done is because ~Conversion~ is a /SAM/ with definition:
  #+begin_src scala
    abstract class Conversion[-T, +U] extends (T => U):
      def apply(x: T): U
  #+end_src

- Switch on /implicit conversion/:
  * goblally with the compiler option: ~-language:implicitConversions~

  * Per file by ~import~'s:
    #+begin_src scala
      import scala.language.implicitConversions
    #+end_src

- If you do _DEFINE /implicit conversions/,_ make sure the conversion will
  always be appropriate.

  * For example,
    converting ~Double~'s to ~Int~'s _implicitly_ would raise some eyebrows,
    BECAUSE
    it's a dubious idea to have something that causes a loss in precision happen
    invisibly.


    + It makes much more sense to go the other way,
      from some more constrained type to a more general one.

      For instance, from ~Int~ to ~Double~. It, and similar reasonable /implicit
      conversions/, exists the ~scala.Predef~ object, which is implicitly
      imported into every Scala program.

** DONE 23.6 Typeclass case study: JSON serialization - 514 - =REVIEW=
CLOSED: [2025-05-10 Sat 21:17]
- In Section 23.1, we mentioned serialization as an example of the kind of
  behavior that is widely applicable to otherwise unrelated types, and
  therefore a good fit for typeclasses.

- As a last example for this chapter, we'd like to _ILLUSTRATE_ using a
  /typeclass/ to support /serialization to JSON/.

  _To keep the example simple, we will only look at /serialization/,_
  NOT /deserialization/, although normally both would be dealt with in the same
  library.

- Anything you want to _serialize to JSON_ *must* therefore be expressed in one
  of those *FIVE* _data types_ that defined in _JSON data model_:
  * strings
  * numbers
  * booleans
  * arrays
  * objects

- You can't define a /trait/ and mix it into Scala standard library types
  representing the above five data types in _JSON data model_:
  * ~String~
  * ~Int~, ~Long~,
    + ~Float~, ~Double~, and other numeric types are not included in this
      example just for the simplicity of this illustration example.
  * ~Boolean~
  * ~List~
  * ANY /class instance/ that used to represent data

- Steps:
  1. Listing 23.13 · A JSON serializer typeclass.
     #+begin_src scala
       trait JsonSerializer[T]:
         def serialize(o: T): String
     #+end_src

  2. To enable your users to invoke a ~toJson~ method on /serializable classes/,
     you can define an /extension method/.

     As discussed in Section 22.5, one _good place_ to provide such an /extension
     method/ is in *the /typeclass trait/ itself.*

     Listing 23.14 · A JSON serializer typeclass with an extension method.
     #+begin_src scala
       trait JsonSerializer[T]:
         def serialize(o: T): String

         extension (a: T)
           def toJson: String = serialize(a)
     #+end_src

  3. A reasonable next step is to _define_ /given typeclass instances/ for Scala
     types representing data types in JSON data model:

     Listing 23.15 · JSON serializer companion object with givens.
     #+begin_src scala
       object JsonSerializer:
         given stringSerializer: JsonSerializer[String] with
           def serialize(s: String) = s"\"$s\""

         given intSerializer: JsonSerializer[Int] with
           def serialize(n: Int) = n.toString

         given longSerializer: JsonSerializer[Long] with
           def serialize(n: Long) = n.toString

         given booleanSerializer: JsonSerializer[Boolean] with
           def serialize(b: Boolean) = b.toString
     #+end_src

*** Importing an extension method - 516 - =IMPORTANT= =REVIEW=
*TARGET*: It is useful to be able to _import_ an /extension method/ that
_ADDS a ~toJson~ /method/ TO ANY /types/ ~T~ for which a ~JsonSerializer[T]~ is
available._

- Listing 23.14 is not enough,
  BECAUSE it only makes ~toJson~ available for a type ~T~ if a ~given
  JsonSerializer[T]~ is _in /scope/._

  If _NO_ ~JsonSerializer[T]~ is _in /scope/,_ it will *NOT work*,
  even if there is a ~JsonSerializer[T]~ *in* the /companion object/ for ~T~.
  =from Jian= This is usually what we do.

- Listing 23.16 · An extension method for convenient importing.
  #+begin_src scala
    object ToJsonMethods:
      extension [T](a: T)(using jser: JsonSerializer[T])
        def toJson: String = jser.serialize(a)
  #+end_src

  * Example:
    #+begin_src scala
      import ToJsonMethods.*

      "tennis".toJson // "tennis"
      10.toJson // 10
      true.toJson // true
    #+end_src

- =IMPORTANT=
  It is instructive to
  _COMPARE_
  the /extension method/ in the ~ToJsonMethods~ object, shown in Listing 23.16,
  _WITH_ the one in the ~JsonSerializer~ trait, shown in Listing 23.14.

  The /extension method/ in ~ToJsonMethods~ takes a ~JsonSerializer[T]~ as a
  /using parameter/,
  BUT the /extension method/ in ~JsonSerializers~ does NOT,
  because it is by definition _ALREADY_ a member of a ~JsonSerializer[T]~.

  Thus,
  * whereas ~toJson~ in ~ToJsonMethods~ invokes ~serialize~ *on the passed
    ~JsonSerializer~ reference*, named ~jser~,

  * the ~toJson~ /method/ in ~trait JsonSerializer~ invokes ~serialize~ on
    ~this~.

*** Serializing domain objects - 517 - =???=
Serialize /instances/ of certain /classes/ from your /domain model/ to JSON,
JSON, including the address book shown in Listing 23.17.

- A _good home_ for ~given JsonSerializer~'s for your /domain objects/ is in
  their /companion objects/.

- =???=
  =???=
  =???=
  but rename it to ~asJson~. This renaming is *necessary* to avoid a conflict with
  the like-named toJson extension method inherited from JsonSerializer, shown
  in Listing 23.14.

  Listing 23.18 · JSON serializers for Address and Phone.
  #+begin_src scala
    object Address:
      given addressSerializer: JsonSerializer[Address] with
        def serialize(a: Address) =
          import ToJsonMethods.{toJson as asJson}
          s"""|{
              | "street": ${a.street.asJson},
              | "city": ${a.city.asJson},
              | "state": ${a.state.asJson},
              | "zip": ${a.zip.asJson}
              |}""".stripMargin

    object Phone:
      given phoneSerializer: JsonSerializer[Phone] with
        def serialize(p: Phone) =
          import ToJsonMethods.{toJson as asJson}
          s"""|{
              | "countryCode": ${p.countryCode.asJson},
              | "phoneNumber": ${p.phoneNumber.asJson}
              |}""".stripMargin
  #+end_src
  =from Jian=
  =rank 0=
  =NEED verification=
  Rename from ~toJson~ to ~asJson~, and all types can use ~asJson~.
  Or else, standard library types in ~object JsonSerializer~ has two ~toJson~
  methods, one from ~object JsonSerializer~ and one from ~ToJsonMethods~.
  This can make compiler raise a method resolution error, I guess.

*** Serializing lists - 519
isting 23.19 · Given JSON serializer for lists.
#+begin_src scala
  object JsonSerializer:
    // givens for strings, ints, and booleans...
    given listSerializer[T](using
        JsonSerializer[T]): JsonSerializer[List[T]] with
      def serialize(ts: List[T]) =
        s"[${ts.map(t => t.toJson).mkString(", ")}]"
#+end_src

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  Using this /typeclass/ way, compiler can report errors of missing /given
  instances/ *at compile time*.
  * In Java, by contrast, if a deeply nested object does not
    implement ~Serializable~, _you will get an exception *at runtime*._

- One last point worth noting is that the reason ~toJson~ can be invoked in the
  body of the function passed to ~map~ (the ~toJson~ in ~t => t.toJson~) is
  because a ~given JsonSerializer[T]~ is _in scope_:
  the /anonymous using parameter/ passed to ~listSerializer~.
  * =IMPORTANT=
    The /extension method/ used in this case, therefore, is the one declared in
    the ~JsonSerializer~ /trait/ itself, shown in Listing 23.14.

*** Putting it all together - 521
Listing 23.20 · Given JSON serializers for Contact and AddressBook.
#+begin_src scala
  object Contact:
    given contactSerializer: JsonSerializer[Contact] with
      def serialize(c: Contact) =
        import ToJsonMethods.{toJson as asJson}
        s"""|{
            | "name": ${c.name.asJson},
            | "addresses": ${c.addresses.asJson},
            | "phones": ${c.phones.asJson}
            |}""".stripMargin

  object AddressBook:
    given addressBookSerializer: JsonSerializer[AddressBook] with
      def serialize(a: AddressBook) =
        import ToJsonMethods.{toJson as asJson}
        s"""|{
            | "contacts": ${a.contacts.asJson}
            |}""".stripMargin
#+end_src

- A _real world JSON library_ would, of course, be far more complicated than
  what you've seen here.

  One thing you would most likely want to do is use /Scala's metaprogramming/
  facilities to *automate* _the GENERATION of ~JsonSerializer~ /typeclass
  instances/_ via /typeclass derivation/.

** DONE 23.7 Conclusion - 523
CLOSED: [2025-05-10 Sat 21:21]
- /Typeclasses/ are a fundamental way to achieve /ad hoc polymorphism/ in Scala.

- /Scala's syntactic sugar/ for /typeclasses/, /context bounds/, is an
  indication of the importance of /typeclasses/ as a design approach in Scala.
  * =from Jian=
    Create a /syntactic sugar/ for it means it is very important!

- You saw several _APPLICATIONS_ of /typeclasses/: for
  * main methods,
  * safe equality comparisons,
  * implicit conversions, and
  * JSON serialization.

* TODO 24 Collections in Depth - 525
- =IMPORTANT=
  =IMPORTANT=
  =from Jian=
  Useful info:
  https://superruzafa.github.io/visual-scala-reference/

- Quite often it's as if you work on a higher level with the basic building
  blocks of a program being whole collections instead of their elements.

  This new style of programming _requires some adaptation._

  Fortunately, the adaptation is helped by several nice properties of Scala
  collections. They are:
  * *Easy to use:*
    _A small vocabulary_ of twenty to fifty methods _is ENOUGH to solve MOST_
    collection problems in a couple of operations.

    - No need to wrap your head around complicated /looping structures/ or
      /recursions/.

    - /Persistent collections/ and /side-effect-free operations/ mean that
      you *NEED NOT WORRY ABOUT accidentally corrupting* existing collections
      with new data.
      + Interference between /iterators/ and /collection updates/ is ELIMINATED.

  * *Concise:*
    You can achieve with a SINGLE word what used to take ONE OR SEVERAL loops.
    + You can express functional operations with lightweight syntax and combine
      operations effortlessly, so that the result feels like a custom algebra.

  * *Safe:*
    The reason is that
    1. the collection operations themselves are heavily used and therefore _well
       tested._
    2. the usages of the collection operation _make inputs and output explicit_ AS
       _function parameters and results_.
    3. These explicit inputs and outputs are subject to /static type checking/.

    The bottom line is that the large majority of misuses will manifest
    themselves as /type errors/.

  * *Fast:* ......

  * *Universal:*
    Collections provide the *SAME operations on ANY /type/* _where it MAKES SENSE to do so._
    + For instance,
      a /string/ is conceptually a sequence of characters.

      Consequently, in Scala collections,
      /strings/ support *ALL* _sequence operations._
      The same holds for /arrays/.

- This chapter describes in depth the APIs of the Scala collection /classes/
  _FROM a user perspective._

- =NEXT=
  _Advanced Programming in Scala_ will look at the *architecture* and
  *extensibility* aspects of the collections library, _FOR people implementing
  new collection types._

** DONE 24.1 Mutable and immutable collections - 526
CLOSED: [2025-05-21 Wed 14:38]
- Scala collections systematically distinguish between *mutable* and *immutable*
  collections.

- All collection classes are found in the package ~scala.collection~ or one of
  its subpackages: ~mutable~, ~immutable~, and ~generic~~.

- Most /collection classes/ needed by client code exist in *THREE variants*, each
  of which has DIFFERENT CHARACTERISTICS _with respect to *mutability*._

  * The *THREE variants* are located in packages:
    + ~scala.collection~
    + ~scala.collection.immutable~
    + ~scala.collection.mutable~

- A collection in package ~scala.collection~ can be either /mutable/ or
  /immutable/.
  * For instance,
    ~scala.collection.IndexedSeq[T]~ is a /supertrait/ of BOTH
    ~scala.collection.immutable.IndexedSeq[T]~ and its mutable sibling
    ~scala.collection.mutable.IndexedSeq[T]~.

- Generally,
  * the _root collections_ in package ~scala.collection~
    *SUPPORT*
    /transformation operations/ affecting the whole collection, such as ~map~
    and ~filter~.

  * The /immutable collections/ in package ~scala.collection.immutable~
    *TYPICALLY ADD*
    operations for _adding_ and _removing_ single values, and

  * the /mutable collections/ in package ~scala.collection.mutable~
    *ADD*
    some /side-effecting modification operations/ to the root interface.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  Another difference between /root collections/ and /immutable collections/:
  * clients of an /immutable collection/ have a *GUARANTEE* that
    _nobody can mutate_ the collection,


  * whereas clients of a /root collection/ only know that they *can't change*
    the collection themselves.

    =IMPORTANT=
    Even though the static type of such a collection provides no operations for
    modifying the collection, *it might still be possible that the /run-time
    type/ is a /mutable collection/ that can be changed by other clients.*

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  *BY DEFAULT, Scala always picks /immutable collections/.*
  * You need to explicitly point out you want /types/ from ~collection.mutable~
    if you want use the /mutable collections/.

- The last package in the collection hierarchy is ~collection.generic~. This
  package contains building blocks for *abstracting over concrete collections.*
  Everyday users of the collection framework should need to refer to classes in
  ~generic~ only in *exceptional circumstances.*
  =???=
  =TODO=
  =IMPORTANT=

** DONE 24.2 Collections consistency - 528
CLOSED: [2025-05-22 Thu 13:33]
- There is quite a bit of *commonality* SHARED by all these collection classes.
  * For instance,
    every kind of collection can be created by the same uniform syntax, writing
    the collection class name followed by its elements:
    #+begin_src scala
      Iterable("x", "y", "z")
      Map("x" -> 24, "y" -> 25, "z" -> 26)
      Set(Color.Red, Color.Green, Color.Blue)
      SortedSet("hello", "world")
      Buffer(x, y, z)
      IndexedSeq(1.0, 2.0)
      LinearSeq(a, b, c)
    #+end_src

    The same principle also applies for specific collection implementations:
    #+begin_src scala
      List(1, 2, 3)
      HashMap("x" -> 24, "y" -> 25, "z" -> 26)
    #+end_src

- Figure 24.1 · Collection hierarchy.
  #+begin_src text
    Iterable
        Seq
            IndexedSeq
                ArraySeq
                Vector
                ArrayDeque (mutable)
                Queue (mutable)
                Stack (mutable)
                Range
                NumericRange
            LinearSeq
                List
                LazyList
                Queue (immutable)
            Buffer
                ListBuffer
                ArrayBuffer
        Set
            SortedSet
                TreeSet
            HashSet (mutable)
            LinkedHashSet
            HashSet (immutable)
            BitSet
            EmptySet, Set1, Set2, Set3, Set4
        Map
            SortedMap
                TreeMap
            HashMap (mutable)
            LinkedHashMap (mutable)
            HashMap (immutable)
            VectorMap (immutable)
            EmptyMap, Map1, Map2, Map3, Map4
  #+end_src
  Most of the classes in Figure 24.1 exist in _THREE_ variants:
  * root
  * mutable
  * immutable

  The _ONLY EXCEPTION_ is the ~Buffer~ /trait/, which only exists as a /mutable
  collection/.

** DONE 24.3 Trait ~Iterable~ - 530
CLOSED: [2025-05-23 Fri 01:09]
- These /methods/ fall into the following categories:
  * Iteration operations
    + ~foreach~
    + ~grouped~
    + ~sliding~

  * Addition
    + ~++~ (alias, ~concat~)

  * Map operations
    + ~map~
    + ~flatMap~
    + ~collect~

  * Conversions
    + ~toIndexedSeq~, ~toIterable~, ~toList~, ~toMap~, ~toSeq~, ~toSet~, and ~toVector~
      return an ~Iterable~ collection into an /immutable collection/.

    + ~toArray~ and ~toBuffer~
      return a *NEW* /mutable collection/, even if the receiver object already matches.
      =IMPORTANT=
      =IMPORTANT=
      =IMPORTANT=
      - =from Jian=
        They are parameterless methods.
        If you accidentally call these methods with ~()~, the error message
        tells you an index is expected for an ~apply~ method.

    + ~to~
      convert to any other collection.
      =TODO=
      =TODO=
      =TODO=
      =TODO=
      =TODO=
      =TODO=
      =TODO: TRY=
      =from Jian= How to create a ~scala.collection.Factory~ as the argument of
      ~to~.

  * Copying operations
    + ~copyToArray~
      An array need to provided.
      /start/ or /start/ and /len/ can be specified.

  * Size operations
    ~isEmpty~, ~nonEmpty~, ~size~, ~knownSize~, ~sizeCompare~, and ~sizeIs~,
    which deal with a collection's size.

    + Computing the number of elements of a collection can *require a
      _traversal_ in some cases*, such as ~List~.

    + In other cases the collection can have an infinite number of elements, for
      example, ~LazyList.from(0)~.

      The ~knownSize~, ~sizeCompare~, and ~sizeIs~ methods give information
      about the number of elements while *traversing as few of the elements as
      possible.*
      =TODO=
      =TODO=
      =TODO=
      =TRY=

  * Element retrieval operations
    ~head~, ~last~, ~headOption~, ~lastOption~, and ~find~.

    Not all collections have a well-defined meaning of what "first" (~head~) and
    "last" means.

    + /Ordering/ is often essential to give reproducible tests and help in
      debugging. That's why Scala collections _provide ORDERED ALTERNATIVES for
      *ALL* collection types._

  * Subcollection retrieval operations
    ~takeWhile~, ~tail~, ~init~, ~slice~, ~take~, ~drop~, ~filter~,
    ~dropWhile~, ~filterNot~, and ~withFilter~.

    These all return some _subcollection_ IDENTIFIED BY
    + an index range or
    + a predicate.

  * Subdivision operations
    + ~groupBy~, ~groupMap~, ~groupMapReduce~, ~splitAt~, ~span~, ~partition~,
      and ~partitionMap~, which split the elements of this collection into
      *SEVERAL* _subcollections_.

  * Element tests
    + ~exists~, ~forall~, and ~count~,
      which test collection elements with a given predicate.

  * Folds
    + ~foldLeft~, ~foldRight~, ~reduceLeft~, ~reduceRight~, which apply a
      /binary operation/ to successive elements.

  * Specific folds
    + ~sum~, ~product~, ~min~, and ~max~, which work on collections of specific
      types (/numeric/ or /comparable/).

  * String operations
    + ~mkString~ (create a string) and
    + ~addString~ (add the string representation of elements in current
      collection to a given ~StringBuilder~),

    They offer alternative ways of _converting a collection to a string._

  * View operations
    + view :: a collection that's evaluated lazily.
    =NEXT= You'll learn more about views in Section 24.13.

- Table 24.1 · Operations in trait ~Iterable~
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=

- *Subcategories of ~Iterable~:*
  In the /inheritance hierarchy/ below ~Iterable~ you find _THREE_ /traits/:
  ~Seq~, ~Set~, and ~Map~.

  A common aspect of ~Seq~ and ~Map~ is that they _both IMPLEMENT_ the
  ~PartialFunction~ /trait/ with its ~apply~ and ~isDefinedAt~ methods.
  *However, the way each /trait implements/ ~PartialFunction~ DIFFERS.*

  * For sequences, apply is positional indexing, where elements are always
    numbered from 0. That is, ~Seq(1, 2, 3)(1) == 2~.

  * For sets, apply is a membership test.
    For instance, ~Set('a', 'b', 'c')('b') == true~
    whereas ~Set()('a') == false~.

  * Finally for maps, apply is a selection.
    For instance, ~Map('a' -> 1, 'b' -> 10, 'c' -> 100)('b') == 10~.

** TODO 24.4 The sequence traits ~Seq~, ~IndexedSeq~, and ~LinearSeq~ - 537
** TODO 24.5 Sets - 544
** TODO 24.6 Maps - 548
** TODO 24.7 Concrete immutable collection classes - 552
** TODO 24.8 Concrete mutable collection classes - 559
** TODO 24.9 Arrays - 564
** TODO 24.10 Strings - 568
** TODO 24.11 Performance characteristics - 569
** TODO 24.12 Equality - 571
** TODO 24.13 Views - 572 - =READING=
** TODO 24.14 Iterators - 576
** TODO 24.15 Creating collections from scratch - 584
** TODO 24.16 Conversions between Java and Scala collections - 586
** TODO 24.17 Conclusion - 588

* DONE 25 Assertions and Tests - 589 - _NOTE_
CLOSED: [2025-05-06 Tue 20:28]
/Assertions/ and /tests/ are two important ways you can check that the software you
write behaves as you expect.

In this chapter, we'll show you
_several options you have in Scala to write and run them._

- =from Jian=
  I should learn more test frameworks!

** DONE 25.1 Assertions - 589
CLOSED: [2025-05-06 Tue 14:58]
- footnote 1: ~assert~ is defined in the ~Predef~ /singleton object/.

- /Assertions/ in Scala are written as calls of a predefined method ~assert~.
  * The expression ~assert(condition)~ throws an ~AssertionError~ if condition
    does NOT hold.

  * There's also a two-argument version of assert:
    The expression ~assert(condition, explanation)~ tests condition and, if it
    does not hold, throws an ~AssertionError~ that CONTAINS _the given
    explanation_.

    + The type of explanation is ~Any~, so you can pass any object as the explanation.
      The ~assert~ method will call ~toString~ on it to get a string explanation to
      place inside the ~AssertionError~.

      For example, in the method named ~above~ of class ~Element~, shown in
      Listing 10.13 on page 231, you might place an ~assert~ after the calls to
      ~widen~ to make sure that the widened elements have _equal widths_. This is
      shown in Listing 25.1.

- The ~ensuring~ method can be used with any /result type/ because of an
  /implicit conversion/.
  * Listing 25.2 · Using ~ensuring~ to assert a function's result.
    #+begin_src scala
      private def widen(w: Int): Element =
        if w <= width then
          this
        else {
          val left = elem(' ', (w - width) / 2, height)
          var right = elem(' ', w - width - left.width, height)
          left beside this beside right
        } ensuring (w <= _.width)
    #+end_src

  * ~ensuring~ calls ~assert~ in its implementation.

- =TODO=
  =from Jian= This doesn't work!!!
  See https://docs.scala-lang.org/scala3/guides/migration/options-lookup.html

  /Assertions/ can be enabled and disabled using the _JVM's_ ~-ea~ and ~-da~
  /command line flags/.
  * =from Jian=
    Since this can be DISABLED, for the tests in code that we want to use as
    preconditions or/and postconditions, we'd better use ~require~.
    =???= Or any other tools???

- =NEXT=
  In the remainder of this chapter, we'll focus on the writing of /external
  tests/, which provide their own test data and run _independently from the
  application_.

** TODO 25.2 Testing in Scala - 591
You have many options for testing in Scala,
from established Java tools, such as _JUnit_ and _TestNG_,
to tools written in Scala, such as _ScalaTest_, _specs2_, and _ScalaCheck_.

- =from Jian=
  * Need a survey to all widely used Scala test frameworks.
  * Compare them with each other and non-Scala famous test frameworks, like pytest.

- For the remainder of this chapter, we'll give you a quick tour of these tools.
  We'll START WITH _ScalaTest_.

- xxx

** TODO 25.3 Informative failure reports - 592
** TODO 25.4 Tests as specifications - 594
** TODO 25.5 Property-based testing - 597
** TODO 25.6 Organizing and running tests - 599
** TODO 25.7 Conclusion - 600

* Glossary - 601
* Bibliography - 617
* About the Authors - 621
* Index - 622
