#+TITLE: Functional Programming Strategies in Scala with Cats
#+AUTHOR: Noel Welsh, Dave Gurnell
#+Date: February 2024 (2024-03-21 pdf)
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* DONE Preface - i
CLOSED: [2018-10-25 Thu 00:07]
- The *AIMS* of this book are _TWO-FOLD_:
  * to introduce /monads/, /functors/, and OTHER /functional programming patterns/
    as a way to *structure program design*,

    AND

  * to *explain* HOW these concepts are *implemented in Cats*.

- Functional patterns differ from OO patterns in *TWO* main ways:
  * thye are _formally_, and thus precisely, defined;

    =from Jian= OO patterns also have formal theory, but not as the functional
    patterns, which are math itself. For OO, a bridge need to be built between
    it and math.

    AND

  * they are extremely (rextremely) GENERAL.

** DONE Preface from Scala with Cats - 2 - =TODO: NOTE=
** DONE Versions - 3
CLOSED: [2018-10-25 Thu 00:07]
This book use *Scala 3.3.0* and *Cats 2.9.0*.
You can use this minimal =build.sbt=:
#+BEGIN_SRC scala
  scalaVersion := "3.3.0"

  libraryDependencies +=
    "org.typelevel" %% "cats-core" % "2.9.0"

  scalacOptions ++= Seq(
    "-Xfatal-warnings"
  )
#+END_SRC

*** DONE Template Projects - 3
CLOSED: [2018-10-25 Thu 00:06]
- The minimal one:
  ~sbt new scalawithcats/cats-seed.g8~

- The more batteries-included one:
  ~sbt new typelevel/sbt-catalysts.g8~

- =TODO= =LEARN MORE=
  =tut-enabled=, =catalysts=, =sbt-catalysts=.

** DONE Conventions Used in This Book - 4
CLOSED: [2018-10-25 Thu 00:07]
*** Typographical Conventions - 4
*** Source Code - 4
*** Callout Boxes - 5

** DONE Acknowledgements - 5
   CLOSED: [2018-10-25 Thu 00:07]
*** Acknowledgements from Scala with Cats - 5
*** Backers - 6

** TODO License - 7

* TODO 1 Functional Programming Strategies - 1
** 1.1 Three Levels for Thinking About Code - 3
** 1.2 Functional Programming - 5
*** 1.2.1 What Functional Programming Is - 5
**** 1.2.1.1 Types - 6

*** 1.2.2 What Functional Programming Isn't - 7
*** 1.2.3 Why It Matters - 9
*** 1.2.4 The Evidence for Functional Programming - 10
*** 1.2.5 Final Words - 11

* I. Foundations - 13
* TODO 2 Algebraic Data Types - 17
** 2.1 Building Algebraic Data Types - 18
*** 2.1.1 Sums and Products - 18
*** 2.1.2 Closed Worlds - 19

** 2.2 Algebraic Data Types in Scala - 19
*** 2.2.1 Algebraic Data Types in Scala 3 - 20
*** 2.2.2 Algebraic Data Types in Scala 2 - 21
*** 2.2.3 Examples - 22
**** 2.2.3.1 Role and User - 22
**** 2.2.3.2 Paths - 23

*** 2.2.4 Representing ADTs in Scala 3 - 24

** 2.3 Structural Recursion - 25
*** 2.3.1 Pattern Matching - 25
*** 2.3.2 The Recursion in Structural Recursion - 26
*** 2.3.3 Exhaustivity Checking - 31
*** 2.3.4 Dynamic Dispatch - 32
*** 2.3.5 Folds as Structural Recursions - 34

** 2.4 Structural Corecursion - 38
- *Duality in Functional Programming*

*** 2.4.1 Unfolds as Structural Corecursion - 47

** 2.5 The Algebra of Algebraic Data Types - 48
** 2.6 Conclusions - 51

* TODO 3 Objects as Codata - 55
** 3.1 Data and Codata - 56
** 3.2 Codata in Scala - 59
** 3.3 Structural Recursion and Corecursion for Codata - 62
*** 3.3.1 Efficiency and Effects - 70

** 3.4 Relating Data and Codata - 74
** 3.5 Data and Codata Extensibility - 81
** 3.6 Exercise: Sets - 84
** 3.7 Conclusions - 86

* TODO 4 Contextual Abstraction - 89
CLOSED: [2019-03-23 Sat 02:53]
The majority of the tools provided by Cats are delivered in the form of /type
classes/ that we can apply to existing Scala types. These tools allow us to
extend existing libraries with new functionality, without using traditional
inheritance, and without altering the original library source code.

- TODO TODO TODO ??? ??? ???
  We'll finish by _tying_ /type classes/ back _into_ /algebraic data types/,
  /pattern matching/, /value classes/, and /type aliases/, presenting a
  structured approach to functional programming in Scala.

** TODO 4.1 The Mechanics of Contextual Abstraction - 90
*** TODO 4.1.1 Using Clauses - 90
*** TODO 4.1.2 Given Instances - 91
*** TODO 4.1.3 Given Scope and Imports - 92
**** TODO 4.1.3.1 Given Instance Priority - 96

** TODO 4.2 Anatomy of a Type Class - 98
There are *THREE* important _components_ to the /type class pattern/:
1. the /type class/ itself
2. /instances/ for particular types
3. the /interface methods/ that we expose to users.

*** DONE 4.2.1 The Type Class - 98
CLOSED: [2020-02-16 Sun 19:41]
A /type class/ is an /interface/ OR /API/
that REPRESENTS some functionality we want to implement.

- In Cats a /type class/
  * is represented by _a *trait* with AT LEAST *ONE* /type parameter/._

- For example,
  represent generic "serialize to JSON" behaviour as follows:
  #+begin_src scala
    // Define a very simple JSON AST
    sealed trait Json
    final case class JsObject(get: Map[String, Json]) extends Json
    final case class JsString(get: String)            extends Json
    final case class JsNumber(get: Double)            extends Json
    case object JsNull                                extends Json

    // The "serialize to JSON" behaviour is encoded in this trait
    trait JsonWriter[A] {
      def write(value: A): Json
    }
  #+end_src
  ~JsonWriter~ is our "type class", with ~Json~ and its /subtypes/ providing
  supporting code.

*** DONE 4.2.2 Type Class Instances - 99
CLOSED: [2020-02-16 Sun 19:41]
_The /instances/ of a /type class/ provide *implementations for the types* we
care about._

- In Scala
  we define /instances/ by
  * creating *concrete implementations* of the /type class/
    AND
  * tagging them with the ~implicit~ keyword:

- Example code:
  #+begin_src scala
    final case class Person(name: String, email: String)

    object JsonWriterInstances {
      implicit val stringWriter: JsonWriter[String] =
        new JsonWriter[String] {
          def write(value: String): Json =
            JsString(value)
        }

      implicit val personWriter: JsonWriter[Person] =
        new JsonWriter[Person] {
          def write(value: Person): Json =
            JsObject(Map("name"  -> JsString(value.name),
                         "email" -> JsString(value.email)))
        }

      // etc...
    }
  #+end_src

*** TODO 4.2.3 Type Class Use - 100
**** 4.2.3.1 Interface Objects - 100
**** 4.2.3.2 Interface Syntax - 101
**** 4.2.3.3 The ~summon~ Method - 103

** TODO 4.3 Type Class Composition - 104
*** 4.3.1 Type Class Composition in Scala 2 - 105

** TODO 4.4 What Type Classes Are - 106
** TODO 4.5 Exercise: Display Library - 108
*** 4.5.1 Using the Library - 109
*** 4.5.2 Better Syntax - 109

** TODO 4.6 Type Classes and Variance - 110
*** 4.6.1 Variance - 110
*** 4.6.2 Covariance - 111
*** 4.6.3 Contravariance - 111
*** 4.6.4 Invariance - 113
*** 4.6.5 Variance and Instance Selection - 113

** TODO 4.7 Conclusions - 116

* TODO 5 Reified Interpreters - 119
** 5.1 Regular Expressions - 120
** 5.2 Interpreters and Reification - 129
*** 5.2.1 The Structure of Interpreters - 130
*** 5.2.2 Implementing Interpreters with Reification - 131

** 5.3 Tail Recursive Interpreters - 132
*** 5.3.1 The Problem of Stack Safety - 133
*** 5.3.2 Tail Calls and Tail Position - 134
*** 5.3.3 Continuationâ€Passing Style - 136
*** 5.3.4 Trampolining - 141
*** 5.3.5 When Tail Recursion is Easy - 146

** 5.4 Conclusions - 149

* DONE II Type Classes - 151
* DONE 6 Using Cats - 155
** TODO 6.1 Quick Start - 155
** TODO 6.2 Using Cats - 156
*** TODO 6.2.1 Defining Custom Instances - 157
**** TODO 6.2.1.1 Exercise: Cat Show - 158

** TODO 6.3 Example: ~Eq~ - 159
*** 6.3.1 Equality, Liberty, and Fraternity - 159
*** 6.3.2 Comparing Ints - 160
*** 6.3.3 Comparing Options - 161
*** 6.3.4 Comparing Custom Types - 162
**** 6.3.4.1 Exercise: Equality, Liberty, and Felinity - 162

* DONE 7 Monoids and Semigroups - 165
CLOSED: [2020-02-18 Tue 02:22]
/Type classes/ /monoid/ and /semigroup/ allow us to combine values.
- There are instances for ~Int~, ~String~, ~List~, ~Option~, and many more.

*** DONE 7.0.0.1 Integer addition - 165
CLOSED: [2018-10-26 Fri 21:35]
- Operation: Closed under integer ~+~
- Identity: ~0~
- Associativity

*** DONE 7.0.0.2 Integer multiplication - 166
CLOSED: [2018-10-26 Fri 21:35]
- Operation: Closed under integer ~*~
- Identity: ~1~
- Associativity

*** DONE 7.0.0.3 String and sequence concatenation - 166
CLOSED: [2018-10-26 Fri 21:35]
- Operation: Closed under String concatenation ~++~
- Identity: ~""~
- Associativity

** DONE 7.1 Definition of a ~Monoid~ - 167
CLOSED: [2020-02-18 Tue 00:20]
- Formally, a /monoid/ for a type ~A~:
  * It has
    + an operation ~combine~ with type ~(A, A) => A~
    + an element ~empty~ of type ~A~
  * It obeys
    + association laws
    + identity laws

- /Monoid/ in Cats:
  #+BEGIN_SRC scala
    trait Monoid[A] {
      def combine(x: A, y: A): A
      def empty: A
    }
  #+END_SRC

- Only the ~combine~ and ~empty~ /methods/ of this ~trait~ *CANNOT* guarantee
  the _monoid in math_ -- /monoids/ *must formally obey* several /laws/, here
  are functions that can be used to _test_ the /laws/:
  #+BEGIN_SRC scala
    def associativeLaw[A : Monoid](x: A, y: A, z: A): Boolean = {
      val m = implicitly[A]
      m.combine(x, m.combine(y, z)) == m.combine(m.combine(x, y), z)
    }

    def identityLaw[A : Monoid](x: A): Boolean = {
      val m = implicitly[A]
      (m.combine(x, m.empty) == x) && (m.combine(m.empty, x) == x)
    }
  #+END_SRC
  * =from Jian=
    Scala does NOT contain a system that can prove a thing defined as monoid-like
    is really a /monoid/. We write down laws, and then prove it with some proof
    system (including a person with pen and paper :-)). In Scala, a more applicable
    way is write down the laws in code, and use tests to show some proof (of
    course, this is often not comprehensive). Even in Scala, we should do the
    paper and pen proof for complicated user-defined monoid.

- /Integer subtraction/ does *NOT* obey the /associative law (for /monoid/)/,
  and there is NO /monoid/ under /integer subtraction/ operation.

- AGAIN,
  *Unlawful instances are dangerous*!!!
  *Unlawful instances are dangerous*!!!
  *Unlawful instances are dangerous*!!!

  It will yield *unpredictable results*.

** DONE 7.2 Definition of a ~Semigroup~ - 168
CLOSED: [2020-02-18 Tue 00:24]
/Semigroups/ have only ~combine~ and NO ~empty~.

- /Semigroups/ are often /monoids/.

- We can add some _restriction_ to eliminate /identitis/ of /monoids/, and
  make them no longer /monids/, but /semigroups/ ONLY.
  For example, there is one we often see and use
  * positive numbers

  * none empty sequences.
    For example, the ~NonEmptyList~ in Cats.

- A more accurate, but still simplified compared to the code in Cats,
  definition of Cat's ~Monoid~ is:
  #+begin_src scala
    trait Semigroup[A] {
      def combine(x: A, y: A): A
    }

    trait Monoid[A] extends Semigroup[A] {
      def empty: A
    }
  #+end_src

*** DONE 7.2.0.1 Exercise: The Truth About Monoids - 169
CLOSED: [2020-02-18 Tue 00:49]
We first complete the ~Monoid~ related definitions in Cats:
#+begin_src scala
  trait Semigroup[A] {
    def combine(x: A, y: A): A
  }

  trait Monoid[A] extends Semigroup[A] {
    def empty: A
  }

  object Monoid {
    def apply[A](implicit monoid: Monoid[A]) =
      monoid
  }
#+end_src

Then let's define the ~Boolean~ related ~Monoid~ (NOT only one):
#+BEGIN_SRC scala
  implict val booleanAndMonoid = new Monoid[Boolean] {
    def combine(x: Boolean, y: Boolean): Boolean = x && y
    def empty: Boolean = true
  }

  implict val booleanOrMonoid = new Monoid[Boolean] {
    def combine(x: Boolean, y: Boolean): Boolean = x || y
    def empty: Boolean = false
  }

  implict val booleanXorMonoid = new Monoid[Boolean] {
    def combine(x: Boolean, y: Boolean): Boolean = (x && !y) || (!x && y)
    def empty: Boolean = false
  }

  implict val booleanXnorMonoid = new Monoid[Boolean] {
    def combine(x: Boolean, y: Boolean): Boolean = (!x || y) && (x || !y)
    def empty: Boolean = true
  }
#+END_SRC
The /identity law/ holds in each case is straightforward.
The /associative law/ can be proved by enumerating the cases.

*** DONE 7.2.0.2 Exercise: All ~Set~ for Monoids - 170
CLOSED: [2020-02-18 Tue 00:52]
- ~Monoid[Set[A]]~ exists UNDER /sets/ ~union~ operation with ~Set.empty[A]~ as
  /identity/:
  #+BEGIN_SRC scala
    implicit def setUnionMonoid[A] = new Monoid[Set[A]] {
      def combine(x: Set[A], y: Set[A]): Set[A] =
        x union y

      // Now you know why we use `def` for `empty` in the definition of `Monoid`!
      def empty: Set[A] = Set.empty
    }
  #+END_SRC
  * Use cases:
    #+begin_src scala
      val intSetMonoid = Monoid[Set[Int]]
      val strSetMonoid = Monoid[Set[String]]

      intSetMonoid.combine(Set(1, 2), Set(2, 3))
      // res2: Set[Int] = Set(1, 2, 3)

      strSetMonoid.combine(Set("A", "B"), Set("B", "C"))
      // res3: Set[String] = Set(A, B, C)
    #+end_src

- ~Semigroup[Set[A]]~ exists UNDER /sets/ ~intersect~ opertion.
  There is *NO* ~Monoid[Set[A]]~ under this operation.

- /Set complement/ and /set difference/ are *NOT* /associative/.
  They are not /monoid/ or /semigroup/.

- ~Monoid[Set[A]]~ exists UNDER /sets/ /symmetric difference/ operation with
  ~Set.empty[A]~ as /identity/:
  #+BEGIN_SRC scala
    implicit def setSymDiffMonoid[A] = new Monoid[Set[A]] {
      def combine(x: Set[A], y: Set[A]): Set[A] =
        (x diff y) union (y diff x)

      def empty: Set[A] = Set.empty
    }
  #+END_SRC

** DONE 7.3 Monoids in Cats - 170
CLOSED: [2020-02-18 Tue 01:09]
We've seen what /monoids/ are.
Now let's look at their *implementation in Cats*.

- Once again we'll look at the *THREE* main aspects of the implementation:
  * the /type class/
  * the /instances/
  * the /interface/ (syntax)

*** DONE 7.3.1 The Monoid Type Class - 170
CLOSED: [2020-02-18 Tue 00:58]
~cats.Monoid~ (an alias of ~cats.kernel.Monoid~) and ~cats.Semigroup~ (an
alias of ~cats.kernel.Semigroup~).
#+begin_src scala
  import cats.Monoid
  import cats.Semigroup
#+end_src

- *Cats Kernel?*
  /Cats Kernel/ is a _subproject_ of Cats providing _a small set_ of
  /typeclasses/ *for libraries that don't require the full Cats toolbox*.

  While these _CORE_ /type classes/ are technically defined in the ~cats.kernel~
  /package/, _they are ALL *aliased* to the ~cats~ package so we RARELY need
  to be aware of the distinction._

  * The /Cats Kernel/ /type classes/ covered in this book:
    + ~Eq~
    + ~Semigroup~
    + ~Monoid~

  * All the other /type classes/ we cover are part of the main Cats project
    and are defined _directly_ in the ~cats~ /package/.

*** DONE 7.3.2 Monoid Instances - 171
CLOSED: [2020-02-18 Tue 00:59]
 - Example (usage):
   #+BEGIN_SRC scala
     import cats.Monoid
     import cats.instances.string._

     Monoid[String].combine("Hi ", "there")  // "Hi there"
     Monoid[String].empty                    // ""
   #+END_SRC
   * ~Monoid[String]~ is actually ~Monoid.apply[String]~

   * ~Semigroup~ usage is similar.

 - Aseemble a ~Monoid[Option[Int]]~:
   #+begin_src scala
     import cats.Monoid
     import cats.instances.int._     // for Monoid
     import cats.instances.option._  // for Monoid

     val a = Option(22)  // a: Option[Int] = Some(22)
     val b = Option(20)  // b: Option[Int] = Some(20)

     Monoid[Option[Int]].combine(a, b)
   #+end_src

*** DONE 7.3.3 Monoid Syntax - 172
CLOSED: [2020-02-18 Tue 01:00]
~|+|~ is the /combine/ operator, which comes from ~cats.syntax.semigroup._~
#+BEGIN_SRC scala
  import cats.instances.string._
  import cats.syntax.semigroup._  // for |+|

  val stringResult = "Hi " |+| "there" |+| Monoid[String].empty
  // stringResult: String = Hi there

  import cats.instances.int._ // for Monoid
  val intResult = 1 |+| 2 |+| Monoid[Int].empty
  // inResult: Int = 3
#+END_SRC

**** DONE 7.3.3.1 Exercise: Adding All The Things - 172
CLOSED: [2020-02-18 Tue 01:06]
- Write ~add~ for ~Int~
  #+BEGIN_SRC scala
    def add(items: List[Int]): Int =
      items.foldLeft(0)(_ + _)
  #+END_SRC

- Write generics that can work for ~Int~ and ~Option[Int]~
  #+BEGIN_SRC scala
    import cats.Monoid
    import cats.instances.int._
    import cats.instances.option._
    import cats.syntax.semigroup._

    def add[A](items: List[A])(implicit monoid: Monoid[A]): A =
      items.foldLeft(monoid.empty)(_ |+| _)
  #+END_SRC

  If there is NOT ~None~ in the list, we'll see:
  #+BEGIN_SRC scala
    add(List(Some(1), Some(2), Some(3)))
    // <console>:61: error: could not find implicit value for evidence parameter of type cats.Monoid[Some[Int]]
    //        add(List(Some(1), Some(2), Some(3)))
    //           ^
  #+END_SRC
  This is because /Cats/ will ONLY generate a ~Monoid~ for ~Option[Int]~.

- Make ~Order~ addable.
  #+BEGIN_SRC scala
    import cats.Monoid

    case class Order(totalCost: Double, quantity: Double)

    implicit val orderMonoid = new Monoid[Order] {
      def combine(x: Order, y: Order): Order =
        Order(x.totalCost + y.totalCost,
              x.quantity + y.quantity)

      def empty: Order =
        Order(0.0, 0.0)
    }
  #+END_SRC

** DONE 7.4 Applications of Monoids - 173
CLOSED: [2020-02-18 Tue 02:12]
Here are a few big ideas where /monoids/ play a major role.
TODO More detail in case studies later in this book.

*** DONE 7.4.1 Big Data - 173
CLOSED: [2020-02-18 Tue 02:11]
- Use cases (Need process a huge amount of logs, NOT/CANNOT in ONLY one
  computer):
  * Calculate how many total visitors a web site has received.
    -- thanks for the reality non-negative ~Int~ under the operation of
       /addition/ and the /zero element/ of ~0~ is a /monoid/.

  * Calculate how many unique visitors a web site has received.
    -- thanks for the reality that ~Set(Int)~ under the operation of
       /union/ and the /zero element/ of ~Set.empty[Int]~ is a /monoid/.

  * If we want to calculate 99% and 95% response times from our server logs,
    we can use a data structure called a ~QTree~ for which there is a /monoid/.
    TODO _Learn how to design and implement this data structure._

- Summary:
  Almost every analysis that we might want to do over a large data set is a
  /monoid/, and therefore we can build an expressive and powerful analytics
  system around this idea.

  This is exactly what Twitter's Algebird and Summingbird projects have
  done. We explore this idea further in the map-reduce case study.

*** DONE 7.4.2 Distributed Systems - 174
CLOSED: [2020-02-18 Tue 02:11]
=TODO= =Case-Study= We explore this idea further in *the CRDT case study*.

*** DONE 7.4.3 Monoids in the Small - 174
CLOSED: [2020-02-18 Tue 02:11]
There are also many cases where having a monoid around makes it easier to
write a small code fragment.

See *case studies* of this book

** DONE 7.5 Summary - 174
CLOSED: [2020-02-18 Tue 02:21]

* DONE 8 Functors - 177 - =TODO= _contravariant and invariant functors_
CLOSED: [2020-02-20 Thu 11:22]
- /Functors/ allow us to represent sequences of operations within a /context/.

- /Functor/ is the base of /applicative functor/ and /monad/, which are more
  useful.

** DONE 8.1 Examples of Functors - 177
CLOSED: [2020-02-18 Tue 02:31]
- Because ~map~ leaves the the /context/ unchanged, we can call it repeatedly
  to *sequence* multiple computations on the _contents_ of an initial data
  structure.
  #+begin_src scala
    // Of course, the first two map's can be merged to one,
    // Here is a illustration example, not best practice:
    List(1, 2, 3).
      map(_ + 1).
      map(_ * 2).
      map(_ + "!")
  #+end_src

- We should think of ~map~
  * *NOT*
    as an /iteration pattern/,
    =from Jian=
    This point of view is not related to composition and is rules
    In the context of category, we don't inspect the object we use in this
    point of view.

  * BUT
    as a way of *sequencing* computations on values
    IGNORING SOME COMPLICATION dictated by the relevant data type.

** DONE 8.2 More Examples of Functors - 179
CLOSED: [2020-02-18 Tue 13:43]
1. Before:
   The ~map~ methods of ~List~, ~Option~, and ~Either~ apply functions eagerly.

2. However, the idea of _sequencing computations_ is MORE GENERAL than this.

3. This Section:
   Let's investigate the behaviour of some other functors that apply the
   pattern in different ways.

**** DONE ~Futures~ - 179
CLOSED: [2020-02-18 Tue 13:16]
#+begin_src scala
  import scala.concurrent.{Future, Await}
  import scala.concurrent.ExecutionContext.Implicits.global
  import scala.concurrent.duration._

  val future: Future[String] =
    Future(123).
      map(n => n + 1).
      map(n => n * 2).
      map(n => n + "!")

  Await.result(future, 1.second)
  // res3: String = 248!
#+end_src

- *Futures and Referential Transparency*
  * Scala's ~Future~'s are *NOT* a great EXAMPLE of _pure functional pro-
    gramming_ because they are *NOT* /referentially transparent/.

  * =from Jian=
    + Q :: Want to use ~Future~ as a /functor/?
    + A :: ONLY use it to do pure computations.

**** DONE Functions (?!) - 182
CLOSED: [2020-02-20 Thu 09:53]
- *It turns out that /single argument functions/ are also /functors/*

- ~map~ for /single argument functions/ is, by concept, /function composition/
  (it works like ~andThen~) -- a kind of *sequencing*! It's queueing up
  operations.

  For example:
  #+begin_src scala
    import cats.instances.functor._  // for `Functor`
    import cats.syntax.functor._     // for `map`

    val func1: Int => Double =
      (x: Int) => x.toDouble

    val func2: Int => Double =
      (y: Double) => y * 2

    (func1 map func2)(1)      // composition using `map`
    // res7: Double = 2.0

    (func1 andThen func2)(1)  // composition using `andThen`
    // res8: Double = 2.0

    func2(func2(1))           // composition with manually encoding
    // res9: Double = 2.0
  #+end_src

- Example:
  #+begin_src scala
    val func =
      ((x: Int) => x.toDouble).
        map(_ + 1).
        map(_ * 2).
        map(_ + "!")

    func(123)
    // res10: String = 248.0!
  #+end_src

- *Partial Unification*
  _BEFORE Scala 2.13_, You need ~scalaOptions += "-Ypartial-unification"~

  Or you'll see some error like:
  #+BEGIN_SRC scala
    func1.map(func2)
    // <console>: error: value map is not a member of Int => Double
    //        func1.map(func2)
  #+END_SRC

  * =TODO= EXPLAIN in Seciton 3.8
    Use compiler option ~-Ypartial-unification~

** DONE 8.3 Definition of a Functor - 184
CLOSED: [2020-02-18 Tue 17:07]
#+BEGIN_SRC scala
  package cats

  import scala.language.higherKinds

  trait Functor[F[_]] {
    def map[A, B](fa: F[A])(f: A => B): F[B]
  }
#+END_SRC
- TODO Next SECTION will explain:
  * /type constructors/ and /higher kinded types/ -- be related to the ~F[_]~
    above.
  * The ~scala.language~ line.


- *Functor Laws*
  * *Identity*:
    calling ~map~ with the /identity function/ is the same as doing nothing:
    _(fa map identity) \equiv{} fa_

  * *Composition*:
    mapping with two functions ~f~ and ~g~ is the same as mapping with ~f~
    and then mapping with ~g~:
    _fa.map(g(f(_))) \equiv{} fa.map(f).map(g)_
    =from Jian=
    The RHS can also be written as ~fa map f map g~
    Or a much more easier to understand version (ONLY when ~fa~ is a single
    parameter function):
    ~fa andThen g(f(_))~ \equiv{} ~fa andThen f andThen g~

** DONE 8.4 Aside: Higher Kinds and Type Constructors - 185
CLOSED: [2020-02-19 Wed 16:01]
=IMPORTANT=
- kinds :: "types" for /types/ -- a concept used to category /types/.

- Informally, a /kind/ of a /type/ is the "hole" in a type -- how many
  /types/ we need to feed in to get a *no ~=>~ /type/.*

- If a /type/ has "hole" (a /type/ on the left hand side of ~=>~ is a "hole"),
  it is called a /higher kinded type/ or a /type constructor/.

  * For example,
    ~List~ is a /type constructor/ (/higher kinded type/), and ~List[Int]~ is a
    /type/ (/kind one type/).

  * A close analogy:
    In Scala, function is also a /value/ in general, but we can also call it
    "value constructor", and call the /value/ that cannot take any parameter
    "value".

- In Scala
  #+BEGIN_SRC scala
    def myMethod[F[_]] = {            // Define
      val functor = Functor.apply[F]  // Reference
    }
  #+END_SRC
  1. we *declare* /type constructors/ with the help of _underscores_.
     Once we've declared them, however,
  2. we *refer to* them as SIMPLE /identifiers/ -- ~F~.

  This is *analogous to* specifying a function's parameters in its definition and
  ommiting them when refering to it:
  #+BEGIN_SRC scala
    val f = (x: Int) => x * 2  // Declare
    val f2 = f andThen f       // Reference
  #+END_SRC

- *Language Feature Imports*
  /Higher kinded types/ are considered an _ADVANCED language feature_ in
  Scala, and you need to enable it in the compiler. There are two ways:
  * Explicit import:
    ~import scala.language.higherKinds~
    More explicit, use it in this book.

  * Set in =build.sbt=:
    ~scalacOptions += "-language:higherKinds~
    More concise, and you may prefer this in your projects.

** DONE 8.5 Functors in Cats - 187
CLOSED: [2020-02-19 Wed 20:06]
Examine the aspects we did for /monoids/:
1. the /type class/
2. the /instances/
3. the /syntax/

*** DONE 8.5.1 The ~Functor~ Type Class and Instances - 187
CLOSED: [2020-02-19 Wed 16:03]
- We *obtain* /instances/ using the STANDARD ~Functor.apply~ /method/ on the
  /companion object/.

- Basic usage:
  #+BEGIN_SRC scala
    import scala.language.higherKinds
    import cats.Functor

    //------------------------------------------
    // `List` functor
    //------------------------------------------
    import cats.instances.list._

    val list1 = List(1, 2, 3)
    // list1: List[Int] = List(1, 2, 3)

    val list2 = Functor[List].map(list1)(_ * 2)
    // list2: List[Int] = List(2, 4, 6)

    //------------------------------------------
    // `Option` functor
    //------------------------------------------
    import cats.instances.option._

    val option1 = Option(123)
    // option1: Option[Int] = Some(123)

    val option2 = Functor[Option].map(option1)(_.toString)
    // option2: Option[String] = Some(123)
  #+END_SRC

- The ~lift~ /method/ of /functors/:
  ~A => B~ to ~F[A] => F[B]~

  #+BEGIN_SRC scala
    val func = (x: Int) => x + 1
    // func: Int => Int = <function1>

    val liftedFunc = Functor[Option].lift(func)
    // liftedFunc: Option[Int] => Option[Int] = cats.Functor$$Lambda$11699/1098992879@279f562e

    liftedFunc(Option(1))
    // res0: Option[Int] = Some(2)
  #+END_SRC

*** DONE 8.5.2 ~Functor~ Syntax - 188
CLOSED: [2020-02-19 Wed 19:33]
Use examples other than ~Option~ and ~List~ as illustration.
(Rationale: Compiler _always prefer a built-in_ method _over_ an extension
method).

- ~Function1~ example:
  #+begin_src scala
    import cats.instances.function._ // for Functor
    import cats.syntax.functor._ // for map

    val func1 = (a: Int) => a + 1
    val func2 = (a: Int) => a * 2
    val func3 = (a: Int) => a + "!"
    val func4 = func1.map(func2).map(func3)

    func4(123)
    // res1: String = 248!
  #+end_src

- A method for general /functors/:
  #+begin_src scala
    def doMath[F[_]](start: F[Int])
              (implicit functor: Functor[F]): F[Int] =
      start.map(_ + 2)

    import cats.instances.option._
    import cats.instances.list._

    doMath(Option(20))
    // res3: Option[Int] = Some(22)

    doMath(List(1, 2, 3))
    // res4: List[Int] = List(3, 4, 5)
  #+end_src

- To illustrate how this works, let's take a look at the definition of the
  ~map~ /method/ in ~cats.syntax.functor~. Here is a simplified version:
  #+begin_src scala
    implicit class FunctorOps[F[_], A](src: F[A]) {
      def map[B](func: A => B)
                (implicit functor: Functor[F]): F[B] =
        functor.map(src)(func)
    }
  #+end_src

  #+begin_src scala
    foo.map(_ + 1)
    // `foo` should have type `F[Int]`

    // 1.
    new FunctorOps(foo).map(_ + 1)
    // There should be a `Functor[F]` implicit parameter.

    // 2.
    new FunctorOps(foo).map(_ + 1)(fooFunctor)

  #+end_src

  * Example: =from Jian= The procesure of /implicit search/.
    We have a expression ~foo.map(_ + 1)~.
    + Assuming ~foo~ has no built-in ~map~ /method/,
      the compiler detects the potential error and wraps the expression in a
      ~FunctorOps~ to fix the code:
      #+begin_src scala
        new FunctorOps(foo).map(_ + 1)
      #+end_src

    + The ~map~ /method/ of ~FunctorOps~ *requires* an ~implicit Functor~ as
      a parameter.
        This means this code will *ONLY compile* if we have a ~Functor~ for
      ~foo~ (type ~A~) in scope. If we don't, we get a compiler error.

*** DONE 8.5.3 Instances for Custom Types - 190
CLOSED: [2020-02-19 Wed 19:53]
- Simple and straightfoward example (already in ~cats.instances~):
  #+BEGIN_SRC scala
    implicit val optionFunctor: Functor[Option] =
      new Functor[Option] {
        def map[A, B](value: Option[A])(func: A => B): Option[B] =
          value.map(func)
      }
  #+END_SRC

- Must *inject dependencies* into our /instances/,
  BUT we can't add parameter(s) to ~future.map~ -- obviously.

  Thus, we provide /dependencies/ when summon the required /instance/.
  #+BEGIN_SRC scala
    import scala.concurrent.{Future, ExecutionContext}

    implicit def futureFunctor(implicit ec: ExecutionContext): Functor[Future] =
      new Functor[Future] {
        def map[A, B](value: Future[A])(func: A => B): Future[B] =
          value.map(func)
      }
  #+END_SRC

- Whenever we summon a ~Functor~ for ~Future~, either directly using
  ~Functor.apply~ or indirectly via the ~map~ /extension method/, the
  compiler will locate ~futureFunctor~ by /implicit resolution and recursively
  search/ for an ~ExecutionContext~ at the call site.

  This is what the expansion might look like:
  #+begin_src scala
    // We write this:
    Functor[Future]

    // Step 1.
    Functor.apply[Future]

    // Step 2.
    Functor.apply[Future](futureFunctor)

    // Step 3.
    Functor.apply[Future](futureFunctor(executionContext))
  #+end_src

*** DONE 8.5.4 Exercise: Branching out with Functors - 191
CLOSED: [2020-02-19 Wed 20:05]
#+BEGIN_SRC scala
  sealed trait Tree[+A]

  final case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]
  final case class Leaf[A](value: A)                        extends Tree[A]

  implicit treeFunctor = new Functor[Tree] {
    def map[A, B](tree: Tree[A])(func: A => B): Tree[B] =
      tree match {
        case Leaf(v)      => Leaf(func(v))
        case Branch(l, r) => Branch(map(l)(func), map(r)(func))
      }
  }
#+END_SRC
1. This is right, but not complete:
   #+begin_src scala
     Branch(Leaf(10), Leaf(20)).map(_ * 2)
     // <console>: 42: error: value map is not a member of wrapper.Branch[Int]
     //        Branch(Leaf(10), Leaf(20)).map(_ * 2)
   #+end_src
   =from Jian= Can dotty new /enum/ resolve this???

2. Let's add some smart constructors to compensate:
   #+begin_src scala
     object Tree {
       def branch[A](left: Tree[A], right: Tree[A]): Tree[A] =
         Branch(left, right)

       def leaf[A](value: A): Tree[A] =
         Leaf(value)
     }

     Tree.leaf(100).map(_ * 2)
     Tree.branch(Tree.leaf(10), Tree.leaf(20)).map(_ * 2)
   #+end_src

** DONE 8.6 Contravariant and Invariant Functors - 191 - =TODO=
CLOSED: [2019-03-31 Sun 01:56]
- The ~Functor~ we explored is actually /covariant functor/, and its ~map~
  *appends* a transformation to a chain.

- We're now going to look at _TWO_ other /type classes/:
  * contravariant functor :: one representing *prepending* operations to a chain,
  * invariant functor :: one representing building a *bidirectional* chain of operations.

- *This Section is Optional!*
  You do _NOT NEED_ to know about /contravariant and invariant functors/ to
  understand /monads/, the most important pattern in this book.

    HOWEVER, /contravariant/ and /invariant/ do come in HANDY in our
  discussion of ~Semigroupal~ and ~Applicative~ in Chapter 6.
  =from Jian= WHY???

  _If you want to move on to monads now, feel free to skip straight to
  Chapter 4. Come back here before you read Chapter 6._

*** DONE 8.6.1 Contravariant Functors and the ~contramap~ Method - 192
CLOSED: [2019-03-31 Sun 01:55]
- /contravariant functor/:
  * ~contramap~ - "prepending" an operation to a chain.

- The ~contramap~ /method/ *only makes sense* for
  _data types that represent transformations._
  =IMPORTANT=
  For example,
  * _Can't_
    There is *NO WAY* to feed a value in an ~Option[B]~ backwards through a
    function ~A => B~.

  * _Can_
    #+begin_src scala
      trait Printable[A] { self =>
        def format(value: A): String
        def contramap[B](func: B => A): Printable[B] = ???
      }
    #+end_src

**** DONE 8.6.1.1 Exercise: Showing off with Contramap - 193
CLOSED: [2019-03-31 Sun 01:55]
#+BEGIN_SRC scala
  trait Printable[A] { self =>
    def format(value: A): String

    def contramap[B](func: B => A): Printable[B] =
      new Printable[B] {
        def format(value: B): String = self.format(func(value))
      }

    //// More concise version:
    // def contramap[B](func: B => A): Printable[B] =
    //   value => self.format(func(value))
  }

  def format[A](value: A)(implicit p: Printable[A]): String =
    p.format(value)
#+END_SRC

- Exercise:
  ~final case class Box[A](value: A)~
  Define an /instance/ of ~Printable~ for ~Box~.
  #+begin_src scala
    implicit def boxPrintable[A](implicit p: Printable[A]): Printable[Box[A]] =
      p.contramap[Box[A]](_.value)
  #+end_src

*** DONE 8.6.2 Invariant functors and the ~imap~ method - 195
CLOSED: [2019-03-31 Sun 01:47]
/Invariant functors/ implement a method called ~imap~.

- ~imap~ is _INFORMALLY equivalent to a combination of ~map~ and ~contramap~._

- If ~map~ generates new /type class/ instances by *appending* a function to a chain,
     and
     ~contramap~ generates them by *prepending* an operation to a chain,

  ~imap~ generates them via _a PAIR of_ *BIDIRECTIONAL transformations*.

- The most intuitive examples:
  A /type class/ that represents _encoding_ and _decoding_ as some data type,
  such as Play JSON's ~Format~ and scodec's ~Codec~.
  TODO I know the former, but I don't know the latter. TODO

- Build our own ~Codec~ by enhancing ~Printable~ to support /encoding/ and
  /deconding/ to/from a ~String~:
  #+begin_src scala
    trait Codec[A] {
      def encode(value: A): String
      def decode(value: String): A
      def imap[B](dec: A => B, enc: B => A): Codec[B] = ???
    }

    def encode[A](value: A)(implicit c: Codec[A]): String =
      c.encode(value)

    def decode[A](value: String)(implicit c: Codec[A]): A =
      c.decode(value)
  #+end_src

- The type chart for imap is shown in *Figure 3.6*. If we have a ~Codec[A]~
  and a pair of functions ~A => B~ and ~B => A~, the imap method creates a
  ~Codec[B]~.

- As an example use case, imagine we have a basic ~Codec[String]~, whose
  ~encode~ and ~decode~ /methods/ are both a no-op:
  #+begin_src scala
    implicit val stringCodec: Codec[String] =
      new Codec[String] {
        def encode(value: String): String = value
        def decode(value: String): String = value
      }
  #+end_src
  We can construct many usefull ~Codec~'s for other types by building off of
  ~stringCodec~ using ~imap~:
  #+begin_src scala
    implicit val intCodec: Codec[Int] =
      stringCodec.imap(_.toInt, _.toString)

    implicit val booleanCodec: Codec[Boolean] =
      stringCodec.imap(_.toBoolean, _.toString)
  #+end_src

- *Coping with Failure* TODO TODO TODO
  * Our ~Codec~ /type class/ does NOT account for failures.

  * If we want to model more sophisticated relationships we can move beyond
    /functors/ to look at /lenses/ and /optics/.

    _This beyond this book (See Julien Truffaut's /Monocle/)._

**** DONE 7.6.2.1 Transformative Thinking with ~imap~ - 189
CLOSED: [2019-10-09 Wed 18:20]
- Exercise:
  Implement ~Codec[A]~
  #+begin_src scala
    trait Codec[A] { self =>
      def encode(value: A): String
      def decode(value: String): A

      def imap[B](dec: A => B, enc: B => A): Codec[B] =
        new Codec[B] {
          override def encode(value: B): String =
            self.encode(enc(value))

          override def decode(value: String): B =
            dec(self.decode(value))
        }
    }
  #+end_src

- Exercise:
  Implement ~Codec[Double]~
  #+begin_src scala
    implicit val doubleCodec =
      stringCodec.imap(_.toDouble, _.toString)
  #+end_src

- Exercise:
  ~case class Box[A](value: A)~
  Implement ~Codec[Box]~
  #+begin_src scala
    implicit def boxCodec[A](implicit aCodec: Codec[A]): Codec[Box[A]] =
      c.imap[Box[A]](Box.apply, _.value)
  #+end_src

- Usage:
  #+begin_src scala
    encode(123.4)
    // res0: String = 123.4

    decode[Double]("123.4")
    // res1: Double = 123.4

    encode(Box(123.4))
    // res2: String = 123.4

    decode[Box[Double]]("123.4")
    // res3: Box[Double] = Box(123.4)
  #+end_src

- *What's With the Names?*
  =TODO=
  =RE-DO=

** DONE 8.7 Contravariant and Invariant in Cats - 198 - =TODO=
CLOSED: [2019-03-31 Sun 02:12]
Cats provide /contravariant and invariant functors/ through /type classes/
~cats.Contravariant~ and ~cats.Invariant~. Here is a SIMPLIFIED version:
#+begin_src scala
  trait Contravariant[F[_]] {
    def contramap[A, B](fa: F[A])(f: B => A): F[B]
  }

  trait Invariant[F[_]] {
    def imap[A, B](fa: F[A])(f: A => B)(g: B => A): F[B]
  }
#+end_src

*** TODO 8.7.1 Contravariant in Cats - 198
#+begin_src scala
  // TODO: Example code
#+end_src

*** TODO 8.7.2 Invariant in Cats - 199
#+begin_src scala
  // TODO: Example code
#+end_src

** TODO 8.8 Aside: Partial Unification - 200
- =from Jian= A clear explanation from _djspiewak_ (GitHub name):
  https://gist.github.com/djspiewak/7a81a395c461fd3a09a6941d4cd040f2
  This article doesn't mention the walkaround for right-biased
  partial-unification, which is given in this section. See blow.

- SI-2712, which is identified as a bug, is a type inference limitation. It is
  already fixed.
  * Before Scala 2.13,
    Use the compiler option =-Ypartial-unification=;

  * From Scala 2.13 on, _partial-unification_ is there by default, and no option
    for it.

- Example:
  * With =-Ypartial-unification= set in =build.sbt=
    #+begin_src scala
      import cats.Functor
      import cats.instances.function._ // for Functor
      import cats.syntax.functor._     // for map

      val func1 = (x: Int) => x.toDouble
      val func2 = (y: Double) => y * 2

      val func3 = func1.map(func2)
      // func3: Int => Double = scala.runtime.AbstractFunction1$$Lambda$7404/290370740@246b5bc6
    #+end_src

  * Without =-Ypartial-unification=, you can see
    #+begin_src scala
      val func3 = func1.map(func2)
      // <console>: error: value map is not a member of Int => Double
      //        val func3 = func1.map(func2)
      //                          ^
    #+end_src
*** TODO 8.8.1 Limitations of Partial Unification - 202

** DONE 8.9 Summary - 204
CLOSED: [2019-10-10 Thu 14:16]
Functors represent sequencing behaviours.

- We covered three types of functor in this chapter:
  * /Covariant Functors/,
    represent the ability to _apply functions to a value in some context_
    with their ~map~ /method/,

    Successive calls to ~map~ apply these functions _in sequence_, each
    accepting the result of its PREdecessor as a parameter.

  * /Contravariant functors/,
    with their ~contramap~ /method/,
    represent the ability to *"prepend"* functions to a function-like context.

    Successive calls to ~contramap~ sequence these functions _in the opposite
    order to_ ~map~.

  * /Invariant functors/,
    represent _bidirectional transformations_. It has the ~imap~ method.

- /Functors/ for collections are extremely important, as they transform each
  element independently of the rest. This allows us to parallelise or
  distribute transformations on large collections, a technique leveraged
  heavily in "mapreduce" frameworks like Hadoop.
  =TODO=
  We will investigate this approach in more detail in the Map-reduce case
  study later in the book.

- The ~Contravariant~ and ~Invariant~ /type classes/ are less widely applicable
  but are still useful for building data types that _represent *transformations*._
  =TODO=
  We will revisit them to discuss the ~Semigroupal~ /type class/ later in Chapter 6.

* TODO 9 Monads - 207 - =RE-Reading=
- Informally,
  a /monad/ is anything with a /computational context/ and a ~flatMap~
  /method/ that obey the /monad laws/.

- However, despite the ubiquity of the concept,
  *the Scala standard library lacks a concrete type to encompass "things that
  can be flatMapped".*

  _Special syntax_ to SUPPORT /monads/: /for comprehensions/.

  =from Jian=
  Programming languages like Scala and Rust don't want to scare their users
  with Monad concept support in their standard library.
    However, because of the good type system and their design, /monad/ is
  inevitable -- actually we should give a hug to it. I believe They will
  definitely support /monad/ in their standard libary in the future.
  =END Comment=

  *This type class is one of the benefits brought to us by Cats.*

** DONE 9.1 What is a Monad? - 207
CLOSED: [2018-10-28 Sun 01:00]
- *A /monad/ is a mechanism for _SEQUENCING computations_.*

*** DONE 9.1.1 ~Option~'s as Monads - 208
CLOSED: [2019-03-31 Sun 04:01]
#+begin_src scala
  import scala.util.Try

  def parseInt(str: String): Option[Int] =
    Try(str.toInt).toOption

  def divide(a: Int, b: Int): Option[Int] =
    if (b == 0) None else Some(a / b)

  def strignDivideBy(aStr: String, bStr: String): Option[Int] =
    parseInt(aStr).flatMap { aNum =>
      parseInt(bStr).flatMap { bNum =>
        divide(aNum, bNum)
      }
    }

  def strignDivideBy(aStr: String, bStr: String): Option[Int] =
    for {
      aNum <- parseInt(aStr)
      bNum <- parseInt(bStr)
      ans <- divide(aNum, bNum)
    } yield ans
#+end_src

*** DONE 9.1.2 ~List~'s as Monads - 210
CLOSED: [2019-03-31 Sun 03:55]
The for-comprehension form with ~List~'s looks very like imperative for loops.
#+begin_src scala
  for {
    x <- List(1, 2, 3)
    y <- List(4, 5)
  } yield (x, y)
#+end_src

_HOWEVER_, there is _ANOTHER_ *mental model* we can apply that highlights the
 /monadic behaviour/ of ~List~:
 if we think of ~List~'s as sets of /intermediate results/, ~flatMap~ becomes
 a construct that calculates _permutations and combinations_.

*** DONE 9.1.3 ~Future~'s as Monads - 211
CLOSED: [2019-03-31 Sun 03:51]
This section we give example with for-comprehension, and ~Future~'s *are
sequenced*.
  We *can* run /futures/ in _parallel_, but this is another story and shall
be told another time. =TODO= =TODO= =TODO=

*Monads are all about sequencing.*

*** DONE 9.1.4 Definition of a Monad - 212
CLOSED: [2018-10-28 Sun 00:04]
#+BEGIN_SRC scala
  import scala.language.higherKinds

  trait Monad[F[_]] {
    def pure[A](value: A): F[A]

    def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]
  }
#+END_SRC

- *Monad Laws*
  ~pure~ and ~flatMap~ must obey a set of /laws/ that allow us to sequence
  operations freely *WITHOUT* unintended glitches and side-effects:

  * Left identity:
    calling ~pure~ and transforming the result with ~func~ is the same as
    calling ~func~:
    ~pure(a).flatMap(func)~ \equiv{} ~func(a)~

  * Right identity:
    passing ~pure~ to ~flatMap~ is the same as doing nothing:
    ~m.flatMap(pure)~ \equiv{} ~m~

  * Associativity:
    flatMapping over two functions ~f~ and ~g~ is the same as flatMapping
    over ~f~ and then flatMapping over ~g~:
    ~m.flatMap(f).flatMap(g)~ \equiv{} ~m.flatMap(x => f(x).flatMap(g))~

*** DONE 9.1.5 Exercise: Getting Func-y - 213
CLOSED: [2018-10-28 Sun 00:04]
#+BEGIN_SRC scala
  import scala.language.higherKinds

  trait Monad[F[_]] {
    def pure[A](a: A): F[A]

    def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]

    def map[A, B](value: F[A])(func: A => B): F[B] =
      flatMap(value)(a => pure(func(a)))
      // from Jian:
      // can I write: flatMap(value)(func andThen pure)
  }
#+END_SRC

** DONE 9.2 ~Monad~'s in Cats - 214
CLOSED: [2018-10-28 Sun 01:00]
Still
- type class
- instances
- syntax

*** DONE 9.2.1 The ~Monad~ Type Class - 214
CLOSED: [2019-04-01 Mon 13:32]
- ~Monad~ extends _TWO_ other /type classes/:
  * ~FlatMap~, which provides ~flatMap~;
  * ~Applicative~, which provides ~pure~.

*** DONE 9.2.2 Default Instances - 215
CLOSED: [2019-04-01 Mon 13:32]
Still inside ~cats.instances~

- There is a ~Monad~ for ~Future~.
  However, the ~ExecutionContext~ should be provided when summon it.
  #+begin_src scala
    import scala.concurrent.ExecutionContext.Implicits.global

    val fm = Monad[Future]
  #+end_src

*** DONE 9.2.3 ~Monad~ Syntax - 216
CLOSED: [2019-04-01 Mon 13:44]
- The syntax for /monads/ comes from _THREE_ places:
  * ~cats.syntax.flatMap~ provides syntax for ~flatMap~;
  * ~cats.syntax.functor~ provides syntax for ~map~;
  * ~cats.syntax.applicative~ provides syntax for ~pure~.

  In practice it's often easier to import everything in one go from
  ~cats.implicits~. For clarity here, we do individual imports.

- We can use ~pure~ to construct /instances/ of a /monad/.
  Disambiguate with the /type parameter/.
  #+begin_src scala
    import cats.instances.option._       // for Monad
    import cats.instances.list._         // for Monad
    import cats.instances.applicative._  // for pure

    l.pure[Option]
    // res4: Option[Int] = Some(1)

    l.pure[List]
    // res5: List[Int] = List(1)
  #+end_src

- Usage:
  #+begin_src scala
    import cats.Monad
    import cats.syntax.functor._ // for map
    import cats.syntax.flatMap._ // for flatMap
    import scala.language.higherKinds

    def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] =
      a.flatMap(x => b.map(y => x*x + y*y))

    import cats.instances.option._ // for Monad
    import cats.instances.list._ // for Monad

    sumSquare(Option(3), Option(4))
    // res8: Option[Int] = Some(25)

    sumSquare(List(1, 2, 3), List(4, 5))
    // res9: List[Int] = List(17, 26, 20, 29, 25, 34)
  #+end_src

  * The /comprehension/ version:
    #+begin_src scala
      def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] =
        for {
          x <- a
          y <- b
        } yield x*x + y*y

      sumSquare(Option(3), Option(4))
      // res10: Option[Int] = Some(25)

      sumSquare(List(1, 2, 3), List(4, 5))
      // res11: List[Int] = List(17, 26, 20, 29, 25, 34)
    #+end_src

** DONE 9.3 The ~Identity~ Monad - 218
CLOSED: [2019-04-01 Mon 14:33]
- TODO NOTE
- TODO NOTE
- TODO NOTE

*** 9.3.1 Exercise: Monadic Secret Identies - 220
#+begin_src scala
  trait Id[A] extends Functor[A] with Applicative[A] with Monoad[A] {
    def pure[A]: Id[A] =
      this.value

    def map[B](f: A => B): Id[B] =
      f(this.value)

    def flaMap[B](f: A => Id[B]): Id[B] =
      f(this.value)
  }
#+end_src
- The Scala compiler is able to interpret values of type ~A~ as ~Id[A]~ and
  vice versa by the context in which they are used.

- =IMPORATNAT=
  *The only restriction* we've seen to this:
  Scala *CANNOT* _unify types and type constructors_
  _when searching for /implicits/._
    Hence our need to re-type ~Int~ as ~Id[Int]~ in the call to ~sumSquare~
  at the opening of this section: ~sumSquare(3 : Id[Int], 4 : Id[Int])~

** DONE 9.4 ~Either~ - 220
CLOSED: [2019-04-13 Sat 20:05]
- In Scala 2.11 and earlier,
  many people didn't consider ~Either~ a /monad/ because it didn't have ~map~
  and ~flatMap~ /methods/.

- Since Scala 2.12,
  ~Either~ becase right biased with added ~map~ and ~flatMap~.

*** DONE 9.4.1 ~Left~ and ~Right~ Bias - 221
CLOSED: [2019-04-10 Wed 14:11]
- Scala 2.11,
  It is inconvenient to use ~Either~ in for-comprehensions.
  #+begin_src scala
    val either1: Either[String, Int] = Right(10)
    val either2: Either[String, Int] = Right(32)

    for {
      a <- either1.right
      b <- either2.right
    } yield a + b
    // res0: scala.util.Either[String,Int] = Right(42)
  #+end_src

- Scala 2.12, there is a redesigned ~Either~,
  #+begin_src scala
    for {
      a <- either1
      b <- either2
    } yield a + b
    // res1: scala.util.Either[String,Int] = Right(42)
  #+end_src

- Cats *back-ports* this behaviour to Scala 2.11 via the ~cats.syntax.either~
  import, allowing us to use right-biased ~Either~ in all supported versions
  of Scala.
  #+begin_src scala
    import cats.syntax.either._  // (no need for Scala 2.12+) for map and flatMap

    for {
      a <- either1
      b <- either2
    } yield a + b
  #+end_src

*** DONE 9.4.2 Creating Instances - 222
CLOSED: [2019-04-10 Wed 18:16]
- Syntax from ~cats.syntax.either~
  #+begin_src scala
    import cats.syntax.either._  // for asRight

    val a = 3.asRight[String]
    // a: Either[String,Int] = Right(3)

    val b = 4.asRight[String]
    // b: Either[String,Int] = Right(4)

    for {
      x <- a
      y <- b
    } yield x*x + y*y
    // res4: scala.util.Either[String,Int] = Right(25)
  #+end_src

- The syntax above has advantages over ~Left.apply~ and ~Right.apply~:
  *avoid over-narrowing types*.
  * Over-narrowing:
    #+begin_src scala
      def countPositive(nums: List[Int]) =
        nums.foldLeft(Right(0)) { (accumulator, num) =>
          if(num > 0) {
            accumulator.map(_ + 1)
          } else {
            Left("Negative. Stopping!")
          }
        }
      // <console>:21: error: type mismatch;
      // found   : scala.util.Either[Nothing,Int]
      // required: scala.util.Right[Nothing,Int]
      //             accumulator.map(_ + 1)
      //                            ^
      // <console>:23: error: type mismatch;
      // found   : scala.util.Left[String,Nothing]
      // required: scala.util.Right[Nothing,Int]
      //             Left("Negative. Stopping!")
      //                 ^
    #+end_src
    This code fails to compile for _TWO_ reasons:
    1. the compiler *infers* the type of the accumulator as ~Right~ instead
       of ~Either~;

    2. we didn't specify type parameters for ~Right.apply~ (=from Jian= two:
       one for result, one for error) so the compiler infers the left
       parameter as ~Nothing~.

  * NO over-narrowing:
    #+begin_src scala
      def countPositive(nums: List[Int]) =
        nums.foldLeft(0.asRight[String]) { (accumulator, num) =>
          if(num > 0) {
            accumulator.map(_ + 1)
          } else {
            Left("Negative. Stopping!")
          }
        }

      countPositive(List(1, 2, 3))
      // res5: Either[String,Int] = Right(3)

      countPositive(List(1, -2, 3))
      // res6: Either[String,Int] = Left(Negative. Stopping!)
    #+end_src

- ~cats.syntax.either~ adds some extension methods to the ~Either~ /companion
  object/. The ~catchOnly~ and ~catchNonFatal~ /methods/ are great for
  capturing ~Exception~'s as instances of ~Either~:
  #+begin_src scala
    Either.catchOnly[NumberFormatException]("foo".toInt)
    // res7: Either[NumberFormatexception, Int] = Left(java.lang.NumberFormatException: For input string: "too")

    Either.catchNonFatal(sys.error("Badness"))
    // res8: Either[Throwable, Nothing] = Left(java.lang.RuntimeException: Badness)
  #+end_src

- Create an ~Either~ from other data types:
  #+begin_src scala
    Either.fromTry(scala.util.Try("foo".toInt))
    // res9: Either[Throwable,Int] = Left(java.lang.NumberFormatException: For input string: "foo")

    Either.fromOption[String, Int](None, "Badness")
    // res10: Either[String,Int] = Left(Badness)
  #+end_src

*** DONE 9.4.3 Transforming ~Either~'s - 224
CLOSED: [2019-04-13 Sat 17:48]
- ~cats.syntax.either~ also _adds_ some useful /methods/ for /instances/ of
  ~Either~.

- Use ~orElse~ and ~getOrElse~ to extract values _from the *right* side_.
  #+begin_src scala
    import cats.syntax.either._

    "Error".asLeft[Int].getOrElse(0)
    // res11: Int = 0

    "Error".asLeft[Int] orElse 2.asRight[String]
    // res11: Int = Right(2)

  #+end_src

- ~ensure~ allows us to check whether the right-hand value satisfies a /predicate/:
  #+begin_src scala
    -1.asRight[String].ensure("Must be non-negative!")(_ > 0)
    // res13: Either[String,Int] = Left(Must be non-negative!)
  #+end_src

- ~recover~ and ~recoverWith~ provide similar error handling to their namesakes
  on ~Future~:
  #+begin_src scala
    "error".asLeft[Int].recover {
      case str: String => -1
    }
    // res14: Either[String,Int] = Right(-1)

    "error".asLeft[Int].recover {
      case str: String => Right(-1)
    }
    // res15: Either[String,Int] = Right(-1)
  #+end_src

- ~leftMap~ and ~bimap~:
  #+begin_src scala
    "foo".asLeft[Int].leftMap(_.reverse)
    // res16: Either[String,Int] = Left(oof)

    6.asRight[String].bimap(_.reverse, _ * 7)
    // res17: Either[String,Int] = Right(42)

    "bar".asLeft[Int].leftMap(_.reverse, _ * 7)
    // res18: Either[String,Int] = Left(rab)
  #+end_src

- ~swap~ exchanges left for right:
  #+begin_src scala
    123.asRight[String]
    // res19: Either[String,Int] = Right(123)

    123.asRight[String].swap
    // res20: Either[String,Int] = Left(123)
  #+end_src

- ~toOption~, ~toList~, ~toTry~, ~toValidated~, and so on.

*** DONE 9.4.4 Error Handling - 225
CLOSED: [2019-04-13 Sat 18:10]
~Either~ is typically used to implement fail-fast error handling.

- We *sequence* computations using ~flatMap~ as usual.
  #+begin_src scala
    for {
      a <- 1.asRight[String]
      b <- 0.asRight[String]
      c <- if (b == 0) "DIV0".asLeft[Int]
      else        (a / b).asRight[String]
    } yield c * 100
    // res21: Either[String, Int] = Left(DIV0)
  #+end_src

- When using ~Either~ for error handling,
  we need to _determine what type we want to useto represent errors._
  1. We could use ~Throwable~ for this:
     ~type Result[A] = Either[Throwable, A]~
     This has similar semantics to ~scala.util.Try~.

  2. Mostly, we don't want such ~Throwable~, which is a extremely broad type.
     We can define an /algebraic data type/ to represent errors, for
     exmaple, that may occur in our program:
     #+begin_src scala
       sealed trait LoginError extends Product with Serializable

       final case class UserNotFound(username: String) extends LoginError
       final case class PasswordIncorrect(username: String) extends LoginError
       case object UnexpectedError extends LoginError

       type LoginResult = Either[LoginError, User]


       // Choose error-handling behaviour based on type:
       def handleError(error: LoginError): Unit =
         error match {
           case UserNotFound(u) =>
             println(s"User not found: $u")

           case PasswordIncorrect(u) =>
             println(s"Password incorrect: $u")

           case UnexpectedError =>
             println(s"Unexpected error")
         }

       val result1: LoginResult = User("dave", "passw0rd").asRight
       // result1: LoginResult = Right(User(dave,passw0rd))

       val result2: LoginResult = UserNotFound("dave").asLeft
       // result2: LoginResult = Left(UserNotFound(dave))

       result1.fold(handleError, println)
       // User(dave,passw0rd)

       result2.fold(handleError, println)
       // User not found: dave
     #+end_src

*** DONE 9.4.5 Exercise: What is Best? - 227
CLOSED: [2019-04-13 Sat 20:05]
=RE-DO=

** DONE 9.5 Aside: Error Handling and ~MonadError~ - 227
CLOSED: [2019-04-10 Wed 14:02]
Cats provides an additional /type class/ called ~MonadError~ that abstracts
over ~Either~-like data types that are used for *error handling*.

- ~MonadError~ provides extra operations for
  * raising errors
  * handling errors

- *This Section is Optional!*
  You won't need to use ~MonadError~ unless you need to *abstract over error
  handling monads* (If you don't need this kind of abstraction right now, feel
  free to skip onwards to Section 4.6).

  * For example, you can use ~MonadError~ to abstract TODO
    + over ~Future~ and ~Try~,
      OR
    + over ~Either~ and ~EitherT~ (which we will meet in Chapter 5).

*** DONE 9.5.1 The ~MonadError~ Type Class - 228
CLOSED: [2019-04-10 Wed 13:35]
- The simplified definition of ~MonadError~:
  #+begin_src scala
    package cats

    trait MonadError[F[_], E] extends Monad[F] {
      // Lift an error in to the `F` context:
      def raiseError[A](e: E): F[A]

      // Handle an error, potentially recovering from it:
      def handleError[A](fa: F[A])(f: E => A): F[A]

      // Test an instance of `F`,
      // failing if the predicate is not satisfied:
      def ensure[A](fa: F[A])(e: E)(f: A => Boolean): F[A]
    }
  #+end_src

- ~MonadError~ is defined in terms of two type parameters:
  * ~F~
    the type of the /monad/;

  * ~E~
    the type of error contained within ~F~.

- To demonstrate how these parameters fit together, here's an example where
  we instantiate the type class for ~Either~:
  #+begin_src scala
    import cats.MonadError
    import cats.instances.either._  // for MonadError

    type ErrorOr[A] = Either[String, A]
    val monadError = MonadError[ErrorOr, String]
  #+end_src

- ~ApplicativeError~
  _In reality_,
  ~MonadError~ extends another /type class/ called ~ApplicativeError~.
  However, we won't encounter ~Applicative~'s until Chapter 6.
  _The /semantics/ are the SAME_ for each /type class/ so we can _ignore
  this detail for now_.

*** DONE 9.5.2 Raising and Handling Errors - 229
CLOSED: [2019-04-10 Wed 13:52]
- The _two_ most important /methods/ of ~MonadError~:
  * ~raiseError~
  * ~handleError~.

- ~raiseError~ is like the ~pure~ /method/ for ~Monad~
  except that it creates an instance representing a _failure_:
  #+begin_src scala
    val success = monadError.pure(42)
    // success: ErrorOr[Int] = Right(42)

    val failure = monadError.raiseError("Badness")
    // failure: ErrorOr[Nothing] = Left(Badness)
  #+end_src

- ~handleError~ is the complement of ~raiseError~.
  It is similar to the ~recover~ /method/ of ~Future~:
  #+begin_src scala
    monadError.handleError(failure) {
      case "Badness" => monadError.pure("It's ok")
      case other     => monadError.raiseError("It's not ok")
    }
    // res2: ErrorOr[ErrorOr[String]] = Right(Right(It's ok))
  #+end_src

- ~ensure~ implements a filter-like behaviour:
  #+begin_src scala
    import cats.syntax.either._  // for asRight

    monadError.ensure(success)("Number too low!")(_ > 1000)
    // res3: ErrorOr[Int] = Left(Number too low!)
  #+end_src

- Syntax:
  ~raiseError~ and ~handleError~ from ~cats.syntax.applicativeError~
  ~ensure~ from ~cats.syntax.monadError~
  #+begin_src scala
    import cats.syntax.applicative._       // for pure
    import cats.syntax.applicativeError._  // for raiseError etc
    import cats.syntax.monadError._        // for pure

    val success = 42.pure[ErrorOr]
    // success: ErrorOr[Int] = Right(42)

    val failure = "Badness".raiseError[ErrorOr, Int]
    // failure: ErrorOr[Int] = Left(Badness)

    success.ensure("Number to low!")(_ > 1000)
    // res4: Either[String,Int] = Left(Number to low!)
  #+end_src

- There are other useful variants of these /methods/. TODO TODO TODO
  See the source of ~cats.MonadError~ and ~cats.ApplicativeError~ for more
  info.

*** DONE 9.5.3 Instances of ~MonadError~ - 231
CLOSED: [2019-04-10 Wed 14:02]
Cats provides instances of ~MonadError~ for numerous data types including
~Either~, ~Future~, and ~Try~.

- The instance for ~Either~ is customisable to any error type,
  whereas the instances for ~Future~ and ~Try~ always represent errors as
  ~Throwables~:
  #+begin_src scala
    import scala.util.Try
    import cats.instances.try_._  // for MonadError


    val exn: Throwable =
      new RuntimeException("It's all gone wrong")

    exn.raiseError[Try, Int]
    // res6: scala.util.Try[Int] = Failure(java.lang.RuntimeException: It's all gone wrong)
  #+end_src

*** TODO 9.5.4 Exercise: Abstracting - 231 - =OPEN ISSUE=
No exercise here -- there is an open issue for this in github

** DONE 9.6 The ~Eval~ Monad - 232
CLOSED: [2019-04-02 Tue 17:57]
~cats.Eval~ is a /monad/ that allows us to _abstract over different models of
evaluation._

- We typically hear of _TWO_ such models: /eager/ and /lazy/.
    ~Eval~ throws in a _further distinction_ of whether or not a result is
  /memoized/.

*** DONE 9.6.1 Eager, Lazy, Memoized, Oh My! - 232
CLOSED: [2019-04-02 Tue 15:33]
- /Eager computations/ HAPPEN _immediately_
  whereas
  /Lazy computations/ HAPPEN _on access_.

  /Memoized computations/ are run *ONCE* _on first access_,
  after which the results are *cached*.

- For example,
  in Scala (the _evaluation properties_ of the three ways below can be shown
  through a _visible side-effect_),
  * ~val~'s are /eager/ and /memoized/.
    #+begin_src scala
      val x = {
        println("Computing X")
        math.random
      }
      // Computing X
      // x: Double = 0.0657586956104027

      x  // first access
      // res0: Double = 0.0657586956104027

      x  // second access
      // res1: Double = 0.0657586956104027
    #+end_src

  * ~def~'s are /lazy/ and *NOT* /memoized/.
    #+begin_src scala
      def y = {
        println("Computing X")
        math.random
      }
      // y: Double

      y  // first access
      // Computing Y
      // res2: Double = 0.9184384488125138

      y  // second access
      // Computing Y
      // res3: Double = 0.20807113447602488
    #+end_src

  * ~lazy val~'s are /lazy/ and /memoized/.
    #+begin_src scala
      lazy val z = {
        println("Computing Z")
        math.random
      }
      // z: Double = <lazy>

      z  // first access
      // Computing Z
      // res4: Double = 0.1783014120350146

      z  // second access
      // res5: Double = 0.1783014120350146
    #+end_src

*** DONE 9.6.2 Eval's Models of Evaluation - 234
CLOSED: [2019-04-02 Tue 16:19]
- ~Eval~ has THREE /subtypes/: ~Now~, ~Later~, and ~Always~.

- We construct these with _THREE /constructor methods/,_ which create
  instances of the THREE /classes/ and *return them typed as ~Eval~:*
  #+begin_src scala
    import cats.Eval

    val now = Eval.now(math.random + 1000)
    // now: cats.Eval[Double] = Now(1000.885603643474)

    val later = Eval.later(math.random + 2000)
    // later: cats.Eval[Double] = cats.Later@679671c

    val always = Eval.always(math.random + 3000)
    // always: cats.Eval[Double] = cats.Always@396fe27e
  #+end_src

  =From Jian= =START=
  It's critical that we should use these /constructor methods/, rather then
  the /constructors/ of EACH /subtypes/.

  *The return type is important!!!*

  The compiler needs ~Eval~, rather than its /subtypes/, too narrow types
  can make the compiler be confused. TODO =MORE DETAILS= =???=
  =From Jian= =END=

- Extract the result of an ~Eval~ using its ~value~ /method/:
  #+begin_src scala
    now.value
    // res6: Double = 1000.885603643474

    later.value
    // res7: Double = 2000.1770874422618

    always.value
    // res8: Double = 3000.637554292833
  #+end_src

- ~Eval.now~ captures a value _right now_.
  Its semantics are similar to a ~val~ -- /eager/ and /memoized/.

- ~Eval.always~ captures a /lazy/ computation, similar to a ~def~ -- /lazy/
  and *NOT* /memoized/.

- ~Eval.later~ captures a /lazy/, /memoized/ computation, similar to a
  ~lazy val~ -- /lazy/ and /memoized/.

- The three behaviours are summarized below:
  | Scala      | Cats     | Properties         |
  |------------+----------+--------------------|
  | ~val~      | ~Now~    | eager, memoized    |
  | ~lazy val~ | ~Later~  | lazy, memoized     |
  | ~def~      | ~Always~ | lazy, not memoized |

- =From Jian=
  We *DO NOT* have /eager/ and *NOT* /memoized/ evaluation model, which is
  not reasonable -- just like copy and paste a segment of code everywhere,
  Everytime see them evaluate them. Even though they are the same code
  segment, sometimes even same calculation (when no side effect), but no
  connections built between them.

*** DONE 9.6.3 ~Eval~ as a ~Monad~ - 236
CLOSED: [2019-04-02 Tue 17:20]
- Like all monads, Eval's ~map~ and ~flatMap~ /methods/ add computations to a
  _chain_.

- In the case of ~Eval~, the _chain_ is stored explicitly as _a list of functions_.
  The functions are NOT run until we call ~Eval~'s ~value~ /method/ to request
  a result:
  #+begin_src scala
    val greeting = Eval.
      always { println("Step 1"); "Hello" }.
      map { str => println("Step 2"); s"$str world" }
    // greeting: cats.Eval[String] = cats.Eval$$anon$8@157f7b8c

    greeting.value
    // Step 1
    // Step 2
    // res15: String = Hello world
  #+end_src

- =IMPORTANT=
  While the /semantics/ of the originating ~Eval~ /instances/ are maintained,
  _mapping functions are *always called lazily* on demand (~def~ /semantics/)._
  #+begin_src scala
    val ans = for {
      a <- Eval.now { println("Calculating A"); 40 }
      b <- Eval.always { println("Calculating B"); 2 }
    } yield {
      println("Adding A and B")
      a + b
    }
    // Calculating A
    // ans: cats.Eval[Int] = cats.Eval$$anon$8@37c1363d

    ans.value  // first access
    // Calculating B
    // Adding A and B
    // res16: Int = 42

    ans.value  // second access
    // Calculating B
    // Adding A and B
    // res17: Int = 42
  #+end_src

- Some times we don't want the ~def~ /semantics/, and ~Eval~ has a ~memoize~
  /method/ that allows us to _memoize a chain of computations_
  * the result of the chain up to the call to ~memoize~ is _CACHED_,
    whereas
  * calculations after the call _RETAIN their ORIGINAL_ /semantics/:
  #+begin_src scala
    val saying = Eval.
      always { println("Step 1"); "The cat" }.
      map { str => println("Step 2"); s"$str sat on" }.
      memoize.
      map { str => println("Step 3"); s"$str the mat" }
    // saying: cats.Eval[String] = cats.Eval$$anon$8@2196a9a1

    saying.value  // first access
    // Step 1
    // Step 2
    // Step 3
    // res18: String = The cat sat on the mat

    saying.value  // second access
    // Step 3
    // res19: String = The cat sat on the mat
  #+end_src

*** DONE 9.6.4 Trampolining and ~Eval.defer~ - 238
CLOSED: [2019-04-02 Tue 17:56]
=from Jian= Try to learn more about /trampolining/.
~Eval~'s ~map~ and ~flatMap~ /methods/ are /trampolined/, which means we can
nest calls to ~map~ and ~flatMap~ *ARBITRARILY without consuming stack
frames.*

_We call this property /stack safety/._

- For example,
  #+begin_src scala
    def factorial(n: BigInt): BigInt =
      if (n == 1) n else n * factorial(n - 1)
  #+end_src
  will stack overflow when the input is large, for instance 50000.

  1. First try:
     #+begin_src scala
       def factorial(n: BigInt): Eval[BigInt] =
         if(n == 1) {
           Eval.now(n)
         } else {
           factorial(n - 1).map(_ * n)
         }
     #+end_src

     This still doesn't work, and we will see
     #+begin_src scala
       factorial(50000).value
       // java.lang.StackOverflowError
       // ...
     #+end_src

     The problem here is we didn't avoid the ~factorial~ call stack overflow
     -- only ~Eval.now(n)~ in the base case and make the return value of type
     ~Eval[BigInt]~ is NOT enough.

  2. Resolve the problem of the first try:
     #+begin_src scala
       def factorial(n: BigInt): Eval[BigInt] =
         if(n == 1) {
           Eval.now(n)
         } else {
           Eval.defer(factorial(n - 1).map(_ * n))
         }
     #+end_src
     This will work perfectly.

- Everything has a cost!!!
  /Trampolining/ help us avoiding consuming /stack/ by creating a chain of
  function /objects/ on the /heap/ -- like some recursion to iterative
  method (iterative traverse of a tree).

- There are still limits on how deeply we can nest computations,
  BUT they are *bounded by the size of the /heap/ rather than the /stack/.*

*** TODO 9.6.5 Exercise: Safer Folding using ~Eval~ - 239
=from Jian= I made a mistake at my first try. Try to do it again later.

** DONE 9.7 The ~Writer~ Monad - 240
CLOSED: [2019-04-14 Sun 02:04]
~cats.data.Writer~ is a /monad/ that lets us carry a log along with a
computation.

- We can use it to
  1. record messages, errors, or additional data about a computation
     AND
  2. extract the log alongside the final result.

- One common use for ~Writer~'s is _recording sequences of steps in multi-threaded
  computations_ where

  * standard imperative logging techniques can result in *interleaved messages
    from different contexts*.

  * With ~Writer~ the log for the computation is _tied to the result_, so we can
    run concurrent computations *without mixing logs*.

- *Cats Data Types*
  ~Writer~ is the FIRST /data type/ we've seen from the ~cats.data~ package.

  * This package provides instances of various /type classes/ that *produce
    useful semantics*.

  * Other examples from ~cats.data~ include the /monad transformers/ that we
    will see in the next chapter, and the ~Validated~ type we will encounter
    in Chapter 6. =TODO= =TODO= =TODO=

*** DONE 9.7.1 Creating and Unpacking Writers - 240
CLOSED: [2019-04-13 Sat 23:55]
- A ~Writer[W, A]~ carries two values:
  * a log of type ~W~
  * a result of type ~A~

- We can create a ~Writer~ from values of each type as follows:
  #+begin_src scala
    import cats.data.Writer
    import cats.instances.vector._  // for Monoid

    Writer(Vector("It was the best of times",
                  "it was the wrost of times"),
           1859)
    // res0: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String], Int] =
    //       WriterT((Vector(It was the best of times, it was the wrost of times),1859))
  #+end_src
  Cats implements ~Writer~ in terms of another type, ~WriterT~:
  ~type Writer[W, A] = Writer[Id, W, A]~ (ignore this before Chapter 5).

- When you only have a result (type ~A~), in scope there must be a ~Monoid[W]~
  which help Cats find proper empty log value.
  For instance,
  #+begin_src scala
    import cats.instances.vector._    // for Monoid
    import cats.syntax.applicative._  // for pure

    type Logged[A] = Writer[Vector[String], A]

    123.pure[Logged]
    // res2: Logged[Int] = WriterT((Vector(), 123))
  #+end_src

- Similary, you may have a log and no result.
  You can create a ~Writer[Unit]~ using ~tell~ syntax from
  ~cats.syntax.writer~:
  #+begin_src scala
    import cats.syntax.writer._  // for tell

    Vector("msg1", "msg2", "msg3").tell
    // res3: cats.data.Writer[scala.collection.immutable.Vector[String],Unit] = WriterT((Vector(msg1, msg2, msg3),()))
  #+end_src

- If we have both a log and a result,
  we can either use
  * ~Writer.apply~
    #+begin_src scala
      val a = Writer(Vector("msg1", "msg2", "msg3"), 123)
      // a: cats.data.WriterT[cats.Id.scala.collection.immutable.Vector[String],Int] =
      //    WriterT((Vector(msg1, msg2, msg3),123))
    #+end_src
    OR
  * the ~writer~ sytnax from ~cats.syntax.writer~:
    #+begin_src scala
      import cats.syntax.writer._  // for writer

      val b = 123.writer(Vector("msg1", "msg2", "msg3"))
      // b: cats.data.WriterT[cats.Id.scala.collection.immutable.Vector[String],Int] = WriterT((Vector(msg1, msg2, msg3),123))
    #+end_src

- Extract result or log:
  #+begin_src scala
    val aResult: Int = a.value
    // aResult: Int = 123

    val aLog: Vector[String] = a.written
    // aLog: Vector[String] = Vector(msg1, msg2, msg3)
  #+end_src

- We can extract both values at the same time:
  #+begin_src scala
    val (log, result) = b.run
    // log: scala.collection.immutable.Vector[String] = Vector(msg1, msg2, msg3)
    // result: Int = 123
  #+end_src

*** DONE 9.7.2 Composing and Transforming Writers - 242
CLOSED: [2019-04-14 Sun 01:49]
As a /moand/, ~Writer~ can be preserved when applying ~map~ or ~flatMap~
over it.

- ~flatMap~ *appends* the logs from the source ~Writer~ and the result of the
  user's sequencing function.
    For this reason, efficient *append* and *concatenate* operations are
  important! We usually use ~Vector~:
  #+begin_src scala
    val writer1 = for {
      a <- 10.pure[Logged]
      _ <- Vector("a", "b", "c").tell
      b <- 32.writer(Vector("x", "y", "z"))
    } yield a + b
    // writer1: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(a, b, c, x, y, z),42))

    writer1.run
    // res4: cats.Id[(Vector[String], Int)] = (Vector(a, b, c, x, y, z) ,42)
  #+end_src

- Transform the log in a /writer/:
  #+begin_src scala
    val writer2 = writer1.mapWritten(_.map(_.toUpperCase))
    // writer2: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] = WriterT((Vector(A, B, C, X, Y, Z),42))

    writer2.run
    // res5: cats.Id[(scala.collection.immutable.Vector[String], Int)] = (Vector(A, B, C, X, Y, Z),42)
  #+end_src

- Transform both log and result simultaneously using
  #+begin_src scala
    val writer3 = writer1.bimap(
      log => log.map(_.toUpperCase),
      res => res * 100
    )
    // writer3: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] =
    //   WriterT((Vector(A, B, C, X, Y, Z),4200))

    writer3.run
    // res6: cats.Id[(scala.collection.immutable.Vector[String], Int)] =
    //   (Vector(A, B, C, X, Y, Z),4200)

    val writer4 = writer1.mapBoth { (log, res) =>
      val log2 = log.map(_ + "!")
      val res2 = res * 1000
      (log2, res2)
    }
    // writer4: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] =
    //   WriterT((Vector(a!, b!, c!, x!, y!, z!),4200))

    writer4.run
    // res7: cats.Id[(scala.collection.immutable.Vector[String], Int)] =
    //   (Vector(A, B, C, X, Y, Z),4200)
  #+end_src
  * ~bimap~, which accept two function parameters for log and result respectively.
  * ~mapBoth~, which accept single function parameter that accept two parameters.

- Clear log with ~reset~;
  Swap log and result with ~swap~.
  #+begin_src scala
    val writer5 = writer1.reset
    // writer5: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(),42))

    writer5.run
    // res8: cats.Id[(Vector[String], Int)] = (Vector(),42)

    val writer6 = writer1.swap
    // writer6: cats.data.WriterT[cats.Id,Int,Vector[String]] = WriterT((42,Vector(a, b, c, x, y, z)))

    writer6.run
    // res9: cats.Id[(Int, Vector[String])] = (42,Vector(a, b, c, x, y, z))
  #+end_src

*** DONE 9.7.3 Exercise: Show Your Working - 245
CLOSED: [2019-04-14 Sun 02:04]
=from Jian= Can we make it look better???
#+begin_src scala
  def slowly[A](body: => A) =
    try body finally Thread.sleep(100)

  type IntWriter = Writer[Vector[String], Int]

  def factorial(n: Int): IntWriter =
    for {
      ans <- n match {
        case 0 => 1.pure[IntWriter]
        case _ => slowly(factorial(n - 1).map(_ * n))
      }

      _ <- Vector(s"fact $n $ans").tell
    } yield ans
#+end_src

** DONE 9.8 The ~Reader~ Monad - 246
CLOSED: [2019-04-17 Wed 15:23]
~cats.data.Reader~ is a /monad/ that allows us to *sequence operations that
depend on some input*.

- Instances of ~Reader~
  * *wrap up* functions of _ONE argument_,
  * providing us with useful methods for *composing* them.

- *One common use for ~Reader~'s is /dependency injection/.*
  =IMPORTANT= =IMPORTANT= =IMPORTANT=
  * dependency injection ::
       If we have a number of operations that all _depend on some EXTERNAL
    configuration_, we can
    + _chain_ them together using a ~Reader~ to produce one large operation
      that
      accepts the configuration _as a parameter_
      and
      runs our program _in the order specified_.

*** DONE 9.8.1 Creating and Unpacking Readers - 246
CLOSED: [2019-04-16 Tue 17:12]
1. Create a ~Reader[A, B]~ from a function ~A => B~ using the ~Reader.apply~.
  #+begin_src scala
    import cats.data.Reader

    case class Cat(name: String, favoriteFood: String)

    val catName: Reader[Cat, String] =
      Reader(_.name)
    // catName: cats.data.Reader[Cat,String] = Kleisli(<function1>)
  #+end_src

2. Extract the function again using the ~Reader~'s ~run~ /method/ and call it
   using ~apply~:
   #+begin_src scala
     catName.run(Cat("Garfield", "lasagne"))
     // res0: cats.Id[String] = Garfield
   #+end_src

3. TODO What advantage do ~Reader~'s give us over the raw functions???

*** DONE 9.8.2 Composing Readers - 247
CLOSED: [2019-04-16 Tue 17:12]
The power of ~Reader~'s comes from their ~map~ and ~flatMap~ /methods/, which
represent _DIFFERENT kinds of *function composition*._
  We typically create a set of ~Reader~'s that accept the *SAME type* of
configuration, combine them with ~map~ and ~flatMap~, and then call ~run~ to
/inject/ the config at the end.

- ~map~ extends the computation in the ~Reader~ by passing its result through
  a function:
  #+begin_src scala
    val greetKitty: Reader[Cat, String] =
      catName.map(name => s"Hello $name")

    greetKitty.run(Cat("Heathcliff", "junk food"))
    // res1: cats.Id[String] = Hello Heathcliff
  #+end_src

- ~flatMap~ combine /readers/ that depend on the _SAME input type_.
  #+begin_src scala
    val feedKitty: Reader[Cat, String] =
      Reader(cat => s"Have a nice bowl of ${cat.favoriteFood}")

    val greetAndFeed: Reader[Cat, String] =
      for {
        greet <- greetKitty
        feed <- feedKitty
      } yield s"$greet. $feed."

    greetAndFeed(Cat("Garfield", "lasagne"))
    // res3: cats.Id[String] = Hello Garfield. Have a nice bowl of lasagne.

    greetAndFeed(Cat("Heathcliff", "junk food"))
    // res4: cats.Id[String] = Hello Heathcliff. Have a nice bowl of junk food.
  #+end_src

*** DONE 9.8.3 Exercise: Hacking on Readers - 248
CLOSED: [2019-04-17 Wed 15:06]
The classic use of ~Reader~'s is to build programs that accept a configuration
as a parameter.

- Example: Simple login system
  * Our configuration will consist of _TWO_ databases:
    a list of valid users and a list of their password:
    #+begin_src scala
      case class Db(
        usernames: Map[Int, String],
        passwords: Map[String, String]
      )
    #+end_src
    + Create ~DbReader~:
      ~type DbReader[A] = Reader[Db, A]~

  * Create /methods/ that generate ~DbReader~'s to look up the username for
    an ~Int~ user ID, and look up the password for a ~String~ username. The
    type signatures should be as follows:
    #+begin_src scala
      def findUsername(userId: Int): DbReader[Option[String]] =
        Reader(_.usernames.get(userId))

      def checkPassword(username: String, password: String): DbReader[Boolean] =
        Reader(_.password.get(username).contains(password))
    #+end_src

  * Create ~checkLogin~ /method/ to check the password for a given user ID.
    =from Jian= This code does not have good look!!!!!
    #+begin_src scala
      def checkLogin(usedId: Int, password: String): DbReader[Boolean] =
        for {
          oUsername <- findUsername(userId)
          oPassword = username.map(un => checkPassword(un, passowrd))
          passwordOk <- oPassword.getOrElse(false.pure[DbReader])
        } yield passwordOk
    #+end_src

*** DONE 9.8.4 When to Use Readers? - 250
CLOSED: [2019-04-17 Wed 15:22]
- ~Reader~'s provide a tool for doing /dependency injection/.
  1. Write steps of our program as /instances/ of ~Reader~
  2. Chain them together with ~map~ and ~flatMap~
  3. Build a function that accepts the /dependency/ as input.

- There are many ways of implementing /dependency injection/ in Scala, from
  _SIMPLE TECHNIQUES like /methods/ with multiple parameter lists_, through
  _/implicit parameters/ and /type classes/,_ to _COMPLEX TECHNIQUES like
  the /cake pattern/ and /DI frameworks/._

- ~Reader~'s are most useful in situations where:
  * we are constructing a batch program that can EASILY be *represented by a
    function*;

  * we need to *defer* /injection/ of a known parameter or set of parameters;

  * we want to be able to *test* parts of the program _in isolation_.

- By representing the steps of our program as ~Reader~'s
  * we can *test* them as easily as pure functions
  * we gain access to the ~map~ and ~flatMap~ /combinators/

- DI and use other ways rather than ~Reader~ =???= =WHY=
  For more advanced problems
  where we have lots of /dependencies/, TODO =EXAMPLE???=
  or
  where a program _isn't easily represented as a pure function_, TODO =EXAMPLE???=
  _other /dependency injection/ techniques tend to be more appropriate_.

- *Kleisli Arraows*
  You may have noticed from console output that ~Reader~ is implemented
  in terms of another type called ~Kleisli~.

  * /Kleisli arrows/ provide a _more general form_ of ~Reader~ that _generalise
    over the type constructor of the result type_.

  * TODO We will encounter ~Kleislis~ again in Chapter 5.

** DONE 9.9 The ~State~ Monad - 251
CLOSED: [2020-02-20 Thu 14:20]
~cats.data.State~ allows us to
pass additional /state/ around as part of a computation.
=from Jian= /state/ as /computation context/.

- We define ~State~ /instances/ representing /atomic state/ operations and
  thread them together using ~map~ and ~flatMap~.
    In this way *we can model /mutable state/ in a purely functional way,
  without using mutation.*

*** DONE 9.9.1 Creating and Unpacking State - 251
CLOSED: [2020-02-20 Thu 11:52]
The instance of /state monad/ ~State[S, A]~ represent functions of type
~S => (S, A)~, where ~S~ is the /type/ of the /state/ and ~A~ is the /type/
of the result.

- Example:
  #+begin_src scala
    import cats.data.State

    val a = State[Int, String] { state =>
      (state, s"The state is $state")
    }
    // a: cats.data.State[Int, String] = cats.data.IndexedStateT@12c18313
  #+end_src

- In other words,
  an instance of ~State~ is a function that does _TWO_ things:
  * *transforms* an _input state_ to an _output state_;
  * *computes* a result.

- ~State~ provides _THREE_ /methods/:
  * ~run~
  * ~runS~
  * ~runA~
  they return different combinations of /state/ and /result/.
  TODO ??? ??? ???
    _Each_ /method/ returns an /instance/ of ~Eval~, which ~State~ uses to
  maintain /stack safety/.

- We call the ~value~ /method/ as usual to extract actual result:
  #+begin_src scala
    // Get the state and the result;
    val (state, result) = a.run(10).value
    // state: Int = 10
    // result: String = The state is 10

    // Get the state, ignore the result;
    val state = a.runS(10).value
    // state: Int = 10

    // Get the result, ignore the state;
    val state = a.runA(10).value
    // result: String = The state is 10
  #+end_src

*** DONE 9.9.2 Composing and Transforming State - 252
CLOSED: [2020-02-20 Thu 12:59]
As we've seen with ~Reader~ and ~Writer~, the power of the ~State~ /monad/
comes from *combining* /instances/.

- The ~map~ and ~flatMap~ /methods/ thread the /state/ from one /instance/ to
  another.

- Each individual /instance/ represents an _atomic_ /state transformation/,
  and their combination represents a complete sequence of changes:
  #+begin_src scala
    val step1 = State[Int, String] { num =>
      val ans = num + 1
      (ans, s"Result of step1: $ans")
    }
    // step1: cats.data.State[Int,String] = cats.data.IndexedStateT@7c6e31c4

    val step2 = State[Int, String] { num =>
      val ans = num * 2
      (ans, s"Result of step2: $ans")
    }
    // step2: cats.data.State[Int,String] = cats.data.IndexedStateT@7428b330

    val both = for {
      a <- step1
      b <- step2
    } yield (a, b)
    // both: cats.data.IndexedStateT[cats.Eval,Int,Int,(String, String)] = cats.data.IndexedStateT@716401f3

    val (state, result) = both.run(20).value
    // state: Int = 42
    // result: (String, String) = (Result of step1: 21,Result of step2: 42)
  #+end_src

- The general model for using the State monad is to represent each step of a
  computation as an instance and compose the steps using the _standard monad
  operators_.
    Cats provides several convenience constructors for creating primitive
  steps:
  * ~get~ extracts the state as the result;
    #+begin_src scala
      val getDemo = State.get[Int]
      // getDemo: cats.data.State[Int, Int] = cats.data.IndexedStateT@4df6ba6a

      getDemo.run(10).value
      // res3: (Int, Int) = (10, 10)
    #+end_src

  * ~set~ updates the state and returns unit as the result;
    #+begin_src scala
      val setDemo = State.get[Int](30)
      // setDemo: cats.data.State[Int, Unit] = cats.data.IndexedStateT@4620d0ef

      setDemo.run(10).value
      // res4: (Int, Unit) = (30, ())
    #+end_src

  * ~pure~ ignores the state and returns a supplied result;
    #+begin_src scala
      val pureDemo = State.pure[Int, String]("Result")
      // pureDemo: cats.data.State[Int,String] = cats.data.IndexedStateT@988d7b2

      pureDemo.run(10).value
      // res5: (Int, String) = (10,Result)
    #+end_src

  * ~inspect~ extracts the state via a transformation function;
    #+begin_src scala
      val inspectDemo = State.pure[Int, String](_ + "!")
      // inspectDemo: cats.data.State[Int,String] = cats.data.IndexedStateT@13734a20

      inspectDemo.run(10).value
      // res6: (Int, String) = (10,10!)
    #+end_src

  * ~modify~ updates the state using an update function.
    #+begin_src scala
      val modifyDemo = State.modify[Int, String](_ + 1)
      // modifyDemo: cats.data.State[Int,Unit] = cats.data.IndexedStateT@79493b6e

      modifyDemo.run(10).value
      // res7: (Int, Unit) = (10,())
    #+end_src

- Use /comprehension/:
  #+begin_src scala
    import State._

    val program: State[Int, (Int, Int, Int)] = for {
      a <- get[Int]
      _ <- set[Int](a + 1)
      b <- get[Int]
      _ <- modify[Int](_ + 1)
      c <- inspect[Int, Int](_ * 1000)
    } yield (a, b, c)
    // program: cats.data.State[Int,(Int, Int, Int)] = cats.data.IndexedStateT@b8a0617

    val (state, result) = program.run(1).value
    // state: Int = 3
    // result: (Int, Int, Int) = (1,2,3000)
  #+end_src

*** DONE 9.9.3 Exercise: Post-Order Calculator - 254 - =TODO= =RE-READ=
CLOSED: [2020-02-20 Thu 14:20]

** DONE 9.10 Defining Custom Monads - 258 - HARD - =RE-READ=
CLOSED: [2023-01-11 Wed 09:44]
*** TODO 9.10.1 Exercise: Branching out Further with Monads - 260
#+begin_src scala
  sealed trait Tree[+A]

  final case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]
  final case class Leaf[A](value: A) extends Tree[A]

  def branch[A](left: Tree[A], right: Tree[A]): Tree[A] =
    Branch(left, right)

  def leaf[A](value: A): Tree[A] =
    Leaf(value)


  import cats.Monad

  val treeMonad = new Monad[Option] {
    def flatMap[A, B](t: Tree[A])
               (fn: A => Tree[B]): Tree[B] =
      t match {
        case Branch(l, r) => Branch(flatMap(l)(fn), flatMap(r)(fn))
        case Leaf(v)      => fn(v)
      }

    def pure[A](v: A): Tree[A] =
      leaf(v)

    def tailRecM[A, B](a: A)(fn: A => Tree[Either[A, B]]): Tree[B] =
      flatMap(fn(a)) {
        case Left(v) => tailRecM(v)(fn)
        case Right(v) => Leaf(v)
      }
  }
#+end_src

** DONE 9.11 Summary - 261
CLOSED: [2020-02-20 Thu 11:45]
In this chapter we've seen monads up-close.
- We saw that ~flatMap~ can be viewed as an operator for sequencing computations,
  dictating the order in which operations must happen. From this viewpoint,
  * ~Option~ represents a computation that can fail without an error message,

  * ~Either~ represents computation that can fail with a message,

  * ~List~ represents multiple POSSIBLE results,

  * ~Future~ represents a computation that may produce a value at some point
    in the future.

- =from Jian=
  CAUTION: Use the data type mentioned above as monad only when the *monad
  laws* are satisfied!!! For instance, ~Future~'s are often used with side
  effects, and are actually _not always_ /monad/.

- Learn some of the custom types and data structures that Cats provides, including
  * ~Id~
  * ~Reader~
  * ~Writer~
  * ~State~

- Finally, in the unlikely event that we have to implement a custom monad,
  we've learned about defining our own instance using ~tailRecM~.
  * ~tailRecM~ is an odd wrinkle that is a concession to building a functional
    programming library that is stack-safe by default.

  * We
    + _don't need_ to understand ~tailRecM~ to understand /monads/,
    + _BUT_ having it around gives us benefits of which we can be grateful when
      writing monadic code.

* DONE 10 Monad Transformers - 263
CLOSED: [2020-02-16 Sun 01:55]
/Monads/ can potentially bloat the code base through nested
for-comprehensions.

- Example:
  #+begin_src scala
    def lookupUserName(id: Long): Either[Error, Option[String]] =
      for (optUser <- lookupUser(id))
      yield {
        for (user <- optUser)
        yield user.name
      }
  #+end_src

** DONE 10.1 Exercise: Composing Monads - 264
CLOSED: [2020-02-15 Sat 20:23]
- Q :: Do /monads/ compose???

- A :: Generally speaking, No! It is easy to show this:
  #+begin_src scala
    import cats.Monad
    import cats.syntax.applicative._  // for `pure`
    import cats.syntax.flatMap._      // for `flatMap`
    import scala.language.higherKinds

    // Hypothetical example. This won't actually compile:
    def compose[M1[_]: Monad, M2[_]: Monad] = {
      type Composed[A] = M1[M2[A]]

      new Monad[Composed] {
        def pure[A](a: A): Composed[A] =
          a.pure[M2].pure[M1]

        def flatMap[A, B](fa: Composed[A])
                         (f: A => Composed[B]): Composed[B] = {
          // Problem! How do we write flatMap?
          ???
        }
      }
    }
  #+end_src
  * Without extra info, there is no way to implement ~flatMap~.

  * *We need some extra info!!!*
    For example, if ~M2~ is ~Option~, we can implement ~flatMap~ as:
    #+begin_src scala
      def flatMap[A, B](fa: Composed[A])
                       (f: A => Composed[B]): Composed[B] =
        fa.flatMap(_.fold(None.pure[M1])(f))
    #+end_src
    This is the idea behind /monad transformers/ -- =from Jian= extra info is
    given for one monad.

- Cats defines transformers for a variety of monads, each providing the extra
  knowledge we need to compose that monad with others.

** DONE 10.2 A Transformative Example - 265
CLOSED: [2020-02-15 Sat 22:28]
- Cats /monad transformer/ naming convetion:
  Inner monad name suffixed with T. For example, ~OptionT~ and ~EitherT~.

- We often alias a composed monad.
  For example, alias ~OptionT[List, A]~ to ~ListOption[A]~.
  Note how we build ~ListOption~ from the inside out.

- Create instance of ~ListOption~:
  #+begin_src scala
    import cats.Monad
    import cats.instances.list._      // for Monad
    import cats.syntax.applicative._  // for pure

    val result1: ListOption[Int] = OptionT(List(Option(10)))
    // result1: ListOption[Int] = OptionT(List(Some(10)))

    val result2: ListOption[Int] = 32.pure[ListOption]
    // result2: ListOption[Int] = OptionT(List(Some(32)))

    result1.flatMap { (x: Int) =>
      result2.map { (y: Int) =>
        x + y
      }
    }

    // OR

    for {
      x <- result1
      y <- result2
    } yield x + y

    // res1: cats.data.OptionT[List, Int] = OptionT(List(Some(42)))
  #+end_src

- *Complexity of Imports*
  The imports in the code samples above hint at how everything bolts
  together.

  1. We import ~cats.syntax.applicative~ to get the ~pure~ syntax.
     ~pure~ requires an implicit parameter of type ~Applicative[ListOption]~.
     _Learn ~Applicative~ in the next chapter. All /monads/ are also
     /applicatives/._

  2. In order to generate our ~Applicative[ListOption]~ we need _instances of
     ~Applicative~ for ~List~ and ~OptionT~._
     * ~OptionT~ is a Cats data type so its instance is provided by its
       /companion object/.

     * The instance for ~List~ comes from ~cats.instances.list~

  3. We're not importing ~cats.syntax.functor~ or ~cats.syntax.flatMap~.
     This is because ~OptionT~ is a _CONCRETE_ data type with its own explicit
     ~map~ and ~flatMap~ /methods/.

  We discuss imports in details is just because we refuse to use the
  universal Cats import, ~cats.implicits~.

** DONE 10.3 Monad Transformers in Cats - 267
CLOSED: [2020-02-16 Sun 01:21]
Each /monad transformer/ is a data type, defined in ~cats.data~, that allows
us to _WRAP stacks of /monads/ TO produce NEW /monads/._

- The main concepts we have to cover to understand /monad transformers/:
  * the available /transformer/ classes;
  * how to BUILD STACKS of /monads/ using /transformers/;
  * how to CONSTRUCT /instances/ of _a /monad/ stack_;
  * how to PULL APART a stack to ACCESS the wrapped /monads/.

*** DONE 10.3.1 The Monad Transformer Classes - 267
CLOSED: [2020-02-15 Sat 23:48]
- In fact, MANY /monads/ in Cats are defined by *combining*
  * a /monad transformer/
    with
  * the ~Id~ /monad/.

- Concretely, some of the available instances are:
  * ~cats.data.OptionT~ for ~Option~;
  * ~cats.data.EitherT~ for ~Either~;
  * ~cats.data.ReaderT~ for ~Reader~;
  * ~cats.data.WriterT~ for ~Writer~;
  * ~cats.data.StateT~ for ~State~;
  * ~cats.data.IdT~ for ~Id~;

- *Kleisli Arrows*
  * In Section 4.8 we mentioned that *the ~Reader~ /monad/ was a specialisation
    of a more general concept called a _"kleisli arrow"_,* represented in Cats as
    ~cats.data.Kleisli~.

  * In fact, ~Kleisli~ and ~ReaderT~ are the same thing!
    ~ReaderT~ is actually a /type alias/ for ~Kleisli~.
      This is why when we were creating ~Reader~'s last chapter and seeing
    ~Kleisli~'s on the console.

*** DONE 10.3.2 Building Monad Stacks - 268
CLOSED: [2020-02-16 Sun 00:35]
- Many /monads/ and all transformers have AT LEAST _two_ /type parameters/,
  so we often have to _define /type aliases/ for intermediate stages_.

- Example:
  Suppose we want to create a NEW /monad/ by composing ~Option~ (inside) and
  ~Either~. We need to use ~Either~ as the FIRST /type parameter/ of ~OptionT~.
  _However, ~Either~ itself has *TWO* /type parameters/ and /monads/ ONLY have
  one._
    We *need* (=from Jian= and *must use*) a /type alias/ to convert the
  type constructor to the correct shape:
  #+begin_src scala
    // Alias `Either` to a type constructor with one parameter:
    type ErrorOf[A] = Either[String, A]

    // Build our final monad stack using `OptionT`:
    type ErrorOrOption[A] = OptionT[ErrorOr, A]
  #+end_src
  * =from Jian=
    We can't define the NEW /monad/ as ~OptionT[Either[String, _], A]~
    + Q :: Can Scala support syntax like this without any ambiguity???
    + A :: =Jian's Guess=:
           I'm not sure, even suppose the compiler understand the ~_~
           syntax, I guess the compiler won't allow this because it can't
           know ~String~ here is a part of the context -- for the compiler,
           it may thing both ~String~ and ~A~ are /type parameters/.

  * Usage:
    #+begin_src scala
      import cats.instances.either._  // for Monad

      val a = 10.pure[ErrorOrOption]
      // a: ErrorOrOption[Int] = OptionT(Right(Some(10)))

      val b = 32.pure[ErrorOrOption]
      // a: ErrorOrOption[Int] = OptionT(Right(Some(32)))

      // val c = a.flatMap(x => b.map(y => x)
      for {
        x <- a
        y <- b
      } yield x + y
      // c: cats.data.OptionT[ErrorOr,Int] = OptionT(Right(Some(42)))
    #+end_src

- Things become even more confusing when we want to stack three or more /monads/.
  For example, let's create a ~Future~ of an ~Either~ of ~Option~.
  * Build inside out with an ~OptionT~ of an ~EitherT~ of ~Future~.
    HOWEVER, we CANNOT define this in one line because ~EitherT~ has _THREE_
    /type parameters/:
    #+begin_src scala
      case class EitherT[F[_], E, A](stack: F[Either[E, A]]) {
        // ...
      }
    #+end_src
    + The three type parameters are as follows:
      - ~F[_]~ is the _outer monad_ in the stack (~Either~ is the inner);
      - ~E~ is the _error type_ for the ~Either~.
      - ~A~ is the _result type_ for the ~Either~.
      -

  * Definition and usage:
    #+begin_src scala
      import scala.concurrent.Future
      import cats.data.{EitherT, OptionT}

      type FutureEither[A] = EitherT[Future, String, A]
      type FutureEitherOption[A] = OptionT[FutureEither, A]

      import cats.instances.future._  // for Monad
      import scala.concurrent.Await
      import scala.concurrent.ExecutionContext.Implicits.global
      import scala.concurrent.duration._

      val futureEitherOr: FutureEitherOption[Int] =
        for {
          a <- 10.pure[FutureEitherOption]
          b <- 32.pure[FutureEitherOption]
        } yield a + b
    #+end_src

- *Kind Projector*
  /Kind projector/ is a compiler plugin that *enhances* Scala's type syntax
  to _make it EASIER to define_ /partially applied type constructors/.
  * For example,
    #+begin_src scala
      import cats.instances.option._  // for Monad
      // import cats.instances.option._

      123.pure[EitherT[Option, String, ?]]
      // res7: cats.data.EitherT[Option,String,Int] = EitherT(Some(Right(123)))
    #+end_src

  * CAUTION:
    The /kind projector/ *CANNOT simplify ALL* _type declarations_ down to a
    single line, but it can reduce the number of intermediate type
    definitions _needed to keep our code readable_.

*** DONE 10.3.3 Constructing and Unpacking Instances - 270
CLOSED: [2020-02-16 Sun 00:52]
- Use the ~apply~ method or ~pure~ method to create _transformed monad stacks
  instances_:
  * Use ~apply~
    #+begin_src scala
      val errorStack1 = OptionT[ErrorOr, Int](Right(Some(10)))
      // errorStack1: cats.data.OptionT[ErrorOr,Int] = OptionT(Right(Some(10)))
    #+end_src

  * Use ~pure~
    #+begin_src scala
      val errorStack2 = 32.pure[ErrorOrOption]
      // errorStack2: ErrorOrOption[Int] = OptionT(Right(Some(32)))
    #+end_src

- Use the ~value~ /method/ to unpack, and
  each ~value~ can upack one level:
  #+begin_src scala
    // Extracting the untransformed monad stack:
    errorStack1.value
    // res11: ErrorOr[Option[Int]] = Right(Some(10))

    // Mapping over the `Either` in the stack:
    errorStack2.value.map(_.getOrElse(-1))
    // res13: scala.util.Either[String,Int] = Right(32)


    // Multiple levels unpack
    futureEitherOr
    // res14: FutureEitherOption[Int] = OptionT(EitherT(Future(Success(Right(Some(42))))))

    val intermediate = futureEitherOr.value
    // intermediate: FutureEither[Option[Int]] = EitherT(Future(Success(Right(Some(42)))))

    val future = intermediate.value
    // stack: scala.concurrent.Future[Either[String,Option[Int]]] = Future(Success(Right(Some(42))))

    Await.result(stack, 1.second)
    // res15: Either[String,Option[Int]] = Right(Some(42))
  #+end_src

*** DONE 10.3.4 Default Instances - 272
CLOSED: [2020-02-16 Sun 00:57]
- Some of the Cats monads defined by /monad transformers/:
  #+begin_src scala
    type Reader[E, A] = ReaderT[Id, E, A]  // = Kleisli[Id, E, A]
    type Writer[W, A] = WriterT[Id, W, A]
    type State[S, A] = StateT[Id, S, A]
  #+end_src

- In other cases, /monad transformers/ are defined separately to their
  _corresponding_ /monads/, and the /methods/ of the transformer *tend to
  MIRROR the /methods/ on the /monad/.* For example,
  * ~OptionT~ defines ~getOrElse~
  * ~EitherT~ defines ~fold~, ~bimap~, ~swap~, and other useful /methods/.

*** DONE 10.3.5 Usage Patterns - 272
CLOSED: [2020-02-16 Sun 01:21]
The system with /monad transformers/ need to be well designed.
_Without careful thought_, developers of code based on this system may
end up having to unpack and repack /monads/ in different configurations to
operate on them in differnt contexts.

- Unfortunately, there aren't one-size-fits-all approaches to working with
  /monad transformers/. The two common approaches:
  1. For *small* OR/AND *homogenous* code bases,
     we can define a single "super stack", and stick ot it throughout our
     code base.
     =from Jian= Even in large and heterogeneous code base, we may find some
     "super stacks", though most of the stacks are not of this kind.

  2. For *large* AND/OR *heterogeneous* code bases,
     we often identify and make local /monad transformers/, use them in
     local, and untansform them before passing them on through _module
     boundaries_.

- Example code: 138 and 139

- The approache 2 is more universal, but it also need more consideration and
  trade off.
    Try to experiment more and gather feedback from colleagures to determine
  whether monad transformers are a good fit.

** DONE 10.4 Exercise: Monads: Transform and Roll Out - 274
CLOSED: [2020-02-16 Sun 01:55]

** DONE 10.5 Summary - 276
CLOSED: [2020-02-16 Sun 01:36]
In this chapter we *introduced* /monad transformers/, which *eliminate* the
need for /NESTED for comprehensions/ and /pattern matching/ when working with
"stacks" of _NESTED monads_.

* DONE 11 ~Semigroupal~ and ~Applicative~ - 277
CLOSED: [2020-02-21 Fri 10:42]
- We'll explore certain types of program flow that they cannot represent.
  * For example, _form validation_:
    When we validate a form we want to return all the errors to the user, *not
    stop* on the first error we encounter.
      _If we model this with a /monad/ like ~Either~, we fail fast and lose
    errors. This is because one depends on the previous one._

- We need a weaker construct -- one that does _NOT guarantee_ sequencing -- to
  achieve the result we want.
    In this chapter we will look at TWO /type classes/ that support this
  pattern:
  * ~Semigroupal~ encompasses the notion of *composing pairs of contexts*.

    Cats provides a ~cats.syntax.apply~ module that makes use of ~Semigroupal~
    and ~Functor~ to allow users to _sequence functions with multiple
    arguments_.

  * ~Applicative~ extends ~Semigroupal~ and ~Functor~.
    It provides a way of _applying functions to parameters within a context_.
    ~Applicative~ is the source of the ~pure~ /method/ we introduced in
    Chapter 4.

- ~Applicative~'s are often formulated in terms of function application, instead
  of the /semigroupal/ formulation that is _emphasised in Cats_.
    This alternative formulation provides a link to other libraries and languages
  such as Scalaz and Haskell.
  TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
  We'll take a look at different formulations of ~Applicative~, as well as the
  relationships between ~Semigroupal~, ~Functor~, ~Applicative~, and ~Monad~,
  towards the end of the chapter.
  =IMPORTANT=

** DONE 11.1 ~Semigroupal~ - 279
   CLOSED: [2020-02-20 Thu 14:42]
   ~cat.Semigroupal~ is a /type class/ that allows us to *combine contexts*:
   If we have two objects of type ~F[A]~ and ~F[B]~, a ~Semigroupal[F]~ allows
   us to combine them to form an ~F[(A, B)]~.

   - Definition in Cats:
     #+begin_src scala
       trait Semigroupal[F[_]] {
         def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]
       }
     #+end_src
     * More freedom than ~Monad~:
       ~fa~ and ~fb~ are mutually independent, and we can compute them *in either
       order* before passing them to ~product~.

       This is in contrast to ~flatMap~, which *imposes a strict order* on its
       parameters.

*** DONE 11.1.1 Joining Two Contexts - 279
CLOSED: [2020-02-20 Thu 14:40]
While ~Semigroup~ allows us to *join* /values/,
~Semigroupal~ allows us to *join* /contexts/.
- For example,
  #+begin_src scala
    import cats.Semigroupal
    import cats.instances.option._  // for Semigroupal

    Semigroupal[Option].product(Some(123), Some("abc"))
    // res0: Option[(Int, String)] = Some((123,abc))

    Semigroupal[Option].product(None, Some("abc"))
    // res1: Option[(Nothing, String)] = None

    Semigroupal[Option].product(Some(123), None)
    // res2: Option[(Int, Nothing)] = None
  #+end_src

*** DONE 11.1.2 Joining Three or More Contexts - 280
CLOSED: [2020-02-20 Thu 14:42]
The companion object for ~Semigroupal~ defines a set of methods on top of
~product~.

- ~tuple2~ to ~tuple22~ generalise ~product~ to different arities:
  #+begin_src scala
    import cats.instances.option._ // for Semigroupal

    Semigroupal.tuple3(Option(1), Option(2), Option(3))
    // res3: Option[(Int, Int, Int)] = Some((1,2,3))

    Semigroupal.tuple3(Option(1), Option(2), Option.empty[Int])
    // res4: Option[(Int, Int, Int)] = None
  #+end_src

- ~map2~ to ~map22~ apply a user-specified function to the values inside 2 to
  22 contexts:
  #+begin_src scala
    Semigroupal.map3(Option(1), Option(2), Option(3))(_ + _ + _)
    // res5: Option[Int] = Some(6)

    Semigroupal.map2(Option(1), Option.empty[Int])(_ + _)
    // res6: Option[Int] = None
  #+end_src

- There are also:
  TODO NO detail in this book. Learn to use these methods!!!
  * ~contramap2~ to ~contramap22~ for ~Contravariant~;
  * ~impa2~ to ~imap22~ for ~Invariant~.

*** DONE 11.1.3 Semigroupal Laws - 280

** DONE 11.2 ~Apply~ Syntax - 281
CLOSED: [2020-02-20 Thu 14:47]
/Apply syntax/, ~cats.syntax.apply~, is a shorthand for the /methods/
described above.

- Import the syntax form ~cats.syntax.apply~.
  #+begin_src scala
    import cats.instances.option._  // for Semigroupal
    import cats.syntax.apply._      // for tupled and mapN
  #+end_src

- The ~tupled~ /method/ is implicitly added to the tuple of ~Option~'s.
  It uses the ~Semigroupal~ for ~Option~ to zip the values inside the
  ~Option~'s, creating a single ~Option~ of a tuple:
  #+begin_src scala
    (Option(123), Option("abc")).tupled
    // res7: Option[(Int, String)] = Some((123,abc))

  #+end_src

  This can be up to 22 values.
  #+begin_src scala
    (Option(123), Option("abc"), Option(true)).tupled
    // res8: Option[(Int, String, Boolean)] = Some((123,abc,true))
  #+end_src

- ~mapN~:
  #+begin_src scala
    case class Cat(name: String, born: Int, color: String)

    (Option("Garfield"),
     Option(1978),
     Option("Orange & black")).mapN(Cat.apply)
    // res9: Option[Cat] = Some(Cat(Garfield,1978,Orange & black))
  #+end_src
  * It's nice to see that this syntax is type checked!!!
    You must guarantee _RIGHT ARITY_, or there will be *compile time error*
    (_GOOOOOOD!!!_).

  * Internally ~mapN~ uses the ~Semigroupal~ to extract the values from the
    ~Option~ and the ~Functor~ to apply the values to the function.

*** DONE 11.2.1 Fancy Functors and Apply Syntax - 283 - =TODO= =???=
CLOSED: [2020-02-20 Thu 14:50]
/Apply syntax/ also has ~contramapN~ and ~imapN~ /methods/ that accept
/Contravariant functors/ and /Invariant functors/.

- WHY??????????????
  =TODO= =IMPORTANT= =TODO=
  Why do we combine ~Monoid~ with ~Invariant~, rather than others?

- For example, we can combine ~Monoid~'s using ~Invariant~:
  #+begin_src scala
    import cats.Monoid
    import cats.instances.int._ // for Monoid
    import cats.instances.invariant._ // for Semigroupal
    import cats.instances.list._ // for Monoid
    import cats.instances.string._ // for Monoid
    import cats.syntax.apply._ // for imapN

    case class Cat(
      name: String,
      yearOfBirth: Int,
      favoriteFoods: List[String]
    )

    val tupleToCat: (String, Int, List[String]) => Cat =
      Cat.apply _

    val catToTuple: Cat => (String, Int, List[String]) =
      cat => (cat.name, cat.yearOfBirth, cat.favoriteFoods)

    implicit val catMonoid: Monoid[Cat] = (
      Monoid[String],
      Monoid[Int],
      Monoid[List[String]]
    ).imapN(tupleToCat)(catToTuple)
  #+end_src

  ~Monoid~ allows us to create "empty" ~Cat~'s, and add ~Cat~'s together
  using the /syntax/ from Chapter 2:
  #+begin_src scala
    import cats.syntax.semigroup._ // for |+|

    val garfield = Cat("Garfield", 1978, List("Lasagne"))
    val heathcliff = Cat("Heathcliff", 1988, List("Junk Food"))

    garfield |+| heathcliff
    // res17: Cat = Cat(GarfieldHeathcliff,3966,List(Lasagne, Junk Food))
  #+end_src

** DONE 11.3 ~Semigroupal~ Applied to Different Types - 284
CLOSED: [2020-02-20 Thu 15:43]
~Semigroupal~ doesn't always provide the behaviour we expect, particularly
for types that also have instances of ~Monad~.

We have seen the behaviour of the ~Semigroupal~ for ~Option~.
Let's look at some examples for other types.

**** DONE ~Future~ - 284
CLOSED: [2020-02-20 Thu 15:34]
#+begin_src scala
  import cats.Semigroupal
  import cats.instances.future._ // for Semigroupal
  import scala.concurrent._
  import scala.concurrent.duration._
  import scala.concurrent.ExecutionContext.Implicits.global
  import scala.language.higherKinds

  val futurePair = Semigroupal[Future].product(Future("Hello"), Future(123))
  Await.result(futurePair, 1.second)
  // res1: (String, Int) = (Hello,123)
#+end_src
The two ~Future~'s start executing the moment we create them, so they are
already calculating results by the time we call product.

Use _apply syntax_ to zip fixed numbers of ~Future~'s:
#+begin_src scala
  import cats.syntax.apply._ // for mapN

  case class Cat(
    name: String,
    yearOfBirth: Int,
    favoriteFoods: List[String]
  )

  val futureCat = (
    Future("Garfield"),
    Future(1978),
    Future(List("Lasagne"))
  ).mapN(Cat.apply)

  Await.result(futureCat, 1.second)
  // res4: Cat = Cat(Garfield,1978,List(Lasagne))
#+end_src

**** DONE ~List~ - 285
CLOSED: [2020-02-20 Thu 15:37]
#+begin_src scala
  import cats.Semigroupal
  import cats.instances.list._ // for Semigroupal

  Semigroupal[List].product(List(1, 2), List(3, 4))
  // res5: List[(Int, Int)] = List((1,3), (1,4), (2,3), (2,4))
#+end_src
TODO
This unexpected behavior (cartesion product, rather than simple zip) will
be explained later.

**** DONE ~Either~ - 286
CLOSED: [2020-02-20 Thu 15:43]
#+begin_src scala
  import cats.instances.either._ // for Semigroupal

  type ErrorOr[A] = Either[Vector[String], A]

  Semigroupal[ErrorOr].product(
    Left(Vector("Error 1")),
    Left(Vector("Error 2"))
  )
  // res7: ErrorOr[(Nothing, Nothing)] = Left(Vector(Error 1))
#+end_src
We see the unexpected fail fast behavior!
Same reason as we see in the last section (~List~).
TODO Explain later.

*** DONE 11.3.1 Semigroupal Applied to Monads - 286
CLOSED: [2020-02-20 Thu 15:29]
The reason for the surprising results for ~List~ and ~Either~ is that they are
both /monads/.
- _To ensure CONSISTENT semantics_,
  *Cats' ~Monad~ (which extends ~Semigroupal~) provides a standard definition
  of ~product~ in terms of ~map~ and ~flatMap~.*

  This gives what we might think of as unexpected and less useful behaviour
  for a number of data types. _The consistency of semantics is important for
  higher level abstractions_, but we don't know about those yet.

- Even our results for ~Future~ are a trick of the light.
  Its ~product~ provides sequential ordering that origin from ~flatMap~:
    The _parallel execution_ we observe occurs because our constituent
  ~Future~'s start running before we call ~product~!!!
  =from Jian=
  this means the _parallel execution_ is still there, but nothing related
  to ~flatMap~ or ~product~, who only do the combination after _parallel
  execution_.

**** DONE 11.3.1.1 Exercise: The Product of Monads - 287
CLOSED: [2020-02-20 Thu 15:07]
#+begin_src scala
  import cats.Monad

  import cats.syntax.flatMap._  // for flatMap
  import cats.syntax.functor._  // for map

  def product[M[_]: Monad, A, B](x: M[A], y: M[B]): M[(A, B)] =
    for {
      xv <- x
      yv <- y
    } yield (xv, yv)
#+end_src

** TODO 11.4 ~Parallel~ - 288
*** 11.4.0.1 Exercise: Parallel List - 291

** DONE 11.5 ~Apply~ and ~Applicative~ - 291
CLOSED: [2020-02-21 Fri 10:36]
/Semigroupals/ are NOT mentioned FREQUENTLY in the wider functional
programming literature.
  They provide a _subset_ of the functionality of a related /type class/
called an /applicative functor/ ("applicative" for short).

- ~Semigroupal~ and ~Applicative~ _effectively provide ALTERNATIVE *encodings*
  of the same notion of *joining contexts*._

- Both ~Semigroupal~ and ~Applicative~ encodings are introduced in the same
  2008 paper by Conor McBride and Ross Paterson.
  + _footnote 2_: /Semigroupal/ is referred to as "monoidal" in the paper

- Cats models /applicatives/ using _TWO_ /type classes/: =IMPORTANT=
  1. ~cats.Apply~, extends ~Semigroupal~ and ~Functor~ and adds an ~ap~ /method/
     that applies a parameter to a function within a context.

  2. ~cats.Applicative~, extends ~Apply~, adds the ~pure~ /method/ introduced
     in Chapter 4.

- Here's a simplified definition in code:
  #+begin_src scala
    trait Apply[F[_]] extends Semigroupal[F] with Functor[F] {
      def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]

      def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
        ap(map(fa)(a => (b: B) => (a, b)))(fb)
    }

    trait Applicative[F[_]] extends Apply[F] {
      def pure[A](a: A): F[A]
  #+end_src

- Don't worry too much about the implementation of /product/!
  It's difficult to read and the details aren't particuarly important.

  The main point is that there is a _tight relationship between_ ~product~,
  ~ap~, and ~map~
  that
  allows _any one of them to be defined in terms of the other two_.
  TODO TODO TODO _TRY!!!_

- ~Applicative~ also introduces the ~pure~ method.
    This is the ~pure~ we saw in ~Monad~, who extends ~Applicative~.
  It constructs a new _applicative instance_ from an unwrapped value.

  In this sense,
  ~Applicative~ is related to ~Apply~ as ~Monoid~ is related to ~Semigroup~.

*** DONE 11.5.1 The Hierarchy of Sequencing Type Classes - 292
CLOSED: [2020-02-21 Fri 10:36]
There is a whole family of /type classes/ that concern themselves with
*sequencing* computations _in DIFFERENT ways_.

- Figure 6.1: ~Monad~ type class hierarchy
  ~Semigroupal~ (~product~)  ~Functor~ (~map~)
                 \            /
                  \          /
                  ~Apply~ (~ap~)
                   /        \
                  /          \
  ~Applicative~ (~pure~)   ~FlatMap~ (~map~)
                  \          /
                   \        /
                     ~Monad~

- EACH /type class/ in the hierarchy represents a particular set of sequencing
  semantics, introduces a set of /characteristic methods/, and *defines the
  functionality of its supertypes in terms of them*:
  * every /apply/ is a /functor/;
    ~Apply~
    + _defines_
      - ~ap~
      - (override) ~product~ _in terms of_ and ~map~
    + _inherits_ ~map~ (from ~Functor~)

  * every /applicative/ is a /semigroupal/;
    ~Applicative~
    + _defines_
      - ~pure~
      - (_override_) ~ap~ TODO _???What's the diff between this and /apply/'s???_

    + _inherits_ standard definitions of
      - ~product~ (from ~Semigroupal~)
      - ~map~ (from ~Functor~).

  * every /monad/ is an /applicative/;
    ~Monad~
    + _defines_
      - ~flatMap~
      - (override) ~product~, ~ap~, and ~map~, _in terms of_ ~pure~ and ~flatMap~;
        =from Jian= The only one that ~Monad~ does _NOT override_ is ~pure~.
    + _inherits_ ~pure~ (from ~Applicative~)

- Assume there is a /monad/ ~Foo~ and a /applicative functor/ ~Bar~.
  * Q :: What can we say about them without knowing more about their implementation?
  * A :: Since ~Monad~ is a subtype of ~Applicative~, we know more about ~Foo~.
         ~Foo~ can guarantee more properties, while ~Bar~, who has fewer
         laws, may have a wider range of behaviours.
           _This is a classic trade-off of power (in the mathematical sense)
         versus constraint._

- If you want to _impose a strict sequencing_ on the computations, ~Monad~ is good.
  If you want to avoid this, ~Semigroupal~ and ~Applicative~ can be a good choice.

** DONE 11.6 Summary - 294
CLOSED: [2020-02-21 Fri 10:42]

* DONE 12 ~Foldable~ and ~Traverse~ - 297
CLOSED: [2020-02-22 Sat 00:56]
_TWO_ /type classes/ that capture *iteration over collecons*:
- ~Foldable~ abstracts the familiar ~foldLeft~ and ~foldRight~ operations;

- ~Traverse~ is a higher-level abstraction that uses ~Applicative~'s to *iterate*
  _with LESS pain than folding_. TODO

We'll start by looking at ~Foldable~, and then _examine cases where folding
becomes complex and ~Traverse~ becomes convenient._ TODO =IMPORTANT=

** DONE 12.1 ~Foldable~ - 297
CLOSED: [2020-02-21 Fri 15:08]
- The ~Foldable~ /type class/ captures the ~foldLeft~ and ~foldRight~ /methods/
  we're used to in sequences like ~List~'s, ~Vector~'s, and ~Stream~'s.

- Using ~Foldable~,
  * we can write /generic folds/ that work with a variety of /sequence types/.

  * We can also
    _invent_ new sequences
    and
    _plug_ them _into_ our code.

- ~Foldable~ gives us greate use cases for ~Monoid~'s and the ~Eval~ /monad/.
  TODO =???=

*** DONE 12.1.1 Folds and Folding - 298
CLOSED: [2020-02-21 Fri 10:52]
- Depending on the operation we're performing, the order in which we fold may
  be important. Thus there are _TWO_ standard variants of /fold/:
  * ~foldLeft~ traverses from "left" to "right" (start to finish)
  * ~foldRight~ traverses from "right" to "left" (finish to start)

- ~foldLeft~ and ~foldRight~ are equivalent if our binary operation is
  /associative/.

*** DONE 12.1.2 Exercise: Reflecting on Folds - 299
CLOSED: [2020-02-21 Fri 10:52]
Try using ~foldLeft~ and ~foldRight~ with _empty lists_ as accumulator and
~::~ as the binary operator. See the result.
#+begin_src scala
  val list: List[Int] = List(1, 2, 3)

  list.foldLeft(List.empty[Int]) {
    (acc, e) => e :: acc
  }
  // List(3, 2, 1)

  list.foldRight(List.empty[Int]) {
    (e, acc) => e :: acc
  }
  // List(1, 2, 3)
#+end_src

*** DONE 12.1.3 Exercise: Scaf-fold-ing Other Methods - 299
CLOSED: [2020-02-21 Fri 10:57]
Implement ~List~'s ~map~, ~flatMap~, ~filter~, and ~sum~ /methods/ in terms
of ~foldRight~:
#+begin_src scala
  def map[A, B](list: List[A])(f: A => B): List[B] =
    list.foldRight(List.empty[B]){ (e, acc) =>
      f(e) :: acc
    }

  def flatMap[A, B](list: List[A])(f: A => List[B]): List[B] =
    list.foldRight(List.empty[B]){ (e, acc) =>
      f(e) ::: acc
    }

  def filter[A](list: List[A])(p: A => Boolean): List[A] =
    list.foldRight(List.empty[A]){ (e, acc) =>
      if (p(e)) e :: acc else acc
    }

  def sum[A](list: List[A])(implicit m: Monoid[A]): A =
    list.foldRight(m.empty)(m.combine)
#+end_src

*** DONE 12.1.4 Foldable in Cats - 300
CLOSED: [2020-02-21 Fri 15:08]
Cats' ~Foldable~ abstracts ~foldLeft~ and ~foldRight~ into a /type class/.
- Instances of ~Foldable~
  1. _define_ these TWO /methods/

  2. _inherit_ a host of /derived methods/.

- Cats provides out-of-the-box /instances/ of ~Foldable~ for a handful of
  Scala data types: ~List~, ~Vector~, ~Stream~, and ~Option~.

- ~List~ with ~Foldable~:
  #+begin_src scala
    import cats.Foldable
    import cats.instance.list._  // for Foldable

    val ints = List(1, 2, 3)

    Foldable[List].foldLeft(ints, 0)(_ + _)
    // res1: Int = 6
  #+end_src

- =from Jian=
  Suggestion to this book:
  Replace ~Stream~ (Deprecated) with ~LazyList~.

- ~Option~ with ~Foldable~:
  #+begin_src scala
    import cats.Foldable
    import cats.instance.option._  // for Foldable

    val maybeInt = Option(123)

    Foldable[Option].foldLeft(maybeInt, 10)(_ * _)
    // res3: Int = 1230
  #+end_src

**** DONE 12.1.4.1 Folding Right - 300 - =TODO= =RE-READ=
CLOSED: [2020-02-21 Fri 14:36]
~Foldable~ defines ~foldRight~ differently to ~foldLeft~, in terms of the
~Eval~ /monad/:
#+begin_src scala
  def foldRight[A, B](fa: F[A], lb: Eval[B])
               (f: (A, Eval[B]) => Eval[B]): Eval[B]
#+end_src
The ~Eval~ /monad/ can promise /stack safe/,

- =from Jian= I think this sentence is *Misleading*!!!
  EVEN WHEN the collection's default definition of ~foldRight~ is NOT.

  =from Jian= Suggestion: delete!

- Example:
  =from Jian= Replace ~Stream~ with other data types. Might not be
  ~LazyList~, I guess ~LazyList~ might have already done the right thing.
  =from Jian= =IMPORTANT= TODO TODO

  #+begin_src scala
    import cats.Eval
    import cats.Foldable
    import cats.instance.stream._  // for Foldable

    def bigData = (1 to 100000).toStream

    bigData.foldRight(0L)(_ + _)
    // java.lang.StackOverflowError ...


    val eval: Eval[Long] =
      Foldable[Stream].
        foldRight(bigData, Eval.now(0L)) { (num, eval) =>
          eval.map(_ + num)
        }

    eval.value
    // res7: Long = 5000050000
  #+end_src

- *Stack Safety in the Standard Library*
  /Stack Safety/ is NOT typically an issue when using the standard library.

  The most commonly used collection types, such as ~List~ and ~Vector~,
  provide /stack safe/ implementations of ~foldRight~.

  We use ~Stream~ here is just because ~Stream~ is an exception.

**** DONE 12.1.4.2 Folding with Monoids - 302
CLOSED: [2020-02-21 Fri 14:39]
- ~Foldable~ provides us with a host of useful /methods/ defined on top of
  ~foldLeft~. Many of these are facsimilies of familiar methods from the
  standard library:
  * ~find~
  * ~exists~
  * ~forall~
  * ~toList~
  * ~isEmpty~
  * ~nonEmpty~, and so on.

- In addition to these familiar methods, Cats provides two /methods/ that
  make use of ~Monoid~'s:
  * ~combineAll~ (and its alias ~fold~) combines all elements in the sequence
    using their ~Monoid~;
    #+begin_src scala
      import cats.instances.int._  // for Monoid

      Foldable[List].combineAll(List(1, 2, 3))
      // res12: Int = 6
    #+end_src

  * ~foldMap~ maps a user-supplied function over the sequence and combines
    the results using a ~Monoid~.
    #+begin_src scala
      import cats.instances.string._  // for Monoid

      Foldable[List].combineAll(List(1, 2, 3))(_.toString)
      // res12: Int = 123
    #+end_src

- Finally, we can compose ~Foldable~'s to support deep traversal of nested
  sequences: TODO =IMPORTANT= details ??? TODO
  #+begin_src scala
    import cats.instance.vector._  // for Monoid

    val ints = List(Vector(1, 2, 3), Vector(4, 5, 6))

    (Foldable[List] compose Foldable[Vector]).combineAll(ints)
    // res15: Int = 21
  #+end_src

**** DONE 12.1.4.3 Syntax for Foldable - 303
CLOSED: [2020-02-21 Fri 15:08]
With syntax imported, the first argument to the /static method/ becomes
the /receiver/ of the /method/ call:
#+begin_src scala
  import cats.syntax.foldable._  // for combineAll and foldMap

  List(1, 2, 3).combineAll
  // res16: Int = 6

  List(1, 2, 3).foldMap(_.toString)
  // res17: String = 123
#+end_src

- *Explicits over Implicits*
  * Scala feature: Use the _explicit available_ on the /receiver/ if it exists.
    For example,
    + Use the ~foldLeft~ defined on ~List~:
      #+begin_src scala
        List(1, 2, 3).foldLeft(0)(_ + _)  // res18: Int = 6
      #+end_src

    + The following generic code will use ~Foldbale~:
      #+begin_src scala
        import scala.language.higherKinds

        def sum[F[_]: Foldable](values: F[Int]): Int =
          values.foldLeft(0)(_ + _)
        // sum: [F[_]](values: F[Int])(implicit evidence$1: cats.Foldable[F])Int
      #+end_src

  * If we need a *stack-safe implementation* of ~foldRight~, using ~Eval~ as
    the accumulator is enough to force the compiler to select the method
    from Cats.

** DONE 12.2 ~Traverse~ - 304 - =TODO= 9.2.2 =RE-READ=
CLOSED: [2020-02-22 Sat 00:56]
~foldLeft~ and ~foldRight~ are flexible iteration methods but they require us
to do a lot of work to *define _accumulators_ and _combinator functions_.*
  The ~Traverse~ /type class/ is a higher level tool that leverages
~Applicative~'s to provide a more convenient, more lawful, pattern for
iteration.

*** DONE 12.2.1 Traversing with ~Future~'s - 304
CLOSED: [2020-02-21 Fri 15:17]
- Question:
  A list of server hostnames and method to poll a host for its uptime:
  #+begin_src scala
    import scala.concurrent._
    import scala.concurrent.duration._
    import scala.concurrent.ExecutionContext.Implicits.global

    val hostnames = List(
      "alpha.example.com",
      "beta.example.com",
      "gamma.demo.com"
    )

    def getUptime(hostname: String): Future[Int] =
      Future(hostname.length * 60)  // just for demonstration
  #+end_src

- We can't simply map over ~hostnames~ because the result -- a ~List[Future[Int]]~
  -- would contain more than one ~Future~.
    We need to reduce the results to a single ~Future~ to get something we can
  block on. Let's start by doing this manually using a ~fold~:
  #+begin_src scala
    val allUptimes: Future[List[Int]] =
      hostnames.foldLeft(Future(List.empty[Int])) { (accum, host) =>
        val uptime = getUptime(host)
        for {
          acc <- accum
          ut  <- uptime
        } yield acc :+ ut
      }

    Await.result(allUptimes, 1.second)
    //res2: List[Int] = List(1020, 960, 840)
  #+end_src

- Expected when simplified:
  #+begin_src scala
    val allUptimes: Future[List[Int]] =
      Future.traverse(hostname)(getUptime)

    Await.result(allUptimes, 1.second)
    // res3: List[Int] = List(1020, 960, 840)
  #+end_src
  * How does this implementated?
    If we ignore distractions like ~CanBuildFrom~ and ~ExecutionContext~,
    #+begin_src scala
      def traverse[A, B](values: List[A])
                        (func: A => Future[B]): Future[List[B]] =
        values.foldLeft(Future(List.empty[A])) { (accum, host) =>
          val item = func(host)
          for {
            acc <- accum
            e   <- item
          } yield acc :+ e
        }
    #+end_src

  * This is essentially the same as our example code above.
    It gives us a clean high-level interface to do what we want:
    + start with a ~List[A]~
    + provide a function ~A => Future[B]~
    + end up with a ~Future[List[B]]~

- There is also a ~Future.sequence~ method defined as
  #+begin_src scala
    object Future {
      def sequence[B](futures: List[Future[B]]): Future[List[B]] =
        traverse(futures)(identity)

      // etc...
    }
  #+end_src
  * start with a ~List[Future[A]]~
  * end up with a ~Future[List[A]]~

- The simplified examples above only work with ~List~'s, but the real
  ~Future.traverse~ and ~Future.sequence~ work with *any* standard Scala
  collection.

- Cats' ~Traverse~ /type class/ generalises these patterns to work with any
  type of ~Applicative~: ~Future~, ~Option~, ~Validated~, and so on.

- We'll approach ~Traverse~ in the next sections in two steps:
  1. We'll generalise over the ~Applicative~, then we'll generalise over the
     /sequence type/.

  2. We'll end up with an extremely valuable tool that trivialises many
     operations involving sequences and other data types.

*** DONE 12.2.2 Traversing with ~Applicative~'s - 307 - =TODO=
CLOSED: [2020-02-21 Fri 15:51]
- We'll see that we can _rewrite_ ~traverse~ in terms of an ~Applicative~.
  Our accumulator from the example above:
  ~Future(List.empty[Int])~ is equivalent to ~Applicative.pure~:
  #+begin_src scala
    import cats.Applicative
    import cats.instances.future._    // for Applicative
    import cats.syntax.applicative._  // for pure

    List.empty[Int].pure[Future]

    def oldCombine(
      accum: Future[List[Int]],
      host : String
    ): Future[List[Int]] = {
      val uptime = getUptime(host)
      for {
        acc <- accum
        ut  <- uptime
      } yield acc :+ ut
    }
  #+end_src
  is now equivalent to ~Semigroupal.combine~:
  #+begin_src scala
    import cats.syntax.apply._ // for mapN

    // Combining accumulator and hostname using an Applicative:
    def newCombine(accum: Future[List[Int]],
                   host: String): Future[List[Int]] =
      (accum, getUptime(host)).mapN(_ :+ _)
  #+end_src

- By substituting these snippets back into the definition of ~traverse~ we can
  generalise it to to work with any ~Applicative~:
  #+begin_src scala
    import scala.language.higherKinds

    def listTraverse[F[_]: Applicative, A, B](list: List[A])
                                             (func: A => F[B]): F[List[B]] =
      list.foldLeft(List.empty[B].pure[F]) { (accum, item) =>
        (accum, func(item)).mapN(_ :+ _)
      }

    def listSequence[F[_]: Applicative, B](list: List[F[B]]): F[List[B]] =
      listTraverse(list)(identity)
  #+end_src
  * Use ~listTraverse~ to re-implement our uptime example:
    #+begin_src scala
      val totalUptime = listTraverse(hostname)(getUptime)
      Await.result(totalUptime, 1.second)
      // res11: List[Int] = List(1020, 960, 840)
    #+end_src

**** DONE 12.2.2.1 Exercise: Traversing with ~Vector~'s - 309
CLOSED: [2019-07-14 Sun 13:58]
#+begin_src scala
  import cats.instances.vector._  // for Applicative

  listSequence(List(Vector(1, 2), Vector(3, 4)))
#+end_src
- Solution:
  ~Vector(List(1, 3), List(1, 4), List(2, 3), List(2, 4))~

**** DONE 12.2.2.2 Exercise: Traversing with ~Option~'s - 309
CLOSED: [2020-02-21 Fri 15:48]
#+begin_src scala
  import cats.instances.option._  // for Applicative

  def process(inputs: List[Int]) =
    listTraverse(inputs)(n => if (n % 2 == 0) Some(n) else None)
#+end_src
- What is the _return type_ of this method?
  ~Option[List[Int]]~

- What does it produce for the following inputs?
  #+begin_src scala
    process(List(2, 4, 6))
    // Some(List(2, 4, 6))

    process(List(1, 2, 3))
    // None
  #+end_src

**** DONE 12.2.2.3 Exercise: Traversing with ~Validated~ - 310 - TODO -WHY
CLOSED: [2020-02-21 Fri 15:51]
#+begin_src scala
  import cats.data.Validated
  import cats.instances.list._ // for Monoid

  type ErrorsOr[A] = Validated[List[String], A]

  def process(inputs: List[Int]): ErrorsOr[List[Int]] =
    listTraverse(inputs) { n =>
      n % 2 match {
        case 0 => Validated.valid(n)
        case _ => Validated.invalid(List(s"$n is not even"))
      }
    }
#+end_src

*** DONE 12.2.3 ~Traverse~ in Cats - 310
CLOSED: [2020-02-22 Sat 00:56]
Generalise over differnt sequence types using a /type class/, which brings us
to Cats' ~Traverse~. Here's the abbreviated definition:
#+begin_src scala
  package cats

  trait Traverse[F[_]] {
    def traverse[G[_]: Applicative, A, B]
                (inputs: F[A])(func: A => G[B]): G[F[B]]

    def sequence[G[_]: Applicative, A]
                (inputs: F[G[A]]): G[F[A]] =
      traverse(inputs)(identity)
  }
#+end_src

- Cats provides instances of ~Traverse~ for ~List~, ~Vector~, ~Stream~, ~Option~,
  ~Either~, and a variety of other types.
    We can _summon instances_ as usual using ~Traverse.apply~ and use ~traverse~
  and ~sequence~ /methods/ as described in the previous section. Or use the
  syntax ~cats.syntax.traverse~

** DONE 12.3 Summary - 312
CLOSED: [2020-02-22 Sat 00:56]

* -----------------------------------------
* III. Interpreters - 315
* TODO 13 Indexed Types - 317
** 13.1 Phantom Types - 318
** 13.2 Indexed Codata - 321
*** Exercise: Torque - 324
*** 13.2.1 API Protocols - 324
*** Exercise: HTML API Design - 329
*** 13.2.2 Beyond Equality Constraints - 329
*** Exercise: Commutivitiy - 331

** 13.3 Indexed Data - 332
** 13.4 Conclusions - 332

* TODO 14 Tagless Final Interpreters - 333
** TODO 14.1 Codata Interpreters - 334
*** 14.1.1 The Terminal - 334
*** 14.1.2 Color Codes - 335
*** 14.1.3 The Trouble with Escape Codes - 335
*** 14.1.4 Programs and Interpreters - 337
*** 14.1.5 Composition and Reasoning - 344
*** 14.1.6 Codata and Extensibility - 344

** TODO 14.2 Tagless Final Interpreters - 345
** TODO 14.3 Algebraic User Interfaces - 352
** TODO 14.4 A Better Encoding - 358
** TODO 14.5 Conclusions - 365

* TODO 15 Optimizing Interpreters and Compilers - 367
** 15.1 Algebraic Manipulation - 367
** 15.2 From Continuations to Stacks - 377
** 15.3 Compilers and Virtual Machines - 382
*** 15.3.1 Virtual and Abstract Machines - 382
*** 15.3.2 Compilation - 383

** 15.4 From Interpreter to Stack Machine - 384
*** 15.4.1 Effectful Interpreters - 389
*** 15.4.2 Further Optimization - 390

** 15.5 Conclusions - 393

* IV. Case Studies - 397
* DONE 16 Creating Usable Code - 399
* DONE 17 Case Study: Testing Asynchronous Code - 401
CLOSED: [2020-02-24 Mon 09:56]
Simplify unit tests for asynchronous code
by making them synchronous.

- XXX TODO
  #+begin_src scala
    import scala.concurrent.Future

    trait UptimeClient {
      def getUptime(hostname: String): Future[Int]
    }
  #+end_src

- XXX TODO
  #+begin_src scala
    import cats.instances.future._  // for Applicative
    import cats.instances.list._    // for Traverse
    import cats.syntax.traverse._   // for traverse

    import scala.concurrent.ExecutionContext.Implicits.global

    class UptimeService(client: UptimeClient) {
      def getTotalUptime(hostname: List[String]): Future[Int] =
        hostname.traverse(client.getUptime).map(_.sum)
    }
  #+end_src

** TODO 17.1 Abstracting over Type Constructors - 403
** TODO 17.2 Abstracting over Monads - 404
** TODO 17.3 Summary - 405

* DONE 18 Case Study: Map-Reduce - 407
CLOSED: [2020-02-24 Mon 09:56]
** TODO 18.1 Parallelizing ~map~ and ~fold~ - 407
** TODO 18.2 Implementing ~foldMap~ - 409
** TODO 18.3 Parallelising ~foldMap~ - 411
*** TODO 18.3.1 ~Future~'s, Thread Pools, and ~ExecutionContext~'s - 411
*** TODO 18.3.2 Dividing Work - 415
*** TODO 18.3.3 Implementing ~parallelFoldMap~ - 415
*** TODO 18.3.4 ~parallelFoldMap~ with more Cats - 416

** TODO 18.4 Summary - 416

* TODO 19 Case Study: Data Validation - 417
- Goals:
  Be able to
  * associate meaningful messages with each validation failure.
  * combine small checks into larger ones.
  * transform data while we are checking it.
  * accumulate all the failures in one go.

** TODO 19.1 Sketching the Library Structure - 418
**** TODO Providing error messages - 358
- Figure 10.1: A validation result
  ~F[A]~

- Figure 10.2: A validation check
  ~A => F[A]~

**** TODO Combine checks - 359
**** TODO Accumulating errors as we check - 360
**** TODO Transforming data as we check it - 360

** TODO 19.2 The Check Datatype - 421
** TODO 19.3 Basic Combinators - 422
** TODO 19.4 Transforming Data - 423
*** TODO 19.4.1 Predicates - 364
*** TODO 19.4.2 Checks - 366
*** TODO 19.4.3 Recap - 368

** TODO 19.5 Kleislis - 429
** TODO 19.6 Summary - 433

* TODO 20 Case Study: CRDTs - 435
** TODO 20.1 Eventual Consistency - 435
** TODO 20.2 The GCounter - 436
*** TODO 20.2.1 Simple Counters - 436
*** TODO 20.2.2 GCounters - 438
*** TODO 20.2.3 Exercise: GCounter Implementation - 439

** TODO 20.3 Generalisation - 440
*** TODO 20.3.1 Implementation - 442
*** TODO 20.3.2 Exercise: ~BoundedSemiLattice~ Instances - 443
*** TODO 20.3.3 Exercise: Generic GCounter - 443

** TODO 20.4 Abstracting GCounter to a Type Class - 443
** TODO 20.5 Abstracting a Key Value Store - 445
** TODO 20.6 Summary - 447

* -----------------------------------------
* Part V. Solutions to Exercises - 449
* TODO A Solutions for: Algebraic Data Types - 451
** A.1 Tree - 391
** A.2 Methods for Tree - 392
** A.3 Tree Fold - 394
** A.4 Using Fold - 396
** A.5 Iterate - 396
** A.6 Map - 397
** A.7 Identities - 397
** A.8 Identities Part 2 - 398

* TODO B Solutions for: Objects as Codata - 459
** B.1 Stream Combinators - 399
** B.2 Or and Not - 400
** B.3 Sets - 401
** B.4 Sets Part 2 - 402
** B.4 Sets Part 3 - 403

* TODO C Solutions for: Contextual Abstraction - 465
** C.1 Printable Library - 405
** C.2 Printable Library Part 2 - 406
** C.3 Printable Library Part 3 - 407
** C.4 Cat ~Show~ - 408
** C.5 Equality, Liberty, and Felinity - 409

* TODO D Solutions for: Reified Interpreteres - 469
** TODO D.1 Arithmetic - 411
** TODO D.2 Arithmetic Part 2 - 411
** TODO D.3 Arithmetic Part 3 - 412
** TODO D.4 CPS Arithmetic - 413
** TODO D.5 Exercise: Trampolined Arithmetic - 415

* TODO E Solutions for: Using Cats - 475
* TODO E Solutions for: ~Monoid~'s and ~Semigroup~'s - 479
** E.1 The Truth About Monoids - 417
** E.2 All Set for Monoids - 418
** E.3 Adding All The Things - 419
** E.4 Adding All The Things Part 2 - 420
** E.5 Adding All The Things Part 3 - 421

* TODO F Solutions for: ~Functor~'s - 485
** F.1 Branching out with Functors - 423
** F.2 Showing off with Contramap - 424
** F.3 Showing off with Contramap Part 2 - 425
** F.4 Transformative Thinking with imap - 426
** F.5 Transformative Thinking with imap Part 2 - 426
** F.6 Transformative Thinking with imap Part 3 - 426

* TODO G Solutions for: ~Monad~'s - 491
** G.1 Getting Func-y - 429
** G.2 Monadic Secret Identities - 430
** G.3 What is Best? - 431
** G.4 Abstracting - 432
** G.5 Safer Folding using ~Eval~ - 432
** G.6 Show Your Working - 433
** G.7 Hacking on Readers - 435
** G.8 Hacking on Readers Part 2 - 436
** G.9 Hacking on Readers Part 3 - 436
** G.10 Post-Order Calculator - 437
** G.11 Post-Order Calculator Part 2 - 438
** G.12 Post-Order Calculator Part 3 - 438
** G.13 Branching out Further with Monads - 438

* TODO H Solutions for: Monad Transformers - 505
** H.1 ~Monad~'s: Transform and Roll Out - 443
** H.2 ~Monad~'s: Transform and Roll Out Part 2 - 443
** H.3 ~Monad~'s: Transform and Roll Out Part 3 - 443
** H.4 ~Monad~'s: Transform and Roll Out Part 4 - 443

* TODO I Solutions for: ~Semigroupal~ and ~Applicative~ - 509
** I.1 The Product of Lists - 447
** I.2 Parallel List - 448

* TODO J Solutions for: ~Foldable~ and ~Traverse~ - 511
** J.1 Reflecting on Folds - 449
** J.2 Scaf-fold-ing Other Methods - 450
** J.3 Traversing with Vectors - 451
** J.4 Traversing with Vectors Part 2 - 452
** J.5 Traversing with Options - 452
** J.6 Traversing with Validated - 453

* TODO ? Solutions for: Indexed Types - 517
* TODO K Solutions for: Case Study: Testing Asynchronous Code - 521
** K.1 Abstracting over Type Constructors - 455
** K.2 Abstracting over Type Constructors Part 2 - 456
** K.3 Abstracting over Monads - 456
** K.4 Abstracting over Monads Part 2 - 457

* TODO L Solutions for: Case Study: Map-Reduce - 525
** L.1 Implementing ~foldMap~ - 459
** L.2 Implementing ~foldMap~ Part 2 - 459
** L.3 Implementing ~parallelFoldMap~ - 460
** L.4 ~parallelFoldMap~ with more Cats - 462

* TODO M Solutions for: Case Study: Data Validation - 531
** M.1 Basic Combinators - 465
** M.2 Basic Combinators Part 2 - 466
** M.3 Basic Combinators Part 3 - 466
** M.4 Basic Combinators Part 4 - 470
** M.5 Basic Combinators Part 5 - 471
** M.6 Checks - 472
** M.7 Checks Part 2 - 473
** M.8 Checks Part 3 - 474
** M.9 Recap - 475
** M.10 Recap Part 2 - 478
** M.11 Kleislis - 480
** M.12 Kleislis Part 2 - 481

* TODO N Solutions for: Case Study: CRDTs - 551
** M.1 ~GCounter~ Implementation - 485
** M.2 ~BoundedSemiLattice~ Instances - 486
** M.3 Generic ~GCounter~ - 487
** M.4 Abstracting ~GCounter~ to a Type Class - 487
** M.5 Abstracting a Key Value Store - 488
* TODO Acknowledgements - 555
* TODO Bibliography - 559
