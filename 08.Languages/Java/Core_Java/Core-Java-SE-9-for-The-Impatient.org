#+TITLE: Core Java SE 9 for The Impatient
#+VERSION: 2nd, 2018
#+INFO: Covers Java SE 9
#+AUTHOR: Cay S. Horstmann
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* TODO Preface - xxi
  - Difference between this book and the classic *Core Java* book:

    + NO words about the Java history

    + NO words about the past Java versions

  - Traditionally, xxxxx =TODO=

  - Finally, this book is written
    + for application programmers

    + *NOT* for a college course

    + *NOT* for systems wizards

  - In another words, the book
    + covers issues that application programmers need to wrestle with, such as
      * logging
      * working with files

    + does *NOT* cover how to implement a linked list by hand

    + does *NOT* cover how to write a web server

* Acknowledgments - xxiii
* About the Author - xxv
* DONE 1. FUNDAMENTAL PROGRAMMING STRUCTURES - 1
  CLOSED: [2017-06-06 Tue 21:12]
  The key points of this chapter are:
  1. In Java, all methods are declared in a class.
     You invoke a nonstatic method on an object of the class to which the method
     belongs.

  2. Static methods are not invoked on objects.
     Program execution starts with the static ~main~ method.

  3. Java has eight primitive types:
     + four integer types,
     + two floating-point
     + types,
     + char,
     + boolean.

  4. The Java operators and control structures are very similar to those of C or
     JavaScript.

  5. The Math class provides common mathematical functions.

  6. String objects are sequences of characters or, more precisely, Unicode code
     points in the UTF-16 encoding.

  7. With the System.out object, you can display output in a terminal window. A
     Scanner tied to System.in lets you read terminal input.

  8. Arrays and collections can be used to collect elements of the same type.

** 1.1 Our First Program - 2
*** 1.1.1 Dissecting the "Hello, World" Program - 2
    #+BEGIN_SRC java
    package ch01.sec01;

    public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello, World!");
        }
    }
    #+END_SRC

    - The ~main~ method is the first method that is called when the program runs.

    - A function is declared as ~static~ does not operate on any objects.

    - =TODO= ~String[] args~

    - ~public~, ~private~

    - ~package~: A package is a set of related classes.

    - ~System.out~, ~System.out.println~

*** 1.1.2 Compiling and Running a Java Program - 3
    #+BEGIN_SRC bash
    # 1. compiles the Java source code into Java byte codes;
    # 2. saves the byte codes into class files.
    javac ch01/sec01/HelloWorld.java

    # launches a virtual machine that loads the class files and excutes the
    # byte codes.
    java ch01.sec01.HelloWorld
    #+END_SRC

*** 1.1.3 Method Calls - 6
    - ~System.out~ is an object, and it is an /instance/ of a class called
      ~PrintStream~ (has method ~println~, ~print~, etc.).

    - ~new Random().nextInt()~ means:
      construct a ~Random~ object, and then call the method ~nextInt()~
      =From Jian=: I think this is a bad syntax!
                   ~(new Random()).nextInt()~ is a much better one.

    - ~Random~ class is declared in the ~java.util~ package. To use it in your
      program, add an ~import~ statement: ~import java.util.Random;~.

*** 1.1.4 JShell - 7

** 1.2 Primitive Types - 10
*** 1.2.1 Signed Integer Types - 10
    - Table 1-1 Java Integer Types
      | Type    | Storage requirement | Range(inclusive)                                        |
      |---------+---------------------+---------------------------------------------------------|
      | ~int~   | 4 bytes             | -2,147,483,648 to 2,147,483,647 (just over 2 billion)   |
      | ~long~  | 8 bytes             | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |
      | ~short~ | 2 bytes             | -32,768 to 32,767                                       |
      | ~byte~  | 1 byte              | -128 to 127                                             |

    - ~Integer~, ~Long~, ~Short~, and ~Byte~ classes have ~MIN_VALUE~ and
      ~MAX_VALUE~ constants.

    - =TODO= ~BigInteger~ class, See Section 1.4.6

    - ~long~ integer literals: add a suffix ~L~.

    - NO syntax for literals of type ~byte~ or ~short~. Use cast, for example:
      ~(byte) 127~.

    - Literals of numbers of different base:
      + Hexadecimal literals: prefix ~0x~
      + Binary literals: prefix ~0b~
      + Octal literals: prefix ~0~

    - You can add underscores to number literals. For example, ~1_000_000~
      They are for human eyes only, the Java compiler simply removes them.

    - _NOTE_:
      _Integer types in Java are signed_ (In CLR, integer can be unsigned).

        However, if you work with values that can never be negative and you
      really need _an additional bit_, you can use methods that interpret
      values as unsigned.

      For example,
      + Reuirement: a byte value ~b~ represent the range from -128 to 127, you
        may want a range from 0 to 255.

      + Solution: Store it in a ~byte~ type value, and
        =???= due to the nature of binary arithmetic, certain operations such as
        addition and subtraction will work.
        For other operations, call ~Byte.toUnsignedInt(b)~, and get an ~int~
        value between 0 and 255.

*** 1.2.2 Floating-Point Types - 12
    - Table 1-2 Java Integer Types
      | Type     | Storage requirement | Range(inclusive)                                                        |
      |----------+---------------------+-------------------------------------------------------------------------|
      | ~float~  | 4 bytes             | Approximately +-3.40282347E+38F(6-7 significant decimal digits          |
      | ~double~ | 8 bytes             | Approximately +-1.79769313486231570E+308F(15 significant decimal digits |
      |          |                     |                                                                         |

    - Literals:
      + ~float~ number example: ~3.14F~
      + ~double~ number example: ~3.14~ or ~3.14D~

    - floating-point literals has hexadecimal form. For example:
      Decimal number 0.0009765625 can be written as (hex form) 0x1.0p-10.
      Since ~e~ is used in hex form, use ~p~ to denote the exmponent.
      + _Even in hex form, the exponent is written in decimal_

    - ~Double.POSITIVE_INFINITY~, ~Double.NEGATIVE_INFINITY~, and ~Double.NaN~.

    - All "not a number" values are considered to be distinct from each other.
      Use ~Double.isNaN(x)~ to test, rather than ~(x == Double.NaN)~ (which is
      always true). There are also
      + ~Double.isInfinite~ tests for ±∞
      + ~Double.isFinite~ tests is the floating-number is neither infinite nor
        NaN.

    - If you need precise numerical computations without roundoff errors, use the
      ~BigDecimal~ class, introduced in Section 1.4.6, “Big Numbers,” on p. 19.
      =TODO=

*** 1.2.3 The ~char~ Type - 13
    - The char type describes "code units” in the _UTF-16 character_ encoding
      used by Java.

    - =TODO= The details are rather technical—see Section 1.5, “Strings,” on p. 20.

    - _You probably won't use the ~char~ type very much._

*** 1.2.4 The ~boolean~ Type - 14
    ~boolean~ type is not a number type.
    There is _NO_ replationship between ~boolean~ values and the integers 0 and
    1.

** 1.3 Variables - 14
   _LEARN_
   how to _declare_ and _initialize_
   + variables
   + constants

*** DONE 1.3.1 Variable Declarations - 14
    CLOSED: [2017-04-23 Sun 01:48]
    - Prefer to use separate declarations for _each_ variable.

    - Declare a variable and initialize it with a constructed object,
      the name of the object's class occurs _TWICE_:
      ~Random generator = new Random();~

*** DONE 1.3.2 Names - 14
    CLOSED: [2017-04-23 Sun 01:49]
    - Java identifier rules:
      + MUST _begin_ with a letter.

      + Can consist of
        * any letters,
        * digits,
        * the symbols
        * ~_~ and ~$~.

      + HOWEVER,
        the ~$~ symbol is intended for automatically generated names,
        and
        you _should NOT_ use it.

*** DONE 1.3.3 Initialization - 15
    CLOSED: [2017-04-23 Sun 01:50]

*** DONE 1.3.4 Constants - 15
    CLOSED: [2017-04-23 Sun 15:39]
    - ~final~

    - Declare a constant _outside_ a method, using the ~static~ keyword:
      #+BEGIN_SRC scala
      public class Calendar {
        public static final int DAYS_PER_WEEK = 7;
      }
      #+END_SRC

    - _Note_:
      The System class declares a constant
      #+BEGIN_SRC scala
      public static final PrintStream out
      #+END_SRC
      that you can use anywhere as ~System.out~.

      _This is one of the few examples of a constant that is not written in
      uppercase._

    - It is legal to defer the initialization of a final variable, provided it is
      initialized exactly once before it is used for the first time. For example,
      the following is legal:
      #+BEGIN_SRC scala
      final int DAYS_IN_FEBRUARY;

      if (leapYear) {
        DAYS_IN_FEBRUARY = 29;
      } else {
        DAYS_IN_FEBRUARY = 28;
      }
      #+END_SRC

    - _Note_:
      + ~enum~ =TODO= Chapter 4

** 1.4 Arithmetic Operations - 17
   - Table 1-3 Java Operators =IMPORTANT=

   - _Note_:
     In this table, operators are listed by _decreasing_ precedence.

*** 1.4.1 Assignment - 18
*** 1.4.2 Basic Arithmetic - 18
    - Always be careful using ~%~ with potentially _negative_ operands.

    - ~X % 12~ returns
      1. a _positive_ number between 0 and 11 (inclusive) _if_ ~X~ _is positive_
      2. a _negative_ number between -11 and -1 (inclusive) _if_ ~X~ _is negative_

    - ~Math.floorMod(X, 12)~ always returns a positive number between 0 and 11
      (inclusive).
      =COMMENT= The first two cases can be simplified as
                ~(X % 12 + 12) % 12~
      1. _if_ ~X~ _is positive_, it returns a result the same as ~X % 12~.
      2. _if_ ~X~ _is negative_, it returns a result the same as ~(X % 12) + 12~.
      3. _if_ the second argument (the divisor) is negative, the result is
         negative.
         This is usually NOT what we want, but fortunately, this situation
         doesn't often occur in practice.

    - _Note_:
      + One of the stated goals of the Java programming language is portability.

        A computation should yield the same results no matter which virtual
        machine executes it.

      + However, many modern processors use
        _floating-point registers with more than 64 bit_
        1. to add precision
           and
        2. reduce the risk of overflow in intermediate steps of a computation.
        Java allows these optimizations, since otherwise floatingpoint operations
        would be slower and less accurate.

      + For the small set of users who care about this issue, there is a
        ~strictfp~ modifier.
        When added (this modifier) to a method, all floating-point operations in
        the method are strictly portable.

*** 1.4.3 Mathematical Methods - 19
    - ~Math.pow(x, y)~ (yields x^y),
      ~Math.sqrt(x)~,
      ~Math.min(x, y)~,
      ~Math.max(x, y)~,
      ~Math.PI~
      ~Math.E~

    - /static methods/

    - Due to overflows, ~Math.multiplyExact(1000000000, 3)~ throws an exception.
      There are also methods
      ~addExact~,
      ~subtractExact~,
      ~incrementExact~,
      ~decrementExact~,
      ~negateExact~,
      all with ~int~ and ~long~ parameters.

    - A few mathematical methods are in other classes.
      For example, there are methods
      ~compareUnsigned~,
      ~divideUnsigned~, and
      ~remainderUnsigned~ in the ~Integer~ and ~Long~ classes to
      _work with UNSIGNED values_.

    - As discussed in the preceding section, some users require strictly
      reproducible floating-point computations even if they are less efficient.
      The ~StrictMath~ class provides strict implementations of mathematical
      methods.

*** TODO 1.4.4 Number Type Conversions - 20
    - important and details
      =TODO= =PAGE 37=

    - ~Math.round~: If you want to round to the nearest integer instead.
      It returns a ~long~.

    - ~Math.toIntExact~: This alarms (throw an exception) you that a /cast/ can
      silently throw away important parts of a number if the number cannot
      convert a ~long~ to an ~int~.

*** 1.4.5 Relational and Logical Operators - 22
    - _Caution_: =This help to avoid to shift to far away=
      The right-hand side argument of the shift operators is reduced
      + modulo 32 if the left hand side is an ~int~,
        or
      + modulo 64 if the left hand side is a ~long~.
      For example, the value of ~1 << 35~ is the same as ~1 << 3~ or ~8~.

    - _Tip_:
      The ~&~ (and) and ~|~ (or) operators, when applied to ~boolean~ values,
      _force evaluation of both operands before combining the results_.
      =NOT SHORT CIRCUIT ANY MORE=
      This usage is very uncommon:
      1. Provided that the right hand side doesn't have a side effect, they act
         just like ~&&~ and ~||~, except they are less efficient.

      2. If you really need to force evaluation of the second operand, assign it
         to a ~boolean~ variable so that the flow of execution is plainly visible.
         =avoid unwanted multiple side effects, if the rhs has side effect.=
         =this method will has one side effect=
         =if not this method, it might be multiple side effects. It depends on=
         =how many times the rhs is used.=

*** 1.4.6 Big Numbers - 23
    - ~BigInteger~ and ~BigDecimal~ classes in the ~java.math~ package.
      _ARBITRARILY LONG SEQUENCE OF DIGITS_

    - Construct a ~BigInteger~ from a string of digits:
      1. Use the _static_ ~valueOf~ method turns a ~long~ into a ~BigInteger~:
         #+BEGIN_SRC java
         BigInteger n = BigInteger.valueOf(876543210123456789L);
         #+END_SRC

      2. from a string of digits:
         #+BEGIN_SRC java
         BigInteger k = new BigInteger("9876543210123456789");
         #+END_SRC

    - _Java does NOT permit the use of operators with objects_,
      so you must use method calls to work with big numbers.
      For example,
      #+BEGIN_SRC java
      BigInteger r = BigInteger.valueOf(5).multiply(n.add(k));
      #+END_SRC

    - ~BigDecimal.valueOf(n, e)~ returns a ~BigDecimal~ instance with value
      n\times10^-e
      For example,
      #+BEGIN_SRC java
      BigDecimal.valueOf(2, 0).substract(BigDecimal.valueOf(11, 1))
        // is exactly 0.9 in value.
      #+END_SRC

** 1.5 Strings - 24
   A string is a sequence of characters.
   In Java, a string can contain any Unicode characters (UTF-16).
*** DONE 1.5.1 Concatenation - 24
    CLOSED: [2017-04-24 Mon 02:20]
    - When you concatenate a string with another value, that value is converted
      to a string. (=From Jian=: like scala implicit conversion?)

    - Don't mix concatenation and addition. At least, use parentheses properly
      group them.
      #+BEGIN_SRC java
      // expected result:
      // "Next year, you will be 43
      "Next year, you will be " + age + 1 // Error
      "Next year, you will be " + (age + 1) // OK
      #+END_SRC

    - Combine several strings, separated with a delimiter, use the ~join~ method:
      #+BEGIN_SRC java
      String names = String.join(", ", "Peter", "Paul", "Mary");
        // Set names to "Peter, Paul, Mary"
      #+END_SRC
      1. The first argument is the separator string,
      2. followed by the strings you want to join.
         * There can be any number of them,
           or
         * you can supply an array of strings.

*** DONE 1.5.2 Substrings - 25
    CLOSED: [2017-04-24 Mon 02:24]
    - ~substring~
      #+BEGIN_SRC java
      String greeting = "Hello, World!";
      String location = greeting.substring(7, 12); // Sets location to "World"
      #+END_SRC
    - ~split~
      #+BEGIN_SRC java
      // The separator is a literal
      String names = "Peter, Paul, Mary";
      String[] result = names.split(", ");
        // An array of three strings ["Peter", "Paul", "Mary"]

      // The separator is a regular expression
      input.split("\\s+");
      #+END_SRC

*** DONE 1.5.3 String Comparison - 25
    CLOSED: [2017-04-24 Mon 02:35]
    - ~equals~

    - ~==~:
      1. Don't use this in most of the time. This returns ~true~ only the lhs
         and rhs are the same object in memory.
      2. To test whether an object is ~null~, DO use ~==~.

    - When comparing a string _against a literal string_,
      it is a GOOD idea to _put the literal string first_:
      #+BEGIN_SRC java
      if (“World”.equals(location)) ///...
      #+END_SRC
      This test works correctly even when location is ~null~.

    - ~equalsIgnoreCase~

    - ~compareTo~ (use Unicode values)
      It returns the difference of Unicode values (can be negative).

    - The strings are compared _a character at a time_,
      until one of them _runs out of_ characters or a _mismatch_ is found.

    - _Tip_:
      When _sorting human-readable strings_,
      use a ~Collator~ object that knows about language-specific sorting rules.
      =TOD0= See Chapter 13 for more information.

*** DONE 1.5.4 Converting Between Numbers and Strings - 27
    CLOSED: [2017-04-24 Mon 14:42]
    - integer -> string. use static methods:
      + ~Integer.toString(n)~ (~\quot\quot + n~ can do the same thing, but it is ugly and
        slightly inefficient).
      + ~Integer.toString(n, radix)~, where the radix should be between 2 and 36.

    - string -> integer. use static methods:
      + ~Integer.parseInt(str);~
      + ~Integer.parseInt(str, radix);~

    - For floating-point numbers, use ~Double.toString~ and ~Double.parseDouble~

*** DONE 1.5.5 The String API - 28
    CLOSED: [2017-04-24 Mon 14:51]
    - Table 1-4
      * group 1
        ~boolean startsWith(String str)~
        ~boolean endsWith(String str)~
        ~boolean contains(CharSequence str)~

      * group 2
        ~int indexOf(String str)~
        ~int lastIndexOf(String str)~
        ~int indexOf(String str, int fromIndex)~
        ~int lastIndexOf(String str, int fromIndex)~

      * group 3
        ~String toUpperCase()~
        ~String toLowerCase()~

      * group 4
        ~String trim()~

    - Java ~String~ class is /immutable/.

    - ~CharSequence~ is a common supertype of
      + ~String~
      + ~StringBuilder~

*** DONE 1.5.6 Code Points and Code Units - 30
    CLOSED: [2017-04-24 Mon 15:20]
    - Nowadays, Unicode requires 21 bits.

    - Each valid Unicode value is called a /code point/.

    - Java suffers from having been born at the time between the transition from
      16 to 21 bits.
      One /code point/ contains one or two /code unit/.

    - Java strings are sequences of /code units/, the 16-bit quantities of the
      UTF-16 encoding.

    - If Chinese ideographs are not in your consideration, /code unit/ and
      /code point/ can be considered as the same thing.
      You can get
      + the ith character as ~char ch = str.charAt(i);~ and
      + the length of a string as ~int length = str.length();~

    - If you want to handle strings properly, you have to work harder.
      + The ith Unicode code point
        ~int codePoint = str.codePointAt(str.offsetByCodePoints(0, i));~
      + The total number of code point
        ~int length = str.codePointCount(0, str.length());~

    - Traverse a string (visit each code point in turn):
      + ~codePoints~ method yields a stream of ~int~ values. =TODO= =cHAPTER 8=

      + _FOR NOW_, just convert it to an array
        ~int[] codePoints = str.codePoints().toArray();~

** 1.6 Input and Output - 32
*** 1.6.1 Reading Input - 32
    - ~System.in~ object only has methods to read individual bytes.

    - To read strings and numbers, construct a ~Scanner~ that is attached to
      ~System.in~:
      =LOCATION= ~Scanner~ calss is located in the ~java.util~ package, which
                 ISN'T imported by default.
      #+BEGIN_SRC java
      Scanner in = new Scanner(System.in);

      // read a line of input.
      String name = in.nextLine();

      // read a word (delimited by whitespace)
      String firstName = in.next();

      // read an integer
      int age = in.nextInt();

      // read an floating-point number
      double height = in.nextDouble();
      #+END_SRC

    - Predicate methods used to check if there is another line, word, integer, or
      floating-point number available.
      + ~hasNextLine~
      + ~hasNext~
      + ~hasNextInt~
      + ~hasNextDouble~

    - _Tip_:
      The input through an ~Scanner~ object is visible. Use ~Console~ object to
      get things like password:
      #+BEGIN_SRC java
      Console terminal = System.console();
      String username = terminal.readLine("User name: ");
      char[] passwd = terminal.readPassword("Password: ");
      #+END_SRC
      The result passwd has a good feature due to its data type:
      ~char[]~ can be overwrite when you are done, while ~String~ (immutable) can
      be.

*** 1.6.2 Formatted Output - 33
    - ~System.out.print(oneArg)~;

    - ~System.out.printf(formatString, ...);~

    - Table 1–5 Conversion Characters for Formatted Output

    - Table 1–6 Flags for Formatted Output

    - static method ~String.format(formatString, ...)~

** 1.7 Control Flow - 36
*** 1.7.1 Branches - 36
    - _Caution_:
      + -Xlint:fallthrough
        With the option ~-Xlint:fallthrough~, the compiler will issue a warning
        message whenever an alternative does not end with a ~break~ or ~return~
        statement.

      + If you acutally want to use the fallthrough behavior, tag the
        surrounding method with the annotation
        ~@SuppressWarnings("fallthrough")~.

    - The values of any of the following types can be used in Java ~switch~:
      + A constant expression of type ~char~, ~byte~, ~short~, or ~int~ (or their
        corresponding wrapper classes ~Character~, ~Byte~, ~Short~, and
        ~Integer~).

      + A string literal.

      + A value of an enumeration.

*** 1.7.2 Loops - 38
*** 1.7.3 Breaking and Continuing - 39
    - If you want to ~break~ to jump to the end of another enclosing statement
      (not the immediate one), use a _labeled_ ~break~ statement.
      Label the statement that should be exited, and provide the label with the
      ~break~ like this:
      #+BEGIN_SRC java
      outer:
      while (...) {
          ...
          while (...) {
            ...
            if (...) break outer;
            ...
          }
          ...
      }
      // Labeled break jumps here
      #+END_SRC
      The label can be any name.

    - _CAUTION_:
      You label the top of the statement, but the break statement jumps to the
      end.

    - A _regular_ ~break~ can only be used to exit a _loop_ or ~switch~
      A _labeled_ ~break~ can transfer control to the end of _any statement_,
      even _a block statement_:
      #+BEGIN_SRC java
      exit: {
          ...
          if (...) break exit;
          ...
      }
      // Labeled break jumps here
      #+END_SRC

    - There is also a _labeled_ ~continue~ statement that jumps to the next
      iteration of a labeled loop.

    - _Tip_
      ~break~ and ~continue~ statems are confusing in some cases.
      _We won't use them in this book._

*** 1.7.4 Local Variable Scope - 41
    - In Java, you cannot have local variables with the same name in overlapping
      scopes.
** 1.8 Arrays and Array Lists - 43
   - Built-in type: ~int[]~, ~String[]~, ...
   - ~ArrayList~ class for arrays that grow and shrink on demand.
   - =TODO=
*** 1.8.1 Working with Arrays - 43
    - Declaration and initialization:
      #+BEGIN_SRC java
      String[] names1 = new String[100];

      // OR
      String[] names2;
      names2 = new String[100];
      #+END_SRC

    - Exception ~ArrayIndexOutOfBoundsException~

    - C style syntax is available, but FEW Java programmers use it.
      ~int numbers[];~
*** 1.8.2 Array Construction - 44
    - When you construct an array with the ~new~ operator, it is
      _filled with a default value_.
      + Arrays of _numeric_ type
        (including ~char~, and _NOT_ including ~BigInteger~ whose instance is an
        object) are filled with _zeroes_.

      + Arrays of _boolean_ are filled with ~false~.

      + Arrays of _objects_ are filled with ~null~ references.

    - Another way to declare and initialize an array simutaneously:
      ~int[] primes = { 2, 3, 5, 7, 11, 13 };~

    - Assignment:
      ~primes = new int[] { 17 ,19, 23, 29, 31 };~

    - _Note_:
      0 length array: ~int[0]~ or ~new int[] {}~

*** 1.8.3 Array Lists - 45
    - ~ArrayList~ class is in the ~java.util~ package.

    - An ~ArrayList~ object manages an array internally:
        When that array becomes too small or is insufficiently utilized, another
      internal array is automatically created, and the elements are moved into
      it.
        This process is invisible to the programmer using the array list.

    - Array lists are classes, and you use the normal syntax for constructing
      instances and invoking methods.

    - ~ArrayList~ class is a /generic class/.

    - Declaration:
      ~ArrayList<String> friends;~

      Initialization or assignment:
      ~friends = new ArrayList<>();~
      ~friends = new ArrayList<String>();~

    - empty ~<>~ is called /diamond syntax/.

    - Add elements to the end:
      ~friends.add("Peter");~

    - Add elements _before_ the given index:
      ~friends.add(0, "Peter");~

    - Unfortunately, there is _NO_ initializer syntax for array lists.

    - Remove elements:
      ~friends.remove(1);~

    - Use method calls to access elements, _NOT_ the ~[]~ syntax.
      #+BEGIN_SRC java
      String first = friends.get(0);
      friends.set(1, "Mary");
      #+END_SRC

    - ~size~ method of the array lists.
      =COMMENT= ~length~ is a property/field, _NOT_ a method.

*** 1.8.4 Wrapper Classes for Primitive Types - 46
    - Java generic classes can't use /primitive types/ as type parameters.
      The remedy is to use /wrapper class/:
      + ~Integer~
      + ~Byte~
      + ~Short~
      + ~Long~
      + ~Character~
      + ~Float~
      + ~Double~
      + ~Boolean~

    - xxx

    - Conversion between primitive types and their corresponding wrapper types is
      _automatic_.

    - /autoboxing/, /unbox/
      #+BEGIN_SRC java
      ArrayList<Integer> numbers = new ArrayList<>();

      // autoboxing
      numbers.add(42);

      // (auto) unbox
      int first = numbers.get(0);
      #+END_SRC

    - ~==~ and ~!=~ compare object references, _NOT_ the contents of objects.
      Thus, remember to use ~equals~ method.
      For example,
      ~numbers.get(i) == numbers.get(j)~ doesn't NOT test whether the numbers at
      index =i= and =j= are the same. Should use ~equals~.

*** 1.8.5 The Enhanced ~for~ Loop - 47
    - C style ~for~ loop

    - /enhanced/ ~for~ loop:
      #+BEGIN_SRC java
      int sum = 0;

      // Here `numbers` can be array or array list
      for (int n: numbers) {
          sum += n;
      }
      #+END_SRC

*** 1.8.6 Copying Arrays and Array Lists - 47
    - For an /array/, use static method of copy ~Arrays.copyOf~:
      ~int[] copiedPrimes = Arrays.copyOf(primes, primes.length);~

    - For an /array list/:
      #+BEGIN_SRC java
      // Here `friends` is an array list
      ArrayList<String> copiedFriends = new ArrayList<>(friends);

      // Here `names` is an array
      String[] names = ...;
      ArrayList<String> friends = new ArrayList<>(Arrays.asList(names));
      ArrayList<String> friends = new ArrayList<>(Arrays.asList("Peter", "Paul",
                                                                "Mary"));
      #+END_SRC

    - Copy an array list into an array:
      ~String[] names = friends.toArray(new String[0]);~
      You _MUST_ supply an array of the correct type.

    - _NOTE_:
      There is _NO easy way_ to convert between
      primitive type arrays and the corresponding array lists of wrapper classes.
        For example, to convert between an ~int[]~ and an ~ArrayList<Integer>~,
      you need an _explicit loop_ or an ~IntStream~ (see Chapter 8). =TODO=

*** 1.8.7 Array Algorithms - 49
    - /array/ realted:
      ~Arrays.fill(numbers, 0); // int[] array~
      ~Array.sort(names);~
      ~Array.toString(primes);~

    - (for array) ~parallelSort~ method that distributes the work over multiple
      processors if the array is large.

    - Fill an array list:
      ~Collections.fill(friends, ""); // ArrayList<String>~
      ~Collections.sort(friends);~
      ~friends.toString();~

      _NO_ counterpart for arrays.
      ~Collections.reverse(friends);~
      ~Collections.shuffle(friends);~

    -
*** 1.8.8 Command-Line Arguments - 49
    - Example: ~java Greeting -g cruel world~
      Here,
      + ~args[0]~ is "-g"
      + ~args[1]~ is "cruel"
      + ~args[2]~ is "world"

*** 1.8.9 Multidimensional Arrays - 50
    - No true multidimensional arrays in Java, only arrays of arrays.
      #+BEGIN_SRC java
      int[][] square = {
          { 16, 3, 2, 13 },
          { 5, 10, 11, 8 },
          { 9, 6, 7, 12 },
          { 4, 15, 14, 1 }
      };
      #+END_SRC

    - There is _no requirement_ that the row arrays have equal length.
      ~int[][] triangleOfPascal = new int[n][];~

    - _Tip_:
      To print out a list of the elements of a two-dimensional array for
      debugging, call
      ~System.out.println(Arrays.deepToString(triangle));~

    - _Note_:
      _NO_ 2D array list,
      _BUT_
      1. you can delcare a variable of type ~ArrayList<ArrayList<Integer>>~
      2. build up the rows youself. ==

** 1.9 Functional Decomposition - 52
*** 1.9.1 Declaring and Calling Static Methods - 53
    #+BEGIN_SRC java
    class AverageOfTwoNumbers {
        public static double average(double x, double y) {
            double sum = x + y;
            return sum / 2;
        }

        public static void main(String[] args) {
            double a = 3.0;
            double b = 5.0;
            double result = average(a, b);
            // ...
        }
    }
    #+END_SRC

*** 1.9.2 Array Parameters and Return Values - 53
    #+BEGIN_SRC java
    class XXX {
        // in place change
        public static void swap(int[] values, int i, int j) {
            int temp = values[i];
            values[i] = values[j]
            values[j] = temp;
        }

        // return an array (This is different from C, who can only use indirect
        // way (a pointer to an array) to return an array.)
        public static void swap(int[] values, int i, int j) {
            int temp = values[i];
            values[i] = values[j]
            values[j] = temp;
        }
    }
    #+END_SRC

*** 1.9.3 Variable Arguments - 53
    - Declare a "varargs" parameter with ~...~ after the type:
      ~public static double average(double... values)~

        When the method is called, an array is created and filled with the argu-
      ments.
      _In the method body, you use it as you would any other array._

    - You can also pass an array directly as the "varargs" parameter, and this
      array is the "varargs" parameter it self, not the first element.

    - The variable parameter must be the last parameter of the method.
      =From Jian= This implies that only one variable parameter cant exist.

** Exercises - 54

* DONE 2. OBJECT-ORIENTED PROGRAMMING - 59
  CLOSED: [2017-06-06 Tue 21:12]
  The key points of this chapter are:
  1. _Mutator_ methods change the state of an object;
     _accessor_ methods don't.

  2. In Java, variables don't hold objects; they hold _references_ to objects.

  3. Instance variables and method implementations are declared inside the class
     declaration.

  4. An instance method is invoked on an object, which is accessible through the
     this reference.

  5. A constructor has the _SAME name as the class_. A class can have multiple
     (overloaded) constructors.

  6. Static variables DON'T belong to any objects.
     Static methods are NOT invoked on objects.

  7. Classes are organized into /packages/.
     Use ~import~ declarations so that you don't have to use the package name in
     your programs.

  8. Classes can be _nested_ in other classes.

  9. An /inner class/ is a _nonstatic_ nested class.
       Its instances have a reference to the object of the enclosing class that
     constructed it.

  10. The ~javadoc~ utility processes source files, producing HTML files with de-
      clarations and programmer-supplied comments.

** DONE 2.1 Working with Objects - 60
   CLOSED: [2017-05-05 Fri 23:38]
   - ~LocalDate date = LocalDate.of(year, month, 1);~

   - ~date.plusDays(1);~ returns a newly constructed ~LocalDate~ object.

   - ~data.getMonthValue();~, ~data.getDayOfMonth();~

   - ~DayOfWeek weekday = date.getDayOfWeek();~

   - ~weekday.getValue();  // it returns an integer~
     1 for Monday, ..., and 7 for Sunday.

*** 2.1.1 Accessor and Mutator Methods - 62
    - /mutator/ and /accessor/

    - all methods of the ~LocalDate~ class are /accessors/.

*** 2.1.2 Object References - 63
    - In Java, a variable can ONLY hold a _reference_ to an object.

    - _Note_: =TODO= =???=

    - Be aware that it is possible to mutate a shared object through any of its
      references.
        However, if a class has no mutator methods (such as ~String~ or
      ~LocalDate~), you don't have to worry.

    - It is possible for an object variable to _refer to NO object_ at all, by
      setting it to the special value ~null~.

    - _Caution_
      Invoke a method on ~null~ causes a ~NullPointerException~ (which should
      really have been called a ~NullReferenceException~).

      For optional values, use ~Optional~ type.

** DONE 2.2 Implementing Classes - 65
   CLOSED: [2017-05-06 Sat 10:01]
*** 2.2.1 Instance Variables - 65
    - ~private~ variables: only methods of the same class can access them.
*** 2.2.2 Method Headers - 65
    - ~private~ methods: only the other methods of the same class can access them
*** 2.2.3 Method Bodies - 66
*** 2.2.4 Instance Method Invocations - 66
*** 2.2.5 The ~this~ Reference - 67
    - _Note_: =TODO=
      In some programming languages, instance variables are decorated in some
      way, for example ~\under{}name~ and ~\under{}salary~. This is legal in Java but is not
      commonly done.

    - _Note_:
      You CAN even declare ~this~ as a parameter of a method (but
      NOT a /constructor/)
      #+BEGIN_SRC java
      public void setSalary(Employee this, double salary) {
          this.salary = salary;
      }
      #+END_SRC
      =TODO= However, this syntax is very rarely used. It exists so that you can
      annotate the receiver of the method -- _See Chapter 11_. =TODO=

*** 2.2.6 Call by Value - 68
** DONE 2.3 Object Construction - 69
   CLOSED: [2017-05-07 Sun 00:39]
*** 2.3.1 Implementing Constructors - 69
    - Declaring a constructor is similar to declaring a method.
      Same name as the class name.
      No return type.

    - ~public~ constructor
      #+BEGIN_SRC java
      public class Empoyee {
          public Employee(String name, double salary) {
              this.name = name;
              this.salary = salary;
          }

          // ...
      }
      #+END_SRC

    - ~private~ constructor: some methods call a private constructor.

    - If you accidentally specify a return type, then you declare a method.

    - The ~new~ operator returns a reference to the constructed object.
      You will normally
      + save that reference in a variable.
      + pass it to a method.

*** 2.3.2 Overloading - 70
    There can be more than one version of a constructor.

*** 2.3.3 Calling One Constructor from Another - 71
    #+BEGIN_SRC java
    public class Empoyee {
        public Employee(String name, double salary) {
            this.name = name;
            this.salary = salary;
        }

        public Employee(double salary) {
            this("", salary);
            // Other statements
        }
    }
    #+END_SRC
    Here, ~this~ is _NOT a reference to the object_ that is being constructed.
    Instead, it is a _special syntax_ that is only used for invoking another
    constructor of the same class.

*** 2.3.4 Default Initialization - 71
    - If you don't set an instance variable explicitly in a constructor, it is
      automatically set to a _default value_:
      + numbers to ~0~
      + boolean values to ~false~
      + object references to ~null~

      For example,
      #+BEGIN_SRC java
      public class Employee {
          public Employee(String name) {
              // salary automatically set to zero
              this.name = name;
          }

          // ...
      }
      #+END_SRC

    - _Note_:
      In this regards,
      /instance variables/ are very different from /local variables/
      /local variables/ _MUST_ always be explicitly initialized.

    - This is not a good feature for object. It is the source of null pointer
      exception.

      For example, you have a constructor:
      #+BEGIN_SRC java
      public Employee(double salary) {
          // name automatically set to null
          this.salary = salary;
      }
      #+END_SRC
      When you call ~e.getName()~ (here ~e~ is an instance of ~Employee~), a null
      pointer exception will be raised.
      _SOLUTION_: The example of section 2.3.3

*** 2.3.5 Instance Variable Initialization - 72
    - This initialization occurs
      + _AFTER_ the object has been allocated
      + _BEFORE_ a constructor runs.
      #+BEGIN_SRC java
      public class Employee {
          private String name = "";
          // ...
      }
      #+END_SRC

    - /initialization blocks/
      #+BEGIN_SRC java
      public class Employee() {
          private String name = "";
          private int id;
          private double salary;

          { // An initialization block
              Random generator = new Random();
              id = 1 + generator.nextInt(1_000_000);
          }

          public Employee(String name, double salary) {
              // ...
          }
      }
      #+END_SRC
      This is _NOT_ a commonly used feature. Most programmers place lengthy
      initialization code into a helper method and invoke that method from the
      constructors.

    - /Instance variable initializations/ and /initialization blocks/ are execut-
      ed
      + _in the order in which they appear_ in the class declaration
      + _BEFORE_ the body of the constructor.

*** 2.3.6 Final Instance Variables - 73
    A ~final~ can't change the object it reference, though it can change the
    content of the object it points to.

*** 2.3.7 The Constructor with No Arguments - 73
    - _Note_:
      If a class already has a constructor,
      it does NOT automatically get another constructor with no arguments.

      If you supply a constructor and also want a no-argument constructor,
      you have to write it yourself.

    - Due to the existence of garbage collector,
      Java has NO mechanism for "finalizing" an object when you don't need it
      (C++ has NO GC, and it requires this mechanism).

** DONE 2.4 Static Variables and Methods - 74
   CLOSED: [2017-05-07 Sun 02:10]
*** DONE 2.4.1 Static Variables - 74
    CLOSED: [2017-05-07 Sun 01:24]
    - A ~static~ variable means there is only one such variable per class.

    - A better name for the ~static~ variables should be /class variables/,
      though this is rarely used.

      Use ~static~ is a historical issue:
      + ~static~ of Java comes from C++
      + ~static~ of C++ comes from _an UNRELATED use_ in C

    - For example:
      #+BEGIN_SRC java
      public class Employee {
          private static int lastId = 0;
          private int id;

          public Employee() {
              lastId++;
              id = lastId;
          }
      }
      #+END_SRC

      =CAUTION= The class above doesn't work is its objects are constructed
      concurrently in multiple threads.
      _remedy this_: Chapter 10 =TODO=

*** DONE 2.4.2 Static Constants - 75
    CLOSED: [2017-05-07 Sun 01:41]
    - _Mutable_ static variables are rare (but we have an example in the last
      section).
      statc constants (~static final~ variables) are quite common.

    - For example:
      #+BEGIN_SRC java
      public class Math {
          // ...
          public static final double PI = 3.14159265358979323846;
          // ...
      }
      #+END_SRC
      With this ~static~ keyword, you use ~Math~ class rather than its instance
      to access ~PI~.

    - Another thing you may want to share and can be ~final~ is a random number
      generator:
      + You don't want to waste resource to create one generator for each
        instance.
      + For the same reason, ~final~ is used to prevent the reference changing.

    - _Caution_ =TODO=
      Even though ~out~ is declared as ~final~ in the ~System~ class,
      there is a method ~setOut~ that sets ~System.out~ to a different stream.
      This method is a "native" method, _not implemented in Java_, which can
      bypass the access control mechanisms of the Java language.

      This is a very unusual situation from the early days of Java, and not
      something you are likely to encounter elsewhere.

*** DONE 2.4.3 Static Initialization Blocks - 76
    CLOSED: [2017-05-07 Sun 01:24]
    #+BEGIN_SRC java
    public class CreditCardForm {
        private static final ArrayList<Integer> expirationYear = new ArrayList<>();
        static {
            // Add the next twenty years to the array list
            int year = LocalDate.now().getYear();
            for (int i = year; i <= year + 20; i++) {
                expirationYear.add(i);
            }
        }
        // ...
    }
    #+END_SRC

    - Static initialization occurs when the class is first loaded.

    - Like instance variables, static variables are ~0~, ~false~, or ~null~
      unless you explicitly set them to another value.

    - All /static variable initializations/ and /static initialization blocks/
      are executed _in the order in which they occur_ in the class declaration.

*** DONE 2.4.4 Static Methods - 77
    CLOSED: [2017-05-07 Sun 02:01]
    - It is legal to invoke a static method on an object,
      but most java programmers would consider this poor style.

    - Since static methods DON'T operate on objects,
      + you _CANNOT_ access instance variables from a /static method/.

      However, /static methods/ can access the /static variables/ in their class.

*** DONE 2.4.5 Factory Methods - 78
    CLOSED: [2017-05-07 Sun 02:10]
    - A common use for static methods is a factory method.

    - /factory method/: a static method that returns new instances of the class.

    - For example,
      #+BEGIN_SRC java
      NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
      NumberFormat percentFormatter = NumberFormat.getPercentInstance();
      double x = 0.1;
      System.out.println(currencyFormatter.format(x)); // Prints $0.10
      System.out.println(percentFormatter.format(x)); // Prints 10%
      #+END_SRC

    - Q: Why not use a constructor instead?
      A: The ONLY way to distinguish two constructors is by their parameter
         types. You cannot have two constructors with no arguments.

    - _Moreover_
      + A /constructor/ ~new NumberFormat(...)~ yields a ~NumberFormat~.
      + A /factory method/ can return an object of a _subclass_.
        In fact, these /factory methods/ return _instances of_ the
        ~DecimalFormat~ class.

    - A factory method can also return a /shared object/, instead of
      unnecessarily constructing new ones.
        For example, the call ~Collections.emptyList()~ returns a shared
      immutable empty list.

** DONE 2.5 Packages - 78
   CLOSED: [2017-05-08 Mon 15:09]
*** 2.5.1 Package Declarations - 79
    - A package name: a dot-separated list of identifiers (e.g.
      ~java.util.regex~).

    - To guarantee unique package names, it is a good idea to use an Internet
      domain name (which is known to be unique) written in reverse.
        A major exception to this rule is the standard Java library whose package
      names start with ~java~ or ~javax~.

    - _Note_:
      _In Java, packages do not nest._
      For example, ~java.util~ and ~java.util.regex~ have nothing to do with each
      other.

    - Put a class into a package:
      #+BEGIN_SRC java
      package com.horstmann.corejava;

      public class Employee {
          // ...
      }
      #+END_SRC
      Then, ~Empolyee~ can be use with /fully qualified name/
      ~com.horstmann.corejava.Employee~

    - /default package/: if no package is specified, your program is put into the
      /default package/. This use is not recommended.

    - When class files are read from a file system, the path name needs to match
      the package name.

      For example, if the right /fully qualified name/ is
      ~com.horstmann.corejava.Employee~, the file ~Employee.class~ must be in a
      subdirectory ~com/horstmann/corejava~.

    - If
      + you arrange the source files in the same way as their package structure
        and
      + compile from the directory that contains the initial package names, then
        the class files are automatically put in the correct place.

      For example,
      Suppose the ~EmployeeDemo~ class makes use of ~Employee~ objects, and you
      compile it as
      #+BEGIN_SRC bash
      javac com/horstmann/corejava/EmployeeDemo.java
      #+END_SRC
      The compiler generates class files
      + ~com/horstmann/corejava/EmployeeDemo.class~
      + ~com/horstmann/corejava/Employee.class~.

      You run the program by specifying the fully qualified class name:
      #+BEGIN_SRC bash
      java com.horstmann.corejava.EmployeeDemo
      #+END_SRC

    - _Caution_:
      If a source file is not in a subdirectory that matches its package name,
      the ~javac~ compiler will _NOT_ complain and generate a class file,
      BUT you will need to put it in the right place.
      =TODO= This can be quite confusing -- see Exercise 12.

    - _Tip_: =TODO= =Try=
      It is a good idea to run ~javac~ with the ~-d~ option.
      Then the class files are generated in a separate directory, without
      cluttering up the source tree, and they have the correct subdirectory
      structure.

*** 2.5.2 The =jar= Command - 80
*** 2.5.3 The Class Path - 81
    - Place class files into a JAR files, rather than scattering and storing them
      in the file system.

    - ~jar~ utility is a part of the JDK.
      It command-line options are similar to those of the Unix ~tar~ program.
      For example, ~jar cvf library.jar com/mycompany/*.class~

    - _Note_:
      JAR files can actually be in two formats:
      + ZIP format (default)
      + "pack200", which is designed to compress class files more efficient.

    - ~jar~ is commonly used with package libraries, but
      it can also package a program. For example,
      #+BEGIN_SRC bash
      jar cvfe program.jar com.mycompany.MainClass com/mycompany/*.class

      # run it
      java -jar program.jar
      #+END_SRC

    - /class path/: A class path can contain
      + Directories containing class files (in subdirectories that match their
        package names)
      + JAR files
      + Directories containing JAR files

    - When you use library JAR files in a project, you need to tell the compiler
      and the virtual machine where these files are by specifying the
      /class path/.

    - The ~javac~ and ~java~ programs have an option ~-classpath~, which you can
      abbreviate to ~-cp~. For example
      #+BEGIN_SRC bash
      java -classpath .:../libs/lib1.jar:../libs/lib2.jar com.mycompany.MainClass
      #+END_SRC

    - Use wildcard to specify many JAR files in a directory:
      #+BEGIN_SRC bash
      java -cp .:../libs/\* com.mycompany.MainClass
      # Here * is escaped.
      # If no backslash here, Unix shell will intercept it, use it, and no
      # wildcard will be passed to `java` command.
      #+END_SRC

    - ~javac~ always looks for files in the current directory.

      ~java~ ONLY looks into the current directory when ~.~ is explicitly given
      through /class path/.

    - ~CLASSPATH~ enviroment variable.
      The details depend on your shell.
      #+BEGIN_SRC bash
      export CLASSPATH=.:/home/username/project/libs/\*
      #+END_SRC

      #+BEGIN_SRC powershell
      SET CLASSPATH=.;C:\Users\/username\project\libs\*
      #+END_SRC

    - _Caution_: This is truly bad advice!!!
      Some people suggests put all JAR files into the ~jre/lib/ext~ directory.

      + Code that manually loads classes does not work correctly when placed in
        the extension directory.

      + Foroget there are libraries in the ~jre/lib/ext~ directory.

*** 2.5.4 Package Access - 83
    - If you don't specify either ~public~ or ~private~, the feature (that is,
      the /class/, /method/, or /variable/)
      _can be accessed by all methods in the SAME package._

    - _Note_: One package can contain multiple classes.
      1. At most one can be a ~public~ class.
      2. If this /public class/ does exist, the name of the source file must
         match the /public class/ name.

    - ~ClassLoader~ =TODO= =???=

    - The Java implementors protect themselves from such an attack by rigging the
      ~ClassLoader~ class so it will NOT load any class whose fully qualified name
      starts with ~java~. =TODO= =???=

    - /manifest/: a plain text file containing entries
      #+BEGIN_SRC txt
      Name: com/mycompany/util/
      Sealed: true
      Name: com/mycompany/misc/
      Sealed: true
      #+END_SRC

    - /sealed JAR/: provide a /manifest/ and run the ~jar~ command like this:
      ~jar cvfm library.jar manifest.txt com/mycompany/*/*.class~

*** 2.5.5 Importing Classes - 83
    - Import all classes from a package with a wildcard:
      ~import java.util.*;~

    - Wildcard can only import classes, not packages.
      You can't do ~import java.*;~

    - Compiler will complains when there are name conflictions when use ~import~.
      For example,
      #+BEGIN_SRC java
      import java.util.*;
      import java.sql.*;
      // They both have `Date` class
      #+END_SRC

      You can import the specific class that you want to solve this:
      #+BEGIN_SRC java
      import java.util.*;
      import java.sql.*;
      import java.sql.Date;
      #+END_SRC

    - Inside .class files, all class names are fully qualified.
      This means the quanlifiers are added when compile.

    - ~import~ is like the ~using~ in C++ (imports do NOT cause files to be
      recompiled).

      It doesn't like the ~#include~ in C,

*** 2.5.6 Static Imports - 85
    - Only _import_ /static methods and variables/:
      + All: ~import static java.lang.Math.*;~
      + A specific: ~import static java.lang.Math.PI;~

    - _Note_: ~java.util.Comparator~ and ~java.util.strea.Collections~ have
      a lot of static things.

    - _Caution_:
      You CANNOT import static methods of fields from a class in the default
      package.

** TODO 2.6 Nested Classes - 85
   - /nested class/: a /class/ _inside_ another /class/.

   - WHY Useful:
     + restrict visibility

     + avoid cluttering up a package with generic names such as =Element=,
       =Node=, or =Item=.

   - Java has _TWO_ kinds of nested classes, with somewhat different behavior.
     =TODO= =???=

*** DONE 2.6.1 Static Nested Classes - 85
    CLOSED: [2018-01-15 Mon 23:07]
    - *private* static /nested class/
      #+BEGIN_SRC java
        public class Invoice {
            // See next section for the reason of `static` here
            private static class Item { // `Item` is nested inside `Invoice`
                String description;
                int quantity;
                double unitPrice;
                double price() { return quantity * unitPrice; }
            }
            private ArrayList<Item> items = new ArrayList<>();
            // ...
        }
      #+END_SRC

      + Here ~Item~ is private for ~Invoice~, so only ~Invoice~ methods can
        access it. For that reason, no need to make the instance variables of
        the /inner class/ private.

      + An example of a method that constructs an object of the /inner class/:
        =FROM JIAN= You cannot add an ~Item~ -- it is a ~private class~, its
        /constructor/ cannot be used outside this class.
        #+BEGIN_SRC java
          public class Invoice {
              // ...
              public void addItem(String description, int quantity,
                                  double unitPrice) {
                  Item newItem = new Item();
                  newItem.description = description;
                  newItem.quantity = quantity;
                  newItem.unitPrice = unitPrice;
                  items.add(newItem);
              }
          }
        #+END_SRC

    - *public* static /nested class/
      In this case, one would want to use the usual encapsulation mechanism --
      make the instance variables *private*.
      #+BEGIN_SRC java
        public class Invoice {
            public static class Item { // A public nested class
                private String description;
                private int quantity;
                private double unitPrice;
                public Item(String description, int quantity, double unitPrice) {
                    this.description = description;
                    this.quantity = quantity;
                    this.unitPrice = unitPrice;
                }
                public double price() { return quantity * unitPrice; }
                // ...
            }

            private ArrayList<Item> items = new ArrayList<>();

            // This method cannot be defined and used as a public method when the
            // `Item` class is private -- outside class cannot use its
            // constructor.
            public void add(Item item) { items.add(item); }
            // ...
        }
      #+END_SRC
      + In this case, anyone can construct ~Item~ objects by using the
        qualified name ~Invoice.Item~.

      + There is _essentially NO DIFFERENCE_ between this ~Invoice.Item~ class
        and a class ~InvoiceItem~ declared outside any other class.

        =From Jian= It is meaningful in semantics!!!
          _Nesting the class_ just makes it obvious that *the ~Item~ class
        represents items in an ~Invoice~.*

*** TODO 2.6.2 Inner Classes - 87
    - /inner classes/: non-static nested classes.

    - Example:
      A social network in which each member has friends that are also members.
      #+BEGIN_SRC java
        public class Network {
            public class Member { // Member is an inner class of Network
                private String name;
                private ArrayList<Member> friends;
                public Member(String name) {
                    this.name = name;
                    friends = new ArrayList<>();
                }

                // ...
            }
            private ArrayList<Member> members;
            // ...
        }
      #+END_SRC

      + With the ~static~ modifier dropped, a ~Member~ object knows to which
        network it blongs

      + Define a method to add a member
        #+BEGIN_SRC java
          public class Network {
              // ...
              public Member enroll(String name) {
                  Member newMember = new Member(name);
                  members.add(newMember);
                  return newMember;
              }
          }
        #+END_SRC

      + When add a member, you can get a reference to it.
        #+BEGIN_SRC java
        Network myFace = new Network();
        Network.Member fred = myFace.enroll("Fred");
        #+END_SRC

      + Define a method to leave a network.
        #+BEGIN_SRC java
          public class Network {
              public class Member {
                  // ...
                      public void leave() {
                      members.remove(this);
                      // The inner class is accessing the instance variables of
                      // the outer class object that created it.
                  }
              }
              private ArrayList<Member> members;
              // ...
          }

          fred.leave();
        #+END_SRC

        The inner class is accessing the instance variables of the outer class
        object that created it.

      + The inner class can also invoke methods of the outer class through its
        outer class instance.

        Define a method to unenroll a member.
        #+BEGIN_SRC java
          public class Network {
              public class Member {
                  // ...
                  public void leave() {
                      unenroll(this);
                  }
              }

              private ArrayList<Member> members;

              public Member enroll(String name) { // ... }
              public void unenroll(Member m) { // ... }
              // ...
          }
        #+END_SRC
        ~unenroll(this);~ in this case is actually means
        ~outer.unenroll(this);~ (not a legal syntax, just illustration).

*** TODO 2.6.3 Special Syntax Rules for Inner Classes - 89
    - ~OuterClass.this~ denotes the outer class reference.

    - For example,
      #+BEGIN_SRC java
      public void leave() {
          Network.this.members.remove(this);
      }
      #+END_SRC
      Here, the ~Network.this~ is redundant.

    - Sometimes you may need the outer class reference explicitly:
      #+BEGIN_SRC java
      public class Network {
          public class Member {
              // ...
              public boolean belongsTo(Network n) {
                  return Network.this == n;
              }
          }
      }
      #+END_SRC

    - When you construct an inner class object, it remembers the enclosing class
      object that constructed it. In the preceding section, a new member was
      created by this method:
      #+BEGIN_SRC java
      public class Network {
          // ...
          Member enroll(String name) {
              Member newMember = new Member(name);
              // That is a shortcut for
              // Member newMember = this.new Member(name);

              // ...
          }
      }
      #+END_SRC

    - You can invoke an inner class constructor on any instance of an outer class:
      ~Network.Member wilma = myFace.new Member("Wilma");~

    - _NOTE_: =TODO=
      _Inner classes CANNOT declare static members other than compile-time constants._

      An ambiguity about the meaning of _static_.
      1. Does it mean there is only one instance in the virtual machine?
         Or
      2. only one instance per outer object?

      _The language designers decided not to tackle this issue._

    - _NOTE_: =TODO=
      By historical accident, inner classes were added to the Java language at a
      time when the virtual machine specification was considered complete, so
      they are translated into regular classes with a hidden instance variable
      referring to the enclosing instance.
      =TODO=
      _Exercise 14 invites you to explore this translation_

    - _NOTE_: =TODO=
      /Local classes/ are another variant of inner classes that we will discuss
      in Chapter 3.

** DONE 2.7 Documentation Comments - 90
   CLOSED: [2017-05-12 Fri 15:55]
   - ~javadoc~: a tool from JDK used to generates HTML documentation from your
     source files.

   - The online AP documentation is simply the result of running ~javadoc~ on
     the source code of the standard Java library.

   - ~javadoc~ realted comments start with the special delimiter ~/**~.

*** 2.7.1 Comment Insertion - 90
    - The ~javadoc~ utility extracts information for the following items:
      + Packages
      + Public classes and interfaces
      + Public and protected variables
      + Public and protected constructors and methods
      =TODO= See Chapter 4 for /protected features/

    - Comment starts with ~/**~ and ends with ~*/~.
      This kind of comment contains free-form text followed by /tags/.

    - /tag/: text starts with an =@=, such as =@author= or =@param=

    - _The first sentence of the free-form text should be a summary statement._

      The ~javadoc~ utility automatically generates summary pages that extract
      these sentences.

    - Use the HTML tag in the free form text is OK.

      Stay away from heading ~<h1>~, ~<h2>~, ..., ~<hn>~ or rules ~<hr>~, which
      can interfere with the formatting of the documentation.

    - _NOTE_:
      If your comments contain links to other files such as images (for example,
      diagrams or images of user interface components), place those files into a
      subdirectory of the directory containing the source file, named =doc-files=.
      The ~javadoc~ utility will copy the =doc-files= directories and their contents
      from the source directory to the documentation directory. You need to
      specify the =doc-files= directory in your link, for example
      ~<img src="doc-files/uml.png" alt="UML diagram"/>~.

*** 2.7.2 Class Comments - 91
    - The class comment _MUST_ be placed directly _before_ the class declaration.

    - Exmaple:
      #+BEGIN_SRC java
      /**
       * An <code>Invoice</code> object represents an invoice with
       * line items for each part of the order.
       * @author Fred Flintstone
       * @author Barney Rubble
       * @version 1.1
       */
      public class Invoice {
          // ...
      }
      #+END_SRC

    - _NOTE_:
      There is NO need to put a * in front of every line. However, most IDEs
      supply the asterisks automatically, and some even rearrange them when the
      line breaks change.

*** 2.7.3 Method Comments - 92
    - Place each method comment immediately before its method.
      Document the following features:
      + Each parameter, with a comment =@param= /variable description/.

      + The return value, if not ~void~: =@return= /description/.

      + Any thrown exceptions (See Chapter 5): =@throws=
        /exceptionClass description/.

    - Example:
      #+BEGIN_SRC java
      /** Raises the salary of an employee.
       * @param byPercent the percentage by which to raise the salary (e.g., 10 means 10%)
       * @return the amount of the raise
       */
      public double raiseSalary(double byPercent) {
          double raise = salary * byPercent / 100;
          salary += raise;
          return raise;
      }
      #+END_SRC

*** 2.7.4 Variable Comments - 92
    - You only need to document public variables -- generally that means
      /static constants/. For example,
      #+BEGIN_SRC java
      /**
       * The number of days per year on Earth (excepting leap years)
       */
      public static final int DAYS_PER_YEAR = 365;
      #+END_SRC
*** 2.7.5 General Comments - 92
    - =@since=: describe the version in which this feature became available.
      ~@since version 1.7.1~

    - =@deprecated=: describe deprecated features, and suggest a replacement.
      For example,
      ~@deprecated Use <code>setVisible(true)</code> instead~

    - _NOTE_:
      There is also a ~@Deprecated~ annotation that compilers use to issue
      warnings when deprecated itmes are used. =TODO= See Chapter 11.

      The annotation does not have a mechanism for suggesting a replacement,
      so you _should supply both the annotation and the Javadoc comment for
      deprecated items_.

*** 2.7.6 Links - 93
    - Add hyperlinks or external documents with =@see= and =@link= tags.

    - =@see=:
      + package.class#feature label
        For example:
        ~@see com.horstmann.corejava.Employee#raiseSalary(double)~

        If omit the the package name, or both the package and class name, the
        feature will be located in the current package or class.

      + <a href="...">label</a>
        If =@see= is followed by a =<= character, you're specifying a hyperlink.
        For example，
        ~@see <a href="http://en.wikipedia.org/wiki/Leap_year">Leap years</a>~

      + "text"
        If the =@see= tag is followed by a ~"~ character, the text in quotes is
        displayed _in the "see also" section_. For example:
        ~@see "Core Java for the Impatient"~

        =comment= Multiple =@see= tags can be added for one feature, but they
                  must be put together.

    - =@link=:
      hyperlinks to other classes or methods anywhere in any of your
      documentation comments. Insert a tag of the form
      ~{@link package.class#feature label}~ anywhere in a comment.
      The feature description follows the same rules as for the =@see= tag.

*** 2.7.7 Package, Module, and Overview Comments - 94
    - To generate package comments, a separate file in each package directory
      should be added.

      Supply a Java file named =package-info.java=. The file must contain:
      + an initial javadoc comment, delimited with ~/**~ and ~*/~
      + followed by a package statement.

      _REQUIREMENT:_ NO further code or comments.

    - An /overview comment/ for all source files:
      + requirement:
        * name: =overview.html=
        * location: the parent directory that contains all the source files.

      + All text between the tags =<body>= and =</body>= is extracted.
        This comment is displayed when the user select "Overview" from the
        navigation bar.

*** 2.7.8 Comment Extraction - 94
    - Suppose =docDirectory= is where you want the HTML files to go.
      For these steps:
      1. go to the directory the same as that of =overview.html=, if you supplied
         one.
      2. ~javadoc -d docDirectory package1 package2 ...~
         If without ~-d docDirectory~ the HTML files are extracted to the current
         directory. That can get messy, not recommended.

    - Use ~-author~ and ~-version~ options to include the =@author= and
      =@version= tagsin the documentation (they are by default omitted).

    - Use ~-link~  option to include hyperlinks to standard classes. For example,
      run ~javadoc -link http://docs.oracle.com/javase/8/docs/api *.java~, and
      all standard library classes are automatically linked ot the documentation
      on the Oracle web site.

    - Use ~-linksource~ option, each source file is converted to HTML, and each
      class and method name turns into a hyperlink to the source.

** TODO Exercises - 95

* TODO 3. INTERFACES AND LAMBDA EXPRESSIONS - 99
  The key points of this chapter are:
  - An interface specifies a set of methods that an implementing class must
    provide.

  - An interface is a supertype of any class that implements it. Therefore, one
    can assign instances of the class to variables of the interface type.

  - An interface can contain /static methods/.
    All variables of an interface are automatically /static/ and /final/.

  - An interface can contain default methods that an implementing class can
    inherit or override.

  - The ~Comparable~ and ~Comparator~ interfaces are used for comparing objects.

  - A lambda expression denotes a block of code that can be executed at a later
    point in time.

  - Lambda expressions are converted to functional interfaces.

  - Method and constructor references refer to methods or constructors without
    invoking them.

  - Lambda expressions and local inner classes can access effectively final
    variables from the enclosing scope

** DONE 3.1 Interfaces - 100
   CLOSED: [2017-05-11 Thu 15:07]
   An /interface/ is a mechanism for spelling out a contract between two parties:
   the supplier of a service and the classes that want their objects to be
   usable with the service.

*** 3.1.1 Declaring an Interface - 100
    - Consider a service that works on sequences of integers, reporting the
      _average_ of the first ~n~ values:
      ~public static double average(IntSequence seq, int n)~
      The sequence here can take many forms. Here are some examples:
      + A sequence of integers supplied by a user
      + A sequence of random integers
      + The sequence of prime numbers
      + The sequence of elements in an integer array
      + The sequence of code points in a string
      + The sequence of digits in a number

    - We want to implement a single mechanism for dealing with all these kinds of
      sequences.
      Find out what is common between integer sequences. At a minimum:
      + Test whether there is a next element
      + Get the next element

      #+BEGIN_SRC java
      public interface Instance {
          boolean hasNext();
          int next();
      }
      #+END_SRC
      You need not implement these methods,
      but you can provide default implementations if you like -- see Section
      3.2.2, “Default Methods,” on p. 100. =TODO=

      If NO implementation is provided, we say that the method is /abstract/.

    - _Note_: =IMPORTANT=
      All methods of an interface are automatically ~public~.

      Some programmers do it anyway (explicitly provide ~public~) for greater
      clarity.

    - The methods in the interface sufficie to implement the ~average~ method:
      #+BEGIN_SRC java
      public static double average(IntSequence seq, int n) {
          int count = 0;
          double sum = 0;
          while (seq.hasNext() && count < n) {
              count++;
              sum += seq.next();
          }
          return count == 0 ? 0 : sum / count;
      }
      #+END_SRC

*** 3.1.2 Implementing an Interface - 101
    - The classes want to be usable with the ~average~ method need to implement
      the ~IntSequence~ interface. Here is a example of a infinitely many
      squares:
      #+BEGIN_SRC java
      public class SequareSequence implements IntSequence {
          private int i;

          public boolean hasNext() {
              return true;
          }

          public int next() {
              i++;
              return i * i;
          }
      }
      #+END_SRC

    - _Caution_:
      The implementing class _MUST_ declare the methods of the interface as
      ~public~.

      Otherwise, they would default to package access. Since the interface
      requires public access, the compiler would report an error.

    - Another example:
      #+BEGIN_SRC java
      public class DigitSequence implements IntSequence {
          private int number;

          public DigitSequence(int n) {
              number = n;
          }

          public boolean hasNext() {
              return number != 0;
          }

          public int next() {
              int result = number % 10;
              number /= 10;
              return result;
          }

          public int rest() {
              return number;
          }
      }
      #+END_SRC

    - _Note_:
      /abstract class/: If a class only implements some of the methods, then
      it must be declared with the /abstract/ modifier.
      See Chapter 4. =TODO=

*** 3.1.3 Converting to an Interface Type - 103
    - /subtype/ and /supertype/

    - _Note_:
      + It is possible to declare variables of an interface type
      + you can never have an object whose type is an interface.
        All objects are instances of classes.

*** 3.1.4 Casts and the ~instanceof~ Operator - 103
    - /cast/

    - Example of cast:
      #+BEGIN_SRC java
      IntSequence sequence = ...;
      DigitSequence digits = (DigitSequence) sequence;
      System.out.println(digits.rest());
      #+END_SRC
      This is necessary because ~rest~ is a method of ~DigitSequence~ but not
      ~IntSequence~.

    - ~isinstanceof~ operator

    -

*** 3.1.5 Extending Interfaces - 104
    - An instance can /extend/ another.

*** 3.1.6 Implementing Multiple Interfaces - 105
    - A class can implement any number of interfaces.

*** 3.1.7 Constants - 105
    - Any variable defined in an interface is automatically
      ~public static final~.

    - _Note_: =IMPORTANT=
      You cannot have instance variables in an interface.
      _An interface specifies behavior, not object state._

** DONE 3.2 Static, Default, and Private Methods - 105
   CLOSED: [2017-05-11 Thu 15:07]
   In earlier versions of Java, _ALL methods of an interface_ had to be
   /abstract/

   Nowadays you can add two kinds of methods with a concrete implementation:
   + static methods
   + default methods
*** 3.2.1 Static Methods - 105
    - (In earlier version of Java)
      There was never a technical reason why an interface could not have static
      methods,
      but they did not fit into the view of interfaces as abstract specifications.
      =From Jian= I think this is why scala use /trait/ rather than /interface/.

    - Factory methods make a lot of sense in interfaces.

    - Example:
      #+BEGIN_SRC java
      public interface IntSequence {
          // ...
          public static IntSequence digitsOf(int n) {
              return new DigitSequence(n);
          }
      }
      #+END_SRC

    - _Note\under{}(history): =IMPORTANT=
      In the past, it had been common to place static methods in a companion
      class, and you can find pairs of interfaces and utility classes, such as
      ~Collection/Collections~ or ~Path/Paths~, in the standard library.

      _This split is no longer necessary._

*** 3.2.2 Default Methods - 106
    - Example:
      #+BEGIN_SRC java
      public interface IntSequence {
          default boolean hasNext() { return true; }

          int next();
      }
      #+END_SRC
      Here the ~default~ is required.

    - _Note (history)_:
      Again, an interface and a companion class that implements most or all of
      its methods, such as ~Collection/AbstractCollection~ or
      ~WindowListener/WindowAdapter~ in the Java API.

      _Nowadays just implement the methods in the interface_

    - Default method is important for /interface evolution/.
      For example,
      Suppose we provided a class ~public class Bag implements Collectoin~
      In Java 8, a ~stream~ method was added to the interface.
      + Case 1 :: a non-default method to an interface is not
                  /source-compatible/, _we must add a default method ~stream~ to
                  the interface_

      + Case 2 :: use the old JAR (include ~Bag~ class), an ~AbstractMethodError~
                  will triggered when a ~Bag~ instance use the ~stream~ method.
                    However, _add a default method ~stream~ to the interface_
                  (which is /binary-compatible/) can solve this:
                    Since the old JAR includes ~Bag~ is reused without change, no
                  ~Bag.stream~ method can be found, but ~Collection.stream~ now
                  can be used.

*** 3.2.3 Resolving Default Method Conflicts - 107
    - Example:
      #+BEGIN_SRC java
      public interface Person {
          String getName();
          default int getId() { return 0; }
      }


      public interface Identified {
          default int getId() { return Math.abs(hashCode()); }
      }


      public class Employee implements Person, Identified {
          public int getId() { return Identified.super.getId(); }
          // TODO: Why DO NOT use Identified.getId();

          // ...
      }
      #+END_SRC

    - Q: If one interface only has /abstract/ ~getId~, should the compiler pick
         the other (/default/) ~getId~?
      A: This might seem reasonable, but it's actually not:
           The class may expect some logic from the interface ~Identified~,
         rather than from ~Person~ (for instance, suppose identified id's are
         always real ), though this time something unexpected happens
         and no /default/ ~getId~ are created insdie ~Identified~.

    - If a class extends a superclass and implements an interface inheriting the
      same method for both, the rules are easier:
      + only use the superclass method, and
      + any default method from the interface is simply ignored.

*** 3.2.4 Private Methods - 109

** DONE 3.3 Examples of Interfaces - 109
   CLOSED: [2017-05-12 Fri 00:41]
*** DONE 3.3.1 The ~Comparable~ Interface - 109
    CLOSED: [2017-09-21 Thu 22:33]
    - If a class wants to enable sorting for its objects, it should implement the
      ~Comparable~ interface.

      #+BEGIN_SRC java
      public interface Comparable<T> {
          int compareTo(T other);
      }
      #+END_SRC

    - /generic type/: A type with a type parameter such as ~Comparable~ or
      ~ArrayList~.

    - For objects that implement ~Comparable~, ~x.compareTo(y)~ returns
      + a positive value   =>   ~x~ should _after_ ~y~
      + 0                  =>   ~x~ and ~y~ are considered equal.
      + a negative value   =>   ~x~ should _before_ ~y~

    - For example:
      #+BEGIN_SRC java
      public class Employee implements Comparable<Employee> {
          // ...
          public int compareTo(Employee other) {
              return getId() - other.getId();
              // Ok if IDs always ≥ 0
          }
      }
      #+END_SRC

      _Caution_: =Important=
      Returning a difference of integers _does not work_ if the integers can be
      negative. Then the difference can overflow for large operands of opposite
      sign.
        In that case, use the ~Integer.compare~ method that works correctly for
      all integers. =TODO= =Read API=

    - Compare floating-point values, you cannot just return the difference.
      Use static ~Double.compare~ method. It does right thing, even for +-\infty and
      NaN.
      #+BEGIN_SRC java
      public class Employee implements Comparable<Employee> {
          // ...
          public int compareTo(Employee other) {
              return Double.compare(salary, other.salary);
          }
      }
      #+END_SRC

    - _Note_:
      In Java, a method can access /private features/ of any object of its class.

    - Use ~Array.sort~ method to sort an array of ~Comparable~ objects:
      #+BEGIN_SRC java
      String[] friends = { "Peter", "Paul", "Mary" };
      Arrays.sort(friends);  // friends is now ["Mary", "Paul", "Peter"]
      #+END_SRC

    - _Note_: =WHY= =???= =TODO= _NO Answer in this book_
      Strangely, the ~Arrays.sort~ method does NOT check _at compile time_
      whether the argument is an array of ~Comparable~ objects.

      Instead, it throws an exception if it encounters an element of a class
      that doesn't implement the ~Comparable~ interface.

*** DONE 3.3.2 The ~Comparator~ Interface - 111
    CLOSED: [2017-09-21 Thu 22:33]
    - A second version of the ~Arrays.sort~ method whose parameters are an array
      and a /comparator/.

    - /comparator/: an instance of a class that implements the ~Comparator~
      interface.
      #+BEGIN_SRC java
      public interface Comparator<T> {
          int compare(T first, T second);
      }
      #+END_SRC

    - To compare strings by length, define a class that implements
      ~Comparator<String>~:
      #+BEGIN_SRC java
      class LengthComparator implements Comparator<String> {
          public int compare(String first, String second) {
              return first.length() - second.length();
          }
      }

      Comparator<String> comp = new LengthComparator();

      if (comp.compare(words[i], words[j]) > 0) ...
      #+END_SRC
      It's clear that here the ~compare~ method is called on the comparator
      object, _NOT_ the string itself.
      (This is different from the ~compareTo~ method from a comparable instance:
       If applicable it should be in the form of ~word[i].compareTo(words[j])~).

    - _Note_:
      Even though the ~LengthComparator~ object has no state, you still need to
      make an instance of it. ~compare~ is NOT a static method.

    - Application:
      #+BEGIN_SRC java
      String[] friends = { "Peter", "Paul", "Mary" };
      Arrays.sort(friends, new LengthComparator());
      #+END_SRC

*** DONE 3.3.3 The ~Runnable~ Interface - 112
    CLOSED: [2017-09-21 Thu 22:37]
    - You may want to run certain tasks in a separate thread, or give them to a
      thread pool for execution.
        To define the task, you implement the ~Runnable~ interface. It has just
      ONE method. For example,
      #+BEGIN_SRC java
      class HelloTask implements Runnable {
          public void run() {
              for (int i = 0; i < 1000; ++i) {
                  System.out.println("Hello, World!");
              }
          }
      }

      // Excute in a new thread
      Runnable task = new HelloTask();
      Thread thread = new Thread(task);
      thread.start();
     #+END_SRC
     Now the ~run~ method executes in a separate thread, and the current thread
      can proceed with other work.

    - _Note_: =TODO=
      See Chapter 10, other ways of executing a ~Runnable~.

    - There is also a ~Callable<T>~ interface for tasks that return a result of
      type ~T~.

*** DONE 3.3.4 User Interface Callbacks - 112
    CLOSED: [2017-09-21 Thu 22:40]
    - call back :: some code gets called back when a user action occurs.

    - In Java-based GUI libraries, interfaces are used for callbacks.

    - Example:
      #+BEGIN_SRC java
      public interface EventHandler<T> {
          void handle(T event);
      }

      class CancelAction implements EventHandler<ActionEvent> {
          public void handle(ActionEvent event) {
              System.out.println("Oh noes!");
          }
      }

      Button cancelButton = new Button("Cancel");
      cancelButton.setOnAction(new CancelAction());
      #+END_SRC

    - This is tedious. In other language, you just provide a function to the
      ~secOnAction~ method, without going through the detour of making a class
      and instantiating it. =TODO= The next section shows how you can do the same
      in Java.

** DONE 3.4 Lambda Expressions - 113
   CLOSED: [2017-05-11 Thu 15:50]
   - /lambda expression/: a block of code that you can pass around so it can be
     executed later.

   - Java is a language of (almost) pure object-oriented, and there is no
     function types in Java (/function types/: for example, the arrow types in
     Scala).

     _ESSENSE_: Instead, functions are expressed as objects, instances of classes
                that implement a particular interface.
                  Lambda expressions give you a convenient syntax for creating
                such instances. =TODO=

*** DONE 3.4.1 The Syntax of Lambda Expressions - 114
    CLOSED: [2017-05-11 Thu 15:35]
    - Lambda expressions:
      #+BEGIN_SRC java
      // Single expression body
      (String first, String second) -> first.length() - second.length()

      // Non-single expression body
      (String first, String second) -> {
          int difference = first.length() < second.length();

          if (difference < 0) return -1;
          else if (difference > 0) return 1;
          else return 0;
      }

      // No parameter
      () -> { for (int i = 0; i < 1000; i++) doWork(); };

      // parameter types can be inferred
      Comparator<String> comp
          = (first, second) -> first.length() - second.length();

      // If single parameter lambda expression with its type can be inferred, the
      // parentheses can be omitted.
      EventHandler<ActionEvent> listener = event ->
          System.out.println("Oh noes!")
      #+END_SRC

    - You NEVER specify the _result type_ of a lambda expression.
      =From Jian= but if a chance can be given to specify it is not a bad idea!

      However, the compiler infers it from the body and checks that it matches
      the expected type.

*** DONE 3.4.2 Functional Interfaces - 115
    CLOSED: [2017-05-11 Thu 15:50]
    - In Java there are many interfaces, such as ~Runnable~ or ~Comparator~, that
      express actions. Lambda expressions are compatible with these interfaces.

    - functional interface :: a interface that has
         a _single_ /abstract method/.

      #+BEGIN_SRC java
      Arrays.sort(words,
          (first, second) -> first.length() - second.length());
      #+END_SRC

    - In _most programming languages_ that support function literals, you can
      + declare function types such as ~(String, String) -> int~
      + declare variables of those types, put functions into those variables, and
        invoke them.

    - In /Java/ you can _ONLY_ do _ONE_ thing:
      put the lambda expression in a variable typed as a /functional interface/
      (can't be any class), so that it is converted to an instance of that
      interface.

    - Note: =IMPORTANT=
      You _CANNOT_ assign a lambda expression to a variable of type ~Object~,
      REASON: ~Object~ is the common supertype of all classes.
              It is a class, NOT a /functional interface/.

    - The standard library provides a large number of /functional interfaces/
      (see Section 3.6.2, “Choosing a Functional Interface,” on p. 113).
      For example:
      #+BEGIN_SRC java
      public interface Predicate<T> {
          boolean test(T t);
          // Additional default and static methods
      }
      #+END_SRC
      =TODO=
      The ~ArrayList~ class has a ~removeIf~ method whose parameter is a
      ~Predicate~. For example, the folloing statement removes all ~null~ values
      from an array list:
      #+BEGIN_SRC java
      list.removeIf(e -> e == null);
      #+END_SRC

** DONE 3.5 Method and Constructor References - 116
   CLOSED: [2017-05-12 Fri 12:29]
*** DONE 3.5.1 Method References - 117
    CLOSED: [2017-09-15 Fri 14:40]
    - Introduce /method reference/ by examples:
      #+BEGIN_SRC java
      // #1
      Arrays.sort(strings, (x, y) -> x.compareToIgnoreCase(y));
                           // lambda expression

      Arrays.sort(strings, String::compareToIgnoreCase);
                           // method reference


      // #2 removes all null values from a list.
      list.removeIf(Objects::isNull);
      #+END_SRC

    - Another example:
      #+BEGIN_SRC java
      list.forEach(x -> System.out.println(x));

      list.forEach(System.out::println);
      #+END_SRC

    - Three variations of /method reference/:
      + Class::instanceMethod ::
        The first parameter becomes the receiver of the method, and any other
        parameters are passed to the method.

        ~String::compareToIgnoreCase~ is the same as
        ~(x, y) -> x.compareToIgnoreCase(y)~

      + Class::staticMethod ::
        all parameters are passed to the static method.

        ~Objects::isNull~ is equivalent to ~x -> Objects.isNull(x)~

      + object::instanceMethod ::
        the method is invoked on the given object, and the parameters are passed
        to the instance method.
        ~System.out::println~ is equivalent to ~x -> System.out.println(x)~

    - _NOTE_:
      Compiler will try to find from the context which overloaded method is
      required.

    - You can capture the ~this~ parameter in a method reference. For example,
      ~this::equals~ is the same as ~x -> this.equals(x)~.

    - _NOTE_:
      In an inner class, you can capture the ~this~ reference of an enclosing
      class as ~EnclosingClass.this::method~.

      You can also capture ~super~ - See Chapter 4   =TODO=

*** DONE 3.5.2 Constructor References - 118
    CLOSED: [2017-09-18 Mon 23:37]
    - ~ClassName::new~
      If the class has more than one constructor, then which one is called
      depends on the context.

    - Example
      #+BEGIN_SRC java
        List<String> names = ...;
        Stream<Employee> stream = names.stream().map(Employee::new);
        // Here the `Employee(String)` constructor is called.
      #+END_SRC

    - Form constructor references with array types, for example:
      ~int[]::new~,
      which is equivalent to ~n -> new int[n]~

    - Use /constructor reference/ to overcome one of Java's limitation:
      it's usually _NOT_ possible to construct an array of generic type!
      =TODO= See Chapter 6

      =IMPORTANT=
      #+BEGIN_SRC java
      // Usual `toArray` method return an `Object`, not an array of the element
      // type
      Object[] employees = stream.toArray();

      // With constructor reference
      Employee[] buttons = stream.toArray(Employee[]::new);
      #+END_SRC

** DONE 3.6 Processing Lambda Expressions - 119
   CLOSED: [2017-05-14 Sun 20:02]
   Topic: how to write your own methods that can consume lambda expressions.

*** DONE 3.6.1 Implementing Deferred Execution - 119
    CLOSED: [2017-09-18 Mon 22:15]
    - The point of using lambdas is /deferred execution/.

      You need it for many reasons, such as:
      + Running the code in a separate thread

      + Running the code multiple times

      + Running the code at the right point in an algorithm (for example, the
        comparison operation in sorting)

      + Running the code when something happens (a button was clicked, data has
        arrived, and so on)

      + Running the code only when necessary

    - Example:
      #+BEGIN_SRC java
        // #1
        repeat(10, () -> System.out.println("Hello, World!"));

        // a method
        public static void repeat(int n, Runnable action) {
            for (int i = 0; i < n; ++i) action.run();
        }


        // #2 The improved version
        public interface IntConsumer {
            void accept(int value);
        }

        public static void repeat(int n, IntConsumer action) {
            for (int i = 0; i < n; ++ i) action.accept(i);
        }

        repeat(10, i -> System.out.println("Countdown: " + (9 - i)));
      #+END_SRC

*** DONE 3.6.2 Choosing a Functional Interface - 120
    CLOSED: [2017-09-18 Mon 23:30]
    - In most functional programming languages, function types are /structural/.
      They are in the form of (input: two strings input; output: int)
      + ~Function2<String, String, Integer>~
        OR
      + ~(String, String) -> int~

    - In Java, use functional interface such as ~Comparator<String>~.
      In theory this is called /nominal typing/. =TODO= =???=

    - Provided: Table 3-1 Common Functional Interfaces
      =IMPORTANT=
      |----------------------+-----------------+-------------+----------------------+-------------+---------------|
      | Functional Interface | Parameter types | Return type | Abstract method name | Description | Other methods |
      |----------------------+-----------------+-------------+----------------------+-------------+---------------|
      | Runnable             | none            | void        | run                  |             |               |
      | Supplier<T>          | none            | T           | get                  |             |               |
      | Consumer<T>          | T               | void        | accept               |             |               |
      | BiConsumer<T, U>     | T, U            | void        | accept               |             |               |
      | Function<T, R>       | T               | R           | apply                |             |               |
      | BiFunction<T, U, R>  | T, U            | R           | apply                |             |               |
      | UnaryOperator<T>     | T               | T           | apply                |             |               |
      | BinaryOperator<T>    | T, T            | T           | apply                |             |               |
      | Predicate<T>         | T               | boolean     | test                 |             |               |
      | Bipredicate<T, U>    | T, U            | boolean     | test                 |             |               |

    - _NOTE_:
      Most of the standard functional interfaces have nonabstract methods for
      producing or combining functions.
      For example,
      ~Predicate.isEqual(a).or(Predicate.isEqual(b))~, which is the same as
      ~x -> a.equals(x) || b.equals(x)~.

    - Use /functional interfaces/ for primitive types can help you reduce
      autoboxing.

      For this reason, we use ~IntConsumer~ instead of a ~Consumer<Integer>~ in
      the example of the preceeding section.

    - Table 3-2 =IMPORTANT=
      Functional Interfaces for Primitive Types ~p~, ~q~ is ~int~, ~long~,
      ~double~; ~P~, ~Q~ is ~Int~, ~Long~, ~Double~.

*** DONE 3.6.3 Implementing Your Own Functional Interfaces - 123
    CLOSED: [2017-09-18 Mon 23:30]
    Exaplain through an example:
      There is no standard type for a mapping ~(int, int) -> Color~. Of course,
    you could use ~BiFunction<Integer, Integer, Color>~, BUT that involves
    /autoboxing/.

    In this case, it makes sense to define a new interface
    #+BEGIN_SRC java
      @FunctionalInterface
      public interface PixelFunction {
          Color apply(int x, int y);
      }
    #+END_SRC

    - Advantages of using ~@FunctionalInterface~ annotation:
      1. The compiler checks that the annotated entity is a functional interface
         -- an interface with a single abstract method.

      2. The _javadoc_ page includes a statement that your interface is a func-
         tional interface.

    - Implement a method can take a lambda expression parameter, and use it:
      #+BEGIN_SRC java
        BufferedImage createImage(int width, int height, PixelFunction f) {
            BufferedImage image = new BufferedImage(width, height,
                                                    BufferedImage.TYPE_INT_RGB);
            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    Color color = f.apply(x, y); // IMPORTANT
                    image.setRGB(x, y, color.getRGB());
                }
            }
            return image;
        }

        BufferedImage frenchFlag = createImage(150, 100,
            (x, y) -> x < 50 ? Color.BLUE : x < 100 ? Color.WHITE : Color.RED);
      #+END_SRC

** DONE 3.7 Lambda Expressions and Variable Scope - 124
   CLOSED: [2017-05-14 Sun 21:05]
   TOPIC: How variables work inside lambda expressions.
*** DONE 3.7.1 Scope of a Lambda Expression - 124
    CLOSED: [2017-09-19 Tue 00:19]
    - It is _illegal_ to
      + declare a parameter or a local variable in the lambda that has the same
        name as a local variable.
        For example,
        #+BEGIN_SRC java
          int first = 0;
          Comparator<String> comp = (first, second) -> first.length() -
              second.length();
          // Error: Variable `first` already defined
        #+END_SRC

      + introduce same name variables in a lambda expression

    - ~this~ in a lambda expression denotes the ~this~ parameter of the method
      that creates the lambda.

      For example,
      #+BEGIN_SRC java
        public class Application {
            public void doWork() {
                Runnable runner = () -> { // ...
                                          System.out.println(this.toString());
                                          // ...
                };

                // ...
            }
        }
      #+END_SRC
      The expression ~this.toString()~ calls the ~toString~ method of the
      ~Application~ object, _NOT_ the ~Runnable~ instance.
      There is nothing special about the use of this in a lambda expression.
      The scope of the lambda expression is nested inside the ~doWork~ method,
      and ~this~ has the same meaning anywhere in that method.

*** DONE 3.7.2 Accessing Variables from the Enclosing Scope - 124
    CLOSED: [2017-09-19 Tue 00:33]
    - A lambda expression has THREE ingredients:
      1. A block of code
      2. Parameters
      3. Values for the free variables -- that is, the variables that are not
         parameters and not defined inside the code.

    - /closure/: a block of code together with the values of free variables.

      In Java, lambda expressions are closures.

    - To ensure that the captured value is well defined,
      =IMPORTANT=

      there is an important -RESTRICTION-:
      _In a lambda expression, you can only reference variables whose value
      doesn't change_ -- /effective/ ~final~, which means it either is or could
      be declared as ~final~.

      For example, (here is a compile-time error):
      #+BEGIN_SRC java
        for (int i = 0; i < n; ++i) {
            new Thread(() -> System.out.println(i)).start();
            // Error -- cannot capture `i`
        }
      #+END_SRC

    - _NOTE_:
      The same rule applies to variables captured by /local (inner) classes/.

      _In the past_, the rule was more draconian and required captured variables
      to actually be declared ~final~. _This is no longer the case_.

    - _NOTE_:
      The variable of an enhanced ~for~ loop is /effectively final/ since its
      scope is a single iteration. =TODO= =???=
      A legal example:
      #+BEGIN_SRC java
        for (String arg : args) {
            new Thread(() -> System.out.println(arg)).start();
            // OK to capture `arg`
        }
      #+END_SRC
      In contrast, the scope of ~i~ in traditional ~for~ is the entire loop (if
      NOT, why there is ~++i~ or ~i++~).

    - As a consequence of the /effectively final/ rule,
      a lambda expression CANNOT _mutate any captured variables_.
      For example,
      #+BEGIN_SRC java
        public static void repeatMessage(String text, int count, int threads) {
            Runnable r = () -> {
                while (count > 0) {
                    count--; // Error: Can't mutate captured variable
                    System.out.println(text);
                }
            };
            for (int i = 0; i < threads; i++) new Thread(r).start();
        }
      #+END_SRC

      =TODO= This is actually a good thing. As you will see in Chapter 10, if
      two threads update count at the same time, its value is undefined.

    - _NOTE_: =IMPORTANT=
      _Don't count on the compiler to catch all concurrent access errors._

      The prohibition against mutation _ONLY_ holds for _local variables_.

      If ~count~ is an _instance variable_ or _static variable_ of an enclosing
      class, then NO ERROR is reported even though the result is just as
      undefined.

    - _CAUTION_: =IMPORTANT=
      One can circumvent the check for inappropriate mutations by using an array
      of length 1:
      #+BEGIN_SRC java
      int[] counter = new int[1];
      button.setOnAction(event -> counter[0]++);
      #+END_SRC

      The counter variable is /effectively final/ -- it is never changed since it
      always refers to the same array, so you can access it in the lambda
      expression.

      Of course, code like this is _NOT threadsafe_. Except possibly for a
      callback in a single-threaded UI, this is a terrible idea.

      =TODO= You will see how to implement a threadsafe shared counter in
      Chapter 10.

** DONE 3.8 Higher-Order Functions - 127
   CLOSED: [2017-09-21 Thu 23:20]
*** DONE 3.8.1 Methods that Return Functions - 127
    CLOSED: [2017-09-21 Thu 22:44]
    - Example
      #+BEGIN_SRC java
        public static Comparator<String> compareInDirection(int direction) {
            return (x, y) -> direction * x.compareTo(y);
        }
      #+END_SRC
      + call ~compareInDirection(1)~ yields an ascending comparator
      + call ~compareInDirection(-1)~ yields a descending comparator

    - Application
      ~Arrays.sort(friends, compareInDirection(-1));~

*** DONE 3.8.2 Methods That Modify Functions - 128
    CLOSED: [2017-09-21 Thu 22:47]
    Generalize the idea from the last section: Reverse any comparator.
    #+BEGIN_SRC java
      public static Comparator<String> reverse(Comparator<String> comp) {
          return (x, y) -> comp.compare(y, x);
      }

      Arrays.sort(friends, reverse(compareInDirection(1)));
    #+END_SRC

    =From Jian=
    ~Arrays.sort(friends, reverse(compareInDirection(1)));~ is equivalent to the
    ~Arrays.sort(friends, compareInDirection(-1));~ in the last section.


    _NOTE_:
    The ~Comparator~ interface has default method ~reversed~ that produces the
    reverse of a given comparator in just this way.

*** DONE 3.8.3 ~Comparator~ Methods - 128
    CLOSED: [2017-09-21 Thu 23:20]
    - The ~Comparator~ interface has a number of useful static methods that are
      higher-order functions generating comparators.

    - The ~comparing~ method takes a /"key extractor" function/ that maps a type
      ~T~ to a comparable type (such as ~String~), and then compare them.

      For example,
      + ~Arrays.sort(people, Comparator.comparing(Person::getName));~

      + Chain comparators
        #+BEGIN_SRC java
          Arrays.sort(people, Comparator
                      .comparing(Person::getLastName)
                      .thenComparing(Person::getFirstName));
        #+END_SRC

      + Some variations of these methods.
        #+BEGIN_SRC java
          Arrays.sort(people, Comparator.comparing(Person::getName,
              (s, t) -> s.length() - t.length()));
        #+END_SRC

        =TODO= =Practice= Write code that implement ~comparing~

    - =IMPORTANT= Both the ~comparing~ and ~thenComparing~ methods have variants
      that avoid boxing of ~int~, ~long~, or ~double~ values.
        An easier way of sorting by name length would be
      ~Arrays.sort(people, Comparator.comparingInt(p -> p.getName().length()));~

    - If a key function can return ~null~, use static methods ~nullsFirst~ and
      ~nullsLast~.

      They take an existing comparator modify it so that no ~null~ realted exception
      but ranks them as smaller or larger than regular values.

      For example,
      #+BEGIN_SRC java
        import java.util.Comparator.*;

        Arrays.sort(people, comparing(Person::getMiddleName,
                                      nullsFirst(naturalOrder())));
      #+END_SRC
      + ~naturalOrder~: make a comparator for any class implementing ~Comparable~
      + ~reverseOrder~: give the reverse of the natural order.

** DONE 3.9 Local Inner Classes - 129
   CLOSED: [2017-05-14 Sun 22:41]
   _Long before there were lambda expressions_
   Java had a mechanism for concisely defining classes that implement a interface
   (functional or not).
   _For Now_
   + For functional interfaces, use lambda expressions.
   + For non-functional, use /local inner classes/.

*** DONE 3.9.1 Local Classes - 129
    CLOSED: [2017-09-19 Tue 00:10]
   - /local class/: a /class/ inside a /method/.

   - /local class/ occurs often when the /return type/ of a method is annotated
     with an /interface/, rather than a /class/ -- users only care about the API
     specified by this /interface/.

     For example,
     #+BEGIN_SRC java
       private static Random generator = new Random();

       public static IntSequence randomInts(int low, int high) {
           class RandomSequence implements IntSequence {
               public int next() { return low + generator.nextInt(high - low + 1); }
               public boolean hasNext() { return true; }
           }

           return new RandomSequence();
       }
     #+END_SRC

   - _Note_:
     No need to use a /modifer/ like ~public~ or ~private~ to declare a /local
     class/, since it is never accessible outside the /method/.

   - Two advantages of making a /class/ *LOCAL*.
     * This helps avoid namespace pollution.

     * It reduces the noise information.
       ONLY the /interface/ is important, and the information about a specific
       implementation of this /interface/, a class, is noise information.
       =From Jian=

     * The method of the /local class/ can access variables from the enclosing
       scope, just like the variables of a lambda expression.

*** DONE 3.9.2 Anonymous Classes - 130
    CLOSED: [2017-09-19 Tue 00:15]
    The /local class/ ~RandomSequence~ in the preceding section was used only
    once, it can be made _anonymous_:
    #+BEGIN_SRC java
      public static IntSequence randomInts(int low, int high) {
          return new IntSequence() {
              public int next() { return low + generator.nextInt(high - low + 1); }
              public boolean hasNext() { return true; }
          }
      }
    #+END_SRC

    - The expression ~new interface() { methods }~ means:
      Define a /class/ implementing the /interface/ that has the given methods,
      and construct one object of that class.

    - =From Jian=
      https://stackoverflow.com/a/8163863/5988624
      An /anonymous class/ can ONLY
      + /extend/ *one* /subclass/
        OR
      + /implement/ *one* /interface/.

    - _NOTE_:
      As always, the ~()~ in the ~new~ expression indicate the construction
      arguments. A default constructor of the anonymous class is invoked.

    - _Before_ Java had /lambda expressions/, /anonymous inner classes/ is used
      to create functional objects like /runnables/ and /comparators/.
      _They show up frequently in legacy code._

    - =IMPORTANT= *When to use*
      NOWADAYS, _they are only necessary when you need to provide two or more
      methods_, as in the preceding example.

      If the ~IntSequence~ interface has a default ~hasNext~ method, as in
      Exercise 15, you can simply use a lambda expression: =IMPORTANT=
      #+BEGIN_SRC java
        public static IntSequence randomInts(int low, int high) {
            // implements `IntSequence` with default method `hasNext`.
            return () -> low + generator.nextInt(high - low + 1);
        }
      #+END_SRC

** TODO Exercises - 131
   1.
   2.
   3. ~String~ has (directly) supertypes ~Object~, ~Serializable~,
      ~CharSequence~, ~Comparable<String>~. ~String~ is also ~String~'s
      supertype.

      ~Scanner~ has (directly) supertypes ~Object~, ~Closeable~, ~AutoCloseable~,
      ~Iterator<String>~. ~Scanner~ is also ~Scanner~'s supertype.
        ~Closeable~ also has a supertype ~AutoCloseable~, which is alreay in the
      list of types above.

      ~ImageOutputStream~ has (directly) supertypes ~Object~, ~AutoCloseable~,
      ~Closeable~, ~DataInput~, ~DataOutput~, and ~ImageInputStream~.
      ~ImageOutputStream~ is also ~ImageOutputStream~'s supertype.
        ~ImageInputStream~ also has supertypes ~AutoCloseable~, ~Closeable~, and
      ~DataInput~, all of which are alreay in the list of types above.

* TODO 4. INHERITANCE AND REFLECTION - 135
  - /inheritance/

  - /fields/: instance variables and static variables.

  - /members/: /fields/, /methods/, /nested classes/ and /nested interfaces/.

  - /reflection/: the ability to find out more about classes and their members
    in running program.
    + _Reflection is a powerful feature, but it is undeniably COMPLEX._
    + _Tool builders oriented_

  - Key points:
    1. Use the ~super~ keyword to invoke a superclass method or constructor.

    2. A ~protected~ member of a subclass is accessible in a subclass method, but
       only when applied to objects of the same subclass.

    3. Every class is a subclass of ~Object~ which provides methods ~toString~,
       ~equals~, ~hashCode~, and ~clone~.

    4. Each enumerated type is a subclass of ~Enum~ which provides methods
       ~toString~, ~valueOf~, and ~compareTo~.

    5. The ~Class~ class provides information about a Java type, which can be a
       class, array, interface, primitive type, or ~void~.

    6. You can use a ~Class~ object to load resources that are placed alongside
       class files. TODO =???=

    7. You can load classes from locations other than the class path by using a
       class loader. TODO =???=

    8. The reflection library enables programs to discover members of arbitrary
       objects, access variables, and invoke methods. TODO =???=

    9. Proxy objects dynamically implement arbitrary interfaces, routing all
       method invocations to a handler. TODO =???=

** DONE 4.1 Extending a Class - 136
   CLOSED: [2017-05-15 Mon 20:53]
*** DONE 4.1.1 Super- and Subclasses - 136
    CLOSED: [2018-01-05 Fri 14:40]
    #+BEGIN_SRC java
      public class Manager extends Employee {
          // added fields
          // added or overriding methods
      }
    #+END_SRC

    - /superclass/ and /subclass/

    - The _super/sub_ terminology comes from /set theory/.
      ~Manager~'s \subset{} ~Employee~'s
         ^            ^
         |            |
       subset      superset

*** DONE 4.1.2 Defining and Inheriting Subclass Methods - 137
    CLOSED: [2018-01-05 Fri 14:46]
    #+BEGIN_SRC java
      public class Manager extends Employee {
          private double bonus;

          public void setBonus(double bonus) {
              this.bonus = bonus;
          }
      }
    #+END_SRC
    - *New* /instance variable/ and *new* /method/

    - /inherited instance variable/ and /inherited method/

    - /overriding/ =NEXT SECTION=

*** 4.1.3 Method Overriding - 137
    - Example:
      #+BEGIN_SRC java
        public class Manager extends Employee {
            // ...
            public double getSalary() {  // Overrides superclass method
                return super.getSalary() + bonus;
            }
        }
      #+END_SRC

    - _Note_: TODO =???=
      _Unlike_ ~this~, ~super~ is NOT a reference to an object,
      but a directive to bypass dynamic method lookup
      (see Section 4.1.5, “Superclass Assignments,” on p. 131) and invoke a
      specific method instead. TODO =???=

    - ~@Override~ annotation

    - You can *change the return type to a subtype* when _overriding_ a /method/.
      (/convariant return types/ are permitted)

      =From Jian= How about /contravariant/ ????

    - _Caution_: =IMPORTANT=
      When /override/ a /method/,
      the /subclass method/ MUST be _at least as visible_ as the /superclass
      method/.

*** 4.1.4 Subclass Construction - 139
    - Subclass cannot access the private instance variables of the superclass,
      it must initialize them through a super class constructor. For example,
      #+BEGIN_SRC java
        public Manager(String name, double salary) {
            super(name, salary);
            bonus = 0;
        }
      #+END_SRC

    - The superclass constructor call must be the _FIRST_ statement in the
      constructor for the subclass.

    - If omit the superclass constructor call, the superclass must have a
      no-argument constructor which is implicitly called.

*** 4.1.5 Superclass Assignments - 139
    - /covariant/

    - /dynamic method lookup/
      For example,
      #+BEGIN_SRC java
        Manager boss = new Manager(/* ... */);
        Employee empl = boss;  // OK to assign to superclass variable
      #+END_SRC
      Though the type of ~empl~ is ~Employee~, when it calls ~getSalary~ method
      it calls the right one -- the method of ~Manager~, rather than ~Employee~.

    - _CAUTION_:
      In Java, assign a ~Manager[]~ array to an ~Employee[]~ variable is OK,
      BUT it is also _unsound_.
      #+BEGIN_SRC java
        Manager[] bosses = new Manager[10];
        Employee[] empls = bosses; // Legal in Java
        empls[0] = new Employee(/* ... */); // Runtime error
      #+END_SRC
      + ~empls~ and ~bosses~ reference the same ~Manager[]~ array, which cannot
        hold a lowly ~Employee~
      + runtime exception ~ArrayStoreException~.

*** 4.1.6 Casts - 140
    One drawback from the preceding section:
    You can only invoke methods that belong to the superclass.

    For example,
    #+BEGIN_SRC java
      Employee empl = new Manager(/* ... */);
      empl.setBonus(10000); // Compile-time error
    #+END_SRC
    The second line is a compile-time error, though if it can pass compilation,
    the runtime should be OK due to /dynamic method lookup/.

    Solution:
    #+BEGIN_SRC java
      if (empl instanceof Manager) {
          Manager mgr = (Manager) empl;
          mgr.setBonus(10000);
      }
    #+END_SRC

*** 4.1.7 Final Methods and Classes - 141
    - A good example: the ~getClass~ method of the ~Object~ class.
      It does not allow objects to lie about the class to which they belong.

    - ~final~ is good for efficiency only in the early days of Java.

      Modern VM will speculatively "inline" simple methods, even if they are not
      declared ~final~.

      When overriding happens, such inlining is undone.

*** 4.1.8 Abstract Methods and Classes - 141
    - It is not possible to construct an instance of an abstract class.

    - There can be a variable whose type is an abstract class,
      provided it contains a reference to an object of a concrete subclass.
      #+BEGIN_SRC java
        public abstract class Person {
            private String name;
            public Person(String name) { this.name = name; }
            public final String getName() { return name; }
            public abstract int getId();
        }

        public class Student extends Person {
            private int id;
            public Student(String name, int id) { super(name); this.id = id; }
            public int getId() { return id; }
        }

        Person p = new Student(“Fred”, 1729);
      #+END_SRC
*** TODO 4.1.9 Protected Access - 142
    - *CAUTION*:
      In Java,
      + ~protected~ grants package-level access
        and
      + it *ONLY* protects access from other packages.

        =From Jian=
        In another words, if in the same package, it seems ~protected~ takes
        *NO effect*.

      =From Jian=
      I lift this *CAUTION* from the end of this section in the book to here as
      the _FIRST note_ of this section. I think it should be here, or the reader
      may ignore this, which is what I experienced (I was not clear with this
      point for a long time -- more than a year!).

    - ~protected~:
      1. Restrict a /method/ to /subclasses/ ONLY,

      2. _less commonly_, to allow /subclass methods/ to access an /instance
         variable of a superclass/.

    - For example,
      #+BEGIN_SRC java
        package com.horstmann.employees;

        public class Employee {
            protected double salary;
            // ...
        }
      #+END_SRC

      #+BEGIN_SRC java
        package com.horstmann.managers;

        import com.horstmann.employees.Employee;

        public class Manager extends Employee {
            // ...
            public double getSalary()
            {
                return salary + bonus;  // OK to access protected salary variable
            }
        }
      #+END_SRC

    - =TODO= =TODO= =???= =EXAMPLE???=
      The Manager class methods can peek inside the salary variable of Manager
      objects only, not of other Employee objects. This restriction is made so
      that you can’t abuse the protected mechanism by forming subclasses just to
      gain access to protected features.

    - /Protected fields/ should be used with caution.
      Once provided, you cannot take them away without breaking classes that are
      using them. =???=

    - TODO =???= page 151
      /Protected methods and constructors/ are *more common*.
      For example, the ~clone~ /method/ of the ~Object~ /class/ is ~protected~
      since it is somewhat tricky to use (see Section 4.2.4, “Cloning Objects,”
      page 151). =TODO=

*** TODO 4.1.10 Anonymous Subclasses - 143
    -
*** DONE 4.1.11 Inheritance and Default Methods - 144
    CLOSED: [2018-01-23 Tue 23:25]
    - In this situation, _class wins_
      #+BEGIN_SRC java
        public interface Named {
            default String getName() { return ""; }
        }

        public class Person {
            // ...
            public String getName() { return name; }
        }

        public class Student extends Person implements Named {
            // ...
        }
      #+END_SRC

    - You *MUST resolve* a conflict when the SAME /default method/ is inherited
      from _MULTIPLE_ /interfaces/.

    - The "classes win" rule ensures compatibility with Java 7.
      If you add /default methods/ to an /interface/, for compatibility, it has
      _no effect_ on code that worked *BEFORE* there were /default methods/.

*** 4.1.12 Method Expressions with ~super~ - 145
    - ~super::instanceMethod~
      Exmaple:
      #+BEGIN_SRC java
        public class Worker {
            public void work() {
                for (int i = 0; i < 100; ++i) System.out.println("Working");
            }
        }

        public class ConcurrentWorker extends Worker {
            public void work() {
                Thread t = new Thread(super::work);
                t.start();
            }
        }
      #+END_SRC

** DONE 4.2 ~Object~: The Cosmic Superclass - 145
   CLOSED: [2018-01-10 Wed 00:50]
   - Every class in Java directly or indirectly extends the class Object.
     It is the default, and no need to explicitly extend it.
     ~public class Employee { ... }~ is equivalent to
     ~public class Employee extends Object { ... }~

   - _NOTE_: TODO =EXAMPLE= =???=
     Arrays are classes.
     Therefore, it is legal to convert an array, even a primitive type array, to
     a reference of type ~Object~

   - =IMPORTANT=
     _Table 4-1 The Methods of the ~java.lang.Object~ Class_ - Page 149
     + ~String toString()~:
       Yields a string representation of this object,
       BY DEFAULT *the name of the class and the hash code*.

       For example, ~System.out.println(System.out)~ output a string like
       ~"java.io.PrintStream@2f6684"~

     + ~boolean equals(Object other)~:
       By default, two objects are equal if they are *identical*.

       Instead of obj.equals(other), consider the *null-safe* alternative
       ~Objects.equals(obj, other)~.

     + ~int hashCode()~:
       Equal objects must have the same hash code (=From Jian= this axiom must be
       kept, but /equal/ here depends on the specific definition through the
       ~equals~.)

       UNLESS /overridden/, the hash code is assigned in some way by the virtual
       machine.

     + ~Class<?> getClass()~:
       Yields the Class object describing the class to which this object belongs.

       For example, the string representation of ~(new Integer(3)).getClass()~ is
       ~java.lang.Integer~

       =TODO= ~Class<?>~

     + ~protected Object clone()~:
       By default, the copy is *shallow*.

     + ~protected void finalize()~:
       This method is called when this object is reclaimed by the garbage
       collector. *Don't override it*.

       =TODO= =???=

     + ~wait~, ~notify~, ~notifyAll~:
       See Chapter 10.
       =TODO= =TODO= =TODO=

*** DONE 4.2.1 The ~toString~ Method - 146
    CLOSED: [2017-05-16 Tue 16:00]
    - Many ~toString~ methods follow a format: ~className[field1, field2, ...]~.

      For example, implement the ~toString~ method of the ~Employee~ /class/ and
      the ~toString~ method of its /subclass/:
      #+BEGIN_SRC java
        public class Employee {
            public String toString() {
                return getClass().getName() + "[name=" + name
                    + ",salary=" + salary + "]";
            }
        }

        public class Manager extends Employee {
            // ...
            public String toString() {
                return super.toString() + "[bonus=" + bonus + "]";
            }
        }
      #+END_SRC
      Here we use ~getClass().getName()~ rather than the hard coded ="Employee"=
      literal guarantees this method does the right thing for /subclasses/ as
      well.

    - Whenever an /object/ is concatenated with a /string/, the Java compiler
      automatically invokes the ~toString~ method on the object.

      + *TIP*:
        Actually, more general than calling the ~toString~ method -- it even
        works for ~null~.

    - _CAUTION_:
      #+BEGIN_SRC java
        int[] primes = { 2, 3, 5, 7, 11, 13 };

        // yield a string such as "[I@1a46e30". The prefix `[I` denotes an array
        // of integers
        primes.toString();

        // yield the string [2, 3, 5, 7, 11, 13]
        Arrays.toString(primes);
      #+END_SRC
      + Multidimensional arrays should use the ~Arrays.deepToString~ method.

*** DONE 4.2.2 The ~equals~ Method - 148 =RE-READ= =IMPORTANT TIPS=
    CLOSED: [2018-01-09 Tue 21:50]
    - Override the ~equals~ method _ONLY_ for *state-based equality testing*, in
      which two objects are considered equal when they have the same contents.

      =From Jian= I don't think the _ONLY_ above is right. Sometimes we want to
      consider same contents objects are always identical (not from the sense of
      the address in memory). =EXAMPLE= =???=

    - _CAUTION_:
      Whenever you _override_ the ~equals~ method, you *MUST* provide a
      compatible ~hashCode~ method as well -- =TODO= see Section 4.2.3, “The
      hashCode Method” (page 150).

      + =From Jian=
        If the equality check and hashcode are related to some mutable fields
        of the objects, you should *NEVER* put this kind of objects into a
        hashbased collection. =Example are in the book Programming Scala=.

    - Example:
      Suppose we want to consider two objects of a class ~Item~ equal if their
      descriptions and prices match. Here is how you can implement the ~equals~
      method:
      #+BEGIN_SRC java
        public class Item {
            private String description;
            private double price;
            // ...
            public boolean equals(Object otherObject) {
                // A quick test to see if the objects are identical
                if (this == otherObject) return true;
                // Must return false if the parameter is null
                if (otherObject == null) return false;
                // Check that otherObject is an Item
                if (getClass() != otherObject.getClass()) return false;
                // Test whether the instance variables have identical values
                Item other = (Item) otherObject;
                return Objects.equals(description, other.description)
                    && price == other.price;
            }
            public int hashCode() { ... } // See Section 4.2.3
        }
      #+END_SRC
      Every line of the code above has its reason to be there:
      =PAGE 149=

    - _TIP_:
      Use ~Arrays.equals~ to check the contents of two arrays.

    - When you define the ~equals~ method for a /subclass/, first call ~equals~
      on the /superclass/.

      This is the complexity of Programming languages, like Java, that have
      /subtypings/.

    - _NOTE_:
      =TODO= Re-READ the Java API ~java.sql.Timestamp~
      =IMPORTANT=

    - There is one (=From Jian= maybe ONLY one) situation where the ~instanceof~
      test makes sense: if the notion of equality is fixed in the /superclass/ and
      never varies in a /subclass/.
      + For example,
        this is the case if we compare employees by ID. In that case, make an
        ~instanceof~ test and declare the ~equals~ method as ~final~.
        #+BEGIN_SRC java
          public class Employee {
              private int id;
              // ...
              public final boolean equals(Object otherObject) {
                  if (this == otherObject) return true;
                  if (!(otherObject instanceof Employee)) return false;
                  Employee other = (Employee) otherObject;
                  return id == other.id;
              }

              public int hashCode() { /* ... */ }
          }
        #+END_SRC

*** DONE 4.2.3 The ~hashCode~ Method - 150 =RE-READ= =IMPORTANT TIPS=
    CLOSED: [2018-01-09 Tue 22:30]
    - Two UNEQUAL objects should be a *high probability* that their /hashcode/
      are *DIFFERENT*.

    - The ~hashCode~ and ~equals~ methods MUST be *compatible*.
      As a result, when you *REDEFINE* ~equals~, you almost always need to
      *REDEFINE* the ~hashCode~ to make it compatible with the new ~equals~.

    - An example,
      the ~String~ class uses the following algorithm to compute the hash code:
      #+BEGIN_SRC java
        int hash = 0;

        for (int i = 0; i < length(); i++) {
            hash = 31 * hash + charAt(i);
        }
      #+END_SRC

    - If your want to implement a ~hashCode~ method in the way of simply
      combining the hash codes of the instance variables, use the ~Objects.hash~
      method, an varargs method, which is, more importantly, *null-safe*.

    - If your class has instance variables that are arrays,
      compute their hash codes
      1. first with the static ~Arrays.hashCode~ method, which computes a hash
         code composed of the hash codes of the array elements.

      2. then pass the result to ~Objects.hash~.

    - _CAUTION_:
      + In an /interface/, you can *never* make a /default method/ that redefines
        one of the methods in the ~Object~ class.

      + In particular, an /interface/ *CANNOT* define a /default method/ for
        ~toString~, ~equals~, or ~hashCode~.

      This is the consequence of the *classes win rule* =TODO= (see Section
      4.1.11, “Inheritance and Default Methods,” page 144), such a method could
      never win against ~Object.toString~, ~Object.equals~, or ~Object.hashCode~.
      =TODO= =IMPORTANT=

*** DONE 4.2.4 Cloning Objects - 151 =RE-READ= =IMPORTANT TIPS=
    CLOSED: [2018-01-10 Wed 00:50]
    In this section, you will learn how to override the ~clone~ method.

    - Override ~clone~ is *complex*, and it is also *rarely necessary*.
      Do NOT do this unless you have a good reason.

      + *LESS than* 5% of the /classes/ in the standard Java library implement
        ~clone~.

    - The clone method is declared as protected in the Object class, so you must
      override it if you want users of your class to clone instances.
      =TODO= =???=

    - The ~Object.clone~ method makes a /shallow copy/.
      This is fine if the variables are primitive or immutable.

    - It may also be that cloning is impossible or not worth the trouble.
      For example, it would be very challenging to clone a Scanner object.

    - tagging interface (marker interface) ::
         A kind of /interface/ that does *NOT* contain any /method/.
         If will be check when a /class/ that implements it call certain
         method(s).

      + For example,
        the ~Cloneable~ /interface/.
        When call the method ~clone~, it will check if this /interface/ is
        implemented or NOT. If NOT, throw a ~CloneNotSupportedException~.

    - In general, when you implement a class, you need to decide whether
      + You do not want to provide a clone method, or
        * *Solution*:
          Simply do nothing.

        * *Result*:
          - Your /class/ will inherit the ~clone~ method,

          - *NO* user of your /class/ will be able to call it since it is
            ~protected~.


      + The inherited clone method is acceptable, or
        * *Solution*:
          1. Must implement the ~Cloneable~ /interface/.

          2. Override the ~clone~ method by:
             + *raise* the /scope/ from ~protected~ to ~public~
             + *change* the _return type_.

          3. Finally, you need to deal with the /checked exception/
             (=TODO= in Chapter 5) ~CloneNotSupportedException~
             You *MUST* either _declare_ or _catch_ it:
             + If your /class/ is ~final~, you can _catch_ it.

             + Otherwise, declare the exception since it is possible that a
               /subclass/ might again want to throw it.

             #+BEGIN_SRC java
               public class Employee implements Cloneable {
                   // ...
                   public Employee clone() throws CloneNotSupportedException {
                       return (Employee) super.clone();
                   }
               }
             #+END_SRC
             The /cast/ ~(Employee)~ is *NECESSARY* since the return type of
             ~Object.clone~ is ~Object~.

        * *Result*:
          Clonable.

      + The clone method should make a /deep copy/.
           =TODO= =TODO=
        * Do NOT need to use the ~Object.clone~ method at all.
          For example,
          #+BEGIN_SRC java
            public Message clone() {
                Message cloned = new Message(sender, text);
                cloned.recipients = (ArrayList<String>)new ArrayList<>(recipients);
                return cloned;
            }
          #+END_SRC

          - Alternatively, you can call ~clone~ on the /superclass/ _mutable
            instance variables_. =TODO= =EXAMPLE=

        * The ~ArrayList~ /class/ implements the ~clone~ method, yielding a
          /shallow copy/. This is OK for primitive type like ~String~ above.

          *In general, we would have had to /clone/ each element as well*.

          For historical reasons, the ~ArrayList.clone~ method has return type
          ~Object~. You need to use a cast, or else the cloned object that
          contains this non-cast cloned ~ArrayList~ will NOT work well.
            However, the /cast/ like
          ~cloned.recipients = (ArrayList<String>) recipients.clone();~ will
          cause a warning. See Chapter 6 =TODO= -- the cast cannot be fully
          checked at runtime, and you will get a *warning*. Try to _suppress the
          warning_ with an /annotation/ (can ONLY be attched to a /declaration/)

          The complete solution:
          #+BEGIN_SRC java
            // NOT throw `CloneNotSupportedException`!
            // Retionale:
            // 1. The class is `final` and implements `Cloneable`
            // 2. The `ArrayList.clone` does NOT throw the exception.
            public Message clone() {
                try {
                    Message cloned = (Message) super.clone();
                    @SuppressWarnings("unchecked") ArrayList<String> clonedRecipients =
                        (ArrayList<String>) recipients.clone();
                    cloned.recipients = clonedRecipients;
                    return cloned;
                } catch (CloneNotSupportedException ex) {
                    return null; // Can't happend
                }
            }
          #+END_SRC

    - _NOTE_:
      /Arrays/ have a public ~clone~ method whose return type is the same as the
      type of the array. *NO cast required*.

** DONE 4.3 Enumerations - 154 =RE-READ=
   CLOSED: [2017-05-16 Tue 17:43]
   - Example:
     #+BEGIN_SRC java
       public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE };
     #+END_SRC

*** DONE 4.3.1 Methods of Enumerations - 155
    CLOSED: [2017-05-16 Tue 17:10]
    - SINCE each /enumerated type/ has a fixed set of instances,
      ~equals~ is not necessary, use ~==~ is OK (~equals~'s of /enums/ always
      call ~==~).

    - *NO NEED* to create the ~toString~ method for your /enumeration/, and it
      AUTOMATICALLY provided to yield the name of the enumerated object.
      For example, the *NAMES* of the /enumerated objects/ are unsurprisingly:
      ="SMALL"=, ="MEDIUM"=, ="LARGE"=, and ="EXTRA_LARGE"=.

    - Get a /enumeration object/ from its name in string:
      ~Size notMySize = Size.valueOf("SMALL");~

    - ~Size[] allValues = Size.values();~
      =From Jian= Order??? As definition???

    - *TIP*:
      Traverse all instances of an enumerated type:
      ~for (Size s : Size.values()) { System.out.println(s); }~

    - The ~ordinal~ method yields the position of an instance in the ~enum~
      declaration, counting from _zero_.
      + Example: ~Size.MEDIUM.ordinal()~ returns 1.
      + BE CAREFUL! The values shift if new constants are instered, which means
        you *CANNOT* expect the ~ordinal~ method of a specific
        /enumeration object/ always returns the same result.

    - Every enumerated type automatically implements ~Comparable<E>~, allowing
      *comparisons ONLY against its own objects*. The comparison is by
      /oridinal values/.

    - _NOTE_:
      Technically, an /enumerated type/ ~E~ *extends* the class ~Enum<E>~ from
      which it inherits the ~compareTo~ method as well as the other methods
      described in this section.
      Table 4-2 Methods of the ~java.lang.Enum<E>~ Class

*** DONE 4.3.2 Constructors, Methods, and Fields - 156
    CLOSED: [2017-05-16 Tue 17:10]
    - Add constructors, methods, and fields to an enumerated type, if you want.
      For example,
      #+BEGIN_SRC java
        public enum Size {
            SMALL("S"), MEDIUM("M"), LARGE("L"), EXTRA_LARGE("XL");

            private String abbreviation;

            // `private` by default for a `enum`
            Size(String abbreviation) {
                this.abbreivation = abbreviation;
            }

            public String getAbbreviation() { return abbreviation; }
        }
      #+END_SRC
      Each instance of the enumeration is guaranteed to be constructed exactly
      once.

    - _NOTE_:
      _The constructor of an enumeration is always private_.
      You can omit the ~private~ modifier, as in the preceding example.

      It is a _syntax error_ to declare an ~enum~ /constructor/ as ~public~ or
      ~protected~.
      =From Jian= *ONLY* ~private~ can help to guarantee _only construct once_.

*** DONE 4.3.3 Bodies of Instances - 157
    CLOSED: [2017-05-16 Tue 17:19]
    - You can add methods to each individual ~enum~ instance, but they have to
      override methods defined in the enumeration.
      For example, to implement a calculator:
      #+BEGIN_SRC java
        public enum Operation {
            ADD {
                public int eval(int arg1, int arg2) { return arg1 + arg2; }
            },
            SUBTRACT {
                public int eval(int arg1, int arg2) { return arg1 - arg2; }
            },
            MULTIPLY {
                public int eval(int arg1, int arg2) { return arg1 * arg2; }
            },
            DIVIDE {
                public int eval(int arg1, int arg2) { return arg1 / arg2; }
            };

            public abstract int eval(int arg1, int arg2);
        }

        Operation op = /* ... */;
        int result = op.eval(first, second);
      #+END_SRC

    - _NOTE_:
      Technically,
      _each of these constants belongs to an anonymous subclass of ~Operation~._

      Anything that you could place into an anonymous subclass body you can also
      add into the body of a member.

*** DONE 4.3.4 Static Members - 157
    CLOSED: [2017-05-16 Tue 17:35]
    - It is _LEGAL_ for an enumeration to have /static members/.

      HOWEVER, you have to BE CAREFUL WITH _construction order_.
        The /enumerated constants/ are constructed _BEFORE_ the /static members/,
      so you *CANNOT* refer to any /static members/ in an /enumeration
      constructor/.

    - An *ILLEGAL* example:
      #+BEGIN_SRC java
        public enum Modifier {
            PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, ABSTRACT;
            private static int maskBit = 1;
            private int mask;
            public Modifier() {
                mask = maskBit; // Error -- cannot access static variable in constructor
                maskbit *= 2;
            }

            // ...
        }
      #+END_SRC

      REMEDY
      #+BEGIN_SRC java
        public enum Modifier {
            PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, ABSTRACT;
            private int mask;

            static {
                int maskBit = 1;
                for (Modifier m : Modifier.values()) {
                    m.mask = maskBit;  // ???? How can this happend: access private field directly?
                    maskBit *= 2;
                }
            }
        }
      #+END_SRC

      Once the /enumeration constants/ have been constructed, /static variable
      initializations/ and /static initializers/ run in the usual top-to-bottom
      fashion.

    - NOTE
      Enumerated types can be nested inside classes.
      Such nested enumerations are implicitly static nested classes -- that is,
      their methods cannot reference instance variables of the enclosing class.

*** DONE 4.3.5 Switching on an Enumeration - 158
    CLOSED: [2017-05-16 Tue 17:43]
    - Enumeration constants can be used in a ~switch~ statement.
      For example,
      #+BEGIN_SRC java
        enum Operation { ADD, SUBTRACT, MULTIPLY, DIVIDE };

        public static int eval(Operation op, int arg1, int arg2)
        {
            int result = 0;

            switch (op)
            {
                case ADD:      result = arg1 + arg2; break;
                case SUBTRACT: result = arg1 - arg2; break;
                case MULTIPLY: result = arg1 * arg2; break;
                case DIVIDE:   result = arg1 / arg2; break;
            }

            return result;
        }
      #+END_SRC
      You use ~ADD~, and it *MUSTN'T BE* ~Operation.ADD~, inside the ~switch~
      statement -- the type is _inferred_ from the type of the expression on
      which the ~switch~ is computed.

    - NOTE
      The language specification _encourages_ the compilers to give a WARNING if
      a switch on an enumeration is _not exhaustive_.

      However, _the Oracle compiler does NOT produce such a warning_

    - _TIP_
      Outside a ~switch~, if you want to use the ~enum~ constants by their simple
      names, you can use a _static import declaration_ like
      ~import static com.horstmann.corejava.Size.*;~.

** TODO 4.4 Runtime Type Information and Resources - 159
   In Java,
   + you can find out at /runtime/ to which /class/ a given /object/ belongs.

   + you can also find out *how* the /class/ was _loaded_
     and
     *load* its /resources/ (associated data).

*** DONE 4.4.1 The Class ~Class~ - 159
    CLOSED: [2018-01-10 Wed 01:22]
    =From Jian=
    Remember all the results of the /methods/ we talk about in this section can
    be get /at runtime/!!!

    - The ~Class<?> getClass()~ method.
      *NOTE* =TODO= Chapter 6, explain the ~<?>~ of ~Class<?>~

    - =From Jian=
      The type name ~Class~ is not accurate, and we can even say it's MISLEADING!

      The returned things can be /class/, as well as /interfaces/, /primitive
      types/, and ~void~, and the last three are *NOT* /class/.

    - =From Jian=
      #+BEGIN_SRC java
        class ABC{}
        ABC abc = new ABC();
        // Here you cannot use Class<ABC>
        Class<?> c1 = abc.getClass();              // it works
        Class<? extends ABC> c1 = abc.getClass();  // it works
      #+END_SRC

    - Dual operation:
      + ~Class~ -----> class name in ~String~: ~getName()~
        * *CAUTION*:
          - The ~getName~ method returns *strange names* for /array types/. For
            example:
            + ~String[].class.getName()~ returns ="[Ljava.lang.String;"=
            + ~int[].class.getName()~ returns ="[I"=

            This notation has been used _since archaic times_ in the virtual
            machine.

          - Use ~getCanonicalName~ instead to get names such as
            ="java.lang.String[]"= and ="int[]"=.

      + class name in ~String~ -----> ~Class~: ~forName(className)~
        * The ~className~ above must be the same as the one gotten through the
          ~getName()~ /method/.

          You cannot use the name gotten from ~getCannonicalName~

    - The ~getName()~ results are used _for JVM_.
      The ~getCannonicalName()~ results are used _for human to read_.

    - *CAUTION*
      The ~Class.forName~ method, as well as many other methods =???= =TODO=
      used with /reflection/, throws /checked exceptions/
      ~ReflectiveOperationException~ when something goes wrong.

    - The ~Class.forName~ method is intended for constructing ~Class~ objects for
      classes that _MAY *NOT* be known at /compile time/._

      If you know in advance which class you want, use a /class literal/
      instread: ~Class<?> cl = java.util.Scanner.class;~, which can also be
      written as ~Class<ABC> c2 = ABC.class;~.

    - The virtual machine _manages a *UNIQUE* ~Class~ object for each type_.
      Therefore, you can use the ~==~ operator to compare class objects.

      Though the ~equals~ /method/ still also work, it's not as clear as ~==~ for
      this usage in semantics for the programmers who read the code.

    - Table 4-3 Useful Methods of the ~java.lang.Class<T>~ /Class/
      Table 4-3 Useful Methods of the ~java.lang.Class<T>~ /Class/ (Continued)
      =TODO= =TODO= =IMPORTANT= =Re-Read=

    - Table 4-4 Methods of the ~java.lang.reflect.Modifier~ /Class/
      =TODO= =???=

*** DONE 4.4.2 Loading Resources - 162
    CLOSED: [2018-01-10 Wed 01:31]
    - One useful service of the ~Class~ /class/ is to locate /resources/ that
      your program may need, such as configuration files or images.

    - If you place a /resource/ into the *same directory* as the /class file/,
      you can open an /input stream/ to the file like this:
      #+BEGIN_SRC java
        InputStream stream = MyClass.class.getResourceAsStream("config.txt");
        Scanner in = new Scanner(stream);
      #+END_SRC

    - NOTE:
      Some /legacy methods/ (=???= =From Jian= try to get a list!!!) such as
      ~Applet.getAudioClip~ and the ~javax.swing.ImageIcon~ constructor read
      data from a ~UR~ /object/. In that case, you can use the ~getResource~
      /method/ which returns a _URL to the resource_.

    - /Resources/ can have subdirectories which can be relative or absolute.
        For example, ~MyClass.class.getResourceAsStream("/config/menus.txt")~
      locates =config/menus.txt= in the directory that contains _the root of the
      /package/ to which ~MyClass~ belongs_. =???= =???= =???=
      =TODO= =TODO= =TODO=

    - If you package classes into JAR files,
      zip up the /resources/ together with the /class files/, and they will be
      located as well.

*** DONE 4.4.3 Class Loaders - 163
    CLOSED: [2018-01-20 Sat 20:58]
    - A /class file/ can be located
      + on a file system
      + in a JAR file
      + at a remote location
      + in memory (dynamically constructed)

    - class loader :: it
      1. loads the bytes
      2. turning them into a /class/ or /interface/ in the virtual machine.

    - The virtual machine loads class files on demand,
      1. _starting with_ the /class/ whose ~main~ /method/ is to be invoked.

      2. That /class/ will *depend on* other /classes/, which will be loaded
         together with the /classes/ that they *depend on*.

    - When executing a Java program, _AT LEAST_ *THREE* /class loaders/ are
      involved.
      1. The /bootstrap class loader/:
         it loads the most fundamental Java library classes.
         _It is a part of the virtual machine_.

      2. The /platform class loader/:
         it loads other library classes.
         *UNLIKE* the classes loaded with the /bootstrap class loader/,
         _platform class permissions can be configured with a security policy_.

      3. The /system class loader/:
         it loads the application classes.
         It locates classes in the directories and JAR files on the /class path/
         and /module path/.

    - *CAUTION*:
      In =PREVIOUS releases= (=TODO= =???=) of the Oracle JDK,
      the /platform and system class loaders/ *WERE* instances of the
      ~URLClassLoader~ /class/. *This is no longer the case*.

      Some programmers *used* the ~getURLs~ /method/ of the ~URLClassLoader~ to
      find the /class path/.
        Use ~System.getProperty( "java.class.path")~ *instead*.

    - You can load /classes/ from a _directory_ or _JAR file_ that is *NOT*
      already on the /class path/, by creating your own ~URLClassLoader~
      instance. This is commonly done to load plugins.
      #+BEGIN_SRC java
        URL[] urls = {
            new URL("file:///path/to/directory/"),
            new URL("file:///path/to/jarfile.jar")
        };

        String className = "com.mycompany.plugins.Entry";
        try (URLClassLoader loader = new URLClassLoader(urls)) {
            Class<?> cl = Class.forName(className, true, loader);
            // Now construct an instance of cl—see Section 4.5.4
            // ...
      #+END_SRC

    - *CAUTION*:
      The _second_ parameter in the call
      ~Class.forName(className, true, loader)~
      ensures that the /static initialization/ of the /class/ happens *after*
      loading. You definitely want that to happen.

      Do *NOT* use the ~ClassLoader.loadClass~ /method/. It does *NOT* run the
      /static initializers/.

    - *NOTE*:
      The ~URLClassLoader~ loads /classes/ from the /file system/.
      If you want to load a /class/ from somewhere else, you need to write /your
      own class loader/. The only method you need to implement is ~findClass~,
      like this:
      #+BEGIN_SRC java
        public class MyClassLoader extends ClassLoader {
            // ...
            @Override public Class<?> findClass(String name)
                throws ClassNotFoundException
            {
                byte[] bytes = // the bytes of the class file
                return defineClass(name, bytes, 0, bytes.length);
            }
        }
      #+END_SRC
      =TODO=
      See Chapter 14 for an example in which classes are compiled into
      memory and then loaded.

*** TODO 4.4.4 The Context Class Loader - 164
    - Most of the time you _don't have to worry about_ the /class loading
      process/. /Classes/ are transparently loaded as they are required by other
      /classes/.

    - However, if a method loads classes dynamically, and that method is called
      from a class that itself was loaded with another class loader, then
      problems can arise.

    - Here is a specific example.
      =TODO=
      =TODO=
      =TODO=
      =TODO=
      =TODO=

    - =TODO=

    - *TIP*:
      =TODO=

*** TODO 4.4.5 Service Loaders - 166

** TODO 4.5 Reflection - 168
   - /Reflection/ allows a program
     + to inspect the contents of objects at runtime
     + to invoke arbitrary methods on them.

   - This capability is useful for implementing tools such as /object-relational
     mappers/ or /GUI builders/. =TODO= =???=

*** DONE 4.5.1 Enumerating Class Members - 168
    CLOSED: [2018-01-21 Sun 05:04]
    - The THREE /classes/ ~Field~, ~Method~, and ~Constructor~
      + They are in the package ~java.lang.reflect~

      + _ALL THREE_ have a /method/ called ~getName~ that returns the name of the
        member.

      + The ~Field~ /class/ has a /method/ ~getType~ that returns an object,
        again of type ~Class~, that describes the /type of a field/.

      + The ~Method~ and ~Constructor~ /classes/ have /methods/ to report the
        /types of the parameters/

      + The ~Method~ class also reports the /return type/.

      + _ALL THREE_ of these /classes/ also have a /method/ called ~getModifiers~
        that returns *an integer, with various bits turned on and off*, that
        describes the /modifiers/ used (such as ~public~ or ~static~).

        * You can use /static methods/ such as ~Modifier.isPublic~ and
          ~Modifier.isStatic~ to analyze the integer that ~getModifiers~ returns.

        * The ~Modifier.toString~ returns _a string of all modifiers_.

    - The ~getFields~, ~getMethods~, and ~getConstructors~ /methods/ of the
      ~Class~ /class/ return *arrays of the ~public~ /fields/, /methods/, and
      /constructors/* that the /class/ supports; this includes public inherited
      members.

    - The ~getDeclaredFields~, ~getDeclaredMethods~, and ~getDeclaredConstructors~
      /methods/ return *arrays consisting of _ALL_ /fields/, /methods/, and
      /constructors/* that are declared in the /class/.
        This includes ~public~, ~private~, /package/ (no modifier), and
      ~protected~ members, but *NOT members of /superclasses/*.

    - The ~getParameters~ /method/ of the ~Executable~ /class/, the common
      /superclass/ of ~Method~ and ~Constructor~, _returns_ an *array of
      ~Parameter~ objects* describing the /method parameters/.

    - NOTE:
      The _names of the parameters_ are *ONLY* available at /runtime/ if the
      /class/ has been compiled with the =-parameters= flag.
      =TODO= =???= =Try it=

    - For example, here is how you can PRINT _all methods of a class_:
      #+BEGIN_SRC java
        Class<?> cl = Class.forName(className);

        while (cl != null) {
            for (Method m : cl.getDeclaredMethods()) {
                System.out.println(
                    Modifier.toString(m.getModifiers()) + " " +
                    m.getReturnType().getCanonicalName() + " " +
                    m.getName() +
                    Arrays.toString(m.getParameters()));
            }
            cl = cl.getSuperclass();
        }
      #+END_SRC

      + This code can analyze *ANY* /class/ that the JVM can load -- *NOT* just
        the /classes/ that were available when the program was compiled.

    - *CAUTION*:
      As you will see in Chapter 15, =TODO=
      the Java platform /module system/ imposes *significant restrictions* on
      /reflective access/.
      + _By default_,
        ONLY classes *in the same module* can be analyzed through /reflection/.

      + If you don't declare /modules/, ALL your /classes/ *belong to a single
        module*, and they can ALL be accessed through /reflection/.

          However, the Java library /classes/ belong to *DIFFERENT modules*, and
        /reflective access/ to their *non-public* members is _restricted_.

*** DONE 4.5.2 Inspecting Objects - 170
    CLOSED: [2018-01-21 Sun 05:21]
    - ~Field~ ::  describes the /types/ and _names_ of an /object/'s /fields/.

    - These ~Field~ /objects/ can do more:
      They can access /field values/ in /objects/ that have the given /field/.

      For example, enumerate the contents of ALL fields of an object:
      #+BEGIN_SRC java
        for (Field f : obj.getClass().getDeclaredFields()) {
            f.setAccessible(true);
            Object value = f.get(obj);
            System.out.println(f.getName() + ":" + value);
        }
      #+END_SRC
      If the value is a primitive type value, a wrapper object is returned.

    - NOTE:
      + The ~f.setAccessible(true);~ above is important. It must be called before
        accessing if a gotten ~f~ /field/ is ~private~ in the /class/ declared it

      + The /module system/ or a /security manager/ =TODO= =???= can *BLOCK* the
        request and protect objects from being accessed in this way.
        * If this happens, the ~setAccessible~ /method/ throws an
          ~InaccessibleObjectException~ or ~SecurityException~.

        * Alternatively, you can call the ~trySetAccessible~ /method/ which
          simply returns ~false~ if the /field/ or /method/ is *NOT* accessible.

    - *CAUTION*:
      Mentioned in the NOTE above.

    - Once a /field/ is ACCESSIBLE, you can also _set it_.
      #+BEGIN_SRC java
        Field f = obj.getClass().getDeclaredField("salary");
        f.setAccessible(true);
        double value = f.getDouble(obj);
        f.setDouble(obj, value * 1.1);
      #+END_SRC
      + No matter /f/ value is ~double~ or ~Double~, this can work well.

*** DONE 4.5.3 Invoking Methods - 171
    CLOSED: [2018-01-21 Sun 21:36]
    #+BEGIN_SRC java
      Method m = ...;
      Object result = m.invoke(obj, arg1, arg2, ...);

      Method staticMethod = ...;
      Object result = staticMethod.invoke(null, arg1, arg2, ...);
    #+END_SRC

    - Example to obtain a method:
      #+BEGIN_SRC java
        // get a method `setName(String)` from the `Person` class
        Person p = ...;
        Method m = p.getClass().getMethod("setName", String.class);
        m.invoke(obj, "********");
      #+END_SRC

    - *CAUTION*: =TODO= =???= =WHY?=
      Even though ~clone~ is a /public method/ of *ALL* /array types/, it is
      *NOT* reported by ~getMethod~ when invoked on _a ~Class~ object describing
      an array_.

*** DONE 4.5.4 Constructing Objects - 171
    CLOSED: [2018-01-21 Sun 21:51]
    - To construct an /object/
      1. find the ~Constructor~ /object/
      2. call its ~newInstance~ /method/

    - Example:
      #+BEGIN_SRC java
        Constructor constr = cl.getConstructor(int.class);
        Object obj = constr.newInstance(42);
      #+END_SRC

    - *CAUTION*:
      + The ~Class~ /class/ has a ~newInstance~ /method/ (NOT a /method/ of
        ~Constructor~ as above) to construct an /object/ of the given /class/
        with the no-argument constructor.
          That /method/ is now *DEPRECATED* because it has a curious flaw:
        If the no-argument constructor throws a checked exception, the
        newInstance method rethrows it even though it isn't declared, thereby
        completely defeating the compile-time checking of checked exceptions.

      + Instead, you should call ~newInstance~ from a ~Constructor~ object, no
        matter how many parameters it have. For this case,
        ~cl.getConstructor().newInstance()~.
        =TODO= =More details=
        Then any /exception/ is wrapped inside an ~InvocationTargetException~.

    - Table 4-5 Useful Classes and Methods in the ~java.lang.reflect~ Package
      =IMPORTANT=

*** TODO 4.5.5 JavaBeans - 172
    - Java doesn't support /properties/ in syntax,
      but it has a convention in which properties correspond to ~getter/setter~
      pairs.

    - A ~JavaBean~ is a class with a no-argument constructor, /getter\slash{}setter/
      pairs, and any number of other methods.

    - The /getters/ and /setters/ *MUST* follow the specific pattern
      #+BEGIN_SRC java
        public PropertyType getProperty() { ... }
        public void setProperty(PropertyType newValue) { ... }
      #+END_SRC
      + A ~getSalary\slash{}setSalary~ pair gives rise to a property named ~salary~.

      + If the *first two letters* of the suffix are *uppercase*, then it is
        taken *verbatim*. For example, ~getURL~ yields a read-only /property/
        named ~URL~.

    - NOTE:
      For /Boolean properties/, you may use
      + either ~getProperty~
      + or ~isProperty~ (*preferred*)

    - _(De facto ~@Deprecated~)_
      JavaBeans have their origin in GUI builders, a lot of arcane rules.
      These features are *rarely used* nowadays.

    - It is a GOOD idea to use the standard classes for ~JavaBeans~ support
      WHENEVER you need to _work with arbitrary properties_.
      #+BEGIN_SRC java
        Class<?> cl = ...;
        BeanInfo info = Introspector.getBeanInfo(cl);
        PropertyDescriptor[] props = info.getPropertyDescriptors();

        String propertyName = ...;
        Object propertyValue = null;
        for (PropertyDescriptor prop: props)
        {
            if (prop.getName().equals(propertyName))
                propertyValue = prop.getReadMethod().invoke(obj);
        }
      #+END_SRC
      + For a given ~PropertyDescriptor~, call ~getName~ and ~getPropertyType~ to
        get the name and type of the /property/.

      + The ~getReadMethod~ and ~getWriteMethod~ yield ~Method~ /objects/ for the
        /getter/ and /setter/.

      + *UNFORTUNATELY*, there is *NO* /method/ to get the /descriptor/ for a
        given /property name/, so *you'll have to _traverse_ the array of
        descriptors*. This is WHY we use a /foreach iteration/ above.

*** DONE 4.5.6 Working with Arrays - 174
    CLOSED: [2018-01-23 Tue 06:26]
    - The ~isArray~ /method/ checks whether a given ~Class~ /object/ represents
      an /array/.

      If so, the ~getComponentType~ /method/ yields the ~Class~ describing the
      /type/ of the array elements.

    - For _further analysis_, or to _create arrays DYNAMICALLY_, use the ~Array~
      /class/ in the ~java.lang.reflect~ /package/.

    - Table 4-6 Methods of the ~java.lang.reflect.Array~ Class

    - _As an exercise_, let us implement the ~copyOf~ /method/ in the ~Arrays~
      /class/.
      Recall how this /method/ can be used to grow an array that has become full.
      #+BEGIN_SRC java
        Person[] friends = new Person[100];
        // ...
        // Array is full
        friends = Arrays.copyOf(friends, 2 * friends.length);
      #+END_SRC
      + *WRONG*:
        #+BEGIN_SRC java
          public static Object[] badCopyOf(Object[] array, int newLength) { // Not useful
              Object[] newArray = new Object[newLength];

              for (int i = 0; i < Math.min(array.length, newLength); i++)
                  newArray[i] = array[i];
              return newArray;
          }
        #+END_SRC
        You *CANNOT* cast the returned ~Object[]~ /array/ to the type you want!!!

        - The Java /arrays/ know the exact type of their elements.
          + If one /array/ is created as ~Object[]~, cast it to ~AnyOtherType[]~
            is *FORBIDDEN*.

          + If one /array/ is created as ~Type[]~, you can cast it to
            ~Object[]~ tempararily, and cast it back to ~Type[]~ later.


      + *RIGHT*:
        #+BEGIN_SRC java
          public static Object goodCopyOf(Object array, int newLength) {
              Class<?> cl = array.getClass();
              if (!cl.isArray()) return null;
              Class<?> componentType = cl.getComponentType();
              int length = Array.getLength(array);
              Object newArray = Array.newInstance(componentType, newLength);

              for (int i = 0; i < Math.min(length, newLength); i++)
                  Array.set(newArray, i, Array.get(array, i));
              return newArray;
          }
        #+END_SRC
        This time we use the ~newInstance~ /method/ of the ~java.lang.reflect.Array~,
        and return an ~Object~ type value. Since any /array/ is a /subtype/ of
        an ~Object~, we can cast the returned value to any /array type/ we want,
        even a /primitive type array/.
        #+BEGIN_SRC java
          int[] primes = { 2, 3, 5, 7, 11 };
          primes = (int[]) goodCopyOf(primes, 10);
        #+END_SRC

*** TODO 4.5.7 Proxies - 175
    - ~Proxy~ class :: it can create, *at runtime*, new /classes/ that implement
                       a given interface or set of interfaces.

    - The ~Proxy~ is _ONLY necessary_
      when you do *NOT yet know at compile time* which /interfaces/ you need to
      implement.

    - =TODO=

    - =TODO=

    - *CAUTION*:
      When the /invocation handler/ is called with a /method/ call that has *NO
      parameters*, the argument array is ~null~, NOT an ~Object[]~ array of
      length 0. For example, in the code above, if ~m~ has no parameter, use
      ~(Object proxy, Method m, null)~

      *That is utterly reprehensible and not something you should do in your own
      code.*
      =From Jian= Let me translate this sentence:
      This is BAD design. Do NOT design like this in your code!
** TODO Exercises - 177

* TODO 5. EXCEPTIONS, ASSERTIONS, AND LOGGING - 181
  - Exception-handling

  - ~assert~ statement: provides a structured and efficient way of expressing
    internal assumptions.

  - logging API: use it to keep a record of the various events, be they routine
    or suspicious, in the execution of your programs.

  - The key points of this chapter are: =TODO=
    1. In Java, /checked exceptions/ are tracked by the compiler.

    2. The try-with-resources statement automatically closes resources after
       normal execution or when an exception occurred.

    3. A stack trace describes all method calls that are pending at a point of
       execution.

    4. Loggers are arranged in a hierarchy, and they can receive logging messages
       with levels ranging from ~SEVERE~ to ~FINEST~.

    5. Log handlers can send logging messages to alternate destinations, and
       formatters control the message format.

    6. You can control logging properties with a log configuration file.

** DONE 5.1 Exception Handling - 182
   CLOSED: [2018-01-27 Sat 03:44]
*** DONE 5.1.1 Throwing Exceptions - 182
    CLOSED: [2017-05-15 Mon 21:55]
    Example:
    #+BEGIN_SRC java
      if (low > high) {
          throw new IllegalArgumentException(
              String.format("low should be <= high but low is %d and high is %d",
                  low, high));
      }
    #+END_SRC

*** DONE 5.1.2 The Exception Hierarchy - 183
    CLOSED: [2017-05-15 Mon 21:55]
    - Figure 5-1 The exception hierarchy

      Throwable
       /       \
      Error    Exception
       |            \
       |             Runtime Exception
       |               /   \
      Subclasses      /     \
      are unchecked -/       Subclasses
      exceptions             are checked
                             exceptions

    - ~Error~: exceptions that program cannot be expected to handle, such as
      memory exhaustion.

      For ~Error~, usually the only thing you can do is to give a message to the
      user.

    - ~Exception~: This is usually (or should be) Programmer-reported. Two
      categories:
      + /Unchecked exceptions/ are subclasses of ~RuntimeException~.
      + All other exceptions are /checked exceptions/.

    - See in the next section TODO
      programmers MUST
      + either _catch_ /checked exceptions/
        or
      + declare them in the method header.

      The compiler checks that these exceptions are handled properly.

    - _Note_:
      The exceptions that are subclasses of ~RuntimeException~ are not checked
      during compilation.

    - /Checked exceptions/ are used in situations where failure
      _should be anticipated_.

    - /Unchecked exceptions/ indicate logic errors caused by programmers, _NOT_
      by unavoidable external risks.

      For example, ~NullPointerException~
      Just about any method might throw one, and programmers shouldn't spend
      time on catching them. Instead, they should make sure that no ~null~'s are
      dereferenced in the first place.

    - Sometimes, Implementors need to use their judgment:
      + ~Integer.parseInt(str)~ can throw _unchecked_ ~NumberFormatException~
      + ~Class.forName(str)~ can throw _checked_ ~ClassNotFoundException~

      Rationale:
      It's possible to check whether a string is a valid integer before calling
      ~Integer.parseInt~.

      It's NOT possible to know whether a class can be loaded until you actually
      try to load it.

    - When create your own exception classes,
      it is a good idea to supply both
      + a no-argument constructor
        and
      + a constructor with a message string.

      For example,
      #+BEGIN_SRC java
        public class FileFormatException extends IOException {
            public FileFormatException() {}
            public FileFormatException(String message) {
                super(message);
            }
            // TODO: Also add constructors for chained exceptions—see Section 5.1.7
        }
      #+END_SRC

*** DONE 5.1.3 Declaring Checked Exceptions - 185
    CLOSED: [2018-01-26 Fri 09:26]
    - In the ~throws~ clause, you can *combine* /exceptions/ into a /common
      superclass/.
      _Whether or not that is a good idea depends on the /exceptions/._

    - *TIP*:
      The GOLDEN RULE of /exceptions/: *Throw early, catch late*.

    - When you *override* a /method/, =IMPORTANT=
      comparing to the /overrided superclass method/
      + it *CANNOT* throw *MORE* /checked exceptions/
      + it *CAN* throw *LESS* /checked exceptions/

    - *CAUTION*:
      =IMPORTANT=
      If the /superclass method/ has _NO ~throws~ clause_, then *NO*
      /overriding method/ can throw a /checked exception/.

    - Use ~@thorws~ tag (!! NOT /annotation/) to document when a /method/ throws
      a /checked\slash{}unchecked exception/.
        Do this only when it is necessary. For example,
      #+BEGIN_SRC java
        /*
         ,* @throws NullPointerException if filename is null
         ,* @throws FileNotFoundException if there is no file with name filename
         ,*/
      #+END_SRC

    - NOTE:
      You can only pass a /lambda expression/ that can throw a /checked
      exception/ to a /functional interface/ whose /method/ _declares that
      /exception/._

      (=From Jian= this rarely happen in my experience. In another words, /lambda
       expression with checked exception/ is NOT a friendly thing in Java. Hope
       there is a better way to deal with it in the future.
       *I cannot guess! Call for a genius*)

      For example, the call ~list.forEach(obj -> write(obj, "output.dat"));~ is
      an error since the ~accept(T t)~ /method/ of the ~Consumer<T>~ /interface/
      does _NOT throw any /checked exception/._
      #+BEGIN_SRC java
        public interface Consumer<T>
        {
            void accept(T t);
        }
      #+END_SRC

*** DONE 5.1.4 Catching Exceptions - 186
    CLOSED: [2018-01-26 Fri 09:32]
    #+BEGIN_SRC java
      try
      {
          statements
      }
      catch (ExceptionClass1 ex)
      {
          handler1
      }
      catch (ExceptionClass2 ex)
      {
          handler2
      } catch (ExceptionClass3 ex)
      {
          handler3
      }


      // From Java 7
      try
      {
          statements
      }
      catch (ExceptionClass1 | ExceptionClass2 | ExceptionClass3 ex)
      {
          handler
      }
    #+END_SRC

*** DONE 5.1.5 The Try-with-Resources Statement - 187
    CLOSED: [2018-01-26 Fri 10:32]
    - Pattern:
      + Before: (From Java 7 =???=)
        #+BEGIN_SRC java
          ArrayList<String> lines = ...;
          PrintWriter out = new PrintWriter("output.txt");
          lines.forEach(l -> out.println(l.toLowerCase()));
          out.close();
        #+END_SRC

      + Now:
        #+BEGIN_SRC java
          ArrayList<String> lines = ...;
          try (PrintWriter out = new PrintWriter("output.txt")) // Variable declaration
          {
              lines.forEach(l -> out.println(l.toLowerCase()));
          }

          // OR

          PrintWriter out = new PrintWriter("output.txt");
          try (out) // Variable declaration
          {
              lines.forEach(l -> out.println(l.toLowerCase()));
          }
        #+END_SRC

    - resource :: a /class/ implementing the ~AutoCloseable~ /interface/.

    - The ~AutoCloseable~ /interface/ has a *SINGLE* /method/:
      ~public void close() throws Exception~

    - NOTE:
      There is also a ~Closeable~ /interface/, which is a /subinterface/ of
      ~AutoCloseable~ and also has a *SINGLE* ~close~ /method/. However, that
      /method/ is declared to throw an ~IOException~.

    - You can declare *MULTIPLE* /resources/, separated by *semicolons*.
      =IMPORTANT=
      The /resources/ are *closed in REVERSE ORDER of their initialization*.

    - Q:
      Some ~close~ /methods/ can throw exceptions. Then what will happen???

      A:
      + If that happens when the try block completed normally, the exception is
        thrown to the caller.

      + If _ANOTHER_ /exception/ had been thrown, causing the ~close~ /methods/
        of the /resources/ to be called, and one of them (~close~'s) throws an
        /exception/, that /exception/ is likely to be of _lesser importance
        than the original one_.

        In this situation,
        * the _ORIGINAL_ /exception/ gets rethrown,
          and
        * the /exceptions/ from calling ~close~ are caught and attached as
          /“suppressed” exceptions/.

        =TODO=
        This is a very useful mechanism that would be tedious to implement by
        hand (see Exercise 5).

        When you catch the /primary exception/, you can *retrieve* the /secondary
        exceptions/ by calling the ~getSuppressed~ method:

        #+BEGIN_SRC java
          try
          {
              // ...
          }
          catch (IOException ex)
          {
              Throwable[] secondaryExceptions = ex.getSuppressed();
              // ...
          }
        #+END_SRC

        If you want to implement such a mechanism yourself in a (hopefully rare)
        situation when you can't use the /try-with-resources statement/, call
        ~ex.addSuppressed(secondaryException)~.

    - A /try-with-resources statement/ can OPTIONALLY have ~catch~ clauses that
      _catch any exceptions in the statement_.

*** DONE 5.1.6 The ~finally~ Clause - 189
    CLOSED: [2018-01-26 Fri 10:45]
    - The ~finally~ clause is executed when the try block comes to an end,
      + either normally
        or
      + due to an /exception/

    - Example (with a trap):
      #+BEGIN_SRC java
        BufferedReader in = null;
        try {
            in = Files.newBufferedReader(path, StandardCharsets.UTF_8);
            Read from in
                } catch (IOException ex) {
            System.err.println("Caught IOException: " + ex.getMessage());
        } finally {
            if (in != null) {
                in.close(); // Caution—might throw an exception
            }
        }
      #+END_SRC

      The ~in.close();~ can also cause an /exception/, but there is NO design in
      the code above deal with this.

      + =IMPORTANT=
        It is often better to rewrite a complex ~try/catch/finally~ statement
        as a /try-with-resources statement/ or by nesting a ~try/finally~ inside
        a ~try/catch~ statement -- see Exercise 6. =TODO=

*** DONE 5.1.7 Rethrowing and Chaining Exceptions - 190
    CLOSED: [2018-01-27 Sat 02:14]
    - This often happens when
      + You really want to stop running a program when some exceptions happen,
        but should be after logging it.

      + You don't know what to do, and choose to log and re-throw.

    - Pattern:
      #+BEGIN_SRC java
        try
        {
            // Do something
        }
        catch (CertainException ex)
        {
            logger.log(level, message, ex);
            throw ex;
        }
      #+END_SRC

    - NOTE: =???= =TODO=

    - Sometimes, you want to *change the class* of a /thrown exception/.

      =From Jian= A more formal form can be found in the book.
      For example, the user of this program may need a /different kind of
      exception/ to tell him/her what happened, rather than the details of the
      original cause.

      + Example:
        #+BEGIN_SRC java
          try
          {
              // Access the database
          }
          catch (SQLException ex)
          {
              throw new ServletException("database error", ex);
          }
        #+END_SRC
        A servlet encounter a database error,
        * the _user_ only need to know the servlet is at fault

        * since we can save the orginal /exception/ into another kind of
          /exception/ before throwing the latter, even for the _developer_, throw
          a new kind of /exception/ is acceptable -- he/she can retrieve the
          original /exception/ (through the ~getCause()~ /method/ for
          ~ServletException~).

      + _Not ALL_ /exception classes/ have a /constructor/ that takes as a
        parameter the *cause* of the /exception/.
        * Use ~initCause~ method
          #+BEGIN_SRC java
            try
            {
                // Access the database
            }
            catch (SQLexception ex)
            {
                Throwable ex2 = new CruftyOldException("database error");
                ex2.initCause(ex);
                throw ex2;
            }
          #+END_SRC

        * If you create you own /exception class/, you should provide, in
          addition to the *TWO* /constructors/ described in Section 5.1.2,
          #+BEGIN_SRC java
            public class FileFormatException extends IOException
            {
                // ...
                public FileFormatException(Throwable cause) { initCause(cause); }

                public FileFormatException(String message, Throwable cause)
                {
                    super(message);
                    initCause(cause);
                }
            }
          #+END_SRC

    - *TIP*:
      The /chaining technique (described above)/ is ALSO USEFUL if a /checked
      exception/ occurs in a /method/ that is _NOT ALLOWED to throw a /checked
      exception/._ You can
      1. catch the /checked exception/
      2. *chain* it to an /unchecked one/

*** DONE 5.1.8 Uncaught Exceptions and the Stack Trace - 192
    CLOSED: [2018-01-27 Sat 03:44]
    - A /stack trace/ is displayed when an exception is NOT caught anywhere.

    - stack trace :: a listing of all PENDING _method calls_ at the point where
                     the /exception/ was thrown.

    - The /stack trace/ is sent to ~System.err~ -- the stream of error messages.

    - You can set the /default uncaught exception handler/:
      #+BEGIN_SRC java
        Thread.setDefaultUncaughtExceptionHandler((thread, ex) -> {
                // Record the exception
        })
      #+END_SRC
      to do something before /an uncaught exception/ is thrown out.
      =From Jian= NOT catch and re-throw! *Uncaught*

    - NOTE:
      An /uncaught exception/ terminates the /thread/ in which it occurred.

      If your application ONLY has ONE /thread/, the program EXITS *after*
      INVOKING the /uncaught exception handler/.

    - For /checked exception/, you are FORBAD to just throw it out directly.
      If you don't know how to deal with it, try to print the /stack trace/ in
      the ~catch~ block throw the ~printStackTrace()~ method.

      + Save the /stack trace/ of an /exception/ to a /string/ in the ~catch~
        block:
        #+BEGIN_SRC java
          ByteArrayOutputStream out = new ByteArrayOutputStream();
          ex.printStackTrace(new PrintWriter(out));
          String description = out.toString();
        #+END_SRC

    - NOTE: =TODO= =Try=
      Use ~StackWalker~ to process the /stack trace/ in more detail.
      For example, prints all /stack frame/:
      #+BEGIN_SRC java
        StackWalker.walker = StackWalker.getInstance();
        walker.forEach(frame -> System.err.println("Frame: " + frame));
      #+END_SRC

*** DONE 5.1.9 The ~Objects.requireNonNull~ Method - 193
    CLOSED: [2018-01-26 Fri 10:55]
    - Convenient ~null~ checks
      #+BEGIN_SRC java
        public void process(String direction)
        {
            this.direction = Objects.requiresNonNull(direction);
            // ...
        }
      #+END_SRC
      A ~NullPointerException~ is thrown if ~direction~ is ~null~.

      _When you see a ~NullPointerException~ comes from ~requiresNonNull~, you
      know you did something wrong._

    - Provide message for the exception:
      ~this.direction = Objects.requireNonNull(direction, "direction must not be null");~

    - Provide a default value *eagerly* with the ~Objects.requireNonNullElse~
      /method/: ~this.direction = Objects.requireNonNullElse(direction, "North");~

    - Provide a default value *lazily* with the ~Objects.requireNonNullElseGet~
      /method/:
      #+BEGIN_SRC java
        this.direction = Objects.requireNonNullElseGet(direction,
            () -> System.getProperty("com.horstmann.direction.default"));
      #+END_SRC

** DONE 5.2 Assertions - 193
   CLOSED: [2017-05-16 Tue 14:25]
   - The assertion mechanism allows you
     + to put in checks during testing
       and
     + to have them automatically removed in the production code.

   - In Java, assertions are intended
     + as a debugging aid for validating internal assumptions,

     + NOT as a mechanism for enforcing contracts.
       (Throw an exception when you need enforce contracts)

*** DONE 5.2.1 Using Assertions - 194
    CLOSED: [2018-01-27 Sat 05:07]
    - Syntax:
      1. ~assert condition;~: evaluate the given condition, and throw an
         ~AssertionError~ if it is false.
         For example, ~assert x >= 0;~

      2. ~assert condition : expression;~: do the things above, and if the value
         of condition is false the expression here is turned into a string that
         becomes the message of the error object.
         For example, ~assert x >= 0 : x;~

*** DONE 5.2.2 Enabling and Disabling Assertions - 194
    CLOSED: [2018-01-27 Sat 05:07]
    - By default, assertions are disabled.

    - Enable them with the option ~-enableassertions~ or ~-ea~.
      For example, ~java -ea MainClass~.

      + No re-compilation is required because enabling or disabling assertions is
        handled by the class loader. =IMPORTANT=

      + You can even enable assertions in specific classes or in entire packages,
        for example:
        ~java -ea:MyClass -ea:com.mycompany.mylib... MainClass~

    - Disable assertions in certain classes and packages with the
      ~-disableassertions~ or ~-da~ option:
      ~java -ea:... -da:MyClass MainClass~

    - ~-ea~ and ~-da~ do NOT apply to the "system classes" that loaded without
      class loaders.

        Use ~enablesystemassertions~ or ~-esa~.

    - It is also possible to programmatically control the assertion status of
      /class loaders/ with the following methods:
      #+BEGIN_SRC java
        void ClassLoader.setDefaultAssertionStatus(boolean enabled);
        void ClassLoader.setClassAssertionStatus(String className, boolean enabled);
        void ClassLoader.setPackageAssertionStatus(String packageName,
                                                   boolean enabled);
      #+END_SRC
      As with the ~-enableassertions~ command-line option, the
      ~setPackageAssertionStatus~ method sets the assertion status for the given
      package and its subpackages.

** TODO 5.3 Logging - 195
   Logging is a kind of persistent record for collecting information during the
   running of a program.

*** DONE 5.3.1 Using Loggers - 195
    CLOSED: [2018-01-27 Sat 10:00]
    - The logging system manages a *DEFAULT* logger that you get by calling a
      /static method/ ~Logger.getGlobal()~.
      + Use the ~info~ /method/ to log an information message:
        ~Logger.getGlobal().info("Opening file " + fileName);~
        the record is printed like this:
        =Aug 04, 2014 09:53:34 AM com.mycompany.MyClass read INFO: Opening file data.txt=

      + You can change the /log level/.
        For example, if you call ~Logger.getGlobal().setLevel(Level.OFF);~ then
        you *turn off* /all log levels/, and nothing will be logged.

        =From Jian= We will see later that ~Level.OFF~ is a *switch*, not one of
        a /log level/.

    - NOTE
      Even if you set /log level/ to ~Level.OFF~, the ~"Opening file " + fileName~
      string will, of course, be created. When you care about the cost, use a
      no parameter lambda expression:
      ~Logger.getGlobal().info(() -> "Opening file " + fileName);~

*** DONE 5.3.2 Loggers - 196
    CLOSED: [2018-01-27 Sat 10:56]
    - Create a custom logger object:
      ~Logger logger = Logger.getLogger("com.mycompany.myapp");~

    - /logger/ *names* are is _hierarchical_.
      + There is *NO* semantics relathionship between a /package/ and its parent.

      + There is semantics relathionship between a /logger/ and its parent.

        For example, if you turn off the /logger/ ~"com.mycompany"~, then the
        /child logger/ are *ALSO* deactivated.

    - NOTE
      In this section, we introduced the ~java.util.logging~ framework, which is
      *NOT* universally loved, and there are alternatives with better performance
      and more flexibility.

      Many projects use a logging façade such as SLF4J (https://www.slf4j.org).
      =From Jian= Yes I see this in the apps in our research.

    - NOTE
      + Even the JVM does *NOT* love ~java.util.logging~, but for an entirely
        different reason: in order to have a minimal footprint, the most basic
        JVM /modules/ do *NOT* want to depend on the ~java.logging~ /module/
        that contains the ~java.util.logging~ /package/.

      + There is a lightweight ~System.Logger~ /interface/ that some JVM
        /modules/ use for logging.

      + On a full JVM, these logs are *REDIRECTED to* ~java.util.logging~, but
        they can also be redirected *elsewhere*.

      This is not a facility that is intended for application programmers, so you
      should use ~java.util.logging~ OR a logging façade.

*** DONE 5.3.3 Logging Levels - 197
    CLOSED: [2018-01-27 Sat 11:43]
    - There are _SEVEN_ logging levels:
      1. ~SEVERE~
      2. ~WARNING~
      3. ~INFO~
      4. ~CONFIG~
      5. ~FINE~
      6. ~FINER~
      7. ~FINEST~

    - *By default*, the top _THREE_ levels are actually logged.

    - There are /logging methods/ corresponding to each level, such as
      ~logger.warning(message)~, ~logger.fine(message)~, and so on.

      + If a /logging level/ is saved in a variable, you can set it in this way:
        #+BEGIN_SRC java
          Level level = ...;
          logger.log(level, message);
        #+END_SRC

    - *TIP*
      + The DEFAULT logging configuration logs all records with the levels
        ~SEVERE~, ~WARNING~, and ~INFO~.

      + You should use the other four levels for *debugging* messages that are
        useful for diagnostics but meaningless to the user. =HOW= =TODO= =???=

    - *CAUTION*
      If you set the /logging level/ to a value _finer than_ ~INFO~, you also
      need to *change* the _log handler configuration_. =HOW= The _DEFAULT log
      handler_ *SUPPRESSES* messages *below* ~INFO~.

      =TODO= =SOON=
      See Section 5.3.6, “Log Handlers” (page 200) for details.

*** TODO 5.3.4 Other Logging Methods - 197
    - x

*** TODO 5.3.5 Logging Configuration - 199
    - x

*** TODO 5.3.6 Log Handlers - 200
    - x

*** TODO 5.3.7 Filters and Formatters - 202
    - x

** TODO Exercises - 203

* TODO 6. GENERIC PROGRAMMING - 207
  - =TODO=
** DONE 6.1 Generic Classes - 208
   CLOSED: [2018-01-15 Mon 23:24]
   - generic class :: a /class/ with one or more /type parameters/.

   - *CAUTION*:
     /Type parameters/ *CANNOT* be instantiated with /primitive types/.
     =From Jian= Can this be changed from Java 10???? =TODO=

   - When you use the diamond syntax ~<>~, omit the type parameters from the
     /constructor/, the /type parameters/ for the /constructor/ are *inferred*.

** DONE 6.2 Generic Methods - 209
   CLOSED: [2018-01-16 Tue 20:31]
   - generic method :: a /method/ with /type parameters/.

   - /generic method/ can be a /method/ of
     + a regular class
       OR
     + a generic class.

   - Example (a /generic method/ of a /non-generic class/)
     #+BEGIN_SRC java
       public class Arrays
       {
           public static <T> void swap(T[] array, int i, int j)
           {
               T temp = array[i];
               array[i] = array[j];
               array[j] = temp;
           }
       }
     #+END_SRC

   - When calling a /generic method/, you do *NOT* need to specify the /type
     parameter/, which can be inferred. However, if you like, you still can
     supply the type explicitly in the form of (*before* the /method name/):
     ~Arrays.<String>swap(friends, 0, 1);~

   - Syntax in in the pattern of
     ~<access-control-modifier> [static] <T, K> <return type>~
     For example,
     ~public static <T> void swap(T[] array, int i, int j)~

** DONE 6.3 Type Bounds - 210
   CLOSED: [2018-01-16 Tue 20:52]
   - type bounds :: constraints applied on /type parameters/.

   - Example:
     #+BEGIN_SRC java
       public static <T extends AutoCloseable> void closeAll(ArrayList<T> elems)
               throws Exception {
           for (T elem : elems) elem.close();
       }
     #+END_SRC

   - =TODO=
     Exercise 14 has a more interesting variant of this method.

   - NOTE: =FROM JIAN= /covariance/, /contravariance/, and /non-variance/.
     In the above example,
     + if that /method/ accepts ~Array~, then
       ~public static void closeAll(AutoCloseable[] elems) throw Exception~

       This works because types, like ~PrintStream[]~, are the subtypes of
       ~AutoCloseable[]~.

     + HOWEVER, ~ArrayList<PrintStream>~ is *NOT* a /subtype/ of
       ~ArrayList<AutoCloseable>~. Using a bounded type parameter solves this
       problem

   - A /type parameter/ can have multiple /bounds/, such as
     ~T extends Runnable & AutoCloseable~

   - =IMPORTANT=
     If you have a /class/ as a /bound/, it *MUST* be the *FIRST* one in the
     /bounds/ list.

** TODO 6.4 Type Variance and Wildcards - 211
   - ~Array~'s in Java is /covariance/.

   - NOTE:
     *ALL* /generic types/ in Java are /invariant/.

   - In Java, you use /wildcards/ to specify how /method parameter/ and
     /return types/ should be allowed to vary.

     =IMPORTANT=
     This mechanism is sometimes called /use-site variance/.
     =TODO= You will see the details in the following sections.

*** DONE 6.4.1 Subtype Wildcards - 212
    CLOSED: [2018-01-16 Tue 22:11]
    - The ~get~ /method/ of ~ArrayList<E>~ has the /reutrn type/
      ~ArrayList<? extends Employee>~, and it is legal to do
      ~Employee e = staff.get(i);~

    - The ~add~ /method/ of ~ArrayList<E>~ does *NOT* has a
      ~ArrayList<? extends Employee>~ type parameter.

      If it were, there is *NO* /object/ that you can pass to this /method/.

    - In summary,
      + you can *convert* from ~? extends Employee~ to ~Employee~
      + you can *never convert* anything to ~? extends Employee~.

      This explains why you can read from an ~ArrayList<? extends Employee>~ but
      *CANNOT* write to it.

*** TODO 6.4.2 Supertype Wildcards - 213
    :LOGBOOK:
    CLOCK: [2018-01-16 Tue 22:24]
    :END:
    - *WRONG*
      #+BEGIN_SRC java
        public static void printAll(Employee[] staff, Predicate<Employee> filter) {
            for (Employee e : staff)
                if (filter.test(e))
                    System.out.println(e.getName());
        }
      #+END_SRC

    - *Right*
      #+BEGIN_SRC java
        public static void printAll(Employee[] staff, Predicate<? super Employee> filter)
        {
            for (Employee e : staff)
                if (filter.test(e))
                    System.out.println(e.getName());
        }
      #+END_SRC

    - In general,
      when you specify a /generic functional interface/ as a /method parameter/,
      you should use a ~super~ /wildcard/ -- /functions/ are naturally
      /contravriant/ in their /parameter types/.

    - NOTE:
      Some programmers like the “PECS” mnemonic for wildcards:
      *producer extends, consumer super*. An ~ArrayList~ from which you _read_
      values is a _producer_, so you use an _extends_ wildcard.

      For example, A ~Predicte~ to which you give values for testing is a
      /consumer/, and you use /super/.

*** TODO 6.4.3 Wildcards with Type Variables - 214
*** DONE 6.4.4 Unbounded Wildcards - 215
    CLOSED: [2018-01-17 Wed 20:25]
    If you need a generics, but you won't use the type parameter(s).
    Try the /unbounded wildcards/.

    - Example:
      #+BEGIN_SRC java
        public static boolean hasNulls(ArrayList<?> elements)
        {
            for (Object e: elements)
            {
                if (e == null) return true;
            }

            return false;
        }
      #+END_SRC
      + Since the ~if (booleanVal) return booleanVal'~ is in the loop, you cannot
        replace it with ~return booleanVal~ -- if this ~booleanVal~ is ~false~,
        we do *NOT* want to ~return~ it.

      + You are free to replace the ~?~ above with ~T~, but it not necessary and
        it will introduce noise info.

*** DONE 6.4.5 Wildcard Capture - 216
    CLOSED: [2018-01-17 Wed 20:33]
    You can use ~?~ as a /type argument/, but *NOT* as a /type/.
    - You *CANNOT* do
      #+BEGIN_SRC java
        public static void swap(ArrayList<?> elements, int i, int j)
        {
            ? temp = elements.get(i);  // Won't work
            elements.set(i, elements.get(j));
            elements.set(j, temp);
        }
      #+END_SRC

    - Walk around
      #+BEGIN_SRC java
        public static void swap(ArrayList<?> elements, int i, int j)
        {
            swapHelper(elements, i, j);
        }

        public static <T> void swapHelper(ArrayList<T> elements, int i, int j)
        {
            T temp = elements.get(i);
            elements.set(i, elements.get(j));
            elements.set(j, temp);
        }
      #+END_SRC

    - The thing we gain from the work around:
      Simpler API instead of a /generic method/.

      =From Jian= I don't think so!!! I prefer to use the /type parameter/ from
      the very beginning.
      #+BEGIN_SRC java
        public static <T> void swapHelper(ArrayList<T> elements, int i, int j)
        {
            T temp = elements.get(i);
            elements.set(i, elements.get(j));
            elements.set(j, temp);
        }
      #+END_SRC

** DONE 6.5 Generics in the Java Virtual Machine - 216
   CLOSED: [2018-01-17 Wed 22:36]
*** DONE 6.5.1 Type Erasure - 217
    CLOSED: [2018-01-17 Wed 21:27]
    - Case 1:
      The ~Entry~ /class/ we met in Section 6.1 will be compiled into one with
      *raw* type.
      #+BEGIN_SRC java
        public class Entry
        {
            private Object key;
            private Object value;

            public Entry(Object key, Object value)
            {
                this.key = key;
                this.value = value;
            }

            public Object getKey() { return key; }
            public Object getValue() { return value; }
        }
      #+END_SRC

    - Case 2:
      With /bound/
      #+BEGIN_SRC java
        public class Entry<K extends Comparable<? super K> & Serializable,
                           V extends Serializable>
      #+END_SRC

      After type erasure, it becomes

      #+BEGIN_SRC java
        public class Entry
        {
            private Comparable key;
            private Serializable value;
            // ...
        }
      #+END_SRC

      *bounded type parameter is replaced with the _FIRST bound_.*

*** DONE 6.5.2 Cast Insertion - 217
    CLOSED: [2018-01-17 Wed 21:31]
    For code like
    #+BEGIN_SRC java
      Entry<String, Integer> entry = anInteger;
      String key = entry.getKey();
    #+END_SRC

    The compiler will insert a cast, and type will be checked at /runtime/.
    #+BEGIN_SRC java
      Entry<Object, Object> entry = anInteger;
      String key = (String) entry.getKey();
    #+END_SRC

*** DONE 6.5.3 Bridge Methods - 218
    CLOSED: [2018-01-17 Wed 22:36]
    You have definition:
    #+BEGIN_SRC java
      public class WordList extends ArrayList<String> {
          public boolean add(String e) {
              return isBadWord(e) ? false : super.add(e);
          }

          // ...
      }
    #+END_SRC

    You want to use this definition in this way:

    #+BEGIN_SRC java
      WordList words = aWordList;
      ArrayList<String> strings = words; // OK -- conversion to superclass
      strings.add("C++");
    #+END_SRC

    When you call the ~add~ method above, one would reasonably expect /dynamic
    method lookup/, rather than use the ~add~ method of ~ArrayList<String>~.

    Java implements this in this way:
    #+BEGIN_SRC java
      public boolean add(Object e)
      {
          return add((String) e);
      }
    #+END_SRC
    This input varies.

    - /Bridge methods/ can also be called when the /return type/ varies.
      #+BEGIN_SRC java
        public class WordList extends ArrayList<String>
        {
            public String get(int i)
            {
                return super.get(i).toLowerCase();
            }
        }
      #+END_SRC

      + In the ~WordList~ /class/, there are _TWO_ ~get~ /methods/:
        1. ~String get(int)~, which is defined in ~WordList~ written by the programmer.

        2. ~Object get(int i)~, which overrides the /method/ defined in ~ArrayList~,
           and it is *synthesized by the compiler*.

      The second one calls by the first one.
      #+BEGIN_SRC java
        public class WordList extends ArrayList<String>
        {
            // Synthesized.
            public Object get(int i)  // NOT legal Java code, but its bytecode form in JVM is OK!
            {
                return this.get(i);
            }

            public String get(int i)
            {
                return super.get(i).toLowerCase();
            }
        }

        WordList words = aWordList;
        words = aMethodReturnsWordList();
        ArrayList<String> strings = words; // OK -- conversion to superclass
        strings.get(0);
      #+END_SRC
      + Steps:
        1. ~ArrayList<String> strings~ calls ~Object get(int i)~, which is the
           /signature/ of the ~get~ inside ~ArrayList<String>~.

        2. However, /the real type of this object at runtime/ is ~WordList~,
           ~strings~ will call the ~Object get(int i)~ of ~WordList~, not that of
           the ~ArrayList<String>~.

        3. There is a /method/ *synthesized by the Java compiler* for ~WordList~
           to /override/ the ~Object get(int i)~ /method/ of its /super class/
           ~ArrayList<String>~, and we (NOT the compiler) know the return type
           is ~String~ (this is why the programmer write ~String get(int i)~).
           Therefore, the *synthesized method* body should return a call to the
           ~String get(int i)~ of ~WordList~.

      + *CAUTION*:
        *Same name* different /return types/ methods *CANNOT* be Java source
        code, but it be OK in JVM.

    - /Bridge methods/ are
      + _not only_ used for /generic types/.
      + _but also_ used to implement /covariant return types/.

      In chapter 4, you saw how you should declare a ~clone~ method with the
      appropriate /return type/:
      #+BEGIN_SRC java
        public class Employee implements Cloneable
        {
            public Employee clone() throws CloneNotSupportedException
            {
                // ...;
            }
        }
      #+END_SRC
      It is compiled into code with
      + ~Employee clone()~, which defined above by the programmer.

      + ~Object clone()~, which is a *synthesized* /bridge method/.
        The /bridge method/, again generated to make /dynamic method lookup/
        work (it will be found, when a /superclass/ of ~Employee~ ~clone~ method
        is called on a ~Employee~ object), and it should call the first method
        ~Employee clone()~.

** TODO 6.6 Restrictions on Generics - 220
   There are *several RESTRICTIONS* when using /generic classes and methods/ in
   Java:
   + some merely surprising
   + others genuinely inconvenient.

   MOST of them are _CONSEQUENCES of /type erasure/._

   =TODO= The following sections show you those that you will most likely
   encounter in practice.

*** TODO 6.6.1 No Primitive Type Arguments - 220
    The /generic type/ should be a /class/, the /subclass/ of ~Object~, and the
    /primitive types/ are *NOT* subclass of ~Object~ -- they are even NOT ANY
    /class/.

    - When the /generics/ were first introduced, this inconvinience was NOT
      considered a big deal -- after all, one can rely on /autoboxing/.

    - As the /generics/ are more commonly used today, the pain is *increasing*!

    - There is a profusion of /functional interfaces/ such as ~IntFunction~,
      ~LongFunction~, ~DoubleFunction~, ~ToIntFunction~, ~ToLongFunction~,
      ~ToDoubleFunction~ -- and that *ONLY* takes care of /unary functions/ and
      /three of the eight primitive types/.
      =TODO= =???= =TODO= =???=

*** TODO 6.6.2 At Runtime, All Types Are Raw - 220
    - xx

    - xxx

    - *CAUTION*:

    - *TIP*:

*** TODO 6.6.3 You Cannot Instantiate Type Variables - 221
*** TODO 6.6.4 You Cannot Construct Arrays of Parameterized Types - 223
*** TODO 6.6.5 Class Type Variables Are Not Valid in Static Contexts - 224
*** TODO 6.6.6 Methods May Not Clash after Erasure - 224
*** TODO 6.6.7 Exceptions and Generics - 225

** TODO 6.7 Reflection and Generics - 226
*** TODO 6.7.1 The ~Class<T>~ Class - 227
*** TODO 6.7.2 Generic Type Information in the Virtual Machine - 227

** TODO Exercises - 229

* TODO 7. COLLECTIONS - 235
** TODO 7.1 An Overview of the Collections Framework - 236
** TODO 7.2 Iterators - 240
** TODO 7.3 Sets - 242
** TODO 7.4 Maps - 243
** TODO 7.5 Other Collections - 247
*** TODO 7.5.1 Properties - 247
*** TODO 7.5.2 Bit Sets - 248
*** TODO 7.5.3 Enumeration Sets and Maps - 250
*** TODO 7.5.4 Stacks, Queues, Deques, and Priority Queues - 250
*** TODO 7.5.5 Weak Hash Maps - 251

** TODO 7.6 Views - 252
*** TODO 7.6.1 Small Collections - 252
*** TODO 7.6.2 Ranges - 253
*** TODO 7.6.3 Unmodifiable Views - 254

** TODO Exercises - 255

* TODO 8. STREAMS - 259
** TODO 8.1 From Iterating to Stream Operations - 260
** TODO 8.2 Stream Creation - 261
** TODO 8.3 The ~filter~, ~map~, and ~flatMap~ Methods - 263
   - NOTE
   - NOTE
** TODO 8.4 Extracting Substreams and Combining Streams - 264
** TODO 8.5 Other Stream Transformations - 265
** TODO 8.6 Simple Reductions - 266
** TODO 8.7 The Optional Type - 267
*** 8.7.1 How to Work with Optional Values - 267
   - NOTE
*** 8.7.2 How Not to Work with Optional Values - 269
*** 8.7.3 Creating Optional Values - 269
*** 8.7.4 Composing Optional Value Functions with ~flatMap~ - 269
   - NOTE

*** 8.7.5 Turning an Optional Into a Stream - 270

** TODO 8.8 Collecting Results - 271
** TODO 8.9 Collecting into Maps - 273
   - NOTE
   - NOTE
** TODO 8.10 Grouping and Partitioning - 274
   - NOTE
   - NOTE
** TODO 8.11 Downstream Collectors - 275
   - NOTE
   - NOTE
** TODO 8.12 Reduction Operations - 277
   - NOTE
   - NOTE
   - NOTE
** TODO 8.13 Primitive Type Streams - 279
   - NOTE
** TODO 8.14 Parallel Streams - 280
   - *CAUTION*

** TODO Exercises - 283

* TODO 9. PROCESSING INPUT AND OUTPUT - 287
  The key points of this chapter are:
  1. An ~InputStream~ is a source of bytes,
     and
     an ~OutputStream~ is a destination for bytes.

  2. A ~Reader~ reads characters
     and
     a ~Writer~ write them.
     + BE SURE to *specify a character encoding*.

  3. The ~Files~ class has convenience methods for _READING_ all /bytes/ or /lines/
     of a file.

  4. The ~DataInput~ and ~DataOutput~ interfaces have methods for writing numbers
     in *binary format*.

  5. Use a ~RandomAccessFile~ or a /memory-mapped file/ for random access.
     TODO ??? /memory-mapped file/

  6. A ~Path~ is an _absolute or relative_ _sequence of path components_ in a file
     system. ~Path~'s can be combined (or "resolved").

  7. Use the methods of the ~Files~ class to
     + copy files,
     + move files, or
     + delete files
       and to
     + _recursively walk through_ a directory tree. TODO ???

  8. To read or update a ZIP file, use a ZIP file system.
     TODO ???

  9. *Read* the _contents of a web page_ with the ~URL~ class.
     *Read* metadata or *write* data, use the ~URLConnection~ class.

  10. With the ~Pattern~ and ~Matcher~ classes, you can find all matches of a regular
      expression in a string, as well as the captured groups for each match.

  11. The serialization mechanism can save and restore any object implementing
      the ~Serializable~ interface, provided its instance variables are also
      serializable. TODO ??? _provided_ part ???

** TODO 9.1 Input/Output Streams, Readers, and Writers - 288
   In the Java API:
   - /input stream/ :: a source from which one can read bytes.

   - =COMMENT= The /stream/ here are unrelated to the class ~Stream~ (see Ch8).

   - The bytes can _come from_
     + a file
     + a network connection
     + an array in memory

   - /output stream/ :: a destination for bytes.

   - /readers/ :: object that _consume_ sequences of characters.

   - /writers/ :: object that _produce_ sequences of characters.

*** DONE 9.1.1 Obtaining Streams - 288
    CLOSED: [2019-09-17 Tue 16:22]
    - Obtain a /stream/
      + from a _file_
        #+BEGIN_SRC java
          InputStream in = Files.newInputStream(path);
          OutputStream out = Files.newOutputStream(path);
        #+END_SRC
        Here ~path~ is an instance of the ~Path~ class (TODO See Sec9.2.1).
      + from a _URL_:
        #+BEGIN_SRC java
          URL url = new URL("http://horstmann.com/index.html");
          InputStream in = url.openStream();
        #+END_SRC
        TODO See Sec9.3 for the ~URL~ class.
        * TODO Section 9.3, "HTTP Connections" (page 306) shows how to send data
          to a web server.

      + from an _array of bytes_ with ~ByteArrayInputStream~:
        #+BEGIN_SRC java
        byte[] bytes = /* ... */;
        InputStream in = new ByteArrayInputStream(bytes);
        #+END_SRC

        * Send /output stream/ to a /byte array/, use ~ByteArrayOutputStream~:
          #+BEGIN_SRC java
          ByteArrayOutputStream out = new ByteArrayOutputStream();
          // TODO: Write to `out`, and then
          byte[] bytes = out.toByteArray();
          #+END_SRC

*** DONE 9.1.2 Reading Bytes - 289
    CLOSED: [2019-09-17 Tue 16:22]
    - ~read()~: Read a single byte from ~InputStream~
      + The RETURN type is ~int~:
        * an integer 0 and 255.
        * -1 if the /end of input stream/ has been reached.

      + _CAUTION_:
        * They Java ~byte~ type has values between -128 and 127.

        * You can /cast/ the returned ~int~ value into a ~byte~
          (=From Jian= I think first translate 0 ~ 255 to -128 to 127)
          after you have checked that the return value of the /method/ ~read~ is
          NOT -1.

    - Read *ALL* /bytes/
      + from an /input stream/
        =IMPORTANT= (*NO* /method/ in the Java library *before* Java 9):
        #+BEGIN_SRC java
          public static byte[] readAllBytes(InputStream in) throws IOException {
              ByteArrayOutputStream out = new ByteArrayOutputStream();
              copy(in, out);
              out.close();
              return out.toByteArray();
          }
        #+END_SRC
        TODO See ~copy~ in the next section.

      + from a file (Exist at least from Java 7):
        ~byte[] bytes = Files.readAllBytes(path);~

    - Read _some_ but NOT all /bytes/:
      #+BEGIN_SRC java
        byte[] bytes = new byte[len];
        int bytesRead = in.readNBytes(bytes, offset, n);
      #+END_SRC
      - The method reads *until*
        + either   =n= /bytes/ are read
        + or       *NO* further input is available,

      - returns
        + the actual *number of bytes* read;
        + ~-1~, if no input was available at all.

    - *NOTE* =TODO= =???= =???=
      There is also a ~read(byte[], int, int)~ method whose description seems
      exactly like ~readNBytes~. The *difference* is that
      + the ~read~ method ONLY attempts to read the bytes and returns immediately
        with a lower count if it fails.

      + The ~readNBytes~ method keeps calling ~read~ until all requested bytes have
        been obtained or read returns -1.

*** DONE 9.1.3 Writing Bytes - 290
    CLOSED: [2019-09-17 Tue 16:22]
    - ~write~ methods (of ~OutputStream~) ::
         write _individual bytes_ and _byte arrays_.

      #+BEGIN_SRC java
        OutputStream out = /* ... */;
        int b = /* ... */;
        out.write(b);
        byte[] bytes = /* ... */;
        out.write(bytes);
        out.write(bytes, start, length);
      #+END_SRC
      *Close* the stream when you are done in order to _commit any buffered
      output_.

    - /Try-with-resources statement/ (like the ~with~ in Python):
      #+BEGIN_SRC java
        try (OutputStream out = /* ... */) {
            out.write(bytes);
        }
      #+END_SRC

    - There is NO method to transfer from a /input stream/ to an /output stream/
      before Java 9:
      + Since Java 9:
        #+BEGIN_SRC java
          try (inputStream in = ...; OutputStream out =...)
          {
              in.transferTo(out);
          }
        #+END_SRC

      + Before Java 9:
        #+BEGIN_SRC java
          public static void transferTo(InputStream in, OutputStream out) throws IOException
          {
              final int BLOCKSIZE = 1024;
              byte[] bytes = new byte[BLOCKSIZE];
              int len;
              while ((len = in.read(bytes)) != -1) out.write(bytes, 0, len);
          }
        #+END_SRC

    - To write a file to an OutputStream, call ~Files.copy(path, out);~

    - To save an ~InputStream~ to a file, call
      ~Files.copy(in, path, StandardCopyOption.REPLACE_EXISTING);~

*** TODO 9.1.4 Character Encodings - 290
    Work with _sequences of characters_ rather than /sequences of bytes/.

    - Java uses the /Unicode standard/ for characters.

      Each character or “code point” has a *21-bit integer number*.
        There are different character encodings—methods for packaging those
      21-bit numbers into bytes.

    - UTF-8 encoding :: encode each /Unicode code point/ into a sequence of
                        *ONE to FOUR bytes*.

    - UTF-16 encoding :: encode each /Unicode code point/ into
         *ONE or TWO 16-bit* values.
      + This is the encoding used in Java strings.

      + It has two forms:
        * /big-endian/
          For example, =0x2122= is considered =0x21= followed by =0x22=.

        * /little-endian/
          For example, =0x2122= is considered =0x22= followed by =0x21=.

      + byte order mark :: a mark (a /file/ can start with it) that is used to
           indicate which of the two form is used.

        * It is the 16-bit quantity =0xFEFF=.
          (=From Jian= NOT sure
           In /big-endian/ system, you see =0xFEFF=
           In /small-endian/ system, you see =0xFFFE=)

          A reader can use this value to determine the _byte order_ and
          *discard it*.

    - *CAUTION*: =IMPORTANT=
      + *FACT*:
        Some programs, including /Microsoft Notepad/, add a /byte order mark/ at
        the beginning of UTF-8 encoded files.

      + This is *UNNECESSARY*
        since there are *no byte ordering issues in UTF-8*.

        But the *Unicode standard allows it*, and even suggests that it's a
        pretty good idea since it leaves little doubt about the encoding.

      + It is supposed to be removed when reading a UTF-8 encoded file.
        _Sadly, Java does not do that, and bug reports against this issue are
        closed as “will not fix.”_

      + *Solution*:
        Your best bet is to *strip out any leading =\uFEFF= that you find* in
        your input.

    - There is *no reliable way to automatically detect the character encoding*
      from *a stream of bytes*.
        Therefore, you *should always explicitly specify the encoding*. For
      example, when reading a web page, check the =Content-Type= header.
      =TODO=

    - NOTE:
      + ~static~ method ~Charset.defaultCharset()~ returns the platform encoding.

      + ~static~ method ~Charset.availableCharsets()~ returns all available
        ~Charset~ instances, as *a map from canonical names to ~Charset~ objects*.
        =TODO= =??? canonical names=

    - *CAUTION*:
      The Oracle implementation has a /system property/ ~file.encoding~ for
      *overriding* the platform default.

      This is *NOT* an officially supported property, and it is *NOT*
      consistently followed by all parts of Oracle's implementation of the Java
      library. *You should not set it*.

    - The ~StandardCharsets~ class has /static variables/ of type ~Charset~ for
      the character encodings that every Java virtual machine *MUST support*:
      + ~StandardCharsets.UTF_8~
      + ~StandardCharsets.UTF_16~
      + ~StandardCharsets.UTF_16BE~
      + ~StandardCharsets.UTF_16LE~
      + ~StandardCharsets.ISO_8859_1~
      + ~StandardCharsets.US_ASCII~

    - To obtain the ~Charset~ for another encoding, use the ~static~ ~forName~
      method: ~Charset shiftJIS = Charset.forName("Shift_JIS");~

    - Use the ~Charset~ object when reading or writing text. For example, you can
      _turn an *array of bytes* into a *string* as_
      ~String str = new String(bytes, StandardCharsets.UTF_8);~

    - *TIP*:
      + *FACT*:
        Some methods allow you to *specify a character encoding* with
        * a ~Charset~ object
          or
        * a /string/.

      + *CHOICE*:
        Choose /the ~StandardCharsets~ constants/, so you don't have to worry
        about the correct spelling.

          If NOT, for example, use ~new String(bytes, "UTF 8")~ is *NOT*
        acceptable and *will cause a runtime error*.

    - *CAUTION*: =IMPORTANT=
      + Some methods (such as the ~String(byte[])~ constructor) use the
        *default platform encoding* if it is *NOT specified*;

      + Some other methods (such as ~Files.readAllLines~) use *UTF-8*.

*** DONE 9.1.5 Text Input - 293
    CLOSED: [2018-02-02 Fri 21:14]
    Use ~Reader~ to *read* /text input/.

    - Obtain a ~Reader~ from any input stream with the ~InputStreamReader~
      adapter:
      #+BEGIN_SRC java
        InputStream inStream = ...;
        Reader in = new InputStreamReader(inStream, charset);
      #+END_SRC

    - Get a UTF-16 code unit at a time (The ~in~ below is the ~Reader in~ above):
      ~int ch = in.read();~
      + integer between ~0~ and ~65536~
      + ~-1~ at the end of input

    - Read a, usually short, text file in to a ~String~ variable:
      ~String content = new String(Files.readAllBytes(path), charset);~

    - Read a, usually short, text file in to a variable as _a sequence of
      ~String~'s_:
      ~List<String> lines = Files.readAllLines(path, charset);~

    - Process the file lazily as a ~Stream~:
      #+BEGIN_SRC java
        try (Stream<String> lines = Files.lines(path, charset)) {
            // ...
        }
      #+END_SRC

    - NOTE
      =293= =TODO= =???= =EXAMPLE???=

    - To reader /numbers/ or /words/ from a file, use a ~Scanner~, as you have
      seen in Chapter 1. For example,
      #+BEGIN_SRC java
        Scanner in = new Scanner(path, "UTF-8");
        while (in.hasNextDouble())
        {
            double value = in.nextDouble();
            // ...
        }
      #+END_SRC

    - *TIP*
      To read /alphabetic words/, set the /scanner/'s /delimiter/ to a /regular
      expression/ that is the complement of what you want to accept as a
      /token/.

      For example,
      1. after calling ~in.useDelimiter("\\PL+");~, the /scanner/ reads in
         letters since any sequence of nonletters is a delimiter.
         =TODO= Section 9.4.1  REGEX

      2. You can then obtain a stream of all words as
         ~Stream<String> words = in.tokens();~

    - If your input does *NOT come from a file*, wrap the ~InputStream~ into a
      ~BufferedReader~:
      #+BEGIN_SRC java
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream())))
        {
            Stream<String> lines = reader.lines();
            // ...
        }
      #+END_SRC

      A ~BufferedReader~ reads input *in chunks for efficiency*.
      (Oddly, this is not an option for basic readers.)

      + It has a /method/ ~readLine~ to read _a single line_

      + It has a /method/ ~lines~ to yield _a stream of lines_

    - If a /method/ asks for a ~Reader~ and you want it to read from a file, call
      ~Files.newBufferedReader(path, charset)~.

*** TODO 9.1.6 Text Output - 294
    -

    - NOTE

    - *CAUTION*

    -

*** TODO 9.1.7 Reading and Writing Binary Data - 295
    -

*** TODO 9.1.8 Random-Access Files - 296
    -

*** TODO 9.1.9 Memory-Mapped Files - 297
    -

*** DONE 9.1.10 File Locking - 297 =re-read=
    CLOSED: [2017-05-16 Tue 23:23]
    - To lock a file, call either the ~lock~ or ~tryLock~ methods of the
      ~FileChannel~ class.
      #+BEGIN_SRC java
        FileChannel = FileChannel.open(path);
        FileLock lock = channel.lock();

        // OR
        // FileLock lock = channel.tryLock();
      #+END_SRC

    - The first call (~lock~) blocks until the lock becomes available.

      The second call (~tryLock~) returns immediately, either with the lock or
      with ~null~ if the lock is not available.

      The file remains locked until the lock or the channel is closed.

    - It is best to use try-with-resources statement:
      #+BEGIN_SRC java
        try (FileLock lock = channel.lock()) {
            // ...
        }
      #+END_SRC

** DONE 9.2 Paths, Files, and Directories - 298
   CLOSED: [2018-02-04 Sun 13:05]
*** DONE 9.2.1 Paths - 298
    CLOSED: [2018-02-02 Fri 22:38]
    - ~Path~ :: a sequence of directory names, OPTIONALLY followed by a file name
      + A ~Path~ *may* contains a root component
        * absolute.
          Example: ~Path absolute = Paths.get("/", "home", "cay");~

        * relative
          Example: ~Path relative = Paths.get("myapp", "conf", "user.properties");~

    - The /static method/ ~Paths.get~ will ajust the path separator in a
      reasonable way. For example, both the sentences below work well:
      #+BEGIN_SRC java
        final Path p1 = Paths.get("abc", "def");
        final Path p2 = Paths.get("abc/", "def");
        final Path p3 = Paths.get("abc", "/def");
        final Path p4 = Paths.get("abc/", "/def");

        assert p1.equals(p2);
        assert p1.equals(p3);
        assert p1.equals(p4);
      #+END_SRC

    - ~InvalidPathException~ will be thrown out if ~Paths.get~ CANNOT concatenate
      all its arguments with proper adjusted (add or remove) separator(s) to for
      a LEGAL /path/.

    - NOTE
      There is no need for ~Path~ object to be a exist path,
      =From Jian= which is reasonable.

    - ~path.resolve(anotherPath)~
      =IMPORTANT= read the API and pay attention to the tricky case.

    - ~path.resolveSibling(anotherPath)~
      =TODO= read the API
      For example, ~Paths.get("/home/cay/myapp/work").resolveSibling("temp");~
      yields a path of =/home/cay/myapp/temp=

    - ~path.relativize(anotherPathString)~
      For example, ~Paths.get("/home/cay").relativize(Paths.get("/home/fred/myapp"))~
      yieds a path of =../fred/myapp=

    - ~path.normalize()~
      For example, /normalize/ the path =/home/cay/../fred/./myapp= and yields a
      path of =/home/fred/myapp=

    - ~path.toAbsolutePath()~

    - Some other usages:
      #+BEGIN_SRC java
        Path p = Paths.get("/home", "cay", "myapp.properties");

        Path parent = p.getParent();  // The path /home/cay
        Path file = p.getFileName();  // The last element, myapp.properties
        Path root = p.getRoot();      // The initial segment / (null for a relative path)
        Path first = p.getName(0);    // The first element
        Path dir = p.subpath(1, p.getNameCount());

        // All but the first element, cay/myapp.properties
      #+END_SRC

    - The ~Path~ interface extends the ~Iterable<Path>~ element, and you can
      iterate over the name components of a ~Path~:
      ~for (Path component : path) { ... }~

    - NOTE
      + =TODO= 300

      + ~File~ has a /method/ ~toPath~, and ~Path~ has a /method/ ~toFile~.

*** DONE 9.2.2 Creating Files and Directories - 300
    CLOSED: [2018-02-02 Fri 22:49]
    - ~Files.createDirectory(path);~
      All but the last component in the path _must already exist._

    - ~Files.createDirectories(path);~
      Also create the intermediate directories.

    - ~Files.createFile(path);~
      Create an empty file.
      + The call throws an /exception/ if the file already exists.

      + The _checks for existence_ and the _creation_ are *atomic*.
        If the file doesn't exist, it is created before anyone else has a chance
        to do the same.

    - ~Files.exist(path)~

    - ~Files.isDirectory(path)~

    - ~Files.isRegularFile(path)~
      NOT a directory or symbolic link

    - Creating a temporary file or directory in a given or system-specific location.

      =Comment from Jian= I think "system-specific location" in *nix, should
                          be =/tmp=.

      #+BEGIN_SRC java
        Path tempFile = Files.createTempFile(dir, prefix, suffix);
        Path tempFile = Files.createTempFile(prefix, suffix);
        Path tempDir = Files.createTempDirectory(dir, prefix);
        Path tempDir = Files.createTempDirectory(prefix);
      #+END_SRC
      + ~dir~ is a ~Path~

      + ~prefix~ and ~suffix~ are strings, and they can be ~null~
        For example, ~Files.createTempFile(null, ".txt")~ might return a path
        such as =/tmp/1234405522364837194.txt=

*** DONE 9.2.3 Copying, Moving, and Deleting Files - 301
    CLOSED: [2018-02-02 Fri 23:12]
    - ~Files.copy(fromPath, toPath)~

    - ~Files.move(fromPath, toPath)~
      This can also be used to move an *EMPTY* directory.

    - The simple /copy/ or /move/ above will fail if the target exits.

      + To *overwrite*, use the ~REPLACE_EXISTING~ option.

      + To *copy all file attributes*, use the ~COPY_ATTRIBUTES~ option.

      For example,
      #+BEGIN_SRC java
        Files.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING,
                   StandardCopyOption.COPY_ATTRIBUTES);
      #+END_SRC

    - Specify the move should be *atomic*.
      ~Files.move(fromPath, toPath, StandardCopyOption.ATOMIC_MOVE);~

    - Delete a exist file
      ~Files.delete(path);~
      It throws an /exception/ if the file does NOT exist.

    - Delete if exist:
      ~boolean rc = Files.deleteIfExists(path);~
      You can check its /return code/.
      =From API=
      + ~true~ if the file was *deleted* by this method
      + ~false~ if the file *could not be deleted* _because it did not exist_

    - Table 9-3 Standard Options for File Operations
      =IMPORTANT= =TODO= =RE-READ=

*** DONE 9.2.4 Visiting Directory Entries - 302
    CLOSED: [2018-02-04 Sun 13:04]
    - ~Files.list()~ returns a ~Stream<Path>~
      + Since reading a directory involves a system resource that needs to be
        closed, you *should use* a /try-with-resources/ block:
        #+BEGIN_SRC java
          try (Stream<Path> entries = Files.list(pathToDirectory))
          {
              // ...
          }
        #+END_SRC

    - The ~Files.list()~ does NOT enter subdirectories.
      To process all descendants of a directory, use the
      ~Files.walk(pathToDirectory)~ /method/ instead:
      #+BEGIN_SRC java
        try (Stream<Path> entries = Files.walk(pathToRoot))
        {
            // Contains all descendants, visited in depth-first order.
        }
      #+END_SRC

      + The *depth* can be limited by calling
        ~Files.walk(pathToRoot, depth)~

      + All ~Files.walk~ /methods/ have a /varargs/ parameter of type
        ~FileVisitOption...~, but there is *only ONE* option you can supply:
        ~FOLLOW_LINKS~ to _follow symbolic links_.

    - NOTE =TODO=
      If
      + you *filter* the /paths/ returned by *walk*
        and
      + your filter criterion involves the file attributes stored with a
        directory, such as size, creation time, or type (file, directory,
        symbolic link),

      then *use the ~find~ /method/ INSTEAD of ~walk~.*

      Call that method with a predicate function that accepts a path and a
      ~BasicFileAttributes~ object. *The only advantage is efficiency*. Since
      the directory is being read anyway, the attributes are readily available.

    - Example,
      This code fragment uses the ~Files.walk~ /method/ to *copy one directory to
      another*:
      #+BEGIN_SRC java
        Files.walk(source).forEach(p -> {
                try
                {
                    Path q = target.resolve(source.relativize(p));
                    if (Files.isDirectory(p))  Files.createDirectory(q);
                    else                       Files.copy(p, q);
                }
                catch (IOException ex)
                {
                    throw new UncheckedIOException(ex);
                }
            });
      #+END_SRC

    - UNFORTUNATELY, you
      *CANNOT easily use the ~Files.walk~ /method/ to delete a tree of directories*
      since you need to first visit the children before deleting the parent.

      + Solution: =TODO=
        In that case, use the ~walkFileTree~ /method/. It requires an instance of
        the ~FileVisitor~ /interface/. Here is when the file visitor gets notified:
        1. *Before* a directory is processed:
           ~FileVisitResult preVisitDirectory(T dir, IOException ex)~

        2. When a /file/ (=From Jian= non-directory???) is *encountered*:
           ~FileVisitResult visitFile(T path, BasicFileAttributes attrs)~

        3. When an /exception/ *occurs* in the ~visitFile~ method:
           ~FileVisitResult visitFileFailed(T path, IOException ex)~

        4. *After* directory is processed:
           ~FileVisitResult postVisitDirectory(T dir, IOException ex)~

      + In each case, the notification method returns one of the following results:
        * Continue visiting the next file:
          ~FileVisitResult.CONTINUE~

        * Continue the walk, but without visiting the entries in this directory:
          ~FileVisitResult.SKIP_SUBTREE~

        * Continue the walk, but without visiting the siblings of this file:
          ~FileVisitResult.SKIP_SIBLINGS~

        * Terminate the walk:
          ~FileVisitResult.TERMINATE~

      + If any of the /methods/ throws an /exception/, _the walk is also
        terminated_, and that /exception/ is thrown from the ~walkFileTree~
        /method/.

      + Code:
        #+BEGIN_SRC java
          final FileVisitor fv =
              new SimpleFileVisitor<Path>()
              {
                  public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                      throws IOException
                  {
                      return FileVisitResult.CONTINUE;
                  }

                  public FileVisitResult postVisitDirectory(Path dir, IOException ex)
                      throws IOException
                  {
                      if (ex != null) throw ex;
                      Files.delete(dir);
                      return FileVisitResult.CONTINUE;
                  }
              };

          Files.walkFileTree(root, fv);
        #+END_SRC

*** DONE 9.2.5 ZIP File Systems - 305
    CLOSED: [2018-02-04 Sun 13:05]
    - The ~Paths~ class looks up /paths/ in the _DEFAULT file system_ -- the
      files on the _user's local disk_.

    - You have other files systems, one of the more useful ones is a /ZIP file
      system/.

    - If ~zipname~ is the name of a ZIP file, then call
      ~FileSystem zipfs = FileSystems.newFileSystem(Paths.get(zipname), null);~
      to _establish a file system that contains all files in the ZIP archive_.

    - *Copy* files out of the /ZIP file system/:
      ~Files.copy(zipfs.getPath(sourceName), targetPath);~
      + The ~getPath~ /method/ here is an analog of ~Paths.get~ for an /ARBITRARY
        file system/.

    - *List* all files in a /ZIP file system/:
      #+BEGIN_SRC java
        Files.walk(zipfs.getPath("/")).forEach(p -> {
            Process p
        });
      #+END_SRC

    - *Create* a new ZIP file:

      =From Jian= Recite it! Or find if there is one in a commonly used
      non-standard library.

      #+BEGIN_SRC java
        Path zipPath = Paths.get("myfile.zip");
        URI uri = new URI("jar", zipPath.toUri().toString(), null);
        // Constructs the URI jar:file://myfile.zip

        try (FileSystem zipfs = FileSystems.newFileSystem(uri, Collections.singletonMap("create", "true")))
        {
            // To add files, copy them into the ZIP file system
            Files.copy(sourcePath, zipfs.getPath("/").resolve(targetPath));
        }
      #+END_SRC

    - NOTE
      OLD API ~ZipInputStream~ and ~ZipOutputStream~.
      They are not as easy to use as the one described in this section.
      =TODO= =Try them= =???=

** TODO 9.3 HTTP Connections - 306
*** 9.3.1 The ~URLConnection~ and ~HttpURLConnection~ Classes - 306
*** 9.3.2 The HTTP Client API - 307

** TODO 9.4 Regular Expressions - 310
*** 9.4.1 The Regular Expression Syntax - 310
    - Meta-characters: ~.~, ~*~, ~+~, ~?~, ~{~, ~|~, ~(~, ~)~, ~[~, ~\~, ~^~, ~$~

    - Character class: a set of character alternatives enclosed in brackets.

    - Predefined character classes:
      + ~\d~ (digits)
      + ~\p{Sc}~ (Unicode currency symbols) TODO ???

    - Use backslash to escape meta-characters.
      + In /character class/, you only need to escape ~[~ and ~\~, provided you are
        careful about the positions of ] - ^.
        * For example, ~[]^-]~ is a class containing all three of them.

    - Surround a string with ~\Q~ and ~\E~ can also escape characters in the between.
      For example, ~\(\$0\.99\)~ and ~\Q($0.99)\E~ both match the string =($0.99)=.

    - *TIP*

*** 9.4.2 Finding One Match - 314
*** 9.4.3 Finding All Matches - 315
*** 9.4.4 Groups - 316
*** 9.4.5 Splitting along Delimiters - 317
*** 9.4.6 Replacing Matches - 317
*** 9.4.7 Flags - 318

** TODO 9.5 Serialization - 319
*** TODO 9.5.1 The ~Serializable~ Interface - 319
*** TODO 9.5.2 Transient Instance Variables - 321
*** TODO 9.5.3 The ~readObject~ and ~writeObject~ Methods - 321
*** TODO 9.5.4 The ~readResolve~ and ~writeReplace~ Methods - 322
*** TODO 9.5.5 Versioning - 324

** TODO Exercises - 325

* TODO 10. CONCURRENT PROGRAMMING - 329
** TODO 10.1 Concurrent Tasks - 330
*** TODO 10.1.1 Running Tasks - 330
    - _NOTE_

*** TODO 10.1.2 Futures - 333
    - _NOTE_

    - _NOTE_

** TODO 10.2 Asynchronous Computations - 335
*** TODO 10.2.1 Completable Futures - 335
    - _NOTE_

*** TODO 10.2.2 Composing Completable Futures - 337

*** TODO 10.2.3 Long-Running Tasks in User-Interface Callbacks - 340
    - _NOTE_

** TODO 10.3 Thread Safety - 341
*** TODO 10.3.1 Visibility - 342
    - _TIP_

*** TODO 10.3.2 Race Conditions - 344
*** TODO 10.3.3 Strategies for Safe Concurrency - 346
*** TODO 10.3.4 Immutable Classes - 347
    - _NOTE_

** TODO 10.4 Parallel Algorithms - 348
*** TODO 10.4.1 Parallel Streams - 348
    - _CAUTION_

*** TODO 10.4.2 Parallel Array Operations - 349
    - _NOTE_

** TODO 10.5 Threadsafe Data Structures - 350
   - _NOTE_

*** TODO 10.5.1 Concurrent Hash Maps - 350
    - _NOTE_

    - _NOTE_

*** TODO 10.5.2 Blocking Queues - 352
    - _NOTE_

*** TODO 10.5.3 Other Threadsafe Data Structures - 354

** TODO 10.6 Atomic Counters and Accumulators - 354
   - _NOTE_
   - _NOTE_
   - _TIP_

** TODO 10.7 Locks and Conditions - 357
*** TODO 10.7.1 Locks - 357
    - _NOTE_

*** TODO 10.7.2 The ~synchronized~ Keyword - 358
    - _NOTE_

*** TODO 10.7.3 Waiting on Conditions - 360
    - _CAUTION_

    - _NOTE_

** TODO 10.8 Threads - 362
*** TODO 10.8.1 Starting a Thread - 363
    - _NOTE_

*** TODO 10.8.2 Thread Interruption - 364
    - _NOTE_

    - _TIP_

*** TODO 10.8.3 Thread-Local Variables - 365
*** TODO 10.8.4 Miscellaneous Thread Properties - 366

** TODO 10.9 Processes - 366
   - _NOTE_

*** TODO 10.9.1 Building a Process - 367
    - _CAUTION_

    - _NOTE_

*** TODO 10.9.2 Running a Process - 368
    - _CAUTION_

*** 10.9.3 Process Handles - 370

** TODO Exercises - 371

* TODO 11. ANNOTATIONS - 377
** TODO 11.1 Using Annotations - 378
*** TODO 11.1.1 Annotation Elements - 378
    - _CAUTION_

    - NOTE

*** TODO 11.1.2 Multiple and Repeated Annotations - 380
*** TODO 11.1.3 Annotating Declarations - 380
    - NOTE

*** TODO 11.1.4 Annotating Type Uses - 381
    - NOTE

    - NOTE

*** TODO 11.1.5 Making Receivers Explicit - 382
    - NOTE

** TODO 11.2 Defining Annotations - 383
   - NOTE
   - _CAUTION_

** TODO 11.3 Standard Annotations - 386
*** TODO 11.3.1 Annotations for Compilation - 387
*** TODO 11.3.2 Annotations for Managing Resources - 388
*** TODO 11.3.3 Meta-Annotations - 389

** TODO 11.4 Processing Annotations at Runtime - 391
** TODO 11.5 Source-Level Annotation Processing - 394
*** TODO 11.5.1 Annotation Processors - 394
    - NOTE

*** TODO 11.5.2 The Language Model API - 395
*** TODO 11.5.3 Using Annotations to Generate Source Code - 395
    - _TIP_

    - NOTE

** TODO Exercises - 398

* TODO 12. THE DATE AND TIME API - 400
  - History:
    1. Java 1.0:
       *Immature* ~Date~ API

    2. Java 1.1:
       introduced ~Calendar~, the most of the Java 1.0 ~Date~ /methods/ are
       deprecated.

    3. Java 1.8:
       Introduced ~java.time~ (JSR-310, which takes 7 years).
       Before Java 1.8, Joda-time is the de facto date and time library for Java.

  - The key points of this chapter are:
    1. All ~java.time~ objects are *immutable*.

    2. An ~Instant~ is a point on the time line (similar to a ~Date~).

    3. In Java time, each day has exactly _86,400 seconds_ (that is, *NO* /leap
       seconds/).

    4. A ~Duration~ is the difference between two /instants/.

    5. ~LocalDateTime~ has no time zone information.

    6. ~TemporalAdjuster~ methods handle common calendar computations, such as
       finding the first Tuesday of a month.

    7. ~ZonedDateTime~ is a point in time in a given time zone (similar to
       ~GregorianCalendar~).

    8. Use a ~Period~, not a ~Duration~, when advancing zoned time, in order to
       account for daylight savings time changes.

    9. Use ~DateTimeFormatter~ to format and parse dates and times.

** DONE 12.1 The Time Line - 402
   CLOSED: [2018-02-04 Sun 14:49]
   - =Re-read=

   - The Java ~Date~ and ~Time~ API specification requires that Java uses a time
     scale that:
     + Has 86,400 seconds per day

     + Exactly matches the official time at noon each day

     + Closely matches it elsewhere, in a precisely defined way

     That gives Java the flexibility to adjust to future changes in the official
     time.

   - ~Instant~ :: represents a point on the time line.

   - epoch (the origin) :: January 1, 1970 at the prime meridian that passes
        through the Greenwich Royal Observatory in London.

        _This is the same convention used in the Unix/POSIX time._

   - Starting from the /origin/, time is measured
     + in 86,400 seconds per day
     + forward and backward
       * ~Instant.MIN~ is a billion years ago.
       * ~Instant.MAX~ is December 31 of the year 1,000,000,000.
     + to nanosecond precision

   - ~Instant.now()~ gives the current instant.

   - ~Instant~ objects can call ~equals~ and ~compareTo~ to compare.

   - Use ~Duration.between(startInstant, endInstant);~ to calculate the running
     time of a process. For example,
     #+BEGIN_SRC java
       Instant start = Instant.now();
       runAlgorithm();
       Instant end = Instant.now();
       Duration timeElapsed = Duration.between(start, end);
       long millis = timeElapsed.toMillis();
     #+END_SRC

   - The ~Duration~ class has /methods/
     + ~toNanos~
     + ~toMillis~
     + ~toSeconds~
     + ~toMinutes~
     + ~toHours~
     + ~toDays~

   - The ~Duration~ class has /static factory methods/
     + ~ofNanos~
     + ~ofMillis~
     + ~ofSeconds~
     + ~ofMinutes~
     + ~ofHours~
     + ~ofDays~

   - ~Durations~ require *more than* a ~long~ value for their _internal storage_.

     + The number of seoncds is stored in a ~long~

     + The number of nanoseoncds in an additional ~int~

     + If
       you want to make computations to _nanosecond accuracy_,
       and
       you actually need the entire range of a ~Duration~,
       you can use one of the methods in Table 12-1.

       =Comment from Jian= This means if you use the methods in Table 12-1, and
       don't save ~Instant~ and ~Duration~ as numbers in a variable, you can
       avoid overflow troubles.

   - NOTE:
     It takes *300 years* of nanoseconds to *overflow* a ~long~

   - Examle:
     Check whether an algorithm is at least ten times faster than another:
     #+BEGIN_SRC java
       Duration timeElapsed2 = Duration.between(start2, end2);
       boolean overTenTimesFaster = timeElapsed.multipliedBy(10).minus(timeElapsed2).isNegative();
     #+END_SRC

   - NOTE:
     We can always write /fluent style/ code when using ~Instant~ and ~Duration~.
     They are *immutable*.

   - =IMPORTANT= Table 12-1 Arithmetic Operations for Time ~Instant~'s and
     ~Duration~'s

     *CAUTIONS*
     Most of these are /method/ names *SHARED* by ~Duration~ and ~Instants~
     (actually the interfaces they implement)

     - ~plus~, ~minus~

     - ~plusNanos~, ~plusMillis~, ~plusSeconds~,
       ~plusMinutes~, ~plusHours~, ~plusDays~

     - ~minusNanos~, ~minusMillis~, ~minusSeconds~,
       ~minusMinutes~, ~minusHours~, ~minusDays~

     - ~multipliedBy~, ~dividedBy~, ~negated~
       _For ~Duration~ ONLY -- ~Instant~ CANNOT be scaled_

     - ~isZero~, ~isNegative~
       _For ~Duration~ ONLY_

** DONE 12.2 Local Dates - 404
   CLOSED: [2018-02-04 Sun 17:01]
   Now let us turn from /absolute time/ to /human time/.
   - =TODO= =RE-READ=

   - The API designer recommend that you do *NOT* use /zoned time/
     _UNLESS you really want to represent absolute time instantces_ =???=.

   - Good examples for /local dates or times/:
     + Birthdays
     + holidays
     + schedule times

   - ~LocalDate~ :: a date with a year, month, and day of the month.

   - Construct an object of a ~LocalDate~, use the /static factory method/ ~now~
     or ~of~:
     #+BEGIN_SRC java
       LocalDate today = LocalDate.now();  // Today's date
       LocalDate alonzosBirthday = LocalDate.of(1903, 6, 14);
       assert alonzosBirthday.equals(LocalDate.of(1903, Month.JUNE, 14));
     #+END_SRC

     + Alonzo's birthday is 1903-06-14, and you pass ~1903~, ~6~, and ~14~.
       It looks nothing amazing.

       This is different from the convention in Unix and ~java.util.Date~, where
       * /months/ are *zero-based*

         Even though, with ~java.time~, use ~Month~ /enumeration/, rather than
         integers, is preferred.

       * /years/ are *counted from 1900*

   - Example:
     Compute /Programmer's Day/ of a specific year.
     + Programmer's Day :: the 256th day of a year.

     + Code:
       #+BEGIN_SRC java
         LocalDate programmersDay = LocalDate.of(2014, 1, 1).plusDays(255);
       #+END_SRC
       This works well even with /leap years/.

   - The difference between two /local dates/ is a ~Period~.
     Its counterpart for /instants/ is ~Duration~.

     For example,
     Use ~birthday.plus(Period.ofYears(1))~ to get the birthday next year.
     ~birthday.plusYears(1)~ also works well.

     You mustn't use ~birthday.plus(Duration.ofDays(365))~, which won't produce
     the correct result in a /leap year/.

   - Get the difference between two local dates:
     ~independenceDay.util(christmas)~
     This yields a period of 5 months and 21 days.
     Since the days per month varies, this kind of results are not terribly
     useful!

     More useful result:
     ~independenceDay.util(christmas, ChronoUnit.DAYS)  // 174 days~

   - Table 12-2 ~LocalDate~ Methods
     =TODO= =READ=

   - *CAUTION*
     Some methods in Table 12-2 could potentially create nonexistent dates.

     However, sometimes the library knows how to get a reasonable result:
     both ~LocalDate.of(2016, 1, 31).plusMonths(1)~ and
     ~LocalDate.of(2016, 1, 31).plusMonths(1)~ yields reasonable result February
     29, 2016.

   - ~datesUntil~ yields a /stream/  of ~LocalDate~ objects between a start and an
     end date:
     #+BEGIN_SRC java
       Stream<LocalDate> allDaysInMay2018 =
           LocalDate.of(2018, 5, 1).datesUtil(LocalDate.of(2018,6,1));

       Stream<LocalDate> allMondaysIn2018 =
           LocalDate.of(2018, 1, 1).datesUtil(LocalDate.of(2019,1,1), Period.ofDays(7));
     #+END_SRC

   - ~getDayOfWeek~ yields the weekday, as a value of the ~DayOfWeek~ enumeration.

     ~DayOfWeek.MONDAY~ has the numerical value 1, and ~DayOfWeek.SUNDAY~ has
     the value 7.

     For example, ~LocalDate.of(1900, Month.JANUARY, 1).getDayofWeek().getValue()~
     yields ~1~.

   - The ~DayOfWeek~ /enumeration/ has convenience methods ~plus~ and ~minus~ to
     _compute weekdays modulo 7_.

     For example, ~DayOfWeek.SATURDAY.plus(3)~ yields ~DayOfWeek.TUESDAY~.

   - NOTE:
     _The weekend days actually come at the end of the week in ~java.time~._
     This is *DIFFERENT* from ~java.util.Calendar~ where ~Sunday~ has value 1
     and ~Saturday~ value 7.

   - In addition to ~LocalDate~, there are also classes ~MonthDay~, ~YearMonth~,
     and ~Year~ to describe partial dates.

** DONE 12.3 Date Adjusters - 407
   CLOSED: [2018-02-04 Sun 17:00]
   /Date Adjusters/ are used to compute the dates such as "the first Tuesday of every month."

   - ~TemporalAdjusters~ class provides a number of /static methods/ for common
     adjustments.

     Pass the result of an /adjustment method/ to the ~with~ method.

   - Exmaple,
     the first Tuesday of a month can be computed like this:
     #+BEGIN_SRC java
       LocalDate firstTuesday = LocalDate.of(year, month, 1).
           with(TemporalAdjusters.nextOrSame(DayOfWeek.TUESDAY));
     #+END_SRC

   - Table 12-3 Date Adjusters in the ~TemporalAdjusters~ Class
     =TODO= =READ=

   - Implement your own customized /adjusters/.
     For example, an /adjuster/ for _computing the next weekday_:
     + Method 1
       #+BEGIN_SRC java
         TemporalAdjuster NEXT_WORKDAY = w -> {
             LocalDate result = (LocalDate) w;
             do {
                 result = result.plusDays(1);
             } while (result.getDayOfWeek().getValue() >= 6);
             return result;
         };

         LocalDate backToWork = today.with(NEXT_WORKDAY);
       #+END_SRC
       * Note that there is a /cast/:
         the parameter of this lambda expression is of type ~Temporal~, and it
         must be cast to ~LocalDate~.

     + Method 2 (use ~ofDateAdjuster~ /method/, which expects a
       ~UnaryOperator<LocalDate>~, to *avoid* /cast/)
       #+BEGIN_SRC java
         TemporalAdjuster NEXT_WORKDAY = TemporalAdjusters.ofDateAdjuster(w -> {
             LocalDate result = w;  // No cast
             do {
                 result = result.plusDays(1);
             } while (result.getDayOfWeek().getValue() >= 6);
             return result;
         });
       #+END_SRC

** DONE 12.4 Local Time - 409
   CLOSED: [2018-02-04 Sun 17:16]
   - ~LocalTime~ :: represents a time of day, such as 15:30:00.

   - Construct an /instance/ of ~LocalTime~ with the ~now~ or ~of~ /static
     factory methods/:
     #+BEGIN_SRC java
       LocalTime rightNow = LocalTime.now();
       LocalTime bedtime = LocalTime.of(22, 30);  // or LocalTime.of(22, 30, 0)
     #+END_SRC

   - NOTE:
     ~LocalTime~ does NOT concern itself with AM/PM.
     Use /formatter/ -- =TODO= see Section 12.6, "Formatting and Parsing" (page 413).

   - Table 12-4 ~LocalTime~ Methods
     =TODO= =READ=

   - ~LocalDateTime~ :: represents a date and time.

     That class is suitable for storing points in time in a fixed time zone
     for example, for a schedule of classes or events.

   - You should *NOT*, for example, use ~LocalDateTime~ to
     + make calculations that span the daylight savings time;
     + deal with users in different time zones.

     you should use the ~ZonedDateTime~ class that we discuss next.

** TODO 12.5 Zoned Time - 410
   - NOTE:

   - *CAUTION*

** TODO 12.6 Formatting and Parsing - 413 =Read When Use=
   - NOTE:

** TODO 12.7 Interoperating with Legacy Code - 416 =Try to Re-Read multiple times=
** TODO Exercises - 417

* TODO 13. INTERNATIONALIZATION - 421
** TODO 13.1 Locales - 422
*** TODO 13.1.1 Specifying a Locale - 423
    - NOTE

    - NOTE

*** TODO 13.1.2 The Default Locale - 426
    - NOTE

    - *TIP*

*** TODO 13.1.3 Display Names - 426

** TODO 13.2 Number Formats - 427
** TODO 13.3 Currencies - 428
** TODO 13.4 Date and Time Formatting - 429
   - *CAUTION*

   - *CAUTION*

** TODO 13.5 Collation and Normalization - 431
** TODO 13.6 Message Formatting - 433
   - NOTE

   - *CAUTION*

** TODO 13.7 Resource Bundles - 435
   - NOTE

*** TODO 13.7.1 Organizing Resource Bundles - 435
    - *CAUTION*

    - NOTE

    - NOTE

    - *CAUTION*

*** TODO 13.7.2 Bundle Classes - 437
    - *CAUTION*

** TODO 13.8 Character Encodings - 438
   - *TIP*

** TODO 13.9 Preferences - 439
   - NOTE

   - NOTE

** TODO Exercises - 441

* TODO 14. COMPILING AND SCRIPTING - 443
  The key points of this chapter are:
  1. With the compiler API, you can generate Java code on the fly and compile it.

  2. The scripting API lets Java program interoperate with a number of scripting
     languages.

  3. The JDK includes /Nashorn/, a JavaScript interpreter with good performance
     and fidelity to the JavaScript standard.

  4. /Nashorn/ offers a convenient syntax for working with Java lists and maps,
     as well as JavaBeans properties.

  5. /Nashorn/ supports lambda expressions and a limited mechanism for extending
     Java classes and implementing Java interfaces.

  6. /Nashorn/ has support for writing shell scripts in JavaScript.

** TODO 14.1 The Compiler API - 444
*** TODO 14.1.1 Invoking the Compiler - 444

*** TODO 14.1.2 Launching a Compilation Task - 444
    - NOTE

*** TODO 14.1.3 Reading Source Files from Memory - 445

*** TODO 14.1.4 Writing Byte Codes to Memory - 446

*** TODO 14.1.5 Capturing Diagnostics - 447

** TODO 14.2 The Scripting API - 448
*** TODO 14.2.1 Getting a Scripting Engine - 448
    - NOTE

*** TODO 14.2.2 Bindings - 449
*** TODO 14.2.3 Redirecting Input and Output - 449
    - NOTE

    - NOTE

*** TODO 14.2.4 Calling Scripting Functions and Methods - 450
    - NOTE

    - NOTE

*** TODO 14.2.5 Compiling a Script - 452

** TODO 14.3 The Nashorn Scripting Engine - 452
*** TODO 14.3.1 Running Nashorn from the Command Line - 452
    - *TIP*

    - *TIP*

*** TODO 14.3.2 Invoking Getters, Setters, and Overloaded Methods - 453

*** TODO 14.3.3 Constructing Java Objects - 454
    - NOTE

    - *CAUTION*

*** TODO 14.3.4 Strings in JavaScript and Java - 455

*** TODO 14.3.5 Numbers - 456

*** TODO 14.3.6 Working with Arrays - 457
    - *CAUTION*

*** TODO 14.3.7 Lists and Maps - 458
    - NOTE

*** TODO 14.3.8 Lambdas - 458
    - NOTE

*** TODO 14.3.9 Extending Java Classes and Implementing Java Interfaces - 459
    - NOTE

    - *CAUTION*

    - NOTE

*** TODO 14.3.10 Exceptions - 461

** TODO 14.4 Shell Scripting with Nashorn - 461
*** TODO 14.4.1 Executing Shell Commands - 462
*** TODO 14.4.2 String Interpolation - 462
*** TODO 14.4.3 Script Inputs - 463
    - *CAUTION*

** TODO Exercises - 464

* TODO 15. THE JAVA PLATFORM MODULE SYSTEM - 469
  - A /module/ can make /classes/ and /packages/ selectively available so that
    its *evolution can be controlled*.
    =TODO= =???=

  - The key points of this chapter are:
    1. The /Java Platform Module System/ was designed to *modularize* the Java
       platform.

    2. You can use the /Java Platform Module System/ to *modularize*
       /applications/ and /libraries/.

    3. *A /module/ is a COLLECTION of /packages/.*

    4. The /properties/ of a /module/ are defined in =module-info.java=.

    5. A /module/ declares on which other /modules/ it depends.

    6. A /module/ provides /encapsulation/.
       Accessible /packages/ *must be EXPLICITLY exported*.

    7. A /module/ may allow /reflective access/ to /private features/ by *opening
       a /package/ or the /entire module/.*

    8. The /module system/ provides support for the ~ServiceLoader~ facility.
       =TODO= =???=

    9. A /modular JAR/ is a JAR with a =module-info.class= file that is placed on
       the /module path/.

    10. By placing a /regular JAR/ on the /module path/, it becomes an /automatic
        module/ that *exports* and *opens* ALL of its /packages/.

    11. All /packages/ on the /class path/ form the /unnamed module/.

    12. To *migrate* existing applications,
        you may need to *override* /access restrictions/ with command-line
        options.

    13. The =jdeps= tool analyzes the *dependencies* of a given set of JAR files.
        The =jlink= tool produces an application with *minimal dependencies*.

** DONE 15.1 The Module Concept - 470
   CLOSED: [2018-01-12 Fri 01:49]
   - =TODO= my NOTE

   - =TODO= my NOTE

   - A Java platform module consists of:
     + A COLLECTION of /packages/
     + _Optionally_, /resource files/ and /other files/ such as native libraries
     + A LIST of the /ACCESSIBLE packages/ in the /module/
     + A LIST of ALL /modules/ on which this /module/ *depends*

   - The Java platform enforces /encapsulation/ and /dependencies/,
     both at /compile time/ and /in the virtual machine/.

   - *TWO advantages* of the /Java Platform Module System/ (compared to the
     approach of using JAR files on the /class path/):
     + *STRONG encapsulation*:
       You can control which of your /packages/ are *accessible*, and you don't
       have to worry about maintaining code that you didn't intend for public
       consumption.

     + *Reliable configuration*:
       You *avoid* _common /class path/ problems_ such as *duplicate* or
       *missing* /classes/.

   - There are some issues that the /Java Platform Module System/ does _NOT address_!

     For example, the *versioning of modules* problem.
       There is no support for specifying which version of a module is required,
     or for using multiple versions of a module in the same program. These can
     be desirable features, but *you MUST use mechanisms other than the /Java
     Platform Module System/ if you need them*.

     =From Jian= =IMPORTANT=
     Maybe I should write the versioning info into the =module-info.java= file as
     comment.
       I think this is a good location, and if the *version of modules
     management* feature is added to the /Java Platform Module System/ in the
     future, the developer can translate the comment about versioning info to
     corresponding code.

** DONE 15.2 Naming Modules - 472
   CLOSED: [2018-01-12 Fri 02:06]
   - module :: a COLLECTION of /packages/.

   - There is NO mandatory constraints about the /module name/ and the /package
     names/ _in this module_.

     For example, the ~java.sql~ module contains /packages/ ~java.sql~,
     ~javax.sql~, and ~javax.transaction.xa~.

     From this example, you can see that the /module name/ and one of its
     /package name/ can the same.

   - Just as with /package names/, there is *NO* hierarchical relationship
     between /modules/.

     For example, a ~com.horstmann~ /module/ and a ~com.horstmann.corejava~
     /module/ would be unrelated, as far as the module system is concerned.

   - A /module name/ MUST be *globally UNIQUE*.
     =From Jian= Must be clever and take care when creating a /module name/!!!

   - Any given /package/ can ONLY be placed in *one* /module/.

   - One tip or trick:
     If your /module names/ are *unique* and your /package names/ _start with the
     module name_, then your /package names/ will also be *UNIQUE*.

   - Use *shorter* /module names/ for /modules/ that are not meant to be used by
     other programmers, such as a module containing an /application program/. For
     example, ~ch15.sec03~.

   - /Modules/ with what could plausibly be /library/ code will have names such
     as ~com.horstmann.greet~.

   - NOTE:
     + You only use /module names/ in /module declarations/.

     + In the /source files/ for your /Java classes/, you *NEVER* refer to
       /module names/. Instead, you use /package names/ in the same way that
       they have always been used.

       =From Jian= This means when migrating to the OLD Java code to Java 9 with
       /module system/, *you do NOT need to touch the source code*!

** DONE 15.3 The Modular “Hello, World!” Program - 472
   CLOSED: [2018-01-12 Fri 03:10]
   1. *By convention*,
      the name of the /base directory/ is the same as the /module name/.
      #+BEGIN_SRC text
        ch15.sec03/
        └ module-info.java
          com/
          └ horstmann/
            └ hello/
              └ HelloWorld.java
      #+END_SRC

   2. =module-info.java=
      #+BEGIN_SRC java
        @SuppressWarnings("module")
        module ch15.sec03 {
        }
      #+END_SRC

   3. =$ javac ch15.sec03/module-info.java ch15.sec03/com/horstmann/hello/HelloWorld.java=

      + _The =module-info.java= file does *NOT* look like a Java source file_,
        and of course there *CANNOT be a /class/ with the name =module-info=,*
        since /class names/ *CANNOT contain hyphens*.
          The ~module~ keyword, as well as keywords ~requires~, ~exports~, and
        so on, that you will see in the following sections, are /restricted
        keywords/ that have a _special meaning *ONLY* in /module declarations/._

        =TODO= =???= =HOW= =HOW= =HOW=
        The file is compiled into a class file =module-info.class= that contains
        the /module definition/ in binary form.

        =From Jian=
        A =.class= file can contain /module definition/, rather than a /class/.

   4. =$ java --module-path ch15.sec03 --module ch15.sec03/com.horstmann.hello.HelloWorld=
      OR for short
      =$ java -p ch15.sec03 -m ch15.sec03/com.horstmann.hello.HelloWorld=

      + To run this program as a /modular application/, you specify the
        /module path/, which is *similar to* the /class path/, but it contains
        /modules/. You also specify the /main class/ in the format
        =modulename/classname=.

   5. NOTE:
      + If not use the =@SuppressWarnings("module")= /annotation/ in the
        =module-info.java= file, we will see warnings
        #+BEGIN_SRC text
          warning: [module] module name component sec03 should avoid terminal digits
          warning: [module] module name component ch15 should avoid terminal digits
        #+END_SRC

        This kind of warnings are used to tell the programmer _add the version
        info into the /module names/ is a *bad idea*._

      + In this one respect, the /module declaration/ is just like a
        /class declaration/: _You can /annotate/ it_.

        =TODO= =???=
        (The /annotation/ type must have target =ElementType.MODULE=.)

*** DONE 15.3.1 Use IntelliJ IDEA to run the example above - *From Jian*
    CLOSED: [2018-01-12 Fri 02:53]
    1. Create an empty folder called =ch15.sec03=.

    2. Create the package =com.horstmann.hello=.

    3. In this =com.horstmann.hello= package, add a =HelloWorld.java= file with
       content:
       #+BEGIN_SRC java
         package com.horstmann.hello;

         public class HelloWorld {
             public static void main(String[] args)
             {
                 System.out.println("Hello, Modular World!");
             }
         }
       #+END_SRC

    4. Create the =module-info.java= file in the =ch15.sec03= folder.
       Its content is
       #+BEGIN_SRC java
         @SuppressWarnings("module")
         module ch15.sec03 {
         }
       #+END_SRC

    5. Use IntellJ to open this =ch14.sec03= as a /project/.

    6. Right click the /root folder/ =ch14.sec03=, and in the menu choose
       =Mark directory as ...= -> =Source root=.

    7. In the menu, click Run -> + symbol -> Application. And fill in the
       *Configuration* tab with:
       - Main class: =com.horstmann.hello.HelloWorld=

       - Working directory: <this project directory>

       - Use classpath of module: =ch15.sec03=

       - JRE (I use default): =Default(9.0 - SDK of 'ch15.sec03' module)=

       - Shorten command line (I use default):
         =user-local default: none - java [options] classname [args]=

       - (a subsection) Before lauch: Build, Active tool windows:
         Click + symbol and pick =Build=

    8. After the create this configuration. You can run it.

*** DONE 15.3.2 Use IntelliJ IDEA re-create the example of this section - *From Jian*
    CLOSED: [2018-01-12 Fri 02:53]
    1. Create a /project/ called =ch15.sec03= and use the default layout.

    2. In the =src= folder, create a package called =com.horstmann.hello=.

    3. In this =com.horstmann.hello= package, add a =HelloWorld.java= file with
       content:
       #+BEGIN_SRC java
         package com.horstmann.hello;

         public class HelloWorld {
             public static void main(String[] args)
             {
                 System.out.println("Hello, Modular World!");
             }
         }
       #+END_SRC

    4. In the =src= folder, create the =module-info.java= file.
       The content is
       #+BEGIN_SRC java
         @SuppressWarnings("module")
         module ch15.sec03 {
         }
       #+END_SRC

    5. In the menu, click Run -> + symbol -> Application. And fill in the
       *Configuration* tab with:
       - Main class: =com.horstmann.hello.HelloWorld=

       - Working directory: <this project directory>

       - Use classpath of module: =ch15.sec03=

       - JRE (I use default): =Default(9.0 - SDK of 'ch15.sec03' module)=

       - Shorten command line (I use default):
         =user-local default: none - java [options] classname [args]=

       - (a subsection) Before lauch: Build, Active tool windows:
         Click + symbol and pick =Build=

    6. After the create this configuration. You can run it.

** DONE 15.4 Requiring Modules - 474
   CLOSED: [2018-01-12 Fri 04:50]
   - Steps:
     1. Create a /project/ called =ch15.sec04= and use the default setting (with
        =src=, and you cannot create =.java= file outside =src=).

        Jian thinks the constraints are enforced by the rules written in the
        =.iml= configuration file of IntelliJ IDEA.

     2. In the =src= folder, create the =module-info.java= file.
        The content is
        #+BEGIN_SRC java
          @SuppressWarnings("module")
          module ch15.sec03 {
              requires java.desktop;
          }
        #+END_SRC

     3. In the =src= folder, create a package called =com.horstmann.hello=.

     4. In this =com.horstmann.hello= package, add a =HelloWorld.java= file with
        content:
        #+BEGIN_SRC java
          package com.horstmann.hello;

          import javax.swing.JOptionPane;

          public class HelloWorld {
              public static void main(String[] args)
              {
                  JOptionPane.showMessageDialog(null, "Hello, Modular World!");
              }
          }
        #+END_SRC

     5. In the menu, click Run -> + symbol -> Application. And fill in the
        *Configuration* tab with:
        - Main class: =com.horstmann.hello.HelloWorld=

        - Working directory: <this project directory>

        - Use classpath of module: =ch15.sec04=

        - JRE (I use default): =Default(9.0 - SDK of 'ch15.sec04' module)=

        - Shorten command line (I use default):
          =user-local default: none - java [options] classname [args]=

        - (a subsection) Before lauch: Build, Active tool windows:
          Click + symbol and pick =Build=

     6. After the create this configuration. You can run it.

   - The ~requires~ statement in =module-info.java= has a a *design goal* of the
     /module system/ that /modules/ are explicit about their requirements, so
     that the virtual machine can *ensure that all requirements are fulfilled
     _BEFORE_ starting a program.*

   - The ~requires~ statement is required when you
     + do NOT only use the _default_ /uname module/
       and
     + do NOT ONLY use the ~java.lang~ /package/

   - We ~requires java.desktop;~.
     The ~java.desktop~ /module/ itself declares that it requires *THREE* other
     /modules/, namely ~java.datatransfer~, ~java.prefs~, and ~java.xml~.

     + However, ~requires~ is *NOT* /transitive/ -- *our module*, though it can
       use packages from /module/ ~java.desktop~, it CANNOT use /packages/ from
       the /modules/ that ~java.desktop~ depends on.

       This can be relaxed in some cases =TODO= Section 15.10.

   - Figure 15-1  The /module graph/ of the Swing "Hello, Modular World!"
     application.

   - The /module graph/ is a /dependency graph/, which, of course, should be
     /directed acyclic graphs/.

   - NOTE:
     If we didn't include the ~requires java.desktop;~ in our =module-info.java=
     file, we can see an error message, which states something like _our
     =ch15.sec04= /module/ did NOT *read* the ~java.desktop~ /module/._ In the
     parlance of the /Java Platform Module System/,
     *module M reads module N* in the following cases:
     1. M *requires* N.

     2. M *requires* a /module/ that *transitively requires* N =TODO= =TODO=
        (see Section 15.10, “Transitive and Static Requirements,” page 487).

     3. N *is* M or ~java.base~.

** DONE 15.5 Exporting Packages - 476
   CLOSED: [2018-01-12 Fri 21:15]
   - Use a ~requires~ keyword to declare the request to a /module/.
     HOWEVER, this does *NOT* automatically make *ALL* /packages/ in the required
     /module/ available.

   - A /module/ states which of its packages are accessible, using the ~exports~
     keyword.
       For example, here is a part of the /module/ declaration for the ~java.xml~
     module:
     #+BEGIN_SRC java
       module java.xml {
           exports javax.xml;
           exports javax.xml.catalog;
           exports javax.xml.datalog;
           exports javax.xml.namespace;
           exports javax.xml.parsers;
           // ...
       }
     #+END_SRC

   - NOTE:
     + A ~exports~ keyword is ALWAYS followed by a /package name/;
     + A ~requires~ keyword is ALWAYS followed by a /module name/.

   - *CAUTION*: =IMPORTANT=
     *A module does not provide a scope.*

     _As a result_,
     You *CANNOT have two /packages/ with the same name in different /modules/.*
     This is true even for /hidden packages (/packages/ that are not exported)/.

   - Here is the source file structure for these *TWO* /modules/:
     #+BEGIN_SRC text
       com.horstmann.greet
       ├ module-info.java
       └ com
         └ horstmann
           └ greet
             ├ Greeter.java
             └ internal
               └ GreeterImpl.java

       ch15.sec05
       ├ module-info.java
       └ com
         └ horstmann
           └ hello
             └ HelloWorld.java
     #+END_SRC

   - Compile command:
     #+BEGIN_SRC bash
       javac com.horstmann.greet/module-info.java \
             com.horstmann.greet/com/horstmann/greet/Greeter.java \
             com.horstmann.greet/com/horstmann/greet/internal/GreeterImpl.java

       # Or the short form:
       javac -p com.horstmann.greet ch15.sec05/module-info.java \
             ch15.sec05/com/horstmann/hello/HelloWorld.java
     #+END_SRC

   - Run the program:
     #+BEGIN_SRC bash
       java -p ch15.sec05:com.horstmann.greet \
            -m ch15.sec05/com.horstmann.hello.HelloWorld
     #+END_SRC

*** DONE 15.5.1 Use IntelliJ IDEA to implement this example - *From Jian*
    - Create a /project/, which is automatically a /module/.
      Therefore, the /modules/ inside this /project/ *CANNOT have the same name
      as the /project/ name*

    - Create TWO /modules/ =com.horstmann.greet= and =ch15.sec05=, and the result is like:
      #+BEGIN_SRC text
        <project root (also a module)>
          ├ com.horstmann.greet
          | └ src
          |   ├ module-info.java
          |   └ com
          |     └ horstmann
          |       └ greet
          |         ├ Greeter.java
          |         └ internal
          |           └ GreeterImpl.java
          |
          └ ch15.sec05
            └ src
              ├ module-info.java
              └ com
                └ horstmann
                  └ hello
                    └ HelloWorld.java
      #+END_SRC

      + /module/ =com.horstmann.greet=:
        * /package/ =com.horstmann.greet=, which will be exported.

        * /package/ =com.horstmann.greet.internal=

        * The content =module-info.java=
          #+BEGIN_SRC java
            module com.horstmann.greet {
                exports com.horstmann.greet; // package name
            }
          #+END_SRC

      + /module/ =ch15.sec04=, which is the application module (an *entry point*
        /class/ inside):
        * /package/ =com.horstmann.hello=

        * The content =module-info.java=
          #+BEGIN_SRC java
            module com.horstmann.greet {
                requires com.horstmann.greet; // module name
            }
          #+END_SRC

    - Configure /module dependencies/:
      + File -> Project Structure -> Modules

      + Click /module/ =ch15.sec05=, and you see the specific configuration for
        this /module/.

        (In this project, ONLY this *application* /module/ depends on another
         /module/, and we ONLY need to configure its dependencies.)

        * Click the *Dependencies* tab

          - Click + symbol to add the =com.horstmann.greet= as a dependency.

    - In the menu, click *Run* -> *Edit Configurations*.
      Then click + symbol to choose *Application* in the drop-down menu to create
      an empty *Application configuration*.

    - Fill in the *Configuration* tab of the new create *Application
      configuration* with:
      + Main class: =com.horstmann.hello.HelloWorld=

      + Working directory: <this project directory>

      + Use classpath of module: =ch15.sec05=

      + JRE (I use default): =Default(9.0 - SDK of 'ch15.sec05' module)=

      + Shorten command line (I use default):
        =user-local default: none - java [options] classname [args]=

      + (a subsection) Before lauch: Build, Active tool windows:
        Click + symbol and pick =Build=

    - After the create this configuration. You can run it.

** TODO 15.6 Modules and Reflective Access - 479 =Read after learning Reflection=
   - NOTE:
     xxx

** DONE 15.7 Modular JARs - 482
   CLOSED: [2018-01-15 Mon 19:06]
   - modular JAR :: a module can be deployed by placing all its classes in a JAR
                    file, with a =module-info.class= in the root.

   - Compile with the ~-d~ option, which places _class files_ into a separate
     directory, to create a modular JAR with multiple packages.
     + The directory is created if it doesn't already exists.

     ~javac -d modules/com.horstmann.greet `find com.horstmann.greet -name *.java`~

   - Use ~-C~ option to change to that directory when collecting files.
     ~jar -cvf com.horstmann.greet.jar -C modules/com.horstmann.greet .~

     =From Jian=
     1. ~-C modules/com.horstmann.greet~ means change directory to the given path.

     2. After changing the path, the command can be considered as
        ~jar -cvf com.horstmann.greet.jar .~
          If you consider all the ~jar~ above as ~tar~, it's easy to understand
        this command -- use all the files in ~.~ to create a JAR with the given
        name ~com.horstmann.greet.jar~ (the /manifest/ is added automatically).

   - If you use a build tool such as Maven, Ant, or Gradle,
     just keep building your JAR file as you always do.
     *As long as =module-info.class= is included*, you get a /modular JAR/.

   - *CAUTION*
     + In the past, there are /split packages/ -- one package is packed to
       multiple JAR's. _This was probably *NEVER* a good idea_.

     + Now you *CANNOT* pack a /modular/ to multiple modular JAR's.
       =From Jian= Perfect!

   - Create a modular JAR with main class specified:
     1. ~javac -p com.horstmann.greet.jar -d modules/ch15.sec05 `find ch15.sec05 -name "*.java"`~
        + This command use the /module JAR/ =com.horstmann.greet.jar= created
          before this command.

        + Here the last argument of the ~find~ command is ~"\star{}.java"~ , rather
          than the ~\star{}.java~ in the book. The former works with both /zsh/ and
          /bash/, and the latter works with /bash/ *ONLY*.

     2. ~jar -c -v -f ch15.sec05.jar -e com.horstmann.hello.HelloWorld -C modules/ch15.sec05 .~

        + =From Jian=
          I don't know WHY, but you cannot write ~-cvf~ (or ~cvf~), or else
          you'll see two error messages:
          #+BEGIN_SRC text
            -e : no such file or directory
            com.horstmann.hello.HelloWorld : no such file or directory
          #+END_SRC
          It seems when you use the combined flags, the ~jar~ command will
          consider ~-e~ and ~com.horstmann.hello.HelloWorld~ as
          files/directories. =TODO= =???= =TODO= =???=

        + You can optionally specify a version number with ~--module-version~.
          ~jar -c -v -f com.horstmann.greet@1.0.jar --module-version 1.0 -C com.horstmann.greet .~
          * As discussed before, this version number won't be used by the /Java
            Platform Module System/.

          * It can queried by other tools and frameworks.

   - NOTE:
     Find out the version number throgh the /reflection/ API
     #+BEGIN_SRC java
       Optional<String> version =
           Greeter.class.getModule().getDescriptor().rawVersion();
       // The result is an `Optinal` containing the version string "1.0".
     #+END_SRC

   - Run it:
     ~java -p com.horstmann.greet.jar:ch15.sec05.jar -m ch15.sec05~

   - NOTE: =TODO= =????????= =TODO=
     Page 483

   - *TIP*: =IMPORTANT= =TODO= =TEST=
     *Load a /module/ into JShell*:
     + include the JAR on the /module path/
       and
     + use the ~--add-modules~ option:

     #+BEGIN_SRC bash
       jshell --module-path com.horstmann.greet@1.0.jar \
              --add-modules com.horstmann.greet
     #+END_SRC
     =From Jian=
     After issuing this command, you can *import* the /packages/ *exported*.

** DONE 15.8 Automatic Modules and the Unnamed Module - 484
   CLOSED: [2018-01-13 Sat 02:36]
   - We cannot stop programming, and wait all the published Java code to be
     re-organized and migrate to modularized code.

   - *For migration purposes*,
     Any JAR file can be turned into a /module/,
     =HOW=
     simply by placing it onto a directory in the /module path/ instead of the
     /class path/.

   - an automatic module :: A JAR without a =module-info.class= on the
        /module path/.

   - An /automatic module/ has the following properties:
     1. The /module/ *IMPLICITLY* has a ~requires~ clause for *ALL other
        /modules/.*
        =TODO=
        =From Jian= Does *all other modules* here means *ALL other /modules/ in
        current /module path/?*

     2. *ALL* of its /packages/ are *exported* and *opened*.
        =From Jian= This is reasonable and easy to guess.

     3. /Module name/ convention:
        1. _IF_
           there is an entry with key =Automatic-Module-Name= in the JAR file
           /manifest/ =META-INF/MANIFEST.MF=,
          *the value becomes the /module name/.*

        2. _OTHERWISE_
           *the /module name/ is obtained from the /JAR file name/*,

           *STRATEGY of eliminating illegal/error-prone characters*:
           + _DROPPING_ any trailing version number
             and
           + _REPLACING_ sequences of non-alphanumeric characters _with a *dot*._

   - A real world example that follows the above given rule:
     Suppose you have a /project/ depends on /Apache Commons CSV library/.
     The JAR file of this library is name as =common-csv-1.4.jar=.
     You put this JAR file into the /module path/.
     Then you can use ~requires common.csv;~ in your =module-info.java=.

   - Since /Commons CSV/ is well known and it is unlikely that someone else will
     try to use the same name for different /modules/,
     the above example has an acceptable /module name/.
       However, this is NOT always the case.

     + *A better SOLUTION* (but STILL should be done by the maintainers):
       It would be better if the maintainers of this JAR file could quickly agree
       to reserve a /reverse DNS name/, preferably the /top-level package/ name
       =org.apache.commons.csv= as the /module name/. They just need to add a
       line into the =META-INF/MANIFEST.MF= file inside the JAR:
       =Automatic-Module-Name: org.apache.commons.csv=

   - NOTE:
     =From Jian= I Re-write this. Use the info, but express different core idea.

     Before you make a Jar file as a /automatic module/:
     1. *CHECK* if it is already a /module/?
        When the answer is yes, use it directly.

     2. If this JAR file is NOT a /module/,
        *CHECK* if a /module name/ is already provided in the /manifest/ file.


   - unnamed module :: A /module/ formed by any class that is NOT on the
                       /module path/.

     + As with /automatic modules/, the /unnamed module/ CAN access *ALL* other
       /modules/, and *ALL* of its /packages/ are *exported* and *opened*.

     + However, *NO* /named module/ CAN access the /unnamed module/.

       * =From Jian=
         Due to this restriction to the other /modules/ of /unnamed module/, the
         main part of the /unnamed module/ can only be the /application code/ --
         it can depends on all other code, and it *cannot* be depended on.

       * Therefore, migration to the Java Platform Module System is necessarily
         *a bottom-up process*:
         1. The Java platform itself is modularized. (=bottom=)

         2. Next, you modularize libraries,
            either by using /automatic modules/ or by turning them into /true
            modules/.
            (=middle=)

         3. Once ALL libraries used by your application are modularized,
            you can turn the code of your application into a module.
            (=top=)

         =From Jian= WHY IN THIS ORDER??? I give more explanation:
         It is obvious why 1 is the bottom.

         If we modularize 3 before modularizing 2, we modularize the application
         code, but leave the un-modularized libraries code as the /unnamed
         module/.
           _HOWEVER_, this is NOT applicable! If all the other parts have already
         been modularized, /unnamed module/ cannot be libraries -- NO modules can
         access the /unnamed module/ -- the second property of /unnamed module/.

** TODO 15.9 Command-Line Flags for Migration - 485
   - NOTE:
     xxx

** DONE 15.10 Transitive and Static Requirements - 487
   CLOSED: [2018-01-14 Sun 21:12]
   - For example,
     Suppose a /module/ requires the ~javafx.controls~ /module/ that contains
     JavaFX user interface elements such as buttons. The ~javafx.controls~
     /module/ requires the ~javafx.base~ /module/, and everyone using
     ~javafx.controls~ will also need ~javafx.base~. For this reason, the
     ~javafx.controls~ /module/ declares the requirement with the ~transitive~
     _modifier_:
     #+BEGIN_SRC java
       module javafx.controls
       {
           requires transitive javafx.base;
           // ...
       }
     #+END_SRC
     Now ANY /module/ that declares a requirement on ~javafx.controls~ now
     automatically requires ~javafx.base~.

   - NOTE:
     Some programmers recommend ALWAYS use ~requires transitive~.
     *DO NOT do this.*

     In the jdk, the =module-info.java= file of /module/ ~java.sql~ includes a
     line ~requires transitive java.logging;~. Use the ~transitive~ here cannot
     be seen as a GOOD idea (but there might be some reason to design like this
     ???? =TODO=) --- ~java.logging~ is used ONLY ONCE in the entire ~java.sql~
     API, namely the ~java.sql.Driver.parentLogger~. It is perfectly acceptable
     to not use ~transitive~, and only those other /modules/ that need to use
     this method declare the requirements of this ~java.logging~ /module/.

   - aggregator module :: a /module/ includes *NO* packages and only /trasitive
        requirements/.
          One such /module/ is ~java.se~, which includes *ALL* /modules/ of the
        Java SE platform. You can use it when you don't need fin-grained /module
        dependencies/.
        #+BEGIN_SRC java
          module java.se {
              requires transitive java.compiler;
              requires transitive java.datatransfer;
              requires transitive java.desktop;
              //...
              requires transitive java.sql;
              requires transitive java.sql.rowset;
              requires transitive java.xml;
              requires transitive java.xml.crypto;
          }
        #+END_SRC

   - ~requires static~ is rarely used.
     The /requires-static module/ means this /module/
     + MUST be present at /compile time/
     + is OPTIONAL at /runtime/.

   - In two cases we may need ~requires static~
     + To access an /annotation/, which is only used at /compile time/, in a
       different /module/.

     + A module is the rank 1 choice, but there are also other options.
       For example,
       #+BEGIN_SRC java
         try {
             new oracle.jdbc.driver.OracleDriver();
             //...
         } catch (NoClassDefFoundError er) {
             // Do something else
         }
       #+END_SRC

** DONE 15.11 Qualified Exporting and Opening - 489
   CLOSED: [2018-01-14 Sun 22:35]
   - qualified export :: the /listed modules/ can access the /package/, but other
        /modules/ CANNOT.
     + For example,
       #+BEGIN_SRC java
         exports com.sun.javafx.collections to
             javafx.controls, javafx.graphics, javafx.fxml, javafx.swing;
       #+END_SRC

   - qualified open :: the /listed modules/ can access the /package/, but other
        /modules/ CANNOT.
     + For example,
       #+BEGIN_SRC java
         opens com.horstmann.places to java.xml.bind;
       #+END_SRC

   - Excessive use of /qualified export/ and /qualified open/ can indicate a poor
     modular structure.

     + Nevertheless, they can arise when modularizing an existing code base.

     + In a greenfield project, one can instead design a more robust public API.
       Re-organize or split some packages to eliminate /qualified export\slash{}open/.

** TODO 15.12 Service Loading - 490
** DONE 15.13 Tools for Working with Modules - 491
   CLOSED: [2018-01-14 Sun 06:15]
   =Summary from Jian=
   This section will introduce three tools distributed with JDK 9.

   =From Jian=
   I'll split this section into three sub-sections.

*** DONE 15.13.1 ~jdeps~ - =From Jian=
    CLOSED: [2018-01-14 Sun 06:02]
    Use ~jdeps~ to analyze the /dependencies/ of a given *set of JAR files*
    =From Jian= Can I use it to analyze a project directory? =TODO=

    - EXAMPLE: Suppose you want to _modularize_ *JUnit 4*. Run a command in the
      pattern of ~$ jdeps <flag> junit-4.12.jar hamcrest-core-1.3.jar~

      + ~-s~ (or ~-summary~) flag:
        The output is the /module (dependencies) summary/ ONLY.
        #+BEGIN_SRC text
          hamcrest-core-1.3.jar -> java.base
          junit-4.12.jar -> hamcrest-core-1.3.jar
          junit-4.12.jar -> java.base
          junit-4.12.jar -> java.management
        #+END_SRC

      + NO flag:
        The output is the /module (dependencies) summary/ followed by the
        /package dependencies summary/ (=Jian= add this incomplete sample
        output):
        #+BEGIN_SRC text
          hamcrest-core-1.3.jar -> java.base
             org.hamcrest     -> java.io                  java.base
             org.hamcrest     -> java.lang                java.base
             org.hamcrest     -> java.lang.annotation     java.base
        #+END_SRC

      + ~-v~ (or ~-verbose~) flag:
        The output is the /module (dependencies) summary/ followed by the
        /class dependencies summary/ (=Jian= add this incomplete sample output):
        #+BEGIN_SRC text
          hamcrest-core-1.3.jar -> java.base
             org.hamcrest.BaseDescription      -> java.lang.Character          java.base
             org.hamcrest.BaseDescription      -> java.lang.Class              java.base
             org.hamcrest.BaseDescription      -> java.lang.Exception          java.base
             org.hamcrest.BaseDescription      -> java.lang.Float              java.base
             org.hamcrest.BaseDescription      -> java.lang.Integer            java.base
             org.hamcrest.BaseDescription      -> java.lang.Iterable           java.base
             org.hamcrest.BaseDescription      -> java.lang.Long               java.base
             org.hamcrest.BaseDescription      -> java.lang.Object             java.base
             org.hamcrest.BaseDescription      -> java.lang.Short              java.base
             org.hamcrest.BaseDescription      -> java.lang.String             java.base
             org.hamcrest.BaseDescription      -> java.lang.StringBuilder      java.base
             org.hamcrest.BaseDescription      -> java.util.Arrays             java.base
             org.hamcrest.BaseDescription      -> java.util.Iterator           java.base
             org.hamcrest.BaseDescription      -> java.util.List               java.base
             org.hamcrest.BaseDescription      -> org.hamcrest.Description     hamcrest-core-1.3.jar
        #+END_SRC

    - ~--generate-module-info <dir>~ flag and parameter:
      Generate =module-info.class= files in the given folder =<dir>=.

    - NOTE:
      Use graphviz (dot language) to generate /depedency graph/:
      ~$ jdeps -s -dotoutput <dir> junit-4.12.jar hamcrest-core-1.3.jar~
      ~$ dot -Tpng <dir>/summary.dot > <dir>/junit/summary.png~

*** DONE 15.13.2 ~jlink~ - =From Jian=
    CLOSED: [2018-01-14 Sun 06:02]
    Use ~jlink~ to produce an application that executes without a separate /Java
    runtime/.

    - The resulting image is much smaller than the entire JDK.

    - Example:
      #+BEGIN_SRC bash
        jlink --module-path com.horstmann.greet.jar:ch15.sec05.jar:${JAVA_HOME}/jmods \
              --add-modules ch15.sec05 \
              --output /tmp/hello
      #+END_SRC

      + You can SPECIFY
        * the /modules/ need to be included (=ch15.sec05= in this example)

          =From Jian= Then the *dependencies* are added automatically from the
          *modules in the given --module-path*

        * an output directory (=/tmp/hello= in this example)

      + In the output directory of the ~jlink~ command, there is a =bin= folder
        with a ~java~ executable. If you run ~<output dir>/bin/java -m ch15.sec05~,
        (suppose you have already added a =MANIFEST.MF=, when creating the
        jars, that indicates the /main class/) the ~main~ method of the
        /module/'s /main class/ is invoked.

        =From Jian= =IMPORTANT=
        If there is NO =MANIFEST.MF=, and to avoid an error about "cannot find
        main class", you need to use the command like
        ~<output dir>/bin/java -m ch15.sec05/com.horstmann.hello.HelloWorld~.
        The ~-m~ is a shorthand to ~--module~, which means it is used to
        indicate the /module/ need to be run. However, when there is *NO*
        =MANIFEST.MF=, you also need provide extra /main class/ info after the
        /to-be-run module name/ in the pattern of *<module>/<MainClass>*. Of
        course, the *<MainClass>* part includes _the FULL package name and class
        name_.

      + The point of ~jlink~ is that it bundles up the *MINIMAL set of modules*
        that is required to run the application. To list them all:
        ~<output dir>/bin/java --list-modules~
        In this example, the output is
        #+BEGIN_SRC text
          ch15.sec05
          com.horstmann.greet
          java.base@9.0.1
        #+END_SRC

      + *All the modules* are included in a /runtime image/ file =lib/modules=.
        * On my computer, it is 23MB,
          whereas the runtime image of all JDK modules take up 181MB.

        * The entire application takes up 45MB, less than 10% of the JDK which
          is 486MB.

    - NOTE:
      You can inspect the /runtime image/ with the ~jimage~ command.
        However, the format is internal to the JVM, and /runtime images/ are
      *NOT* meant to be generated or used by other tools.

**** IntelliJ IDEA - =From Jian=
     - Until now (2017-01-14), IntelliJ IDEA does *NOT* have *simple command* to
       generate JAR's for ~jlink~ -- it by default provide two options after
       clicking the File -> Product Structure -> Artifacts -> + symbol:

       + (Create) JAR -> *Empty*.
           We need to configure from the very beginning (NOT complicated, but
         cumbersome).

       + (Create) JAR -> *From modules with dependencies*.
         This is more like what we want, but we still need to edit the
         "Output Layout" tab to delete the /dependencies/ from the
         _default layout_.

     - See *IDEA-161641 Ability to produce JLink artefacts* in
       https://youtrack.jetbrains.com/issue/IDEA-161641
       I think when this one is finished, this problem is solve.
       The simplest way for the simple cases I met is to add a third option

       _(Create) JAR -> *From modules WITHOUT dependencies*._

*** DONE 15.13.3 ~jmod~ - =From Jian=
    CLOSED: [2018-01-14 Sun 06:14]
    Use ~jmod~ to build and inspect the /module/ files that are included with
    the JDK.

    - When you look into the =jmods= directory inside the the =<JDK>= folder
      (=From Jian= usually the ~JAVA_HOME~ environment variable you configured),
      you will find a file with extension =.jmod= for *EACH* /module/.

      *There is _no longer_ a =rt.jar= file.*

    - *LIKE* JAR files, these JOMD files contain
      + class files

      + (In addition)
        * can hold native code libraries
        * commands
        * header files
        * configuration files
        * legal notices

    - *The JMOD files use the ZIP format.*
      You can inspect their contents with any ZIP tool.

    - *UNLIKE* JAR files, JMOD files are *ONLY useful for /linking/;* that is,
      for producing /runtime images/.
      =TODO=
      =FROM JIAN= Does this /linking/ means ~jlink~, at least mostly ~jlink~?????

      *There is no need for you to produce JMOD files*
      unless you also want to bundle binary files such as native code libraries
      with your modules.

    - NOTE:
      Since the =rt.jar= and =tools.jar= files are no longer included with
      Java 9, _you need to *UPDATE* any references to them_.
      =From Jian= =TODO= What is =tools.jar=????????????????????????????????

        For example, if you referred to =tools.jar= in a /security policy file/,
      =TODO= =FROM JIAN= what is a /security policy file/?????????
      change it to a reference to the /module/:
      #+BEGIN_SRC java
        grant codeBase "jrt:/jdk.compiler" {
            permission java.security.AllPermission;
        };
      #+END_SRC
      The ~jrt:~ syntax denotes the Java runtime file. =TODO= =???= =HOWTO USE??=

** TODO Exercises - 494
   From 1 to 13

* Tips
  - Static initialization occurs when the class is first loaded.

  - _The constructor of an enumeration is always private_.

  - _NOTE_:
    _Integer types in Java are signed_ (In CLR, integer can be unsigned).

      However, if you work with values that can never be negative and you
    really need _an additional bit_, you can use methods that interpret
    values as unsigned.

    For example,
    + Reuirement: a byte value ~b~ represent the range from -128 to 127, you
      may want a range from 0 to 255.

    + Solution: Store it in a ~byte~ type value, and
      =???= due to the nature of binary arithmetic, certain operations such as
      addition and subtraction will work.
      For other operations, call ~Byte.toUnsignedInt(b)~, and get an ~int~
      value between 0 and 255.

  - _Even in hex form, the exponent is written in decimal_

  - _Tip_:
    The ~&~ (and) and ~|~ (or) operators, when applied to ~boolean~ values,
    _force evaluation of both operands before combining the results_.
    =NOT SHORT CIRCUIT ANY MORE=
    This usage is very uncommon:
    1. Provided that the right hand side doesn't have a side effect, they act
       just like ~&&~ and ~||~, except they are less efficient.

    2. If you really need to force evaluation of the second operand, assign it
       to a ~boolean~ variable so that the flow of execution is plainly visible.
       =avoid unwanted multiple side effects, if the rhs has side effect.=
       =this method will has one side effect=
       =if not this method, it might be multiple side effects. It depends on=
       =how many times the rhs is used.=

  - _Java does NOT permit the use of operators with objects_,
    so you must use method calls to work with big numbers.

  - When comparing a string _against a literal string_,
    it is a GOOD idea to _put the literal string first_:
    #+BEGIN_SRC java
    if (“World”.equals(location)) ///...
    #+END_SRC
    This test works correctly even when location is ~null~.

  - For read lines, compare the performance:
    ~Scanner~ use ~hasNextLine()/nextLine~ is slower than the two methods of
    using ~BufferedReader~:
    + Use the ~readLine()~ method.

    + Use the ~lines()~ method, which is lazy since it uses ~Stream<String>~.
