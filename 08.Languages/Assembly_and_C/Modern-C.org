#+TITLE: Modern C
#+Copyright: 2020
#+AUTHOR: Jens Gustedt
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Acknowledgments - ix
* About this book - xi
* About the cover illustration - xvi
* DONE Preliminaries
  CLOSED: [2018-12-27 Thu 17:27]
  - Rule A :: C and C++ are different, don't mix them and don't mix them up.

* DONE LEVEL 0. Encounter - 1
  CLOSED: [2017-04-25 Tue 16:11]
** DONE 1. Getting started - 3
   CLOSED: [2020-02-16 Sun 15:45]
   - TAKEAWAY B :: Don't panic.

*** 1.1. Imperative programming - 4
    - TAKEAWAY 1.1 :: C is an imperative programming language.

*** 1.2. Compiling and running - 5
    - TAKEAWAY 1.2 :: C is a compiled programming language.

    - TAKEAWAY 1.3 :: A correct C program is portable between different platforms.

    - ~-Werror~ (for gcc): reject programs with =warnings=, all =warnings= will
      be treated as errors.

    - TAKEAWAY 1.4 :: A C program should compile cleanly without warnings.

** DONE 2. The principal structure of a program - 11
   CLOSED: [2020-02-16 Sun 15:49]
   - There are _two_ categories of aspects to consider in a C program:
     + syntactical aspects :: how do we specify the program so the compiler
          understands it.
     + semantic aspects :: what do we specify so that the program does what we
          want it to do.

   - In the following subsections we will introduce =RE-READ=
     + the syntactical aspects (“grammar”) and
     + three different semantic aspects, namely
       1. declarative parts (what things are),
       2. definitions of objects (where things are) and
       3. statements (what are things supposed to do).

*** 2.1. Grammar - 11
    - special words
    - punctuations
      + parenthesis (should always come in pairs):
        1. ~{}~
        2. ~()~
        3. ~[]~
        4. ~/**/~
        5. ~<>~: on the same logical line of text.
    - TAKEAWAY 2.1 :: Punctuation characters can be used with several different meanings.
    - comments
    - literals
    - identifiers
    - functions
    - operators

*** 2.2. Declarations - 13
    - TAKEAWAY 2.2 :: All identifiers of a program have to be declared.

    - How identifiers differ from keywords?
      + identifier: declared before being used.
      + keyword: predefined by the language, and must not be declared or redefined.

    - Declarations may be repeated, but only if they specify exactly the same thing.

    - TAKEAWAY 2.3 :: Identifiers may have several consistent declarations.

    - TAKEAWAY 2.4 :: Declarations are bound to the scope in which they appear.

    - Identifiers in _file scope_ are often referred to as globals.
 
*** 2.3. Definitions - 15
    - TAKEAWAY 2.5 :: Declarations specify identifiers whereas definitions speci-
                      fy objects.

    - TAKEAWAY 2.6 :: An object is defined at the same time as it is initialized.

    - TAKEAWAY 2.7 :: Missing elements in initializers default to 0.

    - TAKEAWAY 2.8 :: For an array with =n= the first element has index ~0~, the
                      last has index ~n-1~.

    - TAKEAWAY 2.9 :: Each object must have exactly one definition.

    - _COMMENT_: This rule concerns data objects as well as function objects.

*** 2.4. Statements - 17
**** 2.4.1. Iteration - 17
     - /domain iteration/: each iteration of ~for~ is related to a specific value
       ~i~, which makes this ~for~ an iteration over the /domain/ =0, . . . , 4=.
       This kind of iteration is called /domain iteration/.
 
     - TAKEAWAY 2.10 :: Domain iterations should be coded with a for statement.

     - TAKEAWAY 2.11 :: The loop variable should be defined in the initial part of
                        a ~for~, if it not used outside.

**** 2.4.2. Function calls - 18
**** 2.4.3. Function return - 19
     - ~EXIT_SUCCESS~ from ~stdlib.h~

* DONE LEVEL 1. Acquaintance - 21
  CLOSED: [2017-04-25 Tue 16:11]
  - Write good C programs.
    "Good" here refers to _a modern understanding of the language_:
    1. avoiding most of the pitfalls of early dialects of C,
    2. offering you some constructs that were not present before, and that are
       portable across the vast majority of modern computer architectures, from
       your cell phone to a mainframe computer.

  - The most dangerous constructs in C are the so-called /casts/, so we'll skip
    them at this level.
    + We will _focus_ primarily on the ~unsigned~ versions of integer types.
    + We will _introduce_ /pointers/ in steps: ......
    + We will _focus_ on the use of /arrays/ whenever possible, instead.

  - We define variables as close to their first use as possible.

  - Lack of variable initialization, especially for pointers, is one of the major
    pitfalls for novice C programmers. This is why we should, whenever possible,
    combine the declaration of a variable with the first assignment to it

  - We use prefix notation for code blocks (in this book).

** TODO Warning to experienced C Programmers - 13
** DONE 3. Everthing is about control - 27
   CLOSED: [2017-04-25 Tue 16:11]
*** 3.1. Conditional execution - 28
   - /controlling expression/, /dependent block/

   - Rule 1.3.1.1 :: The value 0 represents logical false.

   - Rule 1.3.1.2 :: Any value different from 0 represents logical true.

   - =stdbool.h=
     #+BEGIN_SRC c
     #include <stdbool.h>
     bool b = true;
     #+END_SRC

   - Rule 1.3.1.3 :: Don’t compare to ~0~, ~false~ or ~true~.

   - Rule 1.3.1.4 :: All scalars have a truth value.
                     TABLE 1. Scalar types used in this book =RE-READ=

*** 3.2. Iterations - 30
    - Example 1:
      #+BEGIN_SRC c
      #include <stdlib.h>
      // Iterate 9 times! Type size_t is a nonegative type.
      for (size_t i = 9; i <= 9; --i) {
        something_else(i);
      }
      #+END_SRC

    - ~do ... while~ always needs a semicolon ; after the while (condition) to
      terminate the statement. =IMPORTANT=

    - [ =TODO= ] Later we will see that this is a syntactic feature that turns
      out to be quite useful in the context of multiple nested statements, see
      Section 10.3.

    - Special usage (equivalent loosp):
      #+BEGIN_SRC c
      #include <tgmath.h>

      double const eps = 1E-9;
      double const a = 34.0;
      double x = 0.5;

      // #1
      while (fabs(1.0 - prod) >= eps) {
        double prod = a * x;
        x *= (2.0 - prod);
      }

      // #2
      while (true) {
        double prod = a * x;

        if (fabs(1.0 - prod) < eps) {
          break;
        }

        x *= (2.0 - prod);
      }

      // #3
      // there is a tradition among C programmers to write it in as follows.
      for (;;) {
        double prod = a*x;

        if (fabs(1.0 - prod) < eps) {
          break;
        }

        x *= (2.0 - prod);
      }
      #+END_SRC

    - PAGE 19 =TODO ???=

*** 3.3. Multiple selection - 34
    - The /fallback/ case of ~switch~.
    - Rule 1.3.3.1 :: ~case~ values must be integer constant expressions.
    - Rule 1.3.3.2 :: ~case~ labels must not jump beyond a variable definition. =TODO ???=

** DONE 4. Expressing computations - 37
   CLOSED: [2017-04-25 Tue 16:11]
   - Rule 1.4.0.1 :: The type ~size_t~ represents values in the range
                     ~[0, SIZE_MAX]~.
   - The value of ~SIZE_MAX~ (from =stdint.h=) is quite large, depending on the
     platform it should be one of
     1. 2^16 − 1 = 65535 (minimal requirement)
     2. 2^32 − 1 = 4294967295 (common today)
     3. 2^64 − 1 = 18446744073709551615 (common today)

*** 4.1. Arithmetic - 40
**** 4.1.1. ~+~, ~-~ and ~*~ - 40
     - TABLE 2 :: value operators =IMPORTANT=
     - TABLE 3 :: object operators =IMPORTANT=
     - TABLE 4 :: type operators =IMPORTANT=
     - Rule 1.4.1.1 :: Unsigned arithmetic is always well defined. =TODO ???=
     - Rule 1.4.1.2 :: Operations +, - and * on size_t provide the
                       mathematically correct result if it is representable as a
                       ~size_t~.

**** 4.1.2. Division and remainder - 41
     - ~/~ and ~%~.
     - Rule 1.4.1.3 :: For unsigned values, ~a == (a/b)*b + (a%b)~ is ~true~.
     - Rule 1.4.1.4 :: Unsigned ~/~ and ~%~ are well defined only if the second
                       operand is not =0=.
     - Rule 1.4.1.5 :: Arithmetic on ~size_t~ implicitly does computation
                       ~% (SIZE_MAX+1)~
     - Rule 1.4.1.6 :: In case of overflow, unsigned arithmetic wraps around.
     - Rule 1.4.1.7 :: The result of unsigned ~/~ and ~%~ is always smaller than
                       the operands. _And thus_
     - Rule 1.4.1.8 :: Unsigned ~/~ and ~%~ can't overflow.

*** 4.2. Operators that modify objects - 42
    - Rule 1.4.2.1 :: Operators must have all their characters directly attached
                      to each other. i.e. ~+ +~ is invalid.
    - Rule 1.4.2.2 :: Side effects in value expressions are evil.
    - Rule 1.4.2.2 :: Side effects in value expressions are evil.
    - /postfix increment/ and /postfix decrement/.
    - Sciene You will nicely obey to _Rule 1.4.2.2_, you will not be tempted to
      use them.

*** 4.3. Boolean context - 43
    - Two categories:
      1. comparisons
      2. logical evaluation

**** 4.3.1. Comparison - 43
     - Rule 1.4.3.1 :: Comparison operators return the values ~false~ or ~true~.
**** 4.3.2. Logic - 44
     - Rule 1.4.3.2 :: Logic operators return the values ~false~ or ~true~.


    - Page =26= _NEW_Standard.
*** 4.4. The ternary or conditional operator - 45
    - =complex.h= is indirectly included by =tgmath.h=.
    - ~__STDC_NO_COMPLEX__~
    - ~#error~

*** 4.5. Evaluation order - 45
    - Rule 1.4.5.1 :: &&, ||, ?: and , evaluate their first operand first.

    - Rule 1.4.5.2 :: Don’t use the , operator.
                      _Remark_: ~A[i, j]~ is not a two dimension index for
                                matrix ~A~, but results just in ~A[j]~.

    - Rule 1.4.5.3 :: Most operators don’t sequence their operands.
                      Other operators, excepts ~&&~, ~||~, ~?:~ and ~,~ don’t
                      have an evaluation restriction.
                      _Remark_: That chosen order can depend on your compiler, on
                                the particular version of that compiler, on
                                compile time options or just on the code that
                                surrounds the expression. Don’t rely on any such
                                particular sequencing.
                                i.e.,
                                ~f(a) + g(b)~, if ~f(a)~ has side effects that
                                can change ~g(b)~, or vice versa, this is a
                                _potential bug_. =IMPORTANT=

    - Rule 1.4.5.4 :: Function calls don’t sequence their argument expressions.

    - Rule 1.4.5.5 :: Functions that are called inside expressions should not have side effects.

** TODO 5. Basic values and data - 49 - =RE-READ=
*** 5.1. The abstract state machine - 50
**** 5.1.1. Values - 52
     - Rule 1.5.0.1 :: All values are numbers or translate to such.

     - The /state/ of the program execution is determined by: =IMPORTANT=
       * the executable
       * the current point of execution
       * the data
       * outside intervention such as IO from the user. 

     - (_Different from the original text, changed by Jian_):
       We usually don't satisfy the points above, and we want get rid of the
       first point "the executable", which is platform specific.
         _From Jian_: The last point is also platform specific, but if we can
       ignore the IO action details, it can be considered as platform
       independent.

**** 5.1.2. Types - 52
     - A /type/ is an additional property that C associates with values.

     - Rule 1.5.0.2 :: All values have a type that is statically determined.

     - Rule 1.5.0.3 :: Possible operations on a value are determined by its type.

     - Rule 1.5.0.4 (ver1) :: A value's type determines the results of all
          operations.

     - Rule 1.5.0.4 (ver2) :: A value's type determines the sematics of all
          related operations, and then determines the results of all operations.

**** 5.1.3. Binary representation and the abstract state machine - 52
     - Since there are things that can't be specified by C standard,
       C can't impose the results of the operations on a given type completely.
       e.g.
       * /sign representation/: how does the sign or signed type is represented.
       * /floating point representation/: this usually follows the IEEE standard.

     - C only imposes as much properties on all representations, such that the
       _results of operations can be deduced a priori from two different sources_:
       * the values of the operands
       * some characteristic values that describe the particular platform.
       e.g.
       the operations on the type ~size_t~ can be entirely determined when ins-
       pecting the value of ~SIZE_MAX~ in addition to the operands.

     - We call the model to represent values of a given type _on a given
       platform_ the /binary representation/ _of the type_.

     - Rule 1.5.0.5 :: A type's binary representation determines the results of
                       all operations.

     - Generally, all information that we need to determine that model are in
       reach of any C program, the C library headers provide the necessary infor-
       mation through named values (such as ~SIZE_MAX~), operators and function
       calls. 
 
     - Rule 1.5.0.6 :: A type's binary representation is observable.

     - /object representation/ =TODO= Section 12.1

     - The program text describes an /abstract state machine/ that regulates how
       the program switches from one state to the next.
         These transitions are determined _only_ by
       * value,
       * type, and
       * binary representation
 
     - Rule 1.5.0.7 (as-if) :: Programs execute as if following the abstract
          state machine.

**** 5.1.4. Optimization - 53
     - =IMPORTANT= How a concrete executable achieves this goal is left to the
       discretion of the compiler creators.
         Most modern C compilers produce code that
       * doesn’t follow the exact code prescription,
       * they cheat (for efficiency) wherever they can and
       * _only respect the observable states of the abstract state machine_.

     - But such an optimization can also be forbidden because the compiler can't
       prove that a certain operation will not force a program termination.
       e.g.
       _unsigend integer_ overflow usually won't raise an exception, but
       _signed integer_ overflow may raise an exception.

     - Rule 1.5.0.8 :: Type determines optimization opportunities. =IMPORTANT=

*** 5.2. Basic types - 54
    - _first level of specification_: it is entirely done with _keywords_ of
      the language, such as ~signed~, ~int~ or ~double~.
        This first level is mainly _organized_ according to _C internals_.

    - (On top of that first level) _second level of specification_: it comes
      through header files and for which we already have seen examples, too,
      namely ~size_t~ or ~bool~.
        This second level is _organized_ by _type semantic_, that is by
      specifying what properties a particular type brings to the programmer.

    - As a principal distinction we have _two different classes_ of numbers, with
      _two subclasses_, each, namely
      1. unsigned integers,
      2. signed integers
      3. real floating point numbers and
      4. complex floating point numbers

      They differ according to their precision, which determines the valid range
      of values that are allowed for a particular type.

    - /narrow types/ can't be directly used for arithmetic.

    - Rule 1.5.1.1 :: Each of the 4 classes of base types has 3 distinct
                      unpromoted types.

    - Table 6. an overview of the 18 base types.

    - =IMPORTANT= Remember that _unsigned types_ are the most convenient types,
      since they are the _only types_ that
      1. They have an arithmetic that is defined consistently with mathematical
         properties, namely modulo operation.
      2. They can't raise signals on overflow and
      3. They can be optimized best.
      TODO They are described in more detail in Section 5.5.1. =IMPORTANT=

    - Rule 1.5.1.2 :: Use ~size_t~ for
      1. _sizes_,
      2. _cardinalities_ or
      3. _ordinal numbers_.
 
    - Rule 1.5.1.3 :: Use ~unsigned~ for small quantities that can’t be negative.
 
    - Rule 1.5.1.4 :: Use ~signed~ for small quantities that bear a sign.

    - Rule 1.5.1.5 :: Use ~ptrdiff_t~ for large differences that bear a sign. =TODO ??????=

    - Rule 1.5.1.6 :: Use ~double~ for floating point calculations.
 
    - Rule 1.5.1.7 :: Use ~double complex~ for complex calculations.

    - Table 7. Some semantic arithmetic types for specialized use cases. =RE-READ=

    - PAGE 34 =RE-READ=

*** 5.3. Specifying values - 57
    - /literals/:
      * =123= - /decimal integer constant/.
      * =077= - /octal integer constant/. This type of specification has merely
        historical value and is rarely used nowadays.
      * =0xFFFF= - /hexadecimal integer constant/.
      * =1.7E-13= - /decimal floating point constant/
      * =0x1.7aP-13= - /hexadecimal floating point constant/.
        Usually used to describe floating point values in a form that will
        ease to _specify values that have exact representations_.
          Use this representation is because map from hex to bin is easy and no
        precision lost, and hex representation is much shorter.
      * 'a' - /integer character constant/.
      * "hello" - /string literal/.

      All but the last are numerical constants.

    - Rule 1.5.2.1 :: Consecutive string literals are concatenated.

    - =EXPLANATION=: That is if we write something like =-34= or =-1.5E-23=,
      _the leading sign is not considered part of the number but is the negation
      operator applied to the number that comes after_.
        =TODO= We will see below where this is important. =IMPORTANT=
        Bizarre as this may sound, the minus sign in the exponent is considered
        to be part of a floating point literal. =TODO ???=

    - Rule 1.5.2.2 :: Numerical literals are never negative.

    - Rule 1.5.2.3 :: Decimal integer constants are signed.
 
    - Rule 1.5.2.4 :: A decimal integer constant has the first of the _3_ signed
                      types that fits it.

    - =EXPLANATION=: This rule can have surprising effects. Suppose that on a
      platform the minimal signed value is −2^15 = −32768 and the maximum value
      is 2^15 − 1 = 32767. The constant 32768 then doesn't fit into signed and is
      thus signed long. As a consequence the expression -32768 has type signed
      long. Thus the minimal value of the type signed on such a platform cannot
      be written as a literal constant. =IMPORTANT=

    - Rule 1.5.2.5 :: The same value can have different types.

    - Rule 1.5.2.6 :: Don't use octal or hexadecimal constants to express
                      negative values.

    - Rule 1.5.2.7 :: Use decimal constants to express negative values.

    - Integer constants can be forced to be _unsigned_ or to be of
      _a type of minimal width_.
      This done by appending =U=, =L= or =LL= to the literal.
      e.g.
      * ~1U~ has value 1 and type ~unsigned~,
      * ~1L~ is ~signed long~, and
      * ~1ULL~ has the same value but type ~unsigned long long~.

    - =TIPs= Show that the expressions ~-1U~, ~-1UL~ and ~-1ULL~ have the maximum
      values and type of the three usable unsigned types, respectively.
      =IMPORTANT=

    - Table 8 =RE-READ=

    - _A common error_ is to try to assign a hexadecimal constant to a _signed_
      under the expectation that it will represent a negative value. =IMPORTANT=

    - Rule 1.5.2.8 :: Different literals can have the same value.
                      =COMMENT=: This is obvious for integers, but this is not
                      obvious for floating point numbers.
                      However, this is important for floating point numbers.
                      =IMPORTANT=

    - Rule 1.5.2.9 :: The effective value of a decimal floating point constant
                      may be different from its literal value.

    - floating point constants can be followed by the letters ~f~ or ~F~ to
      denote a ~float~
      or
      by ~l~ or ~L~ to denote a ~long double~.
      Otherwise
      they are of type ~double~.

    - Rule 1.5.2.10 :: Literals have value, type and binary representation.

**** 5.2.1 Complex constants - 61
     - Complex types are _not necessarily supported_ by all C platforms.
       The fact can be checked by inspecting ~__STDC_NO_COMPLEX__~.

     - To have full support of complex types, use ~#include <complex.h>~.
       If you use ~#include <tgmath.h>~ for mathematical functions, =complex.h=
       this is already done implicitly.

     - Rule 1.5.4.12 :: ~I~ (macro) is reserved for the imaginary unit.
                        =COMMENT=: leave ~I~ alone, don't use it as the name of
                                   an identifier you create.

     - Two form:
       1. ~0.5 + 0.5*I~ is of type ~double complex~, and ~0.5F + 0.5F*I~ is of
          type ~float complex~.
       2. ~CMPLX(0.5, 0.5)~ is the same ~double complex~ value as above.
          ~CMPLXF(0.5F, 0.5F)~ is the same ~float complex~ value as above.
            =COMMENT=: This usage is what Jian guesses, no example in the book.
            =TODO= read the ~complex.h~ later.

     - TABLE 9. Bounds for scalar types used in this book =TODO RE-READ=

*** 5.4. Implicit conversions - 61
*** 5.5. Initializers - 64
    - Rule 1.5.3.1 :: All variables should be initialized.

    - =TODO= VLA, see Section 6.1.3, that don’t allow for an initializer, or code
      that must be highly optimized.

    - =TODO ???= For most code that we are able to write so far, a modern compi-
      ler will be able to trace the origin of a value to the last assignment or
      the initialization. Superfluous assignments will simply be optimized out.

    - Scalar initializer expression may be surrounded with an _optional_ ~{}~.
      Initializers for other types _must_ have these ~{}~.
      #+BEGIN_SRC C
      # scalars
      double a = 7.8;
      double b = 2 * a;
      double c = { 7.8 };
      double d = { 0 };
      
      # vectors
      double A[] = { 7.8, };
      double B[3] = { 2 * A[0], 7, 33, };
      double C[] = { [0] = 7.8, [7] = 0, };
      #+END_SRC
      Designated initializers as for =C= above are by far preferable,
      since they make the code more robust against small changes in declaration.

    - /incomplete type/: it is completed by the initializer to fully specify the
      length.

    - Rule 1.5.3.2 :: Use designated initializers for all aggregate data types.

    - Rule 1.5.3.3 :: ~{0}~ is a valid initializer for all object types that are
                      not VLA. =IMPORTANT=

    - There are several things, that ensure that this works.
      * First,
        + _if_ we omit the designation (the =.fieldname= for ~struct~, see
          Section 6.3 or ~[n]~ for arrays, see Section 6.1)
          1. initialization is just done in /declaration order/, that is the =0=
             in the default initializer designates the very first field that is
             declared, and
          2. all other fields then are initialized per default to =0= as well.

      * Then, the ~{}~ form of initializers for scalars ensures that ~{ 0 }~ is
        also valid for these.

      =IMPORTANT= (gcc, g++, clang, and clang++ work well with this feature)
      Maybe your compiler warns you about this: annoyingly some compiler
      implementers don't know about this special rule. It is explicitly designed
      as catch-all initializer in the C standard, so this is one of the rare
      cases where I would switch off a compiler warning.

*** 5.6. Named constants - 65
    - Rule 1.5.4.1 All constants with particular meaning must be named.

    - Rule 1.5.4.2 All constants with different meaning must be distinguished.

**** 5.6.1. Read-only objects - 66
     - Rule 1.5.4.3 An object of const-qualified type is read-only.
       =COMMENT=: That DOESN'T MEAN that the compiler or run-time system may not
       perhaps change the value of such an object: other parts of the program
       may see that object without the qualification and change it. =IMPORTANT=
       e.g.
       The fact that you cannot write the summary of your bank account directly
       (but only read it), doesn't mean that it will remain constant over time.

     - Rule 1.5.4.4 String literals are read-only.
       There is another family of read-only objects, that _unfortunately_ are
       _not protected_ by their type from being modified: /string literals/.

       =Rationale=: If introduced today, the type of string literals would
       certainly be ~char const[]~, an array of const-qualified characters.
       Unfortunately, the const keyword had only been introduced much later than
       string literals to the C language, and therefore remained as it is for
       backward compatibility.
**** 5.6.2. Enumerations - 67 =RE-READ DO NOT QUITE UNDERSTAND=
      - Rule 1.5.4.5 :: Enumeration constants have either
        1. an explicit or
        2. positional value.

      - Rule 1.5.4.6 :: Enumeration constants are of type ~signed int~.

      - Rule 1.5.4.7 :: An integer constant expression doesn't evaluate any
                        object.

      - /integer constant expression/: abbreviated as /ICE/. =TODO: explanation=

      - Still, even when the value is an /ICE/ to be able to use it to define an
        enumeration constant you'd have to ensure that the value fits into a
        ~signed~.

**** 5.6.3. Macros - 68
     - example: ~# define M_PI 3.14159265358979323846~. This macro definition
       consists of 5 different parts:
       1. A starting ~#~ character that _must be_ the first non-blank character
          on the line.
       2. The keyword ~define~.
       3. An identifier that is to be declared, here ~M_PI~.
       4. The replacement text, here =3.14159265358979323846=.
       5. A terminating newline character.

     - In this book such C standard macros are all printed in _dark red_.

     - Rule 1.5.4.8 :: Macro names are in all caps.
       =COMMENT=: This is a =CONVETIONS=, and it is applicable for most cases,
       though not all.

**** 5.6.4. Compound literals - 69 =RE-READ=
     - For types that don't have literals that describe their constants, things
       get even a bit more complicated.
         We have to use /compound literals/ on the replacement side of the macro.
       Such a /compound literal/ has the form =(T) { INIT }= (a type, in
       parenthesis, followed by an initializer).
       e.g.
       #+BEGIN_SRC C
       # define CORVID_NAME /**/        \
       (char const*const[corvid_num]){  \
         [chough] = "chough",           \
         [raven] = "raven",             \
         [magpie] = "magpie",           \
         [jay] = "jay",                 \
       }
       // With that we could leave out the "animal" array from above and rewrite
       // our for-loop:

       for (unsigned i = 0; i < corvid_num; ++i) {
         printf("Corvid %u is the %s\n", i, CORVID_NAME[i]); 
       }
       #+END_SRC

     - Rule 1.5.4.9 :: A compound literal defines an object.

     - Over all, _this form of macro_ has some _PITFALLS_ =MOST IMPORTANT=:
       * Compound literals aren't suitable for ICE.

       * For our purpose here to declare "named constants" the type T should be
         constqualified C. This ensures that the optimizer has a bit more slack-
         ness to generate good binary code for such a macro replacement.

       * There must be space between the macro name and the ~()~ of the compound
         literal, here indicated by the ~/**/~ comment. Otherwise this would be
         interpreted as the start of a definition of a function-like macro.
         We will see these much later.

       * A backspace character ~\~ at the very end of the line can be used to
         _continue the macro_ definition to the next line.

       * There _must be no_ ~;~ at the end of the macro definition. Remember it
         is all just text replacement.

     - Rule 1.5.4.10 :: Don't hide a terminating semicolon inside a macro.

     - Rule 1.5.4.11 :: Right-indent continuation markers for macros to the same
                        column.
                        =COMMENT=: As you can see above this helps to visualize
                        the whole spread of the macro definition easily.

     - 
*** 5.7. Binary representions - 70 - =RE-READ=
    - Rule 1.5.5.1 :: The same value may have different binary representations.

**** 5.5.1. Unsigned integers - 70
     - Rule 1.5.5.2 :: Unsigned arithmetic wraps nicely.

     - ~UINT_MAX~, ~ULONG_MAX~ and ~ULLONG_MAX~ are provided through =limits.h=.

     - ~SIZE_MAX~ for ~size_t~ is from =stdint.h=.

     - \sum (b_i * 2^i) from i=0 to p-1. Here b_0, ..., b_{p-1} are called
       /bits/. Here p is /precision/.

     - /LSB/: Of the bits b_i that are 1 the one with minimal index i is called the
       /least significant bit/.

     - /MSB/: the one with the highest index is the /most significant bit/.

     - Rule 1.5.5.3 :: The maximum value of any integer type is of the form
                       2^p − 1.

     - Rule 1.5.5.4 :: Arithmetic on an ~unsigned~ integer type is determined by
                       its precision.

**** 5.5.2. Bit sets and bitwise operators - 71
     - ~|~, ~&~, and ~^~.

     - All these operator can be written with identifiers, namely ~bitor~,
       ~bitand~, ~xor~, ~or_eq~, ~and_eq~, ~xor_eq~, and ~compl~ if you include
       header =iso646.h=.

     - A typical usage of bit sets is for "flags", variables that control certain
       settings of a program. E.g. =IMPORTANT=
       #+BEGIN_SRC c
       enum corvid { magpie, raven, jay, chough, corvid_num, };
       #define FLOCK_MAGPIE 1U
       #define FLOCK_RAVEN 2U
       #define FLOCK_JAY 4U
       #define FLOCK_CHOUGH 8U
       #define FLOCK_EMPTY 0U
       #define FLOCK_FULL 15U

       int main(void) {
         unsigned flock = FLOCK_EMPTY;
         // ...
         if (something) { flock |= FLOCK_JAY; } 
         // ...
         if (flock & FLOCK_CHOUGH) {
           do_something_chough_specific(flock);
         }
       #+END_SRC

**** 5.5.3. Shift operators - 73
     - Rule 1.5.5.5 :: The second operand of a shift operation must be less than
                       the precision.

**** 5.5.4. Boolean values - 74
     - Treating ~bool~ as an _unsigned type_ is a certain stretch of the concept.
     - Assignment to a variable of that type doesn’t follow the
       Modulus Rule 1.4.1.5, but a the special Rule 1.3.1.1.
**** 5.5.5. Signed integers - 74
     - The complexity of _signed types_ are more complicated than
       _unsigned types_, because a C implementation has to decide on two points:
       1. What happens on arithmetic overflow?
       2. How is the sign of a signed type represented?

     - Rule 1.5.5.6 :: Positive values are represented independently from
                       signedness.

     - C allows three different /sign representations/:
       1. /sign and magnitude/ =only have historic or exotic relevance=
       2. /one's complement/ =only have historic or exotic relevance=
       3. /two's complement/ =in use=

     - Where unsigned values are forced to wrap around,
       _the behavior of a signed overflow is undefined_.

     - page 46: The as-if Rule 1.5.0.7 allows it to optimize the second loop
       to ...
       =From Jian= Never do optimization with undefined behavior!!!
       =IMPORTANT= [[http://www.yinwang.org/blog-cn/2016/10/12/compiler-bug][C 编译器优化过程中的 Bug]] and
                   [[https://www.zhihu.com/question/51544127][如何评价《王垠：C 编译器优化过程中的 Bug》？]]

     - Rule 1.5.5.7 :: Once the abstract state machine reaches an
                       _undefined state_ no further assumption about the
                       continuation of the execution can be made.

     - Rule 1.5.5.8 :: It is your responsibility to avoid undefined behavior of
                       all operations.

     - Rule 1.5.5.9 :: ~signed~ arithmetic may trap badly.

     - Rule 1.5.5.10 :: In twos' complement representation ~INT_MIN < -INT_MAX~.

     - Or stated otherwise, in _twos' complement representation_ the
       _positive value_ ~-INT_MIN~ is out of bounds since the value of the
       operation is larger than ~INT_MAX~.

     - Rule 1.5.5.11 :: Negation may overflow for ~signed~ arithmetic.

     - Rule 1.5.5.12 :: Use ~unsigned~ types for bit operations.

**** 5.5.6. Fixed width integer types - 77
     - Rule 1.5.5.13 :: If the type ~uintN_t~ is provided it is an unsigned
                        integer type with _exactly N bits width_ and precision.

     - Rule 1.5.5.14 :: If the type ~intN_t~ is provided it is signed, with two's
                        complement representation, has
                        _a width of exactly N bits_ and
                        _a precision of N − 1_.

     - _None of these types is guaranteed to exist, but_

     - Rule 1.5.5.15 :: If types with the required properties exist for values of
                        8, 16, 32 or 64, types ~uintN_t~ and ~intN_t~ respective-
                        ly must be provided.

     - And in fact, nowadays platforms _usually_ provide:
       * uint8_t, uint16_t, uint32_t and uint64_t unsigned types and
       * int8_t, int16_t, int32_t and int64_t signed types.

     - Their presence and bounds can be tested with _macros_:
       * UINT8_MAX, UINT16_MAX, UINT32_MAX and UINT64_MAX for unsigned types and
       * INT8_MIN, INT8_MAX, INT16_MIN, INT16_MAX,INT32_MIN, INT32_MAX, INT64_MIN and INT64_MAX,
         respectively.
       To encode literals of the requested type there are _macros_:
       * UINT8_C, UINT16_C, UINT32_C UINT64_C,
       * INT8_C, INT16_C, INT32_C and INT64_C, respectively.
       E.g on platforms where uint64_t is unsigned long, INT64_C(1) would expand to 1UL.
       =TODO=

     - =inttypes.h= provides PRId64, PRIi64, PRIo64, PRIu64, PRIx64 and PRIX64,
       for printf formats "%d", "%i", "%o", "%u", "%x" and "%X", respectively:
       #+BEGIN_SRC C
       uint32_t n = 78;
       int64_t max = (-UINT64_C(1))>>1; // same value as INT64_MAX
       printf("n is %" PRIu32 ", and max is %" PRId64 "\n", n, max);
       #+END_SRC

     - Rule 1.5.5.16 :: For any of the fixed-width types that are provided,
                        ~_MIN~ (only ~signed~), ~maximum _MAX~ and literals ~_C~
                        macros are provided, too.

**** 5.5.7. Floating point data - 78
     - =float.h=: ~DBL_MIN~ and ~DBL_MAX~ that provides us with the _minimal_ and
       _maximal_ values for ~double~.
       =But beware=: here ~DBL_MIN~ is the smallest number that is strictly
                     _greater then 0.0_;
                     the _smallest negative_ ~double~ value is ~-DBL_MAX~.

     - /floating number/: s * 2^e * (sum f_k * 2^(-k) from k=1 to p), where
       e_min <= e <= e_max. e_min and e_max are type dependent, the can be
       obtained through macros such as:
       ~DBL_MANT_DIG~ (for p, typically 53),
       ~DBL_MIN_EXP~ (e_min, -1021) and
       ~DBL_MAX_EXP~ (e_max, 1024).

     - From that calculation we see also that floating point values are
       _always representable as a fraction that has some power of two in the
       denominator_.

     - An important thing that we have to have in mind with such floating point
       representations is that values _can be cut off during intermediate
       computations_. =TODO examples=

     - Rule 1.5.5.17 :: Floating point operations are _NEITHER_ associative,
                        commutative or distributive.

     - Rule 1.5.5.18 :: Never compare floating point values for equality.
                        =IMPORTANT=

     - For any =z= of one of the three complex types we ~#include <tgmath.h>~
       have that ~z == creal(z)+ cimag(z)*I~

** DONE 6. Derived data types - 81
   CLOSED: [2017-04-25 Tue 16:11]
   =50 ~ 61=
   - All other data types in C are derived from the basic types that we know now.
     There are _four_ different strategies for combining types:
     * arrays :: These combine items that all have _the same base type_.
     * pointers :: Entities that refer to an object in memory. =TODO in section 11=
     * structures :: These combine items that _may have different base types_.
     * unions :: These overlay items of different base types in the same memory
                 location. =TODO section 12.2=

   - /aggregate data types/

*** 6.1. Arrays - 82
    - Rule 1.6.1.1 :: Arrays are not pointers.
**** 6.1.1. Array declaration - 82
     - /multidimensional array/:
       #+BEGIN_SRC C
       // For those, declarations become a bit more difficult to read since []
       // binds to the left. The following two declarations declare variables of
       // exactly the same type:
       double C[M][N];
       double (D[M])[N];
       #+END_SRC

**** 6.1.2. Array operations - 83
     - Rule 1.6.1.2 :: An array in a condition evaluates to ~true~.

     - Rule 1.6.1.3 :: There are array objects but no array values.

     - =COMMENT=: So arrays can't be operands for _value operators_ in Table 2,
       there is _no_ arithmetic declared on arrays (themselves) and also 

     - Rule 1.6.1.4 :: Arrays can't be compared.

     - =COMMENT=: Arrays also can't be on the value side of object operators in
       Table 3.

     - Rule 1.6.1.5 :: Arrays can't be assigned to.

**** 6.1.3. Array length - 83
     - There are two different categories of arrays:
       1. /fixed length arrays (FLA)/: exist from the very beginning of C.
       2. /variable length arrays (VLA)/: introduced in C99 and is relatively
          unique to C, and has some restrictions to its usage.

     - Rule 1.6.1.6 :: VLA can't have initializers.

     - Rule 1.6.1.7 :: VLA can't be declared outside functions.
 
     - Rule 1.6.1.8 :: The length of an FLA is determined by:
       1. an ICE or
       2. an initializer.

     - There is _no type restriction_ for the ICE of array length, any integer
       type would do.
                       
     - Rule 1.6.1.9 :: An array length specification must be strictly positive.
 
     - Rule 1.6.1.10 :: An array with a length not an integer constant expression is an VLA.
 
     - Rule 1.6.1.11 :: The length of an array A is ~(sizeof A) / (sizeof A[0])~.
                        =REMARK=: A must be an array, not a pointer to the array.
                                  Again, Arrays are not pointers (Rule 1.6.1.1)!!!
**** 6.1.4. Arrays as parameters - 85
     - Rule 1.6.1.12 :: The innermost dimension of an array parameter to a
                        function is lost.

     - Rule 1.6.1.13 :: Don't use the ~sizeof~ operator on array parameters to
                        functions.

     - Rule 1.6.1.14 :: Array parameters behave as-if the array is
                        /passed by reference/.

**** 6.1.5. Strings are special - 85
     - Rule 1.6.1.15 :: A string is a 0-terminated array of ~char~.

     - As all arrays, _strings_ can't be assigned to, but they can be initialized
       from _string literals_:
       #+BEGIN_SRC C
       char chough0[] = "chough";
       char chough1[] = {"chough"};
       char chough2[] = {'c', 'h', 'o', 'u', 'g', 'h', 0, };
       char chough3[7] = {'c', 'h', 'o', 'u', 'g', 'h', };
       #+END_SRC
       These are all equivalent declarations.

     - _Beware_ that _not_ all arrays of char are strings, such as
       #+BEGIN_SRC C
       char chough4[6] = { 'c', 'h', 'o', 'u', 'g', 'h', };
       #+END_SRC
       because it is _not 0-terminated_.

     - It seems both ~char chough2[] = {'c', 'h', 'o', 'u', 'g', 'h', }~ and
       ~char chough2[] = {'c', 'h', 'o', 'u', 'g', 'h'}~ work well.
       =FROM JIAN= Is this SPECIAL???

     - Those that just suppose an array start their ~#include <string.h>~ names
       with =mem= and those that in addition suppose that their arguments are
       strings start with =str=:
       1. Functions that operate on ~char~-array: =TODO: try!!!=
          * ~memcpy(target, source, len)~
          * ~memcmp(s0, s1, len)~ 
          * ~memchr(s, c, len)~

       2. String functions: =TODO: try!!!=
          * ~strlen(s)~
          * ~strcpy(target, source)~
          * ~strcmp(s0, s1)~
          * ~strcoll(s0, s1)~
          * ~strchr(s, c)~
          * ~strspn(s0, s1)~
          * ~strcspn(s0, s1)~

     - Rule 1.6.1.16 :: Using a string function with a non-string has
                        _undefined behavior_.

     - In real life, common symptoms for such a misuse may be: =page 54=

     - C11 introduces functions with bounds checking: ~strnlen_s~ and ~strcpy_s~.

*** 6.2. Pointers as opaque types - 89
    - The binary representation of pointer is completely up to the platform.

    - Rule 1.6.2.1 :: Pointers are opaque objects.
                      =Remark=: _opaque_ here means that we will only be able to
                      deal with pointers through the operations that the C
                      language allows for them. =IMPORTANT=

    - Rule 1.6.2.2 :: Pointers are _valid_, _null_ or _indeterminate_.
                      =Remark=: the _null state_ of any pointer type
                      _corresponds to_ 0, sometimes known under its
                      _pseudo_ ~false~.

    - Rule 1.6.2.3 :: Initialization or assignment with 0 makes a pointer null.

    - Rule 1.6.2.4 :: In logical expressions, pointers evaluate to ~false~ iff
                      they are null.
                      =Remark=: Note that such test _can't_ distinguish valid
                                pointers from indeterminate ones.
                                =IMPORTANT= So, the really "bad" state of a
                                pointer is "indeterminate", since this state is
                                _not observable_.

    - Rule 1.6.2.5 :: Indeterminate pointers lead to undefined behavior.
                      =Remark=: make sure that pointers _never_ reach an
                                intermediate state.
                                  Thus, if we can't ensure that a pointer is
                                valid, we must at least ensure that it is set to
                                null.

    - Rule 1.6.2.6 :: Always initialize pointers.

*** 6.3. Structures - 91
    - The _order_ or position of the fields in the structure is usually _NOT_
      important.
 
    - Rule 1.6.3.1 :: Omitted struct initializers force the corresponding field
                      to ~0~.

    - Rule 1.6.3.2 :: A struct initializer must initialize at least one field.

    - Rule 1.6.3.3 :: struct parameters are passed by value.

    - Here we see that the assignment operator "=" is _well defined_ for all
      structure types.
      Unfortunately, its counterparts for comparisons _are not_.

    - Rule 1.6.3.4 :: Structures can be assigned with ~=~ but _not compared with_
                      ~==~ or ~!=~.

    - Rule 1.6.3.5 :: A structure layout is an important design decision.

    - =COMMENT=: You may regret your design after some years, when all the exist-
      ing code that uses it makes it almost impossible to adapt it to new
      situations.

    - Any data type besides VLA is allowed as a field in a structure.

    - Rule 1.6.3.6 :: All struct declarations in a nested declaration have the
                      same scope of visibility.

*** 6.4. New names for types: type aliases - 96
    - a structure
      1. not only _introduces a way to aggregate differing information into one
         unit_,
      2. it also _introduces a new type name_.

    - _For historical reasons (again!)_ the name that we introduce for the
      structure always has to be preceded by the keyword ~struct~, which makes
      the use of it a bit clumsy.

    - Example:
      #+BEGIN_SRC c
      typedef struct animalStruct animalStructure;
      typedef struct animalStruct animalStruct;
      #+END_SRC

    - /forward declaration/ of the structure: That is to precede the proper
      ~struct~ declaration by a ~typedef~ using exactly the same name. This works
      because the combination of ~struct~ with a following name, the /tag/ is
      always valid.
      Example:
      #+BEGIN_SRC c
      typedef struct animalStruct animalStruct;
      struct animalStruct {
        // ...
      }
      #+END_SRC

    - Rule 1.6.4.1 :: Forward-declare a ~struct~ within a ~typedef~ using the
                      same identifier as the /tag name/.

                      =COMMENT=: C++ follows a similar approach by default, so
                      this strategy will make your code easier to read for people
                      coming from there.

    - The ~typedef~ mechanism can also be used for other types than structures.

    - The C standard also uses ~typedef~ a lot internally, for example: ~size_t~.
      Here the standard often uses names that terminate with =_t= for ~typedef~.

    - Rule 1.6.4.2 :: Identifier names terminating with =_t= are _reserved_.

** DONE 7. Functions - 99
   CLOSED: [2017-04-25 Tue 16:11]
   - Motivation: /modularity/ =IMPORTANT=
     * Avoid code repetition
       + Avoid copy and paste errors.
       + Increase readability and maintainability.
       + Decrease compilation times.
     * Provide clear interfaces
       + Specify the origin and type of data that flows into a computation.
       + Specify the type and value of the result of a computation.
       + Specify invariants for a computation, namely pre- and post-conditions
     * Dispose a natural way to formulate algorithms that use a "stack" of
       itermediate values.

   - Besides the concept of functions,
     C has _other means of unconditional transfer of control_, that are mostly
     used to
     _handle error conditions_ or _other forms of exceptions from the usual
     control flow_
     * ~exit~, ~_Exit~, ~quick_exit~ and ~abort~ terminate the program execution
       TODO See Section 8.6
     * ~goto~ transfers control within a function body
       TODO See Section 13.2.2 and 15
     * ~setjmp~ and ~longjmp~ can be used to return unconditionally to a calling
       context,
       TODO see Section 18.4.
     * Certain events of the execution environment or calls to the function raise
       may raise so-called signals and that pass control to a specialized
       function, a /signal handler/.
       TODO ???

*** 7.1. Simple functions - 100
    - /prototype/: _declaration_ and _definition_ included:
      * a parameter type-list and
      * a return type.

    - There are _two_ special conventions that use the keyword ~void~:
      * If the function is to be _called with no parameter_, the list is replaced
        by the keyword ~void~.
      * If the function _doesn't return a value_, the return type is given as
        ~void~.

    - Such a /prototype/ _helps the compiler in places where the function is to
      be called_. It _only has to know about the parameters that the function
      expects_. For example:
      #+BEGIN_SRC C
      extern double fbar(double x);
      // ... ...
      double fbar2 = fbar(2) / 2;
      #+END_SRC
      Here the call ~fbar(2)~ is not directly compatible with the expectation of
      function fbar: it wants a ~double~ but receives a ~signed int~. But since
      the calling code knows this, it can convert the ~signed int~ argument =2=
      to the ~double~ value =2.0= before calling the function. The same holds
      for the return: the caller knows that the return is a ~double~, so floating
      point division is applied for the result expression. =IMPORTANT=

    - In C, _there are ways to declare functions without prototype_,
      but you will not see them here. You _shouldn't use_ them, they should be
      retired. There were even ways in previous versions of C that allowed to
      use functions without any knowledge about them at all. Don’t even think of
      using functions that way. =TODO=

    - Rule 1.7.1.1 :: All functions must have prototypes.

    - Exception: functions that can receive a varying number of parameters.
                 ~<stdargs.h>~, /variable argument list/ =TODO= 17.4.2
      Try to avoid using this in any case.

    - Rule 1.7.1.2 :: Functions only have one entry but several ~return~.

    - For a function that expects a return value, all return statements must
      contain an expression;
      functions that expect none, mustn't contain expressions.

    - Rule 1.7.1.3 :: A function ~return~ must be consistent with its type.

    - If the type of the function is ~void~ the ~return~ (without expression) can
      even be omitted.

    - Rule 1.7.1.4 :: Reaching the end of the ~{}~ block of a function is equiva-
                      lent to a ~return~ statement without expression.
      _THIS IMPLIES_ 

    - Rule 1.7.1.5 :: Reaching the end of the ~{}~ block of a function is only
                      allowed for void functions. 

*** 7.2. ~main~ is special - 102
    - The prototype of ~main~ function is enforced by the C standard,
      but it is implemented by the programmer.

    - Being such a pivot between the runtime system and the application, it has
      to obey some special rules:
      1. First, to suit different needs it has several prototypes, one of which
         must be implemented. _Two_ should always be possible:
         #+BEGIN_SRC C
         int main(void);
         #+END_SRC

         #+BEGIN_SRC C
         int main(int argc, char* argv[argc+1]);
         // int main(int argc, char* argv[]);
         #+END_SRC

      2. There is another feature in the second prototype of ~main~, namely
         ~argv~, the vector of commandline arguments. We already have seen
         some examples where we used this vector to communicated some values
         from the commandline to the program. E.g. in Listing 1.1 these
         commandline arguments were interpreted as double data for the program.

    - Then, any specific C platform may provide other interfaces. There are _two_
      variations that are relatively common:
      * On some embedded platforms where ~main~ is not expected to return to the
        runtime system the return type may be ~void~.
      * On many platforms a _third parameter_ can give access to the
        "environment".

    - Rule 1.7.2.1 :: Use ~EXIT_SUCCESS~ or ~EXIT_FAILURE~ as return values of
                      ~main~.
 
    - Rule 1.7.2.2 :: Reaching the end of the ~{}~ block of ~main~ if equivalent
                      to a ~return EXIT_SUCCESS;~.

    - The library function ~exit~ holds a special relationship with ~main~.
      As the name indicates, a call to exit terminates the program; the prototype
      is
      #+BEGIN_SRC C
      _Noreturn void exit(int status);
      #+END_SRC
      In fact, this functions terminates the program exactly as a ~return~ from
      ~main~ would. The parameter =status= has the role that the
      _return expression_ in ~main~ would have. 

    - Rule 1.7.2.3 :: Calling ~exit~(s) is equivalent evaluation of ~return s~ in
                      ~main~.

    - Rule 1.7.2.4 :: ~exit~ _never fails_ and _never returns to its caller_.

    - The later is indicated by the special keyword ~_Noreturn~. This keyword
      should _only be used for such special functions_. There is even a pretty
      printed version of it, the macro ~noreturn~, that comes with the header
      ~stdnoreturn.h~.

    - Strictly spoken, _each of the ~argv[i]~ for i = 0, ..., ~argc~ is a
      pointer_, but since we don't know yet what that is (_didn't teach_), as an
      easy first approximation we can see them as strings.

    - Rule 1.7.2.5 :: All commandline arguments are transferred as strings.

    - Rule 1.7.2.6 :: Of the arguments to ~main~, ~argv[0]~ holds the name of the
                      program invocation.
                      =REMARK=: There is no strict rule of what that
                                "program name" should be, but usually this is
                                just taken as the name of the program executable.
                                =IMPORTANT= NO rule in C standard.

    - Rule 1.7.2.7 :: Of the arguments to ~main~, ~argv[argc]~ is =0=.
                      =TODO=: usage??? only used to identify the end? We have
                              ~argc~ already!!! Historical reason???

*** 7.3. Recursion - 104 - =RE-READ=
    - Rule 1.7.3.1 :: Make all preconditions for a function explicit.

    - Rule 1.7.3.2 :: In a recursive function, first check the termination
                      condition.

    - Rule 1.7.3.3 :: Ensure the preconditions of a recursive function in a
                      wrapper function.
                      #+BEGIN_SRC C
                      
                      #+END_SRC

    - This avoids that the precondition has to be checked at each recursive
      call: the ~assert~ macro is such that it can be disabled in the final
      "production" object file. 
      #+BEGIN_SRC C
      // Just a example. (From Jian) The implimantation is not good though.
      size_t gcd2(size_t a, size_t b) {
        assert (a <= b);
        if (!a) return b;
        size_t rem = b % a;
        return gcd2(rem, a);
      }

      size_t gcd(size_t a, size_t b) {
        assert (a);
        assert (b);
        if(a < b) return gcd2(a, b);
        else      return gcd2(b, a);
      } 
      #+END_SRC
      This avoids that the precondition has to be checked at each recursive
      call: the ~assert~ macro is such that it can be disabled in the final
      “production” object file.

    - Rule 1.7.3.4 :: Multiple recursion may lead to exponential computation
                      times.

    - Rule 1.7.3.5 :: A bad algorithm will never lead to a performing
                      implementation.

    - Rule 1.7.3.6 :: Improving an algorithm can dramatically improve
                      performance.

    - /VLA/: variable-length array
    - /FLA/: fixed-length array

** TODO 8. C Library functions - 113
   - The functionality that the C standard provides is separated into _TWO_ big
     parts:
     1. the proper C language,
     2. the C library.

   - The choices of compilers and standard libraries on Linux:
     + Compilers: /gcc/ and /clang/
     + Standard Libraries: /glibc/, /dietlibc/, and /musl/

*** TODO 8.1 General properties of the C library and its functions - 113
    - Roughly, library functions target one or two different purposes:
      1. Platform abstraction layer: Implement some functions (e.g. IO) requires
         deep platform specific knowledge. Standard library should provide some of
         them.

      2. Basic tools: Functions that implement a task (such as e.g. ~strtod~) that
         often occurs in programming in C for which
         _it is important that the interface is fixed_.

    - ~snprintf~: =TODO Section 14.1=

**** 8.1.1 Headers - 114
     - TABLE 12. C library headers
       | Name              | Content                                      | Mentioned Section |
       |-------------------+----------------------------------------------+-------------------|
       | ~<assert.h>~      | assert run time conditions                   |               8.6 |
       | ~<complex.h>~     | complex numbers                              |             5.5.7 |
       | ~<ctype.h>~       | character classification and conversion      |               8.3 |
       | ~<errno.h>~       | error codes                                  |                15 |
       | ~<fenv.h>~        | floating-point environment.                  |                   |
       | ~<float.h>~       | properties of floating point types           |               5.5 |
       | ~<inttypes.h>~    | format conversion of integer types           |             5.5.6 |
       | ~<iso646.h>~      | alternative spellings for operators          |               4.1 |
       | ~<limits.h>~      | properties of integer types                  |             5.0.3 |
       | ~<locale.h>~      | internationalization                         |               8.5 |
       | ~<math.h>~        | type specific mathematical functions         |               8.1 |
       | ~<setjmp.h>~      | non-local jumps                              |              18.4 |
       | ~<signal.h>~      | signal handling functions                    |              18.5 |
       | ~<stdalign.h>~    | alignment of objects                         |              12.7 |
       | ~<stdarg.h>~      | functions with varying number of arguments   |            17.4.2 |
       | ~<stdatomic.h>~   | atomic operations                            |              18.5 |
       | ~<stdbool.h>~     | Booleans                                     |               3.1 |
       | ~<stddef.h>~      | basic types and macros                       |               5.1 |
       | ~<stdint.h>~      | exact width integer types                    |             5.5.6 |
       | ~<stdio.h>~       | input and output                             |               8.2 |
       | ~<stdlib.h>~      | basic functions                              |                 2 |
       | ~<stdnoreturn.h>~ | non-returning functions                      |                 7 |
       | ~<string.h>~      | string handling                              |               8.3 |
       | ~<tgmath.h>~      | type generic mathematical functions          |               8.1 |
       | ~<threads.h>~     | threads and control structures               |                19 |
       | ~<time.h>~        | time handling                                |               8.4 |
       | ~<uchar.h>~       | Unicode characters                           |              14.3 |
       | ~<wchar.h>~       | wide string                                  |              14.3 |
       | ~<wctype.h>~      | wide character classification and conversion |              14.3 |

**** 8.1.2 Interfaces - 114
     - Most interfaces of the C library are specified as functions,
       _but_ implementations are free to chose to implement them as macros, were
       this is appropriate.

     - /functionlike macros/:
       #+BEGIN_SRC C
       #define putchar(A) putc(A, stdout)
       #+END_SRC
       =COMMENT=: Since the replacement text may contain a macro argument several
       times, it would be quite bad to pass any expression with side effects to
       such a macro-or-function.
       Fortunately, because of Rule 1.4.2.2 you don't do that, anyhow.

**** 8.1.3 Error checking - 116
     C library functions usually indicate failure through a special return value.
     _However_, what value indicates the failure can be
     different and depends on the function itself. _Generally, READ THE MANUAL._
     - There are three categories that apply:
       1. a special value that indicates an error,
       2. a special value that indicates success, and
       3. functions that return some sort of positive counter on success and a
          negative value on failure.

     - A typical error checking code:
       #+BEGIN_SRC C
       if (puts("hello world") == EOF) {
               perror("can't output to terminal:");
               exit (EXIT_FAILURE);
       }
       #+END_SRC

     - Rule 1.8.0.1 :: Failure is always an option.

     - Rule 1.8.0.2 :: Check the return value of library functions for errors.

     - TABLE 13. Error return strategies for C library functions.
       Some functions may also indicate a specific error condition through the
       value of the macro ~errno~.
       | failure              | test            | typical case                  | example                    |
       |----------------------+-----------------+-------------------------------+----------------------------|
       | =0=                  | ~!value~        | other values are valid        | ~fopen~                    |
       |----------------------+-----------------+-------------------------------+----------------------------|
       | special error code   | ~value == code~ | other values are valid        | ~puts~, ~clock~, ~mktime~, |
       |                      |                 |                               | ~strtod~, ~fclose~         |
       |----------------------+-----------------+-------------------------------+----------------------------|
       |----------------------+-----------------+-------------------------------+----------------------------|
       | non-zero value       | ~value~         | value otherwise unneeded      | ~fgetpos~, ~fsetpos~       |
       |----------------------+-----------------+-------------------------------+----------------------------|
       | special success code | ~value != code~ | case distinction for failure  | ~thrd_create~              |
       |                      |                 | condition                     |                            |
       |----------------------+-----------------+-------------------------------+----------------------------|
       |----------------------+-----------------+-------------------------------+----------------------------|
       | negative value       | ~value < 0~     | positive value is a "counter" | ~printf~                   |
       |----------------------+-----------------+-------------------------------+----------------------------|

     - Rule 1.8.0.3 :: Fail fast, fail early and fail often.
       =COMMENT=: An immediate failure of the program is often the best way to
       ensure that bugs are detected and get fixed in early development.

**** 8.1.4 Bounds-checking interfaces - 117
     - bounds-checking interfaces of /Annex K/ of the standard.

     - _TWO_ macros regulate access to theses interfaces:
       1. ~__STDC_LIB_EXT1__~ tells if this optional interfaces is supported, and
       2. ~__STDC_WANT_LIB_EXT1__~ switches it on.
       The later must be set before any header files are included:
       #+BEGIN_SRC c
       #if !__STDC_LIB_EXT1__
       #  error "This code needs bounds checking interface Annex K"
       #endif
       #define __STDC_WANT_LIB_EXT1__ 1

       #include <stdio.h>
       // Use printf_s from here on.
       #+END_SRC

     - Rule 1.8.0.4 :: Identifier names terminating with ~_s~ are reserved.

     - If a bounds-checking function encounters an inconsistency, a
       /runtime constraint violation/,
       it usually should end program execution after printing a diagnostic.

**** 8.1.5 Platform preconditions - 118
     - Rule 1.8.0.5 :: Missed preconditions for the execution platform must abort
                         compilation.

     - The classical tool to achieve this are /preprocessor conditionals/ as we
       have seen them above:
       #+BEGIN_SRC c
       #if !__STDC_LIB_EXT1__
       #  error "This code needs bounds checking interface Annex K"
       #endif
       #+END_SRC
       
     - Rule 1.8.0.6 :: Only evaluate macros and integer literals in a
                       preprocessor condition.

     - Rule 1.8.0.7 :: In preprocessor conditions unknown identifiers evaluate
                       to 0.

     - ~__Static_assert~ and ~static_assert~ from =assert.h=.
       #+BEGIN_SRC c
       #include <assert.h>
       static_assert(sizeof(double) == sizeof(long double),
           "Extra precision needed for convergence.");
       #+END_SRC

*** 8.2. Mathematics - 119
    - =math.h= and =tgmath.h= (type generic macros).

    - TABLE 14. Mathematical functions.
      Type generic macros are printed in red, real functions in green.
 
*** TODO 8.3. Input, output and file manipulation - 121
**** 8.3.1. Unformated text output - 121
     - The ~type int as parameter~ for ~putchar~ is just a _historical accident_
       that shouldn't hurt you much.

     - ~fputs~ and ~fputs~:
       #+BEGIN_SRC c
       int fputc(int c, FILE * stream);
       int fputs(char const s[static 1], FILE * stream);
       #+END_SRC

     - The type ~FILE*~ for /streams/ provides an abstraction for writing
       results to some permanent storage.

     - The identifier ~FILE~ itself is a so-called /opaque type/, for which don't
       know more than is provided by the functional interfaces.
       =TODO=: that we will see in this section.

     - The facts that it is implemented as a macro and
       the _MISUSE_ of the name ~FILE~ for a /stream/ is a reminder that this
       is one of the _historic interfaces that predate standardization_.

     - Rule 1.8.2.1 :: Opaque types are specified through functional interfaces.

     - Rule 1.8.2.2 :: Don't rely on implementation details of opaque types.
                       =COMMENT=: Jian thinks this rule is applicable all types.

     - Rule 1.8.2.3 :: puts and fputs differ in their end of line handling.

**** 8.3.2. Files and streams - 123
     - ~fopen~ and ~freopen~:
       #+BEGIN_SRC c
       FILE* fopen(char const path[static 1], char const mode[static 1]);
       FILE* freopen(char const path[static 1], char const mode[static 1], FILE *stream);
       #+END_SRC

     - TABLE 15 Modes and modifiers for ~fopen~ and ~freopen~.

     - =Optional= (Annex K):
       + function: ~fopen_s~ and ~freopen_s~ =TODO=
       + ~error_t~ type =TODO=
       + ~restrict~ keyword for pointer types =TODO=
       #+BEGIN_SRC c
       errno_t fopen_s(FILE* restrict streamptr[restrict],
                       char const filename[restrict], char const mode[restrict]);

       errno_t freopen_s(FILE* restrict newstreamptr[restrict],
                         char const filename[restrict],
                         char const mode[restrict], FILE* restrict stream);
       #+END_SRC

     - TABLE 16 Mode strings for ~fopen~ and ~freopen~. Valid combinations. =TODO=

     - The modifiers are _used less commonly_ in everyday's coding:
       1. "Update" mode with ~+~ should be used carefully.
       2. Reading and writing at the same (~rb~, etc.) time is not so easy and
          needs some special care.
       3. For ~b~ we will discuss the difference between text and binary streams
          in some more detail =in Section 14.4=. =TODO=

     - ~freopen~ (prototype mentioned above), ~fclose~, and ~fflush~:
       #+BEGIN_SRC c
       int fclose(FILE * fp);
       int fflush(FILE * stream);
       #+END_SRC
       + ~freopen~: associate a given stream to a different file and eventually
         change the mode.
         This is particular useful to associate the standard streams to a file.
         #+BEGIN_SRC c
         int main(int argc, char * argv[argc+1]) {
             if (!freopen("mylog.txt", "a", stdout)) {
                 perror("freopen failed");
                 return EXIT_FAILURE;
             }
             puts("feeling fine today");
             return EXIT_SUCCESS;
         }
         #+END_SRC

**** 8.3.3. Text IO - 125
     - For efficiency, output to text streams is usually /buffered/.
       Physical reason.

     - When apply ~fclose~, all buffers are guraanteed to be /flushed/ to where
       it is supposed to go.

     - ~fflush~

     - /line buffering/: the most common form of IO buffering. Do physically
       output when encounter the end of a text line. In this mode:
       1. ~puts~ would always appear immediately on the terminal.
       2. ~fputs~ would wait until it meets an ~'\n'~

     - Rule 1.8.2.4 :: Text input and output converts data.
                       =COMMENT= This is because internal and external represen-
                       tation of text characters are not necessarily the same.
                       the C library is in charge of doing this conversion.

     - Rule 1.8.2.5 :: There are three commonly used conversion to encode
                       end-of-line

     - Rule 1.8.2.6 :: Text lines should not contain trailing white space.
                       =COMMENT=: They (include blank and tabulator characters)
                       can be suppressed.

     - TABLE 17. Format specifications for printf and similar functions, with the
       general syntax "%[FF][WW][.PP][LL]SS"

     - TABLE 18. Format specifiers for ~printf~ and similar functions

     - ~remove~ and ~rename~:
       #+BEGIN_SRC c
       int remove(char const pathname[static 1]);
       int rename(char const oldpath[static 1], char const newpath[static 1]);
       #+END_SRC

**** 8.3.4. Formatted output - 127
     - Rule 1.8.2.7 :: Parameters of ~printf~ must exactly correspond to the
                       format specifiers.

     - TABLE 19. Format modifiers for ~printf~ and similar functions. ~float~
       arguments are first converted to ~double~.

     - TABLE 20. Format flags for ~printf~ and similar functions.

     - Rule 1.8.2.8 :: Use "%+d", "%#X" and "%a" for conversions that have to be
                       read, later. =IMPORTANT=

     - =Optional= ~printf_s~ and ~fprintf_s~:
       1. They check that the stream, format and any string arguments are valid
          pointers.
       2. They don't check if the expressions in the list correspond to correct
          format specifiers. 

**** 8.3.5. Unformatted text input - 130
     - ~fgetc~ and ~fgets~
       #+BEGIN_SRC c
       int fgetc(FILE * stream);
       char * fgets(char s[restrict], int n, FILE * restrict stream);
       int getchar(void);
       #+END_SRC

     - =Optional=:
       ~getchar~ and ~gets_s~
       #+BEGIN_SRC c
       char * gets_s(char s[static 1], rsize_t n);
       #+END_SRC

     - _Historically_, in the same spirit as ~puts~ specializes ~fputs~, prior
       version of the C standard had a ~gets~ interface. This has been removed
       because it was inherently unsafe. =TODO why=

     - Rule 1.8.2.9 :: Don't use ~gets~.

     - Rule 1.8.2.10 :: ~fgetc~ returns ~int~ to be capable to encode a special
                        error status, =EOF=, in addition to all valid characters.

     - We have to call ~feof~ to test if a stream's position has reached its
       end-of-file marker. Test a return =EOF= alone is not enough. =TODO=

     - Rule 1.8.2.11 :: End of file can only be detected after a failed read.

*** TODO 8.4. String processing and conversion - 132
    - TABLE 21. Character classifiers.
    - Rule 1.8.3.1 :: The interpretation of numerically encoded characters
                      depends on the execution character set.

*** TODO 8.5. Time - 136
*** TODO 8.6. Runtime environment settings - 141
    - TABLE 23. strftime format specifiers.

*** TODO 8.7. Program termination and assertions - 143
    - Rule 1.8.6.1 :: Regular program termination should use ~return~ from
                      ~main~.
    - TABLE 24. Categories for the ~setlocale~ function
    - Rule 1.8.6.2 :: Use ~exit~ from a function that may terminate the regular
                      control flow.

    - Rule 1.8.6.3 :: Don't use other functions for program termination than
                      ~exit~, unless you have to inhibit the execution of library
                      cleanups.
 
    - Rule 1.8.6.4 :: Use as many ~assert~ (macro) as you may to confirm runtime
                      properties.

    - Rule 1.8.6.5 :: In production compilations, use ~NDEBUG~ (macro) to switch
                      off all ~assert~ (macro).

* TODO LEVEL 2. Cognition - 147
** DONE 9. Style - 149
   CLOSED: [2017-04-25 Tue 16:10]
  - Programs serve both sides:
    + give instructions to the compiler and the final executable.
    + document the intended behavior of a system for us people
      that have to deal with it.

  - Rule C :: All C code must be readable.

    + =from Jian=
      About the *readable*:
      * Be readable in the details level for people who have domain knowledge.

      * Be readable for all programmers in the outline level -- people can easily
        understand the high level logic.

    + Here the *readable* is mainly for human, whose condition is _constrained_
      by _TWO major factors_:
      * Physical ability;
      * Cultural baggage.

  - Rule 2.9.0.1 :: Short term memory and the field of vision are small.

  - Try to read /the coding style for the Linux kernel/.

  - Rule 2.9.0.2 :: Coding style is NOT a question of taste BUT of culture.

    _Ignoring this, easily leads to endless and fruitless debates about not much
    at all._

  - Rule 2.9.0.3 :: When you enter an established project you enter a new cultural space.

  - You can decide the style of your own project,
    but be careful if you want others to adhere to it.

*** 9.1. Formatting - 150
    - _The need for code formatting originates in human incapacity_.
    - Rule 2.9.1.1 :: Choose a consistent strategy for white space and other text formatting.
    - Rule 2.9.1.2 :: Have your text editor automatically format your code correctly.

*** 9.2. Naming - 151
    - _The limit of automatic formatting tools is reached when it comes to naming._

    - There are two different aspects to naming:
      1. technical restrictions
      2. semantic conventions
      Unfortunately, they are often mixed up.

    - Rule 2.9.2.1 :: Choose a consistent naming policy for all identifiers.

    - _All identifiers_:
      1. types (struct or not),
      2. struct and union fields,
      3. variables,
      4. enumerations,
      5. macros,
      6. functions,
      7. function-like macros.
      There are so many tangled “name spaces” you’d have to be careful.

    - In particular the interaction between header files and macro definitions
      can have surprising effects. A seemingly innocent example:
      #+BEGIN_SRC c
      double memory_sum(size_t N, size_t I, double strip[N][I]);
      #+END_SRC
      * ~N~ is a capitalized identifier, thus your collaborator could be tempted
        to define a macro ~N~ as a big number.
      * ~I~ is used for the root of −1 as soon as someone includes ~complex.h~.
        (And you see that the automatic code annotation system of this book
        thinks that this refers to the macro.)
      * The identifier ~strip~ might be used by some C implementation for a library
        function or macro.
      * The identifier ~memory_sum~ might be used by the C standard for a type name
        in the future.

    - Rule 2.9.2.2 :: Any identifier that is visible in a header file must be conforming.

    - Here conforming is a wide field. In the C jargon an identifier is /reserved/
      if its meaning is fixed by the C standard and you may not redefined it otherwise.
      * Names starting with an underscore and a second underscore or a capital
        letter are reserved for language extensions and other internal use.
        ~_xxx~, ~__xxx~, and ~Cxxx~
      * Names starting with an underscore are reserved in file scope and for
        enum, struct and union tags. =TODO ???=
      * Macros have all caps names.
      * All identifiers that have a predefined meaning are reserved and cannot be
        used in file scope. These are lot of identifiers, e.g.
        1. all functions in the C library,
        2. all identifiers starting with =str= (as our strip, above),
        3. all identifiers starting with =E=,
        4. all identifiers ending in =_t= and many more.

    - A simple strategy to keep the probability of naming conflicts low is to
      expose as few names as possible
 
    - Rule 2.9.2.3 :: Don’t pollute the global name space.

    - A good strategy for a library that has vocation of use by others or in
      other projects is to use naming prefixes that are unlikely to create
      conflicts.

    - There are two sorts of names that may interact badly with macros that
      another programmer writes at which you might not think immediately:
      * field names of ~struct~ and ~union~
      * parameter names in function interfaces.
      _Solution_: use prefix:
      * ~struct timespec~ has ~tv_sec~ rather than ~sec~.
      * parameter names:
        #+BEGIN_SRC c
          double p99_memory_sum(size_t p00_n, size_t p00_i,
                                double p00_strip[p00_n][p00_i]); 
        #+END_SRC

    - This problem gets worse when we are also exposing program internals to the
      public view. This happens in two cases:
      * So-called ~inline~ functions, that are functions that have their definition
        (and not only declaration) visible in a header file.

      * Functional macros. =TODO= =???=

    - Now that we have cleared the technical aspects of naming, we will look at
      the semantic aspect.

    - Rule 2.9.2.4 :: Names must be recognizable and quickly distinguishable.
    - Rule 2.9.2.5 :: Naming is a creative act.
    - Rule 2.9.2.6 :: File scope identifiers must be comprehensive.
    - Rule 2.9.2.7 :: A type name identifies a concept.
    - Rule 2.9.2.8 :: A global constant identifies an artifact.
    - Rule 2.9.2.9 :: A global variable identifies state.
    - Rule 2.9.2.10 :: A function or functional macro identifies an action.

** DONE 10. Organization and documentation - 157
   CLOSED: [2017-04-25 Tue 16:10]
   - Rule 2.10.0.1 (what) :: Function interfaces describe what is done.

   - Rule 2.10.0.2 (what for) :: Interface comments document the purpose of a
        function.

   - Rule 2.10.0.3 (how) :: Function code tells how things are done.

   - Rule 2.10.0.4 (why) :: Code comments explain why things are done as they
        are.

   - Rule 2.10.0.5 :: Separate interface and implementation.

   - Rule 2.10.0.6 :: Document the interface -- Explain the implementation.

*** 10.1. Interface documentation - 158
    - Rule 2.10.1.1 :: Document interfaces thoroughly.

    - Rule 2.10.1.2 :: Structure your code in units that have strong semantic
                       connections.

    - /include guards/: protect against multiple inclusion. E.g.
      If there is a ~brain.h~ for ~struct brain~:
      #+BEGIN_SRC c
      #ifndef BRAIN_H
      #define BRAIN_H
      #include <time.h>

      // ... ...
      #endif
      #+END_SRC

*** 10.2. Implementation - 161
    - Good programming only needs to explain the ideas and prerequisites that are
      not obvious, the difficult part. Through the structure of the code, it
      shows what it does and how.

    - Rule 2.10.2.1 :: Implement literally.

    - Rule 2.10.2.2 :: Control flow must be obvious.

    - There are many possibilities to obfuscate control flow. The most important
      are:
      1. /burried jumps/: ~break~, ~continue~, ~return~, and ~goto~.
      2. /flyspeck expressions/: =TODO=

**** 10.2.1. Macros - 162
     - Rule 2.10.3.1 :: Macros should not change control flow in a surprising way.

     - ~do ... while(false)~ trick used in macro for grouping several statements.

     - Rule 2.10.3.2 :: Function like macros should syntactically behave like
                        function calls.

     - Possible pitfalls are: =PAGE 105= many many!!! =TODO=

**** 10.2.2. Pure functions - 164
     - Functions are extensions of the value operators (in Table 2), and
                 NOT of the object operators (of Table 3).

     - Rule 2.10.4.1 :: Function parameters are passed by value.

     - Rule 2.10.4.2 :: Global variables are frowned upon.

     - A function with the following two properties is called /pure/:
       + No other effects than returning a value.
       + The returned value only depends on its parameters.
         No matter how many times you call the function, it always returns the
         same result if you pass the same parameters.

     - Rule 2.10.4.3 :: Express small tasks as pure functions whenever possible.

     - =TODO= ~inline~ and /link time optimization/

** TODO 11. Pointers - 106 =RE-READ=
*** 11.1. Pointer operators - 170
**** 11.1.1. Address-of and object-of operators - 170
     - Rule 2.11.1.1 :: Using ~*~ with an _indeterminate_ or /null pointer/ has
                        /undefined behavior/.

       + The _indeterminate_ case might access some random object in memory and
         modify it. Often this leads to bugs that are difficult to trace.

       + The /null pointer/ case will nicely crash your program -- consider this
         to be a feature.

**** 11.1.2. Pointer addition - 171
     - Rule 2.11.2.1 :: A VALID pointer addresses the _FIRST_ element of an ARRAY
                        of the /base type/.

     - Code in 3 ways:
       #+BEGIN_SRC c
         // #1
         double sum0(size_t len, double const* a) {
           double ret = 0.0;

           for (size_t i = 0; i < len; ++i) {
             ret += *(a + i);
           }

           return ret;
         }

         // #2
         double sum1(size_t len, double const* a) {
           double ret = 0.0;

           for (double const* p = a; p < a+len; ++p) {
             ret += *p;
           }

           return ret;
         }

         // #3
         double sum2(size_t len, double const* a) {
           double ret = 0.0;

           for (double const*const aStop = a+len; a < aStop; ++a) {
             ret += *a;
           }

           return ret;
         }
       #+END_SRC

     - Rule 2.11.2.2 :: The length an array object cannot be reconstructed from a
                        pointer.

     - =Comment= In this case ~sizeof~ doesn't work.
       You must pass the length to functions.

       For example,
       #+BEGIN_SRC c
         double A [7] = { 0, 1, 2, 3, 4, 5, 6, };

         double s0_7 = sum0(7, &A[0]);  // for the whole
         double s1_6 = sum0(6, &A[1]);  // for last 6
         double s2_3 = sum0(3, &A[2]);  // for 3 in the middle
       #+END_SRC

     - Rule 2.11.2.3 :: Pointers are NOT arrays.

     - So if we pass arrays through pointers to a function, it is important to
       retain the real length that the array has.
         This is why we prefer the array notation for pointer interfaces through-
       out this book:
       #+BEGIN_SRC c
       // "Preferred" form contains more info. It DIRECTLY tells the reader `a`
       // is an array of length `len`

       // Preferred
       double sum0(size_t len, double const a[len]);
      
       // Just OK
       double sum0(size_t len, double const * a);
       #+END_SRC

     - Another difference is:
       that pointers have value and that that value can change.
       Thus they can be used by value operators as operands.
       _Array is not a value type_.

     - Setting pointers to 0 if it hasn't some valid address is very important and
       should not be forgotten.
       It helps to check and keep track if a pointer has been set.

     - Rule 2.11.2.4 :: Pointers have truth.

     - Rule 2.11.2.5 :: A pointed-to object must be of the indicated type.

     - Rule 2.11.2.6 :: A pointer must point to
       + a valid object,
       + one position beyond a valid object
         or 
       + be /null/.

     - =COMMENT=:
       1. This usually works:
          #+BEGIN_SRC c
          double A[2] = { 0.0, 1.0, };
          double * p = &A[0];
          printf("element %g\n", *p); // referencing object
          p += 2;                     // valid pointer, no object
          printf("element %g\n", *p); // referencing non-object
                                      // undefined behavior
          #+END_SRC

       2. This may crash at the increment operation:
          #+BEGIN_SRC c
          double A[2] = { 0.0, 1.0, };
          double * p = &A[0];
          printf("element %g\n", *p); // referencing object
          p += 3;                     // valid pointer, no object
          printf("element %g\n", *p); // referencing non-object
                                      // undefined behavior
          #+END_SRC

**** 11.1.3. Pointer subtraction and difference - 173

     - Rule 2.11.2.7 :: Only subtract pointers to elements of an array object.

       + _It is *only allowed* if the two pointers refer to elements of the *same*
         array object_.

     - Rule 2.11.2.8 :: All pointer differences have type ~ptrdiff_t~.

     - Rule 2.11.2.9 :: Use ~ptrdiff_t~ to encode
                        SIGNED differences of _positions_ or _sizes_.

**** 11.1.4. Pointer validity - 177
**** 11.1.5. Null pointers - 177
     - /null pointer/: 0 value of any pointer type.

     - C has the concept of /null pointer/. Here:
       #+BEGIN_SRC c
       double const * const nix = 0;
       double const * const nax = nix;
       #+END_SRC
       "nix" and "nax" would be such _a pointer object of value 0_.
       _But_ unfortunately a /null pointer constant/ is then not what you'd
       expect. =IMPORTANT=
       1. here by /constant/ the term refers to a compile time constant and _NOT_
          to a ~const~ qualified object.
          So for that reason already, both pointer objects above are not null
          pointer constants.
       2. the permissible type for these constants is restricted, it may be
          * any constant expression of _integer_ type or
          * of type ~void*~.

     - =TODO=: Other pointer types are not permitted, and we will only learn about
       pointers of that "type" below in Section 12.4. =IMPORTANT=

     - The definition by the C standard of what could be the expansion of the
       macro ~NULL~ is quite loose, it just has to be a null pointer constant.
       Therefore a C compiler could chose any of the following for it:
       | expansion                       | type                 |
       |---------------------------------+----------------------|
       | ~0U~                            | ~unsigned~           |
       |---------------------------------+----------------------|
       | ~0~                             | ~signed~             |
       | ~'\0'~                          |                      |
       | enumeration constant of value 0 |                      |
       |---------------------------------+----------------------|
       | ~0UL~                           | ~unsigned long~      |
       | ~0L~                            | ~signed long~        |
       |---------------------------------+----------------------|
       | ~0ULL~                          | ~unsigned long long~ |
       | ~0LL~                           | ~signed long~        |
       |---------------------------------+----------------------|
       | ~(void *)0~                     | ~void*~              |
       
     - Rule 2.11.7.1 :: Don't use ~NULL~.

     - =COMMENT=: ~NULL~ hides more than it clarifies,
       1. either use =0=, or
       2. if you really want to emphasize that the value is a pointer use the
          magic token sequence ~(void*)0~ directly.

*** 11.2. Pointers and structures - 178
    - If ~a~ is a pointer, ~a->tv_sec~ is nothing but ~(*a).tv_sec~.
    
**** 11.??. Opaque structures - 115
     - Rule 2.11.4.1 :: Don't hide pointers in a ~typedef~. =Extremely Important=

*** 11.3. Pointers and arrays - 182
**** 11.3.1. Array and pointer access are the same - 182
     - Rule 2.11.5.1 :: The two expressions ~A[i]~ and ~*(A+i)~ are equivalent.

     - =COMMENT=: This holds _regardless_ whether ~A~ is an array or a pointer.

     - If ~A~ is an array, ~*(A+i)~ shows our first application of one of the most
       important rules in C, called /array-to-pointer decay/.

     - Rule 2.11.5.2 :: Evaluation of an array ~A~ returns ~&A[0]~.

     - =COMMENT=: In fact, this is the reason behind Rules 1.6.1.3 to 1.6.1.5:
       Whenever an array occurs that requires a value,
       1. it decays to a pointer and
       2. we loose all additional information.

**** 11.3.2. Array and pointer parameters are the same - 182
     - Rule 2.11.6.1 :: In a function declaration any array parameters rewrites to
                        a pointer. =IMPORTANT=

     - =COMMENT=: The rule that we follow in this book to: =IMPORTANT=
       1. use array notation if we suppose that this _CAN'T be null_, and
       2. use pointer notation if it corresponds to one single item of the base
          type that also _can be null_ to indicate a special condition.

     - Rule 2.11.6.2 :: Only the innermost dimension of an array parameter is
                        rewritten.

     - Examples(they are equivalent):
       1. 
           #+BEGIN_SRC c
           void matrix_mult(size_t n, size_t k, size_t m,
                            double (C[n])[m],
                            double (A[n])[k],
                            double (B[k])[m]);
         
           #+END_SRC

       2.
          #+BEGIN_SRC c
          void matrix_mult(size_t n, size_t k, size_t m,
                           double (*C)[m],
                           double (*A)[k],
                           double (*B)[m]);
          #+END_SRC

       Observe that once we have rewritten the innermost dimension as a pointer,
       the parameter type is not an array anymore, but a "pointer to array". So
       there is no need to rewrite the subsequent dimensions.        

     - Rule 2.11.6.3 :: Declare length parameters before array parameters.

*** 11.4. Function pointers - 184 =TODO: Re-Read=
    - Rule 2.11.8.1 :: A function =f= without following opening =(= decays to a
                       pointer to its start.

    - Syntactically functions and function pointers are also similar to arrays in
      type declarations and as function parameters:  =TODO= =TODO= =???=
      #+BEGIN_SRC c
      typedef void atexit_function(void);
      // two equivalent definitions of the same type, that hides a pointer
      typedef atexit_type* atexit_function_pointer;
      typedef void (*atexit_function_pointer)(void);

      // five equivalent declarations for the same function
      void atexit(void f(void));
      void atexit(void (*f)(void));
      void atexit(atexit_function f);
      void atexit(atexit_function* f);
      void atexit(atexit_function_pointer f);
      #+END_SRC

    - There is some sort of catch-all pointer type, ~void*~,
      that can be used as a generic pointer to object types, no such generic type
      or implicit conversion exists for function pointers.

    - Rule 2.11.8.2 :: Function pointers must be used with their exact type. =IMPORTANT=

    - Example:
      The prototype of ~qsort~ in =stdlib.h= is
      #+BEGIN_SRC c
      void qsort(void *base, size_t nitems, size_t size,
                 int (*compar)(const void *, const void *));
      #+END_SRC
      Don't use ~int compare_int(int const * a, int const * b);~ as the ~compar~
      function.

    - Rule 2.11.8.3 :: The function call operator (...) applies to function pointers.

    - =COMMENT=: Similar rules as for arrays and pointers and the ~[...]~.

    - Equivalent (legal) calls to ~f~:   =TODO= =TODO= =???=
      #+BEGIN_SRC c
      double f(int a);
      
      f(3);            // decay to function pointer
      (&f)(3);         // address of function
      (*f)(3);         // decay to function pointer, then dereference, then decay
      (*&f)(3);        // address of function, then dereference, then decay
      (&*f)(3);        // decay, dereference, address of
      #+END_SRC
      So technically, in terms of the abstract state machine,
      1. _the pointer decay is always performed_ and
      2. _the function is called via a function pointer_.
      The first, "natural", call (~f(3)~) has a hidden evaluation of the ~f~
      identifier that results in the function pointer.

    - With all that, we can use function pointers almost like functions.
      #+BEGIN_SRC c
      // TODO....
      #+END_SRC

    - When using this feature you should always be aware that this introduces an
      indirection to the function call. The compiler first has to fetch the
      contents of logger and can only then call the function at the address that
      he found, there.
      _This has a certain overhead and should be avoided in time critical code_.

** TODO 12. The C memory model - 191 =RE-READ=
   - Apply unary operator ~&~ to (almost) all objects to retrieve their address.
     =Comment (footnote 16)=: only objects that are declared with keyword
                              ~register~ don't have an address.
     TODO (see Section 13.2.2 on Level 2).

   - Seen from C, the address is important, and it's not necessary to care about
     the "real" locations (, which can be in the RAM, a disk file, or an IO port,
     etc.).
     C is supported to do right thing, regardless.

   - Rule 2.12.0.1 :: Pointer types with distinct base types are distinct.

*** DONE 12.1. A uniform memory model - 193
    CLOSED: [2017-04-24 Mon 17:48]
    - THREE distinct types that by definition use _exactly one byte_ of memory:
      1. ~char~
      2. ~unsigned char~
      3. ~signed char~

    - Rule 2.12.1.1 :: ~sizeof (char)~ is _1_ by definition.

    - Rule 2.12.1.2 :: Every object A can be viewed as ~unsigned char[sizeof A]~.

    - Rule 2.12.1.3 :: Pointers to character types are special.

    - The types that are used to "compose" all other object types is derived from
      ~char~.
      This is _merely an historical accident_ and you shouldn't read too much
      into it.
      In particular, you should clearly distinguish the TWO different use cases:

    - Rule 2.12.1.4 :: Use the type ~char~ for character and string data.

    - Rule 2.12.1.5 :: Use the type ~unsigned char~ as the atom of all object
                       types. =IMPORTANT=

    - The type ~signed char~ is of much less importance than the two others.

    - Rule 2.12.1.6 :: The ~sizeof~ operator can be applied to objects and object
                       types.
                       =USAGE=:
                       1. When apply to objects
                          BOTH ~sizeof(object)~ and ~sizeof object~ are right!
                       1. apply to object types: 
                          ONLY ~sizeof(object)~ is right.

*** DONE 12.2. Unions - 193
    CLOSED: [2017-04-24 Mon 17:48]
    - /Unions/ are similar in declaration to ~struct~
      but have different semantic!

    - Rule 2.12.2.1 :: The in-memory order of the representation digits of a
                       numerical type is implementation defined.

    - /little Endian/ and /big Endian/
      All of this is not normalized by the standard, it is implementation defined
      behavior.

    - Rule 2.12.2.2 :: On _most_ architectures ~CHAR_BIT~ is 8 and ~UCHAR_MAX~ is
                       255.

    - The in memory representation of other base types are more complicated.

*** DONE 12.3. Memory and state - 195 =RE-READ=
    CLOSED: [2017-04-25 Tue 15:57]
    - /aliasing/: The phenomenon of accessing the same object through different
      pointers.

    - Rule 2.12.3.1 (Aliasing) :: With the _exclusion_ of character types,
         _only_ pointers of the same base type may alias.

    - Try to write programs such that to _protect_ our variables _from ever being
      aliased_, and there is an easy way to achieve that:

    - Rule 2.12.3.2 :: Avoid the ~&~ operator.

    - =TODO=: Depending on properties of a given variable, the compiler may then
      see that the address of the variable is never taken, and thus that the
      variable can't alias at all. In Section 13.2 we will see which properties
      of a variable or object may have influence on such decisions and how the
      ~register~ keyword can protect us from taking addresses inadvertently.

    - =TODO=: Later then, in Section 16.2, we will see how the ~restrict~ keyword
      allows to specify aliasing properties of pointer arguments, even if they
      have the same base type.
                       
*** DONE 12.4. Pointers to unspecific objects - 197
    CLOSED: [2017-04-25 Tue 00:17]
    - The main purpose of ~void~ is to be used a fallback pointer type:

    - Rule 2.12.4.1 :: Any object pointer converts _to_ and _from_ ~void*~.

    - =COMMENT=: Observe that this only talks about pointers to objects, not
      pointers to functions.  =IMPORTANT=

    - Rule 2.12.4.2 :: Converting an object pointer to ~void*~ and then back to
                       the same type is the _identity operation_.

    - The _ONLY_ thing a variable looses when converting to ~(void *)~ is the
      type information.

    - Rule 2.12.4.3 (avoid2*) :: Avoid ~void*~.

    - =COMMENT=: Avoid whenever you can.

    - Never use ~void~ to declare variables.
      =From Jian= The sematics of an operation is connected to the type of the
                  operand(s), and ~void~ has no realted operation.

*** DONE 12.5. Explicit conversions - 198
    CLOSED: [2017-04-25 Tue 01:05]
    - Problematic:
      #+BEGIN_SRC c
      unsigned char highC = 1;
      unsigned char highU = (highC << 32);  // undefined behavior
      #+END_SRC
      _Looks innocent, but isn't._

      In the second, the problem lays in the RHS.
      1. Narrow types are converted before doing arithmetic on them (Table 6).
         Here =highC= is converted to ~int~
         and
         the left shift operation is then performed on that type.

      2. By our assumption shifting by 31 bit shifts the 1 into the highest order
         bit, the sign bit.
         Thus the result of the expression on the right is _undefined_.
         =TODO= =REVIEW=

    - Rule 2.12.5.1 :: Chose your arithmetic types such that implicit conversions
                       are harmless.

    - /narrow types/ _ONLY make sense_ in very special circumstances:
      + Save memory.
        For example, A really _BIG array_ of _SMALL values_.

      + Use ~char~ for _characters_ and _strings_.
        But then you WOULDN'T do arithmetic with them.

      + You use ~unsigned char~ to inspect the bytes of an object.
        But then, again, you WOULDN'T do arithmetic with them.

    - Rule 2.12.5.2 :: DON'T use /narrow types/ in arithmetic.

    - Rule 2.12.5.3 :: Use ~unsigned~ types whenever you may.

    - There are ONLY _TWO_ forms of /implicit conversions/ that are permitted for
      pointers to data:
      1. conversions _from_ and _to_ ~void*~
      2. conversions that _add a qualifier_ to the target type.
      For example,
      =IMPORTANT=
      #+BEGIN_SRC c
      float f = 37.0; // conversion : to float
        // remember the rhs is double if not suffixed with 'f'

      double a = f; // conversion : back to double
        // sizeof(double) > sizeof(float)

      float * pf = &f; // exact type
      float const * pdc = &f; // conversion : adding a qualifier
      void * pv = &f; // conversion : pointer to void *

      float * pfv = pv; // conversion : pointer from void *
        // this is OK due to the real data pointed by `pv` is float.

      float * pd = &a; // error : incompatible pointer type (compiler knows)
        // assigning a pointer to a type that has a different size and
        // interpretation can and will lead to serious damage.
        // 
        // NOTICE:
        // This is one of the difference between pointer variables and the other
        // type of variables.
        //
        // this is an ERROR due to the real data pointed by `pv` is a double.
        //   sizoeof(float) < sizeof(double)

      double * pdv = pv; // undefined behavior if used 
        // These two steps will definitely happen (before this statment).
        // 1. the `pv` pointer points to the address `&f`
        //
        // 2. since the type of `pv` is `void *`, before proper operation no one
        //    knows how many bytes after the address `&f` will this pointer
        //    point.
        //
        // since this statement is an undefined behavior, we can supoose a
        // situation that can lead to errors:
        // 3. `double * pdv = pv;` means when de-reference `pdv`, it may intend
        //    to use more than sizeof(float) bytes (since its `double *`).
        //      If this happens, since we don't know the information of the bytes
        //    exceeds sizeof(float), we can't predict what will happen.
      #+END_SRC

    - Rule 2.12.5.4 :: Don't use casts.
                       =COMMENT= In most use cases that I have come across in
                       real life,
                       _the compiler was right and the programmer was wrong_:
                       even experienced programmers tend to abuse casts to hide
                       poor design decisions concerning types.

    - /casts/ deprive you of precious information and if you chose your types
      carefully you will only need them at very special occasions.

    - Use /cast/ HARMLESSLY in one situation:
      + You may want to inspect the contents of an object on byte level.
      + Constructing a ~union~ around an object _might not always be possible (or
        too complicated)_ so here we can go for a cast. For example,
        #+BEGIN_SRC c
        unsigned val = 0xAABBCCDD ;
        unsigned char * valp = (unsigned char *)& val;
        for ( size_t i = 0; i < sizeof val; ++i) {
          printf (" byte [%zu]: 0x %.02 hhX\n", i, valp[i]); 
        }
        #+END_SRC

*** DONE 12.6. Effective Type - 199
    CLOSED: [2017-04-25 Tue 02:06]
    - To cope with different views to the same object that pointers may provide,
      C has introduced the concept of effective types. It heavily restricts how
      an object can be accessed:

    - Rule 2.12.6.1 (/Effective Type/) :: _Objects_ must be accessed
      + through their effective type
        or
      + through a pointer to a character type.

    - Because the /effective type/ of a ~union~ variable is the ~union~ type and
      NONE of the member types, the rules for union members can be relaxed:

    - Rule 2.12.6.2 :: Any member of an object that has an effective union type
                       can be accessed at any time, provided the byte representa-
                       tion amounts to a valid value of the access type.
                       =EXAMPLES ???=

    - Rule 2.12.6.3 :: The /effective type/ of a variable or compound literal is
                       _the type of its declaration_.

    - Rule 2.12.6.4 :: _Variables_ and _compound literals_ must be accessed
      + through their declared type
        or
      + through a pointer to a character type.

    - _Asymmetry_ in all of this for character types.
      + Any object can be seen as a composed of ~unsigned char~,
      + but not any array of ~unsigned char~ can be used through another type.
      #+BEGIN_SRC c
      unsigned char A[sizeof(unsigned)] = { 9 };
      // valid but useless , as most casts are
      unsigned * p = (unsigned *)A;
      // error , access with type that is neither the effective type nor a
      // character type
      printf("value \%u\n", *p); 
      #+END_SRC

    - The reasons for such a strict rule are _multiple_.
       =TODO= (EXPLAIN THE "multiple" here)
      _The very first motivation_ for introducing /effective types/ in the C
      standard was to
      _deal with aliasing as we have seen in Section 12.3_.

      In fact,
      _the Aliasing Rule 2.12.3.1 is derived from the Effective Type Rule 2.12.6.1._

      As long as there is NO ~union~ involved, the compiler knows that, for
      example,
      + we CANNOT access a ~double~ through a ~size\under{}t *~,
        and
      + so he may assume that the objects are different.

*** DONE 12.7. Alignment - 200 =RE-READ=
    CLOSED: [2017-04-25 Tue 15:57]
    - /alignment/

    - /word boundary/

    - The inverse direction of pointer conversions (from "pointer to character
      type” to “pointer to object") is not harmless at all,
      1. not only because of possible aliasing.
      2. but also because of alignment (another property of the memory model of C).

    - Objects of most non-character types CAN'T start at any arbitrary byte posi-
      tion, they usually start at a /word boundary/.

    - /bus error/: data bus alignment error

    - Some architectures are more tolerant to misalignment than others
      and
      we might have to force the system to error out on such a condition.

    - ~\under{}Alignof(oneArg)~, ~\under{}Alignas(oneArg)~, ~<stdalign.h>~

** TODO 13. Storage - 205
*** 13.1. ~malloc~ and friends - 206
    - /dynamic memory allocation/, related functions are in  =stdlib.h=:
      #+BEGIN_SRC c
      #include <stdlib.h>
      void * malloc(size_t size);
      void free(void * ptr);
      void * calloc (size_t nmemb, size_t size); // set all bits to 0
      void * realloc(void * ptr, size_t size); // grow or shrink an object
      void * aligned_alloc(size_t alignment, size_t size);
      // ensures non-default alignment   ??? =TODO=
      #+END_SRC

    - Some examples:
      #+BEGIN_SRC c
      double * largeVec = malloc(length * sizeof(*largeVect));

      double * largeVec = malloc(length * sizeof(double)); // Add by Jian
      
      double * largeVec = malloc(sizeof(double[length]));
      #+END_SRC
 
    - Rule 2.13.1.1 :: Don't cast the return of ~malloc~ and friends.

    - =COMMENT=: Strong typed language C++ requires this kind of _CAST_.


    - Rule 2.13.1.2 :: Objects that are allocated through malloc are
                       uninitialized.
**** 13.1.1. A complete example with varying array size - 207
     - Rule 2.13.1.3 :: ~malloc~ indicates failure by returning a null pointer
                        value.

**** 13.1.2. Ensuring consistency of dynamic allocations - 215
     - Rule 2.13.1.4 :: For every ~malloc~ there must be a ~free~.

     - Rule 2.13.1.5 :: For every free there must be a ~malloc~.

     - Rule 2.13.1.6 :: Only call free with pointers as they are returned by
                        ~malloc~.
                        
*** 13.2. Storage duration, lifetime, and visibility - 215
     - Rule 2.13.2.1 :: Identifiers only have visibility inside their scope,
                        starting at their declaration.

     - Rule 2.13.2.2 :: The visibility of an identifier can be shadowed by an
                        identifier of the same name in a subordinate scope.

     - Rule 2.13.2.3 :: Every definition of a variable creates a new distinct
                        object.

     - Rule 2.13.2.4 :: Read-only object literals may overlap.

     - Rule 2.13.2.5 :: Objects have a lifetime outside of which they can't be
                        accessed.

     - Rule 2.13.2.6 :: Refering to an object outside of its lifetime has
                        undefined behavior.

**** 13.2.1. Static storage duration - 219
     - Rule 2.13.2.7 :: Objects with static storage duration are always
                        initialized.

**** 13.2.2. Automatic storage duration - 220
     - Rule 2.13.2.8 :: Unless they are VLA or temporary objects, automatic
                        objects have a lifetime corresponding to the execution of
                        their block of definition.

     - Rule 2.13.2.9 :: The ~&~ operator is not allowed for variables declared
                        with /register/.

     - Rule 2.13.2.10 :: Variables declared with /register/ can't alias.

     - Rule 2.13.2.11 :: Declare local variables in performance critical code as
                         /register/.

     - Rule 2.13.2.12 :: For an object that is not a VLA, lifetime starts when
                         the scope of the definition is entered, and it ends
                         when that scope is left.

     - Rule 2.13.2.13 :: Initializers of automatic variables and compound
                         literals are evaluated each time the definition is met.

     - Rule 2.13.2.14 :: For a VLA, lifetime starts when the definition is
                         encountered, ends when the visibility scope is left.

     - Rule 2.13.2.15 :: Objects of temporary lifetime are read-only.

     - Rule 2.13.2.16 :: Temporary lifetime ends at the end of the enclosing full
                         expression.

*** 13.3. Digression: using objects "before" their definition - 221
*** 13.4. Initialization - 223
    * Rule 2.13.3.1 :: Objects of static or thread storage duration are
                       initialized per default.

    * Rule 2.13.3.2 :: Objects of automatic or allocated storage duration must be
                       initialized explicitly.

    * Rule 2.13.3.3 :: Systematically provide an initialization function for each
                       of your data types.

*** 13.5. Digression: a machine model - 225

** TODO 14. More involved processing and IO - 231
*** 14.1. Text processing - 231
    - Rule 2.14.1.1 :: The string strto... conversion functions are not
                       ~const~-safe.

    - Rule 2.14.1.2 :: The ~memchr~ and ~strchr~ search functions are not
                       ~const~-safe.

    - Rule 2.14.1.3 :: The ~strspn~ and ~strcspn~ search functions are
                       ~const~-safe.

    - Rule 2.14.1.4 :: ~sprintf~ makes no provision against /buffer overflow/.

    - Rule 2.14.1.5 :: Use ~snprintf~ when formatting output of unknown length.

*** 14.2. Formatted input - 238
    - TABLE 1
    - TABLE 2
    - TABLE 3

*** 14.3. Extended character sets - 239
    - Rule 2.14.3.1 :: Multibyte characters don't contain null bytes.

    - Rule 2.14.3.2 :: Multibyte strings are null terminated.

*** 14.4. Binary streams - 247
*** 14.5. Error checking and cleanup - 249

* TODO LEVEL 3. Experience - 255
** 15. Performance - 257 - TODO Re-number TAKEAWAY's
   - TAKEAWAY D :: Premature optimization is the root of all evil.

   - TAKEAWAY 15.1 :: Do not trade off safety for performance.

   - TAKEAWAY 15.2 :: Optimizers are clever enough to eliminate unused initializations.

   - TAKEAWAY 15.3 :: The different notations of pointer arguments to functions
                      result in the same binary code.

   - TAKEAWAY 15.4 :: Not taking addresses of local variables helps the optimizer
                      because it inhibits aliasing.

*** 15.1. Inline functions - 260
    - TAKEAWAY 15.5 :: Inlining can open a lot of optimization opportunities.

    - TAKEAWAY 15.6 :: Adding a compatible declaration without ~inline~ keyword
                       ensures the emission of the function symbol in the current
                       TU.

    - TAKEAWAY 15.7 :: An ~inline~ function definition is visible in all TU.

    - TAKEAWAY 15.8 :: An ~inline~ definition goes in a header file.

    - TAKEAWAY 15.9 :: An additional declaration without ~inline~ goes in exactly
                       one TU.

    - TAKEAWAY 15.10 :: Only expose functions as ~inline~ if you consider them to
                        be stable.

    - TAKEAWAY 15.11 :: All identifiers that are local to an ~inline~ function
                        should be protected by a convenient naming convention.

    - TAKEAWAY 15.12 :: ~inline~ functions can't access identifiers of ~static~
                        functions.

    - TAKEAWAY 15.13 :: ~inline~ functions can't define or access identifiers of
                        ~static~ objects.

*** 15.2. Avoid aliasing: restrict qualifiers - 263
    - TAKEAWAY 15.14 :: A ~restrict~-qualified pointer has to provide exclusive
                        access.

    - TAKEAWAY 15.15 :: A ~restrict~-qualification constrains the caller of a
                        function.

*** 15.3. Measurement and inspection - 265
    - TAKEAWAY D :: Don't speculate about performance of code, verify it rigorously.

    - TAKEAWAY 15.16 :: Complexity assessment of algorithms needs proofs.

    - TAKEAWAY 15.17 :: Performance assessment of code needs measurement.

    - TAKEAWAY 15.18 :: All measurements introduce bias.

    - TAKEAWAY 15.19 :: Instrumentation changes compile time and runtime properties.

    - TAKEAWAY 15.20 :: The relative standard deviation of run times must be in a
                        low percentage range.

    - TAKEAWAY 15.21 :: Collecting higher order moments of measurements to compute
                        variance and skew is simple and cheap.

    - TAKEAWAY 15.22 :: Runtime measurements must be hardened with statistics.

** TODO 16. Function-like macros - 275
   - TAKEAWAY 16.1 :: Whenever possible, prefer an inline function to a functional
                      macro.

   - TAKEAWAY 16.2 :: A functional macro shall provide a simple interface to a
                      complex task.

*** 16.1. How function-like macros work - 277
    - TAKEAWAY 16.3 :: Macro replacement is done in an early translation phase,
                       before any other interpretation is given to the tokens
                       that compose the program.

    - TAKEAWAY 16.4 (macro retention) :: If the name of functional macro is not
                                         followed by () it is not expanded.

*** 16.2. Argument checking - 279
*** 16.3. Accessing the calling context - 282
    - TAKEAWAY 16.5 :: The line number in ~__LINE__~ may not fit into an ~int~.

    - TAKEAWAY 16.6 :: Using ~__LINE__~ is inherently dangerous.

    - TAKEAWAY 16.7 :: Stringification with the operator ~#~ does not expand macros
                       in its argument.

*** 16.4. Default argument lists - 285
*** 16.5. Variable length argument lists - 286
**** 16.5.1. Variadic macros - 287
**** 16.5.2. A detour: variadic functions - 291
     - TAKEAWAY 16.8 :: When passed to a variadic parameter, all arithmetic types
                        are converted as for arithmetic operations, with the ex-
                        ception of ~float~ arguments which are converted to
                        ~double~.

     - TAKEAWAY 16.9 :: A variadic function has to receive valid information
                        about the type of each argument in the variadic list.

     - TAKEAWAY 16.10 :: Using variadic functions is not portable, unless each
                         argument is forced to a specific type.

     - TAKEAWAY 16.11 :: Avoid variadic functions for new interfaces.

     - TAKEAWAY 16.12 :: The ~va_arg~ mechnanism doesn't give access to the length
                         of the ~va_list~ .

     - TAKEAWAY 16.13 :: A variadic function needs a specific convention for the
                         length of the list. 

*** 16.6. Type-generic programming - 294
    - TAKEAWAY 16.14 :: The result type of a ~_Generic~ expression depends on the
                        type of chosen expression.

    - TAKEAWAY 16.15 :: Using ~_Generic~ with ~inline~ functions adds optimization
                        oportunities.

    - TAKEAWAY 16.16 :: The type expressions in a ~_Generic~ expression should
                        only be unqualified types, no array types and no function
                        types.

    - TAKEAWAY 16.17 :: The type expressions in a ~_Generic~ expression must refer
                        to mutually incompatible types.

    - TAKEAWAY 16.18 :: The type expressions in a ~_Generic~ expression cannot be
                        a pointer to VLA.

    - TAKEAWAY 16.19 :: All choices expression1 ... expressionN in a ~_Generic~
                        must be valid.

** 17. Variations in control flow - 301 - TODO Re-number TAKEAWAY's
*** 17.1. A complicated example - 303
*** 17.2. Sequencing - 305
    - TAKEAWAY 17.1 :: Side effects in functions can lead to indeterminate results.

    - Here is a list of all sequence points that are defined in terms of C's grammar:
      * The end of a statement, either by semicolon (;) or closing brace (}).
      * The end of an expression before the comma operator (,).19
      * The end of a declaration, either by semicolon (;) or comma (,).20
      * The end of the controlling expressions of ~if~, ~switch~, ~for~, ~while~,
        conditional evaluation (?:) or short circuit evaluation (|| and &&).
      * After the evaluations of the function designator (usually a function
        name) and the function arguments of a function call21 but before the
        actual call.
      * The end of a return statement.

    - There are other sequencing restrictions besides those implied by sequence
      points. The first two are more or less obvious but should be stated
      nevertheless:

    - TAKEAWAY 17.2 :: The specific operation of any operator is sequenced after
                       the evaluation of all its operands.

    - TAKEAWAY 17.3 :: The effect of updating an object by any of the assignment,
                       increment or decrement operators is sequenced after the
                       evaluation of its operands.

    - TAKEAWAY 17.4 :: A function call is sequenced with respect to all evalua-
                       tions of the caller.

    - TAKEAWAY 17.5 :: Initialization list expressions for array or structure
                       types are indeterminately sequenced.

*** 17.3. Short jumps - 308
    - TAKEAWAY 17.1 :: Each iteration defines a new instance of a local object.

    - TAKEAWAY 17.2 :: ~goto~ should only be used for exceptional changes in
                       control flow.

*** 17.4. Functions - 309
    - TAKEAWAY 17.1 :: Each function call defines a new instance of a local
                       object.

*** 17.5. Long jumps - 310
    - TAKEAWAY 17.1 :: ~longjmp~ never returns to the caller.

    - TAKEAWAY 17.2 :: When reached through normal control flow, a call to
                       ~setjmp~ marks the call location as a jump target and
                       returns =0=.

    - TAKEAWAY 17.3 :: Leaving the scope of a call to ~setjmp~ invalidates the
                       jump target.

    - TAKEAWAY 17.4 :: A call to ~longjmp~ transfers control directly to the
                       position that was set by ~setjmp~ as if that had returned
                       the condition argument.

    - TAKEAWAY 17.5 :: A =0= as _condition_ parameter to ~longjmp~ is replaced
                       by =1=.

    - TAKEAWAY 17.6 :: ~setjmp~ may only be used in simple comparisons inside
                       controlling expression of conditionals.

    - TAKEAWAY 17.7 :: Optimization interacts badly with calls to ~setjmp~.

    - TAKEAWAY 17.8 :: Objects that are modified across longjmp must be
                       ~volatile~.

    - TAKEAWAY 17.9 :: ~volatile~ objects are reloaded from memory each time they
                       are accessed.

    - TAKEAWAY 17.10 :: ~volatile~ objects are stored to memory each time they
                        are modified.

    - TAKEAWAY 17.11 :: The ~typedef~ for ~jmp_buf~ hides an array type.

*** 17.6. Signal handlers - 315
    - TAKEAWAY 17.1 :: C's signal handling interface is minimal and should only
                       be used for elementary situations.

    - TAKEAWAY 17.2 :: Signal handlers can kick in at any point of execution.

    - TAKEAWAY 17.3 :: After return from a signal handler, execution resumes
                       exactly where it was interrupted.

    - TAKEAWAY 17.4 :: A C statement may correspond to several processor
                       instructions.

    - TAKEAWAY 17.5 :: Signal handlers need types with uninterruptible
                       operations.

    - TAKEAWAY 17.6 :: Objects of type ~sig~atomic_t_ should not be used as
                       counters.

    - TAKEAWAY 17.7 :: Unless specified otherwise, C library functions are not
                       asynchrounous signal safe.

** TODO 18. Threads - 225
*** 18.1. Simple inter-thread control - 328
    - TAKEAWAY 18.1 :: If a tread T_{0} writes a non-atomic object that is simultaneously
                       read or written by another thread T_{1} the behavior of the execution
                       becomes undefined.

    - TAKEAWAY 18.2 :: In view of execution in different threads, standard operations
                       on atomic objects are indivisible and linearizable.

    - TAKEAWAY 18.3 :: Use the specifier syntax ~_Atomic (T)~ for atomic declarations.

    - TAKEAWAY 18.4 :: There are no atomic array types.

    - TAKEAWAY 18.5 :: Atomic objects are the privileged tool to force the absence
                       of race conditions.

*** 18.2. Race-free initialization and destruction - 330
    - TAKEAWAY 18.6 :: A properly initialized ~FILE*~ can be used race-free by
                       several threads.

    - TAKEAWAY 18.7 :: Concurrent write operations should print entire lines at
                       once.

    - TAKEAWAY 18.8 :: Destruction and deallocation of shared dynamic objects needs
                       a lot of care.

*** 18.3. Thread local data - 333
    - TAKEAWAY 18.9 :: Pass thread specific data through function arguments.

    - TAKEAWAY 18.10 :: Keep thread specific state in local variables.

    - TAKEAWAY 18.11 :: A ~thread_local~ variable has one separate instance for
                        each thread.

    - TAKEAWAY 18.12 :: Use ~thread_local~ if initialization can be determined at
                        compile time.

*** 18.4. Critical data and critical sections - 333
    - TAKEAWAY 18.13 :: Mutex operations provide linearizability.

    - TAKEAWAY 18.14 :: Every mutex must be initialized with ~mtx_init~.

    - TAKEAWAY 18.15 :: A thread that holds a non-recursive mutex must not call
                        any of the mutex lock function for it.

    - TAKEAWAY 18.16 :: A recursive mutex is only released after the holding
                        thread issues as many calls to ~mtx_unlock~ as it has
                        acquired locks.

    - TAKEAWAY 18.17 :: A locked mutex must be released before the termination of
                        the thread.

    - TAKEAWAY 18.18 :: A thread must only call ~mtx_unlock~ on a mutex that it
                        holds.

    - TAKEAWAY 18.19 :: Each successful mutex lock corresponds to exactly one call
                        to ~mtx_unlock~.

    - TAKEAWAY 18.20 :: A mutex must be destroyed at the end of its lifetime.

*** 18.5. Communicating through condition variables - 336
    - TAKEAWAY 18.21 :: On return from a ~cnd_t~ wait, the expression must be
                        checked, again.

    - TAKEAWAY 18.22 :: A condition variable can only be used simultaneously with
                        one mutex.

    - TAKEAWAY 18.23 :: A ~cnd_t~ must be initialized dynamically.

    - TAKEAWAY 18.24 :: A ~cnd_t~ must be destroyed at the end of its lifetime.

*** 18.6. More sophisticated thread management - 341
    - TAKEAWAY 18.25 :: Returning from ~main~ or calling ~exit~ terminates all
                        threads.

    - TAKEAWAY 18.26 :: While blocking on ~mtx_t~ or ~cnd_t~ a thread frees
                        processing resources.

** TODO 19. Atomic access and memory consistency - 345
   - TAKEAWAYS 19.1 :: Every evaluation has an effect.

*** 19.1. The "happend before" relation - 347
    - TAKEAWAYS 19.2 :: If F is sequenced before E, then F -> E.

    - TAKEAWAYS 19.3 :: The set of modifications of an atomic object A are performed
                        in an order that is consistent with the sequenced before
                        relation of any threads that deals with A.

    - TAKEAWAYS 19.4 :: An acquire operation E in a thread T_E synchronizes with a
                        release operation F in another thread T_F if E reads the value
                        that F has written.

    - TAKEAWAYS 19.5 :: If F synchronizes with E, all effects X that have happened
                        before F must be visible at all evaluations G that happen
                        after E.

    - TAKEAWAYS 19.6 :: We only can conclude that one evaluation happened before
                        another if we have a sequenced chain of synchronizations
                        that links them.

    - TAKEAWAYS 19.7 :: If an evaluation F happened before E, all effects that are
                        known to have happened before F are also known to have happened
                        before E.

*** 19.2. C library calls that provide synchronization - 349
    - TAKEAWAY 19.8 :: Critical sections that are protected by the same mutex
                       occur sequentially.

    - TAKEAWAY 19.9 :: In a critical section that is protected by mutex mut all
                       effects of previous critical sections protected by mut are
                       visible.

    - TAKEAWAY 19.10 :: ~cnd_wait~ or ~cnd_timedwait~ have release-acquire
                        semantics.

    - TAKEAWAY 19.11 :: Calls to ~cnd_signal~ or ~cnd_broadcast~ synchronize via
                        the mutex.

    - TAKEAWAY 19.12 :: Calls to ~cnd_signal~ or ~cnd_broadcast~ should occur inside
                        a critical section that is protected by the same mutex as
                        the waiters.

*** 19.3. Sequential consistency - 352
    - TAKEAWAY 19.13 :: All atomic operations with sequential consistency occur in
                        one global modification order, regardless of the atomic
                        object they are applied to.

    - TAKEAWAY 19.14 :: All operators and functional interfaces on atomics that
                        don't specify otherwise have sequential consistency.

*** 19.4. Other consistency models - 353
    - TAKEAWAY 19.15 :: Every functional interface for atomic objects has a form with
                        ~_explicit~ appended which allows to specify its consistency
                        model.

* Takeaways - 357
* Bibliography - 370
* Index - 372
* TODO (DELETED) LEVEL 4. Ambition - 243
** TODO (DELETED) 15. Error checking and cleanup - 165
   - The C standard itself imposes only ~EOF~ (which is negative), and ~EDOM~,
     ~EILSEQ~ nad ~ERANGE~ (which is positive).

   - Rule 2.15.0.1 :: Labels for ~goto~ are visible in the whole function that
                      contains them.

   - Rule 2.15.0.2 :: ~goto~ can only jump to a label inside the same function.

   - Rule 2.15.0.3 :: ~goto~ should not jump over variable initializations.

** 21. The ~register~ overhaul - 244
   - Rule 4.21.0.1 :: Objects that are declared with /register/ storage duration
                      can't alias.
   - The goals of this proposal are multiple:
     * Goal 1 :: Use ~const~ qualified register objects as typed compile time constants.
     * Goal 2 :: Extend the optimization opportunities of ~register~ to file scope objects.
     * Goal 3 :: Create new optimization opportunities for functions that are local to a TU.
     * Goal 4 :: Improve the interplay between objects and functions that are local to a TU.
     * Goal 5 :: Impose bounds checking for constant array subscripts.:: 
*** Overview - 245
*** 21.1. Introduce ~register~ storage class in file scope - 245
**** 21.1.1. Changes for object types

*** 21.2. Typed constants with ~register~ storage class and ~const~ qualification - 246
    - Rule 4.21.2.1 :: File scope ~static const~ objects may be replicated in
                       all compilation units that use them.

    - Rule 4.21.2.2 :: File scope ~static const~ objects cannot be used inside
                       ~inline~ functions with external linkage.

    - Rule 4.21.2.3 :: File scope ~extern const~ objects may miss optimization
                       opportunities for constant folding and instruction imme-
                       diates.

    - Rule 4.21.2.4 :: File scope ~extern~ or ~static const~ objects may miss
                       optimization opportunities because of mispredicted aliasing.

*** 21.3. Extend ICE to register constants - 249
    - Rule 4.21.3.1 :: Changing an identifier that represents an integer
                       constant to be an ICE, can change effective types of
                       objects and execution paths.

*** 21.4. Functions - 251
**** 21.4.1. Optimization opportunities
**** 21.4.2. Relaxed constraints for TU local objects
**** 21.4.3. Changes for function types

*** 21.5. Unify designators - 253

** 22. Improve type generic expression programming - 256
   - Goal 6 :: Amend the C standard to be able to use anonymous functions and
               inferred types for type generic expressions inside macros.
*** 22.1. Storage class for compound literals - 257
*** 22.2. Inferred types for variables and functions - 258
**** 22.2.1. Extended use of auto

*** 22.3. Anonymous functions - 261
    - Goal 7 :: Extend the notion of compound literals to function types.

**** 22.3.1. ~static~ anonymous functions
**** 22.3.2. ~register~ anonymous functions
**** 22.3.3. ~auto~ anonymous functions
**** 22.3.4. A partial implementation
** 23. Improve the C library - 263
*** 23.1. Make the presence of all C library headers mandatory - 263
    - Goal 8 :: Allow optional C library headers to be incomplete.
    - Goal 9 :: Provide feature test macros for completeness of headers.
    - Goal 10 :: Provide a version macro for all C library headers.
    - Goal 11 :: Distinguish test macros for compiler and library features.
    - Goal 12 :: Make all C library headers mandatory.

*** 23.2. Add requirements for sequence points - 269
*** 23.3. Provide type generic interfaces for string functions - 271
    - Goal 13 :: Ensure that all C library interfaces honor the ~const~ contract.
    - Goal 14 :: Provide type generic interfaces for narrow and wide string functions.

** 24. Modules - 274
*** 24.1. C needs a specific approach - 275
*** 24.2. All is about naming - 275
*** 24.3. Modular C features - 276

** 25. Simplify the object and value models - 277
   - Goal 15 :: Simplify the value and memory models.

*** 25.1. Remove objects of temporary lifetime - 277
*** 25.2. Introduce comparison operator for object types - 277
*** 25.3. Make ~memcpy~ and ~memcmp~ consistent - 277
*** 25.4. Enforce representation consistency for ~_Atomic~ objects - 278
*** 25.5. Make string literals ~char const~ array - 278
*** 25.6. Default initialize padding to ~0~ - 278
*** 25.7. Make ~restrict~ qualification part of the function interface - 278
**** 25.7.1. Function parameters
**** 25.7.2. Function return
**** 25.7.3. Proposed additions

*** 25.8. References - 279

** 26. Contexts - 279
*** 26.1. Introduce evaluation contexts in the standard - 279
*** 26.2. Convert object pointers to void* in unspecific context - 279
*** 26.3. Introduce =nullptr= as a generic null pointer constant and deprecate ~NULL~ - 279

