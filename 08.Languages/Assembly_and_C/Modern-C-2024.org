#+TITLE: Modern C
#+Copyright: 2024-10-15
#+AUTHOR: Jens Gustedt
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Acknowledgments - ii
* About this book - iii
- Takeaway #1 :: C and C++ are different: don’t mix them, and don't mix them up.

* C revisions - iii
* This edition - iii
* C and C++ - iii
* Requirements - iv
* Source code - v
* Exercises and challenges - v
* Organization - v
* Author - vi
* DONE LEVEL 0. Encounter - 1
CLOSED: [2017-04-25 Tue 16:11]

This first level of the book provides you with a rough knowledge of
C programs, their purposes, their structures, and how to use them.

- It is not meant to give you a complete overview. On the contrary, it is
  intended to give you a general idea of what C is all about, open up questions,
  and promote ideas and concepts.
  * These then will be explained in detail throughout the book.

** DONE 1. Getting started - 2
CLOSED: [2025-03-16 Sun 19:57]
- This section covers
  * Introduction to /imperative programming/
  * Compiling and running code

- In this section, I will introduce you to a simple program that contains many
  of the constructs of the C language.

- An important bit of wisdom for programming in general, and for this book in
  particular, is summarized in the following quote from the Hitchhiker's Guide
  to the Galaxy by Douglas Adams [1986]:
  * Takeaway 1 #2 :: Don't panic.

*** 1.1. Imperative programming - 2
- Takeaway 1.1 #1 :: C is an imperative programming language.

- LISTING 1.1. :: 
  #+begin_src c
    /* This may look like nonsense, but really is -*- mode: C -*- */
    #include <stdlib.h>
    #include <stdio.h>

    /* The main thing that this program does. */
    int main(int argc, [[maybe_unused]] char* argv[argc+1]) {
      // Declarations
      double A[5] = {
        [0] = 9.0,
        [1] = 2.9,
        [4] = 3.E+25,
        [3] = .00007,
      };

      // Doing some work
      for (size_t i = 0; i < 5; ++i) {
        printf("element %zu is %g, \tits square is %g\n",
               i,
               A[i],
               A[i]*A[i]);
      }

      return EXIT_SUCCESS;
    }
  #+end_src

*** 1.2. Compiling and running - 4
- Takeaway 1.2 #1 :: C is a compiled programming language.

- The target binary code is _platform dependent_.
  * That's one of the reasons for C to exist:
    C provides a level of abstraction for all the different machine-specific
    languages (usually referred to as an /assembly language/).

- Takeaway 1.2 #2 :: A correct C program is portable between different platforms.

- In this book, we will put a lot of effort into writing "correct" C programs
  that ensure portability.

  * _UNFORTUNATELY_,
    + there are some platforms that claim to be C but do not conform to the
      _LATEST standards_, and
    + some conforming platforms
      - accept _INCORRECT_ programs or
      - provide _extensions_ to the C standard that are not widely portable.
    So, running and testing a program on a single platform will not always
    guarantee portability.

- footnote 2:
  In fact, the *translation* itself is done in _SEVERAL STEPS_ that go from
  _textual replacement_ to _proper compilation_ and _linking_.

  Nevertheless, the tool that bundles all this is traditionally called a
  *compiler* and NOT a translator, which would be more accurate.

- ~c17 -Wall -o getting-started getting-started.c -lm~
  * ~-Wall~ tells it to warn us about anything that it finds unusual.

- portable (in current context) :: wherever you run that program, its behavior
  should be the same.

- The names of compilers vary. Here are some common alternatives that might do
  the trick:
  #+begin_src shell
    clang -std=c2x -Wall -lm -o getting-started getting-started.c

    gcc -std=c2x -Wall -lm -o getting-started getting-started.c

    icc -std=c2x -Wall -lm -o getting-started getting-started.c
  #+end_src

- ~-Werror~ (for gcc): reject programs with =warnings=, all =warnings= will
  be treated as errors.
  * =from Jian=
    As of _gcc_ version 14.2.0, even without this flag, no output will be
    generated, like _clang_.

- Takeaway 1.2 #3 :: A C program should compile cleanly without warnings.
  * =from Jian=
    Actually, not only C programs!

- Footnote Exs 7: =todo=

*** Summary - 8
- C is designed to give orders to computers. Therefore, it mediates between us
  (the programmers) and computers.

- C must be compiled to be executed.
  The compiler provides the translation between the language that we understand
  (C) and the specific needs of the particular platform.

- C gives a level of abstraction that provides portability.
  One C program _CAN_ be used on many different computer architectures.

- The C compiler is there to help you. If it warns you about something in your
  program, listen to it.

** DONE 2. The principal structure of a program - 9
CLOSED: [2020-02-16 Sun 15:49]
- This section covers
  * C grammar
  * Declaring identifiers
  * Defining objects
  * Instructing the compiler with statements

- There are _two_ categories of aspects to consider in a C program:
  * syntactical aspects :: how do we specify the program so the compiler
                           understands it.
  * semantic aspects :: what do we specify so that the program does what we
                        want it to do.

- =IMPORTANT=
- =IMPORTANT=
- =IMPORTANT=
- In the following subsections we will introduce
  * the _syntactical_ aspects ("grammar") and
  * three different _semantic_ aspects, namely
    1. declarative parts (what things are),
    2. definitions of objects (where things are) and
    3. statements (what are things supposed to do).

*** DONE 2.1. Grammar - 9
CLOSED: [2025-03-17 Mon 20:44]
- Special words in listing 1.1:
  * ~#include~
  * ~int~
  * ~maybe_unused~
  * ~char~
  * ~void~
  * ~double~
  * ~for~
  * ~return~

- In program text in this book, most of _special words_
  will be printed in _black bold_.
  * footnote 8:
    In C jargon, _special words_ in above sentence are
    _directives_, _keywords_, _attributes_, and _reserved_
    identifiers.

- Punctuations
  * Six kinds of brackets (should always come in pairs):
    1. ~{}~
    2. ~()~
    3. ~[]~
    4. ~[[]]~
    5. ~/**/~
    6. ~<>~: on the same logical line of text.

  * Two different /separators/ or /terminators/:
    + comma: ~,~
    + semicolon: ~;~

- One of the difficulties for newcomers to C is that the same punctuation
  characters are used to express different concepts. For example, the pairs ~{}~
  and ~[]~ are each used for *three different purposes* in listing 1.1.[Exs 9]
  =TODO=

- Takeaway 2.1 #1 :: Punctuation characters can be used with several
                     different meanings.

- Comments
  * /* */
  * //

- Literals

- Identifiers
  * Data objects
  * Type
  * Functions
  * Constants

- Functions

- Operators

- Attributes ::
  Such as ~[[maybe_unused]]~ are placed into double square brackets as shown and
  provide some _SUPPLEMENTAL_ information to the principle structure of the
  program.^{C23}

- In the following subsections, we will dig into the THREE main _semantic
  categories_ that C distinguishes:
  1. declarations
  2. definitions
  3. statements

*** DONE 2.2. Declarations - 10
CLOSED: [2025-03-17 Mon 22:07]
- *BEFORE* we may use a particular /identifier/ in a program,
  we have to _give the compiler a /declaration/ that *specifies*
  WHAT that identifier is supposed to represent._

- /Identifiers/ differ from /keywords/:
  * keyword: _PREDEFINED_ by the language,
             _and *must not* be declared or redefined_.

  * identifier: _DECLARED_ before being used.

- Takeaway 2.2 #1 :: ALL identifiers of a program have to be /declared/.

- Several of the identifiers we use are effectively *declared in our program*:
  #+begin_src c
    int main(int, char* []);
    int argc;
    [[maybe_unused]] char* argv[];
    double A[5];
    size_t i;
  #+end_src
  * Later we will see where the other identifiers (~printf~, ~size_t~, and
    ~EXIT_SUCCESS~) come from.

- Figure in page 11:
  CONCEPTUALLY, it is important to *distinguish*
  * the box itself (the /object/),
  * the specification (its /type/),
  * the box contents (its /value/), and
  * the name or label that is written on the box (the /identifier/).

- ~printf~, ~size_t~, and ~EXIT_SUCCESS~ are predeclared identifiers:
  * ~printf~ comes from ~<stdio.h>~
  * ~size_t~ and ~EXIT_SUCCESS~ come from ~<stdlib.h>~

- Because the specifics of these predeclared features are of _minor importance_

  (=from Jian= I don't think they are of minor importance, and this is why other
  programming languages provide much better and clearer import syntax),

  this information is normally hidden from you in /include files/ or /header
  files/.

  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  If you need to know their /semantics/,
  1. it is usually a *BAD idea* to look them up in the corresponding files,
     as these tend to be barely readable.

  2. INSTEAD,
     search in the documentation that comes with your platform.
     * *For the brave*, I always recommend a look into the current C standard,
       as that is where they all come from.
       =IMPORTANT= =TODO=

     * *For the less courageous*, the following commands may help:
       #+begin_src shell
         apropos printf

         man printf

         man 3 printf
       #+end_src
       =IMPORTANT= =TODO=

- A /declaration/
  _ONLY_ describes a feature
  _BUT_ does not create it,
  so repeating a declaration does not do much harm BUT adds REDUNDANCY.

- Takeaway 2.2 #2 :: Identifiers may have several *consistent* /declarations/.

- In the same part of the program (/scope/), C only allow one kind of
  declaration.
  * scope :: a part of the program where an identifier is *visible*.

- Takeaway 2.2 #3 :: /Declarations/ are bound to the /scope/ in which they
  appear.

- The /scopes/ of identifiers are UNAMBIGUOUSLY described by the grammar.

- /block scope/
  * ~main~, together with its parameter list (enclosed in ~()~) and the whole
    body (enclosed in ~{}~), forms a single /block/ of its own.

  * The ~for~ construct forms a /primary block/, and
    the loop body forms a /secondary block/.

- Blocks can be nested.

- Identifiers in /file scope/ are often referred to as /globals/.
  * ~main~ is in /file scope/.

*** DONE 2.3. Definitions - 13
CLOSED: [2025-03-18 Tue 10:09]
Generally,
/declarations/ _ONLY_ specify the kind of object an identifier refers to, NOT
what the concrete value of an identifier is, NOR where the object it refers to
can be found.

This important role is filled by a /definition/.

- Takeaway 2.3 #1 :: /Declarations/ specify /identifiers/ whereas /definitions/
                     specify /objects/.

- More complicated in real life,
  BUT for now we can *make the simplification* that
  we will _ALWAYS initialize our variables_.

- initialization :: a grammatical construct that AUGMENTS a /declaration/ and
  provides an initial value for the /object/.
  * For instance,
    #+begin_src c
      size_t i = 0;
    #+end_src

- In C, such _a declaration with an initializer_ also defines the /object/ with
  the corresponding name: that is, it instructs the compiler to provide _storage_
  in which the /value/ of the /variable/ can be stored.

- Takeaway 2.3 #2 :: An object is defined at the same time as it is initialized.

- A box visualization:
  #+begin_src text
      |------------|
    i |  size_t 0  |
      |------------|
  #+end_src

- Array ~A~ is a bit more complex because it has several components:
  #+begin_src c
    double A[5] = {
      [0] = 9.0,
      [1] = 2.9,
      [4] = 3.E+25,
      [3] = .00007,
    };
  #+end_src
  The form of the initializer we see here is called /designated/: a pair of
  brackets with an integer designates which item of the array is initialized
  with the corresponding value.

  * As a _special rule_, any position that is not listed in the initializer is
    set to ~0~. In our example, the missing ~[2]~ is filled with ~0.0~.

- Takeaway 2.3 #3 :: Missing elements in initializers default to 0.

- Takeaway 2.3 #4 :: For an array with =n= the first element has index ~0~, the
                     last has index ~n-1~.

- In our examples so far, we have seen names for _TWO different features_:
  /objects/ (~i~ and ~A~) and /functions/ (~main~ and ~printf~).

  * In contrast to /object or function declarations/, where several are allowed
    for the same identifier, /definitions of objects or functions/ must be
    *unique*.

- Takeaway 2.3 #5 :: Each object or function must have exactly one definition.

*** DONE 2.4. Statements - 14
CLOSED: [2025-03-17 Mon 20:40]
- /Statements/ are /instructions/ that tell the compiler *what to do* with
  /identifiers/ that have been declared so far.

- In the following subsection, we will go a bit into the details of _THREE
  categories_ of statements:
  * iterations (do something several times),
  * function calls (delegate execution somewhere else), and
  * function returns (resume execution from where a function was called).

**** 2.4.1. Iteration - 15
- domain iteration :: each iteration of ~for~ is related to a specific value
  ~i~, which makes this ~for~ an iteration over the /domain/ =0, . . . , n=.

- Takeaway 2.4.1 #1 :: Domain iterations should be coded with a ~for~ statement.

- Takeaway 2.4.1 #2 :: The /loop variable/ should be defined in the initial part
                       of a ~for~.

**** 2.4.2. Function calls - 15
- Function calls :: special statements that
  1. _SUSPEND_ the execution of the current function (at the beginning, this is usually ~main~)
  2. and then _HAND OVER CONTROL_ to the named function

- call by value :: functions take arguments by values, and they are not able to
  change the origins of arguments.
  * For example, you pass ~i~ to a function by its argument ~a~.
    This function get the value of ~i~ through ~a~, ~a~ and ~i~ have the same
    value, but ~a~ is not ~i~, and this function can't change ~i~.

- Other programming /call by reference/, a mechanism where the called function
  can change the value of a variable.

- C does *NOT* implement /pass by reference/;
  instead, it has another mechanism to pass the control of a variable to another
  function: _by take addresses and transmitting pointers._
  * =TODO=
    We will see this mechanism much later.

**** 2.4.3. Function return - 16

*** DONE Summary - 17
CLOSED: [2025-03-17 Mon 20:44]
- C distinguishes
  * the /lexical structure/ (the punctuators, identifiers, and numbers),
  * the /grammatical structure/ (syntax), and
  * the /semantics/ (meaning)
  of programs.

- _ALL /identifiers/ (names) must be *declared*,_
  so we know the properties of the concept they represent.

- _ALL /objects/ (things that we deal with) and /functions/ (methods that we use
  to deal with things) must be *defined*;_ that is, we must specify *HOW* and
  *WHERE* they come to be.

- /Statements/ indicate *HOW* things are going to be done:
  * /iterations/ (for) repeat variations of certain tasks,
  * /function calls/ (printf(...)) delegate a task to a function, and
  * /function returns/ (return something;) go back where we came from.

* DONE LEVEL 1. Acquaintance - 19
CLOSED: [2017-04-25 Tue 16:11]
This level will acquaint you with the C programming language;
that is, it will provide you with enough knowledge to
_write_ and _use_ *good C programs*.

- "Good" here refers to a *modern* understanding of the language, avoiding most
  of the pitfalls of *early dialects* of C and offering you some constructs that
  were not present before and that are portable across the vast majority of
  modern computer architectures, from your cell phone to a mainframe computer.

- Having worked through these sections, you should be able to write short code
  for everyday needs that is not extremely sophisticated but useful and
  portable.

** TODO Buckle up - 20
- The most dangerous constructs in C are the so-called /casts/, so we'll skip
  them at this level.
  * We will _focus_ primarily on the ~unsigned~ versions of integer types.
  * We will _introduce_ /pointers/ in steps: ......
  * We will _focus_ on the use of /arrays/ whenever possible, instead.

- We define variables as close to their first use as possible.

- Lack of variable initialization, especially for pointers, is one of the major
  pitfalls for novice C programmers. This is why we should, whenever possible,
  combine the declaration of a variable with the first assignment to it

- We use prefix notation for code blocks (in this book).

** DONE 3. Everthing is about control - 23
CLOSED: [2017-04-25 Tue 16:11]
*** 3.1. Conditional execution - 23
- /controlling expression/, /dependent block/

- Takeaway 3.1 #1 :: The value 0 represents logical false.

- Takeaway 3.1 #2 :: Any value different from 0 represents logical true.

- =stdbool.h=
  #+BEGIN_SRC c
  #include <stdbool.h>
  bool b = true;
  #+END_SRC

- Takeaway 3.1 #3 :: Don’t compare to ~0~, ~false~ or ~true~.

- Takeaway 3.1 #4 :: All scalars have a truth value.

- TABLE 1. Scalar types used in this book =RE-READ=

*** 3.2. Iterations - 26
- Example 1:
  #+BEGIN_SRC c
  #include <stdlib.h>
  // Iterate 9 times! Type size_t is a nonegative type.
  for (size_t i = 9; i <= 9; --i) {
    something_else(i);
  }
  #+END_SRC

- ~do ... while~ always needs a semicolon ; after the while (condition) to
  terminate the statement. =IMPORTANT=

- [ =TODO= ] Later we will see that this is a syntactic feature that turns
  out to be quite useful in the context of multiple nested statements, see
  Section 10.3.

- Special usage (equivalent loosp):
  #+BEGIN_SRC c
  #include <tgmath.h>

  double const eps = 1E-9;
  double const a = 34.0;
  double x = 0.5;

  // #1
  while (fabs(1.0 - prod) >= eps) {
    double prod = a * x;
    x *= (2.0 - prod);
  }

  // #2
  while (true) {
    double prod = a * x;

    if (fabs(1.0 - prod) < eps) {
      break;
    }

    x *= (2.0 - prod);
  }

  // #3
  // there is a tradition among C programmers to write it in as follows.
  for (;;) {
    double prod = a*x;

    if (fabs(1.0 - prod) < eps) {
      break;
    }

    x *= (2.0 - prod);
  }
  #+END_SRC

- PAGE 19 =TODO ???=

*** 3.3. Multiple selection - 30
- The /fallback/ case of ~switch~.

- Takeawy 3.3 #1 :: ~case~ values must be integer constant expressions.

- Takeawy 3.3 #2 :: ~case~ values must be unique for each ~switch~ statement.

- Takeawy 3.3 #3 :: ~case~ labels must not jump beyond a variable definition. =TODO ???=

*** Summary - 33

** DONE 4. Expressing computations - 34
CLOSED: [2017-04-25 Tue 16:11]
*** 4.1 Operands and operators - 34
- Takeaway 4.1 #1 :: The type ~size_t~ represents values in the range
                     ~[0, SIZE_MAX]~.

- The value of ~SIZE_MAX~ (from =stdint.h=) is quite large, depending on the
  platform it should be one of
  1. 2^16 − 1 = 65535 (minimal requirement)
  2. 2^32 − 1 = 4294967295 (common today)
  3. 2^64 − 1 = 18446744073709551615 (common today)

*** 4.2. Arithmetic - 35
**** 4.2.1. ~+~, ~-~ and ~*~ - 35
- TABLE 4.1 :: value operators =IMPORTANT=

- TABLE 4.2 :: object operators =IMPORTANT=

- TABLE 4.3 :: type operators =IMPORTANT=

- Rule 4.2.1 #1 :: Unsigned arithmetic is always well defined. =TODO ???=

- Rule 4.2.1 #2 :: Operations +, - and * on size_t provide the
                  mathematically correct result if it is representable as a
                  ~size_t~.

**** 4.2.2. Division and remainder - 36
- ~/~ and ~%~.

- Takeaway 4.2.2 #1 :: For unsigned values, ~a == (a/b)*b + (a%b)~.

- Takeaway 4.2.2 #2 :: Unsigned ~/~ and ~%~ are well defined only if the second
                       operand is not =0=.

- Takeaway 4.2.2 #3 :: Arithmetic on ~size_t~ implicitly computes modulo
                       ~SIZE_MAX +1~.

- Takeaway 4.2.2 #4 :: In the case of overflow, unsigned arithmetic wraps around.

- Takeaway 4.2.2 #5 :: The result of unsigned ~/~ and ~%~ is always smaller than
                       the operands.

- Takeaway 4.2.2 #6 :: Unsigned ~/~ and ~%~ can't overflow.

*** 4.3. Operators that modify objects - 37
- Takeaway 4.3 #1 :: Operators must have all their characters directly attached
                     to each other.

- Takeaway 4.3 #2 :: Side effects in value expressions are evil.

- Takeaway 4.3 #3 :: Never modify more than one object in a statement.

- /postfix increment/ and /postfix decrement/.

- Sciene You will nicely obey to _Rule 1.4.2.2_, you will not be tempted to
  use them.

*** 4.4. Boolean context - 38
- Two categories:
  1. comparisons
  2. logical evaluation

**** 4.4.1. Comparison - 38
- Rule 4.4.1 #1 :: Comparison operators return the values ~false~ or ~true~.

**** 4.4.2. Logic - 39
- Rule 4.4.2 #1 :: Logic operators return the values ~false~ or ~true~.

- Page =26= _NEW_Standard.

*** 4.5. The ternary or conditional operator - 40
- =complex.h= is indirectly included by =tgmath.h=.

- ~__STDC_NO_COMPLEX__~

- ~#error~

*** 4.6. Evaluation order - 40
- Rule 4.6 #1 :: &&, ||, ?: and , evaluate their first operand first.

- Rule 4.6 #2 :: Don't use the , operator.
                 _Remark_: ~A[i, j]~ is not a two dimension index for
                           matrix ~A~, but results just in ~A[j]~.

- Rule 4.6 #3 :: Most operators don't sequence their operands.
                 Other operators, excepts ~&&~, ~||~, ~?:~ and ~,~ don't
                 have an evaluation restriction.
                 _Remark_: That chosen order can depend on your compiler, on
                           the particular version of that compiler, on
                           compile time options or just on the code that
                           surrounds the expression. Don’t rely on any such
                           particular sequencing.
                           i.e.,
                           ~f(a) + g(b)~, if ~f(a)~ has side effects that
                           can change ~g(b)~, or vice versa, this is a
                           _potential bug_. =IMPORTANT=

- Rule 4.6 #4 :: Function calls don't sequence their argument expressions.

- Rule 4.6 #5 :: Functions calls within expressions should not have side effects.

*** Summary - 43

** TODO 5. Basic values and data - 44 - =RE-READ=
- Takeaway 5 #1 :: C programs primarily reason about values and not about their
                   representation.

*** 5.1. The abstract state machine - 44
**** 5.1.1. Values - 46
- Takeaway 5.1.1 #1 :: All values are numbers or translate to such.

- The /state/ of the program execution is determined by: =IMPORTANT=
  * the executable
  * the current point of execution
  * the data
  * outside intervention such as IO from the user. 

- (_Different from the original text, changed by Jian_):
  We usually don't satisfy the points above, and we want get rid of the
  first point "the executable", which is platform specific.
    _From Jian_: The last point is also platform specific, but if we can
  ignore the IO action details, it can be considered as platform
  independent.

**** 5.1.2. Types - 46
- A /type/ is an additional property that C associates with values.

- Takeaway 5.1.2 #1 :: All values have a type that is statically determined.

- Takeaway 5.1.2 #2 :: Possible operations on a value are determined by its type.

- Takeaway 5.1.2 #3 :: A value's type determines the results of all operations.

**** 5.1.3. Binary representation and the abstract state machine - 47
- Since there are things that can't be specified by C standard,
  C can't impose the results of the operations on a given type completely.
  e.g.
  * /sign representation/: how does the sign or signed type is represented.
  * /floating point representation/: this usually follows the IEEE standard.

- C only imposes as much properties on all representations, such that the
  _results of operations can be deduced a priori from two different sources_:
  * the values of the operands
  * some characteristic values that describe the particular platform.
  e.g.
  the operations on the type ~size_t~ can be entirely determined when ins-
  pecting the value of ~SIZE_MAX~ in addition to the operands.

- We call the model to represent values of a given type _on a given
  platform_ the /binary representation/ _of the type_.

- Takeaway 5.1.3 #1 :: A type's binary representation determines the results of
                   all operations.

- Generally, all information that we need to determine that model are in
  reach of any C program, the C library headers provide the necessary infor-
  mation through named values (such as ~SIZE_MAX~), operators and function
  calls.

- Takeaway 5.1.3 #2 :: A type's binary representation is observable.

- /object representation/ =TODO= Section 12.1

- The program text describes an /abstract state machine/ that regulates how
  the program switches from one state to the next.
    These transitions are determined _only_ by
  * value,
  * type, and
  * binary representation

- Takeaway 5.1.3 #3 (as-if) :: Programs execute as if following the abstract
                               state machine.

**** 5.1.4. Optimization - 47
- =IMPORTANT= How a concrete executable achieves this goal is left to the
  discretion of the compiler creators.
    Most modern C compilers produce code that
  * doesn’t follow the exact code prescription,
  * they cheat (for efficiency) wherever they can and
  * _only respect the observable states of the abstract state machine_.

- But such an optimization can also be forbidden because the compiler can't
  prove that a certain operation will not force a program termination.
  e.g.
  _unsigend integer_ overflow usually won't raise an exception, but
  _signed integer_ overflow may raise an exception.

- Takeaway 5.1.4 #1 :: Type determines optimization opportunities. =IMPORTANT=

*** 5.2. Basic types - 48
- _first level of specification_: it is entirely done with _keywords_ of
  the language, such as ~signed~, ~int~ or ~double~.
    This first level is mainly _organized_ according to _C internals_.

- (On top of that first level) _second level of specification_: it comes
  through header files and for which we already have seen examples, too,
  namely ~size_t~ or ~bool~.
    This second level is _organized_ by _type semantic_, that is by
  specifying what properties a particular type brings to the programmer.

- As a principal distinction we have _two different classes_ of numbers, with
  _two subclasses_, each, namely
  1. unsigned integers,
  2. signed integers
  3. real floating point numbers and
  4. complex floating point numbers

  They differ according to their precision, which determines the valid range
  of values that are allowed for a particular type.

- /narrow types/ can't be directly used for arithmetic.

- Takeaway 5.2 #1 :: Before arithmetic, narrow integers are prompted to
                     ~signed int~.

- Takeaway 5.2 #2 :: Each of the four classes of base types has 3 distinct
                     unpromoted types.

- Table 6. an overview of the 18 base types.

- =IMPORTANT= Remember that _unsigned types_ are the most convenient types,
  since they are the _only types_ that
  1. They have an arithmetic that is defined consistently with mathematical
     properties, namely modulo operation.
  2. They can't raise signals on overflow and
  3. They can be optimized best.
  TODO They are described in more detail in Section 5.5.1. =IMPORTANT=

- Takeaway 5.2 #3 :: Use ~size_t~ for
  1. _sizes_,
  2. _cardinalities_ or
  3. _ordinal numbers_.

- Takeaway 5.2 #4 :: Use ~unsigned~ for small quantities that can't be negative.

- Takeaway 5.2 #5 :: Use ~signed~ for small quantities that bear a sign.

- Takeaway 5.2 #6 :: Use ~ptrdiff_t~ for large differences that bear a sign. =TODO ??????=

- Takeaway 5.2 #7 :: Use ~double~ for floating-point calculations.

- Takeaway 5.2 #8 :: Use ~double complex~ for complex calculations.

- Table 7. Some semantic arithmetic types for specialized use cases. =RE-READ=

- PAGE 34 =RE-READ=

*** 5.3. Specifying values - 51
- /literals/:
  * =123= - /decimal integer constant/.
  * =077= - /octal integer constant/. This type of specification has merely
    historical value and is rarely used nowadays.
  * =0xFFFF= - /hexadecimal integer constant/.
  * =1.7E-13= - /decimal floating point constant/
  * =0x1.7aP-13= - /hexadecimal floating point constant/.
    Usually used to describe floating point values in a form that will
    ease to _specify values that have exact representations_.
      Use this representation is because map from hex to bin is easy and no
    precision lost, and hex representation is much shorter.
  * 'a' - /integer character constant/.
  * "hello" - /string literal/.

  All but the last are numerical constants.

- Takeaway 5.3 #1 :: Consecutive string literals are concatenated.

- =EXPLANATION=: That is if we write something like =-34= or =-1.5E-23=,
  _the leading sign is not considered part of the number but is the negation
  operator applied to the number that comes after_.
    =TODO= We will see below where this is important. =IMPORTANT=
    Bizarre as this may sound, the minus sign in the exponent is considered
    to be part of a floating point literal. =TODO ???=

- Takeaway 5.3 #2 :: Numerical literals are never negative.

- Takeaway 5.3 #3 :: Decimal integer literals are signed.

- Takeaway 5.3 #4 :: A decimal integer literal has the first of the three signed
                     types that fits.

- =EXPLANATION=: This rule can have surprising effects. Suppose that on a
  platform the minimal signed value is −2^15 = −32768 and the maximum value
  is 2^15 − 1 = 32767. The constant 32768 then doesn't fit into signed and is
  thus signed long. As a consequence the expression -32768 has type signed
  long. Thus the minimal value of the type signed on such a platform cannot
  be written as a literal constant. =IMPORTANT=

- Takeaway 5.3 #5 :: The same value can have different types.

- Takeaway 5.3 #6 :: Don't use binary, octal, or hexadecimal literals for
                     negative values.

- Takeaway 5.3 #7 :: Use decimal literal for negative values.

- Integer constants can be forced to be _unsigned_ or to be of
  _a type of minimal width_.
  This done by appending =U=, =L= or =LL= to the literal.
  e.g.
  * ~1U~ has value 1 and type ~unsigned~,
  * ~1L~ is ~signed long~, and
  * ~1ULL~ has the same value but type ~unsigned long long~.

- =TIPs= Show that the expressions ~-1U~, ~-1UL~ and ~-1ULL~ have the maximum
  values and type of the three usable unsigned types, respectively.
  =IMPORTANT=

- Table 8 =RE-READ=

- _A common error_ is to try to assign a hexadecimal constant to a _signed_
  under the expectation that it will represent a negative value. =IMPORTANT=

- Takeaway 5.3 #8 :: Different literals can have the same value.
                     =COMMENT=: This is obvious for integers, but this is not
                     obvious for floating point numbers.
                     However, this is important for floating point numbers.
                     =IMPORTANT=

- Takeaway 5.3 #9 :: The effective value of a decimal floating-point constant
                     may be different from its literal value.

- floating point constants can be followed by the letters ~f~ or ~F~ to
  denote a ~float~
  or
  by ~l~ or ~L~ to denote a ~long double~.
  Otherwise
  they are of type ~double~.

- Takeaway 5.3 #10 :: Literals have value, type, and binary representation.

**** 5.2.1 Complex constants - 61
     - Complex types are _not necessarily supported_ by all C platforms.
       The fact can be checked by inspecting ~__STDC_NO_COMPLEX__~.

     - To have full support of complex types, use ~#include <complex.h>~.
       If you use ~#include <tgmath.h>~ for mathematical functions, =complex.h=
       this is already done implicitly.

     - Rule 1.5.4.12 :: ~I~ (macro) is reserved for the imaginary unit.
                        =COMMENT=: leave ~I~ alone, don't use it as the name of
                                   an identifier you create.

     - Two form:
       1. ~0.5 + 0.5*I~ is of type ~double complex~, and ~0.5F + 0.5F*I~ is of
          type ~float complex~.
       2. ~CMPLX(0.5, 0.5)~ is the same ~double complex~ value as above.
          ~CMPLXF(0.5F, 0.5F)~ is the same ~float complex~ value as above.
            =COMMENT=: This usage is what Jian guesses, no example in the book.
            =TODO= read the ~complex.h~ later.

     - TABLE 9. Bounds for scalar types used in this book =TODO RE-READ=

*** 5.4. Implicit conversions - 55
- Takeaway 5.4 #1 :: Unary ~-~ and ~+~ have the type of their promoted operand.

- Takeaway 5.4 #2 :: Avoid narrowing conversions.

- Takeaway 5.4 #3 :: Don't use narrow types in arithmetic.

- Takeaway 5.4 #4 :: Avoid operations with operands of different signedness.

- Takeaway 5.4 #5 :: Use unsigned types whenever you can.

- Takeaway 5.4 #6 :: Chose your arithmetic types such that implicit conversions
                     are harmless.
*** 5.5. Initializers - 57
- Takeaway 5.5 #1 :: All variables should be initialized.

- =TODO= VLA, see Section 6.1.3, that don’t allow for an initializer, or code
  that must be highly optimized.

- =TODO ???= For most code that we are able to write so far, a modern compi-
  ler will be able to trace the origin of a value to the last assignment or
  the initialization. Superfluous assignments will simply be optimized out.

- Scalar initializer expression may be surrounded with an _optional_ ~{}~.
  Initializers for other types _must_ have these ~{}~.
  #+BEGIN_SRC C
  # scalars
  double a = 7.8;
  double b = 2 * a;
  double c = { 7.8 };
  double d = { 0 };

  # vectors
  double A[] = { 7.8, };
  double B[3] = { 2 * A[0], 7, 33, };
  double C[] = { [0] = 7.8, [7] = 0, };
  #+END_SRC
  Designated initializers as for =C= above are by far preferable,
  since they make the code more robust against small changes in declaration.

- /incomplete type/: it is completed by the initializer to fully specify the
  length.

- Takeaway 5.5 #2 :: Use designated initializers for all aggregate data types.

- Takeaway 5.5 #3 :: ~{ }~ is a valid initializer for all objects.

- There are several things, that ensure that this works.
  * First,
    + _if_ we omit the designation (the =.fieldname= for ~struct~, see
      Section 6.3 or ~[n]~ for arrays, see Section 6.1)
      1. initialization is just done in /declaration order/, that is the =0=
         in the default initializer designates the very first field that is
         declared, and
      2. all other fields then are initialized per default to =0= as well.

  * Then, the ~{}~ form of initializers for scalars ensures that ~{ 0 }~ is
    also valid for these.

  =IMPORTANT= (gcc, g++, clang, and clang++ work well with this feature)
  Maybe your compiler warns you about this: annoyingly some compiler
  implementers don't know about this special rule. It is explicitly designed
  as catch-all initializer in the C standard, so this is one of the rare
  cases where I would switch off a compiler warning.

*** 5.6. Named constants - 58
- Takeaway 5.6 #1 :: All constants with particular meaning must be named.

- Takeaway 5.6 #2 :: All constants with different meaning must be distinguished.

**** 5.6.1. Read-only objects - 59
- Takeaway 5.6.1 #1 :: An object of ~const~-qualified type is read-only.

  =COMMENT=: That DOESN'T MEAN that the compiler or run-time system may not
  perhaps change the value of such an object: other parts of the program
  may see that object without the qualification and change it. =IMPORTANT=
  e.g.
  The fact that you cannot write the summary of your bank account directly
  (but only read it), doesn't mean that it will remain constant over time.

- Takeaway 5.6.1 #2 :: String literals are read-only.

  There is another family of read-only objects, that _unfortunately_ are
  _not protected_ by their type from being modified: /string literals/.

  =Rationale=: If introduced today, the type of string literals would
  certainly be ~char const[]~, an array of const-qualified characters.
  Unfortunately, the const keyword had only been introduced much later than
  string literals to the C language, and therefore remained as it is for
  backward compatibility.

**** 5.6.2. Enumerations - 67 =RE-READ DO NOT QUITE UNDERSTAND=
- Takeaway 5.6.2 #1 :: Enumeration constants have either
  1. an explicit
     or
  2. positional value.

- Takeaway 5.6.2 #2 :: If all enumeration constants of a simple enumeration type
                       fit into ~signed int~, they have that type.

- Takeaway 5.6.2 #3 :: An integer constant expression must only evaluate objects
                       that are declared with ~constexpr~.

- /integer constant expression/: abbreviated as /ICE/. =TODO: explanation=

- Still, even when the value is an /ICE/ to be able to use it to define an
  enumeration constant you'd have to ensure that the value fits into a
  ~signed~.

- Takeaway 5.6.2 #4 :: If enumeration constants do not fit into ~signed int~, if
                       possible, the enumeration type is adjusted such that it
                       can store all enumeration constants.

- Takeaway 5.6.2 #5 :: If enumeration constants do not fit into ~signed int~, the
                       constants have the enumeration type.

- Takeaway 5.6.2 #6 :: If the enumeration constants potentially do not all fit
                       into  ~signed int~, specify the underlying integer type of
                       an enumeration type.

**** 5.6.3. Macros - 63
- example: ~# define M_PI 3.14159265358979323846~. This macro definition
  consists of 5 different parts:
  1. A starting ~#~ character that _must be_ the first non-blank character
     on the line.
  2. The keyword ~define~.
  3. An identifier that is to be declared, here ~M_PI~.
  4. The replacement text, here =3.14159265358979323846=.
  5. A terminating newline character.

- In this book such C standard macros are all printed in _dark red_.

- Takeaway 5.6.3 #1 :: Macro names are in all caps.
  =COMMENT=: This is a =CONVETIONS=, and it is applicable for most cases,
  though not all.

**** 5.6.4. Compound literals - 63 =RE-READ=
- For types that don't have literals that describe their constants, things
  get even a bit more complicated.
    We have to use /compound literals/ on the replacement side of the macro.
  Such a /compound literal/ has the form =(T) { INIT }= (a type, in
  parenthesis, followed by an initializer).
  e.g.
  #+BEGIN_SRC C
  # define CORVID_NAME /**/        \
  (char const*const[corvid_num]){  \
    [chough] = "chough",           \
    [raven] = "raven",             \
    [magpie] = "magpie",           \
    [jay] = "jay",                 \
  }
  // With that we could leave out the "animal" array from above and rewrite
  // our for-loop:

  for (unsigned i = 0; i < corvid_num; ++i) {
    printf("Corvid %u is the %s\n", i, CORVID_NAME[i]); 
  }
  #+END_SRC

- Rule 5.6.4 #1 :: A compound literal defines an object.

- Over all, _this form of macro_ has some _PITFALLS_ =MOST IMPORTANT=:
  * Compound literals aren't suitable for ICE.

  * For our purpose here to declare "named constants" the type T should be
    constqualified C. This ensures that the optimizer has a bit more slack-
    ness to generate good binary code for such a macro replacement.

  * There must be space between the macro name and the ~()~ of the compound
    literal, here indicated by the ~/**/~ comment. Otherwise this would be
    interpreted as the start of a definition of a function-like macro.
    We will see these much later.

  * A backspace character ~\~ at the very end of the line can be used to
    _continue the macro_ definition to the next line.

  * There _must be no_ ~;~ at the end of the macro definition. Remember it
    is all just text replacement.

- Takeaway 5.6.4 #2 :: Don't hide a terminating semicolon inside a macro.

- Takeaway 5.6.4 #3 :: Right-indent continuation markers for macros to the same
                       column.
                       =COMMENT=: As you can see above this helps to visualize
                       the whole spread of the macro definition easily.

*** 5.7. Binary representions - 65 - =RE-READ=
- Takeaway 5.7 #1 :: The same value may have different binary representations.

**** 5.7.1. Unsigned integers - 65
- ~UINT_MAX~, ~ULONG_MAX~ and ~ULLONG_MAX~ are provided through =limits.h=.

- ~SIZE_MAX~ for ~size_t~ is from =stdint.h=.

- \sum (b_i * 2^i) from i=0 to p-1. Here b_0, ..., b_{p-1} are called
  /bits/. Here p is /precision/.

- /LSB/: Of the bits b_i that are 1 the one with minimal index i is called the
  /least significant bit/.

- /MSB/: the one with the highest index is the /most significant bit/.

- Takeaway 5.7.1 #1 :: The maximum value of any integer type is of the form 2^p − 1.

- Takeaway 5.7.1 #2 :: Arithmetic on an ~unsigned~ integer type is determined by
                       its precision.

**** 5.7.2. Bit sets and bitwise operators - 66
- ~|~, ~&~, and ~^~.

- All these operator can be written with identifiers, namely ~bitor~,
  ~bitand~, ~xor~, ~or_eq~, ~and_eq~, ~xor_eq~, and ~compl~ if you include
  header =iso646.h=.

- A typical usage of bit sets is for "flags", variables that control certain
  settings of a program. E.g. =IMPORTANT=
  #+BEGIN_SRC c
  enum corvid { magpie, raven, jay, chough, corvid_num, };
  #define FLOCK_MAGPIE 1U
  #define FLOCK_RAVEN 2U
  #define FLOCK_JAY 4U
  #define FLOCK_CHOUGH 8U
  #define FLOCK_EMPTY 0U
  #define FLOCK_FULL 15U

  int main(void) {
    unsigned flock = FLOCK_EMPTY;
    // ...
    if (something) { flock |= FLOCK_JAY; } 
    // ...
    if (flock & FLOCK_CHOUGH) {
      do_something_chough_specific(flock);
    }
  #+END_SRC

**** 5.7.3. Shift operators - 68
- Takeaway 5.7.3 #1 :: The second operand of a shift operation must be less than
                       the precision.

**** 5.7.4. Boolean values - 68
- Treating ~bool~ as an _unsigned type_ is a certain stretch of the concept.

- Assignment to a variable of that type doesn’t follow the
  Modulus Rule 1.4.1.5, but a the special Rule 1.3.1.1.

**** 5.7.5. Signed integers - 69
- The complexity of _signed types_ are more complicated than
  _unsigned types_, because a C implementation has to decide on two points:
  1. What happens on arithmetic overflow?
  2. How is the sign of a signed type represented?

- Takeaway 5.7.5 #1 :: Positive values are represented independently from
                       signedness.

- C allows three different /sign representations/:
  1. /sign and magnitude/ =only have historic or exotic relevance=
  2. /one's complement/ =only have historic or exotic relevance=
  3. /two's complement/ =in use=

- Where unsigned values are forced to wrap around,
  _the behavior of a signed overflow is undefined_.

- page 46: The as-if Rule 1.5.0.7 allows it to optimize the second loop
  to ...
  =From Jian= Never do optimization with undefined behavior!!!
  =IMPORTANT= [[http://www.yinwang.org/blog-cn/2016/10/12/compiler-bug][C 编译器优化过程中的 Bug]] and
              [[https://www.zhihu.com/question/51544127][如何评价《王垠：C 编译器优化过程中的 Bug》？]]

- Takeaway 5.7.5 #2 :: Once the abstract state machine reaches an
                       _undefined state_ no further assumption about the
                       continuation of the execution can be made.

- Takeaway 5.7.5 #3 :: It is your responsibility to avoid undefined behavior of
                       all operations.

- Takeaway 5.7.5 #4 :: If the program state reaches an operation with undefined
                       behavior, the execution has failed.

- Takeaway 5.7.5 #5 :: Signed arithmetic may trap badly.

- Takeaway 5.7.5 #6 :: ~INT_MIN < -INT_MAX~.

- Or stated otherwise, in _twos' complement representation_ the
  _positive value_ ~-INT_MIN~ is out of bounds since the value of the
  operation is larger than ~INT_MAX~.

- Takeaway 5.7.5 #7 :: Negation may overflow for signed arithmetic.

- Takeaway 5.7.5 #8 :: Use ~unsigned~ types for bit operations.

**** 5.7.6. Fixed-width integer types - 71
- Takeaway 5.7.6 #1 :: If the type ~uintN_t~ is provided, it is an unsigned
                       integer type with _EXACTLY N bits of width and precision_.

- Takeaway 5.7.6 #2 :: If the type ~intN_t~ is provided, it is signed and has a
                       width of exactly N bits and a precision of N - 1.

- _None of these types is guaranteed to exist, but_

- Takeaway 5.7.6 #3 :: If the types with the required properties exist for a
                       value N, ~intN_t~ and ~uintN_t~ must be provided.

- And in fact, nowadays platforms _usually_ provide:
  * uint8_t, uint16_t, uint32_t and uint64_t unsigned types and
  * int8_t, int16_t, int32_t and int64_t signed types.

- Their presence and bounds can be tested with _macros_:
  * UINT8_MAX, UINT16_MAX, UINT32_MAX and UINT64_MAX for unsigned types and
  * INT8_MIN, INT8_MAX, INT16_MIN, INT16_MAX,INT32_MIN, INT32_MAX, INT64_MIN and INT64_MAX,
    respectively.
  To encode literals of the requested type there are _macros_:
  * UINT8_C, UINT16_C, UINT32_C UINT64_C,
  * INT8_C, INT16_C, INT32_C and INT64_C, respectively.
  E.g on platforms where uint64_t is unsigned long, INT64_C(1) would expand to 1UL.
  =TODO=

- =inttypes.h= provides PRId64, PRIi64, PRIo64, PRIu64, PRIx64 and PRIX64,
  for printf formats "%d", "%i", "%o", "%u", "%x" and "%X", respectively:
  #+BEGIN_SRC C
  uint32_t n = 78;
  int64_t max = (-UINT64_C(1))>>1; // same value as INT64_MAX
  printf("n is %" PRIu32 ", and max is %" PRId64 "\n", n, max);
  #+END_SRC

- Takeaway 5.7.6 #4 :: For any of the fixed-width types that are provided, width
                       ~_WIDTH~, minimum ~_MIN~ (only signed), maximum ~_MAX~ and
                       literals ~_C~ macros are provided, too.

**** 5.7.7. Bit-precise integer types - 73
**** 5.7.8. Floating-point data - 74
- =float.h=: ~DBL_MIN~ and ~DBL_MAX~ that provides us with the _minimal_ and
  _maximal_ values for ~double~.
  =But beware=: here ~DBL_MIN~ is the smallest number that is strictly
                _greater then 0.0_;
                the _smallest negative_ ~double~ value is ~-DBL_MAX~.

- /floating number/: s * 2^e * (sum f_k * 2^(-k) from k=1 to p), where
  e_min <= e <= e_max. e_min and e_max are type dependent, the can be
  obtained through macros such as:
  ~DBL_MANT_DIG~ (for p, typically 53),
  ~DBL_MIN_EXP~ (e_min, -1021) and
  ~DBL_MAX_EXP~ (e_max, 1024).

- From that calculation we see also that floating point values are
  _always representable as a fraction that has some power of two in the
  denominator_.

- An important thing that we have to have in mind with such floating point
  representations is that values _can be cut off during intermediate
  computations_. =TODO examples=

- Rule 5.7.8 #1 :: Floating-point operations are _NEITHER_ associative,
                   commutative or distributive.

- Rule 5.7.8 #2 :: Never compare floating-point values for equality.
                   =IMPORTANT=

- For any =z= of one of the three complex types we ~#include <tgmath.h>~
  have that ~z == creal(z)+ cimag(z)*I~

*** Summary - 76

** DONE 6. Derived data types - 77
CLOSED: [2017-04-25 Tue 16:11]
=50 ~ 61=
- All other data types in C are derived from the basic types that we know now.
  There are _four_ different strategies for combining types:
  * arrays :: These combine items that all have _the same base type_.
  * pointers :: Entities that refer to an object in memory. =TODO in section 11=
  * structures :: These combine items that _may have different base types_.
  * unions :: These overlay items of different base types in the same memory
              location. =TODO section 12.2=

- /aggregate data types/

*** 6.1. Arrays - 77
- Takeaway 6.1 #1 :: Arrays are not pointers.

**** 6.1.1. Array declaration - 77
- /multidimensional array/:
  #+BEGIN_SRC C
  // For those, declarations become a bit more difficult to read since []
  // binds to the left. The following two declarations declare variables of
  // exactly the same type:
  double C[M][N];
  double (D[M])[N];
  #+END_SRC

**** 6.1.2. Array operations - 78
- Takeaway 6.1.2 #1 :: An array in a condition evaluates to ~true~.

- Takeaway 6.1.2 #2 :: There are array objects but no array values.

- =COMMENT=: So arrays can't be operands for _value operators_ in Table 2,
  there is _no_ arithmetic declared on arrays (themselves) and also

- Takeaway 6.1.2 #3 :: Arrays can't be compared.

- =COMMENT=: Arrays also can't be on the value side of object operators in
  Table 3.

- Takeaway 6.1.2 #4 :: Arrays can't be assigned to.

**** 6.1.3. Array length - 79
- There are two different categories of arrays:
  1. /fixed length arrays (FLA)/: exist from the very beginning of C.
  2. /variable length arrays (VLA)/: introduced in C99 and is relatively
     unique to C, and has some restrictions to its usage.

- Takeaway 6.1.3 #1 :: VLA can't have initializers.

- Takeaway 6.1.3 #2 :: VLA can't be declared outside functions.

- Takeaway 6.1.3 #3 :: The length of an FLA is determined:
  1. by an integer constant expression or
  2. by an initializer.

- There is _no type restriction_ for the ICE of array length, any integer
  type would do.

- Takeaway 6.1.3 #4 :: An array-length specification must be strictly positive.

- Takeaway 6.1.3 #5 :: If the length is not an integer constant expression, an
                       array is a VLA.

- Takeaway 6.1.3 #6 :: The length of an array A is ~(sizeof A) / (sizeof A[0])~.
                       =REMARK=: A must be an array, not a pointer to the array.
                                 Again, Arrays are not pointers (Rule 1.6.1.1)!!!

**** 6.1.4. Arrays as parameters - 80
- Takeaway 6.1.4 #1 :: The innermost dimension of an array parameter to a
                       function is lost.

- Takeaway 6.1.4 #2 :: Don't use the ~sizeof~ operator on array parameters to
                       functions.

- Takeaway 6.1.4 #3 :: Array parameters behave as if the array is /passed by
                       reference/.

**** 6.1.5. Strings are special - 80
- Takeaway 6.1.5 #1 :: A string is a 0-terminated array of ~char~.

- As all arrays, _strings_ can't be assigned to, but they can be initialized
  from _string literals_:
  #+BEGIN_SRC C
  char chough0[] = "chough";
  char chough1[] = {"chough"};
  char chough2[] = {'c', 'h', 'o', 'u', 'g', 'h', 0, };
  char chough3[7] = {'c', 'h', 'o', 'u', 'g', 'h', };
  #+END_SRC
  These are all equivalent declarations.

- _Beware_ that _not_ all arrays of char are strings, such as
  #+BEGIN_SRC C
  char chough4[6] = { 'c', 'h', 'o', 'u', 'g', 'h', };
  #+END_SRC
  because it is _not 0-terminated_.

- It seems both ~char chough2[] = {'c', 'h', 'o', 'u', 'g', 'h', }~ and
  ~char chough2[] = {'c', 'h', 'o', 'u', 'g', 'h'}~ work well.
  =FROM JIAN= Is this SPECIAL???

- Those that just suppose an array start their ~#include <string.h>~ names
  with =mem= and those that in addition suppose that their arguments are
  strings start with =str=:
  1. Functions that operate on ~char~-array: =TODO: try!!!=
     * ~memcpy(target, source, len)~
     * ~memcmp(s0, s1, len)~ 
     * ~memchr(s, c, len)~

  2. String functions: =TODO: try!!!=
     * ~strlen(s)~
     * ~strcpy(target, source)~
     * ~strcmp(s0, s1)~
     * ~strcoll(s0, s1)~
     * ~strchr(s, c)~
     * ~strspn(s0, s1)~
     * ~strcspn(s0, s1)~

- Takeaway 6.1.5 #2 :: Using a string function with a non-string leads to program
                       failure.

- In real life, common symptoms for such a misuse may be: =page 54=

- C11 introduces functions with bounds checking: ~strnlen_s~ and ~strcpy_s~.

*** 6.2. Pointers as opaque types - 84
- The binary representation of pointer is completely up to the platform.

- Takeaway 6.2 #1 :: Pointers are opaque objects.
                     =Remark=: _opaque_ here means that we will only be able to
                     deal with pointers through the operations that the C
                     language allows for them. =IMPORTANT=

- Takeaway 6.2 #2 :: Pointers are _valid_, _null_ or _invalid_.
                     =Remark=: the _null state_ of any pointer type
                     _corresponds to_ 0, sometimes known under its
                     _pseudo_ ~false~.

- Takeaway 6.2 #3 :: Initialization or assignment with ~nullptr~ makes a pointer
                     null.

- Takeaway 6.2 #4 :: In logical expressions, pointers evaluate to ~false~ if
                     they are null.
                     =Remark=: Note that such test _can't_ distinguish valid
                               pointers from indeterminate ones.
                               =IMPORTANT= So, the really "bad" state of a
                               pointer is "indeterminate", since this state is
                               _not observable_.

- Takeaway 6.2 #5 :: Invalid pointers lead to program failure.
                     =Remark=: make sure that pointers _never_ reach an
                               intermediate state.
                                 Thus, if we can't ensure that a pointer is
                               valid, we must at least ensure that it is set to
                               null.

- Takeaway 6.2 #6 :: Always initialize pointers.

*** 6.3. Structures - 85
- The _order_ or position of the fields in the structure is usually _NOT_
  important.

**** 6.3.1. Simple structures to access fields by name - 85
- Takeaway 6.3.1 #1 :: Omitted ~struct~ initializers force the corresponding
                       field to ~0~.

- Takeaway 6.3.1 #2 :: ~struct~ parameters are passed by value.

- Takeaway 6.3.1 #2 :: ~struct~ initializer must initialize at least one field.

- Takeaway 6.3.1 #3 :: Structures can be assigned.

- Takeaway 6.3.1 #4 :: Structures can not be compared with ~==~ or ~!=~.

- Here we see that the assignment operator "=" is _well defined_ for all
  structure types.
  Unfortunately, its counterparts for comparisons _are not_.

- Takeaway 6.3.1 #5 :: A structure layout is an important design decision.

- =COMMENT=: You may regret your design after some years, when all the exist-
  ing code that uses it makes it almost impossible to adapt it to new
  situations.

- Any data type besides VLA is allowed as a field in a structure.

**** 6.3.2. Structures with fields of different types - 88
**** 6.3.3. Nested structures - 88
- Takeaway 6.3.3 #1 :: All ~struct~ declarations in a nested declaration have the
                       same scope of visibility.

**** 6.3.4. Coalescing structure fields - 90
- Takeaway 6.3.4 #1 :: There can be padding after any structure member.

- Takeaway 6.3.4 #2 :: There is no padding at the beginning of a structure.

- Takeaway 6.3.4 #3 :: Do not use bare ~int~ for the specification of a
                       bit-field.

- Takeaway 6.3.4 #4 :: Use a ~_BitInt(N)~ type for a numerical bit-field of width ~N~.

- Takeaway 6.3.4 #5 :: Use ~bool~ as type of a flag bit-field of width 1.

*** 6.4. New names for types: type aliases - 92
- a structure
  1. not only _introduces a way to aggregate differing information into one
     unit_,
  2. it also _introduces a new type name_.

- _For historical reasons (again!)_ the name that we introduce for the
  structure always has to be preceded by the keyword ~struct~, which makes
  the use of it a bit clumsy.

- Example:
  #+BEGIN_SRC c
  typedef struct animalStruct animalStructure;
  typedef struct animalStruct animalStruct;
  #+END_SRC

- /forward declaration/ of the structure: That is to precede the proper
  ~struct~ declaration by a ~typedef~ using exactly the same name. This works
  because the combination of ~struct~ with a following name, the /tag/ is
  always valid.
  Example:
  #+BEGIN_SRC c
  typedef struct animalStruct animalStruct;
  struct animalStruct {
    // ...
  }
  #+END_SRC

- Takeaway 6.4 #1 :: Forward-declare a ~struct~ within a ~typedef~ using the same
                     identifier as the /tag name/.

                     =COMMENT=: C++ follows a similar approach by default, so
                     this strategy will make your code easier to read for people
                     coming from there.

- The ~typedef~ mechanism can also be used for other types than structures.

- The C standard also uses ~typedef~ a lot internally, for example: ~size_t~.
  Here the standard often uses names that terminate with =_t= for ~typedef~.

- Takeaway 6.4 #2 :: A ~typeof~ only creates an alias for a type but never a new
                     type.

- Takeaway 6.4 #3 :: Identifier names terminating with =_t= are _reserved_.

*** Summary - 94

** DONE 7. Functions - 95
CLOSED: [2017-04-25 Tue 16:11]
- Motivation: /modularity/ =IMPORTANT=
  * Avoid code repetition
    + Avoid copy and paste errors.
    + Increase readability and maintainability.
    + Decrease compilation times.
  * Provide clear interfaces
    + Specify the origin and type of data that flows into a computation.
    + Specify the type and value of the result of a computation.
    + Specify invariants for a computation, namely pre- and post-conditions
  * Dispose a natural way to formulate algorithms that use a "stack" of
    itermediate values.

- Besides the concept of functions,
  C has _other means of unconditional transfer of control_, that are mostly
  used to
  _handle error conditions_ or _other forms of exceptions from the usual
  control flow_
  * ~exit~, ~_Exit~, ~quick_exit~ and ~abort~ terminate the program execution
    TODO See Section 8.6
  * ~goto~ transfers control within a function body
    TODO See Section 13.2.2 and 15
  * ~setjmp~ and ~longjmp~ can be used to return unconditionally to a calling
    context,
    TODO see Section 18.4.
  * Certain events of the execution environment or calls to the function raise
    may raise so-called signals and that pass control to a specialized
    function, a /signal handler/.
    TODO ???

*** 7.1. Simple functions - 95
- /prototype/: _declaration_ and _definition_ included:
  * a parameter type-list and
  * a return type.

- There are _two_ special conventions that use the keyword ~void~:
  * If the function is to be _called with no parameter_, the list is replaced
    by the keyword ~void~.
  * If the function _doesn't return a value_, the return type is given as
    ~void~.

- Such a /prototype/ _helps the compiler in places where the function is to
  be called_. It _only has to know about the parameters that the function
  expects_. For example:
  #+BEGIN_SRC C
  extern double fbar(double x);
  // ... ...
  double fbar2 = fbar(2) / 2;
  #+END_SRC
  Here the call ~fbar(2)~ is not directly compatible with the expectation of
  function fbar: it wants a ~double~ but receives a ~signed int~. But since
  the calling code knows this, it can convert the ~signed int~ argument =2=
  to the ~double~ value =2.0= before calling the function. The same holds
  for the return: the caller knows that the return is a ~double~, so floating
  point division is applied for the result expression. =IMPORTANT=

- In C, _there are ways to declare functions without prototype_,
  but you will not see them here. You _shouldn't use_ them, they should be
  retired. There were even ways in previous versions of C that allowed to
  use functions without any knowledge about them at all. Don’t even think of
  using functions that way. =TODO=

- Takeaway 7.1 #1 :: All functions must have prototypes.

- Exception: functions that can receive a varying number of parameters.
             ~<stdargs.h>~, /variable argument list/ =TODO= 17.4.2
  Try to avoid using this in any case.

- Takeaway 7.1 #2 :: Functions have only one entry but can have several
                     ~return~'s.

- For a function that expects a return value, all return statements must
  contain an expression;
  functions that expect none, mustn't contain expressions.

- Takeaway 7.1 #3 :: A function ~return~ must be consistent with its type.

- If the type of the function is ~void~ the ~return~ (without expression) can
  even be omitted.

- Takeaway 7.1 #4 :: Reaching the end of the body of a function is equivalent to
                     a ~return~ statement without an expression.
  _THIS IMPLIES_

- Takeaway 7.1 #5 :: Reaching the end of the body of a function is only allowed
                     for ~void~ functions.

*** 7.2. ~main~ is special - 97
- The prototype of ~main~ function is enforced by the C standard,
  but it is implemented by the programmer.

- Being such a pivot between the runtime system and the application, it has
  to obey some special rules:
  1. First, to suit different needs it has several prototypes, one of which
     must be implemented. _Two_ should always be possible:
     #+BEGIN_SRC C
     int main(void);
     #+END_SRC

     #+BEGIN_SRC C
     int main(int argc, char* argv[argc+1]);
     // int main(int argc, char* argv[]);
     #+END_SRC

  2. There is another feature in the second prototype of ~main~, namely
     ~argv~, the vector of commandline arguments. We already have seen
     some examples where we used this vector to communicated some values
     from the commandline to the program. E.g. in Listing 1.1 these
     commandline arguments were interpreted as double data for the program.

- Then, any specific C platform may provide other interfaces. There are _two_
  variations that are relatively common:
  * On some embedded platforms where ~main~ is not expected to return to the
    runtime system the return type may be ~void~.
  * On many platforms a _third parameter_ can give access to the
    "environment".

- Takeaway 7.2 #1 :: Use ~EXIT_SUCCESS~ or ~EXIT_FAILURE~ as return values of
                     ~main~.

- Takeaway 7.2 #2 :: Reaching the end of the body of ~main~ if equivalent to a
                     ~return~ with ~EXIT_SUCCESS~.

- The library function ~exit~ holds a special relationship with ~main~.
  As the name indicates, a call to exit terminates the program; the prototype
  is
  #+BEGIN_SRC c
    [[noreturn]] void exit(int status);
  #+END_SRC
  In fact, this functions terminates the program exactly as a ~return~ from
  ~main~ would. The parameter =status= has the role that the
  _return expression_ in ~main~ would have.

- Takeaway 7.2 #3 :: Calling ~exit(s)~ is equivalent to the evaluation of
                     ~return s~ in ~main~.

- Takeaway 7.2 #4 :: ~exit~ _NEVER fails_ and _NEVER returns to its caller_.

- The later is indicated by the special keyword ~_Noreturn~. This keyword
  should _only be used for such special functions_. There is even a pretty
  printed version of it, the macro ~noreturn~, that comes with the header
  ~stdnoreturn.h~.

- Strictly spoken, _each of the ~argv[i]~ for i = 0, ..., ~argc~ is a
  pointer_, but since we don't know yet what that is (_didn't teach_), as an
  easy first approximation we can see them as strings.

- Takeaway 7.2 #5 :: All command-line arguments are transferred as strings.

- Takeaway 7.2 #6 :: ~argv[0]~ points to the name of the program invocation.
                     =REMARK=: There is no strict rule of what that
                               "program name" should be, but usually this is
                               just taken as the name of the program executable.
                               =IMPORTANT= NO rule in C standard.

- Takeaway 7.2 #7 :: ~argv[argc]~ is a null pointer.
                     =TODO=: usage??? only used to identify the end? We have
                             ~argc~ already!!! Historical reason???

*** 7.3. Recursion - 99 - =RE-READ=
- Takeaway 7.3 #1 :: Make all preconditions for a function explicit.

- Takeaway 7.3 #2 :: In a recursive function, first check the termination
                     condition.

- Takeaway 7.3 #3 :: Ensure the preconditions of a recursive function in a
                     wrapper function.
  #+BEGIN_SRC C
  #+END_SRC

- This avoids that the precondition has to be checked at each recursive
  call: the ~assert~ macro is such that it can be disabled in the final
  "production" object file.
  #+BEGIN_SRC C
  // Just a example. (From Jian) The implimantation is not good though.
  size_t gcd2(size_t a, size_t b) {
    assert (a <= b);
    if (!a) return b;
    size_t rem = b % a;
    return gcd2(rem, a);
  }

  size_t gcd(size_t a, size_t b) {
    assert (a);
    assert (b);
    if(a < b) return gcd2(a, b);
    else      return gcd2(b, a);
  }
  #+END_SRC
  This avoids that the precondition has to be checked at each recursive
  call: the ~assert~ macro is such that it can be disabled in the final
  “production” object file.

- Takeaway 7.3 #4 :: Multiple recursion may lead to exponential computation
                     times.

- Takeaway 7.3 #5 :: A bad algorithm will never lead to a performing
                     implementation.

- Takeaway 7.3 #6 :: Improving an algorithm can dramatically improve
                     performance.

- /VLA/: variable-length array

- /FLA/: fixed-length array

*** Summary - 105

** TODO 8. C Library functions - 106
- This section covers
  * Doing math, handling files, and processing strings
  * Manipulating time
  * Managing the runtime environment
  * Terminating programs

- The functionality that /the C standard/ provides is separated into _TWO_ big
  parts:
  1. the proper C language,
  2. the C library.

- The choices of compilers and standard libraries on Linux:
  * Compilers: /gcc/ and /clang/
  * Standard Libraries: /glibc/, /dietlibc/, and /musl/

*** TODO 8.1 General properties of the C library and its functions - 106
- Roughly, library functions target one or two different purposes:
  1. Platform abstraction layer: Implement some functions (e.g. IO) requires
     deep platform specific knowledge. Standard library should provide some of
     them.

  2. Basic tools: Functions that implement a task (such as e.g. ~strtod~) that
     often occurs in programming in C for which
     _it is important that the interface is fixed_.

- ~snprintf~: =TODO Section 14.1=

**** 8.1.1 Headers - 107
- TABLE 12. C library headers
  | Name              | Content                                      | Mentioned Section |
  |-------------------+----------------------------------------------+-------------------|
  | ~<assert.h>~      | assert run time conditions                   |               8.6 |
  | ~<complex.h>~     | complex numbers                              |             5.5.7 |
  | ~<ctype.h>~       | character classification and conversion      |               8.3 |
  | ~<errno.h>~       | error codes                                  |                15 |
  | ~<fenv.h>~        | floating-point environment.                  |                   |
  | ~<float.h>~       | properties of floating point types           |               5.5 |
  | ~<inttypes.h>~    | format conversion of integer types           |             5.5.6 |
  | ~<iso646.h>~      | alternative spellings for operators          |               4.1 |
  | ~<limits.h>~      | properties of integer types                  |             5.0.3 |
  | ~<locale.h>~      | internationalization                         |               8.5 |
  | ~<math.h>~        | type specific mathematical functions         |               8.1 |
  | ~<setjmp.h>~      | non-local jumps                              |              18.4 |
  | ~<signal.h>~      | signal handling functions                    |              18.5 |
  | ~<stdalign.h>~    | alignment of objects                         |              12.7 |
  | ~<stdarg.h>~      | functions with varying number of arguments   |            17.4.2 |
  | ~<stdatomic.h>~   | atomic operations                            |              18.5 |
  | ~<stdbool.h>~     | Booleans                                     |               3.1 |
  | ~<stddef.h>~      | basic types and macros                       |               5.1 |
  | ~<stdint.h>~      | exact width integer types                    |             5.5.6 |
  | ~<stdio.h>~       | input and output                             |               8.2 |
  | ~<stdlib.h>~      | basic functions                              |                 2 |
  | ~<stdnoreturn.h>~ | non-returning functions                      |                 7 |
  | ~<string.h>~      | string handling                              |               8.3 |
  | ~<tgmath.h>~      | type generic mathematical functions          |               8.1 |
  | ~<threads.h>~     | threads and control structures               |                19 |
  | ~<time.h>~        | time handling                                |               8.4 |
  | ~<uchar.h>~       | Unicode characters                           |              14.3 |
  | ~<wchar.h>~       | wide string                                  |              14.3 |
  | ~<wctype.h>~      | wide character classification and conversion |              14.3 |

**** 8.1.2 Interfaces - 107
- Most interfaces of the C library are specified as functions,
  _but_ implementations are free to chose to implement them as macros, were
  this is appropriate.

- /functionlike macros/:
  #+BEGIN_SRC C
  #define putchar(A) putc(A, stdout)
  #+END_SRC
  =COMMENT=: Since the replacement text may contain a macro argument several
  times, it would be quite bad to pass any expression with side effects to
  such a macro-or-function.
  Fortunately, because of Rule 1.4.2.2 you don't do that, anyhow.

**** 8.1.3 Error checking - 108
C library functions usually indicate failure through a special return value.
_However_, what value indicates the failure can be
different and depends on the function itself. _Generally, READ THE MANUAL._
- There are three categories that apply:
  1. a special value that indicates an error,
  2. a special value that indicates success, and
  3. functions that return some sort of positive counter on success and a
     negative value on failure.

- A typical error checking code:
  #+BEGIN_SRC C
  if (puts("hello world") == EOF) {
          perror("can't output to terminal:");
          exit (EXIT_FAILURE);
  }
  #+END_SRC

- Takeaway 8.1.3 #1 :: Failure is always an option.

- Takeaway 8.1.3 #2 :: Check the return value of library functions for errors.

- TABLE 13. Error return strategies for C library functions.
  Some functions may also indicate a specific error condition through the
  value of the macro ~errno~.
  | failure              | test            | typical case                  | example                    |
  |----------------------+-----------------+-------------------------------+----------------------------|
  | =0=                  | ~!value~        | other values are valid        | ~fopen~                    |
  |----------------------+-----------------+-------------------------------+----------------------------|
  | special error code   | ~value == code~ | other values are valid        | ~puts~, ~clock~, ~mktime~, |
  |                      |                 |                               | ~strtod~, ~fclose~         |
  |----------------------+-----------------+-------------------------------+----------------------------|
  |----------------------+-----------------+-------------------------------+----------------------------|
  | non-zero value       | ~value~         | value otherwise unneeded      | ~fgetpos~, ~fsetpos~       |
  |----------------------+-----------------+-------------------------------+----------------------------|
  | special success code | ~value != code~ | case distinction for failure  | ~thrd_create~              |
  |                      |                 | condition                     |                            |
  |----------------------+-----------------+-------------------------------+----------------------------|
  |----------------------+-----------------+-------------------------------+----------------------------|
  | negative value       | ~value < 0~     | positive value is a "counter" | ~printf~                   |
  |----------------------+-----------------+-------------------------------+----------------------------|

- Takeaway 8.1.3 #3 :: Fail fast, fail early, and fail often.
  =COMMENT=: An immediate failure of the program is often the best way to
  ensure that bugs are detected and get fixed in early development.

**** 8.1.4 Bounds-checking interfaces - 109
- bounds-checking interfaces of /Annex K/ of the standard.

- _TWO_ macros regulate access to theses interfaces:
  1. ~__STDC_LIB_EXT1__~ tells if this optional interfaces is supported, and
  2. ~__STDC_WANT_LIB_EXT1__~ switches it on.
  The later must be set before any header files are included:
  #+BEGIN_SRC c
  #if !__STDC_LIB_EXT1__
  #  error "This code needs bounds checking interface Annex K"
  #endif
  #define __STDC_WANT_LIB_EXT1__ 1

  #include <stdio.h>
  // Use printf_s from here on.
  #+END_SRC

- Takeaway 8.1.4 #1 :: Identifier names terminating with ~_s~ are reserved.

- If a bounds-checking function encounters an inconsistency, a
  /runtime constraint violation/,
  it usually should end program execution after printing a diagnostic.

**** 8.1.5 Platform preconditions - 109
- Takeaway 8.1.5 #1 :: Missed preconditions for the execution platform must abort
                       compilation.

- The classical tool to achieve this are /preprocessor conditionals/ as we
  have seen them above:
  #+BEGIN_SRC c
  #if !__STDC_LIB_EXT1__
  #  error "This code needs bounds checking interface Annex K"
  #endif
  #+END_SRC

- Takeaway 8.1.5 #2 :: In a preprocessor conditional, only evaluate macros and
                       integer literals.

- Takeaway 8.1.5 #3 :: In a preprocessor conditional, unknown identifiers
                       evaluate to 0.

- ~__Static_assert~ and ~static_assert~ from =assert.h=.
  #+BEGIN_SRC c
  #include <assert.h>
  static_assert(sizeof(double) == sizeof(long double),
      "Extra precision needed for convergence.");
  #+END_SRC

*** TODO 8.2. Integer arithmetic - 111
*** TODO 8.3. Numerics - 113
*** TODO 8.4. Input, output and file manipulation - 115
**** 8.4.1. Unformatted text output - 115
- The ~type int as parameter~ for ~putchar~ is just a _historical accident_
  that shouldn't hurt you much.

- ~fputs~ and ~fputs~:
  #+BEGIN_SRC c
  int fputc(int c, FILE * stream);
  int fputs(char const s[static 1], FILE * stream);
  #+END_SRC

- The type ~FILE*~ for /streams/ provides an abstraction for writing
  results to some permanent storage.

- The identifier ~FILE~ itself is a so-called /opaque type/, for which don't
  know more than is provided by the functional interfaces.
  =TODO=: that we will see in this section.

- The facts that it is implemented as a macro and
  the _MISUSE_ of the name ~FILE~ for a /stream/ is a reminder that this
  is one of the _historic interfaces that predate standardization_.

- Takeaway 8.4.1 #1 :: Opaque types are specified through functional interfaces.

- Takeaway 8.4.1 #2 :: Don't rely on implementation details of opaque types.
                       =COMMENT=: Jian thinks this rule is applicable all types.

- Takeaway 8.4.1 #3 :: ~puts~ and ~fputs~ differ in their end-of-line handling.

**** 8.4.2. Files and streams - 116
- ~fopen~ and ~freopen~:
  #+BEGIN_SRC c
  FILE* fopen(char const path[static 1], char const mode[static 1]);
  FILE* freopen(char const path[static 1], char const mode[static 1], FILE *stream);
  #+END_SRC

- TABLE 15 Modes and modifiers for ~fopen~ and ~freopen~.

- =Optional= (Annex K):
  + function: ~fopen_s~ and ~freopen_s~ =TODO=
  + ~error_t~ type =TODO=
  + ~restrict~ keyword for pointer types =TODO=
  #+BEGIN_SRC c
  errno_t fopen_s(FILE* restrict streamptr[restrict],
                  char const filename[restrict], char const mode[restrict]);

  errno_t freopen_s(FILE* restrict newstreamptr[restrict],
                    char const filename[restrict],
                    char const mode[restrict], FILE* restrict stream);
  #+END_SRC

- TABLE 16 Mode strings for ~fopen~ and ~freopen~. Valid combinations. =TODO=

- The modifiers are _used less commonly_ in everyday's coding:
  1. "Update" mode with ~+~ should be used carefully.
  2. Reading and writing at the same (~rb~, etc.) time is not so easy and
     needs some special care.
  3. For ~b~ we will discuss the difference between text and binary streams
     in some more detail =in Section 14.4=. =TODO=

- ~freopen~ (prototype mentioned above), ~fclose~, and ~fflush~:
  #+BEGIN_SRC c
  int fclose(FILE * fp);
  int fflush(FILE * stream);
  #+END_SRC
  + ~freopen~: associate a given stream to a different file and eventually
    change the mode.
    This is particular useful to associate the standard streams to a file.
    #+BEGIN_SRC c
    int main(int argc, char * argv[argc+1]) {
        if (!freopen("mylog.txt", "a", stdout)) {
            perror("freopen failed");
            return EXIT_FAILURE;
        }
        puts("feeling fine today");
        return EXIT_SUCCESS;
    }
    #+END_SRC

**** 8.4.3. Text IO - 118
- For efficiency, output to text streams is usually /buffered/.
  Physical reason.

- When apply ~fclose~, all buffers are guraanteed to be /flushed/ to where
  it is supposed to go.

- ~fflush~

- /line buffering/: the most common form of IO buffering. Do physically
  output when encounter the end of a text line. In this mode:
  1. ~puts~ would always appear immediately on the terminal.
  2. ~fputs~ would wait until it meets an ~'\n'~

- Takeaway 8.4.3 #1 :: Text input and output converts data.
                       =COMMENT= This is because internal and external represen-
                       tation of text characters are not necessarily the same.
                       the C library is in charge of doing this conversion.

- Takeaway 8.4.3 #2 :: There are three commonly used conversion to encode
                       end-of-line

- Takeaway 8.4.3 #3 :: Text lines should not contain trailing white space.
                       =COMMENT=: They (include blank and tabulator characters)
                       can be suppressed.

- TABLE 17. Format specifications for printf and similar functions, with the
  general syntax "%[FF][WW][.PP][LL]SS"

- TABLE 18. Format specifiers for ~printf~ and similar functions

- ~remove~ and ~rename~:
  #+BEGIN_SRC c
  int remove(char const pathname[static 1]);
  int rename(char const oldpath[static 1], char const newpath[static 1]);
  #+END_SRC

**** 8.4.4. Formatted output - 119
- Takeaway 8.4.4 #1 :: Parameters of ~printf~ must exactly correspond to the
                       format specifiers.

- TABLE 19. Format modifiers for ~printf~ and similar functions. ~float~
  arguments are first converted to ~double~.

- TABLE 20. Format flags for ~printf~ and similar functions.

- Takeaway 8.4.4 #2 :: Use ~"%d"~, ~"%u"~ formats to print integer values.

- Takeaway 8.4.4 #3 :: Use ~"%b"~, ~"%x"~ formats to print bit patterns.

- Takeaway 8.4.4 #4 :: Use ~"%g"~ format to print floating-point values.

- Takeaway 8.4.4 #5 :: Using an inappropriate format specifier or modifier makes
                       the behavior undefined.

- Takeaway 8.4.4 #6 :: Use ~"%+d"~, ~"%#X"~, and ~"%a"~ for conversions that have
                       to be read later.

- =Optional= ~printf_s~ and ~fprintf_s~:
  1. They check that the stream, format and any string arguments are valid
     pointers.
  2. They don't check if the expressions in the list correspond to correct
     format specifiers.

**** 8.4.5. Unformatted text input - 123
- ~fgetc~ and ~fgets~
  #+BEGIN_SRC c
  int fgetc(FILE * stream);
  char * fgets(char s[restrict], int n, FILE * restrict stream);
  int getchar(void);
  #+END_SRC

- =Optional=:
  ~getchar~ and ~gets_s~
  #+BEGIN_SRC c
  char * gets_s(char s[static 1], rsize_t n);
  #+END_SRC

- _Historically_, in the same spirit as ~puts~ specializes ~fputs~, prior
  version of the C standard had a ~gets~ interface. This has been removed
  because it was inherently unsafe. =TODO why=

- Takeaway 8.4.5 #1 :: Don't use ~gets~.

- Takeaway 8.4.5 #2 :: ~fgetc~ returns ~int~ to be able to encode a special error
                       status, =EOF=, in addition to all valid characters.

- We have to call ~feof~ to test if a stream's position has reached its
  end-of-file marker. Test a return =EOF= alone is not enough. =TODO=

- Takeaway 8.4.5 #3 :: End-of-file can only be detected after a failed read.

*** TODO 8.5. String processing and conversion - 125
- TABLE 21. Character classifiers.

- Takeaway 8.5 #1 :: The interpretation of numerically encoded characters depends
                     on the execution character set.

**** 8.5.1. Portability of string processing - 129
- Takeaway 8.5.1 #1 :: Don't use the string conversion functions to determine the
                       boundaries of numbers.

- Takeaway 8.5.1 #2 :: Don't use the string conversion functions to scan numbers
                       that originate from number literals.

*** TODO 8.6. Time - 130
*** TODO 8.7. Runtime environment settings - 134
- TABLE 23. strftime format specifiers.

*** TODO 8.8. Program termination and assertions - 135
- Takeaway 8.8 #1 :: Regular program termination should use a ~return~ from
                     ~main~.

- TABLE 24. Categories for the ~setlocale~ function

- Takeaway 8.8 #2 :: Use ~exit~ from a function that may terminate the regular
                     control flow.

- Takeaway 8.8 #3 :: Don't use functions other than ~exit~ for program
                     termination, unless you have to inhibit the execution of
                     library cleanups.

- Takeaway 8.8 #4 :: Use as many ~assert~'s as you can to confirm runtime
                     properties.

- Takeaway 8.8 #5 :: In production compilations, use ~NDEBUG~ to switch off all
                     ~assert~'s.

*** Summary - 138

* TODO LEVEL 2. Cognition - 139
** DONE 9. Style - 149
CLOSED: [2017-04-25 Tue 16:10]
- Programs serve both sides:
  * give instructions to the compiler and the final executable.
  * document the intended behavior of a system for us people
    that have to deal with it.

- Takeaway 9 #1 :: All C code must be readable.

  * =from Jian=
    About the *readable*:
    + Be readable in the details level for people who have domain knowledge.

    + Be readable for all programmers in the outline level -- people can easily
      understand the high level logic.

  * Here the *readable* is mainly for human, whose condition is _constrained_
    by _TWO major factors_:
    + Physical ability;
    + Cultural baggage.

- Takeaway 9 #2 :: Short-term memory and the field of vision are small.

- Try to read /the coding style for the Linux kernel/.

- Takeaway 9 #3 :: Coding style is NOT a question of taste BUT of culture.

  _Ignoring this, easily leads to endless and fruitless debates about not much
  at all._

- Takeaway 9 #4 :: Each established project you constitutes its own cultural
                   space.

- You can decide the style of your own project,
  but be careful if you want others to adhere to it.

*** 9.1. Formatting - 140
- _The need for code formatting originates in human incapacity_.

- Takeaway 9.1 #1 :: Choose a consistent strategy for white space and other text
                     formatting.

- Takeaway 9.1 #2 :: Have your text editor automatically format your code
                     correctly.

*** 9.2. Naming - 141
- _The limit of automatic formatting tools is reached when it comes to naming._

- There are two different aspects to naming:
  1. technical restrictions
  2. semantic conventions
  Unfortunately, they are often mixed up.

- Takeaway 9.2 #1 :: Choose a consistent naming policy for all identifiers.

- _All identifiers_:
  1. types (struct or not),
  2. struct and union fields,
  3. variables,
  4. enumerations,
  5. macros,
  6. functions,
  7. function-like macros.
  There are so many tangled “name spaces” you’d have to be careful.

- In particular the interaction between header files and macro definitions
  can have surprising effects. A seemingly innocent example:
  #+BEGIN_SRC c
  double memory_sum(size_t N, size_t I, double strip[N][I]);
  #+END_SRC
  * ~N~ is a capitalized identifier, thus your collaborator could be tempted
    to define a macro ~N~ as a big number.
  * ~I~ is used for the root of −1 as soon as someone includes ~complex.h~.
    (And you see that the automatic code annotation system of this book
    thinks that this refers to the macro.)
  * The identifier ~strip~ might be used by some C implementation for a library
    function or macro.
  * The identifier ~memory_sum~ might be used by the C standard for a type name
    in the future.

- Takeaway 9.2 #2 :: Any identifier that is visible in a header file must be
                     conforming.

- Here conforming is a wide field. In the C jargon an identifier is /reserved/
  if its meaning is fixed by the C standard and you may not redefined it otherwise.
  * Names starting with an underscore and a second underscore or a capital
    letter are reserved for language extensions and other internal use.
    ~_xxx~, ~__xxx~, and ~Cxxx~
  * Names starting with an underscore are reserved in file scope and for
    enum, struct and union tags. =TODO ???=
  * Macros have all caps names.
  * All identifiers that have a predefined meaning are reserved and cannot be
    used in file scope. These are lot of identifiers, e.g.
    1. all functions in the C library,
    2. all identifiers starting with =str= (as our strip, above),
    3. all identifiers starting with =E=,
    4. all identifiers ending in =_t= and many more.

- A simple strategy to keep the probability of naming conflicts low is to
  expose as few names as possible

- Takeaway 9.2 #3 :: Don't pollute the global space of identifiers.

- A good strategy for a library that has vocation of use by others or in
  other projects is to use naming prefixes that are unlikely to create
  conflicts.

- There are two sorts of names that may interact badly with macros that
  another programmer writes at which you might not think immediately:
  * field names of ~struct~ and ~union~
  * parameter names in function interfaces.
  _Solution_: use prefix:
  * ~struct timespec~ has ~tv_sec~ rather than ~sec~.
  * parameter names:
    #+BEGIN_SRC c
      double p99_memory_sum(size_t p00_n, size_t p00_i,
                            double p00_strip[p00_n][p00_i]); 
    #+END_SRC

- This problem gets worse when we are also exposing program internals to the
  public view. This happens in two cases:
  * So-called ~inline~ functions, that are functions that have their definition
    (and not only declaration) visible in a header file.

  * Functional macros. =TODO= =???=

- Now that we have cleared the technical aspects of naming, we will look at
  the semantic aspect.

- Takeaway 9.2 #4 :: Names must be recognizable and quickly distinguishable.
- Takeaway 9.2 #5 :: Naming is a creative act.
- Takeaway 9.2 #6 :: File scope identifiers must be comprehensive.
- Takeaway 9.2 #7 :: A type name identifies a concept.
- Takeaway 9.2 #8 :: A global constant identifies an artifact.
- Takeaway 9.2 #9 :: A global variable identifies state.
- Takeaway 9.2 #A :: A function or functional macro identifies an action.

*** 9.3. Internationalization, so to speak - 144
- Takeaway 9.3 #1 :: The natural language of a project should be chosen to
                     accommodate the majority of the participants.

- Takeaway 9.3 #2 :: Alphabetic letters are only allowed in identifiers if they
                     map to themselves for Normalization Form C.

- Takeaway 9.3 #3 :: Only use alphabetic letters in identifiers if they originate
                     directly from natural languages or they are clearly
                     distinctive from all natural languages.

- Takeaway 9.3 #4 :: Only use letters from different scripts or variations of
                     decimal digits in identifiers if they are clearly
                     distinctive from one another.

- Takeaway 9.3 #5 :: Using subscript or superscript letters in identifiers is not
                     portable.

*** Summary - 148

** DONE 10. Organization and documentation - 157
CLOSED: [2017-04-25 Tue 16:10]
- Takeaway 10 #1 (what) :: Function interfaces describe what is done.

- Takeaway 10 #2 (what for) :: Interface comments document the purpose of a
                               function.

- Takeaway 10 #3 (how) :: Function code shows how the function is organized.

- Takeaway 10 #4 (in which manner) :: Code comments explain the manner in which
                                      function details are implemented.

- Takeaway 10 #5 :: Separate interface and implementation.

- Takeaway 10 #6 :: Document the interface; explain the implementation.

*** 10.1. Interface documentation - 150
- Takeaway 10.1 #1 :: Document interfaces thoroughly.

- Takeaway 10.1 #2 :: Structure your code in units that have strong semantic
                      connections.

- /include guards/: protect against multiple inclusion. E.g.
  If there is a ~brain.h~ for ~struct brain~:
  #+BEGIN_SRC c
    #ifndef BRAIN_H
    #define BRAIN_H
    #include <time.h>

    // ... ...
    #endif
  #+END_SRC

*** 10.2. Implementation - 152
- Good programming only needs to explain the ideas and prerequisites that are
  not obvious, the difficult part. Through the structure of the code, it
  shows what it does and how.

- Takeaway 10.2 #1 :: Implement literally.

- Takeaway 10.2 #2 :: Control flow must be obvious.

- There are many possibilities to obfuscate control flow. The most important
  are:
  1. /burried jumps/: ~break~, ~continue~, ~return~, and ~goto~.
  2. /flyspeck expressions/: =TODO=

**** 10.2.1. Macros - 153
- Takeaway 10.2.1 #1 :: Macros should not change control flow in a surprising way.

- ~do ... while(false)~ trick used in macro for grouping several statements.

- Takeaway 10.2.1 #2 :: Function-like macros should syntactically behave like
                        function calls.

- Possible pitfalls are: =PAGE 105= many many!!! =TODO=

**** 10.2.2. Pure functions - 155
- Functions are extensions of the value operators (in Table 2), and
  NOT of the object operators (of Table 3).

- Takeaway 10.2.2 #1 :: Function parameters are passed by value.

- Takeaway 10.2.2 #2 :: Global variables are frowned upon.

- A function with the following two properties is called /pure/:
  * No other effects than returning a value.
  * The returned value only depends on its parameters.
    No matter how many times you call the function, it always returns the
    same result if you pass the same parameters.

- Takeaway 10.2.2 #3 :: Express small tasks as pure functions whenever possible.

- =TODO= ~inline~ and /link time optimization/

**** 10.2.3. Attributes - 159
- Takeaway 10.2.3 #1 :: Identifiers in attributes can be replaced by
                        preprocessing.

- Takeaway 10.2.3 #2 :: Use the double underscore forms of attributes in header
                        files.

*** Summary - 162

** TODO 11. Pointers - 163 =RE-READ=
*** 11.1. Pointer operators - 164
**** 11.1.1. Address-of and object-of operators - 164
- Takeaway 11.1.1 #1 :: Using ~*~ with an _indeterminate_ or /null pointer/ has
                        /undefined behavior/.

  * The _indeterminate_ case might access some random object in memory and
    modify it. Often this leads to bugs that are difficult to trace.

  * The /null pointer/ case will nicely crash your program -- consider this
    to be a feature.

**** 11.1.2. Pointer addition - 165
- Takeaway 11.1.2 #1 :: A VALID pointer refers to the _FIRST_ element of an ARRAY
                        of the reference.

- Code in 3 ways:
  #+BEGIN_SRC c
    // #1
    double sum0(size_t len, double const* a) {
      double ret = 0.0;

      for (size_t i = 0; i < len; ++i) {
        ret += *(a + i);
      }

      return ret;
    }

    // #2
    double sum1(size_t len, double const* a) {
      double ret = 0.0;

      for (double const* p = a; p < a+len; ++p) {
        ret += *p;
      }

      return ret;
    }

    // #3
    double sum2(size_t len, double const* a) {
      double ret = 0.0;

      for (double const*const aStop = a+len; a < aStop; ++a) {
        ret += *a;
      }

      return ret;
    }
  #+END_SRC

- Takeaway 11.1.2 #2 :: The length of an array object cannot be reconstructed
                        from a pointer.

- =Comment= In this case ~sizeof~ doesn't work.
  You must pass the length to functions.

  For example,
  #+BEGIN_SRC c
    double A [7] = { 0, 1, 2, 3, 4, 5, 6, };

    double s0_7 = sum0(7, &A[0]);  // for the whole
    double s1_6 = sum0(6, &A[1]);  // for last 6
    double s2_3 = sum0(3, &A[2]);  // for 3 in the middle
  #+END_SRC

- Takeaway 11.1.2 #3 :: Pointers are NOT arrays.

- So if we pass arrays through pointers to a function, it is important to
  retain the real length that the array has.
    This is why we prefer the array notation for pointer interfaces through-
  out this book:
  #+BEGIN_SRC c
  // "Preferred" form contains more info. It DIRECTLY tells the reader `a`
  // is an array of length `len`

  // Preferred
  double sum0(size_t len, double const a[len]);

  // Just OK
  double sum0(size_t len, double const * a);
  #+END_SRC

- Another difference is:
  that pointers have value and that that value can change.
  Thus they can be used by value operators as operands.
  _Array is not a value type_.

- Setting pointers to 0 if it hasn't some valid address is very important and
  should not be forgotten.
  It helps to check and keep track if a pointer has been set.

- =COMMENT=:
  1. This usually works:
     #+BEGIN_SRC c
     double A[2] = { 0.0, 1.0, };
     double * p = &A[0];
     printf("element %g\n", *p); // referencing object
     p += 2;                     // valid pointer, no object
     printf("element %g\n", *p); // referencing non-object
                                 // undefined behavior
     #+END_SRC

  2. This may crash at the increment operation:
     #+BEGIN_SRC c
     double A[2] = { 0.0, 1.0, };
     double * p = &A[0];
     printf("element %g\n", *p); // referencing object
     p += 3;                     // valid pointer, no object
     printf("element %g\n", *p); // referencing non-object
                                 // undefined behavior
     #+END_SRC

**** 11.1.3. Pointer subtraction and difference - 167
- Takeaway 11.1.3 #1 :: Only subtract pointers to elements of the same array object.

  * _It is *only allowed* if the two pointers refer to elements of the *same*
    array object_.

- Takeaway 11.1.3 #2 :: All pointer differences have type ~ptrdiff_t~.

- Takeaway 11.1.3 #3 :: Use ~ptrdiff_t~ to encode
                        SIGNED differences of _positions_ or _sizes_.

- Takeaway 11.1.3 #4 :: For printing cast pointer values to ~void*~ and use the
                        format ~%p~.

**** 11.1.4. Pointer validity - 168
- Takeaway 11.1.4 #1 :: Pointers have a truth value.

- Takeaway 11.1.4 #2 :: Set pointer variables to null as soon as you can.

- Takeaway 11.1.4 #3 :: A program execution that accesses an object that has a
                        non-value representation for its type fails.

- Takeaway 11.1.4 #4 :: When dereferenced, a pointed-to object must be of the
                        designated type.

- Takeaway 11.1.4 #5 :: A pointer must point to a valid object, one position
                        beyond, or be null.

- Takeaway 11.1.4 #6 :: A program execution that computes a pointer value outside
                        the bounds of an array object (or one element beyond)
                        fails.

**** 11.1.5. Null pointers - 170
- /null pointer/: 0 value of any pointer type.

- C has the concept of /null pointer/. Here:
  #+BEGIN_SRC c
  double const * const nix = 0;
  double const * const nax = nix;
  #+END_SRC
  "nix" and "nax" would be such _a pointer object of value 0_.
  _But_ unfortunately a /null pointer constant/ is then not what you'd
  expect. =IMPORTANT=
  1. here by /constant/ the term refers to a compile time constant and _NOT_
     to a ~const~ qualified object.
     So for that reason already, both pointer objects above are not null
     pointer constants.
  2. the permissible type for these constants is restricted, it may be
     * any constant expression of _integer_ type or
     * of type ~void*~.

- =TODO=: Other pointer types are not permitted, and we will only learn about
  pointers of that "type" below in Section 12.4. =IMPORTANT=

- The definition by the C standard of what could be the expansion of the
  macro ~NULL~ is quite loose, it just has to be a null pointer constant.
  Therefore a C compiler could chose any of the following for it:
  | expansion                       | type                 |
  |---------------------------------+----------------------|
  | ~0U~                            | ~unsigned~           |
  |---------------------------------+----------------------|
  | ~0~                             | ~signed~             |
  | ~'\0'~                          |                      |
  | enumeration constant of value 0 |                      |
  |---------------------------------+----------------------|
  | ~0UL~                           | ~unsigned long~      |
  | ~0L~                            | ~signed long~        |
  |---------------------------------+----------------------|
  | ~0ULL~                          | ~unsigned long long~ |
  | ~0LL~                           | ~signed long~        |
  |---------------------------------+----------------------|
  | ~(void *)0~                     | ~void*~              |

- Takeaway 11.1.5 #1 :: Use ~nullptr~ instead of ~NULL~.

- =COMMENT=: ~NULL~ hides more than it clarifies,
  1. either use =0=, or
  2. if you really want to emphasize that the value is a pointer use the
     magic token sequence ~(void*)0~ directly.

*** 11.2. Pointers and structures - 171
- If ~a~ is a pointer, ~a->tv_sec~ is nothing but ~(*a).tv_sec~.

- Takeaway 11.2 #1 :: Don't hide pointer types inside a ~typedef~.

*** 11.3. Pointers and arrays - 175
**** 11.3.1. Array and pointer access are the same - 175
- Takeaway 11.3.1 #1 :: The two expressions ~A[i]~ and ~*(A+i)~ are equivalent.

- =COMMENT=: This holds _regardless_ whether ~A~ is an array or a pointer.

- If ~A~ is an array, ~*(A+i)~ shows our first application of one of the most
  important rules in C, called /array-to-pointer decay/.

- Takeaway 11.3.1 #2 (array decay) :: Evaluation of an array ~A~ returns ~&A[0]~.

- =COMMENT=: In fact, this is the reason behind Rules 1.6.1.3 to 1.6.1.5:
  Whenever an array occurs that requires a value,
  1. it decays to a pointer and
  2. we loose all additional information.

**** 11.3.2. Array and pointer parameters are the same - 175
- Takeaway 11.3.2 #1 :: In a function declaration any array parameters rewrites
                        to a pointer. =IMPORTANT=

- =COMMENT=: The rule that we follow in this book to: =IMPORTANT=
  1. use array notation if we suppose that this _CAN'T be null_, and
  2. use pointer notation if it corresponds to one single item of the base
     type that also _can be null_ to indicate a special condition.

- Takeaway 11.3.2 #2 :: Only the innermost dimension of an array parameter is
                        rewritten.

- Examples(they are equivalent):
  1. Code
     #+BEGIN_SRC c
       void matrix_mult(size_t n, size_t k, size_t m,
                        double (C[n])[m],
                        double (A[n])[k],
                        double (B[k])[m]);
     #+END_SRC

  2. Code
     #+BEGIN_SRC c
       void matrix_mult(size_t n, size_t k, size_t m,
                        double (*C)[m],
                        double (*A)[k],
                        double (*B)[m]);
     #+END_SRC

  Observe that once we have rewritten the innermost dimension as a pointer,
  the parameter type is not an array anymore, but a "pointer to array". So
  there is no need to rewrite the subsequent dimensions.

- Takeaway 11.3.2 #3 :: Declare length parameters before array parameters.

- Takeaway 11.3.2 #4 :: The validity of array arguments to functions must be
                        guaranteed by the programmer.

*** 11.4. Function pointers - 177 =TODO: Re-Read=
- Takeaway 11.4 #1 (function decay) :: A function name without following
                                       parenthesis decays to a pointer to its
                                       start.

- Syntactically functions and function pointers are also similar to arrays in
  type declarations and as function parameters:  =TODO= =TODO= =???=
  #+BEGIN_SRC c
  typedef void atexit_function(void);
  // two equivalent definitions of the same type, that hides a pointer
  typedef atexit_type* atexit_function_pointer;
  typedef void (*atexit_function_pointer)(void);

  // five equivalent declarations for the same function
  void atexit(void f(void));
  void atexit(void (*f)(void));
  void atexit(atexit_function f);
  void atexit(atexit_function* f);
  void atexit(atexit_function_pointer f);
  #+END_SRC

- There is some sort of catch-all pointer type, ~void*~,
  that can be used as a generic pointer to object types, no such generic type
  or implicit conversion exists for function pointers.

- Takeaway 11.4 #2 :: Function pointers must be used with their exact type. =IMPORTANT=

- Example:
  The prototype of ~qsort~ in =stdlib.h= is
  #+BEGIN_SRC c
  void qsort(void *base, size_t nitems, size_t size,
             int (*compar)(const void *, const void *));
  #+END_SRC
  Don't use ~int compare_int(int const * a, int const * b);~ as the ~compar~
  function.

- Takeaway 11.4 #3 :: The function call operator (...) applies to function
                      pointers.

- =COMMENT=: Similar rules as for arrays and pointers and the ~[...]~.

- Equivalent (legal) calls to ~f~:   =TODO= =TODO= =???=
  #+BEGIN_SRC c
  double f(int a);

  f(3);            // decay to function pointer
  (&f)(3);         // address of function
  (*f)(3);         // decay to function pointer, then dereference, then decay
  (*&f)(3);        // address of function, then dereference, then decay
  (&*f)(3);        // decay, dereference, address of
  #+END_SRC
  So technically, in terms of the abstract state machine,
  1. _the pointer decay is always performed_ and
  2. _the function is called via a function pointer_.
  The first, "natural", call (~f(3)~) has a hidden evaluation of the ~f~
  identifier that results in the function pointer.

- With all that, we can use function pointers almost like functions.
  #+BEGIN_SRC c
  // TODO....
  #+END_SRC

- When using this feature you should always be aware that this introduces an
  indirection to the function call. The compiler first has to fetch the
  contents of logger and can only then call the function at the address that
  he found, there.
  _This has a certain overhead and should be avoided in time critical code_.

*** Summary - 182

** TODO 12. The C memory model - 191 =RE-READ=
- Apply unary operator ~&~ to (almost) all objects to retrieve their address.
  =Comment (footnote 16)=: only objects that are declared with keyword
                           ~register~ don't have an address.
  TODO (see Section 13.2.2 on Level 2).

- Seen from C, the address is important, and it's not necessary to care about
  the "real" locations (, which can be in the RAM, a disk file, or an IO port,
  etc.).
  C is supported to do right thing, regardless.

- Takeaway 12 #1 :: Pointer types with distinct base types are distinct.

*** DONE 12.1. A uniform memory model - 183
CLOSED: [2017-04-24 Mon 17:48]
- THREE distinct types that by definition use _exactly one byte_ of memory:
  1. ~char~
  2. ~unsigned char~
  3. ~signed char~

- Takeaway 12.1 #1 :: ~sizeof (char)~ is _1_ by definition.

- Takeaway 12.1 #2 :: Every object A can be viewed as ~unsigned char[sizeof A]~.

- Takeaway 12.1 #3 :: Pointers to character types are special.

- The types that are used to "compose" all other object types is derived from
  ~char~.
  This is _merely an historical accident_ and you shouldn't read too much
  into it.
  In particular, you should clearly distinguish the TWO different use cases:

- Takeaway 12.1 #4 :: Use the type ~char~ for character and string data.

- Takeaway 12.1 #5 :: Use the type ~unsigned char~ as the atom of all object
                      types. =IMPORTANT=

- The type ~signed char~ is of much less importance than the two others.

- Takeaway 12.1 #6 :: The ~sizeof~ operator can be applied to objects and object
                      types.
                      =USAGE=:
                      1. When apply to objects
                         BOTH ~sizeof(object)~ and ~sizeof object~ are right!
                      2. apply to object types:
                         ONLY ~sizeof(object)~ is right.

- Takeaway 12.1 #7 :: The size of all objects of type ~T~ is given by ~sizeof(T)~.

*** DONE 12.2. Unions - 185
CLOSED: [2017-04-24 Mon 17:48]
- /Unions/ are similar in declaration to ~struct~
  but have different semantic!

- Takeaway 12.2 #1 :: The in-memory order of the representation digits of a
                      numerical type is implementation defined.

- /little Endian/ and /big Endian/
  All of this is not normalized by the standard, it is implementation defined
  behavior.

- Takeaway 12.2 #2 :: On _most_ architectures ~CHAR_BIT~ is 8 and ~UCHAR_MAX~ is
                      255.

- The in memory representation of other base types are more complicated.

*** DONE 12.3. Memory and state - 186 =RE-READ=
CLOSED: [2017-04-25 Tue 15:57]
- /aliasing/: The phenomenon of accessing the same object through different
  pointers.

- Takeaway 12.3 #1 (Aliasing) :: With the _exclusion_ of character types,
     _only_ pointers of the same base type may alias.

- Try to write programs such that to _protect_ our variables _from ever being
  aliased_, and there is an easy way to achieve that:

- Takeaway 12.3 #2 :: Avoid the ~&~ operator.

- =TODO=: Depending on properties of a given variable, the compiler may then
  see that the address of the variable is never taken, and thus that the
  variable can't alias at all. In Section 13.2 we will see which properties
  of a variable or object may have influence on such decisions and how the
  ~register~ keyword can protect us from taking addresses inadvertently.

- =TODO=: Later then, in Section 16.2, we will see how the ~restrict~ keyword
  allows to specify aliasing properties of pointer arguments, even if they
  have the same base type.

*** DONE 12.4. Pointers to unspecific objects - 188
CLOSED: [2017-04-25 Tue 00:17]
- The main purpose of ~void~ is to be used a fallback pointer type:

- Takeaway 12.4 #1 :: Any object pointer converts _to_ and _from_ ~void*~.

- =COMMENT=: Observe that this only talks about pointers to objects, not
  pointers to functions.  =IMPORTANT=

- Takeaway 12.4 #2 :: An object has storage, type, and value.

- Takeaway 12.4 #3 :: Converting an object pointer to ~void*~ and then back to
                      the same type is the _identity operation_.

- The _ONLY_ thing a variable looses when converting to ~(void *)~ is the
  type information.

- Takeaway 12.4 #4 (avoid2*) :: Avoid ~void*~.

- =COMMENT=: Avoid whenever you can.

- Never use ~void~ to declare variables.
  =From Jian= The sematics of an operation is connected to the type of the
              operand(s), and ~void~ has no realted operation.

*** DONE 12.5. Explicit conversions - 188
CLOSED: [2017-04-25 Tue 01:05]
- Problematic:
  #+BEGIN_SRC c
  unsigned char highC = 1;
  unsigned char highU = (highC << 32);  // undefined behavior
  #+END_SRC
  _Looks innocent, but isn't._

  In the second, the problem lays in the RHS.
  1. Narrow types are converted before doing arithmetic on them (Table 6).
     Here =highC= is converted to ~int~
     and
     the left shift operation is then performed on that type.

  2. By our assumption shifting by 31 bit shifts the 1 into the highest order
     bit, the sign bit.
     Thus the result of the expression on the right is _undefined_.
     =TODO= =REVIEW=

- /narrow types/ _ONLY make sense_ in very special circumstances:
  * Save memory.
    For example, A really _BIG array_ of _SMALL values_.

  * Use ~char~ for _characters_ and _strings_.
    But then you WOULDN'T do arithmetic with them.

  * You use ~unsigned char~ to inspect the bytes of an object.
    But then, again, you WOULDN'T do arithmetic with them.

- There are ONLY _TWO_ forms of /implicit conversions/ that are permitted for
  pointers to data:
  1. conversions _from_ and _to_ ~void*~
  2. conversions that _add a qualifier_ to the target type.
  For example,
  =IMPORTANT=
  #+BEGIN_SRC c
  float f = 37.0; // conversion : to float
    // remember the rhs is double if not suffixed with 'f'

  double a = f; // conversion : back to double
    // sizeof(double) > sizeof(float)

  float * pf = &f; // exact type
  float const * pdc = &f; // conversion : adding a qualifier
  void * pv = &f; // conversion : pointer to void *

  float * pfv = pv; // conversion : pointer from void *
    // this is OK due to the real data pointed by `pv` is float.

  float * pd = &a; // error : incompatible pointer type (compiler knows)
    // assigning a pointer to a type that has a different size and
    // interpretation can and will lead to serious damage.
    // 
    // NOTICE:
    // This is one of the difference between pointer variables and the other
    // type of variables.
    //
    // this is an ERROR due to the real data pointed by `pv` is a double.
    //   sizoeof(float) < sizeof(double)

  double * pdv = pv; // undefined behavior if used 
    // These two steps will definitely happen (before this statment).
    // 1. the `pv` pointer points to the address `&f`
    //
    // 2. since the type of `pv` is `void *`, before proper operation no one
    //    knows how many bytes after the address `&f` will this pointer
    //    point.
    //
    // since this statement is an undefined behavior, we can supoose a
    // situation that can lead to errors:
    // 3. `double * pdv = pv;` means when de-reference `pdv`, it may intend
    //    to use more than sizeof(float) bytes (since its `double *`).
    //      If this happens, since we don't know the information of the bytes
    //    exceeds sizeof(float), we can't predict what will happen.
  #+END_SRC

- Rule 2.12.5.4 :: Don't use casts.
                   =COMMENT= In most use cases that I have come across in
                   real life,
                   _the compiler was right and the programmer was wrong_:
                   even experienced programmers tend to abuse casts to hide
                   poor design decisions concerning types.

- /casts/ deprive you of precious information and if you chose your types
  carefully you will only need them at very special occasions.

- Use /cast/ HARMLESSLY in one situation:
  + You may want to inspect the contents of an object on byte level.
  + Constructing a ~union~ around an object _might not always be possible (or
    too complicated)_ so here we can go for a cast. For example,
    #+BEGIN_SRC c
    unsigned val = 0xAABBCCDD ;
    unsigned char * valp = (unsigned char *)& val;
    for ( size_t i = 0; i < sizeof val; ++i) {
      printf (" byte [%zu]: 0x %.02 hhX\n", i, valp[i]); 
    }
    #+END_SRC

*** DONE 12.6. Effective Type - 190
CLOSED: [2017-04-25 Tue 02:06]
- To cope with different views to the same object that pointers may provide,
  C has introduced the concept of effective types. It heavily restricts how
  an object can be accessed:

- Takeaway 12.6 #1 (Effective Type) :: _Objects_ must be accessed
  * through their effective type
    or
  * through a pointer to a character type.

- Because the /effective type/ of a ~union~ variable is the ~union~ type and
  NONE of the member types, the rules for union members can be relaxed:

- Takeaway 12.6 #2 :: Any member of an object that has an effective union type
                      can be accessed at any time, provided the byte representa-
                      tion amounts to a valid value of the access type.
                      =EXAMPLES ???=

- Takeaway 12.6 #3 :: The /effective type/ of a variable or compound literal is
                      _the type of its declaration_.

- Takeaway 12.6 #4 :: _Variables_ and _compound literals_ must be accessed
  * through their declared type
    or
  * through a pointer to a character type.

- _Asymmetry_ in all of this for character types.
  * Any object can be seen as a composed of ~unsigned char~,
  * but not any array of ~unsigned char~ can be used through another type.
  #+BEGIN_SRC c
  unsigned char A[sizeof(unsigned)] = { 9 };
  // valid but useless , as most casts are
  unsigned * p = (unsigned *)A;
  // error , access with type that is neither the effective type nor a
  // character type
  printf("value \%u\n", *p); 
  #+END_SRC

- The reasons for such a strict rule are _multiple_.
   =TODO= (EXPLAIN THE "multiple" here)
  _The very first motivation_ for introducing /effective types/ in the C
  standard was to
  _deal with aliasing as we have seen in Section 12.3_.

  In fact,
  _the Aliasing Rule 2.12.3.1 is derived from the Effective Type Rule 2.12.6.1._

  As long as there is NO ~union~ involved, the compiler knows that, for
  example,
  * we CANNOT access a ~double~ through a ~size\under{}t *~,
    and
  * so he may assume that the objects are different.

*** DONE 12.7. Alignment - 191 =RE-READ=
CLOSED: [2017-04-25 Tue 15:57]
- /alignment/

- /word boundary/

- The inverse direction of pointer conversions (from "pointer to character
  type” to “pointer to object") is not harmless at all,
  1. not only because of possible aliasing.
  2. but also because of alignment (another property of the memory model of C).

- Objects of most non-character types CAN'T start at any arbitrary byte posi-
  tion, they usually start at a /word boundary/.

- /bus error/: data bus alignment error

- Some architectures are more tolerant to misalignment than others
  and
  we might have to force the system to error out on such a condition.

- ~\under{}Alignof(oneArg)~, ~\under{}Alignas(oneArg)~, ~<stdalign.h>~

*** Summary - 193

** TODO 13. Storage - 194
*** 13.1. ~malloc~ and friends - 194
- /dynamic memory allocation/, related functions are in  =stdlib.h=:
  #+BEGIN_SRC c
  #include <stdlib.h>
  void * malloc(size_t size);
  void free(void * ptr);
  void * calloc (size_t nmemb, size_t size); // set all bits to 0
  void * realloc(void * ptr, size_t size); // grow or shrink an object
  void * aligned_alloc(size_t alignment, size_t size);
  // ensures non-default alignment   ??? =TODO=
  #+END_SRC

- Some examples:
  #+BEGIN_SRC c
  double * largeVec = malloc(length * sizeof(*largeVect));

  double * largeVec = malloc(length * sizeof(double)); // Add by Jian

  double * largeVec = malloc(sizeof(double[length]));
  #+END_SRC

- Takeaway 13.1 #1 :: Only use the allocation functions with a size strictly
                      greater than zero.

- =COMMENT=: Strong typed language C++ requires this kind of _CAST_.


- Takeaway 13.1 #2 :: Failed allocations result in a null pointer.

- Takeaway 13.1 #3 :: Prefer the use of ~strndup~ over ~strdup~.

- Takeaway 13.1 #4 :: Don't cast the return of ~malloc~ and friends.

- Takeaway 13.1 #5 :: Storage allocated through ~malloc~ is uninitialized and has
                      no type.

**** 13.1.1. A complete example with varying array size - 196
- Takeaway 13.1.1 #1 :: ~malloc~ indicates failure by returning a null pointer
                        value.

**** 13.1.2. Ensuring consistency of dynamic allocations - 204
- Takeaway 13.1.2 #1 :: For every ~malloc~, there must be a ~free~.

- Takeaway 13.1.2 #2 :: For every ~free~, there must be a ~malloc~, ~calloc~,
                        ~aligned_alloc~, or ~realloc~.

- Takeaway 13.1.2 #3 :: Only call ~free~ with pointers as they are returned by
                        ~malloc~, ~calloc~, ~aligned_alloc~, or ~realloc~.

**** 13.1.3. Flexible array members - 205
- Takeaway 13.1.3 #1 :: A structure object with a flexible array member must have
                        enough storage to access the structure as a whole.

- Takeaway 13.1.3 #2 :: Consistency between a length member and a flexible array
                        member must be maintained manually.

*** 13.2. Storage duration, lifetime, and visibility - 205
- Takeaway 13.2 #1 :: Identifiers only have visibility inside their scope,
                      starting at their declaration.

- Takeaway 13.2 #2 :: The visibility of an identifier can be shadowed by an
                      identifier of the same name in a subordinate scope.

- Takeaway 13.2 #3 :: Every definition of a variable creates a new, distinct
                      object.

- Takeaway 13.2 #4 :: Read-only object literals may overlap.

- Takeaway 13.2 #5 :: Objects have a lifetime outside of which they can't be
                      accessed.

- Takeaway 13.2 #6 :: A program execution that refers to an object outside of its
                      lifetime fails.

- Takeaway 13.2 #7 :: A compound literal has the same lifetime as a variable that
                      would be declared with the same storage class within the
                      same context.

**** 13.2.1. Static storage duration - 209
- Takeaway 13.2.1 #1 :: Objects with static storage duration are always
                        initialized.

**** 13.2.2. Automatic storage duration - 209
- Takeaway 13.2.2 #1 :: Unless automatic objects are VLA or temporary objects,
                        they have a lifetime corresponding to the execution of
                        their block of definition.

- Takeaway 13.2.2 #2 :: Each recursive call creates a new local instance of an
                        automatic object.

- Takeaway 13.2.2 #3 :: The ~&~ operator is not allowed for objects declared with
                        ~register~.

- Takeaway 13.2.2 #4 :: Objects declared with ~register~ can't alias.

- Takeaway 13.2.2 #5 :: Declare local variables that are not arrays in
                        performance-critical code as ~register~.

- Takeaway 13.2.2 #6 :: Arrays with storage class ~register~ are useless.

- Takeaway 13.2.2 #7 :: Objects of temporary lifetime are read-only.

- Takeaway 13.2.2 #8 :: Temporary lifetime ends at the end of the enclosing full
                        expression.

*** 13.3. Digression: using objects "before" their definition - 211
- Takeaway 13.3 #1 :: For an object that is not a VLA, lifetime starts when the
                      scope of the definition is entered, and it ends when that
                      scope is left.

- Takeaway 13.3 #2 :: Initializers of automatic variables and compound literals
                      are evaluated each time the definition is met.

- Takeaway 13.3 #3 :: For a VLA, lifetime starts when the definition is
                      encountered and ends when the visibility scope is left.

*** 13.4. Initialization - 212
- Takeaway 13.4 #1 :: Objects of static or thread-storage duration are
                      initialized by default.

- Takeaway 13.4 #2 :: Objects of automatic or allocated storage duration must be
                      initialized explicitly.

- Takeaway 13.4 #3 :: Systematically provide an initialization function for each
                      of your data types.

*** 13.5. Digression: a machine model - 214

** TODO 14. More involved processing and IO - 220
*** 14.1. Text processing - 220
- Takeaway 14.1 #1 :: The string strto... conversion functions are NOT
                      ~const~-safe.

- Takeaway 14.1 #2 :: The function interfaces for ~memchr~ and ~strchr~ search
                      functions are not ~const~-safe.

- Takeaway 14.1 #3 :: The type-generic interfaces for ~memchr~ and ~strchr~
                      search functions are ~const~-safe.

- Takeaway 14.1 #4 :: The ~strspn~ and ~strcspn~ search functions are
                      ~const~-safe.

- Takeaway 14.1 #5 :: ~sprintf~ makes no provision against /buffer overflow/.

- Takeaway 14.1 #6 :: Use ~snprintf~ when formatting output of unknown length.

*** 14.2. Formatted input - 226
- TABLE 14.1
- TABLE 14.2
- TABLE 14.3

*** 14.3. Extended character sets - 228
- Takeaway 14.3 #1 :: Multibyte characters don't contain null bytes.

- Takeaway 14.3 #2 :: Multibyte strings are null terminated.

*** 14.4. UTF character encodings - 235
*** 14.5. Restartable text conversion - 237
- Takeaway 14.5 #1 :: The multibyte mb encoding of a code point is written to the
                      output string all at once.

- Takeaway 14.5 #2 :: The multibyte mb encoding of a code point may be collected
                      piecewise from the input.

*** 14.6. Binary streams - 239
- Takeaway 14.6 #1 :: Open streams on which you use ~fread~ or ~fwrite~ in binary
                      mode.

- Takeaway 14.6 #2 :: Files written in binary mode are not portable between
                      platforms.

- Takeaway 14.6 #3 :: ~fseek~ and ~ftell~ are not suitable for very large file
                      offsets.

*** Summary - 243

* TODO LEVEL 3. Experience - 263
** TODO 16. Performance - 264 - =re-number update done=
- Takeaway 16 #1 :: Premature optimization is the root of all evil.

- Takeaway 16 #2 :: Do not trade off safety for performance.

- Takeaway 16 #3 :: Optimizers are clever enough to eliminate unused initializations.

- Takeaway 16 #4 :: The different notations of pointer arguments to functions
                    result in the same binary code.

- Takeaway 16 #5 :: Not taking addresses of local variables helps the optimizer
                    because it inhibits aliasing.

*** 16.1. Inline functions - 266
- Takeaway 16.1 #1 :: Inlining can open a lot of optimization opportunities.

- Takeaway 16.1 #2 :: Adding a compatible declaration without ~inline~ keyword
                      ensures the emission of the function symbol in the current
                      TU.

- Takeaway 16.1 #3 :: An ~inline~ function definition is visible in all TU.

- Takeaway 16.1 #4 :: An ~inline~ definition goes in a header file.

- Takeaway 16.1 #5 :: An additional declaration without ~inline~ goes in exactly
                      one TU.

- Takeaway 16.1 #6 :: Only expose functions as ~inline~ if you consider them to
                      be stable.

- Takeaway 16.1 #7 :: All identifiers that are local to an ~inline~ function
                      should be protected by a convenient naming convention.

- Takeaway 16.1 #8 :: ~inline~ functions can't access ~static~ functions by name.

- Takeaway 16.1 #9 :: ~inline~ functions can't access modifiable ~static~ objects
                      by name.

- Takeaway 16.1 #A :: ~inline~ functions can't define modifiable ~static~
                      objects.

*** 16.2. Using restrict qualifiers - 270
- Takeaway 16.2 #1 :: A ~restrict~-qualified pointer has to provide exclusive
                      access.

- Takeaway 16.2 #2 :: A ~restrict~-qualification constrains the caller of a
                      function.

*** 16.3. Unsequenced and reproducible attributes - 271
- Takeaway 16.3 #1 :: All pure functions should have the attribute
                      ~[[unsequenced]]~.

- Takeaway 16.3 #2 :: A function with the attribute ~[[unsequenced]]~ shall not
                      read nonconstant global variables or system state.

- Takeaway 16.3 #3 :: In general, a function that uses floating point arithmetic
                      is not pure and shall not have the attribute
                      ~[[unsequenced]]~.

- Takeaway 16.3 #4 :: A function with the attribute ~[[unsequenced]]~ shall not
                      apply visible modifications to global variables or system
                      states.

- Takeaway 16.3 #5 :: A function that returns possible errors through errno is
                      not pure and shall not have the attribute ~[[unsequenced]]~.

- Takeaway 16.3 #6 :: Pragmas that change the floating point state act locally
                      within the current scope.

- Takeaway 16.3 #7 :: Type attributes accumulate within the current scope.

- Takeaway 16.3 #8 :: A function with the attribute ~[[reproducible]]~ may
                      temporarily modify the global state as long as it restores
                      it to its original value.

- Takeaway 16.3 #9 :: For functions with ~[[unsequenced]]~ and ~[[reproducible]]~
                      attribute annotate pointer parameters with restrict.

- Takeaway 16.3 #A :: A function with the attribute ~[[unsequenced]]~ shall not
                      modify the local static state, even through other function
                      calls.

- Takeaway 16.3 #B :: A function with the attribute ~[[reproducible]]~ shall only
                      modify the local static state if that state is not
                      observable from outside the function.

*** 16.4. Measurement and inspection - 273
- Takeaway 16.4 #1 :: Don't speculate about performance of code, verify it
                      rigorously.

- Takeaway 16.4 #2 :: Complexity assessment of algorithms needs proofs.

- Takeaway 16.4 #3 :: Performance assessment of code requires measurement.

- Takeaway 16.4 #4 :: All measurements introduce bias.

- Takeaway 16.4 #5 :: Instrumentation changes compile-time and run-time
                      properties.

- Takeaway 16.4 #6 :: The relative standard deviation of run times must be in a
                      low percentage range.

- Takeaway 16.4 #7 :: Collecting higher-order moments of measurements to compute
                      variance and skew is simple and cheap.

- Takeaway 16.4 #8 :: Run-time measurements must be hardened with statistics.

*** Summary - 283

** TODO 17. Function-like macros - 284
- Takeaway 17 #1 :: Whenever possible, prefer an inline function to a functional
                    macro.

- Takeaway 17 #2 :: A functional macro shall provide a simple interface to a
                    complex task.

*** 17.1. How function-like macros work - 285
- Takeaway 17.1 #1 :: Macro replacement is done in an early translation phase,
                      before any other interpretation is given to the tokens
                      that compose the program.

- Takeaway 17.1 #2 (macro retention) :: If a functional macro is not followed by
                                        ~()~, it is not expanded.

*** 17.2. Argument checking - 287
*** 17.3. Accessing the context of invocation - 291
- Takeaway 17.3 #1 :: The line number in ~__LINE__~ may not fit into an ~int~.

- Takeaway 17.3 #2 :: Using ~__LINE__~ is inherently dangerous.

- Takeaway 17.3 #3 :: Stringification with the operator ~#~ does not expand
                      macros in its argument.

- Takeaway 17.3 #4 :: Nested macro definitions may expand macro arguments several
                      times.

*** 17.4. Variable-length argument lists - 293
**** 17.4.1. Variadic macros - 293
**** 17.4.2. A detour: variadic functions - 297
- TAKEAWAY 17.4.2 #1 :: When passed to a variadic parameter, all arithmetic types
                        are converted as for arithmetic operations, with the ex-
                        ception of ~float~ arguments, which are converted to
                        ~double~.

- TAKEAWAY 17.4.2 #2 :: A variadic function has to receive valid information
                        about the type of each argument in the variadic list.

- TAKEAWAY 17.4.2 #3 :: Using variadic functions is not portable unless each
                        argument is forced to a specific type.

- TAKEAWAY 17.4.2 #4 :: Avoid variadic functions for new interfaces.

- TAKEAWAY 17.4.2 #5 :: The ~va_arg~ mechnanism doesn't give access to the length
                        of the ~va_list~.

- TAKEAWAY 17.4.2 #6 :: A variadic function needs a specific convention for the
                        length of the list.

*** 17.5. Default arguments - 300
*** Summary - 304

** TODO 18. Type-generic programming - 305
*** 18.1 Inherent type-generic features in C - 305
**** 18.1.1 Operators - 305
**** 18.1.2. Default promotions and conversions - 306
**** 18.1.3. Macros - 306
**** 18.1.4. Variadic functions - 308
**** 18.1.5. Function pointers - 308
**** 18.1.6. ~void~ pointers - 309
**** 18.1.7. Type-generic C library functions - 309

*** 18.2 Generic selection - 310
- Takeaway 18.2 #1 :: The result type of a ~_Generic~ expression depends on the
                      type of chosen expression.

- Takeaway 18.2 #2 :: Using ~_Generic~ with ~inline~ functions adds optimization
                      oportunities.

- Takeaway 18.2 #3 :: All choices expression1 ... expressionN in a ~_Generic~
                      must be valid.

- Takeaway 18.2 #4 :: The type expressions in a ~_Generic~ expression should
                      only be unqualified types, not array types and function
                      types.

- Takeaway 18.2 #5 :: The type expressions in a ~_Generic~ expression must refer
                      to mutually incompatible types.

- Takeaway 18.2 # 5 :: The type expressions in a ~_Generic~ expression cannot be
                       a pointer to a VLA.

*** 18.3 Type inferrence - 317
**** 18.3.1 The ~auto~ feature - 317
- Takeaway 18.3.1 #1 :: Protect local variables inside macros by a documented
                        naming convention.

- Takeaway 18.3.1 #2 :: Use ~auto~ definitions where you must ensure type
                        consistency.

**** 18.3.2 The ~typeof~ feature - 318
- Takeaway 18.3.2 #1 :: Prefer ~auto~ over ~typeof~ for variable declarations.

*** 18.4 Anonymous functions - 322
*** Summary - 326

** TODO 19. Variations in control flow - 327
*** 19.1. A detailed example - 328
*** 19.2. Sequencing - 331
- Takeaway 19.2 #1 :: Side effects in functions can lead to indeterminate results.

- Here is a list of all sequence points that are defined in terms of C's grammar:
  * The end of a statement, either by semicolon (;) or closing brace (}).
  * The end of an expression before the comma operator (,).19
  * The end of a declaration, either by semicolon (;) or comma (,).20
  * The end of the controlling expressions of ~if~, ~switch~, ~for~, ~while~,
    conditional evaluation (?:) or short circuit evaluation (|| and &&).
  * After the evaluations of the function designator (usually a function
    name) and the function arguments of a function call21 but before the
    actual call.
  * The end of a return statement.

- There are other sequencing restrictions besides those implied by sequence
  points. The first two are more or less obvious but should be stated
  nevertheless:

- Takeaway 19.2 #2 :: The specific operation of any operator is sequenced after
                      the evaluation of all its operands.

- Takeaway 19.2 #3 :: The effect of updating an object by any of the assignment,
                      increment or decrement operators is sequenced after the
                      evaluation of its operands.

- Takeaway 19.2 #4 :: A function call is sequenced with respect to all evalua-
                      tions of the caller.

- Takeaway 19.2 #5 :: Initialization list expressions for array or structure
                      types are indeterminately sequenced.

*** 19.3. Short jumps - 333
- Takeaway 19.3 #1 :: Each iteration defines a new instance of a local object.

- Takeaway 19.3 #2 :: ~goto~ should only be used for exceptional changes in
                      control flow.

*** 19.4. Functions - 309
- Takeaway 19.4 #1 :: Each function call defines a new instance of a local
                      object.

*** 19.5. Long jumps - 310
- Takeaway 19.5 #1 :: ~longjmp~ never returns to the caller.

- Takeaway 19.5 #2 :: When reached through normal control flow, a call to
                      ~setjmp~ marks the call location as a jump target and
                      returns =0=.

- Takeaway 19.5 #3 :: Leaving the scope of a call to ~setjmp~ invalidates the
                      jump target.

- Takeaway 19.5 #4 :: A call to ~longjmp~ transfers control directly to the
                      position that was set by ~setjmp~ as if that had returned
                      the condition argument.

- Takeaway 19.5 #5 :: A =0= as _condition_ parameter to ~longjmp~ is replaced
                      by =1=.

- Takeaway 19.5 #6 :: ~setjmp~ may only be used in simple comparisons inside
                      controlling expression of conditionals.

- Takeaway 19.5 #7 :: Optimization interacts badly with calls to ~setjmp~.

- Takeaway 19.5 #8 :: Objects modified across ~longjmp~ must be ~volatile~.

- Takeaway 19.5 #9 :: ~volatile~ objects are reloaded from memory each time they
                      are accessed.

- Takeaway 19.5 #A :: ~volatile~ objects are stored each time they are modified.

- Takeaway 19.5 #B :: The ~typedef~ for ~jmp_buf~ hides an array type.

*** 19.6. Signal handlers - 340
- Takeaway 19.6 #1 :: C's signal handling interface is minimal and should only
                      be used for elementary situations.

- Takeaway 19.6 #2 :: Signal handlers can kick in at any point of execution.

- Takeaway 19.6 #3 :: After return from a signal handler, execution resumes
                      exactly where it was interrupted.

- Takeaway 19.6 #4 :: Any C statement may correspond to several processor
                      instructions.

- Takeaway 19.6 #5 :: Signal handlers need types with uninterruptible
                      operations.

- Takeaway 19.6 #6 :: Objects of type ~sig~atomic_t~ should not be used as
                      counters.

- Takeaway 19.6 #7 :: Unless specified otherwise, C library functions are not
                      asynchrounous signal safe.

*** Summary - 349

** TODO 20. Threads - 350
*** 20.1. Simple interthread control - 353
- Takeaway 20.1 #1 :: If a tread T_{0} writes a non-atomic object that is
                      simultaneously read or written by another thread T_{1} the
                      execution fails.

- Takeaway 20.1 #2 :: In view of execution in different threads, standard
                      operations on atomic objects are indivisible and
                      linearizable.

- Takeaway 20.1 #3 :: Use the specifier syntax ~_Atomic (T)~ for atomic
                      declarations.

- Takeaway 20.1 #4 :: There are no atomic array types.

- Takeaway 20.1 #5 :: Atomic objects are the privileged tool to force the absence
                      of race conditions.

*** 20.2. Race-free initialization and destruction - 355
- Takeaway 20.2 #1 :: A properly initialized ~FILE*~ can be used race-free by
                      several threads.

- Takeaway 20.2 #2 :: Concurrent write operations should print entire lines at
                      once.

- Takeaway 20.2 #3 :: Destruction and deallocation of shared dynamic objects
                      needs a lot of care.

*** 20.3. Thread-local data - 357
- Takeaway 20.3 #1 :: Pass thread specific data through function arguments.

- Takeaway 20.3 #2 :: Keep thread specific state in local variables.

- Takeaway 20.3 #3 :: A ~thread_local~ variable has one separate instance for
                      each thread.

- Takeaway 20.3 #4 :: Use ~thread_local~ if initialization can be determined at
                      compile time.

*** 20.4. Critical data and critical sections - 358
- Takeaway 20.4 #1 :: Mutex operations provide linearizability.

- Takeaway 20.4 #2 :: Every mutex must be initialized with ~mtx_init~.

- Takeaway 20.4 #3 :: A thread that holds a non-recursive mutex must not call any
                      of the mutex lock function for it.

- Takeaway 20.4 #4 :: A recursive mutex is only released after the holding
                      thread issues as many calls to ~mtx_unlock~ as it has
                      acquired locks.

- Takeaway 20.4 #5 :: A locked mutex must be released before the termination of
                      the thread.

- Takeaway 20.4 #6 :: A thread must only call ~mtx_unlock~ on a mutex that it
                      holds.

- Takeaway 20.4 #7 :: Each successful mutex lock corresponds to exactly one call
                      to ~mtx_unlock~.

- Takeaway 20.4 #8 :: A mutex must be destroyed at the end of its lifetime.

*** 20.5. Communicating through condition variables - 360
- Takeaway 20.5 #1 :: On return from a ~cnd_t~ wait, the expression must be
                      checked again.

- Takeaway 20.5 #2 :: A condition variable can only be used simultaneously
                      with one mutex.

- Takeaway 20.5 #3 :: A ~cnd_t~ must be initialized dynamically.

- Takeaway 20.5 #4 :: A ~cnd_t~ must be destroyed at the end of its lifetime.

*** 20.6. More sophisticated thread management - 364
- Takeaway 20.6 #1 :: Returning from ~main~ or calling ~exit~ terminates all
                      threads.

- Takeaway 20.6 #2 :: While blocking on ~mtx_t~ or ~cnd_t~ a thread frees
                      processing resources.

*** 20.7. Ensure liveness - 366
- Takeaway 20.7 #1 :: Returning from ~main~ or calling ~exit~ terminates all
                      threads.

- Takeaway 20.7 #2 :: Prefer ~cnd_timedwait~ over ~cnd_wait~ to avoid deadlock.
                      Returning from ~main~ or calling ~exit~ terminates all threads.

*** Summary - 369

** TODO 21. Atomic access and memory consistency - 370
- TakeawayS 21 #1 :: Every evaluation has an effect.

*** 21.1. The "happend before" relation - 371
- TakeawayS 21.1 #1 :: If ~F~ is sequenced before ~E~, then ~F -> E~.

- TakeawayS 21.1 #2 :: The set of modifications of an atomic object X are
                       performed in an order that is consistent with the
                       sequenced before relation of any threads that deals with
                       X.

- TakeawayS 21.1 #3 :: An acquire operation E in a thread T_E synchronizes with a
                       release operation F in another thread T_F if E reads the
                       value that F has written.

- TakeawayS 21.1 #4 :: If F synchronizes with E, all effects X that have happened
                       before F must be visible at all evaluations G that happen
                       after E.

- TakeawayS 21.1 #5 :: We only can conclude that one evaluation happened before
                       another if we have a sequenced chain of synchronizations
                       that links them.

- TakeawayS 21.1 #6 :: If an evaluation F happened before E, all effects that are
                       known to have happened before F are also known to have
                       happened before E.

*** 21.2. C library calls that provide synchronization - 349
- Takeaway 21.2 #1 :: Critical sections that are protected by the same mutex
                      occur sequentially.

- Takeaway 21.2 #2 :: In a critical section that is protected by mutex ~mut~ all
                      effects of previous critical sections protected by ~mut~
                      are visible.

- Takeaway 21.2 #3 :: ~cnd_wait~ or ~cnd_timedwait~ have release-acquire
                      semantics for the mutex.

- Takeaway 21.2 #4 :: Calls to ~cnd_signal~ or ~cnd_broadcast~ synchronize via
                      the mutex.

- Takeaway 21.2 #5 :: Calls to ~cnd_signal~ or ~cnd_broadcast~ should occur
                      inside a critical section that is protected by the same
                      mutex as the waiters.

*** 21.3. Sequential consistency - 352
- Takeaway 21.3 #1 :: All atomic operations with sequential consistency occur in
                      one global modification order, regardless of the atomic
                      object they are applied to.

- Takeaway 21.3 #2 :: All operators and functional interfaces on atomics that
                      don't specify otherwise have sequential consistency.

*** 21.4. Other consistency models - 353
- Takeaway 21.4 #1 :: Synchronizing functional interfaces for atomic objects
                      with ~_explicit~ appended allow us to specify their
                      consistency model.

- Takeaway 19.15 :: Every functional interface for atomic objects has a form with
                    ~_explicit~ appended which allows to specify its consistency
                    model.

* Appendix. Technical Annex - 381
** A. Transitional code - 382
** B. C Compilers - 385
*** B.1. Attributes - 385
*** B.2. Missing #embed - 385
*** B.3. Missing constexpr - 385
*** B.4. Missing 128-bit integer support - 386

** C. C Libraries - 387
*** C.1. Functions borrowed from POSIX or similar systems - 387
*** C.2. Improved UTF-8 support - 387
*** C.3. Bit utilities - 387
*** C.4. Checked integer arithmetic - 387
*** C.5. Formatted IO - 387
*** C.6. Mathematical functions - 387
*** C.7. A reference implementation for musl libc - 388

* Appendix. Takeaways - 389
* Appendix. Bibliography - 404
* Appendix. Index - 407

