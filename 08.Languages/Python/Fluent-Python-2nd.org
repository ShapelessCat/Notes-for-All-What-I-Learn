#+TITLE: Fluent Python
#+SUBTITLE: Clear, Concise, and Effective Programming
#+VERSION: 2nd, Covers Python 3.10, 2022
#+AUTHOR: Luciano Ramalho
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Preface - xix
* TODO Part I. Data Structures - _READING_
** DONE 1. The Python Data Model - 3
CLOSED: [2021-04-04 Sun 22:05]
- One of the best quanlities of Python is its *consistency*.
  * However, if you learned another object-oriented language before Python,
    _you may find it stange to use ~len(collection)~ instad of
    ~collection.len()~._ To understand this, you need to learn /Python Data
    Model/.
    + =from Jian=
      ~len~ is not a good name!!!
      Python even use ~len~ to get _size_.

- We can understand /Python Data Model/ what is Pythonic
  BY
  study the oddity of using the built-in function ~len~ instead of a /method/.

- Python Data Model ::
  describes the API that if you use it properly you can use to make your own
  objects play well with the most idiomatic language features.

- /Python data model/ can be considered as a description of Python as a
  framework.
  * It *formalizes* the interfaces of the building blocks of the language itself,
    such as
    + /sequences/,
    + /iterators/,
    + /functions/,
    + /classes/,
    + /context managers/, and so on.

- When coding with any /framework/,
  you _spend a lot of time implementing methods that are called by the framework._
  The same happens when you leverage the /Python data model/.
  * Explanation:
    The Python interpreter *invokes SPECIAL methods* to perform basic object
    operations, often *triggered by SPECIAL syntax.*

    + The _special method names_ are always written with _leading and trailing
      double underscores_.

- We implement /special methods/
  WHEN
  we want our objects to *support and interact with* _fundamental language
  constructs_ such as:
  * Collections
  * Attribute access
  * Iteration (including asynchronous iteration using ~async for~)
  * Operator overloading
  * Function and method invocation
  * String representation and formatting
  * Asynchronous programming using ~await~
  * Object creation and destruction
  * Managed contexts using the ~with~ or ~async with~ statements

- =IMPORTANT=
  * JARGON:
    ~__getitem__~ is called as *dunder-getitem* (a shortcut for
    "under-under-getitem-under-under" invented by Steve Holden).
    + Call this kind of methods "dunder methods".

  * The "Lexical Analysis" chapter of The Python Language Reference warns that
    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    *"Any use of ~__*__~ names, in any context, that does not follow explicitly
    documented use, is subject to breakage without warning.*"

*** DONE What's new in this chapter - 4
CLOSED: [2025-07-02 Wed 20:24]
Since the /Python Data Model/ is quite stable, there is few changes.

- Ths most significant changes:
  * /Special methods/ supporting /asynchronous programming/ and _other new
    features_, added to the tables in "Overview of Special Methods".
    =TODO=

  * Figure 1-2 showing the use of /special methods/ in "Collection API" on page
    14, including the ~collections.abc.Collection~ /abstract base class/
    introduced in Python 3.6.

- Adopt the /f-string syntax/ introduced in Python 3.6.
  * Try to use this syntax, instead of the less readable ~str.format()~ and
    ~%~ operator.

  * =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    Only use ~my_fmt.format()~ when building the template ~my_fmt~ *at runtime*.

*** DONE A Pythonic Card Deck - 5
CLOSED: [2021-04-04 Sun 22:42]
#+BEGIN_SRC python
  from collections

  Card = collections.namedtuple('Card', ['rank', 'suit'])

  class FrenchDeck:
      ranks = [str(n) for n in range(2, 11)] + ['J', 'K', 'Q', 'A']
      suits = 'spades diamonds clubs hearts'.split()

      def __init__(self):
          self._cards = [Card(rank, suit)
                         for suit in self.suits
                         for rank in self.ranks]

      def __len__(self):
          return len(self._cards)

      def __getitem__(self, position):
          return self._cards[position]
#+END_SRC

- Usage:
  #+BEGIN_SRC python
    ## Create a card through the `Card` namedtuple
    beer_card = Card('7', 'diamonds')
    beer_card
    # Card(rank='7', suit='diamonds')

    ## Instance creation, and use `len`
    deck = FrenchDeck()
    len(deck)
    # 52

    ## Indexing
    deck[0]
    # Card(rank='2', suit='spades')
    deck[-1]
    # Card(rank='A', suit='hearts')

    ## Pick a random card
    from random import choice
    choice(deck)
    # Card(rank='3', suit='hearts')
    choice(deck)
    # Card(rank='K', suit='spades')
  #+END_SRC

- Just by implementing the ~__getitem__~, our deck is also /iterable/ (then
  the ~reverse~ function can be applied).

- /Iteration/ is often _implicit_.
  If a collection has *NO* ~__contains__~ method, the ~in~ operator does a
  _sequential scan_ (use ~__getitem__~).

- *How About Shuffling?*
  By convention, a single underscore prefixed attribute is private -- cannot
  be accessed outside, and therefore de facto *immutable* (ONLY be convention).
  * We can't do shuffling now.

  * =TODO= Chapter 11
    Use ~__setitem__~ to make shuffling available.

*** DONE How Special Methods Are Used - 8
CLOSED: [2025-07-03 Thu 01:24]
- /Special methods/ should always be called by the Python interpreter, and
  NOT by you.

- When measure the size, ~__len__~ is _NOT always_ used by the interpreter.

  For built-in types like ~list~, ~str~, ~bytearray~, and so on, the
  interpreter takes a shortcut:
    The /CPython/ implementation of ~len()~ actually returns the value of the
  ~ob_size~ field in the ~PyVarObject~ C struct that represents any
  _variable-sized built-in object_ in memory. This is _much faster_ than
  calling a method.

- Unless you are doing a lot of /metaprogramming/, you should be implementing
  /special methods/ more often than invoking them explicitly.

- The _ONLY_ /special method/ that is frequently called by user code directly
  is ~__init__~, to invoke the initializer of the superclass in your own
  ~__init__~ implementation.

- _CONCLUSION_:
  If you need to invoke a /special method/,
  it is usually BETTER to call the related built-in function (e.g., ~len~,
  ~iter~, ~str~, etc).

  These built-ins call the corresponding /special method/, but often provide
  other services and -- for built-in types -- are faster than method calls.

  =TODO= See, for example, “A Closer Look at the iter Function” on page 436
  in Chapter 14.

- _NEVER_ create a dunder identifier to your own use -- they can be
  /special methods/ in the future, even if they are not today; consider them
  as reserved names for the future /special methods/.

**** DONE Emulating Numeric Types - 9
CLOSED: [2025-07-03 Thu 01:24]
=TODO= More details in Chapter 13

- What we want is
  #+BEGIN_SRC python
    v1 = Vector(2, 4)
    v2 = Vector(2, 1)
    v1 + v2              # Vector(4, 5)

    v = Vector(3, 4)
    abs(v)               # 5.0

    v * 3                # Vector(9, 12)


  #+END_SRC

- Implementation (with ~__repr__~, ~__abs__~, ~__add__~, and ~__mul__~):
  #+BEGIN_SRC python
    import math

    class Vector:
        def __init__(self, x=0, y=0):
            self.x = x
            self.y = y

        def __repr__(self):
            return 'Vector({!r}, {!r})'.format(self.x, self.y)

        def __abs__(self):
            return math.hypot(self.x, self.y)

        def __bool__(self):
            return bool(abs(self))

        def __add__(self, other):
            x = self.x + other.x
            y = self.y + other.y
            return Vector(x, y)

        def __mul__(self, scalar):
            return Vector(self.x * scalar, self.y * scalar)
  #+END_SRC

**** DONE String Representation - 12
CLOSED: [2025-07-03 Thu 01:24]
- The ~__repr__~ /special method/ is called by the ~repr~ built-in.

- If it wasn't implemented in the example of the last subsection, the
  printed out is like =<Vector object at 0x10e100070>=

- The interactive console and debugger call repr on the results of the
  expressions evaluated. When print, use ~%r~ for ~%~ operator, and use
  ~!r~ for the ~format~ method or function.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  The string returned by ~__repr__~ should be
  * *unambiguous* and,
  * if possible, match the source code necessary to re-create the object being
    represented (when use built-in ~eval~).
  #+BEGIN_SRC python
    repr(3)  # '3'
    repr('3')  # '"3"'
  #+END_SRC

- If no ~__str__~ is implemented, ~__repr__~ will be the fallback.

- StackOverflow Question:
  "Difference between ~__str__~ and ~__repr__~ in Python"
  Answers from Alex Martelli and Martijn Pieters
  =TODO=

**** DONE Boolean Value of a Custom Type - 13
CLOSED: [2025-07-03 Thu 01:24]
- BY DEFAULT,
  1. instances of user-defined classes are considered truthy,
  2. unless either ~__bool__~ or ~__len__~ is implemented.

  Basically, ~bool(x)~ calls ~x.__bool__()~ and uses the result.
  If ~__bool__~ is not implemented, Python will try to invoke ~x.__len__()~,
  which returns ~True~ if it is non-zero.

- The ~__bool__~ method should always do ~return bool(something)~
  If not, when you use built-in ~bool~, the result can be a non-boolean
  variable, even though, as in Python, it always has a boolean value.
  =IMPORTANT=

- A faster ~__bool__~ implementation for our version of ~Vector~ (avoid
  using ~abs~):
  #+BEGIN_SRC python
    def __bool__(self):
        return bool(self.x or self.y)
  #+END_SRC

**** DONE Collection API - 14
CLOSED: [2025-07-03 Thu 01:24]
- Figure 1-2 documents the /interfaces/ of the _essential collection types_ in
  the language.
  * All the /classes/ in the diagram are /abstract base classes/.
    + =NEXT= /ABCs/ and the ~collections.abc~ module are covered in _Chapter 13_.

  * The ~Collection~ ABC is new in Python 3.6 and unifies the *three* essential
    /interfaces/ that every collection should implement:
    + ~Iterable~ to support ~for~, /unpacking/, and other forms of /iteration/
    + ~Sized~ to support the ~len~ built-in function (through ~__len__~)
    + ~Container~ to support the ~in~ operator (through ~__contains__~)

  * Python does *not require* concrete classes to actually inherit from any of
    these ~ABC~'s.
    For example, any class that implements ~__len__~ satisfies the ~Sized~
    interface.
    + =from Jian=
      #+begin_src python
        from collections.abc import Sized

        class A:
            def __len__(self):
                return 3


        issubclass(A, Sized)  # True

        a = A()
        isinstance(a, Sized)  # True
      #+end_src

    + =from Jian= This is the good and bad design of Python.

  * Three very important _specializations_ of ~Collection~ are:
    + ~Sequence~, formalizing the interface of built-ins like ~list~ and ~str~
      - Only ~Sequence~ is ~Reversible~.

    + ~Mapping~, implemented by ~dict~, ~collections.defaultdict~, etc.
      - NOTE:
        Since Python 3.7, the ~dict~ type is officially "ordered" --
        =IMPORTANT=
        =IMPORTANT=
        =IMPORTANT=
        only means the insertion order is preserved, and cannot rearrange the
        keys in a ~dict~ however you like.

    + ~Set~, the interface of the ~set~ and ~frozenset~ built-in types

*** DONE Overview of Special Methods - 15
CLOSED: [2017-09-07 Thu 21:07]
The "Data Model" chapter of _The Python Language Reference_ lists *83* special
method names, *47* of which are used to implement arithmetic, bitwise, and
comparison operators

- Table 1-1. Special method names (operators excluded)
  _READ THE BOOK_

- Table 1-2. Special method names for operators
  _READ THE BOOK_

*** DONE Why ~len~ Is Not a Method - 17
CLOSED: [2021-04-04 Sun 23:07]
I (Luciano Ramalho) asked this question to core developer Raymond Hettinger
in 2013 and the key to his answer was a quote from *The Zen of Python*:
_"practicality beats purity."_

- If the ~__len__~ is always called when calculating the length and size,
  some performance requirement can't be satisfied.
  * When ~len(built_in_object)~ is called, it simply read a field in the
    underlying C struct to get the length. This can be much efficient.

*** DONE Chapter Summary - 18
CLOSED: [2025-07-03 Thu 01:25]
By implementing /special methods/, your objects can *behave like the built-in
types*, enabling the expressive coding style the community considers Pythonic.

- There two possible string representations:
  * ~__repr__~ is for _debugging_ and _logging_
  * ~__str__~ is for end users.

*** TODO Further Reading - 18 - =NOTE= + =TODO: READ=
- *Soapbox*

** TODO 2. An Array of Sequences - 21
- Most of the discussion in this chapter applies to /sequences/ _in general_,
  from the familiar ~list~ to the ~str~ and ~bytes~ types added in Python 3.

  Specific topics on lists, tuples, arrays, and queues are also covered here,
  BUT
  * the specifics of /Unicode strings/ and /byte sequences/ appear in _Chapter 4_.
  * Also, the idea here is to cover /sequence types/ that are ready to use.
    *Creating your own sequence types* is the subject of _Chapter 12_.

- These are the main topics this chapter will cover:
  * /List comprehensions/ and the basics of /generator expressions/

  * Using /tuples/ _as records_
    versus
    using /tuples/ as _immutable lists_

  * /Sequence unpacking/ and /sequence patterns/

  * READING FROM /slices/ and
    WRITING TO /slices/

  * Specialized sequence types, like /arrays/ and /queues/

*** TODO What's New in This Chapter - 22
*** TODO Overview of Built-In Sequences - 22
- The standard library offers a rich selection of sequence types _implemented in
  C_:
  * Container sequences :: can hold items of different types, including nested
                           containers.
    + Some examples: ~list~, ~tuple~, and ~collections.deque~.

  * Flat sequences :: hold items of one simple type.
    + Some examples: ~str~, ~bytes~, ~bytearray~, and ~array.array~.

- Another way of grouping sequence types is by mutability:
  * Mutable sequences :: ~list~, ~bytearray~, ~array.array~,
       ~collections.deque~, and ~memoryview~

  * Immutable sequences :: ~tuple~, ~str~, and ~bytes~

- Figure 2-1. UML class diagram for some classes from ~collectior.abc~
  =TODO=

- Refer to /list comprehensions/ as /listcomps/;
  Refer to /generator/as /genexps/.

*** DONE List Comprehensions and Generator Expressions - 25
CLOSED: [2025-07-01 Tue 15:10]
- Note:
  Many Python programmers
  * refer to /list comprehensions/ as *lispcomps*.
  * refer to /generator expressions/ as *genexprs*.

**** DONE List Comprehensions and Readability - 25
CLOSED: [2025-07-01 Tue 15:03]
- A ~for~ loop may be used to do lots of different things,
  while /listcomps/ should be single duty -- build lists.

- For readability, /listcomps/ should be short and no side-effect.
  * Python doesn't forbid long and effectful /listcomps/,
    but please don't abuse /listcomps/.

- *Local Scope Within Comprehensions and Generator Expressions*
  /Listcomps/ no longer leak their variables in Python 3.
  "Walrus operator" is an expection -- because of its scope definition in
  _PEP 572 -- Assignment Expressions_.

**** DONE Listcomps Versus map and filter - 27
CLOSED: [2025-07-01 Tue 15:04]

**** DONE Cartesian Products - 27
CLOSED: [2025-07-01 Tue 15:10]
#+BEGIN_SRC python
  colors = ['black', 'white']
  sizes = ['S', 'M', 'L']

  tshirts = [(color, size) for color in colors for size in sizes]
  tshirts

  # [('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'),
  # ('white', 'M'), ('white', 'L')]
#+END_SRC

**** DONE Generator Expressions - 29
CLOSED: [2025-07-01 Tue 15:10]

*** DONE Tuples Are Not Just Immutable Lists - 30
CLOSED: [2025-07-01 Tue 16:30]
- Tuples do _double_ duty: they can be used
  * as /immutable lists/
  * as /records/ with no field names.

**** DONE Tuples as Records - 30
CLOSED: [2025-07-01 Tue 15:20]
- =NEXT=
  _Chapter 5_ presents TWO ways of *creating tuples with named fields*.

- Tuples work well as records because of the /tuple unpacking/ mechanism.

- *NOTE*:
  /iterable unpacking/, _PEP 3132 -- Extended Iterable Unpacking_.
  * =NEXT=
    “Unpacking Sequences and Iterables” on page 35 presents a lot more about
    unpacking not only tuples, but sequences and iterables in general.

**** DONE Tuples as Immutable Lists - 32
CLOSED: [2025-07-01 Tue 15:33]
- The immutablity of a /tuple/ only applies to the references contained in it.
  Those references can point to a mutable object and be mutated.
  * =from Jian=
    /interior mutabilit/y

  * _Tuples with mutable items_ can be *a source of bugs*.
    =NEXT=
    "What Is Hashable" on page 84 -- an object is only hashable if its value
    cannot ever change.

- Python core developer Raymond Hettinger in a StackOverflow answer to the
  question:
  “Are tuples more efficient than lists in Python?”.
  * A summary is in the book. =REVIEW=

**** DONE Comparing Tuple and List Methods - 34
CLOSED: [2025-07-01 Tue 16:29]
- /tuple/ supports _all_ list methods _that do NOT involve_ *adding* or
  *removing* items (of course, here only in-place operations cannot be
  involved),

  with _ONE exception_ -- tuple lacks the ~__reversed__~ method, which is
  reasonable -- it's used for in-place reverse (should always have no return
  value). Since we cannot do in-place operations to /tuples/, this is just
  an optimization -- eliminate might-be-confusing /special method/;

  For /tuples/, ~reversed(my_tuple)~ works, and it works without
  ~__reversed__~.

- =From Jian= from table, there is one method that /list/ doesn't implement
  ~s.__getnewargs__()~ that Support for optimized serialization with ~pickle~
  =TODO=: Learn more!

*** DONE Unpacking Sequences and Iterables - 35
CLOSED: [2025-07-01 Tue 16:35]
- /parallel assignment/

**** Using ~*~ to Grab Excess Items - 36
**** Unpacking with ~*~ in Function Calls and Sequence literals - 37
**** Nested Unpacking - 37

*** DONE Pattern Matching with Sequences - 38
CLOSED: [2025-07-02 Wed 00:33]
- PEP 634 -- Structural Pattern Matching: Specification.

- *NOTE*
  * Python core developer Carol Willing wrote the excellent introduction to
    pattern matching in the “Structural Pattern Matching” section of “What’s
    New In Python 3.10”. You may want to read thatquick overview.

  * In this book, I chose to
    *split* the coverage of /pattern matching/ over different chapters,
    depending on the pattern types:
    + “Pattern Matching with Mappings” on page 81 and
    + “Pattern Matching Class Instances” on page 192.
    + An extended example is in “Pattern Matching in lis.py: A Case Study” on
      page 669.

- Example 2-9. Method from an imaginary ~Robot~ class
  #+begin_src python
    def handle_command(self, message):
        match message:
            case ['BEEPER', frequency, times]:
                self.beep(times, frequency)
            case ['NECK', angle]:
                self.rotate_neck(angle)
            case ['LED', ident, intensity]:
                self.leds[ident].set_brightness(ident, intensity)
            case ['LED', ident, red, green, blue]:
                self.leds[ident].set_color(ident, red, green, blue)
            case _:
                raise InvalidCommand(message)
  #+end_src

- ~match~ / ~case~ may look like the ~switch~ / ~case~ statement from the C
  language -- BUT that's only half the story.

  One key improvement of ~match~ over ~switch~ is /destructuring/ -- a more
  advanced form of /unpacking/.

- Example 2-10. Destructuring nested tuples—requires Python ≥ 3.10
  #+begin_src python
    metro_areas = [
        ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),
        ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
        ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
        ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
        ('São Paulo', 'BR', 19.649, (-23.547778, -46.635833)),
    ]

    def main():
        print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')
        for record in metro_areas:
            match record:
                case [name, _, _, (lat, lon)] if lon <= 0:
                    print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')
  #+end_src
  * =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    a /sequence pattern/, square brackets and parentheses mean the *SAME* thing.

- footnote:
  * fallthrough
  * dangling else

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  A /sequence pattern/ can match instances of most actual or virtual subclasses
  of ~collections.abc.Sequence~, with the *EXCEPTION* of ~str~, ~bytes~, and
  ~bytearray~.

- *CAUTION*
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  Instances of ~str~, ~bytes~, and ~bytearray~ are not handled as sequences in
  the context of ~match/case~ -- they are considered as "atomic" values.

  * The *REASON* is clear: consider them as sequences could cause bugs due to
    unintended matches.

  * If you want to _treat an object of those types as a sequence subject_,
    convert it into /sequence/ first:
    #+begin_src python
      match tuple(phone):
          case ['1', *rest]: # North America and Caribbean
              ...
          case ['2', *rest]: # Africa and some territories
              ...
          case ['3' | '4', *rest]: # Europe
              ...
    #+end_src

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  In the standard library, these types are *compatible* with /sequence
  patterns/:
  * ~list~
  * ~memoryview~ =TODO: learn more=
  * ~array.array~
  * ~tuple~
  * ~range~
  * ~collections.deque~

- Unlike unpacking, patterns don’t destructure iterables that are not sequences
  (such asiterators).

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  Make patterns more specific by adding type information:
  ~case [str(name), _, _, (float(lat), float(lon))]:~

- *Tip*
  =TODO=
  =TODO=
  =TODO=
  Using arbitrary classes in patterns is covered in “Pattern Matching Class
  Instances” on page 192.

- Match any number of items
  * bindi them to a variable: ~*extra~
  * without binding them to a variable: ~*_~

**** Pattern Matching Sequences in an Iterpreter - 43
***** Alternative patterns for lambda - 45
***** Shortcut syntax for function definition - 46
- *TIP*
  * We'll see more of =lis.py= in "Pattern Matching in lis.py: A Case Study" on
    page 669, when we'll review the complete ~match~ / ~case~ example in
    ~evaluate~.
    =TODO=

  * If you want to learn more about Norvig's =lis.py=, read his wonderful post
    "(How to Write a (Lisp) Interpreter (in Python))".
    =TODO=
    =TODO=
    =TODO=

*** DONE Slicing - 47 - =TODO=
CLOSED: [2017-09-07 Thu 22:47]
- In this section, we describe the use of these _advanced forms_ of /slicing/.
  =TODO=
  Their implementation in a /user-defined class/ will be covered in Chapter 12,

  in keeping with our philosophy of
  1. covering ready-to-use classes in this part of the book, and
  2. creating new classes in Part III.

**** DONE Why Slices and Range Exclude the Last Item - 47
CLOSED: [2017-09-07 Thu 22:27]
- This convetion works well with zero-based indexing languages.

- Some convenient features of the convention are:
  * It's easy to see the length of a /slice/ or /range/ when only the stop
    position is given:
    ~range(3)~ and ~my_list[:3]~ both produce _three_ items.

  * It's easy to compute the length of a /slice/ or /range/ when _start_ and
    _stop_ are given:
    just subtract _stop - start_.

  * It's easy to *split* a sequence in two parts at any index ~x~, without
    overlapping: simply get ~my_list[:x]~ and ~my_list[x:]~.

- =TODO=
  But the best arguments for this convention were written by the Dutch
  computer scientist Edsger W. Dijkstra (see the last reference in “Further
  Reading” on page 59).

**** DONE Slice Objects - 48
CLOSED: [2025-07-02 Wed 00:51]
- =TODO=
  As we will see in “How Slicing Works” on page 404, to evaluate the expression
  ~seq[start:stop:step]~, Python calls
  ~seq.__getitem__(slice(start, stop, step))~.

- Even if you are not implementing your own sequence types,
  knowing about /slice objects/ is useful
  because it lets you
  _assign names to /slices/._
  =from Jian= _and may *reuse* them._

- Example:
  #+BEGIN_SRC python
    invoice = """
    0.....6.................................40........52...55........
    1909  Pimoroni PiBrella                     $17.50    3    $52.50
    1489  6mm Tactile Switch x20                 $4.95    2    $9.90
    1510  Panavise Jr. - PV-201                 $28.00    1    $28.00
    1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95
    """

    SKU = slice(0, 6)
    DESCRIPTION = slice(6, 40)
    UNIT_PRICE = slice(40, 52)
    QUANTITY = slice(52, 55)
    ITEM_TOTAL = slice(55, None)

    line_items = invoice.split('\n')[2:]

    for item in line_items:
        print(item[UNIT_PRICE], item[DESCRIPTION])

    # $17.50 Pimoroni PiBrella
    # $4.95 6mm Tactile Switch x20
    # $28.00 Panavise Jr. - PV-201
    # $34.95 PiTFT Mini Kit 320x240
  #+END_SRC

- =TODO= We'll come back to slice objects when we discuss creating your own
  collections in _“Vector Take #2: A Sliceable Sequence”_ on page 403.

**** TODO Multidimensional Slicing and ~Ellipsis~ - 49 - =TODO: learn use cases in numpy=
- =TODO= =RE-READ=

- Slices are not just useful to extract information from sequences;

  they can also be used to change mutable sequences in place -- that is,
  without rebuilding them from scratch.

**** DONE Assigning to Slices - 50
CLOSED: [2017-09-07 Thu 22:47]
Mutable sequences can be _grafted_, _excised_, and otherwise modified in place
using /slice notation/ on the left side of an assignment statement or as
the target of a ~del~ statement.

- Example:
  #+BEGIN_SRC python
    l = list(range(10))

    l[2:5] = [20, 30]
    l
    # [0, 1, 20, 30, 5, 6, 7, 8, 9]

    del l[5:7]
    l
    # [0, 1, 20, 30, 5, 8, 9]

    l[3::2] = [11, 22]
    l
    # [0, 1, 20, 11, 5, 22, 9]

    l[2:5] = 100
    l
    # TypeError: can only assign an iterable

    l[2:5] = [100]
    l
    # [0, 1, 100, 22, 9]
  #+END_SRC
  * =from Jian=
    mypy can detect the ~typeError~ of ~l[2:5] = 100~.

*** DONE Using ~+~ and ~*~ with Sequences - 50
CLOSED: [2025-07-03 Thu 01:33]
- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  *TRAP*:
  Suppose ~a~ is a sequence containing _mutable items_, and ~n~ is greater
  than 1.

  The result will contain ~n~ reference to the _mutable items_, and the
  consequence is:
  when you mutate one of this kind of item, the ones refer to it will also
  change -- acutally, the are just images to the mutated item.

**** DONE Building Lists of Lists - 51
CLOSED: [2025-07-03 Thu 01:34]
Use the /list comprehension/.
#+BEGIN_SRC python
  board = [['_'] * 3 for i in range(3)]
  board
  # [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]

  board[1][2] = 'X'
  board
  # [['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]
#+END_SRC

- =TODO= next subsection
  The ~+=~ and ~*=~ operators produce very different results depending on the
  _mutability_ of the target sequence.

- *TIP*:
  =TODO=
  _Chapter 6_ was written to clarify the *mechanics* and *pitfalls* of
  /references/ and /mutable objects/.

**** DONE Augmented Assignment with Sequences - 53
CLOSED: [2017-09-10 Sun 01:34]
The /augmented assignment/ operators ~+=~ and ~*=~ behave VERY DIFFERENTLY
depending on _the FIRST operand_.

To simplify the discussion, we will focus on augmented addition first (~+=~),
but the concepts also apply to ~*=~ and to other augmented assignment
operators.

- =Important=
  =FROM JIAN= I THINK THIS IS A EXTREMELY BAD DESIGN!!!
  _MY REASONS_?????????? =TODO=
  The fallback of ~__iadd__~ (~__imul__~) is ~__add__~ (~__mul__~)!!!
  #+BEGIN_SRC python
    ## a mutable object
    l = [1, 2, 3]
    id(l)
    # 4311953800

    l *= 2
    l
    # [1, 2, 3, 1, 2, 3]

    id(l)
    # 4311953800
    ### Unchanged

    ## a immutable object, no in-place operation implemented, fallback to
    ## non-in-place operations.
    t = (1, 2, 3)
    id(t)
    # 4312681568

    t *= 2
    id(t)
    # 4301348296
    ### changed
  #+END_SRC

- Repeated concatenation of immutable sequences is inefficient, because
  instead of just appending new items, the interpreter has to copy the whole
  target sequence to create a new one with the new items concatenated.3

  =FROM JIAN= WHY NOT USE implement with /persistence/ as Scala???

  - footnote:
    ~str~ is an exception to this description.
    Because string building with ~+=~ in loops is so common in the wild,
    CPython is optimized for this use case. ~str~ instances are allocated in
    memory with room to spare, so that concatenation does NOT require
    copying the whole string every time.

**** DONE A ~+=~ Assignment Puzzler - 54 - =Review NOTE=
CLOSED: [2017-09-10 Sun 01:34]
#+BEGIN_SRC python
  t = (1, 2, [30, 40])
  t[2] += [50, 60]

  # Traceback (most recent call last):
  #   File "<stdin>", line 1, in <module>
  # TypeError: 'tuple' object does not support item assignment

  t
  # (1, 2, [30, 40, 50, 60])
#+END_SRC

- Details ...... (disassemble the Python bytecode)

- Conclusion:
  * Putting mutable items into a supposed immutable objects (e.g. tuple), is
    _NOT_ a good idea.

  * /Augmented assignment/ is _NOT_ an /atomic operation/ -- we just saw it
    throwing an exception after doing part of its job.

  * Inspecting Python bytecode is NOT too DIFFICULT, and is often helpful to
    see what is going on under the hood.

*** DONE ~list.sort~ Versus the ~sorted~ Built-In - 56
CLOSED: [2017-09-10 Sun 00:25]
- Python API convention: the value a in-place operation returns should be
  ~None~. For example, ~list.sort~ and ~random.shuffle~.

- In-palce operation returns ~None~, and thus cascade calls can be applied
  any more.

- Read "Fluent interface" entry in wiki. =TODO=

- ~sorted~ accepts any iterable object as an argument, including generators
  (see Chapter 14). =TODO=

- Both list.sort and sorted take two optional, keyword-only arguments:
  * ~reverse~: The default is ~False~.
  * ~key~: ......

- The _standard binary search algorithm_ is already provided in the ~bisect~
  module of the Python standard library.
  =IMPORTANT=

- ~bisect.insort~: use it to make sure that your sorted sequences stay
  sorted.
  =TODO= =???=

*** DONE [REMOVED] Managing Ordered Sequences with ~bisect~ - 44
CLOSED: [2020-04-22 Wed 01:21]
- The ~bisect~ module offers two main functions that exploit the /binary
  search algorithm/:
  * ~bisect~
  * ~insort~

**** DONE Searching with ~bisect~ - 44
CLOSED: [2020-04-22 Wed 01:21]
- ~bisect(haystack, needle)~
  returns the index that all the elements include the one at the returned
  index are less than or equal to the ~needle~.

- TODO =TRY it= TODO
  Raymond Hettinger -- a prolific Python contributor -- has a
  _Sorted Collection recipe_ that leverages the ~bisect~ module
  BUT is _easier_ to use than these standalone functions.

- The ~bisect~ function is an alias of ~bisect_right~.
  There is also an ~bisect_left~.
  * The difference between them is when the ~needle~ equals a value in haystack,
    + When using ~bisect~ / ~bisect_right~, insert it to the _right_.
    + When using ~bisect_left~, insert it to the _left_.

- Read
  _Example 2-17. bisect finds insertion points for items in a sorted sequence_

- Interesting example (Example 2-18) from _the ~bisect~ module documentation_.
  #+begin_src python
    def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
        i = bisect.bisect(breakpoints, score)
        return grades[i]

    [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]
    # ['F', 'A', 'C', 'C', 'B', 'A', 'A']
  #+end_src

**** DONE Inserting with ~bisect.insort~ - 47
CLOSED: [2020-04-22 Wed 01:21]
~insort(seq, item)~ inserts ~item~ into seq so as to keep ~seq~ in _ascending
order_.

- Example 2-19. Insort keeps a sorted sequence always sorted.
  #+begin_src python
    import bisect
    import random

    SIZE = 7

    random.seed(1729)

    my_list = []
    for i in range(SIZE):
        new_item = random.randrange(SIZE * 2)
        bisect.insort(my_list, new_item)
        print(f'{new_item:>2d} -> {my_list}')
  #+end_src

- Like ~bisect~, ~insort~ takes _optional_ ~lo~, ~hi~ arguments to _LIMIT
  the search to a subsequence_.

- There is also an ~insort_left~ variation that uses ~bisect_left~ to find
  insertion points.

- Python programmers sometimes overuse the ~list~ type because it is so handy
  -- I know I’ve done it.
  TODO next section TODO
    If you are handling _lists of numbers_, /arrays/ are the way to go. The
  remainder of the chapter is devoted to them.

*** TODO When a List Is Not the Answer - 59 - =START HERE=
- For specific requirements, there are better options than ~list~:
  * Store 10 million floating-point values, an ~array~ is much more efficient.
      Just like the /array/ in Python's host language C, Python's ~array~ is
    very compact in memory.

  * For a sequence that need to operate its two ends frequently, use ~deque~.

**** DONE Arrays - 59
CLOSED: [2020-04-22 Wed 01:55]
- ~array.array~ supports
  + all mutable sequence operations (including ~.pop~, ~.insert~, and ~.extend~)
  + Fast loading and saving such as ~.frombytes~ and ~.tofile~

- Create an array with typecode like:
  ~array('b')~, where ~'b'~ is the typecode for *signed char*. Each item must
  be a single byte (from -128 to 127).

- Example 2-20. Creating, saving, and loading a large array of floats
  #+begin_src python
    from array import array
    from random import random

    floats = array('d', (random() for i in range(10**7)))
    floats[-1]  # 0.07802343889111107
    floats.tofile(open('floats.bin', 'wb'))

    floats2 = array('d')
    floats.fromfile(open('floats.bin', 'rb'), 10**7)
    floats2[-1]  # 0.07802343889111107

    floats2 == floats  # True
  #+end_src

- ~pickle.dump(array)~ is almost as fast as with ~array.tofile~.
    However, the difference is ~pickle.dump~ can also handle almost all
  built-in types automatically.

- TODO CHAPTER 4 TODO
  For the specific case of numeric arrays representing binary data, such as
  raster images, Python has the bytes and bytearray types discussed in
  Chapter 4.

- Table 2-2. Methods and attributes found in list or array (deprecated array
  methods and those also implemented by object were omitted for brevity)
  TODO =RE-READ=

- As of Python 3.4, ~array~ doesn't have in place sort method.
  Use ~a = array.array(a.typecode, sorted(a))~

**** TODO Memory Views - 62
**** TODO NumPy - 64
**** TODO Deques and Other Queues - 67

*** TODO Chapter Summary - 70
*** TODO Further Reading - 71

** TODO 3. Dictionaries and Sets - 77 - =START HERE 2=
- =NOTE= =TODO=

- ~__builtins__.__dict__~ stores *ALL built-in* /types/, /objects/, and
  /functions/.

- =NOTE= =TODO=

*** TODO What's New in This Chapter - 78
- Most changes in this second edition cover new features related to /mapping
  types/:
  * "Modern dict Syntax" on page 78 covers
    + /ENHANCED unpacking syntax/ and
    + different ways of _merging mappings_ --
      INCLUDING the ~|~ and ~|=~ operators supported by ~dict~'s _since Python
      3.9._

  * "Pattern Matching with Mappings" on page 81 illustrates handling mappings
    with ~match/case~, _since Python 3.10._

  * "~collections.OrderedDict~" on page 95 now focuses on the small but still
    relevant differences between ~dict~ and ~OrderedDict~ -- considering that
    ~dict~ *keeps the _key insertion order_ since Python 3.6.*

  * New sections on the /view objects/ returned by ~dict.keys~, ~dict.items~,
    and ~dict.values~:
    + "Dictionary Views" on page 101 and
    + "Set Operations on dict Views" on page 110.

- The underlying implementation of dict and set still relies on hash tables, but
  the dict code has two important optimizations that save memory and preserve
  the insertion order of the keys in dict. “Practical Consequences of How dict
  Works” on page 102 and “Practical Consequences of How Sets Work” on page 107
  summarize what you need to know to use them well.

- =NOTE=:
  After adding more than 200 pages in this second edition, I moved the optional
  section "Internals of sets and dicts" to the [[fluentpython.com][fluentpython.com]] companion
  website. The updated and expanded 18-page post includes explanations and
  diagrams about:
  * The hash table algorithm and data structures, starting with its use in set,
    which is simpler to understand.
  * The memory optimization that preserves key insertion order in dict instances
    (since Python 3.6).
  * The key-sharing layout for dictionaries holding instance attributes—the
    __dict__ of user-defined objects (optimization implemented in Python 3.3).

*** DONE Modern ~dict~ Syntax - 78
CLOSED: [2025-07-09 Wed 15:35]
The next sections describe _advanced syntax features_ to *build*, *unpack*, and
*process* /mappings/.

**** DONE ~dict~ Comprehensions - 79
CLOSED: [2025-07-09 Wed 15:31]
**** DONE Unpacking Mappings - 80
CLOSED: [2025-07-09 Wed 15:31]
#+begin_src python
  ## 1
  def dump(**kwargs):
      return kwargs


  dump(**{'x': 1}, y=2, **{'z': 3})
  # {'x': 1, 'y': 2, 'z': 3}


  ## 2
  {'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}}
  # {'a': 0, 'x': 4, 'y': 2, 'z': 3}
#+end_src
In the ~## 2~ case, duplicate keys are allowed --
later occurrences *overwrite* previous ones -- see the value mapped to ~x~ in
the example.

**** DONE Merging Mapping with ~|~ - 80
CLOSED: [2025-07-09 Wed 15:32]
~|~ and ~|=~

- *Tip*:
  If you need to maintain code to run on Python 3.8 or earlier,
  the _"Motivation"_ section of
  _PEP 584—Add Union Operators To dict_ provides a good summary of other ways to
  merge mappings.

*** DONE Pattern Matching with Mappings - 81
CLOSED: [2025-07-10 Thu 11:15]
- Patterns for mappings look like ~dict~ literals, but they can match instances
  of _ANY *actual or virtual* /subclass/ of ~collections.abc.Mapping~._
  * footnote 1:
    =IMPORTANT=
    A /virtual subclass/

    + ANY /class/ registered by calling the ~.register()~ method of an ~ABC~,
      =TODO=
      =TODO=
      =TODO=
      =IMPORTANT=
      =IMPORTANT=
      =IMPORTANT=
      as explained in "A Virtual Subclass of an ABC" on page 460.

    + A /type/ implemented via _Python/C API_ is also eligible if a specific
      marker bit is set. See ~Py_TPFLAGS_MAPPING~.

- Example 3-2. creator.py: get_creators() extracts names of creators from mediarecords
  #+begin_src python
    def get_creators(record: dict) -> list:
        match record:
            case {'type': 'book', 'api': 2, 'authors': [*names]}:
                return names
            case {'type': 'book', 'api': 1, 'author': name}:
                return [name]
            case {'type': 'book'}:
                raise ValueError(f"Invalid 'book' record: {record!r}")
            case {'type': 'movie', 'director': name}:
                return [name]
            case _:
                raise ValueError(f'Invalid record: {record!r}')
  #+end_src

- In contrast with /sequence patterns/, /mapping patterns/ *succeed on partial
  matches.*

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  There is _NO NEED_ to use ~**extra~ to match extra key-value pairs,
  BUT
  if you want to _capture_ them as a ~dict~, you can prefix one variable with ~**.~
  * _RESTRICTION_:
    + It MUST BE _the *last* in the pattern_, and
    + ~**_~ is forbidden because it would be redundant.

- =TODO= =RE-READ=
  In _"Automatic Handling of Missing Keys"_ on page 90 we'll study ~defaultdict~
  and other mappings where key lookups via ~__getitem__~ (i.e., ~d[key]~)
  succeed because missing items are created on the fly.

  * *In the context of pattern matching,*
    a ~match~ succeeds _only if_ the subject already has the required keys at
    the top of the match statement.
    #+begin_src python
      s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
      d = defaultdict(list)
      for k, v in s:
          d[k].append(v)


      match d:
          case {'missing': _}:
              print('missing')
          case {'yellow': _}:
              print('yellow')
          case _:
              print('...')

      # yellow
    #+end_src

- *TIP*
  The automatic handling of missing keys is not triggered because /pattern
  matching/ *always uses* the ~d.get(key, sentinel)~ method --
  =IMPORTANT=
  where the *default sentinel* is a _special marker value_ that cannot occur in
  user data.

*** TODO Standard API of Mapping Types - 83 - =REVIEW=
The ~collections.abc~ module provides the ~Mapping~ and ~MutableMapping~
ABCs describing the interfaces of ~dict~ and similar types.

- Figure 3-1. Simplified UML class diagram for the ~MutableMapping~ and its
  /superclasses/ from ~collections.abc~ (inheritance arrows point from
  /subclasses/ to /superclasses/; names in italic are /abstract classes/ and
  /abstract methods/).
  =IMPORTANT=

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  To implement a *custom mapping*, it's easier to extend ~collections.UserDict~,
  or to wrap a ~dict~ _by composition_, instead of *subclassing* these ~ABC~'s.

  The ~collections.UserDict~ /class/ and all _concrete mapping classes_ in the
  standard library encapsulate the basic ~dict~ in their implementation, which
  in turn is built on a hash table. Therefore, they all share the limitation
  that *the keys must be hashable*. If you need a refresher, the next section
  explains.

**** DONE What Is Hashable - 84 - =IMPORTANT= - =REVIEW=
CLOSED: [2025-07-10 Thu 12:08]
~__hash__()~

- /Numeric types/ and /flat immutable types/ ~str~ and ~bytes~ are all
  /hashable/.

  * /Container types/ are /hashable/
    IF
    + they are immutable and
    + all contained objects are also /hashable/.

- A ~frozenset~ is always /hashable/,
  BECAUSE
  every element it contains must be /hashable/ by definition.

- The /hash code/ of an object may be _DIFFERENT depending on_
  * the version of Python,
  * the machine architecture, and
  * because of a /salt/ added to the hash computation for *security reasons*.
    + footnote 3:
      _See PEP 456 -- Secure and interchangeable hash algorithm_ to learn about
      the security implications and solutions adopted.

- =IMPORTANT=
  The /hash code/ of a correctly implemented object is
  _GUARANTEED_ to be *constant only within _one Python process_.*

- /User-defined types/ are *hashable by default*
  BECAUSE their hash code is their ~id()~, and the ~__eq__()~ method inherited
  from the ~object~ class simply compares /the ~object~ IDs/.

- If an object implements a custom ~__eq__()~ that takes into account its
  _internal state_,
  it will be hashable *only if* its ~__hash__()~ always returns the same /hash
  code/.

  * In practice, this REQUIRES that ~__eq__()~ and ~__hash__()~
    *only take into account instance attributes that never change during the
    life of the object.*

**** TODO Overview of Common Mapping Methods - 85 - =IMPORTANT= - =REVIEW=
Table 3-1.

**** DONE Inserting or Updating Mutable Values - 87
CLOSED: [2025-07-10 Thu 13:50]
- ~a_dict.setdefault(word, []).append(location)~
  is equivalent to
  #+begin_src python
    if key not in a_dict:
        a_dict[key] = []
    a_dict[key].append(new_value)
  #+end_src

- =NEXT=
  A related issue, _handling missing keys on any lookup (and not only when
  inserting),_ is the subject of the next section.

*** DONE Automatic Handling of Missing Keys - 90
CLOSED: [2025-07-11 Fri 12:28]
- Sometimes it is convenient to have /mappings/ that
  _RETURN_ some made-up value when a missing key is searched.

  There are two main approaches to this:
  * One is to use a ~defaultdict~ instead of a plain ~dict~.
  * The other is to *subclass* /dict/ or any other /mapping type/ and add a
    ~__missing__~ method.

- Both solutions are covered next.

**** ~defaultdict~: Another Take on Missing Keys - 90
- If no ~default_factory~ is provided, the usual ~KeyError~ is raised for
  missing keys.

- *CAUTION*
  The ~default_factory~ of a ~defaultdict~ is only invoked to provide default
  values for ~__getitem__~ calls, and not for the other methods. For example,
  * if dd is a ~defaultdict~, and ~k~ is a missing key, ~dd[k]~ will call the
    ~default_factory~ to create a default value,

  * but ~dd.get(k)~ still returns ~None~, and ~k~ in dd is ~False~.

- The mechanism that makes ~defaultdict~ work by calling ~default_factory~ is
  the ~__missing__~ special method, a feature that we discuss next.

**** The ~__missing__~ Method - 91
**** Inconsistent Usage of ~__missing__~ in the Standard Library - 94 - =RE-READ=
- Consider the following scenarios, and _how the MISSING KEY lookups are
  affected_:
  =TODO=
  =REVIEW=
  * ~dict~ subclass
  * ~collections.UserDict~ subclass
  * ~abc.Mapping~ subclass with the simplest possible ~__getitem__~
  * ~abc.Mapping~ subclass with ~__getitem__~ calling ~__missing__~

*** TODO Variations of ~dict~ - 95
**** TODO ~collections.OrderedDict~ - 95 - =NOTE=
**** DONE ~collections.ChainMap~ - 95
CLOSED: [2025-07-11 Fri 12:37]
#+begin_src python
  from collections import ChainMap


  d1 = dict(a=1, b=3)
  d2 = dict(a=2, b=4, c=6)

  chain = ChainMap(d1, d2)

  chain['a'] # 1
  chain['c'] # 6

  chain['c'] = -1

  d1  # {'a': 1, 'b': 3, 'c': -1}
  d2  # {'a': 2, 'b': 4, 'c': 6}
#+end_src

A ~ChainMap~ instance holds _a list of mappings_ that can be searched *as one*.

- The lookup is performed on each input mapping in the order it appears in the
  constructor call, and it returns the first one it sees.

- The ~ChainMap~ instance does
  * *not copy* the input mappings,
  * but *holds* references to them.

- The insertion only affect the _FIRST_ input mapping.

**** DONE ~collections.Counter~ - 96
CLOSED: [2025-07-11 Fri 12:46]
~collections.Counter~ is a mapping that holds an integer count for each key.

- Updating an existing key adds to its count.

  This can be used to count instances of hashable objects or as a multiset
  (discussed later in this section).

- ~Counter~ implements the ~+~ and ~-~ operators to combine tallies, and other
  useful methods such as ~most_common([n])~, which returns an ordered list of
  tuples with the ~n~ most common items and their counts.

- Example: Here is ~Counter~ used to count letters in words
  #+begin_src python
    ct = collections.Counter('abracadabra')
    ct # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

    ct.update('aaaaazzz')
    ct # Counter({'a': 10, 'z': 3, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

    ct.most_common(3) # [('a', 10), ('z', 3), ('b', 2)]
  #+end_src
  =CAUTION=
  =IMPORTANT=
  Note that the ~'b'~ and ~'r'~ keys are tied in third place, but
  ~ct.most_common(3)~ shows only three counts, no ~'r'~.

**** TODO ~shelve.Shelf~ - 97
**** TODO Subclassing ~UserDict~ Instead of ~dict~ - 97

*** DONE Immutable Mappings - 99
CLOSED: [2017-09-08 Fri 20:16]
Since Python 3.3, the ~types~ module provides a wrapper class called
~MappingProxyType~, which, given a mapping, returns a ~mappingproxy~ instance
that is a _read-only_ but _dynamic view_ of the original mapping -- updates
to the original mapping can be seen in the ~mappingproxy~, but changes CANNOT
be made through it. (=FROM JIAN= Consider this as a immutable reference to
the original map)
#+BEGIN_SRC python
  from types import MappingProxyType
  d = {'one': 'A'}
  d_proxy = MappingProxyType(d)

  d_proxy
  # mappingproxy({'one': 'A'})

  d_proxy['one']
  # 'A'

  d_proxy['two'] = 'B'
  ## TypeError: ...

  d['two'] = 'B'
  d_proxy
  # mappingproxy({'one': 'A', 'two': 'B'})

  d_proxy['two']
  # 'B'
#+END_SRC

*** TODO Dictionary Views - 101
*** TODO Practical Consequences of How ~dict~ Works - 102
*** TODO Set Theory - 103
**** Set Literals - 105
**** Set Comprehensions - 106

*** TODO Practical Consequences of How Sets Work - 107
**** Set Operations - 107

*** TODO Set Operations on ~dict~ Views - 110
*** TODO Chapter Summary
*** TODO Further Reading

** TODO 4. Unicode Text versus Bytes - 117
*** TODO What's New in This Chapter - 118
*** TODO Character Issues - 118
*** TODO Byte Essentials - 120
*** TODO Basic Encoders/Decoders 123
*** TODO Understanding Encode/Decode Problems - 125
**** Coping with ~UnicodeEncodeError~ - 125
**** Coping with ~UnicodeDecodeError~ - 126
**** SyntaxError When Loading Modules with Unexpected Encoding - 128
**** How to Discover the Encoding of a Byte Sequence - 128
**** BOM: A Useful Gremlin - 129

*** TODO Handling Text Files - 131
**** Beware of Encoding Defaults - 134

*** TODO Normalizing Unicode for Reliable Comparisons - 140
**** Case Folding - 142
**** Utility Functions for Normalized Text Matching - 143
**** Extreme "Normalization": Taking Out Diacritics - 144

*** TODO Sorting Unicode Text - 148
**** Sorting with the Unicode Collation Algorithm - 150

*** TODO The Unicode Database - 150
**** TODO Finding Characters by Name - 151
**** TODO Numeric Meaning of Characters - 153

*** TODO Dual-Mode ~str~ and ~bytes~ APIs - 155
**** ~str~ Versus bytes in Regular Expressions - 155
**** ~str~ Versus bytes on ~os~ Functions - 156

*** TODO Chapter Summary - 157
*** TODO Further Reading - 158

** TODO 5. Data Class Builders - 163
- data class :: (conceptually, NOT ~dataclasses.dataclass~)
  a *simple* /class/ that is just
  * a bunch of /fields/
  * with LITTLE OR NO extra funcionality

- Python offers a few ways to build /data classes/, and ~dataclass~ is the name
  of a /Python decorator/ that supports it.
    This chapter covers _THREE_ DIFFERENT /class builders/ that you may use as
  shortcuts to write /data classes/:
  * ~collections.namedtuple~: the simplest way since Python _2.6_;

  * ~typing.NamedTuple~: an alternative that allows /type annotations/ on the
    fields -- since Python _3.5_; ~class~ syntax supported since _3.6_;

  * ~@dataclasses.dataclass~: a /class decorator/ that allows *more customization
    than previous alternatives*, adding lots of options and potential complexity
    -- since Python _3.7_.

- =TODO= ??? =TODO=
  _AFTER_ covering those /class builders/,
  we will discuss why /Data Class/ is also the name of a *code smell*:
  a coding pattern that may be *a symptom of poor object-oriented design.*
  * footnote 1:
    From Refactoring, first edition, Chapter 3, “Bad Smells in Code, Data Class”
    section, page 87 (Addison-Wesley).

- The chapter ends with a section on a very different topic, but still closely
  related to _record-like data_: the ~struct~ module, designed to PARSE and
  BUILD *packed binary records* that you may find in legacy flat-file _databases_,
  _network protocols_, and _file headers_.
  TODO ??? TODO

- *NOTE*
  =TODO=
  =TODO=
  =TODO=
  ~typing.TypeDict~ (since Python _3.8_) may seem like another /data class
  builder/ -- it's described right after ~typing.NamedTuple~ in the ~typing~
  module documentation, and uses similar syntax.
    However, ~TypedDict~ does not build concrete classes that you can
  instantiate. It's just a way to write /static annotations/ for variables and
  function arguments that are expected to accept plain dictionaries with a
  fixed set of keys and a specific type for the value mapped to each key.

*** DONE What's New in This Chapter - 164
CLOSED: [2020-04-27 Mon 02:52]
This chapter is new in Fluent Python 2nd edition.
- The sections _"Classic Named Tuples"_ and _"Structs and Memory Views"_
  appeared in chapters 2 and 4 in the 1st edition,

- but _the rest of the chapter is completely new._

*** DONE Overview of Data Class Builders - 164
CLOSED: [2020-04-26 Sun 20:38]
- The /data class builders/ covered in this chapter provide the necessary
  ~__init__~, ~__repr__~, and ~__eq__~ /methods/ *automatically*, as well as
  other useful features.
  + =from Jian= Just be similar to /case classes/ in Scala.

- NOTE
  None of the class builders discussed here depend on inheritance to do
  their work.
  + Both ~collections.namedtuple~ and ~typing.NamedTuple~
    build /classes/ that are /tuple/ /subclasses/.

  + ~@dataclass~ is a /class decorator/ that does _NOT affect the /class
    hierarchy/ in any way_.

  + Each of them use *different* _metaprogramming techniques_ to _INJECT /methods/
    and /data attributes/ INTO the class under construction_.

- Use ~namedtuple~
  #+begin_src python
    from collections import namedtuple


    Coordinate = namedtuple('Coordinate', 'lat long')
    issubclass(Coordinate, tuple)  # True
    moscow = Coordinate(55.756, 37.617)
    moscow  # Coordinate(lat=55.756, long=37.617)
    moscow == Coordinate(lat=55.756, long=37.617)  # True
  #+end_src

- Use ~typing.NamedTuple~
  + Before Python 3.6, no extra funcionality:
    #+begin_src python
      from typing


      Coordinate = typing.NamedTuple('Coordinate', [('lat', float),  ('long', float)])
      issubclass(Coordinate, tuple)  # True
      Coordinate.__annotations__
      # {'lat': <class 'float'>, 'long': <class 'float'>}
    #+end_src

    * *TIP*
      Another (more readable) syntax for ~typing.NamedTuple~
      #+begin_src python
        Coordinate = typing.NamedTuple('Coordinate', lat=float, long=float)
      #+end_src

  + Since Python 3.6,
    ~typing.NamedTuple~ can also be used in a ~class~ statement, with /type
    annotations/ written as described in *PEP 526 -- Syntax for Variable
    Annotations*.
    * This is much MORE READABLE, and
      makes it easy to _override methods_ or _add new ones_.

    * Example 5-2 is the same ~Coordinate~ class, with a pair of ~float~ attributes
      and a custom ~__str__~ to display a coordinate formatted like 55.8°N, 37.6°E:
      #+begin_src python
        from typing import NamedTuple

        class Coordinate(NamedTuple):

            lat: float
            long: float

            def __str__(self):
                ns = 'N' if self.lat >= 0 else 'S'
                we = 'E' if self.long >= 0 else 'W'
                return f"{abs(self.lat):.1f}°{ns}, {abs(self.long):.1f}°{we}"
      #+end_src
      - *WARNING*
        Although ~NamedTuple~ appears in the class statement as a superclass, it’s
        actually not. typing.NamedTuple uses the advanced functionality of a
        metaclass2 to customize the creation of the user’s class. Check this out:
        #+begin_src python
          issubclass(Coordinate, typing.NamedTuple)  # False
          issubclass(Coordinate, tuple)              # True
        #+end_src
        In the ~__init__~ /method/ *generated* by ~typing.NamedTuple~, the /fields/
        appear as parameters _in the SAME ORDER they appear in the /class statement/._

- Use ~dataclass~
  _Like ~typing.NamedTuple~, the /dataclass decorator/ supports *PEP 526* syntax to
  declare instance attributes._ The /decorator/ reads the variable annotations
  and automatically generates methods for your class.
  #+begin_src python
    from dataclasses import dataclass


    @dataclass(frozen=True)
    class Coordinate:
        lat: float
        long: float
  #+end_src
  + Note that the body of the classes in Example 5-2 and Example 5-3 are
    identical—the difference is in the class statement itself.

  + The ~@dataclass~ /decorator/ does *NOT depend on* /inheritance/ or a
    /metaclass/, so it should not interfere with your own use of these
    mechanisms.
    #+begin_src python
      issubclass(Coordinate, typing.NamedTuple)  # False
      issubclass(Coordinate, tuple)              # False
      issubclass(Coordinate, object)             # True
    #+end_src

**** Main Features - 167
The different data class builders have a lot of common. Here we’ll discuss
the main features they share. Table 5-1 summarizes.
- Table 5-1. =IMPORTANT= =RE-READ=
  Selected features compared accross the THREE /data class builders/. ~x~
  stands for an instance of a /data class/ of that kind.

*** DONE Classic Named Tuples - 169
CLOSED: [2020-04-27 Mon 02:52]
- *TIP*
  . EACH /instance/ of a /class/ built by ~namedtuple~ takes *EXACTLY the SAME
    amount of memory* a ~tuple~ because the /field names/ are stored in the
    /class/ (rather than in each /instance/).

  . They use *LESS memory than a regular object (=from Jian= /class/ based
    object?)* because they do *NOT* store attributes as key-value pairs in
    one ~__dict__~ for EACH /instance/.

- Besides the methods a ~tuple~ has, a ~namedtuple~ also has ~_fields~ /class
  attribute/, the /class method/ ~_make(iterable)~, and the /instance method/
  ~_asdict()~.
  . ~._asdict()~ is useful to serialize the data in JSON format, for example.
    TODO =LEARN MORE= TODO

- *WARNING*
  . The ~_asdict()~ /method/ returned an ~OrderedDict~ in
    _Python 2.7_, and in _Python 3.1 TO 3.7_.

  . Since _Python 3.8_, a regular ~dict~ is returned -- which is probably fine
    now that we *can rely on* _key insertion order_ (because of the new
    implementation of ~dict~).

  . If you must have an ~OrderedDict~ when you use _Python 3.8+_, the ~_asdict~
    documentation recommends building one from the result:
    ~OrderedDict(x._asdict())~.

- Since Python 3.7, namedtuple accepts the ~defaults~/ keyword-only argument/
  providing an /iterable/ of _N default values for each of the N *rightmost*
  fields_ of the /class/.
  . Example 5-6 show how to define a ~Coordinate~ ~namedtuple~ with a ~default~
    value for a reference field:
    #+begin_src python
      Coordinate = namedtuple('Coordinate', 'lat long reference', defaults=['WGS84'])
      Coordinate(0, 0)            # Coordinate(lat=0, long=0, reference='WGS84')
      Coordinate._field_defaults  # {'reference': 'WGS84'}
    #+end_src

- There are straight forward ways to add methods to ~typing.NamedTuple~ and
  ~@dataclass~ annotated /class/. For ~namedtuple~, we can also do this, but
  must with some hack. See below!

- *HACKING A NAMEDTUPLE TO INJECT A METHOD*
  Define a function and then assign it to a /class attribute/.
  #+begin_src python
    Card = collections.nametuple('Card', ['rank', 'suit'])

    # Attach a class attribute with values for each suit.
    Card.suit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0)

    def spades_high(card):
        rank_value = FrenchDeck.ranks.index(card.rank)
        suit_value = card.suit_values[card.suit]
        return rank_value * len(card.suit_values) + suit_value

    # Attach the spades_high function to the Cards class.
    # It becomes a method named overall_rank.
    Card.overall_rank = spades_high

    lowest_card = Card('2', 'clubs')
    highest_card = Card('A', 'spades')

    lowest_card.overall_rank()  # 0
    highest_card.overall_rank()  # 51
  #+end_src
  * =from Jian=
    From the observation, the ~overall_rank~ use ~self~ as the ~card~ for
    ~spades_high~. ~overall_rank~ is an /instance method/.
    + TODO Learn more about this!
      1. Can ~spades_high~ take more parameters?
      2. Do the parameters _except the first one_ are considered as normal
         /method parameters/?

*** DONE Typed Named Tuples - 172
CLOSED: [2020-04-27 Mon 02:58]
- Example 5-8. ~typing.NamedTuple~
  #+begin_src python
    from typing import NamedTuple


    class Coordinate(NamedTuple):
        lat: float
        long: float
        reference: str = 'WGS84'
  #+end_src

- /Classes/ built by ~typing.NamedTuple~ _do NOT have any methods BEYOND_
  those that ~collections.namedtuple~ also generates -- and those that are
  inherited from ~tuple~.
  * _The Only difference AT RUNTIME_ is the presence of the ~__attributes__~
    /class field/ -- _which Python completely ignores AT RUNTIME._

- *WARNING*
  * BEFORE Python 3.8, classes built with ~typing.NamedTuple~ also have a
    ~_field_types~ /attribute/.

  * SINCE Python 3.8, that /attribute/ is *deprecated* in favor of
    ~__annotations__~ which has the same information and is the _canonical
    place_ to find /type hints/ in Python objects that have them.

*** TODO Type Hints 101 - 173
- /Type hints/ -- a.k.a. /type annotations/

- NOTE
  TODO No complete info for this Early Release version.
  Talk about type hints for function signatures and advanced annotations in
  the future.

**** DONE No Runtime Effect - 173
CLOSED: [2020-04-26 Sun 20:55]
- Example 5-9. Python does not enforce type hints at runtime.
  #+begin_src python
    import typing


    class Coordinate(typing.NamedTuple):
        lat: float
        long: float


    trash = Coordinate('foo', None)
    print(trash)
    # Coordinate(lat='foo', long=None)
  #+end_src

- The /type hints/ are intended primarily to support *third-party* /type
  checkers/.

- If we run ~mypy nocheck_demo.py  # The code includes the Example 5-9 code~,
  we can see:
  #+begin_src note
  nocheck_demo.py:8: error: Argument 1 to "Coordinate" has
  incompatible type "str"; expected "float"
  nocheck_demo.py:8: error: Argument 2 to "Coordinate" has
  incompatible type "None"; expected "float"
  #+end_src

**** DONE Variable Annotation Syntax - 174
CLOSED: [2020-04-26 Sun 21:00]
- The type that goes after the ~:~ must be an _identifier_ for one of these
  (See Acceptable /type hints/ in *PEP 484* for all details):
  * a *concrete* /class/, for example ~str~ or ~FrenchDeck~;

  * an ABC -- /abstract base class/;

  * a type defined in the ~typing~ module, including special types and
    constructs like ~Any~, ~Optional~, ~Union~, etc.;

  * a /type alias/ -- as described in the ~Type~ aliases section of the
    ~typing~ module documentation.

**** TODO The Meaning of Variable Annotations - 175
- We saw in "No runtime effect" that /type hints/ have *NO* _effect at runtime_.
  But _at import time_ -- when a module is loaded -- Python does read them
  to build the ~__annotations__~ dictionary that ~typing.NamedTuple~ and
  ~@dataclass~ then use to *enhance* the /class/.

- Example 5-10. =demo_plain.py=: a plain /class/ with /type hints/
  #+begin_src python
    class DemoPlainClass:
        a: int
        b: float = 1.1
        c = 'spam'
  #+end_src
  * Check the annotation:
    ~c~ is not annotated, and no info saved to ~__annotation__~.
    #+begin_src python
      from demo_plain import DemoPlainClass


      DemoPlainClass.__annotations__
      # {'a': <class 'int'>, 'b': <class 'float'>}

      DemoPlainClass.a
      ## Traceback (most recent call last):
      ##   File "<stdin>", line 1, in <module>
      ## AttributeError: type object 'DemoPlainClass' has no attribute 'a'

      DemoPlainClass.b  # 1.1

      DemoPlainClass.c  # 'spam'
    #+end_src

  * However, since ~a~ was not given a value and it can't become a /class
    attribute/ but annotated, this is why ~a~ info is in
    ~DemoPlainClass.__annotations__~, but we can't evaluate its value
    through ~DemoPlainClass.a~.

*** TODO More About ~@dataclass~ - 179
**** Field Options - 180
- WARNING

**** Post-init Processing - 183
- NOTE

**** Typed Class Attributes - 185
**** Initialization Variables That Are Not Fields - 186
**** ~@dataclass~ Example: Dublin Core Resource Record - 187

*** TODO Data class as a Code Smell - 190
- *CODE SMELL*

**** TODO Data Class as Scaffolding - 191
**** TODO Data Class as Intermediate Representation - 191

*** TODO Pattern Matching Class instances - 192
**** Simple Class Patterns - 192
**** Keyword Class Patterns - 193
**** Positional Class Patterns - 194

*** TODO Chapter Summary - 195
*** TODO Further Reading - 196
- *SOAPBOX*

** TODO 6. Object References, Mutability, and Recycling - 201
- =TODO=
  NOTE

- This is a rather dry chapter,
  =IMPORTANT=
  BUT its topics lie at the heart of *many subtle bugs in real Python programs.*

*** What's New in This Chapter - 202
*** Variables Are Not Boxes - 202
- Metaphor: think of /variables/
  AS
  /labels/ with names attached to /objects/.

- With reference variables, it makes much more sense to say that *the variable
  is assigned to an object,* and not the other way around -- for instance,
  we describe ~s = seesaw~ as "variable s is assigned to the seesaw".

- Because /variables/ are mere _labels_,
  nothing prevents an object from having *several* _labels_ assigned to it.

*** Identity, Equality, and Aliases - 204
- In /The Python Language Reference/, "3.1. Objects, values and types" states:
  #+begin_quote
  An /object's identity/ never changes once it has been created;
  you may think of it as the _object's address in memory_.

  The ~is~ operator compares the identity of two objects; the ~id()~ function
  returns an integer representing its identity.
  #+end_quote
  * The real meaning of an object's ID is *implementation dependent*.
    * In CPython, ~id()~ returns the memory address of the object.

  * The key point is that
    + the ID is guaranteed to be a *unique integer label*, and
    + it will *never change* DURING _the life of the /object/._

- In practice, we rarely use the ~id()~ function.
  Because we can use ~is~ to do the _identity check_, and extract the value of
  an object ID is not very useful in many cases.

- *NOTE*
  For tech reviewer Leonardo Rochael,
  *the most frequent use for ~id()~ is while debugging*:
  when the ~repr()~ of two objects look alike,
  BUT you need to understand whether two /references/ are aliases or point to
  separate objects.

  * If the references are in different contexts -- such as different stack
    frames -- using the ~is~ operator may not be viable.
    =TODO=
    =TODO=
    =TODO=
    =from Jian=
    I don't quite understand this!!!

**** Choosing Between ~==~ and ~is~ - 206
- The ~is~ operator is *faster than* ~==~,
  BECAUSE
  it CANNOT be overloaded, so Python does not have to find and invoke /special
  methods/ to evaluate it, and computing is as simple as comparing two integer
  IDs.

- ~==~ calls ~__eq__~.
  The ~__eq__~ from ~object~ compares object IDs.
  Most built-in types (=from Jian= and customized types) override it with more
  meaningful implementations -- in most scenarios, people want to compare
  /values/ instead of /identities/.

- *CAUTION*
  Mostly, you should pick ~==~.
  When you should use ~is~, you will know.
  * Two scenarios that often show up which use ~is~:
    + Compare with the singleton ~None~.
    + Compare between ~Enum~ /variants/.
      - If between a /variant/ and a string value, assume we use ~StrEnum~,
        use ~==~. Good news: if not, you'll see a warning!

**** The Relative Immutability of Tuples - 207

*** DONE Copies Are Shallow by Default - 208
CLOSED: [2025-07-04 Fri 13:30]
Visualize Python data structures, operations, and their memory layout after each
operation.
https://pythontutor.com/python-compiler.html#

A good practice, guess the data structures, operations, and their memory layout
after each operation:
#+begin_src python
  l1 = [3, [66, 55, 44], (7, 8, 9)]
  l2 = list(l1)
  l1.append(100)
  l1[1].remove(55)
  print('l1:', l1)
  print('l2:', l2)
  l2[1] += [33, 22]
  l2[2] += (10, 11)
  print('l1:', l1)
  print('l2:', l2)
#+end_src

**** Deep and Shallow Copies of Arbitrary Objects - 211
Copy recursively and deeply with the ~deepcopy()~ from the ~copy~ module.

- Note that,
  *IN THEORY*,
  _making deep copies is NOT A SIMPLE MATTER in the general case_ -- cyclic
  references that would cause a naïve algorithm to enter an infinite loop.

- *IN IMPLEMENTATION*,
  the ~deepcopy~ function remembers the objects already copied to handle /cyclic
  references/ gracefully. This is demonstrated in Example 6-10.
  * Example:
    #+begin_src python
      a = [10, 20]
      b = [a, 30]
      a.append(b)
      a  # [10, 20, [[...], 30]]
      from copy import deepcopy
      c = deepcopy(a)
      c
      # [10, 20, [[...], 30]]
    #+end_src

  * Another potential issue:
    *a deep copy may be too deep in some cases.*
    + For example,
      /objects/ may refer to /external resources/ or /singletons/ that should not be
      copied.

  * Use ~__copy__()~ and ~~__deepcopy__()~

*** DONE Function Parameters as References - 213
CLOSED: [2025-07-05 Sat 14:49]
- The only mode of parameter passing in Python is /call by sharing/.

  * The author says "the same mode used in most oo languages, including
    JavaScript, Ruby, and Java)." =from Jian= This is *not True*!!! I tried
    JavaScript and Scala (Java doesn't have this syntax), and none of them
    handle default parameter values that are mutable in the same way as Python.
    *This is a Python's bad design, no execuse!!!*

**** Mutable Types as Parameter Defaults: Bad Idea - 214
Python save parameter default values as /attributes/ of corresponding /function
object/, and share it across different calls that use default values instead
of passing in one.

#+begin_src python
  class HauntedBus:
      """A bus model haunted by ghost passengers"""
      def __init__(self, passengers=[]):
          self.passengers = passengers

      def pick(self, name):
          self.passengers.append(name)

      def drop(self, name):
          self.passengers.remove(name)


  bus = HauntedBus()


  dir(HauntedBus.__init__) # doctest: +ELLIPSIS
  # ['__annotations__', '__call__', ..., '__defaults__', ...]


  HauntedBus.__init__.__defaults__
  # (['Carrie', 'Dave'],)


  HauntedBus.__init__.__defaults__[0] is bus.passengers
  # True
#+end_src

**** Defensive Programming with Mutable Parameters - 216
Considert twice if you want to pass a mutable value to a function!
Should you copy it or not before or after passing it.

*** TODO ~del~ and Garbage Collection - 219 - =TODO= =RE-READ=
*** DONE Tricks Python Plays with Immutables - 221
CLOSED: [2025-07-05 Sat 16:13]
Many operations, which if applied on /mutable objects/ are copy, are not copy
when applying on /immutable objects/. This is a harmless trick -- no effect to
the end user.
#+begin_src python
  t1 = (1, 2, 3)
  t2 = tuple(t1) # or t1[:]
  t3 = (1, 2, 3)

  t3 is t2  # True
  t3 is t1  # False
#+end_src

- Because of this, your code shouldn't depends on /identity check (with ~is~)/
  between copies for /immutable objects/.

- Your code also shouldn't depends on the optimization technique called
  /interning/ -- means you should always do /value equality check (through
  ~==~)/ for values of ~int~ and ~str~.
  #+begin_src python
    s1 = 'ABC'
    s2 = 'ABC'
    s2 is s1  # True
  #+end_src
  * interning :: xxx
  * =IMPORTANT=
    The CPython does *NOT* intern all strings or integers, and the criteria it
    uses to do so is an *undocumented implementation detail*.

*** TODO Chapter Summary - 223
*** TODO Further Reading - 224

* TODO Part II. Functions as Objects
** DONE 7. Functions as First-Class Objects - 231
CLOSED: [2025-07-06 Sun 12:10]
- Programming language researchers define a /first-class object/ as a program
  entity that can be:
  * *Created at /runtime/*
  * *Assigned* to a /variable/ or _element_ in a _data structure_
  * *Passed* as an /argument/ to a /function/
  * *Returned* as the _result_ of a /function/

- This chapter and most of Part III
  EXPLORE
  the practical applications of treating *functions as objects.*

*** What's New in This Chapter - 232
*** Treating a Function Like an Object - 232
*** DONE Higher-Order Functions - 234
CLOSED: [2025-07-06 Sun 11:58]
**** Modern Replacements for map, filter, and reduce - 235

*** DONE Anonymous Functions - 236
CLOSED: [2025-07-06 Sun 11:58]
*** TODO The Nine Flavors of Callable Objects - 237 - =START=
- =TODO: NOTE=

- Tips:
  Given the variety of existing callable types in Python, the safest way to
  determine whether an object is callable is to use the ~callable()~ /built-in/:
  #+begin_src python
    [callable(obj) for obj in (abs, str, 'Ni!')]
    # [True, True, False]
  #+end_src

*** DONE User-Defined Callable Types - 239
CLOSED: [2025-07-06 Sun 00:17]
- Two main use cases:
  * A /class/ implementing ~__call__~ is an easy way to create /function-like
    objects/ that *have some _internal state_ that must be kept _across_
    invocations,* like the remaining items in the ~BingoCage~.
    #+begin_src python
      import random

      class BingoCage:
          def __init__(self, items):
              self._items = list(items)
              random.shuffle(self._items)

          def pick(self):
              try:
                  return self._items.pop()
              except IndexError:
                  raise LookupError('pick from empty BingoCage')

          def __call__(self):
              return self.pick()

      bingo = BingoCage(range(3))
      bingo.pick()     # 1
      bingo()          # 0
      callable(bingo)  # True
    #+end_src

  * Another good use case for ~__call__~ is implementing /decorators/.
    /Decorators/ must be /callable/, and it is sometimes convenient
    + to "remember" something between calls of the /decorator/ (e.g., for
      /memoization/ -- caching the results of expensive computations for later
      use) or
    + to split a complex implementation into separate /methods/.
      =from jian= When using a single function to implement a /decorator/ looks
      too clutter or hard to read and maintain, define a /class/ with ~__call__~,
      and split operations into different internal helper methods.

- The functional approach to creating _functions with internal state_ is to use
  /closures/.
  =TODO=
  =TODO=
  =TODO=
  /Closures/, as well as /decorators/, are the subject of Chapter 9.

*** DONE From Positional to Keyword-Only Parameters - 240
CLOSED: [2025-07-06 Sun 11:39]
One of the best features of Python functions is the _extremely flexible parameter
handling mechanism._

- Closely related are the use of ~*~ and ~**~ to unpack /iterables/ and
  /mappings/ into separate arguments when we call a function.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =from Jian=
  If your function accept a ~*x~ and a ~**y~, when you pass an argument through
  ~x=3~, this is considered as a part of ~**y~! The rule is clear, but this may
  surprise you at your first glance.
  See Example 7-9.

- /Keyword-only arguments/ are a feature of Python 3.
  - name them after the argument prefixed with ~*~.

  - enhancement:
    If you _don't want to support_ /variable positional arguments/ but still
    want /keyword-only arguments/, _put a ~*~ by itself_ in the signature, like
    this:
    #+begin_src python
      def f(a, *, b):
          return a, b


      f(1, b=2)  # (1, 2)

      f(1, 2)
      # Traceback (most recent call last):
      #   File "<stdin>", line 1, in <module>
      # TypeError: f() takes 1 positional argument but 2 were given
    #+end_src

**** Positional-Only Parameters - 242
Since Python 3.8, user-defined function signatures may specify /positional-only
parameters/.

- This feature always existed for built-in functions, such as ~divmod(a, b)~,
  which can ONLY be called with /positional parameters/, and NOT as
  ~divmod(a=10, b=4)~.

- Syntax by example:
  #+begin_src python
    def divmod_(a, b, /):
        d = a // b
        m = a % b
        return d, m
  #+end_src

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =from Jian=
  The author doesn't mention one feature, which is confusing at first glance,
  but it is not new. It is only looks wierd when combined with /positional-only
  parameters/, though *actually NOTHING WRONG!!!*
  #+begin_src python
    def f(a: int = 3, /):
        return a + 1
  #+end_src
  */positional-only parameters/ can have default values*.

*** DONE Packages for Functional Programming - 243
CLOSED: [2025-07-06 Sun 11:58]
**** The ~operator~ Module - 243
- Show the available operators through
  #+begin_src python
    [name for name in dir(operator) if not name.startswith('_')]
  #+end_src
  The group of names prefixed with ~i~ by operate in-place if its first argument
  is mutable. If not, it works just like the one without the ~i~ prefix.

- ~itemgetter~
  * It uses the ~[]~ operator, and it supports not only /sequences/ but also
    /mappings/ and class that implements ~__getitem__~.

  * It can accept multiple parameters like: ~itemgetter(1, 0)~.
    When this happens, it returns a tuple after application.

- ~attrgetter~
  It can get nested attributes. For instance,
  #+begin_src python
    name_lat = attrgetter('name', 'coord.lat')
  #+end_src

- ~methodcaller~
  =from Jian= This book doesn't show any usage that must use this operator.
  #+begin_src python
    from operator import methodcaller


    s = 'The time has come'
    upcase = methodcaller('upper')
    upcase(s)  # 'THE TIME HAS COME'
    ## Can call `str.upper` directly.


    hyphenate = methodcaller('replace', ' ', '-')
    hyphenate(s)  # 'The-time-has-come'
    ## Can use `functools.partial`.
  #+end_src

**** Freezing Arguments with ~functools.partial~ - 247
Example 7-18
#+begin_src python
  from tagger import tag


  tag
  # <function tag at 0x10206d1e0>


  from functools import partial


  picture = partial(tag, 'img', class_='pic-frame')
  picture(src='wumpus.jpeg')
  # '<img class="pic-frame" src="wumpus.jpeg" />'

  picture
  # functools.partial(<function tag at 0x10206d1e0>, 'img', class_='pic-frame')

  picture.func
  # <function tag at 0x10206d1e0>

  picture.args
  # ('img',)

  picture.keywords
  # {'class_': 'pic-frame'}
#+end_src

- ~functools.partial~
  * footnote 4:
    1. The source code for =functools.py= reveals that ~functools.partial~ is
       implemented in C and is used by default.

    2. If that is not available, a pure-Python implementation of partial is
       _available since Python 3.4_.

- ~functools.partialmethod~

- =NEXT=
  /Decorators/ in ~functools~ like ~cache~ and ~singledispatch~ are covered in
  Chapter 9.

*** DONE Chapter Summary - 249
CLOSED: [2025-07-06 Sun 12:10]
*** TODO Further Reading - 250

** DONE 8. Type Hints in Functions - 253
CLOSED: [2025-07-08 Tue 13:21]
=IMPORTANT=
=from Jian=
When reading anything about /type hints/, just learn the fact and usage.
*Never ever trust Python guys understanding to /types/!!!*
You can find wrong ideas about /types/ everywhere in this chapter!!!

This chapter focuses on Python's /type hints/ in /function signatures/.
=NEXT= Chapter 15 explores /type hints/ in the context of /classes/, and other
~typing~ module features.

- The major topics in this chapter are:
  * A hands-on introduction to /gradual typing/ with Mypy
  * The complementary perspectives of /duck typing/ and /nominal typing/
  * Overview of the main categories of /types/ that can appear in /annotations/
    -- this is about 60% of the chapter
  * Type hinting variadic parameters (~*args~, ~**kwargs~)
  * Limitations and downsides of /type hints/ and /static typing/

*** DONE What's New in This Chapter - 254
CLOSED: [2025-07-06 Sun 18:08]
This chapter is completely new.

- /Type hints/ appeared in _Python 3.5_
  _AFTER_ I wrapped up the first edition of Fluent Python.

- Given the limitations of a /static type system/, the best idea of _PEP 484_
  was to introduce a /gradual type system/. Let's begin by defining what that
  means.

*** DONE About Gradual Typing - 254
CLOSED: [2025-07-06 Sun 18:19]
- _PEP 484_ introduced a /gradual type system/ to Python.

- Other languages with /gradual type systems/ are Microsoft's _TypeScript_,
  _Dart_ (the language of the Flutter SDK, created by Google), and _Hack_ (a
  dialect of PHP supported by Facebook's HHVM virtual machine).

- =IMPORTANT=
  =history= The Mypy type checker itself started as a language:
  a gradually typed dialect of Python with its own interpreter.

  * Guido van Rossum convinced the creator of Mypy, Jukka Lehtosalo, to make it
    a _tool_ for checking annotated Python code.

- /gradual type system/
  * Is optional
  * Does not catch type errors at runtime
  * Does not enhance performance
    Type annotations provided data can be useful for optimization, but until
    July 2021 Python didn't do it.

- footnote 3: Python doesn't support recursive types in type hint as of July
  2021! see
  * ~typing~ module issue #182, Define a /JSON type/ and
  * Mypy issue #731, Support /recursive types/.

*** DONE Gradual Typing in Practice - 255
CLOSED: [2025-07-06 Sun 19:12]
- *NOTE*
  * Type checkers:
    + Mypy
    + Google's pytype
    + Microsoft's Pyright
    + Facebook's Pyre
    + IDE embedded

  * Different tools have different features.
    _Pytype_, for example, is designed to handle codebases with NO type hints
    and still provide useful advice. It can also generate annotations for your
    code.

**** Starting with Mypy - 256
- If a /function signature/ has no annotations,
  Mypy ignores it by default -- unless configured otherwise.

**** Making Mypy More Strict - 257
- The command-line option ~--disallow-untyped-defs~ makes Mypy flag any function
  definition that does *not have* /type hints/ for all its parameters and for
  its return value.

**** A Default Parameter Value - 258
- *Code Style: Use flake8 and blue*
  * _blue_ is better than _black_
    BECAUSE
    it follows Python's own style of _using single quotes by default_, _double
    quotes as an alternative_.

  * Use ~black -S~ option to leave your quotes as they are.

**** Using ~None~ as a Default - 260

*** DONE Types Are Defined by Supported Operations - 260
CLOSED: [2025-07-06 Sun 19:23]
- In a gradual type system, we have the interplay of two different views of types:
  * /Duck typing/
    It doesn't matter what the declared type of the object is, only what
    operations it actually supports.

  * /Nomical typing/
    The view adopted by C++, Java, and C#, supported by annotated Python.

*** DONE Types Usable in Annotations - 266
CLOSED: [2025-07-08 Tue 12:56]
**** DONE The ~Any~ Type - 266
CLOSED: [2025-07-06 Sun 19:42]
- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =from Jian=
  From this section, the example from the author, it seems use ~object~ as a
  parameter type is problematic, but actually the author doesn't mean it.
  SEE
  the Python official _type documentation_ - _Type System Reference_ -
  [[https://typing.python.org/en/latest/reference/best_practices.html][Typing Best Practices]]
  #+begin_quote
  If a function accepts every possible ~object~ as an argument, for example
  because it's only passed to str(), use ~object~ instead of ~Any~ as type
  annotation.
  #+end_quote
  ~object~ parameter type always needs the usage of ~isinstance()~ in the body
  of function.

- But ~Any~ is a *magic type* that sits at the /top/ and the /bottom/ of the
  type hierarchy.
  * =from Jian=
    In Scala, ~Any~ is at the /top/ of the /type hierarchy/, more like the
    ~object~ in Python, and need to work together with ~instanceOf~.

***** Subtype-of versus consistent-with - 267
In a /gradual type system/, there is another relationship: /consistent-with/,
which applies wherever /subtype-of/ applies, _with special provisions for type
~Any~._

The rules for /consistent-with/ are:
=from Jian= An enrichment of /subtype-of/
1. Given T1 and a /subtype/ T2, then T2 is /consistent-with/ T1 (Liskov
   substitution).
2. Every type is consistent-with ~Any~:
   you can pass objects of every type to an argument declared of type ~Any~.
3. ~Any~ is consistent-with every type:
   you can always pass an object of type ~Any~ where an argument of another type
   is expected.

**** DONE Simple Types and Classes - 269
CLOSED: [2025-07-06 Sun 19:45]
- *int Is Consistent-With complex*
  1. No /nominal subtype relationship/ between the built-in type ~int~, ~float~,
     and ~complext~.

  2. BUT PEP 484 declares that
     1) ~int~ is consistent-with ~float~
     2) ~float~ is consistent-with ~complex~

**** DONE ~Optional~ and ~Union~ Types - 270
CLOSED: [2025-07-06 Sun 19:47]
- *Better Syntax for Optional and Union in Python 3.10*
  * PEP 604 -- Complementary syntax for ~Union[]~

- Example:
  The ~ord~ built-in /function's signature/ is a simple example of ~Union~ -- it
  accepts ~str~ or ~bytes~, and returns an ~int~:
  ~def ord(c: Union[str, bytes]) -> int: ...~
  * footnote 8:
    To be more precise, ~ord~ *only accepts* ~str~ or ~bytes~ with ~len(s) ==
    1~. But the /type system/ currently *can't express* this constraint.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  *If possible, avoid creating functions that return ~Union~ types,*
  * Rationale:
    as they _put an extra burden on the user_ -- forcing them to check the type
    of the returned value at runtime to know what to do with it.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  ~Union[]~ requires at least two /types/.
  /Nested ~Union~ types/ have the *SAME effect* as a _flattened_ ~Union~.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  ~Union~ is more useful with /types/ that are *NOT consistent* among themselves.
  * For example:
    ~Union[int, float]~ is redundant because ~int~ is consistent -- with ~float~.
    If you just use ~float~ to annotate the parameter, it will accept ~int~
    values as well.

**** DONE Generic Collections - 271
CLOSED: [2025-07-06 Sun 20:14]
- Most Python collections are heterogeneous.
  However, in practice that's not very useful -- if you don't know enough type
  info of an element, you can't operate them through their own methods.

- PEP 585—Type Hinting Generics In Standard Collections lists collections from
  the standard library accepting generic type hints.

- The following list shows only those collections that use the simplest form of
  generic /type hint/, in the form of ~container[item]~:
  * list
  * collections.deque
  * abc.Sequence
  * abc.MutableSequence
  * set
  * abc.Container
  * abc.Set
  * abc.MutableSet
  * frozenset
  * abc.Collection

- =NEXT=
  ~tuple~ and /mapping/ types support more complex /type hints/.

- Challenges from ~array.array~
  =TODO=
  =NOTE= page 272

- *Legacy Support and Deprecated Collection Types*
  (You may skip this box if you only use Python 3.9 or later.)

**** DONE Tuple Types - 274
CLOSED: [2025-07-06 Sun 20:26]
***** Tuples as records - 274
~tuple[str, float, str]~

***** Tuples as records with named fields - 275
#+begin_src python
  from typing import NamedTuple

  from geolib import geohash as gh # type: ignore


  PRECISION = 9


  class Coordinate(NamedTuple):
      lat: float
      lon: float


  def geohash(lat_lon: Coordinate) -> str:
      return gh.encode(*lat_lon, PRECISION)
#+end_src
=IMPORTANT=
=IMPORTANT=
=IMPORTANT=
As explained in _"Overview of Data Class Builders" on page 164_,
~typing.NamedTuple~ is a factory for ~tuple~ /subclasses/, so ~Coordinate~ is
/consistent-with/ ~tuple[float, float]~ BUT *the reverse is not true* -- after
all, ~Coordinate~ has extra methods added by ~NamedTuple~, like ~._asdict()~,
and could also have /user-defined methods/.

***** Tuples as immutable sequences - 275
~tuple[int, ...]~

**** DONE Generic Mappings - 276
CLOSED: [2025-07-07 Mon 10:52]
**** DONE Abstract Base Classes - 278 - =FURTHER DISCUSSION=
CLOSED: [2025-07-07 Mon 11:17]
#+begin_quote
Be conservative in what you send, be liberal in what you accept.
    -- Postel's law, a.k.a. the Robustness Principle
#+end_quote

- *Ideally, a function should accept arguments of those abstract types and not
  concrete types.* -- This gives more flexibility to the caller.

- *The return value of a function is always a concrete object, so the return type
  hint should be a concrete type.*

***** The fall of the numeric tower - 279
- The ~numbers~ package defines the so-called /numeric tower/ described in *PEP
  3141 - A Type Hierarchy for Numbers*. The tower is *linear hierarchy* of ABCs,
  with ~Number~ at the top:
  1. ~Number~
  2. ~Complex~
  3. ~Real~
  4. ~Rational~
  5. ~Integral~

- PEP 484 rejects the ~numbers~ ABCs and dictates that the built-in types
  ~complex~, ~float~, and ~int~ should be treated as special cases, as explained
  in "int Is Consistent-With complex" on page 269.

- =NEXT=
  We'll come back to this issue in “The numbers ABCs and Numeric Protocols”
  on page 478, in _Chapter 13_, which is devoted to contrasting /protocols/ and
  /ABCs/.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  In practice, if you want to annotate numeric arguments for static type
  checking, you have a few options:
  1. Use one of the _concrete types_ ~int~, ~float~, or ~complex~ -- as
     recommended by PEP 488.

  2. Declare a union type like ~float | Decimal | Fraction~.

  3. If you want to avoid hardcoding _concrete types_, use /numeric protocols/
     like ~SupportsFloat~, covered in _"Runtime Checkable Static Protocols"_ on
     page 468.
     =NEXT=

- =NEXT=
  The upcoming section "Static Protocols" on page 286 is a prerequisite for
  understanding the /numeric protocols/.

**** DONE ~Iterable~ - 280
CLOSED: [2025-07-07 Mon 14:59]
- One example of the ~Iterable~ argument appears in the ~math.fsum~ function
  from the standard library:
  #+begin_src python
    def fsum(__seq: Iterable[float]) -> float:
  #+end_src

- *Stub Files and the Typeshed Project*
  =TODO=
  =TODO=
  =TODO= learn more!!!

- *Explicit TypeAlias in Python 3.10*
  _PEP 613 -- Explicit Type Aliases_ introduced a special type, ~TypeAlias~, to
  make the assignments that create /type aliases/ more visible and easier to
  /type check/.

  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  *Starting with Python 3.10,* this is the preferred way to create /type
  aliases/:
  #+begin_src python
    from typing import TypeAlias

    FromTo: TypeAlias = tuple[str, str]
  #+end_src

***** ~abc.Iterable~ versus ~abc.Sequence~
- ~abc.Iterable~ can be infinite which is a potential danger.
  However, this gives the caller the option of providing input data as a
  /generator/ instead of a _prebuilt sequence_, potentially saving a lot of
  memory if the number of input items is large.

- ~abc.Sequence~ must have length.

- Like ~abc.Sequence~, ~abc.Iterable~ is best used as a /parameter type/.
  *It's too vague as a /return type/.*
  A function should be more precise about the /concrete type/ it returns.

- Closely related to ~Iterable~ is the ~Iterator~ type, used as a /return type/.
  =NEXT=
  We'll get back to it in Chapter 17, which is about /generators/ and /classic
  iterators/.

**** DONE Parameterized ~Generics~ and ~TypeVar~ - 282
CLOSED: [2025-07-08 Tue 10:36]
- *Why Is ~TypeVar~ Needed?*
  The authors of _PEP 484_ wanted to introduce /type hints/ by adding the
  ~typing~ module and *not changing anything else in the language.*

  * With clever metaprogramming they could make the ~[]~ operator work on classes
    like ~Sequence[T]~.

  * But the name of the ~T~ variable inside the brackets *must be defined
    somewhere* -- *OTHERWISE* the Python interpreter would need deep changes to
    support /generic type notation/ as special use of ~[]~.

  That's _why the ~typing.TypeVar~ constructor is needed:_
  to introduce the variable name in the current namespace.

***** Restricted ~TypeVar~ - 284
~TypeVar~ accepts extra /positional arguments/ to *restrict* the /type
parameter/.

- Example:
  #+begin_src python
    from collections.abc import Iterable
    from decimal import Decimal
    from fractions import Fraction
    from typing import TypeVar

    NumberT = TypeVar('NumberT', float, Decimal, Fraction)

    def mode(data: Iterable[NumberT]) -> NumberT:
  #+end_src
  That's better than before, and it was the /signature/ for mode in the
  =statistics.pyi= stub file on _typeshed_ on May 25, 2020.
  =from Jian=
  Improved by the author of this book by applying ~bound=~. Mentioned in the
  footnote of next section.

- However, the ~statistics.mode~ documentation includes this example:
  #+begin_src python
    mode(["red", "blue", "blue", "red", "green", "red", "red"])
    # 'red'
  #+end_src
  Add ~str~ to ~NumberT~:
  ~NumberT = TypeVar('NumberT', float, Decimal, Fraction, str)~ is a way, but
  ~NumberT~ is badly misnamed if it accepts ~str~.
  Also, we can't keep listing types forever, as we realize ~mode~ can deal with
  them.

  Better solution is in the next seciton.

***** Bounded ~TypeVar~ - 284
Looking at the body of mode in Example 8-17, we see that _the ~Counter~ class is
used for ranking._ ~Counter~ is based on ~dict~, therefore the element type of the
~data~ /iterable/ must be *hashable*. We can use ~HashableT~ below instead of
using the previous ~NumberT~.
#+begin_src python
HashableT = TypeVar('HashableT', bound=Hashable)
#+end_src
This is better than ~def mode(data: Iterable[Hashable]) -> Hashable:~, because
in the way of bounding with ~Hashable~ but using a ~TypeVar~, ~mode~ return
/concrete types/, while ~-> Hashable~ doesn't and it is not convenient for
the callers of this function.

- To summarize:
  * A /restricted type variable/ will be set to _one of the types named in the
    ~TypeVar~ declaration._

  * A /bounded type variable/ will be set to _the /inferred type/ of the
    expression_ - as long as _the /inferred type/ is consistent-with the
    boundary declared in the ~bound=~ keyword argument of ~TypeVar~._

- =NEXT=
  More on variance in Chapter 15.

***** The ~AnyStr~ predefined type variable - 286 - _Deprecated since 3.13_
~AnyStr = TypeVar('AnyStr', bytes, str)~
A predefined ~TypeVar~ in the ~typing~ module.

- =from Jian=
  In ~typing~:
  Deprecated since version 3.13, will be removed in version 3.18.

  Use ~class A[T: (str, bytes)]: ...~ instead of importing ~AnyStr~.

**** DONE Static Protocols - 286
CLOSED: [2025-07-08 Tue 12:56]
- *NOTE:*
  In object-oriented programming, the concept of a "protocol" as an *informal
  interface* is *as old as Smalltalk,* and is an essential part of Python from
  the beginning.

  _HOWEVER_, in the context of /type hints/, a /protocol/ is a ~typing.Protocol~
  /subclass/ defining an interface that a type checker can verify.

  =NEXT= Both kinds of protocols (dynamic and static) are covered in Chapter 13.
  This is just a brief introduction in the context of function annotations.

- _PEP 544 -- Protocols: Structural subtyping (static duck typing)_
  a protocol type is defined by specifying one or more methods, and the type
  checker verifies that those methods are implemented where that protocol type
  is required.

- _Implement a protocol_ *DON'T need* to /inherit/, /register/, or /declare any
  relationship/ with _the /class/ that defines the /protocol/._

  =IMPORTANT=
  It's up to the /type checker/ to find the available /protocol/ types and
  enforce their usage.

- A key ADVANTAGE of a /protocol type/ over /ABCs/ is that a type doesn't need
  any special declaration to be _consistent-with a /protocol type/._
  =from Jian=
  Just an "advantage" in Python only. Other languages support "ad hoc
  polymorphism".

- Example:
  1. Example 8-20. =comparable.py=: definition of /a ~SupportsLessThan~
     ~Protocol~ type/
     #+begin_src python
       from typing import Protocol, Any


       class SupportsLessThan(Protocol):
           def __lt__(self, other: Any) -> bool: ...
     #+end_src

  2. Example 8-21. =top.py=: definition of the top function using a ~TypeVar~ with
     ~bound=SupportsLessThan~
     #+begin_src python
       from collections.abc import Iterable
       from typing import TypeVar

       from comparable import SupportsLessThan


       LT = TypeVar('LT', bound=SupportsLessThan)


       def top(series: Iterable[LT], length: int) -> list[LT]:
           ordered = sorted(series, reverse=True)
           return ordered[:length]
     #+end_src

   3. Example 8-22. =top_test.py=: partial listing of the test suite for ~top~
      #+begin_src python
        from collections.abc import Iterator
        from typing import TYPE_CHECKING

        import pytest

        from top import top

        # several lines omitted

        def test_top_tuples() -> None:
            fruit = 'mango pear apple kiwi banana'.split()
            series: Iterator[tuple[int, str]] = (
                (len(s), s) for s in fruit)
            length = 3
            expected = [(6, 'banana'), (5, 'mango'), (5, 'apple')]
            result = top(series, length)
            if TYPE_CHECKING:
                reveal_type(series)
                reveal_type(expected)
                reveal_type(result)
            assert result == expected

        # intentional type error
        def test_top_objects_error() -> None:
            series = [object() for _ in range(4)]
            if TYPE_CHECKING:
                reveal_type(series)
            with pytest.raises(TypeError) as excinfo:
                top(series, 3)
            assert "'<' not supported" in str(excinfo.value)
      #+end_src
      * =IMPORTANT=
        =IMPORTANT=
        =IMPORTANT=
        ~reveal_type()~ *cannot be called* _at runtime_, because it is *NOT* a
        regular function but a Mypy debugging facility -- that's why there is no
        ~import~ for it.

        Mypy will output one debugging message for each ~reveal_type()~
        pseudofunction call, showing the /inferred type/ of the argument.

- Now we can _make /duck typing/ explicit_ for /static type checkers/. That's
  why it makes sense to say that ~typing.Protocol~ gives us /static duck
  typing/.

**** DONE ~Callable~ - 291
CLOSED: [2025-07-08 Tue 10:49]
- There is *NO syntax* to annotate /optional or keyword argument types/.

- If you need a /type hint/ to match a function with a *flexible signature*,
  _REPLACE the whole parameter list WITH ~...~,_ like this:
  #+begin_src python
    Callable[..., ReturnType]
  #+end_src

***** Variance in ~Callable~ types - 292
Example 8-24. Illustrating variance.
#+begin_src python
  from collections.abc import Callable


  def update(
          probe: Callable[[], float],
          display: Callable[[float], None]
  ) -> None:
      temperature = probe()
      # imagine lots of control code here
      display(temperature)


  def probe_ok() -> int:
      return 42


  def display_wrong(temperature: int) -> None:
      print(hex(temperature))


  update(probe_ok, display_wrong) # type error


  def display_ok(temperature: complex) -> None:
      print(temperature)


  update(probe_ok, display_ok) # OK
#+end_src

**** DONE ~NoReturn~ - 294
CLOSED: [2025-07-08 Tue 10:54]
This is a special type used only to annotate the return type of functions that
*never return*.

- _USUALLY_, they exist to raise exceptions.
  There are dozens of such functions in the standard library.

- Example (stub, in typeshed):
  #+begin_src python
    def exit(__status: object = ...) -> NoReturn: ...
  #+end_src

- =NEXT=
  In Chapter 24, Example 24-6 uses ~NoReturn~ in the ~__flag_unknown_attrs~, a
  method designed to produce a user-friendly and comprehensive error message,
  and then raise ~AttributeError~.

*** DONE Annotating Positional Only and Variadic Parameters - 295
CLOSED: [2025-07-06 Sun 20:35]
Illustration code from "Positional-Only Parameters" on page 242:
#+begin_src python
  def tag(name, /, *content: str, class_: str | None = None, **attrs: str):
#+end_src
- The type of ~content~ in the body of function is ~tuple[str, ...]~

- The type of ~attr~ in the body of function is ~dict[str, str]~.

- =historical=
  Before supporting the ~/~ parameter syntax introduced in Python 3.8,
  _The PEP 484_ convention is to prefix each /positional-only parameter/ name
  with *two underscores*.

*** DONE Imperfect Typing and Strong Testing - 296
CLOSED: [2025-07-06 Sun 20:48]
- Even in the contexts where they are most beneficial, static typing cannot be
  trusted as the ultimate arbiter of correctness. It's not hard to find:

- Also, if we are forced to _type check everything_, we lose some of the
  expressive power of Python:
  =from Jian= in another words, *Python type system is weak!*
  * Some handy features can't be statically checked;
    + for example,
      /argument unpacking/ like ~config(**settings)~.

  * Advanced features like /properties/, /descriptors/, /metaclasses/, and
    /metaprogramming in general/ are _poorly supported_ or _beyond comprehension
    for type checkers._

  * /Type checkers/ *lag behind* Python releases, rejecting or even crashing
    while analyzing code with new language features -- for more than a year in
    some cases.

- =from Jian=
  Rephrase some paragraphs in this section and add some of my understanding:
  Python type system is weak and the language is too dynamic.
  It can't express many constraints, for example, integers in a range.

*** TODO Chapter Summary - 297
*** TODO Further Reading - 298
- *Soapbox*
  =from Jian= Forget about this Soapbox, which is meaningless.

** TODO 9. Decorators and Closures - 303
- The end goal of this chapter is to explain exactly
  *HOW /function decorators/ work,*
  FROM the simplest /registration decorators/
  TO the rather more complicated _parameterized ones._
  1. However, before we reach that goal we need to cover:
     * HOW Python evaluates _decorator syntax_
     * HOW Python decides whether a variable is _local_
     * WHY closures exist and HOW they work
     * WHAT problem is solved by ~nonlocal~

  2. With this grounding, we can tackle further /decorator/ topics:
     * Implementing a well-behaved /decorator/
     * Powerful /decorators/ in the standard library: ~@cache~, ~@lru_cache~,
       and ~@singledispatch~
     * Implementing a /parameterized decorator/

*** DONE What's New in This Chapter - 304
CLOSED: [2025-07-08 Tue 18:34]
- The /caching decorator/ ~functools.cache~ -- new in _Python 3.9_ -- is simpler
  than the traditional ~functools.lru_cache~, so I present it first.
  The latter is covered in "Using ~lru_cache~" on page 323, including the
  simplified form added in _Python 3.8_.

- "Single Dispatch Generic Functions" on page 324 was expanded and now uses
  /type hints/, the preferred way to use ~functools.singledispatch~ since
  _Python 3.7_.

- "Parameterized Decorators" on page 329 now includes a class-based
  example, Example 9-27.

- I moved Chapter 10, "Design Patterns with First-Class Functions" to the end of
  Part II to improve the flow of the book.
  "Decorator-Enhanced Strategy Pattern" on page 353 is now in that chapter,
  along with other variations of the /Strategy design pattern/ using callables.

- We start with a very gentle introduction to /decorators/, and then proceed
  with the rest of the items listed in the chapter opening.

*** DONE Decorators 101 - 304
CLOSED: [2025-07-08 Tue 18:58]
- decorator :: a /callable/ that takes another function as an argument (the
  decorated function).
  * A decorator may perform some processing with the decorated function, and
    + RETURNS it or
    + REPLACES it WITH ANOTHER /function/ or /callable object/.

- footnote 2: /class decorators/ are covered in _Chapter 24_.

- Strictly speaking, /decorators/ are just /syntactic sugar/.

- Three essential facts make a good summary of decorators:
  * A /decorator/ is a /function/ or another /callable/.
  * A /decorator/ may replace the decorated function with a different one.
  * /Decorators/ are executed _IMMEDIATELY when a /module/ is loaded._

*** DONE When Python Executes Decorators - 306
CLOSED: [2025-07-08 Tue 19:02]
A key feature of /decorators/ is that they run right after the /decorated
function/ is defined. That is usually _at import time_ (i.e., when a /module/ is
loaded by Python).

*** DONE Registration Decorators - 308
CLOSED: [2025-07-08 Tue 19:05]
We will see a /registration decorator/ applied in "Decorator-Enhanced Strategy
Pattern" on page 353 _(Chapter 10)_.

*** TODO Variable Scope Rules - 308 - =NOTE=
- *Comparing Bytecodes*

*** TODO Closures - 311 - =NOTE=
*** DONE The ~nonlocal~ Declaration - 315
CLOSED: [2025-07-08 Tue 20:29]
- Example 9-13. Calculate a running average without keeping all history (fixed
  with the use of ~nonlocal~)
  #+begin_src python
    def make_averager():
        count = 0
        total = 0

        def averager(new_value):
            nonlocal count, total
            count += 1
            total += new_value
            return total / count

        return averager
  #+end_src
  * If omitting the ~nonlocal~ keyword, we will see:
    #+begin_src text
      Traceback (most recent call last):
        ...
      UnboundLocalError: local variable 'count' referenced before assignment
    #+end_src

**** Variable Lookup Logic - 316
=IMPORTANT=
=IMPORTANT=
=IMPORTANT=
When a function is defined, the /Python bytecode compiler/ determines how to
fetch a /variable/ ~x~ that appears in it, based on these rules:
- If there is a ~global x~ declaration, ~x~ comes from and is assigned to the
  ~x~ global variable module.
  * footnote 4:
    Python does *NOT have* a /program global scope/,
    *ONLY* /module global scopes/.

- If there is a ~nonlocal x~ declaration, ~x~
  _comes from_ and _is assigned to_
  the ~x~ /local variable/ of the nearest surrounding function
  WHERE ~x~ is defined.

- If ~x~ is a parameter or is assigned a value in the function body, then ~x~ is
  the /local variable/.

- If ~x~ _is referenced_ BUT _is NOT assigned_ and _is not a parameter_:
  * ~x~ will be looked up in the /local scopes/ of the surrounding function
    bodies (/nonlocal scopes/).
  * If not found in /surrounding scopes/, it will be read from the /module
    global scope/.
  * If not found in the /global scope/, it will be read from
    ~__builtins__.__dict__~.

*** TODO Implementing a Simple Decorator - 317
**** How It Works - 318

- ~functools.wraps~

*** TODO Decorators in the Standard Library - 320
**** Memoization with ~functools.cache~ - 320
- *Stacked Decorators*

**** Using ~lru_cache~ - 323
**** Single Dispatch Generic Functions - 324
***** Function singledispatch - 325

*** TODO Parameterized Decorators - 329
**** A Parameterized Registration Decorator - 329
**** The Parameterized Clock Decorator - 332
**** A Class-Based Clock Decorator - 335

*** TODO Chapter Summary - 336
*** TODO Further Reading - 336
- *Soapbox*

** TODO 10. Design Patterns with First-Class Functions - 341
*** What's New in This Chapter - 342
*** Case Study: Refactoring Strategy - 342
**** Classic Strategy - 342
**** Function-Oriented Strategy - 347
- *Why ~self.promotion(self~)?*

**** Choosing the Best Strategy: Simple Approach - 350
**** Finding Strategies in a Module - 351

*** Decorator-Enhanced Strategy Pattern - 353
*** The Command Pattern - 355
*** Chapter Summary - 357
*** Further Reading - 358
- *Soapbox*

* TODO Part III. Classes and Protocols
** TODO 11. A Pythonic Object - 363
*** What's New in This Chapter - 364
*** Object Representations - 364
*** Vector Class Redux - 365
*** An Alternative Constructor - 368
*** ~classmethod~ Versus ~staticmethod~ - 369
*** Formatted Displays - 370
*** A Hashable ~Vector2d~ - 374
*** Supporting Positional Pattern Matching - 377
*** Complete Listing of ~Vector2d~, Version 3 - 378
*** Private and "Protected" Attributes in Python - 382
*** Saving Memory with ~__slots__~ - 384
**** Simple Measure of ~__slot__~ Savings - 387
**** Summarizing the Issues with ~__slots__~ - 388

*** Overriding Class Attributes - 389
*** Chapter Summary - 391
*** Further Reading - 392
- *Soapbox*

** TODO 12. Special Methods for Sequences - 397
*** What's New in This Chapter - 398
*** Vector: A User-Defined Sequence Type - 398
- *Vector Applications Beyond Three Dimensions*

*** Vector Take #1: Vector2d Compatible - 399
*** Protocols and Duck Typing - 402
*** Vector Take #2: A Sliceable Sequence - 403
**** How Slicing Works - 404
**** A Slice-Aware ~__getitem__~ - 406

*** Vector Take #3: Dynamic Attribute Access - 407
*** Vector Take #4: Hashing and a Faster ~==~ - 411
- *The Awesome zip*

*** Vector Take #5: Formatting - 418
*** Chapter Summary - 425
*** Further Reading - 426
- *Soapbox*

** TODO 13. Interfaces, Protocols, and ABCs - 431
- /Object-oriented programming/ is all about /interfaces/.

- Since Python 3.8, we have *FOUR* ways.
  They are depicted in the _Typing Map (Figure 13-1)_. We can summarize them like
  this:
  * Duck typing
    _avoiding ~isinstance~ checks_

  * Goose typing
    _using ~isinstance~ checks against ~ABC~'s_
    The approach supported by /abstract base classes (ABCs)/ _since Python 2.6_,
    which relies on *runtime checks* of objects against ABCs.
    + /Goose typing/ is a major subject in this chapter.

  * Static typing
    _using ~typing.Protocol~ type hints and external type checker_
    Supported _since Python 3.5_ by the ~typing~ module, and enforced by
    _external type checkers_ compliant with _PEP 484—Type Hints_.
    + This is *NOT* the theme of this chapter.
      Most of _Chapter 8_ and the _upcoming Chapter 15_ are about /static
      typing/.

  * Static duck typing
    _using type hints and external type checker_
    An approach made popular by the Go language;
    Supported by subclasses of ~typing.Protocol~ - _new in Python 3.8_ -- also
    enforced by _external type checkers_.
    + We first saw this in “Static Protocols” on page 286 (Chapter 8).

*** DONE The Typing Map - 432
CLOSED: [2024-11-21 Thu 11:23]
- =IMPORTANT=
  Figure 13-1. The top half describes runtime type checking approaches using just the
  Python interpreter; the bottom requires an external static type checker such as MyPy or
  an IDE like PyCharm. The left quadrants cover typing based on the object’s structure—
  i.e., the methods provided by the object, regardless of the name of its class or super‐
  classes; the right quadrants depend on objects having explicitly named types: the name
  of the object’s class, or the name of its superclasses.

- Each of these four approaches rely on /interfaces/ to work,
  _BUT_ /static typing/ can be done -- poorly -- using only _concrete types_
  instead of /interface/ abstractions like /protocols/ and /abstract base classes/.

  * This chapter is about /duck typing/, /goose typing/, and /static duck typing/
    -- typing disciplines that revolve around /interfaces/.

- This chapter is split in _FOUR_ main sections, addressing three of the four
  quadrants in the Typing Map (Figure 13-1):
  • “Two Kinds of Protocols” on page 434 compares the two forms of structural
    typing with protocols—i.e., the lefthand side of the Typing Map.

  • “Programming Ducks” on page 435 dives deeper into Python's usual /duck typing/,
    including how to make it safer while preserving its major strength: flexibility.

  • "Goose Typing" on page 442 explains the use of ~ABC~'s for _stricter runtime type
    checking_. This is the longest section, not because it's more important, but
    because there are more sections about /duck typing/, /static duck typing/, and
    /static typing/ elsewhere in the book.

  • "Static Protocols" on page 466 covers usage, implementation, and design of
    ~typing.Protocol~ subclasses—useful for static and runtime type checking.

*** TODO What's New in This Chapter - 433
*** Two Kinds of Protocols - 434
- The word /protocol/ has different meanings in computer science depending on
  context.

*** Programming Ducks - 435
**** Python Digs Sequences - 436
**** Monkey Patching: Implementing a Protocol at Runtime - 438
**** Defensive Programming and “Fail Fast” - 440

*** Goose Typing - 442
- *Waterfowl and ABCs*

**** Subclassing an ABC - 447
**** ABCs in the Standard Library - 449
- *isinstance with Hashable and Iterable Can Be Misleading*

**** Defining and Using an ABC - 451
**** ABC Syntax Details - 457
**** Subclassing an ABC - 458
**** A Virtual Subclass of an ABC - 460
**** Usage of register in Practice - 463
**** Structural Typing with ABCs - 464

*** Static ~Protocol~'s - 466
**** The Typed double Function - 466
**** Runtime Checkable Static ~Protocol~'s - 468
- *Duck Typing Is Your Friend*

**** Limitations of Runtime ~Protocol~ Checks - 471
**** Supporting a Static ~Protocol~ - 472
**** Designing a Static ~Protocol~ - 474
**** Best Practices for ~Protocol~ Design - 476
**** Extending a ~Protocol~ - 477
**** The numbers ~ABC~'s and Numeric ~Protocol~'s - 478

*** Chapter Summary - 481
*** Further Reading - 482
- *Soapbox*

** TODO 14. Inheritance: For Good or For Worse - 487
*** What's New in This Chapter - 488
*** The ~super()~ Function - 488
*** Subclassing Built-In Types Is Tricky - 490
*** Multiple Inheritance and Method Resolution Order - 494
*** Mixin Classes - 500
**** Case-Insensitive Mappings - 500

*** Multiple Inheritance in the Real World - 502
**** ~ABC~'s Are Mixins Too - 502
**** ~ThreadingMixIn~ and ~ForkingMixIn~ - 503
**** Django Generic Views Mixins - 504
**** Multiple Inheritance in Tkinter - 507

*** Coping with Inheritance - 510
**** Favor Object Composition over Class Inheritance - 510
**** Understand Why Inheritance Is Used in Each Case - 510
**** Make Interfaces Explicit with ABCs - 511
**** Use Explicit Mixins for Code Reuse - 511
**** Provide Aggregate Classes to Users - 511
**** Subclass Only Classes Designed for Subclassing - 512
**** Avoid Subclassing from Concrete Classes - 513
**** Tkinter: The Good, the Bad, and the Ugly - 513

*** Chapter Summary - 514
*** Further Reading - 515

** TODO 15. More About Type Hints - 519
This chapter is a sequel to _Chapter 8_, covering more of Python's /gradual type
system/. The main topics are:
_ Overloaded function signatures
_ ~typing.TypedDict~ for type hinting ~dict~'s used as records
_ Type casting
_ Runtime access to type hints
_ Generic types
  * Declaring a /generic class/
  * /Variance/: /invariant/, /covariant/, and /contravariant/ types
  * /Generic static protocols/

*** What's New in This Chapter - 519
*** DONE Overloaded Signatures - 520
CLOSED: [2024-11-13 Wed 19:44]
=from Jian=
- This section is useful if you want to do case study for type hint usages.

- What I get from this section is that
  _I'D BETTER_ choose a modern static typed langauge with type inference and a
  good type system,
  _RATHER THAN_ learn all the details of Python's type hints.

- *Take Advantage of Gradual Typing*

**** Max Overload - 521
***** Arguments implementing SupportsLessThan, but key and default not provided - 524
***** Argument key provided, but no default - 524
***** Argument default provided, but no key - 525
***** Arguments key and default provided - 525

**** Takeaways from Overloading max - 525
=NEXT=
Now let’s study the ~TypedDict~ typing construct. It is not as useful as I imagined at
first, but has its uses.

- Experimenting with ~TypedDict~ demonstrates the limitations of static typing for
  handling dynamic structures, such as JSON data.
  =from Jian=
  *This conclusion is wrong!* It can't demonstrate!
  Just pick a good modern static typing language!!!

*** DONE ~TypedDict~ - 526
CLOSED: [2024-11-13 Wed 20:14]
- For runtime checking of JSON-like structures using type hints, check out the
  *pydantic* package on PyPI.

- The syntactic similarity is misleading. ~TypedDict~ is very different from
  /dataclass/ or ~typing.NamedTuple~. It exists only for the benefit of /type
  checkers/, and has *NO runtime effect*.

- ~TypedDict~ provides two things:
  * Class-like syntax to annotate a dict with type hints for the value of each
    “field.”

  * A constructor that tells the type checker to expect a dict with the keys and
    values as specified.

- Example: ~BookDict~
  * The /type hints/ are in ~BookDict.__annotations__~, and not in ~pp~.

- The fact that ~BookDict~ creates a plain ~dict~ also means that:
  * The "fields" in the pseudoclass definition *DON'T create instance attributes*.
  * You *can't* write /initializers/ with default values for the "fields."
  * /Method definitions/ are *NOT allowed*.

- =IMPORTANT=
  Combine ~typing.TYPE_CHECKING~ with ~reveal_type(..)~ (from mypy, no import
  clause needed), we can see some useful info from mypy check output.

- ~TypedDict~ has more features, including support for
  * optional keys,
  * a limited form of inheritance, and
  * an alternative declaration syntax.

  If you want to know more about it, please review
  *PEP 589 - TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys*.

*** TODO Type Casting - 534
~typing.cast()~

- xxx
- xxx

*** TODO Reading Type Hints at Runtime - 537
**** Problems with Annotations at Runtime - 538
**** Dealing with the Problem - 540

*** TODO Implementing a Generic Class - 541
**** Basic Jargon for Generic Types - 544

*** TODO Variance - 544
**** An Invariant Dispenser - 545
**** A Covariant Dispenser - 546
**** A Contravariant Trash Can - 547
**** Variance Review - 549
***** Invariant types - 549
***** Covariant types - 550
***** Contravariant types - 550
***** Variance rules of thumb - 551

*** TODO Implementing a Generic Static Protocol - 552
*** Chapter Summary - 554
*** Further Reading - 555
- *Soapbox*

** TODO 16. Operator Overloading: Doing It Right - 561
*** What's New in This Chapter - 562
*** Operator Overloading 101 - 562
*** Unary Operators - 563
- *When ~x~ and ~+x~ Are Not Equal*

*** Overloading ~+~ for Vector Addition - 566
*** Overloading ~*~ for Scalar Multiplication - 572
*** Using ~@~ as an Infix Operator - 574
- *New ~zip()~ Feature in Python 3.10*

*** Wrapping-Up Arithmetic Operators - 576
*** Rich Comparison Operators - 577
*** Augmented Assignment Operators - 580
*** Chapter Summary - 585
*** Further Reading - 587
- *Soapbox*

* TODO Part IV. Control Flow
** 17. Iterators, Generators, and Classic Coroutines - 593
/Iteration/ is fundamental to data processing: programs apply computations to
data series, from pixels to nucleotides.

If the data _doesn't fit in memory_, we need to fetch the items lazily - one at
a time and on demand. That's what an /iterator/ does.

This chapter shows how /the ~Iterator~ design pattern/ is built into the Python
language so *you NEVER NEED to code it by hand.*

- Every standard collection in Python is /iterable/.
  * iterable :: an object that provides an /iterator/

  * Python uses /iterator/ to support operations like:
    + ~for~ loops
    + List, dict, and set comprehensions
    + Unpacking assignments
    + Construction of collection instances

- This chapter covers the following topics:
  * How Python uses the ~iter()~ /built-in function/ to handle /iterable
    objects/

  * How to implement the /classic Iterator pattern/ in Python

  * How the /classic Iterator pattern/ can be replaced by a /generator function/
    or /generator expression/
  * How a /generator function/ works in detail, with line-by-line descriptions

  * Leveraging the _general-purpose_ /generator functions/ in the standard
    library

  * Using ~yield from~ expressions to *combine* /generators/

  * Why /generators/ and /classic coroutines/ look alike
    BUT are _used in very different ways_ and *should not be mixed*

*** What's New in This Chapter - 594
*** A Sequence of Words - 594
*** Why Sequences Are Iterable: The iter Function - 596
**** Using iter with a Callable - 598

*** Iterables Versus Iterators - 599
*** Sentence Classes with ~__iter__~ - 603
**** Sentence Take #2: A Classic Iterator - 603
**** Don't Make the Iterable an Iterator for Itself - 605
**** Sentence Take #3: A Generator Function - 606
**** How a Generator Works - 607

*** Lazy Sentences - 610
**** Sentence Take #4: Lazy Generator - 610
**** Sentence Take #5: Lazy Generator Expression - 611

*** When to Use Generator Expressions - 613
*** An Arithmetic Progression Generator - 615
**** Arithmetic Progression with ~itertools~ - 618

*** Generator Functions in the Standard Library - 619
*** Iterable Reducing Functions - 630
*** DONE Subgenerators with yield from - 632 - =TODO=
CLOSED: [2025-06-27 Fri 17:58]
- The ~yield from~ expression syntax
  _was introduced in Python 3.3_
  to allow a /generator/ to *delegate work to* a /subgenerator/.

**** Reinventing chain - 633
#+begin_src python
  def chain(*iterables):
      for i in iterables:
          yield from i
#+end_src

It seems like just syntactic sugar with little real gain.
See next section for a more interesting example.

**** Traversing a Tree - 634
Example 17-33. =tree/step6/tree.py=: recursive calls of tree pass an incremented
level argument
#+begin_src python
  def tree(cls, level=0):
      yield cls.__name__, level
      for sub_cls in cls.__subclasses__():
          yield from tree(sub_cls, level+1)


  def display(cls):
      for cls_name, level in tree(cls):
          indent = ' ' * 4 * level
          print(f'{indent}{cls_name}')


  if __name__ == '__main__':
      display(BaseException)
#+end_src

- =TODO=
  =TODO=
  =TODO=
  At the start of “Subgenerators with yield from” on page 632, we saw how yield
  from connects the subgenerator directly to the client code, bypassing the
  delegating generator. That connection becomes really important when generators
  are used as coroutines and not only produce but also consume values from the
  client code, as we’ll see in “Classic Coroutines” on page 641.

*** DONE Generic Iterable Types - 639
CLOSED: [2025-06-27 Fri 18:09]
- PAGE 640:
  Starting with Python 3.10, a type alias should have a /type hint/ of
  ~typing.TypeAlias~ to clarify the reason for this line:
  #+begin_src python
    FromTo: TypeAlias = tuple[str, str]
  #+end_src

- ~collections.abc.Iterator[str]~ is consistent with
  ~collections.abc.Generator[str, None, None]~,
  THEREFORE
  Mypy issues no errors for type checking in Example 17-36.

  * ~Iterator[T]~ is a shortcut for ~Generator[T, None, None]~.

    Both annotations mean "a generator that yields items of type ~T~,
    _BUT_
    that does not /consume values/ or /return values/."

  * =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    ~Generators~ able to *consume* and *return* values are /coroutines/, our
    next topic.

*** TODO Classic Coroutines - 641 - =START HERE!=
- *NOTE*:
  * Important _historical_ PEP:
    *PEP 342 -- Coroutines via Enhanced Generators*
    introduced the ~.send()~ and other features that made it possible to use
    /generators/ as coroutines.
    + From the author:
      Call this _"classic coroutine"_.

  * *PEP 492 -- Coroutines with ~async~ and ~await~ syntax*
    + From the author:
      Call this _"native coroutine"_.

  * But _PEP 342_ is _not deprecated_, and /classic coroutines/ still work as
    originally designed, although they are *no longer supported* by _asyncio_.

- Understanding /classic coroutines/ in Python is *confusing*
  _BECAUSE_ they are actually /generators/ used in a _DIFFERENT_ way.

  So let's *step back to* talk about another feature of Python that can be used
  in two ways -- /tuple/:

  * /Tuple/ as /record/: a tuple is expected to have a specific number of items,
    can with different types.

  * /Tuple/ as /immutable list/: a tuple can have any length, and all items are
    expected to have the _SAME_ type.

- Something similar (to /tuples/) happens with /generators/:
  1. They are commonly used as /iterators/,
  2. BUT they can also be used as /coroutines/.

- A /coroutine/ is really a /generator function/, created with the ~yield~
  keyword in its body.
  * A /coroutine object/ is physically a /generator object/.

- Adding to the *CONFUSION*:
  1. the ~typing~ module authors decided to name that type ~Generator~,
     when in fact it describes the API of a /generator object/ intended to be
     used as a /coroutine/,

  2. while /generators/ are more often used as simple /iterators/.

**** Example: Coroutine to Compute a Running Average - 643
**** Returning a Value from a Coroutine - 646
**** Generic Type Hints for Classic Coroutines - 650

*** Chapter Summary - 652
*** Further Reading - 652

** 18. ~with~, ~match~, and ~else~ Blocks - 657
*** TODO What's New in This Chapter - 658
*** Context Managers and with Blocks - 658
/Context manager objects/ exist to control a ~with~ statement,
just like /iterators/ exist to control a ~for~ statement.

- _Designed for_:
  simplifying some common uses of ~try~ / ~finally~,
  which *guarantees* that some operation is performed after a block of code,
  _EVEN IF_ the block is terminated by ~return~, an /exception/, or a
  ~sys.exit()~ call.
  * The code in the ~finally~ clause usually
    + *releases* a critical resource or
    + *restores* some previous state that was temporarily changed.

- The Python community is finding new, creative uses for context managers.
  Some examples from the standard library are:
  * Managing transactions in the sqlite3 module -- see “Using the connection as a
    context manager”.
  * Safely handling locks, conditions, and semaphores -- as described in the
    threading module documentation.
  * Setting up custom environments for arithmetic operations with Decimal objects
    -- see the decimal.localcontext documentation.
  * Patching objects for testing—see the unittest.mock.patch function.

**** The contextlib Utilities - 663
**** Using ~@contextmanager~ - 664

*** Pattern Matching in =lis.py=: A Case Study - 669
**** Scheme Systax - 669
**** Imports and Types - 671
**** The Parser - 671
**** The Environment - 673
**** The REPL - 675
**** The Evaluator - 676
***** Evaluating numbers - 677
***** Evaluating symbols - 678
***** (quote ...) - 678
***** (if ...) - 679
***** (lambda ...) - 680
***** (define ...) - 681
***** (set! ...) - 682
***** Function call - 684
***** Catch syntax errors - 684

**** Procedure: A Class Implementing a Closure - 686
**** Using OR-patterns - 687
**** Chapter Summary - 689

*** Do This, Then That: else Blocks Beyond if - 687
*** Chapter Summary - 689
*** Further Reading - 690

** 19. Concurrency Models in Python - 695
** 20. Concurrent Executors - 743
** 21. Asynchronous Programming - 775

* TODO Part V. Metaprogramming
** TODO 22. Dynamic Attributes and Properties - 835
- /Data attributes/ and /methods/ are collectively known as /attributes/ in Python.

- A /method/ is an _attribute_ that is /callable/.

- /Dynamic attributes/ present the same interface as /data attributes/ --
  i.e., ~obj.attr~ -- but are _computed on demand_.
  This follows
  * Bertrand Meyer's /Uniform Access Principle/:
    #+begin_quote
    All services offered by a module should be available through _a uniform
    notation_, which does not betray whether they are implemented through
    storage or through computation.
    #+end_quote

- There are several ways to implement /dynamic attributes/ in Python.
  This chapter covers the simplest ways:
  * the ~@property~ /decorator/
  * the ~__getattr__~ /special method/.

*** What's New in This Chapter - 836
*** Data Wrangling with Dynamic Attributes - 836
**** Exploring JSON-Like Data with Dynamic Attributes - 838
**** The Invalid Attribute Name Problem - 842
**** Flexible Object Creation with ~__new__~ - 843

*** Computed Properties - 845
**** Step 1: Data-Driven Attribute Creation - 846
**** Step 2: Property to Retrieve a Linked Record - 848
**** Step 3: Property Overriding an Existing Attribute - 852
**** Step 4: Bespoke Property Cache - 853
**** Step 5: Caching Properties with functools - 855

*** Using a Property for Attribute Validation - 857
**** LineItem Take #1: Class for an Item in an Order - 857
**** LineItem Take #2: A Validating Property - 858

*** A Proper Look at Properties - 860
**** Properties Override Instance Attributess - 861
**** Property Documentation - 864

*** Coding a Property Factory - 865
*** Handling Attribute Deletion - 868
*** Essential Attributes and Functions for Attribute Handling - 869
**** Special Attributes that Affect Attribute Handling - 870
**** Built-In Functions for Attribute Handling - 870
**** Special Methods for Attribute Handling - 871

*** Chapter Summary - 873
*** Further Reading - 873

** TODO 23. Attribute Descriptors - 879
*** What's New in This Chapter - 880
*** Descriptor Example: Attribute Validation - 880
**** LineItem Take #3: A Simple Descriptor - 880
**** LineItem Take #4: Automatic Naming of Storage Attributes - 887
**** LineItem Take #5: A New Descriptor Type - 889

*** Overriding Versus Nonoverriding Descriptors - 892
**** Overriding Descriptors - 894
**** Overriding Descriptor Without ~__get__~ - 895
**** Nonoverriding Descriptor - 896
**** Overwriting a Descriptor in the Class - 897

*** Methods Are Descriptors - 898
*** Descriptor Usage Tips - 900
*** Descriptor Docstring and Overriding Deletion - 902
*** Chapter Summary - 903
*** Further Reading - 904

** 24. Class Metaprogramming - 907
- Class metaprogramming is the art of creating or customizing classes at
  runtime. Classes are first-class objects in Python, so a function can be used
  to create a new class at any time, without using the class keyword. Class
  decorators are also functions, but designed to inspect, change, and even
  replace the decorated class with another class. Finally, metaclasses are the
  most advanced tool for class metaprogramming: they let you create whole new
  categories of classes with special traits, such as the abstract base classes
  we’ve already seen.

- Metaclasses are powerful, but hard to justify and even harder to get right.
  Class decorators solve many of the same problems and are easier to understand.
  Furthermore, Python 3.6 implemented PEP 487—Simpler customization of class
  creation, providing special methods supporting tasks that previously required
  metaclasses or class decorators.

- This chapter presents the class metaprogramming techniques in ascending order
  of complexity.

*** TODO What's New in This Chapter - 908
*** TODO Classes as Objects - 908
Like most program entities in Python, classes are also objects. Every class has
a number of attributes defined in the Python Data Model, documented in “4.13.
Special Attributes” of the “Built-in Types” chapter in The Python Standard
Library. Three of those attributes appeared several times in this book already:
~__class__~, ~__name__~, and ~__mro__~. Other class standard attributes are:

- ~cls.__bases__~
- ~cls.__qualname__~
- ~cls.__subclasses__()~
- ~cls.mro()~

*** TODO type: The Built-In Class Factory - 909
*** TODO A Class Factory Function - 911 - =CONTINUE=
*** TODO Introducing ~__init_subclass__~ - 914
**** Why ~__init_subclass__~ Cannot Configure ~__slots__~ - 921

*** TODO Enhancing Classes with a Class Decorator - 922
*** TODO What Happens When: Import Time Versus Runtime - 925
**** Evaluation Time Experiments - 926

*** TODO Metaclasses 101 - 931
**** How a Metaclass Customizes a Class - 933
**** A Nice Metaclass Example - 934
**** Metaclass Evaluation Time Experiment - 937

*** TODO A Metaclass Solution for Checked - 942
*** TODO Metaclasses in the Real World - 947
**** Modern Features Simplify or Replace Metaclasses - 947
**** Metaclasses Are Stable Language Features - 948
**** A Class Can Only Have One Metaclass - 948
**** Metaclasses Should Be Implementation Details - 949

*** TODO A Metaclass Hack with ~__prepare__~ - 950
*** TODO Wrapping Up - 952
*** TODO Chapter Summary - 953
*** TODO Further Reading - 954

* Afterword - 959
** Further Reading - 961

* Index - 963

