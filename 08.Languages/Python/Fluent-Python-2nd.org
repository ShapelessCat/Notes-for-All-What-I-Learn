#+TITLE: Fluent Python
#+SUBTITLE: Clear, Concise, and Effective Programming
#+VERSION: 2nd, Covers Python 3.10, 2022
#+AUTHOR: Luciano Ramalho
#+STARTUP: overview
#+STARTUP: entitiespretty
#+STARTUP: indent

* Preface - xix
* TODO Part I. Data Structures
** DONE 1. The Python Data Model - 3
   CLOSED: [2021-04-04 Sun 22:05]
   - One of the best quanlities of Python is its *consistency*.
     * However, you may find it stange to use ~len(collection)~ instad of
       ~collection.len()~. To understand this, you need to learn /Python Data
       Model/.
       + =from Jian=
         ~len~ is not a good name!!!
         Python even use ~len~ to get _size_.

   - Python Data Model ::
     describes the API that if you use it properly you can use to make your own
     objects play well with the most idiomatic language features.

   - /Python data model/ can be considered as a description of Python as a
     framework.
       It *formalizes* the interfaces of the building blocks of the language itself,
     such as /sequences/, /iterators/, /functions/, /classes/, /context managers/,
     and so on.

   - While coding with any framework, you spend a lot of time implementing
     methods that are called by the framework. The same happens when you
     leverage the /Python data model/.

   - =IMPORTANT=
     JARGON:
     ~__getitem__~ is called as ~dunder-getitem~ (a shortcut for
     "under-under-getitem-under-under" invented by Steve Holden).
     * Call this kind of methods "dunder methods".

*** DONE What's new in this chapter - 4
    CLOSED: [2021-04-04 Sun 22:05]
    Sine the Python Data Model is quite stable, there is few changes.

    - Ths most significant changes:
      * /Special methods/ supporting /asynchronous programming/ and _other new
        features_, added to the tables in "Overview of Special Methods".
        =TODO=

      * Figure 1-2 showing the use of /special methods/ in "Collection API",
        including the ~collections.abc.Collection~ /abstract base class/ introduced
        in Python 3.6.

    - Adopt the f-string syntax introduced in Python 3.6. 
      * Try to use this syntax, instead of the less readable ~str.format()~ and
        ~%~ operator.

      * Only use ~my_fmt.format()~ when building the template ~my_fmt~ at runtime.

*** DONE A Pythonic Card Deck - 5
    CLOSED: [2021-04-04 Sun 22:42]
    #+BEGIN_SRC python
      from collections import namedtuple

      Card = namedtuple('Card', ['rank', 'suit'])

      class FrenchDeck:
          ranks = tuple([str(n) for n in range(2, 11)] + ['J', 'K', 'Q', 'A'])
          suits = ('spades', 'diamonds', 'clubs', 'hearts')

          def __init__(self):
              self._cards = [Card(rank, suit)
                             for suit in self.suits
                             for rank in self.ranks]

          def __len__(self):
              return len(self._cards)

          def __getitem__(self, position):
              return self._cards[position]
    #+END_SRC

    - Usage:
      #+BEGIN_SRC python
        ## Create a card through the `Card` namedtuple
        beer_card = Card('7', 'diamonds')
        beer_card
        # Card(rank='7', suit='diamonds')

        ## Instance creation, and use `len`
        deck = FrenchDeck()
        len(deck)
        # 52

        ## Indexing
        deck[0]
        # Card(rank='2', suit='spades')
        deck[-1]
        # Card(rank='A', suit='hearts')

        ## Pick a random card
        from random import choice
        choice(deck)
        # Card(rank='3', suit='hearts')
        choice(deck)
        # Card(rank='K', suit='spades')
      #+END_SRC

    - Just by implementing the ~__getitem__~, our deck is also /iterable/ (then
      the ~reverse~ function can be applied).

    - /Iteration/ is often _implicit_.
      If a collection has *NO* ~__contains__~ method, the ~in~ operator does a
      _sequential scan_ (use ~__getitem__~).

    - *How About Shuffling?*
      By convention, a single underscore prefixed attribute is private -- cannot
      be accessed outside, and therefore de facto *immutable* (ONLY be convention).
      * We can't do shuffling now.

      * =TODO= Chapter 11
        Use ~__setitem__~ to make shuffling available.

*** DONE How Special Methods Are Used - 8
    CLOSED: [2017-09-07 Thu 20:09]
    - /Special methods/ should always be called by the Python interpreter, and
      NOT by you.

    - When measure the size, ~__len__~ is _NOT always_ used by the interpreter.

      For built-in types like ~list~, ~str~, ~bytearray~, and so on, the
      interpreter takes a shortcut:
        The /CPython/ implementation of ~len()~ actually returns the value of the
      ~ob_size~ field in the ~PyVarObject~ C struct that represents any
      _variable-sized built-in object_ in memory. This is _much faster_ than
      calling a method.

    - Unless you are doing a lot of /metaprogramming/, you should be implementing
      /special methods/ more often than invoking them explicitly.

    - The _ONLY_ /special method/ that is frequently called by user code directly
      is ~__init__~, to invoke the initializer of the superclass in your own
      ~__init__~ implementation.

    - _CONCLUSION_:
      If you need to invoke a /special method/,
      it is usually BETTER to call the related built-in function (e.g., ~len~,
      ~iter~, ~str~, etc).

      These built-ins call the corresponding /special method/, but often provide
      other services and -- for built-in types -- are faster than method calls.

      =TODO= See, for example, “A Closer Look at the iter Function” on page 436
      in Chapter 14.

    - _NEVER_ create a dunder identifier to your own use -- they can be
      /special methods/ in the future, even if they are not today; consider them
      as reserved names for the future /special methods/.

**** DONE Emulating Numeric Types - 9
     CLOSED: [2017-09-07 Thu 19:02]
     =TODO= More details in Chapter 13

     - What we want is
       #+BEGIN_SRC python
         v1 = Vector(2, 4)
         v2 = Vector(2, 1)
         v1 + v2              # Vector(4, 5)

         v = Vector(3, 4)
         abs(v)               # 5.0

         v * 3                # Vector(9, 12)


       #+END_SRC

     - Implementation (with ~__repr__~, ~__abs__~, ~__add__~, and ~__mul__~):
       #+BEGIN_SRC python
         from math import hypot
         # TODO: ???


         class Vector:
             def __init__(self, x=0, y=0):
                 self.x = x
                 self.y = y

             def __repr__(self):
                 return 'Vector({!r}, {!r})'.format(self.x, self.y)

             def __abs__(self):
                 return hypot(self.x, self.y)

             def __bool__(self):
                 return bool(abs(self))

             def __add__(self, other):
                 x = self.x + other.x
                 y = self.y + other.y
                 return Vector(x, y)

             def __mul__(self, scalar):
                 return Vector(self.x * scalar, self.y * scalar)
       #+END_SRC

**** DONE String Representation - 12
     CLOSED: [2017-09-07 Thu 19:54]
     - The ~__repr__~ /special method/ is called by the ~repr~ built-in.

     - If it wasn't implemented in the example of the last subsection, the
       printed out is like =<Vector object at 0x10e100070>=

     - The interactive console and debugger call repr on the results of the
       expressions evaluated. When print, use ~%r~ for ~%~ operator, and use
       ~!r~ for the ~format~ method or function.

     - The string returned by ~__repr__~ should be unambiguous and, if possible,
       match the source code necessary to re-create the object being represented
       (when use built-in ~eval~).
       #+BEGIN_SRC python
         repr(3)  # '3'
         repr('3')  # '"3"'
       #+END_SRC

     - If no ~__str__~ is implemented, ~__repr__~ will be the fallback.

     - StackOverflow Question:
       "Difference between ~__str__~ and ~__repr__~ in Python"
       Answers from Alex Martelli and Martijn Pieters

**** DONE Boolean Value of a Custom Type - 13
     CLOSED: [2017-09-07 Thu 20:09]
     - By default, instances of user-defined classes are considered truthy, unless
       either ~__bool__~ or ~__len__~ is implemented.

       Basically, ~bool(x)~ calls ~x.__bool__()~ and uses the result.
       If ~__bool__~ is not implemented, Python will try to invoke ~x.__len__()~,
       which returns ~True~ if it is non-zero.

     - The ~__bool__~ method should always do ~return bool(something)~
       If not, when you use built-in ~bool~, the result can be a non-boolean
       variable, even though, as in Python, it always has a boolean value.
       =IMPORTANT=

     - A faster ~__bool__~ implementation for our version of ~Vector~ (avoid
       using ~abs~):
       #+BEGIN_SRC python
         def __bool__(self):
             return bool(self.x or self.y)
       #+END_SRC

**** TODO Collection API - 14

*** DONE Overview of Special Methods - 15
    CLOSED: [2017-09-07 Thu 21:07]
    The “Data Model” chapter of The Python Language Reference lists 83 special
    method names, 47 of which are used to implement arithmetic, bitwise, and
    comparison operators

    - Table 1-1. Special method names (operators excluded)
      _READ THE BOOK_

    - Table 1-2. Special method names for operators
      _READ THE BOOK_

*** DONE Why ~len~ Is Not a Method - 17
    CLOSED: [2021-04-04 Sun 23:07]
    I (Luciano Ramalho) asked this question to core developer Raymond Hettinger
    in 2013 and the key to his answer was a quote from *The Zen of Python*:
    _"practicality beats purity."_

    - If the ~__len__~ is always called when calculating the length and size,
      some performance requirement can't be satisfied.
      * When ~len(built_in_object)~ is called, it simply read a field in the
        underlying C struct to get the length. This can be much efficient.

*** DONE Chapter Summary - 18
    CLOSED: [2021-04-04 Sun 23:02]
    By implementing /special methods/, your objects can *behave like the built-in
    types*, enabling the expressive coding style the community considers Pythonic.

    - There two possible string representations:
      * ~__repr__~ is for _debugging_ and _logging_
      * ~__str__~ is for end users.

*** TODO Further Reading - 18

** TODO 2. An Array of Sequences - 21
*** TODO What's New in This Chapter - 22
*** TODO Overview of Built-In Sequences - 22
    - The standard library offers a rich selection of sequence types implemented
      in C:
      * Container sequences :: ~list~, ~tuple~, and ~collections.deque~ can hold
           items of different types.

      * Flat sequences :: ~str~, ~bytes~, ~bytearray~, ~memoryview~, and
                          ~array.array~ hold items of one type.

    - Another way of grouping sequence types is by mutability:
      * Mutable sequences :: ~list~, ~bytearray~, ~array.array~,
           ~collections.deque~, and ~memoryview~

      * Immutable sequences :: ~tuple~, ~str~, and ~bytes~

    - Figure 2-1. UML class diagram for some classes from ~collectior.abc~
      =TODO=

    - Refer to /list comprehensions/ as /listcomps/;
      Refer to /generator/as /genexps/.

*** DONE List Comprehensions and Generator Expressions - 25
    CLOSED: [2017-09-07 Thu 21:39]
**** DONE List Comprehensions and Readability - 25
     CLOSED: [2017-09-07 Thu 21:34]
    - For readability: /listcomps/ should be short and no side-effect.

    - *Listcomps No Longer Leak Their Variables* in Python 3.

**** DONE Listcomps Versus map and filter - 27
     CLOSED: [2017-09-07 Thu 21:37]
**** DONE Cartesian Products - 27
     CLOSED: [2017-09-07 Thu 21:37]
     #+BEGIN_SRC python
       tshirts = [(color, size) for size in sizes
                                for color in colors]
     #+END_SRC
**** DONE Generator Expressions - 29
     CLOSED: [2017-09-07 Thu 21:39]

*** DONE Tuples Are Not Just Immutable Lists - 30
    CLOSED: [2017-09-07 Thu 22:07]
    Tuples do _double_ duty: they can be used
    + as immutable lists
    + as records with no field names.

    The second use is sometimes overlooked, so we will start with that.

**** DONE Tuples as Records - 30
     CLOSED: [2017-09-07 Thu 21:47]
     - Tuples hold records:
       each item in the tuple holds the data for one field and the position of
       the item gives its meaning.

     - Tuples work well as records because of the /tuple unpacking/ mechanism.

**** DONE Tuples as Immutable Lists - 32
     CLOSED: [2017-09-07 Thu 22:13]
     - Table 2-1. Methods and attributes found in list or tuple (methods
       implemented by object are omitted for brevity)

     - /tuple/ supports _all_ list methods _that do NOT involve_ *adding* or
       *removing* items (of course, here only in-place operations cannot be
       involved),

       with _ONE exception_ -- tuple lacks the ~__reversed__~ method, which is
       reasonable -- it's used for in-place reverse (should always have no return
       value). Since we cannot do in-place operations to /tuples/, this is just
       an optimization -- eliminate might-be-confusing /special method/;

       For /tuples/, ~reversed(my_tuple)~ works, and it works without
       ~__reversed__~.

       (=From Jian= from table, there is one method that /list/ doesn't implement

        ~s.__getnewargs__()~ that Support for optimized serialization with
        ~pickle~)
        =TODO=

**** DONE Comparing Tuple and List Methods - 34
*** TODO Unpacking Sequences and Iterables - 35
**** Using ~*~ to Grab Excess Items - 36
**** Unpacking with ~*~ in Function Calls and Sequence literals - 37
**** Nested Unpacking - 37

*** TODO Pattern Matching with Sequences - 38
**** Pattern Matching Sequences in an Iterpreter - 43

*** DONE Slicing - 47
    CLOSED: [2017-09-07 Thu 22:47]
    - =TODO= Implement a user-defined class with slicing will be covered in
      Chapter 10,

**** DONE Why Slices and Range Exclude the Last Item - 47
     CLOSED: [2017-09-07 Thu 22:27]
     - This convetion works well with zero-based indexing languages.

     - Some convenient features of the convention are:
       + It's easy to see the length of a /slice/ or /range/ when only the stop
         position is given:
         ~range(3)~ and ~my_list[:3]~ both produce _three_ items.

       + It's easy to compute the length of a /slice/ or /range/ when _start_ and
         _stop_ are given:
         just subtract _stop - start_.

       + It's easy to *split* a sequence in two parts at any index ~x~, without
         overlapping: simply get ~my_list[:x]~ and ~my_list[x:]~.

     - =TODO=
       But the best arguments for this convention were written by the Dutch
       computer scientist Edsger W. Dijkstra (see the last reference in “Further
       Reading” on page 59).

**** DONE Slice Objects - 48
     CLOSED: [2017-09-07 Thu 22:37]
     - =TODO= As we will see in “How Slicing Works” on page 281, to evaluate the
       expression ~seq[start:stop:step]~, Python calls
       ~seq.__getitem__(slice(start, stop, step))~.

     - Even if you are not implementing your own sequence types,
       knowing about /slice objects/ is useful
       because it lets you assign names to slices.

     - Example:
       #+BEGIN_SRC python
         invoice = """
         0.....6.................................40........52...55........
         1909  Pimoroni PiBrella                     $17.50    3    $52.50
         1489  6mm Tactile Switch x20                 $4.95    2    $9.90
         1510  Panavise Jr. - PV-201                 $28.00    1    $28.00
         1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95
         """

         SKU = slice(0, 6)
         DESCRIPTION = slice(6, 40)
         UNIT_PRICE = slice(40, 52)
         QUANTITY = slice(52, 55)
         ITEM_TOTAL = slice(55, None)

         line_items = invoice.split('\n')[2:]

         for item in line_items:
             print(item[UNIT_PRICE], item[DESCRIPTION])

         # $17.50 Pimoroni PiBrella
         # $4.95 6mm Tactile Switch x20
         # $28.00 Panavise Jr. - PV-201
         # $34.95 PiTFT Mini Kit 320x240
       #+END_SRC

     - =TODO= We’ll come back to slice objects when we discuss creating your own
       collections in “Vector Take #2: A Sliceable Sequence” on page 280.

**** TODO Multidimensional Slicing and ~Ellipsis~ - 49
     - =TODO= =RE-READ=

     - Slices are not just useful to extract information from sequences;

       they can also be used to change mutable sequences in place -- that is,
       without rebuilding them from scratch.

**** DONE Assigning to Slices - 50
     CLOSED: [2017-09-07 Thu 22:47]
     - Mutable sequences can be grafted, excised, and otherwise modified in place
       using slice notation on the left side of an assignment statement or as
       the target of a del statement.

     - Example:
       #+BEGIN_SRC python
         l = list(range(10))

         l[2:5] = [20, 30]
         l
         # [0, 1, 20, 30, 5, 6, 7, 8, 9]

         del l[5:7]
         l
         # [0, 1, 20, 30, 5, 8, 9]

         l[3::2] = [11, 22]
         l
         # [0, 1, 20, 11, 5, 22, 9]

         l[2:5] = 100
         l
         # TypeError: can only assign an iterable

         l[2:5] = [100]
         l
         # [0, 1, 100, 22, 9]
       #+END_SRC

*** DONE Using ~+~ and ~*~ with Sequences - 50
    CLOSED: [2017-09-07 Thu 22:56]
    - Trap:
      Suppose ~a~ is a sequence containing _mutable items_, and ~n~ is greater
      than 1.

      The result will contain n reference to the _mutable items_, and the
      consequence is: when you mutate one of this kind of item, the ones refer to
      it will also change -- acutally, the are just images to the mutated item.

**** DONE Building Lists of Lists - 51
     CLOSED: [2017-09-07 Thu 22:56]
     Use the /list comprehension/.
     #+BEGIN_SRC python
       board = [['_'] * 3 for i in range(3)]
       board
       # [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]

       board[1][2] = 'X'
       board
       # [['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]
     #+END_SRC

     - =TODO= next subsection
       The ~+=~ and ~*=~ operators produce very different results depending on the
       _mutability_ of the target sequence.

**** DONE Augmented Assignment with Sequences - 53
    CLOSED: [2017-09-10 Sun 01:34]
    The /augmented assignment/ operators ~+=~ and ~*=~ behave VERY DIFFERENTLY
    depending on _the FIRST operand_.

    To simplify the discussion, we will focus on augmented addition first (~+=~),
    but the concepts also apply to ~*=~ and to other augmented assignment
    operators.

    - =Important=
      =FROM JIAN= I THINK THIS IS A EXTREMELY BAD DESIGN!!!
      _MY REASONS_?????????? =TODO=
      The fallback of ~__iadd__~ (~__imul__~) is ~__add__~ (~__mul__~)!!!
      #+BEGIN_SRC python
        ## a mutable object
        l = [1, 2, 3]
        id(l)
        # 4311953800

        l *= 2
        l
        # [1, 2, 3, 1, 2, 3]

        id(l)
        # 4311953800
        ### Unchanged

        ## a immutable object, no in-place operation implemented, fallback to
        ## non-in-place operations.
        t = (1, 2, 3)
        id(t)
        # 4312681568

        t *= 2
        id(t)
        # 4301348296
        ### changed
      #+END_SRC

    - Repeated concatenation of immutable sequences is inefficient, because
      instead of just appending new items, the interpreter has to copy the whole
      target sequence to create a new one with the new items concatenated.3

      =FROM JIAN= WHY NOT USE implement with /persistence/ as Scala???

      - footnote:
        ~str~ is an exception to this description.
        Because string building with ~+=~ in loops is so common in the wild,
        CPython is optimized for this use case. ~str~ instances are allocated in
        memory with room to spare, so that concatenation does NOT require
        copying the whole string every time.

**** DONE A ~+=~ Assignment Puzzler - 54
     CLOSED: [2017-09-10 Sun 01:34]
     #+BEGIN_SRC python
       t = (1, 2, [30, 40])
       t[2] += [50, 60]

       # Traceback (most recent call last):
       #   File "<stdin>", line 1, in <module>
       # TypeError: 'tuple' object does not support item assignment

       t
       # (1, 2, [30, 40, 50, 60])
     #+END_SRC

     - Details ...... (disassemble the Python bytecode)

     - Conclusion:
       + Putting mutable items into a supposed immutable objects (e.g. tuple), is
         _NOT_ a good idea.

       + /Augmented assignment/ is _NOT_ an /atomic operation/ -- we just saw it
         throwing an exception after doing part of its job.

       + Inspecting Python bytecode is NOT too DIFFICULT, and is often helpful to
         see what is going on under the hood.

*** DONE ~list.sort~ Versus the ~sorted~ Built-In - 56
    CLOSED: [2017-09-10 Sun 00:25]
    - Python API convention: the value a in-place operation returns should be
      ~None~. For example, ~list.sort~ and ~random.shuffle~.

    - In-palce operation returns ~None~, and thus cascade calls can be applied
      any more.

    - Read "Fluent interface" entry in wiki. =TODO=

    - ~sorted~ accepts any iterable object as an argument, including generators
      (see Chapter 14). =TODO=

    - Both list.sort and sorted take two optional, keyword-only arguments:
      + ~reverse~: The default is ~False~.
      + ~key~: ......

    - The _standard binary search algorithm_ is already provided in the ~bisect~
      module of the Python standard library.
      =IMPORTANT=

    - ~bisect.insort~: use it to make sure that your sorted sequences stay
      sorted.
      =TODO= =???=

*** DONE [REMOVED] Managing Ordered Sequences with ~bisect~ - 44
    CLOSED: [2020-04-22 Wed 01:21]
    - The ~bisect~ module offers two main functions that exploit the /binary
      search algorithm/:
      + ~bisect~
      + ~insort~

**** DONE Searching with ~bisect~ - 44
     CLOSED: [2020-04-22 Wed 01:21]
     - ~bisect(haystack, needle)~
       returns the index that all the elements include the one at the returned
       index are less than or equal to the ~needle~.

     - TODO =TRY it= TODO
       Raymond Hettinger -- a prolific Python contributor -- has a
       _Sorted Collection recipe_ that leverages the ~bisect~ module
       BUT is _easier_ to use than these standalone functions.

     - The ~bisect~ function is an alias of ~bisect_right~.
       There is also an ~bisect_left~.
       + The difference between them is when the ~needle~ equals a value in haystack,
         * When using ~bisect~ / ~bisect_right~, insert it to the _right_.
         * When using ~bisect_left~, insert it to the _left_.

     - Read
       _Example 2-17. bisect finds insertion points for items in a sorted sequence_

     - Interesting example (Example 2-18) from _the ~bisect~ module documentation_.
       #+begin_src python
         def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
             i = bisect.bisect(breakpoints, score)
             return grades[i]

         [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]
         # ['F', 'A', 'C', 'C', 'B', 'A', 'A']
       #+end_src

**** DONE Inserting with ~bisect.insort~ - 47
     CLOSED: [2020-04-22 Wed 01:21]
     ~insort(seq, item)~ inserts ~item~ into seq so as to keep ~seq~ in _ascending
     order_.

     - Example 2-19. Insort keeps a sorted sequence always sorted.
       #+begin_src python
         import bisect
         import random

         SIZE = 7

         random.seed(1729)

         my_list = []
         for i in range(SIZE):
             new_item = random.randrange(SIZE * 2)
             bisect.insort(my_list, new_item)
             print(f'{new_item:>2d} -> {my_list}')
       #+end_src

     - Like ~bisect~, ~insort~ takes _optional_ ~lo~, ~hi~ arguments to _LIMIT
       the search to a subsequence_.

     - There is also an ~insort_left~ variation that uses ~bisect_left~ to find
       insertion points.

     - Python programmers sometimes overuse the ~list~ type because it is so handy
       -- I know I’ve done it.
       TODO next section TODO
         If you are handling _lists of numbers_, /arrays/ are the way to go. The
       remainder of the chapter is devoted to them.

*** TODO When a List Is Not the Answer - 59
    - For specific requirements, there are better options than ~list~:
      + Store 10 million floating-point values, an ~array~ is much more efficient.
          Just like the /array/ in Python's host language C, Python's ~array~ is
        very compact in memory.

      + For a sequence that need to operate its two ends frequently, use ~deque~.

**** DONE Arrays - 59
     CLOSED: [2020-04-22 Wed 01:55]
     - ~array.array~ supports
       + all mutable sequence operations (including ~.pop~, ~.insert~, and ~.extend~)
       + Fast loading and saving such as ~.frombytes~ and ~.tofile~

     - Create an array with typecode like:
       ~array('b')~, where ~'b'~ is the typecode for *signed char*. Each item must
       be a single byte (from -128 to 127).

     - Example 2-20. Creating, saving, and loading a large array of floats
       #+begin_src python
         from array import array
         from random import random

         floats = array('d', (random() for i in range(10**7)))
         floats[-1]  # 0.07802343889111107
         floats.tofile(open('floats.bin', 'wb'))

         floats2 = array('d')
         floats.fromfile(open('floats.bin', 'rb'), 10**7)
         floats2[-1]  # 0.07802343889111107

         floats2 == floats  # True
       #+end_src

     - ~pickle.dump(array)~ is almost as fast as with ~array.tofile~.
         However, the difference is ~pickle.dump~ can also handle almost all
       built-in types automatically.

     - TODO CHAPTER 4 TODO
       For the specific case of numeric arrays representing binary data, such as
       raster images, Python has the bytes and bytearray types discussed in
       Chapter 4.

     - Table 2-2. Methods and attributes found in list or array (deprecated array
       methods and those also implemented by object were omitted for brevity)
       TODO =RE-READ=

     - As of Python 3.4, ~array~ doesn't have in place sort method.
       Use ~a = array.array(a.typecode, sorted(a))~

**** TODO Memory Views - 62
**** TODO NumPy - 64
**** TODO Deques and Other Queues - 67

*** TODO Chapter Summary - 70
*** TODO Further Reading - 71

** TODO 3. Dictionaries and Sets - 77
*** TODO What's New in This Chapter - 78
*** TODO Modern ~dict~ Syntax - 78
**** TODO ~dict~ Comprehensions - 79
**** TODO Unpacking Mappings - 80
**** TODO Merging Mapping with ~|~ - 80

*** TODO Pattern Matching with Mappings - 81
*** TODO Standard API of Mapping Types - 83
**** TODO Whhat Is Hashable - 84
**** TODO Overview of Common Mapping Methods - 85
***** Handling Missing Keys with setdefault - 68

**** TODO Inserting or Updating Mutable Values - 87

*** TODO Automatic Handling of Missing Keys - 90
**** defaultdict: Another Take on Missing Keys - 90
**** The ~__missing__~ Method - 91
**** Inconsistent Usage of ~__missing__~ in the Standard Library - 94

*** TODO Variations of dict - 95
**** ~collections.OrderedDict~ - 95
**** ~collections.ChainMap~ - 95
**** ~collections.Counter~ - 96
**** ~shelve.Shelf~ - 97
**** Subclassing ~UserDict~ Instead of ~dict~ - 97

*** DONE Immutable Mappings - 99
    CLOSED: [2017-09-08 Fri 20:16]
    Since Python 3.3, the ~types~ module provides a wrapper class called
    ~MappingProxyType~, which, given a mapping, returns a ~mappingproxy~ instance
    that is a _read-only_ but _dynamic view_ of the original mapping -- updates
    to the original mapping can be seen in the ~mappingproxy~, but changes CANNOT
    be made through it. (=FROM JIAN= Consider this as a immutable reference to
    the original map)
    #+BEGIN_SRC python
      from types import MappingProxyType
      d = {'one': 'A'}
      d_proxy = MappingProxyType(d)

      d_proxy
      # mappingproxy({'one': 'A'})

      d_proxy['one']
      # 'A'

      d_proxy['two'] = 'B'
      ## TypeError: ...

      d['two'] = 'B'
      d_proxy
      # mappingproxy({'one': 'A', 'two': 'B'})

      d_proxy['two']
      # 'B'
    #+END_SRC

*** TODO Dictionary Views - 101
*** TODO Practical Consequences of How dict Works - 102
*** TODO Set Theory - 103
**** Set Literals - 105
**** Set Comprehensions - 106

*** TODO Practical Consequences of How Sets Work - 107
**** Set Operations - 107

*** TODO Set Operations on dict Views - 110
*** TODO Chapter Summary
*** TODO Further Reading

** TODO 4. Unicode Text versus Bytes - 117
*** TODO What's New in This Chapter - 118
*** TODO Character Issues - 118
*** TODO Byte Essentials - 120
*** TODO Basic Encoders/Decoders 123
*** TODO Understanding Encode/Decode Problems - 125
**** Coping with ~UnicodeEncodeError~ - 125
**** Coping with ~UnicodeDecodeError~ - 126
**** SyntaxError When Loading Modules with Unexpected Encoding - 128
**** How to Discover the Encoding of a Byte Sequence - 128
**** BOM: A Useful Gremlin - 129

*** TODO Handling Text Files - 131
**** Beware of Encoding Defaults - 134

*** TODO Normalizing Unicode for Reliable Comparisons - 140
**** Case Folding - 142
**** Utility Functions for Normalized Text Matching - 143
**** Extreme "Normalization": Taking Out Diacritics - 144

*** TODO Sorting Unicode Text - 148
**** Sorting with the Unicode Collation Algorithm - 150

*** TODO The Unicode Database - 150
**** TODO Finding Characters by Name - 151
**** TODO Numeric Meaning of Characters - 153

*** TODO Dual-Mode ~str~ and ~bytes~ APIs - 155
**** ~str~ Versus bytes in Regular Expressions - 155
**** ~str~ Versus bytes on ~os~ Functions - 156

*** TODO Chapter Summary - 157
*** TODO Further Reading - 158

** TODO 5. Data Class Builders - 163
   - data class ::
     a *simple* /class/ that is just
     + a bunch of /fields/
     + with LITTLE OR NO extra funcionality

   - Python offers a few ways to build /data classes/, and ~dataclass~ is the name
     of a /Python decorator/ that supports it.
       This chapter covers _THREE different class builders_ that you may use as
     shortcuts to write /data classes/:
     + ~collections.namedtuple~: the simplest way—since Python _2.6_;

     + ~typing.NamedTuple~: an alternative that allows /type annotations/ on the
       fields -- since Python _3.5_; class syntax supported since _3.6_;

     + ~@dataclasses.dataclass~: a /class decorator/ that allows *more customization
       than previous alternatives*, adding lots of options and potential complexity
       -- since Python _3.7_.

   - TODO ??? TODO
     After covering those class builders, we will discuss why Data Class is also
     the name of a code smell: a coding pattern that may be a symptom of poor
     object-oriented design.

   - The chapter ends with a section on a very different topic, but still closely
     related to _record-like data_: the ~struct~ module, designed to PARSE and
     BUILD *packed binary records* that you may find in legacy flat-file _databases_,
     _network protocols_, and _file headers_.
     TODO ??? TODO

   - NOTE TODO TODO TODO TODO TODO TODO
     ~typing.TypeDict~ (since Python _3.8_) may seem like another /data class
     builder/ -- it's described right after ~typing.NamedTuple~ in the ~typing~
     module documentation, and uses similar syntax.
       However, ~TypedDict~ does not build concrete classes that you can
     instantiate. It's just a way to write /static annotations/ for variables and
     function arguments that are expected to accept plain dictionaries with a
     fixed set of keys and a specific type for the value mapped to each key.

*** DONE What's New in This Chapter - 164
    CLOSED: [2020-04-27 Mon 02:52]
    This chapter is new in Fluent Python 2nd edition.
    - The sections _"Classic Named Tuples"_ and _"Structs and Memory Views"_ appeared
      in chapters 2 and 4 in the 1st edition,

    - but _the rest of the chapter is completely new._

*** DONE Overview of Data Class Builders - 164
    CLOSED: [2020-04-26 Sun 20:38]
    - The /data class builders/ covered in this chapter provide the necessary
      ~__init__~, ~__repr__~, and ~__eq__~ /methods/ *automatically*, as well as
      other useful features.
      + =from Jian= Just be similar to /case classes/ in Scala.

    - NOTE
      None of the class builders discussed here depend on inheritance to do
      their work.
      + Both ~collections.namedtuple~ and ~typing.NamedTuple~
        build /classes/ that are /tuple/ /subclasses/.

      + ~@dataclass~ is a /class decorator/ that does _NOT affect the /class
        hierarchy/ in any way_.

      + Each of them use *different* _metaprogramming techniques_ to _INJECT /methods/
        and /data attributes/ INTO the class under construction_.

    - Use ~namedtuple~
      #+begin_src python
        from collections import namedtuple


        Coordinate = namedtuple('Coordinate', 'lat long')
        issubclass(Coordinate, tuple)  # True
        moscow = Coordinate(55.756, 37.617)
        moscow  # Coordinate(lat=55.756, long=37.617)
        moscow == Coordinate(lat=55.756, long=37.617)  # True
      #+end_src

    - Use ~typing.NamedTuple~
      + Before Python 3.6, no extra funcionality:
        #+begin_src python
          from typing


          Coordinate = typing.NamedTuple('Coordinate', [('lat', float),  ('long', float)])
          issubclass(Coordinate, tuple)  # True
          Coordinate.__annotations__
          # {'lat': <class 'float'>, 'long': <class 'float'>}
        #+end_src

        * *TIP*
          Another (more readable) syntax for ~typing.NamedTuple~
          #+begin_src python
            Coordinate = typing.NamedTuple('Coordinate', lat=float, long=float)
          #+end_src

      + Since Python 3.6,
        ~typing.NamedTuple~ can also be used in a ~class~ statement, with /type
        annotations/ written as described in *PEP 526 -- Syntax for Variable
        Annotations*.
        * This is much MORE READABLE, and
          makes it easy to _override methods_ or _add new ones_.

        * Example 5-2 is the same ~Coordinate~ class, with a pair of ~float~ attributes
          and a custom ~__str__~ to display a coordinate formatted like 55.8°N, 37.6°E:
          #+begin_src python
            from typing import NamedTuple

            class Coordinate(NamedTuple):

                lat: float
                long: float

                def __str__(self):
                    ns = 'N' if self.lat >= 0 else 'S'
                    we = 'E' if self.long >= 0 else 'W'
                    return f"{abs(self.lat):.1f}°{ns}, {abs(self.long):.1f}°{we}"
          #+end_src
          - *WARNING*
            Although ~NamedTuple~ appears in the class statement as a superclass, it’s
            actually not. typing.NamedTuple uses the advanced functionality of a
            metaclass2 to customize the creation of the user’s class. Check this out:
            #+begin_src python
              issubclass(Coordinate, typing.NamedTuple)  # False
              issubclass(Coordinate, tuple)              # True
            #+end_src
            In the ~__init__~ /method/ *generated* by ~typing.NamedTuple~, the /fields/
            appear as parameters _in the SAME ORDER they appear in the /class statement/._

    - Use ~dataclass~
      _Like ~typing.NamedTuple~, the /dataclass decorator/ supports *PEP 526* syntax to
      declare instance attributes._ The /decorator/ reads the variable annotations
      and automatically generates methods for your class.
      #+begin_src python
        from dataclasses import dataclass


        @dataclass(frozen=True)
        class Coordinate:
            lat: float
            long: float
      #+end_src
      + Note that the body of the classes in Example 5-2 and Example 5-3 are
        identical—the difference is in the class statement itself.

      + The ~@dataclass~ /decorator/ does *NOT depend on* /inheritance/ or a
        /metaclass/, so it should not interfere with your own use of these
        mechanisms.
        #+begin_src python
          issubclass(Coordinate, typing.NamedTuple)  # False
          issubclass(Coordinate, tuple)              # False
          issubclass(Coordinate, object)             # True
        #+end_src

**** Main Features - 167
     The different data class builders have a lot of common. Here we’ll discuss
     the main features they share. Table 5-1 summarizes.
     - Table 5-1. =IMPORTANT= =RE-READ=
       Selected features compared accross the THREE /data class builders/. ~x~
       stands for an instance of a /data class/ of that kind.

*** DONE Classic Named Tuples - 169
    CLOSED: [2020-04-27 Mon 02:52]
    - *TIP*
      + EACH /instance/ of a /class/ built by ~namedtuple~ takes *EXACTLY the SAME
        amount of memory* a ~tuple~ because the /field names/ are stored in the
        /class/ (rather than in each /instance/).

      + They use *LESS memory than a regular object (=from Jian= /class/ based
        object?)* because they do *NOT* store attributes as key-value pairs in
        one ~__dict__~ for EACH /instance/.

    - Besides the methods a ~tuple~ has, a ~namedtuple~ also has ~_fields~ /class
      attribute/, the /class method/ ~_make(iterable)~, and the /instance method/
      ~_asdict()~.
      + ~._asdict()~ is useful to serialize the data in JSON format, for example.
        TODO =LEARN MORE= TODO

    - *WARNING*
      + The ~_asdict()~ /method/ returned an ~OrderedDict~ in
        _Python 2.7_, and in _Python 3.1 TO 3.7_.

      + Since _Python 3.8_, a regular ~dict~ is returned -- which is probably fine
        now that we *can rely on* _key insertion order_ (because of the new
        implementation of ~dict~).

      + If you must have an ~OrderedDict~ when you use _Python 3.8+_, the ~_asdict~
        documentation recommends building one from the result:
        ~OrderedDict(x._asdict())~.

    - Since Python 3.7, namedtuple accepts the ~defaults~/ keyword-only argument/
      providing an /iterable/ of _N default values for each of the N *rightmost*
      fields_ of the /class/.
      + Example 5-6 show how to define a ~Coordinate~ ~namedtuple~ with a ~default~
        value for a reference field:
        #+begin_src python
          Coordinate = namedtuple('Coordinate', 'lat long reference', defaults=['WGS84'])
          Coordinate(0, 0)            # Coordinate(lat=0, long=0, reference='WGS84')
          Coordinate._field_defaults  # {'reference': 'WGS84'}
        #+end_src

    - There are straight forward ways to add methods to ~typing.NamedTuple~ and
      ~@dataclass~ annotated /class/. For ~namedtuple~, we can also do this, but
      must with some hack. See below!

    - *HACKING A NAMEDTUPLE TO INJECT A METHOD*
      Define a function and then assign it to a /class attribute/.
      #+begin_src python
        Card = collections.nametuple('Card', ['rank', 'suit'])

        # Attach a class attribute with values for each suit.
        Card.suit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0)

        def spades_high(card):
            rank_value = FrenchDeck.ranks.index(card.rank)
            suit_value = card.suit_values[card.suit]
            return rank_value * len(card.suit_values) + suit_value

        # Attach the spades_high function to the Cards class.
        # It becomes a method named overall_rank.
        Card.overall_rank = spades_high

        lowest_card = Card('2', 'clubs')
        highest_card = Card('A', 'spades')

        lowest_card.overall_rank()  # 0
        highest_card.overall_rank()  # 51
      #+end_src
      + =from Jian=
        From the observation, the ~overall_rank~ use ~self~ as the ~card~ for
        ~spades_high~. ~overall_rank~ is an /instance method/.
        * TODO Learn more about this!
          1. Can ~spades_high~ take more parameters?
          2. Do the parameters _except the first one_ are considered as normal
             /method parameters/?

*** DONE Typed Named Tuples - 172
    CLOSED: [2020-04-27 Mon 02:58]
    - Example 5-8. ~typing.NamedTuple~
      #+begin_src python
        from typing import NamedTuple


        class Coordinate(NamedTuple):
            lat: float
            long: float
            reference: str = 'WGS84'
      #+end_src

    - /Classes/ built by ~typing.NamedTuple~ _do NOT have any methods BEYOND_
      those that ~collections.namedtuple~ also generates -- and those that are
      inherited from ~tuple~.
      + _The Only difference AT RUNTIME_ is the presence of the ~__attributes__~
        /class field/ -- _which Python completely ignores AT RUNTIME._

    - *WARNING*
      + BEFORE Python 3.8, classes built with ~typing.NamedTuple~ also have a
        ~_field_types~ /attribute/.

      + SINCE Python 3.8, that /attribute/ is *deprecated* in favor of ~__annotations__~
        which has the same information and is the _canonical place_ to find /type
        hints/ in Python objects that have them.

*** TODO Type Hints 101 - 173
    - /Type hints/ -- a.k.a. /type annotations/

    - NOTE
      TODO No complete info for this Early Release version.
      Talk about type hints for function signatures and advanced annotations in
      the future.

**** DONE No Runtime Effect - 173
     CLOSED: [2020-04-26 Sun 20:55]
     - Example 5-9. Python does not enforce type hints at runtime.
       #+begin_src python
         import typing


         class Coordinate(typing.NamedTuple):
             lat: float
             long: float


         trash = Coordinate('foo', None)
         print(trash)
         # Coordinate(lat='foo', long=None)
       #+end_src

     - The /type hints/ are intended primarily to support *third-party* /type
       checkers/.

     - If we run ~mypy nocheck_demo.py  # The code includes the Example 5-9 code~,
       we can see:
       #+begin_src note
       nocheck_demo.py:8: error: Argument 1 to "Coordinate" has
       incompatible type "str"; expected "float"
       nocheck_demo.py:8: error: Argument 2 to "Coordinate" has
       incompatible type "None"; expected "float"
       #+end_src

**** DONE Variable Annotation Syntax - 174
     CLOSED: [2020-04-26 Sun 21:00]
     - The type that goes after the ~:~ must be an _identifier_ for one of these
       (See Acceptable /type hints/ in *PEP 484* for all details):
       + a *concrete* /class/, for example ~str~ or ~FrenchDeck~;

       + an ABC -- /abstract base class/;

       + a type defined in the ~typing~ module, including special types and
         constructs like ~Any~, ~Optional~, ~Union~, etc.;

       + a /type alias/ -- as described in the ~Type~ aliases section of the
         ~typing~ module documentation.

**** TODO The Meaning of Variable Annotations - 175
     - We saw in "No runtime effect" that /type hints/ have *NO* _effect at runtime_.
       But _at import time_ -- when a module is loaded -- Python does read them
       to build the ~__annotations__~ dictionary that ~typing.NamedTuple~ and
       ~@dataclass~ then use to *enhance* the /class/.

     - Example 5-10. =demo_plain.py=: a plain /class/ with /type hints/
       #+begin_src python
         class DemoPlainClass:
             a: int
             b: float = 1.1
             c = 'spam'
       #+end_src
       + Check the annotation:
         ~c~ is not annotated, and no info saved to ~__annotation__~.
         #+begin_src python
           from demo_plain import DemoPlainClass


           DemoPlainClass.__annotations__
           # {'a': <class 'int'>, 'b': <class 'float'>}

           DemoPlainClass.a
           ## Traceback (most recent call last):
           ##   File "<stdin>", line 1, in <module>
           ## AttributeError: type object 'DemoPlainClass' has no attribute 'a'

           DemoPlainClass.b  # 1.1

           DemoPlainClass.c  # 'spam'
         #+end_src

       + However, since ~a~ was not given a value and it can't become a /class
         attribute/ but annotated, this is why ~a~ info is in
         ~DemoPlainClass.__annotations__~, but we can't evaluate its value
         through ~DemoPlainClass.a~.

*** TODO More About ~@dataclass~ - 179
**** Field Options - 180
     - WARNING

**** Post-init Processing - 183
     - NOTE

**** Typed Class Attributes - 185
**** Initialization Variables That Are Not Fields - 186
**** ~@dataclass~ Example: Dublin Core Resource Record - 187

*** TODO Data class as a Code Smell - 190
    - *CODE SMELL*

**** TODO Data Class as Scaffolding - 191
**** TODO Data Class as Intermediate Representation - 191

*** TODO Pattern Matching Class instances - 192
**** Simple Class Patterns - 192
**** Keyword Class Patterns - 193
**** Positional Class Patterns - 194

*** TODO Chapter Summary - 195
*** TODO Further Reading - 196
    - *SOAPBOX*

** TODO 6. Object References, Mutability, and Recycling - 201
*** What's New in This Chapter - 202
*** Variables Are Not Boxes - 202
*** Identity, Equality, and Aliases - 204
**** Choosing Between ~==~ and ~is~ - 206
**** The Relative Immutability of Tuples - 207

*** Copies Are Shallow by Default - 208
**** Deep and Shallow Copies of Arbitrary Objects - 211

*** Function Parameters as References - 213
**** Mutable Types as Parameter Defaults: Bad Idea - 214
**** Defensive Programming with Mutable Parameters - 216

*** ~del~ and Garbage Collection - 219
*** Tricks Python Plays with Immutables - 221
*** Chapter Summary - 223
*** Further Reading - 224

* TODO Part II. Functions as Objects
** 7. Functions as First-Class Objects - 231
*** What's New in This Chapter - 232
*** Treating a Function Like an Object - 232
*** Higher-Order Functions - 234
**** Modern Replacements for map, filter, and reduce - 235

*** Anonymous Functions - 236
*** The Nine Flavors of Callable Objects - 237
*** User-Defined Callable Types - 239
*** From Positional to Keyword-Only Parameters - 240
**** Positional-Only Parameters - 242

*** Packages for Functional Programming - 243
**** The operator Module - 243
**** Freezing Arguments with functools.partial - 247

*** Chapter Summary - 249
*** Further Reading - 250

** 8. Type Hints in Functions - 253
*** What's New in This Chapter - 254
*** About Gradual Typing - 254
*** Gradual Typing in Practice - 255
**** Starting with Mypy - 256
**** Making Mypy More Strict - 257
**** A Default Parameter Value - 258
**** Using None as a Default - 260

*** Types Are Defined by Supported Operations - 260
*** Types Usable in Annotations - 266
**** The Any Type - 266
**** Simple Types and Classes - 269
**** Optional and Union Types - 270
**** Generic Collections - 271
**** Tuple Types - 274
**** Generic Mappings - 276
**** Abstract Base Classes - 278
**** Iterable - 280
**** Parameterized Generics and TypeVar - 282
**** Static Protocols - 286
**** Callable - 291
**** NoReturn - 294

*** Annotating Positional Only and Variadic Parameters - 295
*** Imperfect Typing and Strong Testing - 296
*** Chapter Summary - 297
*** Further Reading - 298

** 9. Decorators and Closures - 303
*** What's New in This Chapter - 304
*** Decorators 101 - 304
*** When Python Executes Decorators - 306
*** Registration Decorators - 308
*** Variable Scope Rules - 308
*** Closures - 311
*** The nonlocal Declaration - 315
**** Variable Lookup Logic - 316

*** Implementing a Simple Decorator - 317
**** How It Works - 318

*** Decorators in the Standard Library - 320
**** Memoization with functools.cache - 320
**** Using ~lru_cache~ - 323
**** Single Dispatch Generic Functions - 324

*** Parameterized Decorators - 329
**** A Parameterized Registration Decorator - 329
**** The Parameterized Clock Decorator - 332
**** A Class-Based Clock Decorator - 335

*** Chapter Summary - 336
*** Further Reading - 336

** 10. Design Patterns with First-Class Functions - 341
*** What's New in This Chapter - 342
*** Case Study: Refactoring Strategy - 342
**** Classic Strategy - 342
**** Function-Oriented Strategy - 347
**** Choosing the Best Strategy: Simple Approach - 350
**** Finding Strategies in a Module - 351

*** Decorator-Enhanced Strategy Pattern - 353
*** The Command Pattern - 355
*** Chapter Summary - 357
*** Further Reading - 358

* TODO Part III. Classes and Protocols
** TODO 11. A Pythonic Object - 363
*** What's New in This Chapter - 364
*** Object Representations - 364
*** Vector Class Redux - 365
*** An Alternative Constructor - 368
*** ~classmethod~ Versus ~staticmethod~ - 369
*** Formatted Displays - 370
*** A Hashable Vector2d - 374
*** Supporting Positional Pattern Matching - 377
*** Complete Listing of Vector2d, Version 3 - 378
*** Private and "Protected" Attributes in Python - 382
*** Saving Memory with ~__slots__~ - 384
**** Simple Measure of ~__slot__~ Savings - 387
**** Summarizing the Issues with ~__slots__~ - 388

*** Overriding Class Attributes - 389
*** Chapter Summary - 391
*** Further Reading - 392

** TODO 12. Special Methods for Sequences - 397
*** What's New in This Chapter - 398
*** Vector: A User-Defined Sequence Type - 398
*** Vector Take #1: Vector2d Compatible - 399
*** Protocols and Duck Typing - 402
*** Vector Take #2: A Sliceable Sequence - 403
**** How Slicing Works - 404
**** A Slice-Aware ~__getitem__~ - 406

*** Vector Take #3: Dynamic Attribute Access - 407
*** Vector Take #4: Hashing and a Faster ~==~ - 411
*** Vector Take #5: Formatting - 418
*** Chapter Summary - 425
*** Further Reading - 426

** TODO 13. Interfaces, Protocols, and ABCs - 431
*** The Typing Map - 432
*** What’s New in This Chapter - 433
*** Two Kinds of Protocols - 434
*** Programming Ducks - 435
**** Python Digs Sequences - 436
**** Monkey Patching: Implementing a Protocol at Runtime - 438
**** Defensive Programming and “Fail Fast” - 440

*** Goose Typing - 442
**** Subclassing an ABC - 447
**** ABCs in the Standard Library - 449
**** Defining and Using an ABC - 451
**** ABC Syntax Details - 457
**** Subclassing an ABC - 458
**** A Virtual Subclass of an ABC - 460
**** Usage of register in Practice - 463
**** Structural Typing with ABCs - 464

*** Static Protocols - 466
**** The Typed double Function - 466
**** Runtime Checkable Static Protocols - 468
**** Limitations of Runtime Protocol Checks - 471
**** Supporting a Static Protocol - 472
**** Designing a Static Protocol - 474
**** Best Practices for Protocol Design - 476
**** Extending a Protocol - 477
**** The numbers ABCs and Numeric Protocols - 478

*** Chapter Summary - 481
*** Further Reading - 482

** 14. Inheritance: For Good or For Worse - 487
** TODO 15. More About Type Hints - 519
This chapter is a sequel to _Chapter 8_, covering more of Python's /gradual type
system/. The main topics are:
_ Overloaded function signatures
_ ~typing.TypedDict~ for type hinting ~dict~'s used as records
_ Type casting
_ Runtime access to type hints
_ Generic types
  * Declaring a /generic class/
  * /Variance/: /invariant/, /covariant/, and /contravariant/ types
  * /Generic static protocols/

*** What's New in This Chapter - 519
*** DONE Overloaded Signatures - 520
CLOSED: [2024-11-13 Wed 19:44]
=from Jian=
- This section is useful if you want to do case study for type hint usages.

- What I get from this section is that
  _I'D BETTER_ choose a modern static typed langauge with type inference and a
  good type system,
  _RATHER THAN_ learn all the details of Python's type hints.

**** Max Overload - 521
***** Arguments implementing SupportsLessThan, but key and default not provided - 524
***** Argument key provided, but no default - 524
***** Argument default provided, but no key - 525
***** Arguments key and default provided - 525

**** Takeaways from Overloading max - 525

=NEXT=
Now let’s study the ~TypedDict~ typing construct. It is not as useful as I imagined at
first, but has its uses.

- Experimenting with ~TypedDict~ demonstrates the limitations of static typing for
  handling dynamic structures, such as JSON data.
  =from Jian=
  *This conclusion is wrong!* It can't demonstrate!
  Just pick a good modern static typing language!!!

*** DONE TypedDict - 526
CLOSED: [2024-11-13 Wed 20:14]
- For runtime checking of JSON-like structures using type hints, check out the
  *pydantic* package on PyPI.

- The syntactic similarity is misleading. ~TypedDict~ is very different from
  /dataclass/ or ~typing.NamedTuple~. It exists only for the benefit of /type
  checkers/, and has *NO runtime effect*.

- ~TypedDict~ provides two things:
  * Class-like syntax to annotate a dict with type hints for the value of each
    “field.”

  * A constructor that tells the type checker to expect a dict with the keys and
    values as specified.

- Example: ~BookDict~
  * The /type hints/ are in ~BookDict.__annotations__~, and not in ~pp~.

- The fact that ~BookDict~ creates a plain ~dict~ also means that:
  * The "fields" in the pseudoclass definition *DON'T create instance attributes*.
  * You *can't* write /initializers/ with default values for the "fields."
  * /Method definitions/ are *NOT allowed*.

- =IMPORTANT=
  Combine ~typing.TYPE_CHECKING~ with ~reveal_type(..)~ (from mypy, no import
  clause needed), we can see some useful info from mypy check output.

- ~TypedDict~ has more features, including support for
  * optional keys,
  * a limited form of inheritance, and
  * an alternative declaration syntax.

  If you want to know more about it, please review
  *PEP 589 - TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys*.

*** TODO Type Casting - 534
~typing.cast()~

- xxx
- xxx

*** TODO Reading Type Hints at Runtime - 537
**** Problems with Annotations at Runtime - 538
**** Dealing with the Problem - 540

*** TODO Implementing a Generic Class - 541
**** Basic Jargon for Generic Types - 544

*** TODO Variance - 544
**** An Invariant Dispenser - 545
**** A Covariant Dispenser - 546
**** A Contravariant Trash Can - 547
**** Variance Review - 549

*** TODO Implementing a Generic Static Protocol - 552
*** Chapter Summary - 554
*** Further Reading - 555

** TODO 16. Operator Overloading: Doing It Right - 561
*** What's New in This Chapter - 562
*** Operator Overloading 101 - 562
*** Unary Operators - 563
*** Overloading + for Vector Addition - 566
*** Overloading * for Scalar Multiplication - 572
*** Using @ as an Infix Operator - 574
*** Wrapping-Up Arithmetic Operators - 576
*** Rich Comparison Operators - 577
*** Augmented Assignment Operators - 580
*** Chapter Summary - 585
*** Further Reading - 587

* TODO Part IV. Control Flow
** 17. Iterators, Generators, and Classic Coroutines - 593
** 18. with, match, and else Blocks - 657
** 19. Concurrency Models in Python - 695
** 20. Concurrent Executors - 743
** 21. Asynchronous Programming - 775

* TODO Part V. Metaprogramming
** 22. Dynamic Attributes and Properties - 835
- /Data attributes/ and /methods/ are collectively known as /attributes/ in Python.

- A /method/ is an _attribute_ that is /callable/.

- /Dynamic attributes/ present the same interface as /data attributes/ --
  i.e., ~obj.attr~ -- but are _computed on demand_.
  This follows
  * Bertrand Meyer's /Uniform Access Principle/:
    #+begin_quote
    All services offered by a module should be available through _a uniform
    notation_, which does not betray whether they are implemented through
    storage or through computation.
    #+end_quote

- There are several ways to implement /dynamic attributes/ in Python.
  This chapter covers the simplest ways:
  * the ~@property~ /decorator/
  * the ~__getattr__~ /special method/.

*** What's New in This Chapter - 836
*** Data Wrangling with Dynamic Attributes - 836
**** Exploring JSON-Like Data with Dynamic Attributes - 838
**** The Invalid Attribute Name Problem - 842
**** Flexible Object Creation with ~__new__~ - 843

*** Computed Properties - 845
**** Step 1: Data-Driven Attribute Creation - 846
**** Step 2: Property to Retrieve a Linked Record - 848
**** Step 3: Property Overriding an Existing Attribute - 852
**** Step 4: Bespoke Property Cache - 853
**** Step 5: Caching Properties with functools - 855

*** Using a Property for Attribute Validation - 857
**** LineItem Take #1: Class for an Item in an Order - 857
**** LineItem Take #2: A Validating Property - 858

*** A Proper Look at Properties - 860
**** Properties Override Instance Attributess - 861
**** Property Documentation - 864

*** Coding a Property Factory - 865
*** Handling Attribute Deletion - 868
*** Essential Attributes and Functions for Attribute Handling - 869
**** Special Attributes that Affect Attribute Handling - 870
**** Built-In Functions for Attribute Handling - 870
**** Special Methods for Attribute Handling - 871

*** Chapter Summary - 873
*** Further Reading - 873

** 23. Attribute Descriptors - 879
*** What's New in This Chapter - 880
*** Descriptor Example: Attribute Validation - 880
**** LineItem Take #3: A Simple Descriptor - 880
**** LineItem Take #4: Automatic Naming of Storage Attributes - 887
**** LineItem Take #5: A New Descriptor Type - 889

*** Overriding Versus Nonoverriding Descriptors - 892
**** Overriding Descriptors - 894
**** Overriding Descriptor Without ~__get__~ - 895
**** Nonoverriding Descriptor - 896
**** Overwriting a Descriptor in the Class - 897

*** Methods Are Descriptors - 898
*** Descriptor Usage Tips - 900
*** Descriptor Docstring and Overriding Deletion - 902
*** Chapter Summary - 903
*** Further Reading - 904

** 24. Class Metaprogramming - 907
*** What's New in This Chapter - 908
*** Classes as Objects - 908
*** type: The Built-In Class Factory - 909
*** A Class Factory Function - 911
*** Introducing ~__init_subclass__~ - 914
**** Why ~__init_subclass__~ Cannot Configure ~__slots__~ - 921

*** Enhancing Classes with a Class Decorator - 922
*** What Happens When: Import Time Versus Runtime - 925
**** Evaluation Time Experiments - 926

*** Metaclasses 101 - 931
**** How a Metaclass Customizes a Class - 933
**** A Nice Metaclass Example - 934
**** Metaclass Evaluation Time Experiment - 937

*** A Metaclass Solution for Checked - 942
*** Metaclasses in the Real World - 947
**** Modern Features Simplify or Replace Metaclasses - 947
**** Metaclasses Are Stable Language Features - 948
**** A Class Can Only Have One Metaclass - 948
**** Metaclasses Should Be Implementation Details - 949

*** A Metaclass Hack with ~__prepare__~ - 950
*** Wrapping Up - 952
*** Chapter Summary - 953
*** Further Reading - 954

* Afterword - 959
* Index - 963
