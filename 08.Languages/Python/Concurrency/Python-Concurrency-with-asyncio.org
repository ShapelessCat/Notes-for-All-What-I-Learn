#+TITLE:  Python Concurrency with asyncio
#+VERSION: February 2022
#+AUTHOR: Matthew Fowler
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* preface - xi
* acknowledgments - xiii
* about this book - xiv
* about the author - xvii
* about the cover illustration - xviii
* 1 Getting to know asyncio - 1
** 1.1 What is asyncio? - 2
** 1.2 What is I/O-bound and what is CPU-bound? - 3
** 1.3 Understanding concurrency, parallelism, and multitasking - 4
*** Concurrency - 4
*** Parallelism - 5
*** The difference between concurrency and parallelism - 6
*** What is multitasking? - 7
*** The benefits of cooperative multitasking - 7

** 1.4 Understanding processes, threads, multithreading, and multiprocessing - 8
*** Process - 8
*** Thread - 8

** 1.5 Understanding the global interpreter lock - 12
*** Is the GIL ever released? - 15
*** asyncio and the GIL - 17

** 1.6 How single-threaded concurrency works - 17
*** What is a socket? - 17

** 1.7 How an event loop works - 20

* 2 asyncio basics - 23
** 2.1 Introducing coroutines - 24
*** Creating coroutines with the async keyword - 24
*** Pausing execution with the await keyword - 26

** 2.2 Introducing long-running coroutines with sleep - 27
** 2.3 Running concurrently with tasks - 30
*** The basics of creating tasks - 30
*** Running multiple tasks concurrently - 31

** 2.4 Canceling tasks and setting timeouts - 33
*** Canceling tasks - 34
*** Setting a timeout and canceling with ~wait_for~ - 35

** 2.5 Tasks, coroutines, futures, and awaitables - 37
*** Introducing futures - 37
*** The relationship between futures, tasks, and coroutines - 39

** 2.6 Measuring coroutine execution time with decorators - 40
** 2.7 The pitfalls of coroutines and tasks - 42
*** Running CPU-bound code - 42
*** Running blocking APIs - 44

** 2.8 Accessing and manually managing the event loop - 45
*** Creating an event loop manually - 46
*** Accessing the event loop - 46

** 2.9 Using debug mode - 47
*** Using asyncio.run - 47
*** Using command-line arguments - 47
*** Using environment variables - 48

* 3 A first asyncio application - 50
** 3.1 Working with blocking sockets - 51
** 3.2 Connecting to a server with Telnet - 53
*** Reading and writing data to and from a socket - 54
*** Allowing multiple connections and the dangers of blocking - 56

** 3.3 Working with non-blocking sockets - 57
** 3.4 Using the selectors module to build a socket event loop - 61
** 3.5 An echo server on the asyncio event loop - 64
*** Event loop coroutines for sockets - 64
*** Designing an asyncio echo server - 65
*** Handling errors in tasks - 67

** 3.6 Shutting down gracefully - 69
*** Listening for signals - 69
*** Waiting for pending tasks to finish - 70

* 4 Concurrent web requests - 75
** 4.1 Introducing aiohttp - 76
** 4.2 Asynchronous context managers - 77
*** Making a web request with aiohttp - 79
*** Setting timeouts with aiohttp - 81

** 4.3 Running tasks concurrently, revisited - 82
** 4.4 Running requests concurrently with gather - 84
*** Handling exceptions with gather - 86

** 4.5 Processing requests as they complete - 88
*** Timeouts with ~as_completed~ - 90

** 4.6 Finer-grained control with wait - 92
*** Waiting for all tasks to complete - 92
*** Watching for exceptions - 94
*** Processing results as they complete - 96
*** Handling timeouts - 99
*** Why wrap everything in a task? - 100

* 5 Non-blocking database drivers - 102
** 5.1 Introducing asyncpg - 103
** 5.2 Connecting to a Postgres database - 103
** 5.3 Defining a database schema - 104
** 5.4 Executing queries with asyncpg - 107
** 5.5 Executing queries concurrently with connection pools - 109
*** Inserting random SKUs into the product database - 110
*** Creating a connection pool to run queries concurrently - 113

** 5.6 Managing transactions with asyncpg - 118
*** Nested transactions - 119
*** Manually managing transactions - 120

** 5.7 Asynchronous generators and streaming result sets - 122
*** Introducing asynchronous generators - 123
*** Using asynchronous generators with a streaming cursor - 124

* 6 Handling CPU-bound work - 128
** 6.1 Introducing the multiprocessing library - 129
** 6.2 Using process pools - 131
*** Using asynchronous results - 132

** 6.3 Using process pool executors with asyncio - 133
*** Introducing process pool executors - 133
*** Process pool executors with the asyncio event loop - 134

** 6.4 Solving a problem with MapReduce using asyncio - 136
*** A simple MapReduce example - 137
*** The Google Books Ngram dataset - 139
*** Mapping and reducing with asyncio - 140

** 6.5 Shared data and locks - 145
*** Sharing data and race conditions - 146
*** Synchronizing with locks - 149
*** Sharing data with process pools - 151

** 6.6 Multiple processes, multiple event loops - 154

* 7 Handling blocking work with threads - 159
** 7.1 Introducing the threading module - 160
** 7.2 Using threads with asyncio - 164
*** Introducing the requests library - 164
*** Introducing thread pool executors - 165
*** Thread pool executors with asyncio - 167
*** Default executors - 168

** 7.3 Locks, shared data, and deadlocks - 169
*** Reentrant locks - 171
*** Deadlocks - 173

** 7.4 Event loops in separate threads - 175
*** Introducing Tkinter - 176
*** Building a responsive UI with asyncio and threads - 178

** 7.5 Using threads for CPU-bound work - 185
*** Multithreading with hashlib - 185
*** Multithreading with NumPy - 188

* 8 Streams - 191
** 8.1 Introducing streams - 192
** 8.2 Transports and protocols - 192
** 8.3 Stream readers and stream writers - 196
** 8.4 Non-blocking command-line input - 198
*** Terminal raw mode and the read coroutine - 202

** 8.5 Creating servers - 209
** 8.6 Creating a chat server and client - 211

* 9 Web applications - 217
** 9.1 Creating a REST API with aiohttp - 218
*** What is REST? - 218
*** aiohttp server basics - 219
*** Connecting to a database and returning results - 220
*** Comparing aiohttp with Flask - 226

** 9.2 The asynchronous server gateway interface - 228
*** How does ASGI compare to WSGI? - 228

** 9.3 ASGI with Starlette - 230
*** A REST endpoint with Starlette - 230
*** WebSockets with Starlette - 231

** 9.4 Django asynchronous views - 235
*** Running blocking work in an asynchronous view - 240
*** Using async code in synchronous views - 242

* 10 Microservices - 244
** 10.1 Why microservices? - 245
*** Complexity of code - 245
*** Scalability - 246
*** Team and stack independence - 246
*** How can asyncio help? - 246

** 10.2 Introducing the backend-for-frontend pattern - 246
** 10.3 Implementing the product listing API - 248
*** User favorite service - 248
*** Implementing the base services - 249
*** Implementing the backend-for-frontend service - 253
*** Retrying failed requests - 258
*** The circuit breaker pattern - 261

* 11 Synchronization - 267
** 11.1 Understanding single-threaded concurrency bugs - 268
** 11.2 Locks - 272
** 11.3 Limiting concurrency with semaphores - 276
*** Bounded semaphores - 278

** 11.4 Notifying tasks with events - 280
** 11.5 Conditions - 285

* 12 Asynchronous queues - 290
** 12.1 Asynchronous queue basics - - 291
*** Queues in web applications - - 297
*** A web crawler queue - - 300

** 12.2 Priority queues - - 303
** 12.3 LIFO queues - - 309

* 13 Managing subprocesses - 312
** 13.1 Creating a subprocess - 313
*** Controlling standard output - 315
*** Running subprocesses concurrently - 318

** 13.2 Communicating with subprocesses - 322

* 14 Advanced asyncio - 327
** 14.1 APIs with coroutines and functions - 328
** 14.2 Context variables - 330
** 14.3 Forcing an event loop iteration - 331
** 14.4 Using different event loop implementations - 333
** 14.5 Creating a custom event loop - 334
*** Coroutines and generators - 335
*** Generator-based coroutines are deprecated - 335
*** Custom awaitables - 337
*** Using sockets with futures - 340
*** A task implementation - 342
*** Implementing an event loop - 343
*** Implementing a server with a custom event loop - 346

* index - 349
