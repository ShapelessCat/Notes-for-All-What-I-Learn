#+TITLE: Pydantic
#+VERSION: 2.11
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Getting Started
** Welcome to Pydantic
*** Why use Pydantic?
*** Pydantic examples
*** Who is using Pydantic?

** Why use Pydantic
*** Type hints powering schema validation
*** Performance
*** Serialization
*** JSON Schema
*** Strict mode and data coercion
*** Dataclasses, TypedDicts, and more
*** Customisation
*** Ecosystem
*** Organisations using Pydantic
**** Adobe
**** Amazon and AWS
**** Anthropic
**** Apple
**** ASML
**** AstraZeneca
**** Cisco Systems
**** Comcast
**** Datadog
**** Facebook
**** GitHub
**** Google
**** HSBC
**** IBM
**** Intel
**** Intuit
**** Intergovernmental Panel on Climate Change
**** JPMorgan
**** Jupyter
**** Microsoft
**** Molecular Science Software Institute
**** NASA
**** Netflix
**** NSA
**** NVIDIA
**** OpenAI
**** Oracle
**** Palantir
**** Qualcomm
**** Red Hat
**** Revolut
**** Robusta
**** Salesforce
**** Starbucks
**** Texas Instruments
**** Twilio
**** Twitter
**** UK Home Office

** Help with Pydantic
*** Usage Documentation
*** API Documentation
*** GitHub Discussions
*** Stack Overflow
*** YouTube

** Installation
*** Optional dependencies
*** Install from repository

** Migration Guide
*** Install Pydantic V2
*** Code transformation tool
*** Continue using Pydantic V1 features
**** Using Pydantic v1 features in a v1/v2 environment

*** Migration guide
**** Changes to pydantic.BaseModel
**** Changes to pydantic.generics.GenericModel
**** Changes to pydantic.Field
**** Changes to dataclasses
**** Changes to config
**** Changes to validators
***** @validator and @root_validator are deprecated
***** Changes to @validator's allowed signatures
***** TypeError is no longer converted to ValidationError in validators
***** Validator behavior changes
***** The allow_reuse keyword argument is no longer necessary
***** @validate_arguments has been renamed to @validate_call

**** Input types are not preserved
**** Changes to Handling of Standard Types
***** Dicts
***** Unions
***** Required, optional, and nullable fields
***** Patterns / regex on strings

**** Type conversion from floats to integers
**** Introduction of TypeAdapter
**** Defining custom types
**** Changes to JSON schema generation
**** BaseSettings has moved to pydantic-settings
**** Color and Payment Card Numbers moved to pydantic-extra-types
**** Url and Dsn types in pydantic.networks no longer inherit from str
**** Constrained types
**** Mypy plugins

*** Other changes
*** Moved in Pydantic V2
*** Deprecated and moved in Pydantic V2
*** Removed in Pydantic V2

** Version Policy
*** Pydantic V1
*** Pydantic V2
*** Pydantic V3 and beyond
*** Experimental Features
**** Naming Conventions
**** Importing Experimental Features
**** Lifecycle of Experimental Features

*** Support for Python versions

** Contributing
*** Issues
*** Pull Requests
**** Prerequisites
**** Installation and setup
**** Check out a new branch and make your changes
**** Run tests and linting
**** Build documentation
***** Updating the documentation

**** Commit and push your changes

*** Documentation style
**** Code documentation
**** Documentation Style

*** Debugging Python and Rust
*** Badges
**** With Markdown
**** With reStructuredText
**** With HTML

*** Adding your library as part of Pydantic's third party test suite

** Changelog

* Concepts
** Models
** Fields
** JSON Schema
** JSON
** Types
** Unions
** Alias
** Configuration
** Serialization
** Validators
** Dataclasses
** Forward Annotations
** Strict Mode
** Type Adapter
** Validation Decorator
** Conversion Table
** Settings Management
** Performance
** Experimental

* API Documentation
** Pydantic
*** BaseModel
*** RootModel
*** Pydantic Dataclasses
*** TypeAdapter
*** Validate Call
*** Fields
*** Aliases
*** Configuration
*** JSON Schema
*** Errors
*** Functional Validators
*** Functional Serializers
*** Standard Library Types
*** Pydantic Types
*** Network Types
*** Version Information
*** Annotated Handlers
*** Experimental

** Pydantic Core
*** ~pydantic_core~
*** ~pydantic_core.core_schema~

** Pydantic Settings
** Pydantic Extra Types
*** Color
*** Country
*** Payment
*** Phone Numbers
*** Routing Numbers
*** Coordinate
*** Mac Address
*** ISBN
*** Pendulum
*** Currency
*** Language
*** Script Code
*** Semantic Version
*** Timezone Name
*** ULID

* Internals
** Architecture
*** Model definition
**** Communicating between pydantic and pydantic-core: the core schema
**** JSON Schema generation
**** Customizing the core schema and JSON schema

*** Model validation and serialization

** Resolving Annotations
*** The challenges of runtime evaluation
*** Resolving annotations at class definition
**** Limitations and backwards compatibility concerns

*** Resolving annotations when rebuilding a model

* Examples
** Validating File Data
*** JSON data
*** JSON lines files
*** CSV files
*** TOML files

** Web and API Requests
*** httpx requests

** Queues
*** Redis queue

** Databases
*** SQLAlchemy

** Custom Validators
*** Custom datetime Validator via Annotated Metadata
*** Validating Nested Model Fields

* Error Messages
** Error Handling
*** Error messages
**** Customize error messages

** Validation Errors
*** ~arguments_type~
*** ~assertion_error~
*** ~bool_parsing~
*** ~bool_type~
*** ~bytes_invalid_encoding~
*** ~bytes_too_long~
*** ~bytes_too_short~
*** ~bytes_type~
*** ~callable_type~
*** ~complex_str_parsing~
*** ~complex_type~
*** ~dataclass_exact_type~
*** ~dataclass_type~
*** ~date_from_datetime_inexact~
*** ~date_from_datetime_parsing~
*** ~date_future~
*** ~date_parsing~
*** ~date_past~
*** ~date_type~
*** ~datetime_from_date_parsing~
*** ~datetime_future~
*** ~datetime_object_invalid~
*** ~datetime_parsing~
*** ~datetime_past~
*** ~datetime_type~
*** ~decimal_max_digits~
*** ~decimal_max_places~
*** ~decimal_parsing~
*** ~decimal_type~
*** ~decimal_whole_digits~
*** ~dict_type~
*** ~enum~
*** ~extra_forbidden~
*** ~finite_number~
*** ~float_parsing~
*** ~float_type~
*** ~frozen_field~
*** ~frozen_instance~
*** ~frozen_set_type~
*** ~get_attribute_error~
*** ~greater_than~
*** ~greater_than_equal~
*** ~int_from_float~
*** ~int_parsing~
*** ~int_parsing_size~
*** ~int_type~
*** ~invalid_key~
*** ~is_instance_of~
*** ~is_subclass_of~
*** ~iterable_type~
*** ~iteration_error~
*** ~json_invalid~
*** ~json_type~
*** ~less_than~
*** ~less_than_equal~
*** ~list_type~
*** ~literal_error~
*** ~mapping_type~
*** ~missing~
*** ~missing_argument~
*** ~missing_keyword_only_argument~
*** ~missing_positional_only_argument~
*** ~model_attributes_type~
*** ~model_type~
*** ~multiple_argument_values~
*** ~multiple_of~
*** ~needs_python_object~
*** ~no_such_attribute~
*** ~none_required~
*** ~recursion_loop~
*** ~set_item_not_hashable~
*** ~set_type~
*** ~string_pattern_mismatch~
*** ~string_sub_type~
*** ~string_too_long~
*** ~string_too_short~
*** ~string_type~
*** ~string_unicode~
*** ~time_delta_parsing~
*** ~time_delta_type~
*** ~time_parsing~
*** ~time_type~
*** ~timezone_aware~
*** ~timezone_naive~
*** ~too_long~
*** ~too_short~
*** ~tuple_type~
*** ~unexpected_keyword_argument~
*** ~unexpected_positional_argument~
*** ~union_tag_invalid~
*** ~union_tag_not_found~
*** ~url_parsing~
*** ~url_scheme~
*** ~url_syntax_violation~
*** ~url_too_long~
*** ~url_type~
*** ~uuid_parsing~
*** ~uuid_type~
*** ~uuid_version~
*** ~value_error~

** Usage Errors
*** Class not fully defined
*** Custom JSON Schema
*** Decorator on missing field
*** Discriminator no field
*** Discriminator alias type
*** Discriminator needs literal
*** Discriminator alias
*** Invalid discriminator validator
*** Callable discriminator case with no tag
*** ~TypedDict~ version
*** Model parent field overridden
*** Model field missing annotation
*** ~Config~ and ~model_config~ both defined
*** Keyword arguments removed
*** Circular reference schema
*** JSON schema invalid type
*** JSON schema already used
*** BaseModel instantiated
*** Undefined annotation
*** Schema for unknown type
*** Import error
*** ~create_model~ field definitions
*** Validator with no fields
*** Invalid validator fields
*** Validator on instance method
*** ~json_schema_input_type~ used with the wrong mode
*** Root validator, ~pre~, ~skip_on_failure~
*** ~model_serializer~ instance methods
*** ~validator~, ~field~, ~config~, and ~info~
*** Pydantic V1 validator signature
*** Unrecognized ~field_validator~ signature
*** Unrecognized ~field_serializer~ signature
*** Unrecognized ~model_serializer~ signature
*** Multiple field serializers
*** Invalid annotated type
*** ~config~ is unused with ~TypeAdapter~
*** Cannot specify ~model_config['extra']~ with ~RootModel~
*** Cannot evaluate type annotation
*** Incompatible ~dataclass~ ~init~ and ~extra~ settings
*** Incompatible ~init~ and ~init_var~ settings on dataclass field
*** ~model_config~ is used as a model field
*** ~with_config~ is used on a ~BaseModel~ subclass
*** ~dataclass~ is used on a ~BaseModel~ subclass
*** Unsupported type for ~validate_call~
**** ~@classmethod~, ~@staticmethod~, and ~@property~
**** Classes
**** Callable instances
**** Invalid signature

*** ~Unpack~ used without a ~TypedDict~
*** Overlapping unpacked ~TypedDict~ fields and arguments
*** Invalid ~Self~ type
*** ~validate_by_alias~ and ~validate_by_name~ both set to ~False~

* Integrations
* Blog
* Pydantic People
