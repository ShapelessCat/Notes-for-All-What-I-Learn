#+TITLE: Robust Python
#+SUBTITLE: Write Clean and Maintainable Code
#+VERSION: 2021
#+AUTHOR: Patrick Viafore
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Preface - xi
** Who Should Read This Book - xii
- xxx

- While I will be covering many advanced Python topics, the goal of this book is
  not to
be a how-to for using all of Python’s features. Instead, the features
  are a backdrop for
a larger conversation about robustness and how your
  choices impact maintainability.
At times I will discuss strategies that you
  should rarely use, if at all. That is because I
want to illustrate first
  principles of robustness; the journey of understanding why and
how we make
  decisions in code is more important than knowing what tools to use in
an
  optimal scenario. In practice, the optimal scenario is a rare occurence. Use
  the
principles in this book to draw your own conclusions from your codebase.

- This book is not a reference book.
  You might call it a discussion book.

- A system can be robust in many different ways. It can be security hardened,
  scalable,
fault-tolerant, or less likely to introduce new errors. Each one of
  these facets of
robustness warrants a full book; this book is focused on
  preventing the developers
who inherit your code from creating new faults in
  your system. I will show you
how to communicate to future developers, how to
  make their lives easier through architectural patterns, and how to catch
  errors in your codebase before they make it
into production.

  _This book zeroes in on the robustness of your Python codebase, not the
  robustness of your system as a whole._

- Ideal readers include:
  * Developers currently working in a large codebase, looking to find better
    ways to communicate with their colleagues

  * Primary codebase maintainers, looking for ways to help lessen the burden of
    future maintainers

  * Self-taught developers who can write Python really well but need to better
    understand why we do the things we do

  * Software engineering graduates who need a reminder of practical advice for
    development

  * Senior developers looking for a way to tie their design rationale to first
    principles of robustness

** About This Book - xiii
** Conventions Used in This Book - xv
** Using Code Examples - xv
** O’Reilly Online Learning - xvi
** How to Contact Us - xvi
** Acknowledgments - xvii

* 1. Introduction to Robust Python - 1
This book is all about making your Python *more manageable*.

- You'll be taking a hard look at _how you write code,_ and
- you'll learn _the /implications/ of your decisions._

- From C. A. R. Hoare:
  #+begin_quote
  There are two ways of constructing a software design: One way is to make it so
  simple that there are obviously no deficiencies, and the other way is to make
  it so complicated that there are no obvious deficiencies. The first method is
  far more difficult.
  #+end_quote
  * This book is about developing systems the first way.

- In this chapter we're going to cover what /robustness/ means and why you
  should care about it.

  We'll go through
  1. How your communication method _implies_ certain benefits and drawbacks, and
  2. How best to represent your intentions.

  You'll learn
  * how to evaluate whether your code is written in an obvious way, and
  * what you can do to fix it.

** Robustness - 2
- *The Importance of Clean Code*

*** Why Does Robustness Matter? - 4

** What's Your Intent? - 5
*** Asynchronous Communication - 8

- *Self-Documenting Code*

** Examples of Intent in Python - 12
*** Collections - 12
- *Dynamic Versus Static Indexing*

*** Iteration - 15
*** Law of Least Surprise - 17

** Closing Thoughts - 18

* Part I. Annotating Your Code with Types
/Types/ are a fundamental underpinning of any programming language.

Python books and tutorials often miss out on the fundamental discussion about
when to use types appropriately.
_That's where I’ll start._

** DONE 2. Introduction to Python Types - 23
CLOSED: [2025-05-31 Sat 21:34]
1. start by talking about _WHAT a /type/ actually is_ and _WHY that matters_.
2. then move on to _HOW the Python language's decisions about its type system
   affects the robustness of your codebase._

*** What's in a Type? - 23 - =NOTE=
- The author consider a type to have a very simple definition:
  a communication method.

- The author break the representation down into two different facets:
  * Mechanical representation
    Types communicate behaviors and constraints to _the Python language itself_.

  * Semantic representation
    Types communicate behaviors and constraints to _other developers_.

=NEXT= Let's go learn a little more about each representation.

**** Mechanical Representation - 24
- Type information gives Python what it needs to know to make sense of all the
  ones and zeroes (the only language the hardware can understand).

- Example: print out the memory of variables
  #+begin_src python
    from ctypes import string_at
    from sys import getsizeof
    from binascii import hexlify

    a = 0b01010000_01000001_01010100
    print(a)
    # >>> 5259604

    # prints out the memory of the variable
    print(hexlify(string_at(id(a), getsizeof(a))))
    # >>> b'0100000000000000607c054995550000010000000000000054415000'

    text = "PAT"
    print(hexlify(string_at(id(text), getsizeof(text))))
    # >>>b'0100000000000000a00f0649955500000300000000000000375c9f1f02acdbe4e5379218b77f0000000000000000000050415400'
  #+end_src
  * These hex strings display the contents of the memory containing a /Python object/.

  * NOTE:
    + A little-endian machine.
    + Not guaranteed to run on other Python implementations such as Jython or PyPy.

**** Semantic Representation - 25

*** DONE Typing Systems - 28
CLOSED: [2025-05-31 Sat 21:17]
**** DONE Strong Versus Weak - 28
CLOSED: [2025-05-31 Sat 21:16]
- Languages toward the stronger side of the spectrum tend to
  restrict the use of operations to the types that support them.

  In other words, if you _BREAK_ the /semantic representation/ of the /type/,
  you are told (sometimes quite loudly) through a /compiler error/ or a /runtime
  error/.
  * Languages such as Haskell, TypeScript, and Rust are all considered /strongly
    typed/.

  * Languages such as JavaScript, Perl, and older versions of C are /weakly
    typed/.

- Python falls toward the stronger side of the spectrum.
  There are very few implicit conversions that happen between types.
  #+begin_src python
    [] + {}
    # TypeError: can only concatenate list (not "dict") to list

    {} + []
    # TypeError: unsupported operand type(s) for +: 'dict' and list
  #+end_src

  compared with JavaScript
  #+begin_src javascript
    [] + {}
    // "[object Object]"

    {} + []
    // 0
  #+end_src

  * *Are Weakly Typed Languages Inherently Not Robust?*
    + =from Jian= Yes!
    + =from the author= No, some explanation

**** DONE Dynamic Versus Static - 30
CLOSED: [2025-05-31 Sat 21:17]
- *Are Dynamically Typed Languages Inherently Not Robust?*
  * =from Jian= Yes!
  * =from the author= No, some explanation

**** DONE Duck Typing - 31
CLOSED: [2025-05-31 Sat 21:06]
- /Duck typing/ is the ability to use objects and entities in a programming
  language as long as they _adhere_ to some /interface/.
  * Q :: So how does this play into robustness?
  * A :: It turns out that duck typing is *a double-edged sword*.
    + It can increase robustness
      - BECAUSE
        it *increases* /composability/ (we'll learn more about composability in
        _Chapter 17_) -- building up a library of solid abstractions able to
        handle a multitude of types lessens the need for complex special cases.

      - HOWEVER, =IMPORTANT=, =IMPORTANT=, =IMPORTANT=
        if duck typing is overused, you start to break down assumptions that a
        developer can rely upon. When updating code, it's not simple enough to
        just make the changes; you must look at all calling code and make sure
        that the types passed into your function satisfy your new changes as
        well.

- The often mentioned quote about /duck type/ is not clear!
  #+begin_quote
  If it walks like a duck and it quacks like a duck, then it must be a duck.
  #+end_quote

  A better version from the author as a conclusion of this section:
  #+begin_quote
  If it walks like a duck and quacks like a duck, and you are looking for things
  that walk and quack like ducks, then you can treat it as if it were a duck.
  #+end_quote

- =from Jian=
  When using /duck typing/, I prefer a clear /interface/ (from a ~class~,
  usually abstract), not just some convention!

*** DONE Closing Thoughts - 33
CLOSED: [2025-05-31 Sat 21:34]
- /Types/
  * are a PILLAR of _clean_, _maintainable_ code and
  * serve as a _communication tool_ to other developers.

  If you take care with /types/, you communicate a great deal,
  creating *less burden for FUTURE maintainers.*

- =NEXT=
  The rest of Part I will show you how to use types to enhance a codebase's
  robustness.

- Python is dynamically and strongly typed.
  * /strongly typed/:
    a boon for us -- Python will notify us about errors when we use incompatible
    types.

  * /dynamically typed/:
    its nature is something we will *have to overcome* in order to write better
    code.

  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  These language choices *shape* how Python code is written and
  you should keep them in mind as you write your code.

- =NEXT=
  Next chapter:
  1. talk about /type annotations/
  2. /type annotations/ is our primary communication method of behaviors to
     future developers. They
     * help *overcome the limitations* of a /dynamically typed language/ and
     * allow you to enforce intentions throughout a codebase.

** TODO 3. Type Annotations - 35
#+begin_quote
I've learned a painful lesson that for small programs dynamic typing is great.
For large programs you have to have a more disciplined approach and it helps if
the language actually gives you that discipline, rather than telling you "Well,
you can do whatever you want."
#+end_quote
FROM
Guido van Rossum. "A Language Creators' Conversation." PuPPy (Puget Sound
Programming Python) Annual Benefit 2019. https://oreil.ly/1xf01.

*** What Are Type Annotations? - 36
- *Type Annotations Before Python 3.5*
  =from Jian=
  I won't use Python 3.5.

- *WARNING/CAUTION*:
  _If you aren't going to follow the /type annotation/,
  you are setting yourself up for problems_
  if the original code changes in a way that is incompatible with the types that
  you are using (such as expecting a certain function to work with that type).
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=

- =MISSING NOTE=
  ~def find_workers_available_for_time(open_time: datetime.datetime):~
  =TODO=
  =TODO=
  =TODO=

- *NOTE*:
  =from Jian=
  A better name is also important and can reveal the EXPECTED /type/ of a
  variable.

- *NOTE*:
  In Python 3.8 and earlier, /built-in collection types/ such as ~list~,
  ~dict~, /set/, did NOT allow bracket syntax such as ~list[Cookbook]~.
  Need ~Dict~, ~List~, which accpet bracket syntax.

  From Python 3.9+ on, /collection type/ like ~List~ is no longer useful -- we
  can use ~list[T]~.

*** Benefits of Type Annotations - 40
**** Autocomplete - 40
**** Typecheckers - 40
mypy

**** Exercise: Spot the Bug - 41

*** When to Use Type Annotations - 43
*** Closing Thoughts - 44

** TODO 4. Constraining Types - 45 - =STARt=
*** Optional Type - 46
- *Exceptions*

*** Union Types - 51
**** Product and Sum Types - 53

*** DONE Literal Types - 55
CLOSED: [2025-06-23 Mon 16:31]
It likes /enumerations/ and it is a little more lightweight.

*** Annotated Types - 56
*** TODO NewType - 57 - =TODO: Need experiments!=
- *Type Alias*

*** TODO Final Types - 59 - =TODO: Need experiments!=
- *CAUTION*
  ~Final~ will not error out _when mutating an object through a function (=from
  Jian= do you mean method? Like mypy doesn't forbid a ~Final~ list calls ~append~)._
  It only prevents the variable from being rebound (set to a new value).
  =TODO=
  Need experiments!

*** Closing Thoughts - 60

** TODO 5. Collection Types - 61
*** Annotating Collections - 61
*** Homogeneous Versus Heterogeneous Collections - 63
*** TypedDict - 67
*** Creating New Collections - 69
**** Generics - 69
**** Modifying Existing Types - 71
**** As Easy as ABC - 74

*** Closing Thoughts - 76

** TODO 6. Customizing Your Typechecker - 79
*** Configuring Your Typechecker - 79
**** Configuring mypy - 80
**** Mypy Reporting - 83
**** TODO Speeding Up mypy - 84 - =NOTE=

*** Alternative Typecheckers - 85
**** Pyre - 85
**** Pyright - 91

*** Closing Thoughts - 93
** TODO 7. Adopting Typechecking Practically - 95
*** Trade-offs - 96
*** Breaking Even Earlier - 97
**** Find Your Pain Points - 97
**** Target Code Strategically - 98
**** Lean on Your Tooling - 100

*** Closing Thoughts - 106


* Part II. Defining Your Own Types
- In this part of the book, we’ll go over three different user-defined types:
  * /Enumerations (Enums)/
    Enumerations provide a developer with a restricted set of values.

  * /Data classes/
    Data classes represent a relationship between different concepts.

  * /Classes/
    Classes represent a relationship between different concepts, with an
    invariant that needs to be preserved.

  You'll learn all about using these types in a natural way and how they relate
  to one another.

- By learning the *principles* behind /user-defined types/,
  you will more _effectively communicate to_ future developers.

** DONE 8. User-Defined Types: Enums - 111 - =TODO: NOTE=
CLOSED: [2025-06-23 Mon 16:02]
In this chapter, I'm going to focus on
what a user-defined type is and cover the simplest user-defined data type:
enumerations.
1. I'll discuss how to create an enumeration that will protect your code from
   common programming mistakes.
2. I'll then go over advanced features that allow you to express your ideas more
   clearly,
   such as
   * creating aliases,
   * making enumerations unique, or
   * providing automatically generated values.

*** User-Defined Types - 111
- This will help other developers buildmental models about your codebase.

- IfI were to use lists, dictionaries, and tuples instead, I’d force my
  readers to constantlyreinterpret the meaning of variables to their more
  natural mappings.

- You’ve spent the first part of this book focusing on expressing intent
  throughannotations; this next part will focus on communicating intentions by
  building ashared vocabulary and making that vocabulary available to every
  developer workingin the codebase.

*** Enumerations - 112
- This unfortunately does not communicate intent.

**** Enum - 114
**** When Not to Use - 115

*** Advanced Usage - 116
**** Automatic Values - 116
- *Enums Versus Literals*

**** Flags - 117
**** Integer Conversion - 119
=???=

**** Unique - 120

*** Closing Thoughts - 121

** DONE 9. User-Defined Types: Data Classes - 123
CLOSED: [2025-06-23 Mon 16:00]
=from Jian=
Only basic usages.

*** DONE Data Classes in Action - 123
CLOSED: [2025-06-23 Mon 15:23]
- /Data classes/ represent a /heterogeneous collection/ of variables, all rolled
  into a /composite type/.
  * /Composite types/ are made up of multiple values
  * /Composite types/ should always represent some sort of relationship or
    logical grouping.

- Example code:
  #+begin_src python
    import datetime
    from dataclasses import dataclass
    from enum import auto, Enum


    class ImperialMeasure(Enum):
        TEASPOON = auto()
        TABLESPOON = auto()
        CUP = auto()


    class Broth(Enum):
        VEGETABLE = auto()
        CHICKEN = auto()
        BEEF = auto()
        FISH = auto()


    @dataclass(frozen=True)
    # Ingredients added into the broth
    class Ingredient:
        name: str
        amount: float = 1
        units: ImperialMeasure = ImperialMeasure.CUP


    @dataclass
    class Recipe:
        aromatics: set[Ingredient]
        broth: Broth
        vegetables: set[Ingredient]
        meats: set[Ingredient]
        starches: set[Ingredient]
        garnishes: set[Ingredient]
        time_to_cook: datetime.timedelta

        def make_vegetarian(self):
            self.meats.clear()
            self.broth = Broth.VEGETABLE

        def get_ingredient_names(self):
            ingredients = (self.aromatics |
                           self.vegetables |
                           self.meats |
                           self.starches |
                           self.garnishes)
            return ({i.name for i in ingredients} |
                    {self.broth.name.capitalize() + " broth"})
  #+end_src

*** DONE Usage - 128
CLOSED: [2025-06-23 Mon 15:41]
**** String Conversion - 128
/Data classes/ provide dataclass-specific ~__str__~ and ~__repr_~
implementations.

**** Equality - 128
If you want to be able to test equality (~==~, ~!=~) between two /data classes/,
you can specify ~eq=True~ when defining your ~dataclass~: ~@dataclass(eq=True)~.

_BY DEFAULT_, equality checks will *compare every field* across two instances of
a /data class/.

**** Relational Comparison - 129
~dataclass(eq=True, order=True)~

The generated comparison functions will go through each field, comparing them
*IN THE ORDER IN which they were defined.*

- *CAUTION*:
  If you _override_ /comparison functions/, *DO NOT* specify ~order=True~, as
  that will raise a ~ValueError~.
  =from Jian=
  * Q :: WHY?
  * A :: Prevent logical inconsistencies!

**** Immutability - 130
~@dataclass(frozen=True)~

- When you *freeze* a /dataclass/, it _AUTOMATICALLY_ becomes hashable, as long
  as
  * you don't explicitly disable equality checking and
  * all fields are hashable.

*** DONE Comparison to Other Types - 132
CLOSED: [2025-06-23 Mon 15:53]
- /Data classes/ are relatively new (introduced in Python 3.7).

- =IMPORTANT=
  As you evaluate /data class/ *adoption*,
  you need to understand where a /data class/ shines in relation to other
  constructs.

**** Data Classes Versus Dictionaries - 132
Use /dictionaries/ for homogeneous data only, or else typecheckers can't help
you.

**** Data Classes Versus ~TypedDict~ - 133
Also discussed in Chapter 5 was the ~TypedDict~ type.

- At first glance, ~TypedDict~ and /data classes/ solve a very similar problem.

- The author's rule of thumb is to think of *a /dataclass/ as the DEFAULT*,
  as
  * it can have functions defined on it and
  * you can control /immutability/, /equality/, /comparability/, and other
    operations.

- _HOWEVER_, if you _are *ALREADY* working with /dictionaries/ (such as for
  working with JSON)_, you should reach for a ~TypedDict~, *PROVIDED* that you
  don't need any of the benefits of a /dataclass/.
  =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=

**** Data Classes Versus ~namedtuple~ - 133
The author says he always pick /dataclasses/, and only reach for a ~namedtuple~
_IF_ he explicitly need _compatibility with Python 3.6 or before._

*** DONE Closing Thoughts - 134
CLOSED: [2025-06-23 Mon 15:55]

/Data class/'s fields should be independent to each other.
=from Jian= You can't easily do this with /data classes/.
If you want to build dependencies between them, you need /classes/.

** 10. User-Defined Types: Classes - 135
*** Class Anatomy - 135
**** Constructors - 136

*** Invariants - 137
**** Avoiding Broken Invariants - 140
**** Why Are Invariants Beneficial? - 140
**** Communicating Invariants - 143
**** Consuming Your Class - 143
**** What About Maintainers? - 144

*** Encapsulation and Maintaining Invariants - 146
**** Encapsul-what, Now? - 146
**** Protecting Data Access - 147
**** Operations - 149

*** Closing Thoughts - 152

** 11. Defining Your Interfaces - 155
*** Natural Interface Design - 156
**** Thinking Like a User - 157

*** Natural Interactions - 160
**** Natural Interfaces in Action - 160
**** Magic Methods - 166
**** Context Managers - 167

*** Closing Thoughts - 170

** 12. Subtyping - 171
*** Inheritance - 172
*** Substitutability - 176
*** Design Considerations - 182
**** Composition - 183

*** Closing Thoughts - 185

** 13. Protocols - 187
*** Tension Between Typing Systems - 187
**** Leave the Type Blank or Use Any - 189
**** Use a Union - 189
**** Use Inheritance - 190
**** Use Mixins - 191

*** Protocols - 192
**** Defining a Protocol - 193

*** Advanced Usage - 194
**** Composite Protocols - 194
**** Runtime Checkable Protocols - 195
**** Modules Satisfying Protocols - 196

*** Closing Thoughts - 197
** 14. Runtime Checking With pydantic - 199
*** Dynamic Configuration - 200
*** pydantic - 205
**** Validators - 207
**** Validation Versus Parsing - 209
*** Closing Thoughts - 210

* Part III. Extensible Python
** 15. Extensibility - 215
*** What Is Extensibility? - 215
**** The Redesign - 217

*** Open-Closed Principle - 221
**** Detecting OCP Violations - 222
**** Drawbacks - 223

*** Closing Thoughts - 224

** 16. Dependencies - 225
*** Relationships - 226
*** Types of Dependencies - 228
**** Physical Dependencies - 228
**** Logical Dependencies - 232
**** Temporal Dependencies - 234

*** Visualizing Your Dependencies - 236
**** Visualizing Packages - 236
**** Visualizing Imports - 237
**** Visualizing Function Calls - 238
**** Interpreting Your Dependency Graph - 240

*** Closing Thoughts - 241

** 17. Composability - 243
*** Composability - 243
*** Policy Versus Mechanisms - 243
*** Composing on a Smaller Scale - 251
**** Composing Functions - 251
**** Composing Algorithms - 255

*** Closing Thoughts - 257
** 18. Event-Driven Architecture - 259
*** How It Works - 259
**** Drawbacks - 261

*** Simple Events - 262
**** Using a Message Broker - 262
**** The Observer Pattern - 264

*** Streaming Events - 266
*** Closing Thoughts - 269

** 19. Pluggable Python - 271
*** The Template Method Pattern - 272
*** The Strategy Pattern - 275
*** Plug-in Architectures - 277
*** Closing Thoughts - 281

* Part IV. Building a Safety Net
** 20. Static Analysis - 285
*** Linting - 285
**** Writing Your Own Pylint Plug-in - 287
**** Breaking Down the Plug-in - 289

*** Other Static Analyzers - 291
**** Complexity Checkers - 292
**** Security Analysis - 295

*** Closing Thoughts - 296

** 21. Testing Strategy - 297
*** Defining Your Test Strategy - 297
**** What Is a Test? - 298

*** Reducing Test Cost - 303
**** AAA Testing - 303

*** Closing Thoughts - 313

** 22. Acceptance Testing - 315
*** Behavior-Driven Development - 316
**** The Gherkin Language - 316
**** Executable Specifications - 318

*** Additional behave Features - 320
**** Parameterized Steps - 320
**** Table-Driven Requirements - 321
**** Step Matching - 322
**** Customizing the Test Life Cycle - 322
**** Using Tags to Selectively Run Tests - 323
**** Report Generation - 323

*** Closing Thoughts - 324

** 23. Property-Based Testing - 325
*** Property-Based Testing with Hypothesis - 325
**** The Magic of Hypothesis - 330
**** Contrast with Traditional Tests - 330

*** Getting the Most Out of Hypothesis - 331
**** Hypothesis Strategies - 331
**** Generating Algorithms - 333

*** Closing Thoughts - 336

** 24. Mutation Testing - 337
*** What Is Mutation Testing? - 337
*** Mutation Testing with mutmut - 340
**** Fixing Mutants - 342
**** Mutation Testing Reports - 342

*** Adopting Mutation Testing - 344
**** The Fallacy of Coverage (and Other Metrics) - 345

*** Closing Thoughts - 346

* Index - 349
