#+TITLE: Speed Up Your Python with Rust
#+SUBTITLE: Optimize Python performance by creating Python pip modules in Rust with PyO3
#+VERSION: 2021
#+AUTHOR: Maxwell Flitton
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Preface
* Section 1: Getting to Understand Rust
** Chapter 1: An Introduction to Rust from a Python Perspective
*** Technical requirements
*** Understanding the differences between Python and Rust
*** Why fuse Python with Rust?
*** Passing strings in Rust
*** Sizing up floats and integers in Rust
*** Managing data in Rust's vectors and arrays
*** Replacing dictionaries with hashmaps
*** Error handling in Rust
*** Understanding variable ownership
*** Copy
*** Move
*** Immutable borrow
*** Mutable borrow
*** Keeping track of scopes and lifetimes
*** Building structs instead of objects
*** Metaprogramming with macros instead of decorators
*** Summary
*** Questions
*** Answers
*** Further reading

** Chapter 2: Structuring Code in Rust
*** Technical requirements
*** Managing our code with crates and Cargo instead of pip
*** Structuring code over multiple files and modules
*** Building module interfaces
*** Benefits of documentation when coding
*** Interacting with the environment
*** Summary
*** Questions
*** Answers
*** Further reading

** Chapter 3: Understanding Concurrency
*** Technical requirements
*** Introducing concurrency
*** Threads
*** Processes
*** Basic asynchronous programming with threads
*** Running multiple processes
*** Customizing threads and processes safely
*** Amdahl's law
*** Deadlocks
*** Race conditions
*** Summary
*** Questions
*** Answers
*** Further reading

* Section 2: Fusing Rust with Python
** Chapter 4: Building pip Modules in Python
*** Technical requirements
*** Configuring setup tools for a Python pip module
*** Creating a GitHub repository
*** Defining the basic parameters
*** Defining a README file
*** Defining a basic module
*** Packaging Python code in a pip module
*** Building our Fibonacci calculation code
*** Creating a command-line interface
*** Building unit tests
*** Configuring continuous integration
*** Manually deploying onto PyPI
*** Managing dependencies
*** Setting up type checking for Python
*** Setting up and running tests and type-checking with GitHub Actions
*** Create automatic versioning for our pip package
*** Deploying onto PyPI using GitHub Actions
*** Summary
*** Questions
*** Answers
*** Further reading

** Chapter 5: Creating a Rust Interface for Our pip Module
*** Technical requirements
*** Packaging Rust with pip
*** Define gitignore and Cargo for our package
*** Configuring the Python setup process for our package
*** Installing our Rust library for our package
*** Building a Rust interface with the pyO3 crate
*** Building our Fibonacci Rust code
*** Creating command-line tools for our package
*** Creating adapters for our package
*** Building tests for our Rust package
*** Comparing speed with Python, Rust, and Numba
*** Summary
*** Questions
*** Answers
*** Further reading

** Chapter 6: Working with Python Objects in Rust
*** Technical requirements
*** Passing complex Python objects into Rust
*** Updating our setup.py file to support .yml loading
*** Defining our .yml loading command
*** Processing data from our Python dictionary
*** Extracting data from our config file
*** Returning our Rust dictionary to our Python system
*** Inspecting and working with custom Python objects
*** Creating an object for our Rust interface
*** Acquiring the Python GIL in Rust
*** Adding data to our newly created PyDict struct
*** Setting the attributes of our custom object
*** Constructing our own custom Python objects in Rust
*** Defining a Python class with the required attributes
*** Defining class static methods to process input numbers
*** Defining a class constructor
*** Wrapping up and testing our module
*** Summary
*** Questions
*** Answers
*** Further reading

** Chapter 7: Using Python Modules with Rust
*** Technical requirements
*** Exploring NumPy
*** Adding vectors in NumPy
*** Adding vectors in pure Python
*** Adding vectors using NumPy in Rust
*** Building a model in NumPy
*** Defining our model
*** Building a Python object that executes our model
*** Using NumPy and other Python modules in Rust
*** Recreating our NumPy model in Rust
*** Building ~get_weight_matrix~ and
*** ~inverse_weight_matrix~ functions
*** Building ~get_parameters~, ~get_times~, and ~get_input_vector~ functions
*** Building ~calculate_parameters~ and ~calculate_times~ functions
*** Adding calculate functions to the Python
*** bindings and adding a NumPy dependency to our setup.py file
*** Building our Python interface
*** Summary
*** Questions
*** Answers
*** Further reading

** Chapter 8: Structuring an End-to-End Python Package in Rust
*** Technical requirements
*** Breaking down a catastrophe modeling problem for our package
*** Building an end-to-end solution as a package
*** Building a footprint merging process
*** Building the vulnerability merge process
*** Building a Python interface in Rust
*** Building our interface in Python
*** Building package installation instructions
*** Utilizing and testing our package
*** Building a Python construct model using pandas
*** Building a random event ID generator function
*** Timing our Python and Rust implementations with a series of different data sizes
*** Summary
*** Further reading

* Section 3: Infusing Rust into a Web Application
** Chapter 9: Structuring a Python Flask App for Rust
*** Technical requirements
*** Building a basic Flask application
*** Building an entry point for our application
*** Building our Fibonacci number calculator module
*** Building a Docker image for our application
*** Building our NGINX service
*** Connecting and running our Nginx service
*** Defining our data access layer
*** Defining a PostgreSQL database in docker-compose
*** Building a config loading system
*** Building our data access layer
*** Setting up the application database migration system
*** Building database models
*** Applying the database access layer to the fib calculation view
*** Building a message bus
*** Building a Celery broker for Flask
*** Building a Fibonacci calculation task for Celery
*** Updating our calculation view
*** Defining our Celery service in Docker
*** Summary
*** Questions
*** Answers
*** Further reading

** Chapter 10: Injecting Rust into a Python Flask App
*** Technical requirements
*** Fusing Rust into Flask and Celery
*** Defining our dependency on the Rust Fibonacci number calculation package
*** Building our calculation model with Rust
*** Creating a calculation view using Rust
*** Inserting Rust into our Celery task
*** Deploying Flask and Celery with Rust
*** Deploying with a private GitHub repository
*** Building a Bash script that orchestrates the whole process
*** Reconfiguring the Rust Fib package installment in our Dockerfile
*** Fusing Rust with data access
*** Setting up our database cloning package
*** Setting up the diesel environment
*** Autogenerating and configuring our database models and schema
*** Defining our database connection in Rust
*** Creating a Rust function that gets all the Fibonacci records and returns them
*** Deploying Rust nightly in Flask
*** Summary
*** Questions
*** Answers
*** Further reading

** Chapter 11: Best Practices for Integrating Rust
*** Technical requirements
*** Keeping our Rust implementation simple by piping data to and from Rust
*** Building a Python script that formulates the numbers for calculation
*** Building a Rust file that accepts the numbers, calculates the Fibonacci numbers, and returns the calculated numbers
*** Building another Python script that accepts the calculated numbers and prints them out
*** Giving the interface a native feel with objects
*** Defining traits
*** Defining struct behavior with traits
*** Passing traits through functions
*** Storing structs with common traits
*** Running our traits in the main file
*** Keeping data-parallelism simple with Rayon
*** Further reading
