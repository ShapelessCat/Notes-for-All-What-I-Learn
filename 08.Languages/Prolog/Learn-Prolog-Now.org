#+TITLE: Learn Prolog Now!
#+VERSION: ???? 2001
#+AUTHOR: Patrick Blackburn, Johan Bos and Kristina Striegnitz
#+STARTUP: overview
#+STARTUP: entitiespretty

* DONE Chapter 1  Facts, Rules, and Queries
  CLOSED: [2017-08-09 Wed 04:51]
  This chapter has _TWO_ main GOALS:
  1. To give some simple examples of Prolog programs.
     * This will introduce us to the three basic constructs in Prolog:
       + /facts/
       + /rules/
       + /queries/

     * It will also introduce us to a number of other themes, like
       + the role of /logic/ in Prolog
       + the idea of performing /unification/ with the aid of variables

  2. To begin the systematic study of Prolog by defining
     * /terms/
     * /atoms/
     * /variables/
     * other syntactic concepts

** TODO 1.1 Some Simple Examples
   - /knowledge base (or a database)/: A collection of facts and rules.

   - _Prolog programming is all about writing knowledge bases_.

   - Q: How do we use Prolog program?
     A: By posing queries (by asking questions about the info stored in the
        /knowledge base/).

   - Logic programming is useful in
     + computational linguistics
     + AI
     + etc.

*** TODO Knowledge Base 1
    - /facts/

    - =TODO=

*** TODO Knowledge Base 2
    - /rules/

    - ~:-~

    - The part on the _left hand side_ of the ~:-~ is called
      /the head of the rule/,
      the part on the _right hand side_ is called /the body/.

    - =TODO=

*** DONE Knowledge Base 3
    CLOSED: [2017-08-08 Tue 23:17]
    #+BEGIN_SRC prolog
      happy(vincent).
      listens2Music(butch).
      playsAirGuitar(vincent):-
          listens2Music(vincent),
          happy(vincent).
      playsAirGuitar(butch):-
          happy(butch).
      playsAirGuitar(butch):-
          listens2Music(butch).
    #+END_SRC

    - The ~,~ in the body is the way logical conjunction (logic and) is
      expressed in Prolog.
        The meaning of the rule below is "Vincent plays air guitar if he listens
      to music and he is happy".
      #+BEGIN_SRC prolog
        playsAirGuitar(vincent):-
            listens2Music(vincent),
            happy(vincent).
      #+END_SRC

      + There are _two_ /goals/ in the /body/ of this rule.

    - The ~;~ in the body is the way logical disjunction (logic or) is expressed
      in Prolog.
      #+BEGIN_SRC prolog
        playsAirGuitar(butch):-
            happy(butch);
            listen2Music(butch).
      #+END_SRC

      This can also be written as:
      #+BEGIN_SRC prolog
        playsAirGuitar(butch):-
            happy(butch).
        playsAirGuitar(butch):-
            listen2Music(butch).
      #+END_SRC

      The pros can cons of ~;~:
      + pros :: The semicolon is more efficient as Prolog only has to deal with
                one rule.
      + cons :: Extensive use of semicolon can make Prolog code hard to read.

    - =TODO= Talk about /negation/ in Chapter 10.

    - 

    - 

*** DONE Knowledge Base 4
    CLOSED: [2017-08-09 Wed 00:11]
    #+BEGIN_SRC prolog
      woman(mia).
      woman(jody).
      woman(yolanda).

      loves(vincent,mia).
      loves(marsellus,mia).
      loves(pumpkin,honey_bunny).
      loves(honey_bunny,pumpkin).
    #+END_SRC
    The novelty here is _NOT_ the database. We will introduce /variables/.

    - Query #1: ~woman(X).~

      The meaning of it is: tell me which of the individuals you know about is a
      woman.

      Here, ~X~ is a variable.
      Any word beginning with an upper-case letter is a Prolog variable.

      Prolog answers this query by working its way through =KB4=, from top to
      bottom, trying to =TODO<= /unify/ (or /match/) =>TODO= the expression
      ~woman(X)~ with the information =KB4= contains.
        There is a lot of different terminology for this process: we can also
      say that
      + Prolog /instantiates/ ~X~ to ~mia~
      + Prolog /binds/ ~X~ to ~mia~

      + STEP 1:
        Prolog then reports back to us as follows:
        ~X = mia~

      + STEP 2:
        Type =return= to stop this process and back to the ready to be queried
        state.

        OR

        Type ~;~ (NO =return= follows) to unify with different things.
        Then, you'll see:
        #+BEGIN_SRC prolog
          X = mia ;
          X = jody ;
          X = yolanda.
        #+END_SRC
        The last ~.~ is issued by Prolog automatically.

    - Query #2: ~loves(marsellus,X), woman(X).~
      "Is there any individual ~X~ such that _Marsellus_ loves ~X~ and ~X~ is a
       ~woman~?"

      + Answer is: 
        ~X = mia.~

*** DONE Knowledge Base 5
    CLOSED: [2017-08-09 Wed 00:56]
    #+BEGIN_SRC prolog
      loves(vincent,mia).
      loves(marsellus,mia).
      loves(pumpkin,honey_bunny).
      loves(honey_bunny,pumpkin).

      jealous(X,Y):- loves(X,Z), loves(Y,Z).
    #+END_SRC
    - /variables/ NOT ONLY can be used in knowledge bases,
      it's only when we start to do so that we can write truly interesting
      programs.

    - Query: ~jealous(marsellus,W).~
      "Can you find an individual W such that Marsellus is jealous of W?"

      + Answer is:
        ~W = vincent.~

    - Now some questions for you:
      1. Are there any other jealous people in =KB5=?

      2. Suppose we wanted Prolog to tell us about all the jealous people:
         + Q: what query would we pose?
           A: ~jealous(X,Y).~

         + Q: Do any of the answers surprise you? Do any seem silly?
           A: (1) self-jealous (I think this is useless).
              (2) exchange the values of ~X~ and ~Y~ (Repeat some right but
                  already know de facto equal facts).

** DONE 1.2 Prolog Syntax
   CLOSED: [2017-08-09 Wed 01:31]
   Q: What are /facts/, /rules/, and /queries/ built out of?
   A: The answer is /terms/, and there are _FOUR_ kinds of term in Prolog:
      /atoms/, /numbers/, /variables/, and /complex terms/ (or /structures/).

   Atoms and numbers are lumped together under the heading constants, and
   constants and variables together make up the simple terms of Prolog.

*** DONE Atoms
    CLOSED: [2017-08-09 Wed 01:15]
    An /atom/ is either:
    1. A string of characters made up of upper-case letters, lower-case letters,
       digits, and the underscore character, that begins with a lower-case letter.
       Here are some examples: ~butch~, ~big_kahuna_burger~, ~listens2Music~ and
       ~playsAirGuitar~.

    2. An arbitrary sequence of characters enclosed in single quotes. For example
       ~'Vincent'~,
       ~'The Gimp'~,
       ~'Five_Dollar_Shake'~,
       ~'&^%&#@$ &*'~,
       and ~' '~.
       The sequence of characters between the single quotes is called the
       /atom name/.
       + Note that we are allowed to use spaces in such atoms; in fact, a
         common reason for using single quotes is so we can do precisely that.

    3. A string of special characters. Here are some examples: ~@=~ and ~====>~
       and ~;~ and ~:-~ are all /atoms/.
         As we have seen, some of these /atoms/, such as ~;~ and ~:-~ have a
       pre-defined meaning.

*** DONE Numbers
    CLOSED: [2017-08-09 Wed 01:05]
    - /Real numbers/ are NOT particularly important in typical Prolog
      applications. Most Prolog implementations do support them, but we say
      little about it.

    - /integers/ =TODO= CHAPTER 5

    - The way to write /integers/ is normal in Prolog: 1, 2, 0, 100, -30, and so
      on.

*** DONE Variables
    CLOSED: [2017-08-09 Wed 01:09]
    - /variable/ :: a string of
      + upper-case letters
      + lower-case letters
      + digits
      + underscore characters

      that starts either with an _upper-case letter_ or with an _underscore_.

    - ~_~ is rather special. It's called the anonymous variable.
      =TODO= Chapter 4

*** DONE Complex terms
    CLOSED: [2017-08-09 Wed 01:31]
    - /constants/, /numbers/, and /variables/ are the building blocks.
      We need to know how to fit them together to make /complex terms/.

    - /complex terms/ are often called /structures/.

    - /complex terms/ are build out of
      a /functor/ followed by /a sequence of arguments/.

    - The /arguments/ are
      + put in ordinary parentheses,
      + separated by commas, and
      + placed after the /functor/.

    - The /functor/ must be an atom.
      That is, variable CANNOT be used as /functors/.

      /arguments/ can be any kind of term.

    - Nested complex terms (or recursively structured terms) enable us to
      represent many problem naturally.

      =IMPORTANT=
      The interplay between recursive term structure and variable unification is
      _the source of much of Prolog's power_.

    - /arity/

    - Two same spell different arities functor will treated as different
      predicats. =TODO= Chapter 5

    - When we talk about predicates, we prefer to write it in the form of
      functorName/arity. For example, listens2Music/1, happy/1.

** TODO 1.3 Exercises
** DONE 1.4 Practical Session
   CLOSED: [2017-08-10 Thu 05:21]
   - The prompt of Prolog interpreter ~?-~ indicates -- ready to accept a query.

   - ~listing~: a built-in Prolog predicate, which instructs Prolog to
     _display the contents of the current knowledge base_.

     If nothing loaded, Prolog interpreter should print NOTHING but ~true~ (or
     ~yes~ in some version).
     _However_, this never happened! Sophisticated Prolog implementations often
     preload some libraries (=TODO= Chapter 12).

   - ~consult('kb2.pl').~ has another form ~[kb2].~
     Or with path ~['home/lanjian/Prolog/kb2.pl'].~ or
     ~['c:/Documents and Settings/lanjian/Prolog/kb2.pl']~

   - Some Prolog implementations you don't actually have to type in the ~.pl~
     suffix when you ~consult~ a file.

   - Perl scripts also have a ~.pl~ suffix, too. C'est la vie.

   - ~listing(playAirGuitar)~ lists all the information in the knowledge base
     about the ~playAirGuitar~ predicate.

* TODO Chapter 2  Unification and Proof Search
  This chapter has two main goals:
  1. To discuss /unification/ in Prolog, and to explain how /Prolog unification/
     _differs_ from /standard unification/.
       Along the way, we'll introduce ~=/2~, the built-in predicate for
     /Prolog unification/, and ~unify_with_occurs_check/2~ , the built-in
     predicate for /standard unification/.

  2. To explain the search strategy Prolog uses when it tries to deduce new
     information from old using /modus ponens/.

** DONE 2.1 Unification
   CLOSED: [2017-08-10 Thu 04:23]
   - Basic intuition:
     Two terms unify if they are the same term or if they contain variables that
     can be uniformly instantiated with terms in such a way that the resulting
     terms are equal.

   - Precise description:
     1. If ~term1~ and ~term2~ are /constants/, then ~term1~ and ~term2~ unify
        iff they are the same atom, or the same number.

     2. _IF_
        ~term1~ is a variable
        and
        ~term2~ is any type of term,
        _THEN_ ~term1~ and ~term2~ /unify/, and ~term1~ is /instantiated/ to ~term2~.

        Similarly,
        _IF_
        ~term2~ is a variable
        and
        ~term1~ is any type of term,
        _THEN_ ~term1~ and ~term2~ unify, and ~term2~ is instantiated to ~term1~.

        (So if they are both variables, they're both instantiated to each other,
         and we say that they share values.)

     3. If ~term1~ and ~term2~ are /complex terms/, then they /unify/ iff:
        1. They have the same functor and arity, _and_
        2. all their corresponding arguments unify, _and_
        3. the variable instantiations are compatible. (For example, it is not
           possible to instantiate variable X to mia when unifying one pair of
           arguments, and to instantiate X to vincent when unifying another pair
           of arguments.)

     4. Two terms /unify/ iff it follows from the previous three clauses that
        they /unify/.

*** DONE Examples
    CLOSED: [2017-08-10 Thu 01:21]
    - For Prolog,
      any atom of the form ~'symbols'~ is considered the same entity as the atom
      of the form symbols. For example, ~'mia'~ can ~mia~ can be unified.
      (This doesn't work for numbers： ~2~ is a number, but ~'2'~ is an /atom/)

    - An instantiated variable isn't really a variable anymore:
      it has become what it was instantiated with.
      #+BEGIN_SRC prolog
        X = mia, X = vincent.
        %%output%% false
      #+END_SRC

*** DONE The occurs check
    CLOSED: [2017-08-10 Thu 02:07]
    - /unification/ is thoroughly studied, and many unification algorithms are
      known.

    - Prolog DOES _NOT_ use a standard unification algorithm when it performs its
      version of unification. INSTEAD it takes a _shortcut_.
      =TODO= _You need to know about this shortcut_.

    - A standard /unification/ algorithm will say ~father(X) = X.~ is ~false~.

    - Old Prolog will give a message like: =Not enough memory to complete query!=
      and a long string of symbols like:
      #+BEGIN_SRC prolog
        X = father(father(father(father(father(father
           (father(father(father(father(father(father
           (father(father(father(father(father(father
           (father(father(father(father(father(father 
           (father(father(father(father(father(father
      #+END_SRC

    - Modern Prolog (SWI Prolog or SICStus Prolog) will print out the answer like:
      ~X = father(X).~ and NO ~true~ or ~false~.

    - =TODO= However, why you might want to use such representations, and what
      such representations actually are, are topics that lie beyond the scope of
      this book. =TODO=

    - _SUMMARY_:
      In short, there are actually _THREE_ DIFFERENT responses to the question
      “does father(X) unify with X ”:
      1. The answer given by the standard unification algorithm (which is to say
         _NO_).

      2. the response of older Prolog implementations (which is to run amok until
         they use up the available memory).

      3. the answer given by sophisticated Prolog implementations (which is to
         say _YES_, and _return a finite representation of an infinite term_).

      In short, there is _NO absolute 'right' answer_ to this question.

      =IMPORTANT=
      What is important is that you understand the difference between standard
      unification and Prolog unification, and know how the Prolog implementation
      that you work with handles such examples.

    - /standard unification algorithms/ are _pessimistic_ -- they do
      /occurs check/ and the case can't pass /occurs check/ will be considered
      NO unification can be applicable.

    - /Prolog unification algorithms/ are _optimistic_ -- they assumes no
      dangerous thing will be fed in, and they take a shortcut: omit the
      /occurs check/.

      This is reasonable for _TWO_ reasons:
      1. /unification/ is one of the fundamental processes that makes Prolog
         work, so it needs to be carried out as fast as possible.

      2. It is unlikely the programmer ever (intentionally) ask Prolog to do
         anything like that when writing a real program.

    - A built-in predicate in Prolog that carries out /standard unification/:
      ~unify_with_occurs_check/2~.

      The answer of ~unify_with_occurs_check(father(X),X).~ is _NO_.

*** TODO Programming with unification
    #+BEGIN_SRC prolog
      vertical(line(point(X,Y),point(X,Z))).
      horizontal(line(point(X,Y),point(Z,Y))). 

      %% ?- vertical(line(point(1,1),point(1,3))).
      %% yes

      %% ?- vertical(line(point(1,1),point(3,2))).
      %% no

      %% ?- horizontal(line(point(1,1),point(2,Y))).
      %% Y = 1.

      %% ?- horizontal(line(point(2,3),P)).
      %% P = point(_1972,3).
    #+END_SRC

    - Notice: the symbol ~_1972~ in variable of random name (here, implies any
      number).

    - =IMPORTANT=
      A general remark:
      the answer given to our last query is _structured_. That is, the answer is
      a /complex term/, representing a sophisticated concept (namely "any point
      whose y-coordinate is 3").

      This structure was built using unification and _nothing else_:
        NO logical inference (and in particular, no use of /modus ponens/) was
      used to produce it. Building structure by unification turns out to be a
      powerful idea in Prolog programming, far more powerful than this rather
      simple example might suggest.

      Moreover, when a program is written that makes heavy use of /unification/,
      it is likely to be _extremely efficient_.

      =TODO= We will study a beautiful example in Chapter 7 when we discuss
      difference lists, which are used to implement Prolog's built-in grammar
      system, /Definite Clause Grammars/.

    - This style of programming is particularly useful in applications where the
      important concepts have _a natural hierarchical structure_ (as they did in
      the simple knowledge base above), for
      1. we can then use complex terms to represent this structure,
         and
      2. unification to access it.

      _This way of working plays an important role in computational linguistics_,
      for example, because information about language has a natural hierarchical
      structure.

** DONE 2.2 Proof Search
   CLOSED: [2017-08-10 Thu 04:31]
   - Prolog keeps track of choice points it has encountered, so that if it makes
     a wrong choice it can retreat to the previous choice point and try
     something else instead. This process is called /backtracking/, and it is
     _fundamental to proof search in Prolog_.

   - ~;~ force a /backtracking/, and try to find another possibility.

   - By searching
     + _top to bottom_ in the knowledge base,
     + _left to right_ in goal lists,
       and
     + _backtracking_ to the previous choice point whenever it _fails_.

   - This diagram has the form of a tree; in fact it is our first example of what
     is known as a /search tree/.

     The /nodes/ of such trees say which goals have to be satisfied at the various
     steps of the proof search,

     and

     the /edges/ keep track of the variable instantiations that are made when the
     current goal (that is, the first one in the list of goals) is unified to a
     fact or to the head of a rule in the knowledge base.

   - /Leaf nodes/ which still contain unsatisfied goals are points where Prolog
     _failed_ (either because it made a wrong decision somewhere along the path,
     or because no solution exists).

     /Leaf nodes/ with an empty goal list correspond to a possible solution.

     The _edges along the path from the root node to a successful leaf node_ tell
     you the variable instantiations that need to be made to satisfy the
     original query.

** TODO 2.3 Exercises 
** TODO 2.4 Practical Session
* TODO Chapter 3  Recursion
** DONE 3.1 Recursive Definitions
   CLOSED: [2017-08-11 Fri 03:00]
*** DONE Example 1: Eating
    CLOSED: [2017-08-11 Fri 03:00]
    #+BEGIN_SRC prolog
      is_digesting(X,Y) :- just_ate(X,Y).
      is_digesting(X,Y) :-
          just_ate(X,Z),
          is_digesting(Z,Y).

      just_ate(mosquito,blood(john)).
      just_ate(frog,mosquito).
      just_ate(stork,frog).
    #+END_SRC

*** DONE Example 2: Descendant
    CLOSED: [2017-08-11 Fri 01:08]
    Consider the facts below:
    #+BEGIN_SRC prolog
      child(bridge,caroline).
      child(caroline,donna).
    #+END_SRC

    We can define ~descend/2~ as below
    #+BEGIN_SRC prolog
      descend(X,Y) :- child(X,Y).
      descend(X,Y) :- child(X,Z),
                      child(Z,Y).
    #+END_SRC

    However, the rules above _ONLY works for at most TWO generations_.
    We need a ~descend/2~ definition in general (use recursive definitions):
    #+BEGIN_SRC prolog
      descend(X,Y) :- child(X,Y).
      descend(X,Y) :- child(X,Z),
                      descend(Z,Y).
    #+END_SRC

*** DONE Example 3: Successor
    CLOSED: [2017-08-11 Fri 01:42]
    #+BEGIN_SRC prolog
      numeral(0).
      numeral(succ(X)) :- numeral(X).
    #+END_SRC

    - The answer for ~numeral(succ(succ(succ(0)))).~ is ~true.~

    - The answer for ~numeral(X).~ is interesting:
      #+BEGIN_SRC prolog
        X  =  0;
        X  =  succ(0);
        X  =  succ(succ(0));
        X  =  succ(succ(succ(0)));
        X  =  succ(succ(succ(succ(0))));
        X  =  succ(succ(succ(succ(succ(0)))));
        X  =  succ(succ(succ(succ(succ(succ(0))))));
        X  =  succ(succ(succ(succ(succ(succ(succ(0)))))));
        X  =  succ(succ(succ(succ(succ(succ(succ(succ(0))))))));
        X  =  succ(succ(succ(succ(succ(succ(succ(succ(succ(0)))))))));
        X  =  succ(succ(succ(succ(succ(succ(succ(succ(succ(succ(...))))))))));
        X  =  succ(succ(succ(succ(succ(succ(succ(succ(succ(succ(...))))))))));
        X  =  succ(succ(succ(succ(succ(succ(succ(succ(succ(succ(...))))))))));

        %%.. NO STOP
      #+END_SRC
      Prolog will print forever if you keep pressing ~;~.
      In the latter cases, it is clever to use ~...~, rather than printing every
      -thing out.

    - Building and binding =TODO=. /Recursion/, /unification/, and
      /proof search/.
        These are ideas that lie at the heart of Prolog programming.

    - _search tree_

*** DONE Example 4: Addition
    CLOSED: [2017-08-11 Fri 02:59]
    #+BEGIN_SRC prolog
      add(0,Y,Y).
      add(succ(X),Y,succ(Z)) :-
          add(X,Y,Z).
    #+END_SRC

    Here's the complete trace of our query
    ~add(succ(succ(succ(0))), succ(succ(0)), R)~:

    Call:  (6)  ~add(succ(succ(succ(0))), succ(succ(0)), R)~
    Call:  (7)  ~add(succ(succ(0)), succ(succ(0)), _G648)~
    Call:  (8)  ~add(succ(0), succ(succ(0)), _G650)~
    Call:  (9)  ~add(0, succ(succ(0)), _G652)~
    Exit:  (9)  ~add(0, succ(succ(0)), succ(succ(0)))~
    Exit:  (8)  ~add(succ(0), succ(succ(0)), succ(succ(succ(0))))~ 
    Exit:  (7)  ~add(succ(succ(0)), succ(succ(0)), succ(succ(succ(succ(0)))))~
    Exit:  (6)  ~add(succ(succ(succ(0))), succ(succ(0)), succ(succ(succ(succ(succ(0))))))~

    _search tree_
** DONE 3.2 Rule Ordering, Goal Ordering, and Termination
   CLOSED: [2017-08-11 Fri 03:39]
   - Prolog was the first reasonably successful attempt to create a logic
     programming language.

   - Underlying logic programming is a simple (and seductive) vision:
     _the task of the programmer is simply to describe problems._

     The programmer _should_ write down (in the language of logic) a declarative
     specification (that is: a knowledge base), which describes the situation of
     interest.
     The programmer _shouldn't_ have to tell the computer what to do. To get
     information, he or she simply asks the questions. It's up to the logic
     programming system to figure out how to get the answer.

   - The above description can be used to describe a /full logic programming
     language/.

     _However, Prolog is NOT_.
       This is due to the specific way, of Prolog, of working out the answers to
     queries (this can give a dramatic effect when you make a query):
     1. search the knowledge base from top to bottom,
     2. search the clauses from left to right,
     3. uses /backtracking/ to _recover_ from bad choices.

   - Examples:
     1. The query is ~descend(X,Y).~.
        #+BEGIN_SRC prolog
          %% descend1.pl
          child(anne,bridget).
          child(bridget,caroline).
          child(caroline,donna).
          child(donna,emily).

          descend(X,Y)  :-  child(X,Y).

          descend(X,Y)  :-  child(X,Z),
                            descend(Z,Y).

          %%% answer:
          %% X = anne
          %% Y = bridget
        #+END_SRC

        #+BEGIN_SRC prolog
          %% descend2.pl
          child(anne,bridget).
          child(bridget,caroline).
          child(caroline,donna).
          child(donna,emily).

          descend(X,Y)  :-  child(X,Y).

          descend(X,Y)  :-  child(X,Z),
                            descend(Z,Y).

          %%% answer:
          %% X = anne
          %% Y = emily
        #+END_SRC

     2. If the query is ~descend(anne,bridget).~, non-termination.
        If the query is ~descend(anne,emily).~, non-termination.
        _non-termination_ due to /left recursion/!!!
        #+BEGIN_SRC prolog
          %% descend3.pl
          child(anne,bridget).
          child(bridget,caroline).
          child(caroline,donna).
          child(donna,emily).

          descend(X,Y) :- child(X,Z),
                          descend(Z,Y).

          descend(X,Y) :- child(X,Y).
        #+END_SRC

     3. If the query is ~descend(anne,bridget).~, there is a termination.
        If the query is ~descend(anne,emily).~, non-termination.
        #+BEGIN_SRC prolog
          %% descend4.pl
          child(anne,bridget).
          child(bridget,caroline).
          child(caroline,donna).
          child(donna,emily).

          descend(X,Y) :- child(X,Y).

          descend(X,Y) :- descend(Z,Y),
                          child(X,Z).
        #+END_SRC

     3. /left recursive rule/: the leftmost item of the body is identical (=TODO=
        modulo the choice of variables) with the rule's head.

        As our example shows, such rules easily give rise to non-terminating compu-
        tations.

   - _Goal order_, NOT rule ordering, and in particular /left recursion/, is the
     root of all evil when it comes to non-termination.
     =IMPORTANT=

   - The change in rule ordering between =descend3.pl= and =descend4.pl= merely
     means that
     =descend4.pl= will TERMINATE in some cases where =descend3.pl= will NOT.

   - _The basic rule of thumb_:
     _NEVER_ to write as the _leftmost goal_ of the body something that is
     identical (modulo variable names) with the goal given in the head.

     Rather, place such goals (which trigger recursive calls) as _FAR_ as
     possible towards the right of the tail. That is, place them after the goals
     which test for the various (non-recursive) termination conditions.

** TODO 3.3 Exercises
   - 3.1
   - 3.2
   - 3.3
   - 3.4
   - 3.5

** TODO 3.4 Practical Session
* DONE Chapter 4  Lists
  CLOSED: [2017-08-11 Fri 22:07]
  This chapter has THREE main goals:
  1. To introduc lists.
  2. To define the ~member/2~ predicate, a fundamental Prolog tool for
     manipulating lists.
  3. To introduce the idea of recursing down lists.

** DONE 4.1 Lists
   CLOSED: [2017-08-11 Fri 19:57]
   - Some examples of lists:
     ~[mia, vincent, jules, yolanda]~,
     ~[mia, robber(honey_bunny), X, 2, mia]~
     ~[]~
     ~[mia, [vincent, jules], [butch, girlfriend(butch)]]~,
     ~[[], dead(z), [2, [b, c]], [], Z, [2, [b, c]]]~

   - Any non-empty list has two parts: /head/ and /tail/.

   - The usage of ~|~ operator:
     1. The simplest usage is to make a query like
        ~[Head|Tail] = [mia, vincent, jules, yolanda].~
        The result is
        #+BEGIN_SRC prolog
          %% Head = mia
          %% Tail = [vincent,jules,yolanda]
          %% true.
        #+END_SRC

        If you try to query ~[X|Y] = []~, the result is ~false.~

     2. Still simple but with a unknown variable
        ~[X|Y] = [[], dead(z), [2, [b, c]], [], Z].~
        The result is
        #+BEGIN_SRC prolog
          %% X = []
          %% Y = [dead(z), [2, [b, c]], [], _7800]
          %% Z = _7800
          %% true
        #+END_SRC

     3. ~|~ is not only to be used to get /head/ and /tail/.
        A query ~[X,Y | W] = [[], dead(z), [2, [b, c]], [], Z].~
        The result is
        #+BEGIN_SRC prolog
          %% X = []
          %% Y = dead(z)
          %% W = [[2, [b, c]], [], _8327]
          %% Z = _8327
          %% true
        #+END_SRC

        ~[X,Y | W]~ is the same as ~[X | [Y | W]]~

   - The anonymous variable: ~_~.
     A query ~[_, X, _, Y | _] = [[], dead(z), [2, [b, c]], [], Z].~
     #+BEGIN_SRC prolog
       X = dead(z)
       Y = []
       Z = _9593
       true
     #+END_SRC

     ~_~ is not a normal variable. You cannot use the same variable name
     repeatedly in one list query. All ~_~'s are independent (each one can be
     bound to something different), and all the same name variables are not
     independent.

   - Another exmaple of ~_~:
     A query ~[_, _, [_ | X] | _] = [[], dead(z), [2, [b, c]], [], Z, [2, [b, c]]].~
     The result is:
     #+BEGIN_SRC prolog
       %% X = [[b, c]]
       %% Z = _100087
       %% true
     #+END_SRC

** DONE 4.2 Member
   CLOSED: [2017-08-11 Fri 20:29]
   #+BEGIN_SRC prolog
     member(X, [X|T]).
     member(X, [H|T]) :- member(X, T).
   #+END_SRC

   This definition can be used, but when you load it Prolog will issue TWO
   warnnings: one for the ~T~ in the /fact/, and one for the ~H~ in the /rule/.
     The reason we have these warnings is that we created them and never used
   them. A concise and NO warning version is here:
   #+BEGIN_SRC prolog
     member(X, [X|_]).
     member(X, [_|T]) :- member(X, T).
   #+END_SRC

   Notice that there is NO /fact/ or /rule/ for the case that ~[]~ is the second
   arguments of ~member/2~.

   If this happen in the other languages, and exception would be thrown out.
   For Prolog, NO /fact/ or /rule/ can be found means ~false~.

   - Trivial use:
     ~member(yolanda, [yolanda, trudy, vincent, jules]).~
     ~member(vincent, [yolanda, trudy, vincent, jules]).~
     ~member(zed, [yolanda, trudy, vincent, jules]).~

   - With a variable (this is a extremely common use of ~member/2~: list every
     member of a list):
     ~member(X, [yolanda, trudy, vincent, jules]).~
     The reulst is:
     #+BEGIN_SRC prolog
       %% X = yolanda ;
       %% X = trudy ;
       %% X = vincent ;
       %% X = jules ;
       %% false.
     #+END_SRC

** DONE 4.3 Recursing down Lists
   CLOSED: [2017-08-11 Fri 20:46]
   #+BEGIN_SRC prolog
     a2b([], []).
     a2b([a|Ta], [b|Tb]) :- a2b(Ta, Tb).
   #+END_SRC

   - when query, ~true~ if
     1. the first list and the second list have the same length
     2. the first list only contains ~a~.
     3. the second list only contains ~b~.

   - ~a2b~ can be used as a translator from a list of ~a~ to a list of ~b~
     (for example: ~a2b([a,a,a,a],X)~), or vice versa.

   - Try the query ~a2b(X,Y)~, and it will help you to list all the possible
     ~X~'s and ~Y~'s.

** TODO 4.4 Exercises
   =TODO= the last exercise
** DONE 4.5 Practical Session
   CLOSED: [2017-08-11 Fri 22:05]
   #+BEGIN_SRC prolog
     combine1([],[],[]).
     combine1([H1|T1],[H2|T2],[H1,H2|T]) :- combine1(T1,T2,T).

     combine2([],[],[]).
     combine2([H1|T1],[H2|T2],[[H1,H2]|T]) :- combine2(T1,T2,T).

     j(_,_).
     combine3([],[],[]).
     combine3([H1|T1],[H2|T2],[j(H1,H2)|T]) :- combine3(T1,T2,T).
   #+END_SRC
* DONE Chapter 5  Arithmetic
  CLOSED: [2017-08-13 Sun 00:54]
  This chapter has two main goals:
  1. To introduce Prolog's built-in abilities for performing arithmetic.
  2. To apply them to simple list processing problems, using accumulators.

** DONE 5.1 Arithmetic in Prolog
   CLOSED: [2017-08-12 Sat 17:04]
   =IMPORTANT= This section is OLD,
   integer division is ~//~,
   ~/~ is a normal division (result can be floating number).

   - Examples:
     ~8 is 6+2.~
     ~12 is 6*2.~
     ~3 is 6/2.~
     ~3 is 7//2.~
     ~1 is mod(7,2).~

   - A function-like predicate:
     #+BEGIN_SRC prolog
       add_3_and_double(X,Y) :- Y is (X+3)*2.

       %% %?-% add_3_and_double(1,X).
       %% %%   X = 8.

       %% %?-% add_3_and_double(2,X).
       %% %%   X = 10.
     #+END_SRC

** DONE 5.2 A Closer Look
   CLOSED: [2017-08-12 Sat 18:41]
   - The result of query ~X = 3 + 2.~ is ~X = 3+2~ -- just a unification.

   - To force Prolog to actually evaluate arithmetic expressions we have to use
     ~is~.
       ~is~ does something very special: it sends a signal to Prolog that says
     "Hey! Don’t treat this expression as an ordinary complex term! Call up your
     built-in arithmetic capabilities and carry out the calculations!"

       Arithmetic is something extra that has been bolted on to the basic Prolog
     engine because it is useful.

       Unsurprisingly, there are some restrictions on this extra ability, and we
     need to know what they are.
     + the arithmetic expressions must be on the right hand side of ~is~.
       queries like ~6+2 is X~ lead to errors of ~instantiation_error~:
       =Error: is/2: Arguments are not sufficiently instantiated=

     + although we are free to use variables on the right hand side of ~is~, when
       we actually carry out evaluation, the variable must already have been
       instantiated to a variable-free arithmetic expression.

       This is why
       we can get a result for the query of ~add_3_and_double(2,Y).~

       BUT we will get an _error message_ for the query
       ~add_3_and_double(X,12).~

   - Some syntactic sugar:
     + ~3 + 2~ is ~+(3, 2)~
     + ~X is 3 + 2~ is ~is(X,+(3,2))~

** DONE 5.3 Arithmetic and Lists
   CLOSED: [2017-08-12 Sat 18:41]
   #+BEGIN_SRC prolog
     %% non-tail recursion
     len([],0).
     len([_|T],N) :- len(T,X), N is X+1.

     %% tail recursion
     accLen([_|T],A,L) :- Anew is A+1, accLen(T,Anew,L).
     accLen([],A,A).
     leng(List,Length) :- accLen(List,0,Length).
   #+END_SRC

   - For ~accLen~
     ?- ~accLen([a,b,c],0,L).~ 
           Call:  (6)  accLen([a,  b,  c],  0,  _G449)  ? 
           Call:  (7)  _G518  is  0+1  ? 
           Exit:  (7)  1  is  0+1  ? 
           Call:  (7)  accLen([b,  c],  1,  _G449)  ? 
           Call:  (8)  _G521  is  1+1  ? 
           Exit:  (8)  2  is  1+1  ? 
           Call:  (8)  accLen([c],  2,  _G449)  ? 
           Call:  (9)  _G524  is  2+1  ? 
           Exit:  (9)  3  is  2+1  ? 
           Call:  (9)  accLen([],  3,  _G449)  ? 
           Exit:  (9)  accLen([],  3,  3)  ?  %% Can be returned here.
           Exit:  (8)  accLen([c],  2,  3)  ? 
           Exit:  (7)  accLen([b,  c],  1,  3)  ? 
           Exit:  (6)  accLen([a,  b,  c],  0,  3)  ?

   - For ~len~
     ?- ~len([a,b,c],L).~ 
           Call:  (6)  len([a,  b,  c],  _G418)  ? 
           Call:  (7)  len([b,  c],  _G481)  ? 
           Call:  (8)  len([c],  _G486)  ? 
           Call:  (9)  len([],  _G489)  ? 
           Exit:  (9)  len([],  0)  ? 
           Call:  (9)  _G486  is  0+1  ? 
           Exit:  (9)  1  is  0+1  ? 
           Exit:  (8)  len([c],  1)  ? 
           Call:  (8)  _G481  is  1+1  ? 
           Exit:  (8)  2  is  1+1  ? 
           Exit:  (7)  len([b,  c],  2)  ? 
           Call:  (7)  _G418  is  2+1  ? 
           Exit:  (7)  3  is  2+1  ? 
           Exit:  (6)  len([a,  b,  c],  3)  ?  %% Can only be returned here.

** DONE 5.4 Comparing Integers
   CLOSED: [2017-08-12 Sat 21:56]
   | Arithmetic | Prolog  |
   | x < y      | X < Y   |
   | x \le{} y      | X =< Y  |
   | x = y      | X =:= Y |
   | x \ne{} y      | X =\= Y |
   | x \ge{} y      | X >= Y  |
   | x > y      | X > Y   |

   - Whenever we use these operators, we have to take care that any variables are
     instantiated. =IMPORTANT=
     For example,
     #+BEGIN_SRC prolog
       %%%% Queries with instantiation errors:
       %% X < 3
       %% X < Y
       %% X =:= X.

       %% A good query:
       %% X = 3, X < 4.
     #+END_SRC

   - Variables _MUST_ be instantiated to integers.
     The result of query ~X = b, X < 4.~ is an error message:
     =ERROR: </2: Arithmetic: `b/0' is not a function=

   - Define a predicate (with accumulator) to get the maximum of a non-empty list
     of non-negative integers:
     #+BEGIN_SRC prolog
       accMax([H|T],A,Max) :-
           H > A,
           accMax(T,H,Max).

       accMax([H|T],A,Max) :-
           H =< A,
           accMax(T,A,Max).

       accMax([], A, A).
     #+END_SRC

   - For a non-empty list of general integer values (initialize the accumulator
     to the head of this list.):
     #+BEGIN_SRC prolog
       max(List,Max) :-
           List = [H|_],
           accMax(List,H,Max).
     #+END_SRC

** DONE 5.5 Exercises
   CLOSED: [2017-08-12 Sat 22:53]
** DONE 5.6 Practical Session
   CLOSED: [2017-08-13 Sun 00:43]
   #+BEGIN_SRC prolog
     %% 1.
     %% Try to modify `accMax` slightly, and get the `accMin`.
     accMin([H|T], A, Min) :- H >= A, accMin(T, A, Min).
     accMin([], A, A).

     min(List, Min) :-
         List = [H|_],
         accMin(List, H, Min).

     %% 2.
     %% Write a 3-place predicate `scalarMult` whose first argument is an integer, whose
     %% second argument is a list of integers, and whose third argument is the result
     %% of scalar multiplying the second argument by the first.
     scalarMult(_,[],[]).
     scalarMult(N,[H|T],[HR|TR]) :- HR is N*H, scalarMult(N,T,TR).


     %% 3.
     %% Write a `dot` to do the dot product of vectors.
     dotHelper([], [], A, Result) :- Result is A.
     dotHelper([H1|T1], [H2|T2], A, Result) :-
         NewA = (H1 * H2) + A,
         dotHelper(T1, T2, NewA, Result).

     dot(List1, List2, Result) :-
         dotHelper(List1, List2, 0, Result).
   #+END_SRC
   
* TODO Chapter 6  More Lists
  This chapter has two main goals:
  1. To define ~append/3~, a predicate for concatenating two lists, and
     illustrate what can be done with it.

  2. To discuss two ways of reversing a list:
     + a naive method using ~append/3~,
       and
     + a more efficient method using accumulators.

** DONE 6.1 Append
   CLOSED: [2017-08-14 Mon 21:25]
   ~append/3~ has three list arguments. The last one is the result of
   _concatenating_ the first two list arguments.

   Since we are in Prolog, you may notice that we can also use ~append/3~ to
   _split_ a list.

*** DONE Defining ~append~
    CLOSED: [2017-08-14 Mon 21:25]
    #+BEGIN_SRC prolog
      append([], L, L).
      append([H|T], L2, [H|L3]) :- append(T, L2, L3).
    #+END_SRC

*** DONE Using ~append~
    CLOSED: [2017-08-14 Mon 21:25]
    #+BEGIN_SRC prolog
      %% Test if ~P~ is the prefix of ~L~, or find out the prefix.
      prefix(P, L) :- append(P, _, L).

      %% Test if ~S~ is the suffix of ~L~, or find out the suffix.
      suffix(S, L) :- append(_, S, L).

      %% Find out all the sublists
      sublist(SubL, L) :- suffix(S, L), prefix(SubL, S).
    #+END_SRC

** DONE 6.2 Reversing a List
   CLOSED: [2017-08-14 Mon 21:54]
*** DONE Naive ~reverse~ using ~append~
    CLOSED: [2017-08-14 Mon 21:54]
    #+BEGIN_SRC prolog
      naiverev([], []).
      naiverev([H|T], R) :- naiverev(T, RevT), append(RevT, [H], R).
    #+END_SRC

    =TODO=: TRY TO COUNT
    This take 90 steps to reverse an eight element list.

*** DONE Reverse using an accumulator
    CLOSED: [2017-08-14 Mon 21:48]
    #+BEGIN_SRC prolog
      accRev([H|T], A, R) :- accRev(T, [H|A], R).
      accRev([], A, A).

      rev(L, R) :- accRev(L, [], R).
    #+END_SRC

    - This will be efficient because we simply blast our way through the list
      once: we don't have to waste time carrying out concatenation (NOT like
      ~naiverev~) or other irrelevant work.

    - The idea underlying the accumulator based version is simpler and more
      natural than the recursive calls to ~append/3~.

    - =TODO=: TRY TO COUNT
      This take 20 steps to reverse an eight element list.

** DONE 6.3 Exercises
   CLOSED: [2017-08-15 Tue 00:02]
   - =TODO= 6.6 need a a better answer.
** TODO 6.4 Practical Session
* TODO Chapter 7  Definite Clause Grammars
** TODO 7.1 Context Free Grammars
*** TODO CFG recognition using append
*** TODO CFG recognition using difference lists
** TODO 7.2 Definite Clause Grammars
*** TODO A first example
*** TODO Adding recursive rules
*** TODO A DCG for a simple formal language
** TODO 7.3 Exercises
** TODO 7.4 Practical Session
* TODO Chapter 8  More Definite Clause Grammars
** TODO 8.1 Extra Arguments
*** TODO Context free grammars with features
*** TODO Building parse trees
*** TODO Beyond context free languages
** TODO 8.2 Extra Goals
*** TODO Separating rules and lexicon
** TODO 8.3 Concluding Remarks
** TODO 8.4 Exercises
** TODO 8.5 Practical Session
* TODO Chapter 9  A Closer Look at Terms
** TODO 9.1 Comparing Terms
** TODO 9.2 Terms with a Special Notation
*** TODO Arithmetic terms
*** TODO Lists as terms
** TODO 9.3 Examining Terms
*** TODO Types of Terms
*** TODO The Structure of Terms
*** TODO Strings
** TODO 9.4 Operators
*** TODO Properties of operators
*** TODO Defining operators
** TODO 9.5 Exercises
** TODO 9.6 Practical Session
* TODO Chapter 10 Cuts and Negation
** TODO 10.1 The Cut
** TODO 10.2 Using Cut
** TODO 10.3 Negation as Failure
** TODO 10.4 Exercises
** TODO 10.5 Practical Session
* TODO Chapter 11 Database Manipulation and Collecting Solutions
** TODO 11.1 Database Manipulation
** TODO 11.2 Collecting Solutions
*** TODO The findall/3 predicate 
*** TODO The bagof/3 predicate 
*** TODO The setof/3 predicate 
** TODO 11.3 Exercises
** TODO 11.4 Practical Session
* TODO Chapter 12 Working With Files
** TODO 12.1 Splitting Programs over Files
*** TODO Reading in programs
*** TODO Modules
*** TODO Libraries
** TODO 12.2 Writing to Files
** TODO 12.3 Reading from Files
** TODO 12.4 Exercises
** TODO 12.5 Practical Session
*** TODO Step 1
*** TODO Step 2
*** TODO Step 3
*** TODO Step 4
*** TODO Step 5
*** TODO Step 6
*** TODO Step 7
