#+TITLE: Elixir
#+VERSION: v1.14
#+AUTHOR: Community
#+STARTUP: overview
#+STARTUP: entitiespretty

* TODO Getting Started
** DONE 1. Introduction
   CLOSED: [2021-01-25 Mon 20:02]
   - In this tutorial, we are going to teach you about Elixir fundamentals:
     * the language _syntax_
     * how to *define* /modules/
     * how to manipulate the characteristics of _common data structures_, and more.

   - This chapter will focus on ensuring that Elixir is installed and that you
     can successfully run Elixir's Interactive Shell, called IEx.

   - Our requirements are (see =elixir -v=):
     * Elixir 1.5.0 onwards
     * Erlang/OTP 19 onwards

*** 1. Installation
    If you haven't yet installed Elixir, visit our installation page. Once you
    are done, you can run ~elixir --version~ to get the current Elixir version.

*** 2. Interactive mode
    - After installation you will see three new executables:
      * iex
      * elixir
      * elixirc

    - Example (use REPL):
      #+begin_src elixir
        40 + 2
        # 42

        "hello" <> " world"
        # "hello world"
      #+end_src

    - To exit _iex_ press Ctrl+C twice.

    - In Windows, run =iex --werl=

*** 3. Running scripts
    #+begin_src elixir
      # simple.exs
      IO.puts "Hello world from Elixir"
    #+end_src

    Run it
    #+begin_src shell
      elixir simple.exs
      # Hello world from Elixir
    #+end_src

    - Later on we will learn =TODO=
      * how to *compile* Elixir code (in Chapter 8)
      * how to *use* the _Mix build tool_ (in the Mix & OTP guide).

*** TODO 4. Asking questions

** DONE 2. Basic types
   CLOSED: [2021-01-25 Mon 22:04]
   #+begin_src elixir
     1          # integer
     0x1F       # integer
     1.0        # float
     true       # boolean
     :atom      # atom / symbol
     "elixir"   # string
     [1, 2, 3]  # list
     {1, 2, 3}  # tuple
   #+end_src

*** DONE 1. Basic arithmetic
    CLOSED: [2021-01-25 Mon 20:31]
    #+begin_src elixir
      1 + 2   # 3
      5 * 5   # 25
      10 / 2  # 5.0
      div(10, 2)  # 5 -- integer division
      div 10, 2   # 5
      rem 10, 3   # 1
    #+end_src
    - _ALLOW_ to _drop the parentheses_ when invoking named functions.
      * This feature gives a cleaner syntax when writing declarations and
        control-flow constructs.

    - _Shortcut notations_ for entering /binary/, /octal/, and
      /hexadecimal numbers/:
      #+begin_src elixir
        0b1010  # 10
        0o777   # 511
        0x1F    # 31
      #+end_src

    - Float numbers (64-bit double precision)
      #+begin_src elixir
        1.0      # 1.0
        1.0e-10  # 1.0e-10
      #+end_src

    - ~round~ and ~trunc~
      #+begin_src elixir
        round(3.58)  # 4
        trunc(3.58)  # 3
      #+end_src

*** DONE 2. Identifying functions and documentation
    CLOSED: [2021-01-25 Mon 22:04]
    Functions in Elixir are identified by both their /name/ and their /arity/. 

    - Use ~h~ function to how documentation for any function:
      run ~h trunc/1~ in IEx.
      * This will work, even though ~trunc/1~ is actually defined in the /module/
        ~Kernel~. This is because all functions in ~Kernel~ will automatically
        imported into our namespace.

      * More often, for /funcitons/ _NOT in ~Kernel~,_ we hould ue full path:
        ~h Kernel.trunc/1~

    - Invoking ~h~ without argument displays the documentation for ~IEx.Helpers~,
      which is where ~h~ and other functionality is defined.

*** DONE 3. Booleans
    CLOSED: [2021-01-25 Mon 20:33]
    ~true~ and ~false~

    - ~is_boolean/1~ function

    - ~is_integer/1~, ~is_float/1~, and ~is_number/1~.

*** DONE 4. Atoms
    CLOSED: [2021-01-25 Mon 20:40]
    - atom :: a constant whose value is its own name.

    - Some other languages call these /symbols/.

    - They are often useful to enumerate over distinct values, such as:
      #+begin_src elixir
        :apple   # :apple
        :orange  # :orange
      #+end_src

    - Equality check:
      #+begin_src elixir
        :apple == :apple   # true
        :apple == :orange  # false
      #+end_src

    - the /boolean constants/ ~true~ and ~false~ are also /atoms/:
      #+begin_src elixir
        true == :true       # true
        is_atom(false)      # true
        is_boolean(:false)  # true
      #+end_src
      Elixir allows you to skip the leading ~:~ for the /atoms/ ~false~, ~true~,
      and ~nil~.

    - Finally, Elixir has a construct called aliases which we will explore later. =TODO=
      /Aliases/ *start in upper case* and are also /atoms/:
      #+begin_src elixir
        is_atom(Hello)  # true
      #+end_src

*** DONE 5. Strings
    CLOSED: [2021-01-25 Mon 21:02]
    - /String/ in UTF-8:
      #+begin_src elixir
        "hellö"  # "hellö"
      #+end_src
      In Windows, you may use a terminal that doesn't use UTF-8 by default.
      Run ~chcp 65001~ in your current session before entering IEx.

    - /String interpolation/:
      #+begin_src elixir
        string = :word
        "hellö #{string}"  # "hellö world"
      #+end_src

    - /Strings/ can have _line breaks_ in them.
      You can introduce them using escape sequences:
      #+begin_src elixir
        iex> "hello
        ...> world"
        # "hello\nworld"

        iex> "hello\nworld"
        "hello\nworld"
      #+end_src

    - You can print a /string/ using the ~IO.puts/1~ /function/ from the ~IO~ /module/:
      #+begin_src elixir
        iex> IO.puts "hello\nworld"
        hello
        world
        :ok
      #+end_src
      Notice that the ~IO.puts/1~ /function/ *returns* the /atom/ ~:ok~ after printing.

    - /Strings/ in Elixir are _represented internally_ by *contiguous sequences of
      bytes* known as /binaries/:
      #+begin_src elixir
        is_binary("hellö")  # true
      #+end_src

    - Get the _number of bytes_ in a /string/:
      #+begin_src elixir
        byte_size("hellö")  # 6
      #+end_src

    - Notice that the _number of bytes_ in that /string/ is 6, even though it has
      5 /graphemes/.
        That's because the /grapheme/ =“ö”= takes 2 bytes to be represented in
      UTF-8. We can get the actual length of the /string/, based on the number of
      /graphemes/, by using the ~String.length/1~ /function/:
      #+begin_src elixir
        String.length("hellö")  # 5
      #+end_src

    - The ~String~ /module/
      contains a bunch of /functions/ that _operate on_ /strings/ as defined in
      the /Unicode standard/
      #+begin_src elixir
        String.upcase("hellö")  # "HELLÖ"
      #+end_src

*** DONE 6. Anonymous functions
    CLOSED: [2021-01-25 Mon 21:58]
    #+begin_src elixir
      add = fn a, b -> a + b end
      add.(1, 2)        # 3
      is_function(add)  # true

      x = 42
      (fn -> x = 0 end).()  # 0
      x  # 42
    #+end_src

    - The ~.~ in the _anonymous function invocations_ is used to distinguish the
      /anonymous function/ ~add~ and the named function ~add/2~.
      * In Elixir, named functions can only be defined within a /module/.

*** DONE 7. (Linked) Lists
    CLOSED: [2021-01-25 Mon 21:17]
    - Elixir uses _square brackets_ to specify a _list_ of values.
      Values can be of *any* type:
      #+begin_src elixir
        [1, 2, true, 3]   # [1, 2, true, 3]
        length [1, 2, 3]  # 3
      #+end_src

    - Two /lists/ can be *concatenated* or *subtracted* using the ~++/2~ and ~--/2~
      operators respectively:
      #+begin_src elixir
        [1, 2, 3] ++ [4, 5, 6]
        # [1, 2, 3, 4, 5, 6]

        [1, true, 2, false, 3, true] -- [true, false]
        # [1, 2, 3, true]
      #+end_src

    - List operators *NEVER modify* the existing list.
      We say that Elixir data structures are *immutable*.

    - ~hd/1~ and ~tl/1~
      #+begin_src elixir
        list = [1, 2, 3]
        hd(list)  # 1
        tl(list)  # [2, 3]
      #+end_src

    - Sometimes you will create a /list/ and it will return a _value in single quotes_.
      For example:
      #+begin_src elixir
        [11, 12, 13]               # '\v\f\r'
        [104, 101, 108, 108, 111]  # 'hello'
      #+end_src
      When Elixir sees a /list/ of _printable ASCII numbers_, Elixir will *print
      that as a /charlist/ (literally a list of characters).*
      * /Charlists/ are quite common when interfacing with existing Erlang code.

      * Whenever you see a value in IEx and you are not quite sure what it is,
        you can use the ~i/1~ to retrieve information about it:
        #+begin_src elixir
          i 'hello'
          Term
            'hello'
          Data type
            List
          Description
            ...
          Raw representation
            [104, 101, 108, 108, 111]
          Reference modules
            List
          Implemented protocols
            ...
        #+end_src

    - Keep in mind *single-quoted representation* and *double-quoted representation*
      are not equivalent in Elixir as they are represented by different types:
      #+begin_src elixir
        'hello' == "hello"
        # false
      #+end_src
      * Single quotes are /charlists/
      * Double quotes are /strings/
      =TODO= More in _"Binaries, strings and charlists"_

*** DONE 8. Tuples
    CLOSED: [2021-01-25 Mon 21:38]
    - tuple :: curly bracket delimited, comma separated.

    - Example:
      #+begin_src elixir
        pair = {:ok, "hello"}

        tuple_size pair  # 2

        put_elem(pair, 1, "wolrd")  # {:ok, "world"}
      #+end_src

*** DONE 9. Lists or tuples?
    CLOSED: [2021-01-25 Mon 21:52]
    - /Lists/ are /linked lists/ that stored in memory with no contiguous memory
      guarantee.

    - /Tuples/ are stored in contiguously in memory.
      * One very common use case for /tuples/ is to use them to return *extra*
        information from a function. For example,
        #+begin_src elixir
          File.read("path/to/existing/file")
          # {:ok, "... contents ..."}

          File.read("path/to/unknown/file")
          # {:error, :enoent}
        #+end_src

    - Elixir convention of function names that used to count elements in a data
      structure:
      * Constant time: ~size~
        + ~byte_size/1~ (for the number of /bytes/ in a /string/)
        + ~tuple_size/1~

      * Linear time: ~length~
        + ~length/1~ (for list length)
        + ~String.length/1~ (for the number of frapheme in a string)

** DONE 3. Basic operators
   CLOSED: [2021-01-25 Mon 22:08]
   - ~or~, ~and~, and ~not~ are for boolean expresions only.
     * ~and~ and ~or~ are mapped from ~Erlang~'s ~andalso~ and ~orelse~, respectively.

   - ~||~, ~&&~, and ~!~ accept arguments of ANY type.
     * All values *excpet* ~false~ and ~nil~ will evaluate to ~true~.

   - Both ~==~ and ~===~ exist.
     The latter is more strict when comparing /integer/ and /floats/.

   - Order of different types values:
     *number < atom < reference < function < port < pid < tuple < map < list < bitstring*

** DONE 4. Pattern matching
   CLOSED: [2021-01-25 Mon 22:22]
*** DONE 1. The match operator
    CLOSED: [2021-01-25 Mon 22:16]
    In Elixir, ~=~ is actually the /match operator/.

*** DONE 2. Pattern matching
    CLOSED: [2021-01-25 Mon 22:16]
    #+begin_src elixir
      [head | tail] = [1, 2, 3]
      # [1, 2, 3]

      head  # 1
      tail  # [2, 3]
    #+end_src

*** DONE 3. The pin operator
    CLOSED: [2021-01-25 Mon 22:22]
    Variable in Elixir can be *rebound*.
    Ue the /pin operator/ to avoid /rebound/.

    #+begin_src elixir
      x = 1
      [^x, 2, 3] = [1, 2, 3]  # [1, 2, 3]
      {y, ^x} = {2, 1}        # {2, 1}

      {y, ^x} = {2, 2}
      # ** (MatchError) no match of right hand side value: {2, 2}
    #+end_src

    - If a variable is mentioned *more than once* in a pattern,
      all references should bind to the *SAME* value:
      #+begin_src elixir
        {x, x} = {1, 1}  # {1, 1}

        {x, x} = {1, 2}  # ** (MatchError) no match of right hand side value: {1, 2}
      #+end_src

    - ~_~ in pattern is supported.
      * The variable ~_~ is special in that it can *never* be read from.
        Trying to read from it gives a _compile error_.

** TODO 5. ~case~, ~cond~, and ~if~
*** DONE 1. ~case~
    CLOSED: [2021-01-25 Mon 22:35]
    #+begin_src elixir
      ## Basic
      ##---------
      case {1, 2, 3} do
        {4, 5, 6} -> "This clause won't match"
        {1, x, 3} -> "This clause will match and bind x to 2 in thi clause"
        _         -> "This clause would match any value"
      end

      # "This clause will match and bind x to 2 in thi clause"


      ## Pin operator
      ##-------------
      x = 1

      case 10 do
        ^x -> "Won't match"
        _  -> "Will match"
      end

      # "Will match"


      ## Guards
      ##-------------
      case {1, 2, 3} do
        {1, x, 3} when x > 0 -> "Will match"
        _                    -> "Would match, if guard condition were not satisfied"
      end

      # "Will match"
    #+end_src

    - Anonymous function can also have *MULTIPLE* clauses and /guards/:
      #+begin_src elixir
        f = fn
          x, y when x > 0 -> x + y
          x, y            -> x * y
        end

        f.(1, 3)   # 4
        f.(-1, 3)  # -3
      #+end_src
      * The number of arguments in EACH /anonymous function clause/ needs to be the
        *SAME*, otherwise an error is raised.
        #+begin_src elixir
          f2 = fn
            x, y when x > 0 -> x + y
            x, y, z         -> x * y + z
          end

          # ** (CompileError) iex:1: cannot mix clauses with different arities in anonymous functions
        #+end_src

*** DONE 2. ~cond~
    CLOSED: [2021-01-25 Mon 22:39]
    #+begin_src elixir
      cond do
        2 + 2 == 5 -> "This will not be true"
        2 * 2 == 3 -> "Nor this"
        1 + 1 == 2 -> "But this will"
      end

      # "But this will"
    #+end_src

*** DONE 3. ~if~ and ~unless~
    CLOSED: [2021-01-25 Mon 22:41]
    ~if/2~ and ~unless/2~ are implemented as /macros/.
    They aren't special language constructs in Elixir.

*** TODO 4. ~do/end~ blocks - =RE-NOTE=
    At this point, we have learned _FOUR_ /control structures/: ~case~, ~cond~,
    ~if~, and ~unless~, and they were all wrapped in ~do/end~ blocks.
    It happens we could *also write* if as follows: ~if true, do: 1 + 2~

    - Notice how the example above has a comma between true and do:, that’s
      because it is using Elixir’s regular syntax where each argument is
      separated by a comma. We say this syntax is using keyword lists. We can
      pass else using keywords too:
      #+begin_src elixir
        if false, do: :this, else: :that
        #=> :that
      #+end_src

    - ~do/end~ blocks are a syntactic convenience built on top of the keyword ones.
      That’s why ~do/end~ blocks do not require a comma between the previous
      argument and the block. They are useful exactly because they remove the
      verbosity when writing blocks of code. These are equivalent:
      #+begin_src elixir
        if true do
          a = 1 + 2
          a + 10
        end
        #=> 13


        if true, do: {
          a = 1 + 2
          a + 10
        }
        #=> 13
      #+end_src

    - =IMPORTANT=
      One thing to keep in mind when using ~do/end~ blocks is they are
      *ALWAYS bound to the _outermost_ /function call/.*
      For example, the following expression:
      #+begin_src elixir
        is_number if true do
          1 + 2
        end
        ## **(CompileError) iex:1: undefined function is_number/2
      #+end_src
      
      would be parsed as:
      
      #+begin_src elixir
        is_number(if true) do
          1 + 2
        end
        ## **(CompileError) iex:1: undefined function is_number/2
      #+end_src
      which leads to an undefined function error because that invocation passes
      two arguments, and is_number/2 does not exist. The if true expression is
      invalid in itself because it needs the block, but since the arity of
      is_number/2 does not match, Elixir does not even reach its evaluation.

      * Adding *explicit parentheses* is enough to bind the block to ~if~:
        #+begin_src elixir
          is_number(if true do
            1 + 2
          end)

          #=> true
        #+end_src

    - /Keyword lists/
      * play an important role in the language and
      * are quite common in many /functions/ and /macros/.

    - =NEXT=
      We will explore them a bit more in a future chapter.
      Now it is time to talk about “Binaries, strings, and char lists”.
   
** DONE 6. Binaries, strings, and charlists
   CLOSED: [2021-01-28 Thu 21:16]
   - In “Basic types”, we learned a little bit about strings and we used the
     ~is_binary/1~ /function/ for checks:
     #+begin_src elixir
       string = "hello"   #=> "hello"
       is_binary(string)  #=> true
     #+end_src

   - In this chapter, we will gain clarity on
     * what exactly /binaries/ are,
     * how they relate to /strings/, and
     * what _single-quoted values_, ~'like this'~, mean in Elixir.

   - /strings/ are actually subtly complex and are often misunderstood.

*** DONE 1. Unicode and Code Points
    CLOSED: [2021-01-28 Thu 11:29]
    - Unicode organizes all of the characters in its repertoire into code charts,
      and each character is given a *unique* _numerical index_.
      * This _numerical index_ is known as a /Code Point/.

    - In Elixir you can use a ~?~ in front of a /character literal/ to reveal its
      /code point/, in IEx:
      * ~?a~ output ~97~
      * ~?ł~ output ~322~

    - Note that _most (=from Jian= why only "most"?) Unicode code charts_ will
      refer to a /code point/ by its /hexadecimal representation/, e.g. 97
      translates to _0061_ in hex, and we can represent any _Unicode character_
      in an _Elixir string_ by using the ~\u~ notation and the _hex representation_
      of its /code point/ number:
      #+begin_src elixir
        "\u0061" === "a"  #=> true
        0x0061 = 97 = ?a  #=> 97
      #+end_src

*** DONE 2. UTF-8 and Encodings
    CLOSED: [2021-01-28 Thu 16:14]
    - Whereas the /code point/ is *what* we store, an encoding deals with *how*
      we store it: _encoding is an implementation._
        In other words, we need a mechanism to CONVERT the /code point numbers/
      INTO /bytes/ so they can be stored in memory, written to disk, etc.
      * =from Jian=
        Encoding is used to save the space when storing.

    - Elixir uses UTF-8 to encode its strings, which means that code points are
      encoded as _a series of 8-bit bytes._

    - UTF-8 is a *variable width character encoding* that uses _one to four bytes_
      to store each code point; it is capable of encoding all valid Unicode code
      points.

    - graphemes :: consist of MULTIPLE characters that are often perceived as ONE. 

    - Besides defining characters, *UTF-8 also provides a notion of /graphemes/.*
      * For example,
        ~é~ can be represented in Unicode as a single character.
        It can also be represented as the _COMBINATION_ of
        1. the character ~e~
           and
        2. the acute accent character ~´~
        into a _SINGLE_ /grapheme/.

      * In other words, what we would expect to be a single character, such as é or
        ł, can in practice be multiple characters, each represented by potentially
        multiple bytes. Consider the following:
        #+begin_src elixir
          string = "hełło"       #=> "hełło"
          String.length(string)  #=> 5
          byte_size(string)      #=> 7
        #+end_src
        ~String.length/1~ _counts /graphemes/,_
        but ~byte_size/1~ reveals the _number of underlying /raw bytes/ needed to
        store the string when using UTF-8 encoding._
        + UTF-8 requires
          - *one* byte to represent the /characters/ ~h~, ~e~, and ~o~,
          - but *two* bytes to represent ~ł~.

    - Note (in Windows):
      There is a chance your terminal does _not use UTF-8 by default_.
      You can *change* the /encoding/ of your current session by running
      ~chcp 65001~ *before entering* =iex= (=iex.bat=).

    - A common trick in Elixir when you want to see the
      *inner binary representation* of a /string/ is to concatenate _the null
      byte_ ~<<0>>~ to it:
      #+begin_src elixir
        "hełło" <> <<0>>
        #=> <<104, 101, 197, 130, 197, 130, 111, 0>>
      #+end_src
      * Alternative way (more clean, no trailing ~<<0>>~):
        #+begin_src elixir
          IO.inspect("hełło", binaries: :as_binaries)
          #=> <<104, 101, 197, 130, 197, 130, 111>>
        #+end_src
      
    - =NEXT=
      ~<<>>~
      
*** DONE 3. Bitstrings
    CLOSED: [2021-01-28 Thu 16:26]
    Although we have covered /code points/ and /UTF-8 encoding/, we still need
    to go a bit DEEPER INTO _HOW exactly we store the /encoded bytes/,_ and this
    is where we introduce the /bitstring/.

    - A /bitstring/ is a *fundamental data type* in Elixir, denoted with the
      ~<<>>~ syntax. A /bitstring/ is a _contiguous sequence of bits in memory._

    -  =TODO= =READ=
      A complete reference about the binary / *bitstring constructor* ~<<>>~ can
      be found in the Elixir documentation.

    - *BY DEFAULT*, _8 bits (i.e. 1 byte)_ is used to store each number in a
      /bitstring/,
      * _BUT_ you can manually specify the number of bits via
        + _a ~::n~ modifier_ to denote the size in ~n~ bits,
          OR
        + you can use the more _verbose declaration_ ~::size(n)~:
        #+begin_src elixir
          <<42>> === <<42::8>>  #=> true
          <<3::4>>              #=> <<3::size(4)>>
        #+end_src

    - For example,
      the decimal number ~3~ when represented with 4 bits in base ~2~ would be
      ~0011~, which is equivalent to the values ~0~, ~0~, ~1~, ~1~, each stored
      using 1 bit:
      #+begin_src elixir
        <<0::1, 0::1, 1::1, 1::1>> == <<3::4>>  #=> true
      #+end_src

    - Any value that _exceeds_ what can be stored by the number of bits provisioned
      is *truncated*:
      #+begin_src elixir
        <<1>> === <<257>>  #=> true
      #+end_src
      ~100000001~ (9 bits) is truncated to ~00000001~ (8 bits).

*** DONE 4. Binaries
    CLOSED: [2021-01-28 Thu 17:38]
    - binary :: a /bitstring/ where the number of bits is _divisible by 8_.

    - From the definition of /binary/ we know
      _every /binary/ is a /bitstring/, but not every /bitstring/ is a /binary/._
        We can use the ~is_bitstring/1~ and ~is_binary/1~ functions to demonstrate
      this.
      #+begin_src elixir
        is_bitstring(<<3::4>>)       #=> true
        is_binary(<<3::4>>)          #=> false
        is_bitstring(<<0, 255, 42>>) #=> true
        is_binary(<<0, 255, 42>>)    #=> true
        is_binary(<<42::16>>)        #=> true
      #+end_src

    - We can /pattern match/ on /binaries/ / /bitstrings/:
      #+begin_src elixir
        <<0, 1, x>> = <0, 1, 2>>  #=> <<0, 1, 2>>
        x                         #=> 2
      #+end_src

    - Note that unless you explicitly use ~::~ modifiers, each entry in the binary
      pattern is expected to match a _single byte_ (exactly _8 bits_).
        If we want to match on a binary of *unknown size*, we can use _the ~binary~
      modifier_ *at the end of the pattern*:
      #+begin_src elixir
        <<0, 1, x :: binary>> = <<0, 1, 2, 3>>  #=> <<0, 1, 2, 3>>

        x  #=> <<2, 3>>
      #+end_src

    - There are a couple other /modifiers/ that can be useful when doing _pattern
      matches on binaries._ The ~binary-size(n)~ modifier will match _n bytes_ in
      a /binary/:
      #+begin_src elixir
        <<head::binary-size(2), rest::binary>> = <<0, 1, 2, 3>>  #=> <<0, 1, 2, 3>>
        head  #=> <<0, 1>>
        rest  #=> <<2, 3>>
      #+end_src

    - *A /string/ is a _UTF-8 encoded_ /binary/,* where the /code point/ for each
      character is _encoded using 1 to 4 bytes_.

      * Thus *every /string/ is a /binary/,*
        but _due to the UTF-8 standard encoding rules_, *NOT every /binary/ is a
        valid /string/.*
        #+begin_src elixir
          is_binary("hello")               #=> true
          is_binary(<<239, 191, 19>>)      #=> true
          String.valid?(<<239, 191, 19>>)  #=> false
        #+end_src

    - The _string concatenation operator_ ~<>~ is actually a _binary concatenation
      operator_:
      #+begin_src elixir
        "a" <> "ha"           #=> "aha"
        <<0, 1>> <> <<2, 3>>  #=> <<0, 1, 2, 3>>
      #+end_src

    - Given that /strings/ are /binaries/, we can also _pattern match on /strings/:_
      #+begin_src elixir
        <<head, rest::binary>> = "banana"  #=> "banana"
        head == ?b  #=> true
        rest        #=> "anana"
      #+end_src

    - However, remember that /binary pattern matching/ works on /bytes/,
      so matching on the /string/ like ~“über”~ with _multibyte characters_
      *won't match* on the character, it will match on the _first byte_ of that
      character:
      #+begin_src elixir
        "ü" <> <<0>>                  #=> <<195, 188, 0>>
        <<x, rest::binary>> = "über"  #=> "über"
        x == ?ü                       #=> false
        rest                          #=> <<188, 98, 101, 114>>
      #+end_src

    - Therefore, when _pattern matching on /strings/,_ it is important to use the
      ~utf8~ /modifier/:
      #+begin_src elixir
        <<x::utf8, rest::binary>> = "über"  #=> "über"
        x == ?ü                             #=> true
        rest                                #=> "ber"
      #+end_src

    - You will see that Elixir has excellent support for working with /strings/.
      It also supports many of the _Unicode operations_.
      * In fact, Elixir passes all the tests showcased in the article
        [[http://mortoray.com/2013/11/27/the-string-type-is-broken/][“The string type is broken”]]. =TODO= =READ= =!!!=
        =READ= =READ= =READ= =READ= =READ= =READ= =READ= =READ= =READ= =READ=

*** DONE 5. Charlists
    CLOSED: [2021-01-28 Thu 21:14]
    Our tour of our /bitstrings/, /binaries/, and /strings/ is nearly complete,
    BUT we have one more _data type_ to explain: the /charlist/.

    - charlist :: a /list/ of /integers/
                  where *ALL* the /integers/ are *valid* /code points/.

    - _In practice, you will NOT COME ACROSS THEM OFTEN_,
      EXCEPT perhaps when interfacing with Erlang, in particular when using
      older libraries that do not accept /binaries/ as arguments.
      =IMPORTANT=

    - Whereas /strings/ (i.e. binaries) are created using _double-quotes_,
      /charlists/ are created with _single-quoted literals_:
      #+begin_src elixir
        'hełło'              #=> [104, 101, 322, 322, 111]
        is_list 'hełło'      #=> true
        'hello'              #=> 'hello'
        List.first('hello')  #=> 104
      #+end_src

    - You can see that *instead of containing* /bytes/,
      a /charlist/ contains /integer code points/.
      * _BY DEFAULT,_
        IEx will *ONLY output* /code points/ if *ANY* of the /integers/ falls
        *OUTSIDE* the ASCII range of 0 to 127:
        #+begin_src elixir
          'hello'  #=> 'hello'
          'hełło'  #=> [104, 101, 322, 322, 111]
        #+end_src
        You can use ~IO.inspect/2~ to inspect the /code points/ of ~'hello'~:
        #+begin_src elixir
          IO.inspect('hello')  #=> [104, 101, 108, 108, 111]
        #+end_src

    - *Interpreting* /integers/ *as* /codepoints/ may lead to some _surprising
      behavior_.
      * For example,
        if you are *storing* a _list of integers_ that happen to _range between 0
        and 127,_ BY DEFAULT IEx will interpret this as a /charlist/ and it will
        display the corresponding ASCII characters.
        #+begin_src elixir
          heartbeats_per_minute = [99, 97, 116]  #=> 'cat'
        #+end_src

    - You can convert a /charlist/ to a /string/ and back by using the ~to_string/1~
      and ~to_charlist/1~ /functions/:
      #+begin_src elixir
        to_charlist "hełło"  #=> [104, 101, 322, 322, 111]
        to_string 'hełło'    #=> "hełło"
        to_string :hello     #=> "hello"
        to_string 1          #=> "1"
      #+end_src
      Note that those functions are /polymorphic/ - not only do they convert
      /charlists/ to /strings/, they also operate on /integers/, /atoms/, _and
      so on_.

    - /String (binary)/ concatenation uses the ~<>~ operator
      BUT /charlists/, being /lists/, use the _list concatenation operator_
      ~++~:
      #+begin_src elixir
        'this ' <> 'fails'  #=> ** (ArgumentError) ...

        'this ' ++ 'works'  #=> 'this works'

        "this also " ++ "fails"  #=> ** (ArgumentError) ...
      #+end_src

** DONE 7. Keyword lists and maps
   CLOSED: [2021-01-27 Wed 00:46]
   In Elixir, we have TWO main /associative data structures/:
   - /keyword lists/
   - /maps/

*** DONE 1. Keyword lists
    CLOSED: [2021-01-26 Tue 01:42]
    - Equivalent way of definitions:
      #+begin_src elixir
        list = [{:a, 1}, {:b, 2}]  #=> [a: 1, b: 2]
        list == [a: 1, b: 2]       #=> true
      #+end_src

    - Concatenate:
      #+begin_src elixir
        list ++ [c: 3]  #=> [a: 1, b: 2, c: 3]

        [a: 0] ++ list  #=> [a: 0, a: 1, b: 2]
      #+end_src

    - On lookup, the first match will be picked:
      #+begin_src elixir
        new_list = [a: 0] ++ list  #=> [a: 0, a: 1, b: 2]
        new_list[:a]               #=> 0
      #+end_src

    - /Keyword lists/ are important because they have *THREE* _special
      characteristics_:
      * Keys must be /atoms/.
      * Keys are *ordered*, as specified by the developer.
      * Keys can be given *more than once*.

    - For example, =TODO=
      the *Ecto* library makes use of these features to provide an elegant DSL for
      writing database queries:
      #+begin_src elixir
        query = from w in Weather,
              where: w.prcp > 0,
              where: w.temp < 20,
              select: w
      #+end_src

    - These characteristics are what prompted /keyword lists/ to be the default
      mechanism for passing _options_ to /functions/ in Elixir.
        In chapter 5, when we discussed the ~if/2~ /macro/, we mentioned that
      the following syntax is supported:
      #+begin_src elixir
        if false, do: :this, else: :that
      #+end_src
      * In fact, the call above is equivalent to:
        #+begin_src elixir
          if(false, [do: :this, else: :that])  #=> :that

          if(false, [{:do, :this}, {:else, :that}])  #=> :that
        #+end_src
        *In general, when the /keyword list/ is the _LAST argument_ of a /function/,
        the _square brackets_ are _optional_.*

    - It is rarely done that in practice pattern match /keyword lists/, since
      pattern matching on lists requires the number of items and their order to
      match

    - In order to manipulate /keyword lists/, Elixir provides the =Keyword= module.

    - For the linear performance reason, /keyword lists/ are used in Elixir *mainly
      for passing optional values.* If you need to store many items or guarantee
      one-key associates with at maximum one-value, you should use /maps/ instead.

*** DONE 2. Maps
    CLOSED: [2021-01-26 Tue 16:46]
    - Syntax illustrated by an example:
      #+begin_src elixir
        map = %{:a => 1, 2 => :b}  #=> %{2 => :b, :a => 1}

        map[:a]  #=> 1
        map[2]   #=> :b
        map[:c]  #=> nil
      #+end_src

    - Compared to /keyword lists/, we can already see _TWO_ DIFFERENCES:
      * Maps allow *any* value as a /key/.
      * Maps' /keys/ do *not* follow any _ordering_.

    - Pattern match /maps/ always match on a subset of the given value:
      #+begin_src elixir
        %{} = %{:a => 1, 2 => :b}         #=> %{2 => :b, :a => 1}

        %{:a => a} = %{:a => 1, 2 => :b}  #=> %{2 => :b, :a => 1}
        a  # 1

        %{:c => c} = %{:a => 1, 2 => :b}
        # ** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}
      #+end_src

    - The ~Map~ /module/ provides a _very similar API_ to the ~Keyword~ /module/
      with convenience /functions/ to MANIPULATE /maps/:
      #+begin_src elixir
        Map.get(%{:a => 1, 2 => :b}, :a)     #=> 1
        Map.put(%{:a => 1, 2 => :b}, :c, 3)  #=> %{2 => :b, :a => 1, :c => 3}
        Map.to_list(%{:a => 1, 2 => :b})     #=> [{2, :b}, {:a, 1}]
      #+end_src

    - /Maps/ have the following syntax for *updating* a _key's value_:
      #+begin_src elixir
        map = %{:a => 1, 2 => :b}  #=> %{2 => :b, :a => 1}
        %{map | 2 => "two"}        #=> %{2 => "two", :a => 1}

        %{map | :c => 3}
        #=> ** (KeyError) key :c not found in %{2 => :b, :a => 1}
      #+end_src

    - When *all* the /keys/ in a /map/ are /atoms/,
      you can use the /keyword syntax/ for convenience:
      #+begin_src elixir
        map = %{a: 1, b: 2}  #=> %{a: 1, b: 2}
      #+end_src

    - Another interesting property of /maps/ is that they provide their OWN syntax
      for *accessing* /atom keys/:
      #+begin_src elixir
        map = %{:a => 1, 2 => :b}  #=> %{2 => :b, :a => 1}

        map.a #=> 1

        map.c
        #=> ** (KeyError) key :c not found in: %{2 => :b, :a => 1}
      #+end_src
      Elixir developers typically
      *PREFER to use the ~map.field~ syntax and pattern matching*
      instead of the /functions/ in the ~Map~ /module/ when working with /maps/
      because they lead to an /assertive style of programming/.

      * =TODO=
        [[https://dashbit.co/blog/writing-assertive-code-with-elixir][This blog post by José Valim]] provides insight and examples on how you
        get more concise and faster software by writing assertive code in
        Elixir.

*** TODO 3. ~do~-blocks and keywords
*** DONE 4. Nested data structures
    CLOSED: [2021-01-27 Wed 00:46]
    Often we will have _/maps/ *inside* /maps/,_ or even _/keywords lists/
    *inside* /maps/,_ and so forth.
      Elixir provides conveniences for MANIPULATING _nested data structures_ via
    the ~put_in/2~, ~update_in/2~ and other /macros/ giving the same conveniences
    you would find in imperative languages while keeping the immutable properties
    of the language

    - Imagine you have the following structure:
      #+begin_src elixir
        users = [
          john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
          mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
        ]
        # =>
        # [john: %{age: 27, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
        #  mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}]

        ## Access the value of `john`
        ##---------------------------
        users[:john].age  #=> 27


        ## Update the value with a expression:
        ##---------------------------
        users = put_in users[:john].age, 31
        #=> [john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
        #    mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}]


        ## Update the value with a function:
        ##---------------------------
        users = update_in users[:mary].languages, fn languages -> List.delete(languages, "Clojure") end
        #=> [john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
        #    mary: %{age: 29, languages: ["Elixir", "F#"], name: "Mary"}]
      #+end_src
      * More to learn (Check the ~Kernel~ module):
        + ~get_and_update_in/2~:
          extract a value and update the data structure at once.

        + ~put_in/3~, ~update_in/3~, ~get_and_update_in/3~:
          dynamic access into the data structure.

** DONE 8. Modules and Functions
   CLOSED: [2021-01-26 Tue 01:10]
   We use the ~defmodule~ /macro/ to define /modules/.
   We use the ~def~ /macro/ to define /functions/ in /modules/.

   - Example:
     #+begin_src elixir
       defmodule Math do
         def sum(a, b) do
           a + b
         end
       end
     #+end_src

*** DONE 1. Compilation
    CLOSED: [2021-01-26 Tue 00:29]
    - Steps of compilation and use: 
      1. Write the code above in file =math.ex=.
      2. Compile ~elixirc math.ex~, and get the file =Elixir.Math.beam= containing bytecode.
      3. Start IEx in the same directory of the bytecode file from step 2.
      4. Then you can call ~Math.sum(1, 2)~ in IEx.

    - Elixir projects are usually organized into three directories:
      * =ebin= - contains the compiled bytecode
      * =lib= - contains Elixir code (usually =.ex= files)
      * =test= - contains tests (usually =.exs= files)

    - =TODO=
      When working on actual projects, the build tool called =mix= will be
      responsible for compiling and setting up the proper paths for you.

    - For learning purposes,
      Elixir also supports a *scripted mode* which
      * is _more flexible_
      * does *NOT generate* any compiled artifacts.

*** DONE 2. Scripted mode
    CLOSED: [2021-01-26 Tue 00:33]
    #+begin_src elixir
      defmodule Math do
        def sum(a, b) do
          a + b
        end
      end

      IO.puts Math.sum(1, 2)
    #+end_src
    Run it: ~elixir math.exs~.

    - =.ex= files used for compiling to =.beam= files,
      while =.exs= files are used for scripting.

*** DONE 3. Named functions
    CLOSED: [2021-01-26 Tue 00:40]
    - ~defp/2~ is used to define /private functions/.

    - /Function declarations/ also support /guards/ and /multiple clauses/.
      * Example:
        #+begin_src elixir
          defmodule Math do
            def zero?(0) do
              true
            end

            def zero?(x) when is_integer(x) do
              false
            end
          end

          IO.puts Math.zero?(0)          #=> true
          IO.puts Math.zero?(1)          #=> false
          IO.puts Math.zero?([1, 2, 3])  #=> ** (FunctionClauseError)
          IO.puts Math.zero?(0.0)        #=> ** (FunctionClauseError)
        #+end_src

    - Similar to constructs like ~if~, named functions support both ~do:~ and
      ~do/end~ block syntax, 
      * Example:
        #+begin_src elixir
          defmodule Math do
            def zero?(0), do: true
            def zero?(x) when is_integer(x), do: false
          end
        #+end_src
        _Use ~do:~ for one-liner is good!_

*** DONE 4. Function capturing
    CLOSED: [2021-01-26 Tue 00:56]
    The ~name/arity~ can also be used to *retrieve* a /named function/ as a
    /function type/.

    - Example:
      #+begin_src elixir
        # Run `iex math.exs`, and then type

        Math.zero?(0)        # true

        fun = &Math.zero?/1  # &Math.zero?/1

        is_function(fun)     # true

        fun.(0)              # true
      #+end_src

    - Local or imported functions, like ~is_function/1~, can be _captured *without*
      the /module/:_
      #+begin_src elixir
        &is_function/1          #=> &:erlang.is_function/1
        (&is_funciton/1).(fun)  #=> true
      #+end_src

    - /Capture syntax/ can also be used as a _shortcut_ for *creating* /functions/:
      #+begin_src elixir
        fun = &(&1 + 1)  #=> #Function<6.71889879/1 in :erl_eval.expr/5>
        fun.(1)          #=> 2

        fun2 = &"Good #{&1}"  #=> #Function<6.127694169/1 in :erl_eval.expr/5>
        fun2.("morning")      #=> "Good morning"
      #+end_src

    - If you want to *capture* a /function/ from a /module/,
      there is an alternative syntax similar to ~&Module.function/arity~:
      #+begin_src elixir
        fun = &List.flatten(&1, &2)  #=> &List.flatten/2
        fun.([1, [[2], 3]], [4, 5])  #=> [1, 2, 3, 4, 5]
      #+end_src

*** DONE 5. Default arguments
    CLOSED: [2021-01-26 Tue 01:10]
    - Example:
      #+begin_src elixir
        defmodule Concat do
          def join(a, b, sep \\ " ") do
            a <> sep <> b
          end
        end

        IO.puts Concat.join("Hello", "world")      #=> Hello world
        IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
      #+end_src

    - Any expression is allowed to serve as a /default value/,
      * *BUT it won't be evaluated during the /function definition/.*

      * Every time the function is invoked and any of its /default values/ _have
        to be used_, the expression for that /default value/ will be evaluated:

      * Example:
        #+begin_src elixir
          defmodule DefaultTest do
            def dowork(x \\ "hello") do
              x
            end
          end

          DefaultTest.dowork      #=> "hello"
          DefaultTest.dowork 123  #=> 123
        #+end_src

    - /Multiple clauses function defintion/ with /default values/ requires to create
      a function head (without an actual body) _for declaring defaults_. For example:
      #+begin_src elixir
        defmodule Concat do
          # A function head declaring defaults
          def join(a, b \\ nil, sep \\ " ")

          def join(a, b, _sep) when is_nil(b) do
            a
          end

          def join(a, b, sep) do
            a <> sep <> b
          end
        end
      #+end_src
      The _leading underscore_ in ~_sep~ means that the variable will be *ignored* in
      this function.

    - When using /default values/, one must be CAREFUL to *avoid overlapping function
      definitions*. 
      #+begin_src elixir
        defmodule Concat do
          def join(a, b) do
            IO.puts "***First join"
            a <> b
          end

          def join(a, b, sep \\ " ") do
            IO.puts "***Second join"
            a <> sep <> b
          end
        end
      #+end_src
      Compile this will receive a _warning_:
      =warning: this clause cannot match because a previous clause at line 2 always matches=

      * =from Jian= =TODO=
        If this is on purpose, how can I suppress this warning for this definition???

** DONE 9. Recursion
   CLOSED: [2021-01-26 Tue 01:20]
*** DONE 1. Loops through recursion
    CLOSED: [2021-01-26 Tue 01:20]
    Due to *immutability*, loops in Elixir (as in any /functional programming
    language/) are written differently from /imperative languages/.

*** DONE 2. Reduce and map algorithms
    CLOSED: [2021-01-26 Tue 01:20]
    - Reduce algorithm example:
      #+begin_src elixir
        defmodule Math do
          def sum_list([head | tail], accumulator) do
            sum_list(tail, head + accumulator)
          end

          def sum_list([], accumulator) do
            accumulator
          end
        end

        IO.puts Math.sum_list([1, 2, 3], 0) #=> 6
      #+end_src

    - Map algorithm example:
      #+begin_src elixir
        defmodule Math do
          def double_each([head | tail]) do
            [head * 2 | double_each(tail)]
          end

          def double_each([]) do
            []
          end
        end
      #+end_src

    - We usually don't write code manually like above.
      * We will use the provided functionalities in the ~Enum~ /module/.
        For example:
        #+begin_src elixir
          Enum.reduce([1, 2, 3], 0, &+/2)  #=> 6
          Enum.map([1, 2, 3], &(&1 * 2))   #=> [2, 4, 6]
        #+end_src
        =NEXT=
        Let’s take a deeper look at ~Enumerable~ and, while we're at it, its
        *lazy* counterpart, ~Stream~.

** DONE 10. Enumerables and streams
   CLOSED: [2021-01-27 Wed 03:13]
*** DONE 1. Enumerables
    CLOSED: [2021-01-27 Wed 02:49]
    Elixir provides the concept of /enumerables/ and the ~Enum~ /module/ to work
    with them.

    - We have already learned _TWO_ /enumerables/: /lists/ and /maps/.
      #+begin_src elixir
        Enum.map([1, 2, 3], fn &(&1 * 2) end)            #=> [2, 4, 6]
        Enum.map(%{1 => 2, 3 => 4}, fn {} -> k * v end)  #=> [2, 12]
      #+end_src

    - The ~Enum~ /module/ provides a huge range of /functions/ to
      * /transform/
      * /sort/
      * /group/
      * /filter/
      * /retrieve items/ from /enumerables/.

      It is one of the /modules/ *developers use frequently* in their Elixir code.

    - Elixir also provides /ranges/:
      #+begin_src elixir
        Enum.map(1..3, &(&1 * 2))  #=> [2, 4, 6]
        Enum.reduce(1..3, &+/2)    #=> 6
      #+end_src

    - The /functions/ in the ~Enum~ /module/ are *limited to*, as the name says,
      /enumerating values/ in /data structures/.
      * For specific operations, like *inserting* and *updating* particular
        elements, you may need to reach for /modules/ specific to the _data type_.

      * For example, =TODO= =TRY IT=
        if you want to insert an element at a given position in a /list/, you
        should use the ~List.insert_at/3~ /function/ from the ~List~ /module/,
        as it would make little sense to insert a value into, for example, a /range/.

    - The /functions/ in the ~Enum~ /module/ are /polymorphic/
      because they can work with _DIVERSE data types_, ANY data type that implements
      the ~Enumerable~ /protocol/.
      * =TODO=
        We are going to discuss /Protocols/ in a later chapter;
        for now we are going to move on to a specific kind of /enumerable/ called
        a /stream/.

*** DONE 2. Eager vs Lazy
    CLOSED: [2021-01-27 Wed 02:56]
    *All* the /functions/ in the ~Enum~ /module/ are *eager*.

    - Many /functions/ in the ~Enum~ /module/
      _expect_ an /enumerable/ and
      _return_ a /list/ back.
      #+begin_src elixir
        odd? = &(rem(&1, 2) != 0) #=> #Function<6.80484245/1 in :erl_eval.expr/5>
        Enum.filter(1..3, odd?)   #=> [1, 3]
      #+end_src

*** DONE 3. The pipe operator
    CLOSED: [2021-01-27 Wed 02:56]
    - ~|>~ (pipe operator) ::
      expression on its left side and
      passes it *as the FIRST argument* to the function call on its right side.

    - Example:
      #+begin_src elixir
        1..100_000            |>
          Enum.map(&(&1 * 3)) |>
          Enum.filter(odd?)   |>
          Enum.sum

        #=> 7500000000
      #+end_src

      is equivalent to

      #+begin_src elixir
        Enum.sum(Enum.filter(Enum.map(1..100_000, &(&1 * 3)), odd?))
        #=> 7500000000
      #+end_src

*** DONE 4. Streams
    CLOSED: [2021-01-27 Wed 03:13]
    As an _ALTERNATIVE_ to ~Enum~, Elixir provides the ~Stream~ /module/ which
    supports *lazy operations*.

    - Example:
      #+begin_src elixir
        1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?) |> Enum.sum
        #=> 7500000000
      #+end_src

    - streams :: lazy and composable enumerables.

    - Instead of *generating* _intermediate_ /lists/,
      /streams/ build a series of computations that are invoked
      *only* when we pass the underlying /stream/ to the ~Enum~ /module/.

    - /Streams/ are useful when working with
      * large
      * possibly infinite
      * collections

    - Many /functions/ in the ~Stream~ /module/
      1. *accept* ANY /enumerable/ as an argument
      2. *return* a /stream/ as a result.

    - It also provides /functions/ for *creating* /streams/.
      * For example,
        ~Stream.cycle/1~ can be used to *create* a /stream/ that cycles a given
        enumerable infinitely.
          Be careful to *NOT* call a /function/ like ~Enum.map/2~ on such
        /streams/, as they would *cycle forever*:
        #+begin_src elixir
          stream = Stream.cycle([1, 2, 3])  #=> #Function<15.16982430/2 in Stream.unfold/2>
          Enum.take(stream, 10)             #=> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]
        #+end_src

    - On the other hand, ~Stream.unfold/2~ can be used to *generate values*
      from a _given initial value_:
      #+begin_src elixir
        stream = Stream.unfold("hełło", &String.next_codepoint/1)
        #=> #Function<39.75994740/2 in Stream.unfold/2>

        Enum.take(stream, 3)
        #=> ["h", "e", "ł"]
      #+end_src

    - ~Stream.resource/3~ which can be used to _WRAP around *resources*,_
      guaranteeing they are
      1. *opened* right _BEFORE_ enumeration
      2. *closed* _AFTERWARDS_, even in the case of failures.

    - For example, ~File.stream!/1~ builds on top of ~Stream.resource/3~ to stream
      files:
      #+begin_src elixir
        stream = File.stream!("path/to/file")
        #=>
        #  %File.Stream{
        #    line_or_bytes: :line,
        #    modes: [:raw, :read_ahead, :binary],
        #    path: "path/to/file",
        #    raw: true
        #  }

        Enum.take(stream, 10)
      #+end_src
      This can be very useful for _handling large files_ or even _slow
      resources_ like /network resources/.

** TODO 11. Processes
*** 1. ~spawn~
*** 2. ~send~ and ~receive~
*** 3. Links
*** 4. Tasks
*** 5. State

** DONE 12. IO and the file system - =TODO= =READ after finishing chapter 11=
   CLOSED: [2021-01-28 Thu 23:54]
   This chapter is a quick introduction to _input/output mechanisms_ and
   _file-system-related tasks_, as well as to related /modules/ like ~IO~,
   ~File~ and ~Path~.

*** DONE 1. The ~IO~ module
    CLOSED: [2021-01-28 Thu 23:37]
    The ~IO~ /module/ is the main mechanism in Elixir for *reading* and *writing*
    to _standard input/output (~:stdio~)_, _standard error (~:stderr~)_, /files/,
    and _other IO devices_.

    #+begin_src elixir
      IO.puts("hello world")
      # hello world
      #=> :ok

      IO.gets("yes or no? ")
      # yes or no? yes
      #=> "yes\n"
    #+end_src
    - BY DEFAULT, *read* and *write* _standard input/output_.

    - Can pass ~:stderr~ as an argument to *read* and *write* it:
      #+begin_src elixir
        IO.puts(:stderr, "hello world")
        # hello world
        #=> :ok
      #+end_src

*** DONE 2. The ~File~ module
    CLOSED: [2021-01-28 Thu 23:53]
    The ~File~ /module/ contains /functions/ that allow us to open files as IO
    devices.

    - BY DEFAULT, _files are opened in /binary mode/,_
      which requires developers to use the specific ~IO.binread/2~ and
      ~IO.binwrite/2~ /functions/ from the ~IO~ /module/:
      #+begin_src elixir
        {:ok, file} = File.open("hello", [:write])  #=> {:ok, #PID<0.47.0>}
        IO.binwrite(file, "world")  #=> :ok
        IO.close(file)              #=> :ok
        File.read("hello")          #=> {:ok, "world"}
      #+end_src
      * A /file/ can also be opened with ~:utf8~ /encoding/,
        which tells the ~File~ /module/ to interpret the /bytes/ _read from_ the
        /file/ as /UTF-8-encoded bytes/.

    - Besides /functions/ for _opening_, _reading_ and _writing_ /files/, the
      ~File~ /module/ has many /functions/ to work with the /file system/. Those
      functions are *named after their UNIX equivalents.*
      * For example,
        + ~File.rm/1~
        + ~File.mkdir/1~
        + ~File.mkdir_p/1~
        + ~File.cp_r/2~
        + ~File.rm_rf/1~

    - You will also notice that /functions/ in the ~File~ /module/ have
      _TWO variants_: with or without a trailing bang (~!~).
      * For example,
        when we read the ~"hello"~ file in the example above, we use ~File.read/1~.
        Alternatively, we can use ~File.read!/1~:
        #+begin_src elixir
          File.read("hello")   #=> {:ok, "world"}

          File.read!("hello")  #=> "world"

          File.read("unknown")  #=> {:error, :enoent}

          File.read!("unknown")  # **(File.Error) could not read file "unknown": no such file or directory
        #+end_src
        When you want to handle error, use ~File.read~; Use ~File.read!~ when you
        don't know how to *handle* the error, or you want your program *crash*
        when error happen.

*** DONE 3. The ~Path~ module
    CLOSED: [2021-01-28 Thu 23:39]
    #+begin_src elixir
      Path.join("foo", "bar")  #=> "foo/bar"
      Path.expand("~/hello")   #=> "/Users/jose/hello"
    #+end_src

*** TODO 4. Processes
*** TODO 5. ~iodata~ and ~chardata~

** DONE 13. alias, require, and import - =TODO= =take notes=
   CLOSED: [2021-01-29 Fri 01:19]
*** 1. alias
*** 2. require
*** 3. import
*** 4. use
*** 5. Understanding Aliases
*** 6. Module nesting
*** 7. Multi alias/import/require/use

** DONE 14. Module attributes - =TODO= =take notes=
   CLOSED: [2021-01-29 Fri 01:19]
   /Module attributes/ in Elixir serve _THREE purposes_:
   - They serve to *annotate the /module/,*
     often with information to be used by
     * the user
       OR
     * the /VM/.

   - They work as *constants*.

   - They work as a *temporary module storage* to be used _during compilation_.

*** TODO 1. As annotations - =TODO= =take notes=
*** TODO 2. As “constants” - =TODO= =take notes=
**** TODO 2.1 Accumulating attributes
*** TODO 3. As temporary storage

** DONE 15. Structs
   CLOSED: [2021-01-29 Fri 01:06]
   /Structs/ are extensions _built on top of_ /maps/ that provide *compile-time
   checks* and *default values*.

*** DONE 1. Defining structs
    CLOSED: [2021-01-29 Fri 00:04]
    To define a /struct/, the ~defstruct~ construct is used:
    #+begin_src elixir
      defmodule User do
        defstruct name: "John", age: 27
      end
    #+end_src

    - The /keyword list/ used with ~defstruct~ defines what /fields/ the /struct/
      will have along with their _DEFAULT values_.

    - /Structs/ _take the *name* of the /module/ they're defined in._
      In the example above, we defined a /struct/ _named_ ~User~.

    - We can now create ~User~ /structs/ by using a syntax similar to the one
      used to create maps:
      #+begin_src elixir
        %User{}              #=> %User{age: 27, name: "John"}
        %User{name: "Jane"}  #=> %User{age: 27, name: "Jane"}
      #+end_src
      * if you have _defined the /struct/ in a *SEPARATE file*,_ you can _compile
        the file *inside* IEx *before* proceeding by running ~c "file.exs"~;_
        + be aware
          you may get an error saying the /struct/ was not yet defined if you
          try the below example in a file directly due to when definitions are
          resolved.

    - /Structs/ provide *compile-time guarantees* that only the /fields/ (and all
      of them) defined through ~defstruct~ will be allowed to exist in a /struct/:
      #+begin_src elixir
        %User{oops: :field}
        # ** (KeyError) key :oops not found in: %User{age: 27, name: "John"}
      #+end_src

*** DONE 2. Accessing and updating structs
    CLOSED: [2021-01-29 Fri 00:14]
    - The same techniques (and the same syntax) of /maps/ *access* and *update*
      the /fields/ apply to /structs/ as well:
      #+begin_src elixir
        john = %User{}  #=> %User{age: 27, name: "John"}
        john.name       #=> "John"

        jane = %{john | name: "Jane"}  #=> %User{age: 27, name: "Jane"}

        %{jane | oops: :field}  # (KeyError) key :oops not found in: %User{age: 27, name: "Jane"}
      #+end_src
      When using the _update syntax (~|~)_, the VM is aware that _no new keys
      will be added to the /struct/,_ allowing _the /maps/ underneath_ to *share
      their structure in memory.*
        In the example above, both ~john~ and ~jane~ _share the same key structure
      in memory._ =TODO= =???=

    - /Structs/ can also be used in /pattern matching/, both for matching on the
      value of specific keys as well as for ensuring that
      the _matching value_ is a /struct/ of *the same type as* the _matched value_.
      #+begin_src elixir
        %User{name: name} = john  #=> %User{age: 27, name: "John"}
        name  #=> "John"

        %User{} = %{}  # ** (MatchError) no match of right hand side value: %{}
      #+end_src

*** DONE 3. Structs are bare maps underneath
    CLOSED: [2021-01-29 Fri 01:00]
    - /Structs/ store a "special" /field/ named ~__struct__~ that holds the name
      of the /struct/.

    - Here the *bare* in /bare maps/ means
      *none* of the /protocols/ implemented for /maps/ are available for
      /structs/.
      * However, since /structs/ are just /maps/, they work with the /funcitons/
        from the ~Map~ /module/:
        #+begin_src elixir
          jane = Map.put(%User{}, :name, "Jane")  #=> %User{age: 27, name: "Jane"}

          Map.merge(jane, %User{name: "John"})  # => %User{age: 27, name: "John"}

          Map.keys(jane)  #=> [:__struct__, :age, :name]
        #+end_src

*** DONE 4. Default values and required keys
    CLOSED: [2021-01-29 Fri 01:05]
    - If you do _NOT_ specify a _default key value_ when defining a /struct/,
      ~nil~ will be assumed:
      #+begin_src elixir
        defmodule Product do
          defstruct [:name]
        end

        %Product{}  #=> %Product{name: nil}
      #+end_src

    - When define /structs/,
      you *must first* specify the /fields/ which _implicitly default_ to ~nil~:
      #+begin_src elixir
        defmodule User do
          defstruct [:email, name: "John", age: 27]
        end

        %User{}  #=> %User{age: 27, email: nil, name: "John"}
      #+end_src
      Doing it in reverse order will raise a *syntax error*.

    - *Enforce* that _CERTAIN_ /keys/ have to be specified
      when creating the /struct/:
      #+begin_src elixir
        defmodule Car do
          @enforce_keys [:make]
          defstruct [:model, :make]
        end

        %Car{}
        # ** (ArgumentError) the following keys must also be given when building struct Car: [:make]
        #     expanding struct: Car.__struct__/1
      #+end_src

** TODO 16. Protocols
*** 1. Example
*** 2. Protocols and structs
*** 3. Implementing ~Any~
**** 3.1. Deriving
**** 3.2. Fallback to ~Any~

*** 4. Built-in protocols

** DONE 17. Comprehensions
   CLOSED: [2021-01-29 Fri 02:11]
   In Elixir, it is common to *loop over* an /Enumerable/, often *filtering out*
   some results and *mapping* values into another /list/.
     /Comprehensions/ are *syntactic sugar* for constructs:
   they group those common tasks into the ~for~ /special form/.
   #+begin_src elixir
     for n <- [1, 2, 3, 4], do: n * n
     #=> [1, 4, 9, 16]
   #+end_src

   - A /comprehension/ is made of _THREE parts_:
     1. /generators/
     2. /filters/
     3. /target collectables/ =from Jian= I add this "target"

*** DONE 1. Generators and filters
    CLOSED: [2021-01-29 Fri 02:02]
    /Generators/ are the parts in a /comprehension/: ~pattern <- enumerable~.

    - In the above example, it is ~n <- [1, 2, 3, 4]~.
      Other /enumerables/ also work, for example, we can use a /range/ ~1..4~ to
      do the same thing.

    - Filter in two ways:
      * Values in the _rhs_ /enumerable/ will be *filtered out*
        if it *can't match* the _lhs_ /pattern/.
        #+begin_src elixir
          values = [good: 1, good: 2, bad: 3, good: 4]

          for {:good, n} <- values, do: n * n
          #=> [1, 4, 16]
        #+end_src

      * User a /filter/.
        #+begin_src elixir
          multiple_of_3? = fn(n) -> rem(n, 3) == 0 end

          for n <- 0..5, multiple_of_3?.(n), do: n * n
          #=> [0, 9]
        #+end_src
        The input values of the RHS /enumerable/, which can make it the /filter
        function/ return ~false~ or ~nil~ will be *filtered out*.

    - /Comprehensions/ generally provide a much *more concise* representation than
      using the equivalent _functions from the ~Enum~ and ~Stream~ /modules/._

    - /Comprehensions/ accept *multiple* /generators/ and /filters/.
      #+begin_src elixir
        dirs = ['/home/mikey', '/home/james']

        for dir  <- dirs,
          file <- File.ls!(dir),
          path = Path.join(dir, file),
          File.regular?(path) do
            File.stat!(path).size
        end
      #+end_src

*** DONE 2. Bitstring generators
    CLOSED: [2021-01-29 Fri 02:04]
    #+begin_src elixir
      pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>

      for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b}
      #=> [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]
    #+end_src

*** DONE 3. The ~:into~ option
    CLOSED: [2021-01-29 Fri 02:10]
    /Comprehensions/ by default, when without ~:into~, return /lists/.

    - Use ~:into~ can change their result types, which must be a implementation
      of the ~Collectable~ /protocol/.

    - For example,
      #+begin_src elixir
        for <<c <- " hello world ">>, c != ?\s, into: "", do: <<c>>
        #=> "helloworld"
      #+end_src

    - A _COMMON use case_ of ~:into~ can be _transforming values in a /map/:_
      #+begin_src elixir
        for {key, val} <- %{"a" => 1, "b" => 2}, into: %{}, do: {key, val * val}
        #=> %{"a" => 1, "b" => 4}
      #+end_src

    - Example:
      Echo your input string with its upper-case representation in terminal
      #+begin_src elixir
        stream = IO.stream(:stdio, :line)

        for line <- stream, into: stream do
          String.upcase(line) <> "\n"
        end
      #+end_src
      Since this example code intercept all your input, you have to type twice
      ~Ctrl+C~ to quit IEx.

*** DONE 4. Other options - =TODO= =READ=
    CLOSED: [2021-01-29 Fri 02:03]
    /Comprehensions/ support other options, such as ~:reduce~ and ~:uniq~.
    Please [[https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1][check the complete reference]] for more information.

** TODO 18. Sigils
*** 1. Regular expressions
*** 2. Strings, char lists, and word lists sigils
**** 2.1 Strings
**** 2.2 Char lists
**** 2.3 Word lists

*** 3. Interpolation and escaping in string sigils
*** 4. Calendar sigils
**** 4.1. Date
**** 4.2. Time
**** 4.3. NaiveDateTime
**** 4.4. UTC DateTime

*** 5. Custom sigils

** TODO 19. try, catch, and rescue
*** 1. Errors
**** 1.1 Fail fast / Let it crash
**** 1.2 Reraise

*** 2. Throws
*** 3. Exits
*** 4. After
*** 5. Else
*** 6. Variables scope

** TODO 20. Optional syntax sheet
** TODO 21. Erlang libraries
*** 1. The binary module
*** 2. Formatted text output
*** 3. The crypto module
*** 4. The digraph module
*** 5. Erlang Term Storage
*** 6. The math module
*** 7. The queue module
*** 8. The rand module
*** 9. The zip and zlib modules

** TODO 22. Debugging
*** 1. IO.inspect/2
*** 2. ~dbg~
*** 3. Breakpoints
*** 4. Debugger
*** 5. Observer
*** 6. Other tools and community

** TODO 23. Typespecs and behaviours
*** 1. Types and specs
**** 1.1 Function specifications
**** 1.2 Defining custom types
**** 1.3 Static code analysis

*** 2. Behaviours
**** 2.1 Defining behaviours
**** 2.2 Adopting behaviours
**** 2.3 Dynamic dispatch

** TODO 24. Where to go next
*** 1. Build your first Elixir project
*** 2. Meta-programming
*** 3. Community and other resources
*** 4. A byte of Erlang

* TODO Mix and OTP
** TODO 1. Introduction to Mix
   - =TODO= note

*** TODO 1 Our first project
*** TODO 2 Project compilation
*** TODO 3 Running tests
*** DONE 4 Automatic code formatting
    CLOSED: [2021-01-27 Wed 01:45]
    - One of the files generated by ~mix new~ is the =.formatter.exs=.
      * Elixir ships with a *code formatter* that is capable of automatically
        formatting our codebase according to a consistent style.
          The formatter is triggered with the ~mix format~ task. The generated
        =.formatter.exs= file configures which files should be formatted when
        ~mix format~ runs.

    - For companies and teams, =IMPORTANT=
      we recommend developers to run
      ~mix format --check-formatted~ on their _continuous integration servers_,
      ensuring all current and future code follows the standard.

    - You can learn more about the code formatter by checking
      [[https://hexdocs.pm/mix/Mix.Tasks.Format.html][the format task documentation]] or by reading [[https://elixir-lang.org/blog/2018/01/17/elixir-v1-6-0-released/][the release announcement for
      Elixir v1.6]], the first version to include the formatter.

*** DONE 5 Environments - =RE-READ=
    CLOSED: [2021-01-27 Wed 02:23]
    Mix provides the concept of *“environments”*.

    - They allow a developer to *customize* _compilation_ and _other options for
      specific scenarios_.
      By default, Mix understands _THREE_ /environments/:
      * ~:dev~ - the one in which Mix tasks (like ~compile~) run by default
      * ~:test~ - used by ~mix test~
      * ~:prod~ - the one you will use to run your project in production

    - The /environment/ applies only to the _current project_.

    - As we will see in future chapters, ANY /dependency/ you add to your project
      will _BY DEFAULT_ run in the ~:prod~ /environment/.

    - Customization per /environment/ can be done by accessing [[https://hexdocs.pm/mix/Mix.html#env/0][the ~Mix.env~ function]]
      in your =mix.exs= file, which _returns_ the *current environment* as an /atom/.
      That's what we have used in the ~:start_permanent~ options
      #+begin_src elixir
        def project do
          [
            ...,
            start_permanent: Mix.env == :prod,
            ...
          ]
        end
      #+end_src
      - When true, the ~:start_permanent~ option starts your application in
        /permanent mode/, which means the /Erlang VM/ will crash if your
        application's /supervision tree/ _shuts down_.
        * Notice
          we don't want this behaviour in *dev* and *test* because it is useful to
          _keep the VM instance running in those /environments/ for TROUBLESHOOTING
          purposes._

    - Mix will *default to* the ~:dev~ /environment/,
      EXCEPT for the ~test~ /task/ that will *default to* the ~:test~ /environment/.
      The environment can be changed via the ~MIX_ENV~ environment variable:
      #+begin_src shell
        MIX_ENV=prod mix compile
      #+end_src
      Or on Windows:
      #+begin_src shell
        set "MIX_EN=prod" && mix compile
      #+end_src
      =TODO= TRY THESE COMMANDS

    - Mix is a /build tool/ and, as such,
      it is *not expected* to be available in production.
      =IMPORTANT=
        Therefore, it is recommended to access ~Mix.env~ only in _configuration
      files_ and inside =mix.exs=, never in your application code (~lib~).

*** DONE 6 Exploring
    CLOSED: [2021-01-27 Wed 01:33]
    - A [[https://hexdocs.pm/mix/][general overview is available on the Mix documentation]].
      Read [[https://github.com/elixir-lang/elixir/tree/master/lib/mix][the Mix source code here]].

    - Keep in mind that you can always invoke the help task to list all available tasks:
      #+begin_src shell
        mix help
      #+end_src
      * You can get further information about a _particular task_ by invoking
        ~mix help TASK~.

** TODO 2. Agent
*** 1. The trouble with state
*** 2. Agents
*** 3. Test setup with ExUnit callbacks
*** 4. Other agent actions
*** 5. Client/Server in agents

** 3. GenServer
*** 1. GenServer callbacks
*** 2. The Client API
*** 3. Testing a GenServer
*** 4. The need for monitoring
*** 5. ~call~, ~cast~ or ~info~?
*** 6. Monitors or links?

** 4. Supervisor and Application
*** 1 Our first supervisor
*** 2 Naming processes
*** 3 Understanding applications
**** 3.1 Starting applications

*** 4 The application callback
*** 5 Projects or applications?
*** 6 Next steps

** 5. Dynamic supervisors
*** 1. The bucket supervisor
*** 2. Supervision trees
*** 3. Shared state in tests
*** 4. Observer

** 6. ETS
*** ETS as a cache
*** Race conditions?

** 7. Dependencies and umbrella projects
*** 1. External dependencies
*** 2. Internal dependencies
*** 3. Umbrella projects
*** 4. Dependencies within an umbrella project
*** 5. Don’t drink the kool aid
*** 6. Summing up

** 8. Task and ~gen_tcp~
*** 1. Echo server
*** 2. Tasks
*** 3. Task supervisor

** 9. Doctests, patterns and with
*** 1. Doctests
*** 2. with
*** 3. Running commands

** 10. Distributed tasks and tags
*** 1. Our first distributed code
*** 2. async/await
*** 3. Distributed tasks
*** 4. Routing layer
*** 5. Test filters and tags
*** 6. Wiring it all up
*** 7. Summing up

** 11. Configuration and releases
*** 1. Application environment
*** 2. Configuration
*** 3. Releases
*** 4. Why releases?
*** 5. Assembling multiple releases
*** 6. Configuring releases
**** 6.1 Operating System environment configuration
**** 6.2 VM args

*** 7. Summing up

* TODO Meta-programming in Elixir
** 1. Quote and unquote
*** 1. Quoting
*** 2. Unquoting
*** 3. Escaping

** 2. Macros
*** 1. Foreword
*** 2. Our first macro
*** 3. Macro hygiene
*** 4. The environment
*** 5. Private macros
*** 6. Write macros responsibly

** 3. Domain-specific languages
*** 1. Foreword
*** 2. Building our own test case
*** 3. The ~test~ macro
*** 4. Storing information with attributes
