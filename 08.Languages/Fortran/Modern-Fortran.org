#+TITLE: Modern Fortran
#+SUBTITLE: Building efficient parallel applications
#+AUTHOR: Milan Curcic, Foreword by Damian Rouson
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

** foreword - xi
** preface - xiii
** acknowledgments - xiv
** about this book - xvi
** about the author - xxii
** about the cover illustration - xxiii
* DONE PART 1 GETTING STARTED WITH MODERN FORTRAN - 1
CLOSED: [2024-09-05 Thu 20:56]
In this part, you'll get a taste of Fortran and a gentle introduction into the
language.

- _Chapter 1_
  * the design and features of Fortran,
  * the kinds of problems for which Fortran is suitable.
  * WHY /parallel programming/ is important and WHEN you should use it.

- _Chapter 2_
  we'll build a minimal working example of the tsunami simulator that we'll be
  working on throughout the book.
  * This example will give you a taste of the Fortran essentials:
    + /variable declaration/,
    + /data types/,
    + /arrays/,
    + /loops/, and
    + /branches/.

** DONE 1 Introducing Fortrans - 3
CLOSED: [2024-09-05 Thu 20:53]
- This chapter covers
  * What is Fortran and why learn it?
  * Fortran's strengths and weaknesses
  * Thinking in parallel
  * Building a parallel simulation app from scratch

- =TODO=
  Note

*** DONE 1.1 What is Fortran? - 4
CLOSED: [2024-08-31 Sat 15:28]
- Fortran :: a general-purpose, parallel programming language that excels in
  scientific and engineering applications.
  * Originally called /FORTRAN (FORmula TRANslation)/ in 1957, it has evolved
    over decades to become a robust, mature, and high perfomanceoriented
    programming language.

- Today, Fortran keeps churning under the hood of many systems that we take for
  granted:
  * Numerical weather, ocean, and surf prediction
  * Climate science and prediction
  * Computational fluid dynamics software used in mechanical and civil engineering
  * Aerodynamics solvers for designing cars, airplanes, and spacecraft
  * Fast linear algebra libraries used by machine learning frameworks
  * Benchmarking the fastest supercomputers in the world (https://top500.org)

- /Supercomputers/ are _SIMILAR TO_ /modern server farms/ hosted by Google or
  Amazon, *EXCEPT* that the /network infrastructure/ in /supercomputers/ is
  designed to
  _MAXIMIZE_ /bandwidth/ and
  _MINIMIZE_ /latency/ between the servers themselves,
  rather than between them and the outside world.
  * *AS A RESULT*,
    the CPUs in a supercomputer act like one giant processor with
    distributed-memory access that's _NEARLY AS FAST AS local memory access_.
    To this day, Fortran remains the dominant language used for such
    massive-scale parallel computations.

*** DONE 1.2 Fortran features - 6
CLOSED: [2024-08-31 Sat 15:28]
- In the context of programming languages, Fortran is all of the following:
  * *Compiled*
  * *Statically typed*
    + manifest typing :: explicitly declare the variables before their use.
    + strong typing :: the compiler will raise an error if a procedure is invoked
      with an argument of the wrong type.
      - While /static typing/ helps the compiler to generate efficient programs,
      - /manifest and strong typing/ enforce good programming hygiene and make
        Fortran a safe language.

  * *Multiparadigm*
    + imperative
    + procedural
    + object-oriented
    + functional

  * *Parallel* =TODO: REREAD=
    + Parallel processes can be running
      on the same processing core (threadbased parallelism),
      on different cores that share RAM (shared-memory parallelism), or
      distributed across the network (distributed-memory parallelism).

    + Computers working together on the same parallel program can be
      - physically located in the same cabinet,
      - across the room from each other, or
      - across the world.

    + Fortran's main parallel structure is a ~coarray~, which allows you to
      express parallel algorithms and remote data exchange
      *WITHOUT* any external libraries.

      - /Coarrays/ allow you to access remote memory just like you'd access
        elements of an array, as shown in the following listing.

  * *Mature*
    + 60+ years of evolution

    + Fortran development and implementation in compilers have been heavily
      supported by the industry: IBM, Cray, Intel, NAG, NVIDIA, and others.
      - There has also been significant open source development, most notably
        free compilers:
        * gfortran
        * Flang
        * LFortran

      - A vast set of robust and mature libraries that are computational backbone
        of many applications.

  * *Easy to learn*
    However, like every other programming languages or skill in general, it is
    difficult to master.

*** DONE 1.3 Why learn Fortran? - 8
CLOSED: [2024-08-31 Sat 15:28]
- *High-performance computing*
  /High-performance computing (HPC)/ is the practice of combining computer
  resources to solve computational problems that would otherwise not be possible
  with a single desktop computer.
  * HPC systems typically aggregate hundreds or thousands of servers and connect
    them with fast networks. Most HPC systems today run some flavor of Linux OS.

- Despite being a decades-old technology, Fortran has several attractive features
  that make it indispensable, even compared to more recent languages:
  * Array-oriented
    + For example, in Fortran, multiple two vectors to get a result matrix can be
      represented in ~c = a * b~.

      This is _not only_ more expressive and readable code,
      it also hints to the compiler that it can choose the optimal way to
      perform the operation.

  * The only parallel language developed by a standards committee (ISO)
  * Mature libraries for science, engineering, and math
  * Growing general-purpose library ecosystem
  * Unmatched performance
    =From Jian=
    As the compiler theory and engineer develop, this is NOT ALWAYS TRUE!

- In summary,
  learn Fortran
  _IF_ you need to implement efficient and parallel numerical operations on large
  multidimensional arrays.

*** DONE 1.4 Advantages and disadvantages - 10
CLOSED: [2024-08-31 Sat 15:19]
Many Fortran features give it both an advantage and a disadvantage. For example,
it's all of the following:
- A domain-specific language
  Despite being technically a general-purpose language, Fortran is very much a
  domain-specific language.
  * It is not a good idea to write a web browser or low-level device drivers
    with Fortran.

- A niche language
  Less tutorials or blogs.

- A statically and strongly typed language
  =From Jian=
  I'm not agree with this point in book.
  *Statically and strongly typed* is always a advantage. When this looks like a
  disadvantage, usually it is because of the outdated type system desgin or
  language design, which is the exact reason here.

**** 1.4.1 Side-by-side comparison with Python - 10
- =IMPORTANT=
  Table 1.1 Comparison between Fortran and Python (CPython specifically)

*** DONE 1.5 Parallel Fortran, illustrated - 12
CLOSED: [2024-08-31 Sat 15:56]
_Summer ends on old Ralph’s farm._
*** DONE 1.6 What will you learn in this book? - 13
CLOSED: [2024-08-31 Sat 16:09]
This book will teach you how to write modern, efficient, and parallel Fortran
programs.

- Working through each chapter, we’ll build from scratch a fully functional,
  parallel, fluid dynamics solver with a specific application to tsunami
  prediction.

- If you work through the book, you'll come out with three distinct skill sets:
  * Be fluent with most modern Fortran features.
    This is a unique and desired skill in a robust, multibillion-dollar market
    that is HPC.

  * Be able to recognize problems that are parallel in nature.

  * Get a grasp on good software design, writing reusable code, and sharing
    your project with the online community.

- With parallel thinking, you'll come out with two critical advantages:
  1. You'll be able to solve problems in less time.
  2. You'll be able to solve problems that can’t fit onto a single computer.

*** TODO 1.7 Think parallel! - 14 - =RE-READ=
- All parallel problems fall into two categories:
  * Embarrassingly parallel
  * Nonembarrassingly parallel

- Q :: Why is it called embarrassingly parallel?
- A :: It refers to overabundance, as in an embarrassment of riches.
       It's the kind of problem that you want to have.

  * The term is attributed to Cleve Moler, inventor of MATLAB and one of the
    authors of *EISPACK* and *LINPACK*, Fortran libraries for numerical computing.
    _LINPACK is still used to benchmark the fastest supercomputers in the world._

- Parallel Fortran programming in the past has been done either
  * using the /OpenMP/ directives for shared-memory computers only, or
  * with the /Message Passing Interface (MPI)/ for both shared and distributed
    memory computers.

- Figure 1.5
  * Shared memory (SM) systems
  * distributed-memory (DM) systems

- The main advantage of /SM systems/ is very *low latency* in communication
  between processes.
  _HOWEVER_, there's a limit to the number of processing cores you can have in an
  /SM system/. Since /OpenMP/ was designed for SM parallel programming exclusively,
  *we'll focus on /MPI/ for our specific example.*

- OpenMP versus MPI
  =TODO: NOTE=

**** 1.7.1 Copying an array from one processor to another - 17
=TODO: NOTE=
- *MPI: THE TRADITIONAL WAY TO DO PARALLEL PROGRAMMING*
- *ENTER FORTRAN COARRAYS*
- *A partitioned global address space language*
  =TODO: REREAD=

*** DONE 1.8 Running example: A parallel tsunami simulator - 22
CLOSED: [2024-09-05 Thu 20:49]
Lessons in this book are thus framed around developing your own, minimal and yet
complete, _tsunami_ simulator.

**** DONE 1.8.1 Why tsunami simulator? - 22
CLOSED: [2024-09-05 Thu 19:20]
- A _tsunami_ is a sequence of long water waves that are triggered by a
  displacement in a large body of water. This typically occurs because of
  earthquakes, underwater volcanoes, or landslides. Once generated, a tsunami
  propagates radially outward across the ocean surface. It grows in height and
  steepness as it enters shallow waters.

- A _tsunami_ simulator is a good running example for this book because tsunamis
  are the following:
  * Fun:
    Speaking strictly as a scientist here!
    A tsunami is a process that's fun to watch and play with in a numerical
    sandbox.

  * Dangerous:
    Tsunamis are a great threat to low-lying and heavily populated coastal
    areas. There's a need to better understand and predict them.

  * Simple math:
    They can be simulated using a minimal set of equations -- /shallow water
    equations (SWEs)/. This will help us not get bogged down by the math and
    focus on implementation instead.

  * Parallelizable:
    They involve a physical process that’s suitable for _TEACHING_ /parallel
    programming/, especially considering that it's a /nonembarrassingly parallel
    problem/.
    + =IMPORTANT=
      To make it work, we'll carefully design data copy patterns between images.

- To simulate tsunamis, we’ll write a SOLVER for the shallow water system of
  equations.

**** DONE 1.8.2 Shallow water equations - 23
CLOSED: [2024-09-05 Thu 20:19]
- /Shallow water equations (SWEs)/ are a simple system of equations derived from
  /Navier-Stokes equations/.
  * They are also known as the /Saint-Venant equations/, after the French engineer
    and mathematician A. J. C. Barre de Saint-Venant, who derived them in
    pursuit of his interest in _hydraulic engineering and open-channel flows_.

- /SWEs/ are powerful because they can REPRODUCE many observed motions in the
  atmosphere and the ocean:
  * Large-scale weather, such as cyclones and anticyclones
  * Western boundary currents, such as the Gulf Stream in the Atlantic and the
    Kuroshio in the Pacific
  * Long gravity waves, such as tsunamis and tidal bores
  * Watershed from rainfall and snow melt over land
  * Wind-generated (surf) waves
  * Ripples in a pond

- _Equations are listed in Figure 1.7, page 23_.

- Q :: What's the physical interpretation of this system?

- A ::
  * _The top equation_ states that
    where there's slope along the water surface, water will accelerate and move
    toward a region of lower water level _BECAUSE_ of the /pressure gradient/.

    + The advection term is nonlinear and causes chaotic behavior in fluids
      (turbulence).

  * _The bottom equation_ states that
    where there's convergence (water coming together), the water level will
    increase. This is because water has to go somewhere, and it's why we also
    call it /conservation of mass/. Similarly, if water is diverging, its level
    will decrease in response.

- *Comfortable with math?*
  appendix B

**** DONE 1.8.3 What we want our app to do - 24
CLOSED: [2024-09-05 Thu 20:49]
- Let's narrow down on the specification for our _tsunami simulator_:
  * _Parallel_:
    The model will scale to hundreds of processors with nothing but pure Fortran
    code.

    + This is
      _not only_ important for speeding up the program and reducing compute time,
      _but also_ for enabling very large simulations that otherwise wouldn't fit
      into the memory of a single computer.

    With most modern laptops having at least four cores, you should be able to
    enjoy the fruits of your (parallel programming) labor.

  * _Extensible_:
    Physics terms can be easily formulated and added to the solver.

    This is important for the general usability of the model.
    =from Jian= Abstraction!

    =RE-READ=
    + If we can design our computational kernel in the form of reusable classes
      and functions, we can easily add new physics terms as functional, parallel
      operators, following the approach by Damian Rouson (http://mng.bz/vxPq).
      This way, the technical implementation is abstracted inside these
      functions, and on a high level we'd program our equations much like we'd
      write them on a blackboard.

  * _Software library_:
    This will provide a *REUSABLE* set of /classes/ and /functions/ that can be
    used to build other parallel models.

  * _Documented_

  * _Discoverable online_:
    Writing a program just for yourself is great for learning and discovery.

    + The tsunami simulator and other projects developed in this book are all
      online at https://github.com/modern-fortran.

- By working through this book chapter by chapter, you'll gain the experience of
  developing a fully featured parallel app from scratch.

- =TODO: NEXT=
  We'll start the next chapter by _setting up the development environment_ so
  that you can compile and run the minimal working version of the tsunami
  simulator.

- *Visualizing tsunami output*
   I provide Python scripts in the GitHub repository of the project so you can
   visualize the output yourself.

*** DONE 1.9 Further reading - 25
CLOSED: [2024-09-05 Thu 20:52]
- Fortran website: https://fortran-lang.org
- The history of Fortran on Wikipedia: https://en.wikipedia.org/wiki/Fortran
- Partitioned global address space: http://mng.bz/4A6g
- Companion blog to this book: https://medium.com/modern-fortran

**** DONE Summary
CLOSED: [2024-09-05 Thu 20:52]
- Fortran is the _OLDEST high-level_ programming language still in use today.

- It's the _DOMINANT_ language used for many applications in science and engineering.

- Fortran is *NOT suitable* for programming video games or web browsers
  _BUT_ excels at numerical, parallel computation over large multidimensional
  arrays.

- It's the _ONLY_ (=from Jian= ???) *standardized natively parallel* programming
  language.

- /Coarrays/ provide a cleaner and more expressive syntax for parallel data exchange
  compared to traditional /Message Passing Interface (MPI)/ programming.
  =TODO: Learn more!!!=

- _Fortran compilers and libraries are mature and battle-tested._

** DONE 2 Getting started: Minimal working app - 26
CLOSED: [2024-09-05 Thu 20:54]
- This chapter covers
  * Compiling and running your first Fortran program
  * Data types, declaration, arithmetic, and control flow
  * Building and running your first simulation app

- In this chapter, we'll implement the minimal working version of _the tsunami
  simulator_.

- For simplicity, we'll start by simulating the movement of water in space due to
  background flow, without changing its shape.

  * This problem is sufficiently complex to introduce basic elements of Fortran:
    + numeric data types,
    + declaration,
    + arithmetic expressions and assignment, and
    + control flow.

- Once we successfully simulate the movement of an object in this chapter,
  we'll refactor the code to add other physics processes in chapters 3 and 4,
  which will allow the simulated water to flow more realistically.

- We'll
  1. start off by compiling, linking, and running your first Fortran program.

  2. Then I'll introduce the physical problem that we want to solve and show you
     how to express it in the form of a computer program.

  3. We'll then dive into the essential elements of Fortran:
     - data types,
     - declaration,
     - arithmetic, and
     - control flow.

- At the end of the chapter, you'll have the working knowledge to write basic,
  yet useful, Fortran programs.

*** 2.1 Compiling and running your first program - 27
- Let's start by creating, compiling, and running your first Fortran program.
  * Assumption:
    The GNU Fortran compiler (_gfortran_) has been installed.

- Two steps:
  1. Compiling
  2. Linking

- If we used ~-c~ flag, _gfortran_ won't link automatically.
  ~gfortran hello.f90 -o hello~
  IS EQUIVALENT TO
  ~gfortran -c hello.f90~ and then ~gfortran hello.o -o hello~
  * Here ~-c~ means _compile only, do not link._
    =IMPORTANT=
    This procedure is *NECESSARY*
    WHENEVER we need to compile MULTIPLE source files BEFORE linking them into a
    SINGLE program.

*** 2.2 Simulating the motion of an object - 28 - =TODO=
**** What should our app do? - 29
**** What is advection? - 30

*** 2.3 Implementing the minimal working app - 31
Having set the problem to solve, we’ll soon be able to dive into Fortran coding.
But first we’ll go over the implementation strategy (you should always have one)
in the next subsection. Then, we’ll go over the core elements of the language
and apply them to implement the first version of the tsunami simulator.

**** TODO 2.3.1 Implementation strategy - 32
**** DONE 2.3.2 Defining the main program - 33
CLOSED: [2024-09-05 Thu 15:39]
- /The main program/ is the fundamental program unit in Fortran.
  It allows you to assign a name to your program and defines the program scope.
  #+NAME: Listing 2.3 Defining the program unit and scope
  #+begin_src fortran
    program tsunami
    end program tsunami
  #+end_src

- *What other program units are there?*
  Fortran program units:
  * Main program ::
    Top-level unit that can be invoked only from the operating system.

  * Function ::
    An executable subprogram that is invoked from expressions and always returns
    a single result.

  * Subroutine ::
    An executable subprogram that can modify multiple arguments in-place but
    can't be used in expressions.

  * Module ::
    A nonexecutable collection of
    + /variable/,
    + /function/, and
    + /subroutine definitions/.

  * Submodule ::
    Extends an existing module and is used for defining /variable/ and /procedure/
    definitions that _only that /module/ can access;_ useful for more complex apps
    and libraries.

- For now, we can work with only the main program.
  =TODO: NEXT=
  We'll dive deep into functions and subroutines in chapter 3, and modules in
  chapter 4.

- ~program~ is NOT mandatory.

**** DONE 2.3.3 Declaring and initializing variables - 34
CLOSED: [2024-09-05 Thu 15:24]
#+begin_quote
Explicit is better than implicit
-- Tim Peters
#+end_quote

- The first part of any program unit is the /declaration section/.
  Fortran employs a ~static~, ~manifest~, ~strong~ typing system:
  * _Static_:
    Every variable has a data type at compile time, and that type remains the
    same throughout the life of the program.

  * _Manifest_:
    All variables must be explicitly declared in the declaration section before
    their use. An exception and caveat is implicit typing, described in the
    sidebar.

  * _Strong_:
    Variables must be type-compatible when they're passed between a program and
    functions or subroutines.

- *Implicit typing*
  - Fortran has a historical feature called /implicit typing/.
    * implicit typing :: allows variable types to be inferred by the compiler
      based on the first letter of the variable.

  - /Implicit typing/ comes from the early days of Fortran (ahem, FORTRAN),
    _BEFORE_ /type declarations/ were introduced to the language.

    * Any variable that began with I, J, K, L, M, or N was an integer, and it was
      a real (floating point) otherwise.

  - Fortran evolution:
    * _FORTRAN 66_ introduced /data types/, and

    * _FORTRAN 77_ introduced the ~IMPLICIT~ statement to *override* the _DEFAULT
      implicit typing rules._

    * It wasn't until _Fortran 90_ that the language allowed completely *DISABLING*
      the implicit typing behavior by using the statement ~implicit none~ before
      the declaration.

  - The ~implicit none~ statement will instruct the compiler to report an error if
    you try to use a variable that hasn't been declared. Always use ~implicit none~!

  - =IMPORTANT=
    =from Jian=
    This reveals that
    * In the early days, language may not have /type declaration/, even if the
      language is a static typed language.

    * Language designer didn't know how to distinguish /variable declaration/ and
      /variable usage/.
      + Languages like Python makes the same mistake, and this is why it later
        introduced ~global~ and ~local~.

- /Intrinsic types/ are defined by the language standard and are immediately available
  for use. Fortran has *FIVE* /Intrinsic types/:
  * the logical type
  * the character type for text data.
  * *THREE* /numeric types/:
    + ~integer~: Whole numbers, such as ~42~ or ~-17~
    + ~real~: Floating point numbers, such as ~3.141~ or ~1.82e4~
    + ~complex~: A pair of numbers: one for the real part and one for the imaginary
                 part of the complex number; for example, ~(0.12, -1.33)~

- /Numeric types/ also come in different /kinds/.
  * /Fortran kind/ :: refers to the memory size that's reserved for a variable.
    + It determines the permissible range of values and, in the case of real and
      complex numbers, the precision.

      - In general,
        * higher integer kinds allow a _wider range_ of values.
        * Higher real and complex kinds yield a higher allowed range and a higher
          _precision_ of values.

  * =TODO= You'll learn more about numeric type kinds in chapter 4.

- Fortran /derived types/, like struct in C and class in Python.

**** DONE 2.3.4 Numeric data types - 35
CLOSED: [2024-09-05 Thu 16:01]
Fortran provides THREE /numerical data types/ out of the box:
- ~integer~,
- ~real~, and
- ~complex~.

***** INTEGER NUMBERS
- Declare one or more integers:
  #+begin_src fortran
    integer :: i, n
  #+end_src

- General rules for /integers/:
  * Integers are ALWAYS *signed*.

  * They have a limited range that's determined by their /type kind/.

  * Exceeding the permissible range of a variable results in an /overflow/.
    In that event, the value of the variable will *wrap around* its range limits.

  * The /default integer size/ in memory
    is *NOT* defined by the Fortran standard and
    is system dependent.

    However, on most systems, the /default integer size/ is *4 bytes*.

***** REAL NUMBERS
- *Be mindful about the decimal point*!
  ~42~ is an ~integer~, but ~42.~ is a ~real~.

- Declare real numbers:
  #+begin_src fortran
    real :: x
  #+end_src

***** COMPLEX NUMBERS
A /complex number/ is simply a pair of ~real~ numbers, one for the real
component and one for the imaginary component.

- Declare a complex variable:
  #+begin_src fortran
    complex :: c = (1.1, 0.8)
  #+end_src

**** DONE 2.3.5 Declaring the data to use in our app - 37
CLOSED: [2024-09-05 Thu 16:25]
***** DECLARING VARIABLES
***** DECLARING CONSTANTS
#+NAME: Listing 2.5 Declaring and initializing constants
#+begin_src fortran
  integer, parameter :: grid_size = 100
  integer, parameter :: num_time_steps = 100
  real, parameter :: dt = 1, dx = 1, c = 1
#+end_src
Using the ~parameter~ attribute REQUIRES us to _initialize the variable on the
same line._

***** DECLARING ARRAYS
- Several useful Fortran array properties:
  * Contiguous in memory
  * Multidimensional, allow up to 15 dimensions
  * Static or dynamic
  * Whole-array arithmetic
  * Column-major indexing
    _The leftmost index varies fastest_! This is like MATLAB or R and unlike C
    or Python.
    + For example, ~a(1, 1)~, ~a(2, 1)~, ~a(3, 1)~, and so on.

- ~real, dimension(10, 5, 2) :: h~

- *Shorthand syntax for declaring arrays*
  Omit the keyword ~dimension~:
  #+begin_src fortran
    real :: h(10, 5, 2)
  #+end_src

- *How about dynamic arrays?*
  =TODO: Next= chapter 5.

**** DONE 2.3.6 Branching with an if block - 40
CLOSED: [2024-09-05 Thu 16:34]
- Different forms:
  * single-line: ~if (condition) ...~
  * Full form:
    #+begin_src fortran
      if (condition) then
          ...
      else if (other_condition) then
          ...
      else
          ...
      end if
    #+end_src

**** DONE 2.3.7 Using a do loop to iterate - 42
CLOSED: [2024-09-05 Thu 17:02]
- Loops:
  * infinite loop:
    #+begin_src fortran
      do
        ...
      end do
    #+end_src

  * loop in a range by step
    #+begin_src fortran
      do n = start, end
        ...
      end do


      do n = start, end, increment
        ...
      end do
    #+end_src

  * loop can be named, nested loop can use the loop name in end marker:
    #+begin_src fortran
      outer_loop: do j = 1, jm
        inner_loop: do i = 1, im
          print *, 'i, j = ', i, j
        end do inner_loop
      end do outer_loop
    #+end_src

- The general syntax of ~do~ loop:
  Both ~expr1~ and ~expr3~ are inclusive.
  #+begin_src fortran
    [name: ] do [var = expr1, expr2[, expr3]]
      ...
    end do [name]
  #+end_src

**** DONE 2.3.8 Setting the initial water height values - 44
CLOSED: [2024-09-05 Thu 18:21]
- *Can our array assignment be done in parallel?*
  In the previous example, the array assignment is a /embarrassingly parallel
  problem/. Fortran offers a special ~do~ loop for this purpose, called
  ~do concurrent~. It guarantees to the compiler that there's no dependency
  between individual iterations and that they can be executed out of order, as
  we'll see in the next subsection. =TODO: NEXT=

**** DONE 2.3.9 Predicting the movement of the object - 45
CLOSED: [2024-09-05 Thu 18:56]
- *What ~do concurrent~ is and what it isn't*
  - Q :: What does ~do concurrent~ do exactly?
  - A :: It's a PROMISE from programmer to compiler that
         _the code inside the loop can be safely vectorized or parallelized._
    * In practice, a good compiler would do this using
      + a /system threading library/
        or
      + /SIMD machine instructions/ if available.

  - ~do concurrent~ *by no means guarantees* that the loop will run in parallel!
    In cases such as short loops with simple computations, the compiler may
    determine that serial execution would be more efficient.

    + We'll study explicit,
      =TODO: NEXT= distributed-memory parallelism with ~coarray~'s in chapter 7.
      - For now,
        we use ~do concurrent~ as a note for both ourselves and the compiler
        that some regions of the code are safe to parallelize.

**** DONE 2.3.10 Printing results to the screen - 47
CLOSED: [2024-09-05 Thu 19:01]
- For now, ~print *~ is all we need.
  + Example: ~print *, n, h~

- =TODO: NEXT= We'll explore Fortran input/output in more detail in chapter 6.

**** TODO 2.3.11 Putting it all together - 47
***** THE RESULT
***** COMPLETE CODE

*** 2.4 Going forward with the tsunami simulator - 51
- *A note on abstractions*

*** 2.5 Answer key - 52
**** Exercise: Cold front propagation - 52

*** 2.6 New Fortran elements, at a glance - 52
*** DONE 2.7 Further reading - 52
CLOSED: [2024-09-05 Thu 20:54]

* TODO PART 2 CORE ELEMENTS OF FORTRAN - 55
- This part covers the _core elements_ of Fortran:
  * procedures,
  * modules,
  * arrays, and
  * I/O.

- Chapter 3,
  * /functions/
  * /subroutines/
  collectively called /procedures/.

- Chapter 4,
  /module/ and
  how to use them to _organize_ your data and procedures in reusable and
  portable components.

- Chapter 5
  covers arrays, the fundamental Fortran data structure.
  * You'll learn
    + _HOW TO_ declare, initialize, and use arrays, as well as
    + _HOW TO_ leverage whole-array arithmetic to greatly simplify your code.

- Chapter 6
  covers I/O.
  You'll learn
  + _HOW TO_ read and write data from the standard input, output, and error streams,
  + _HOW TO_ read from and write to files on disk.
  + _HOW TO_ format numerical data as text.

  Practice these skills by writing a minimal note-taking app for the command line.

** DONE 3 Writing reusable code with functions and subroutines - 57
CLOSED: [2024-09-07 Sat 20:46]
- This chapter covers
  * What /procedures/ are and why we use them
  * How /procedures/ break down into two kinds: /functions/ and /subroutines/
  * Writing /procedures/ that don't cause /side effects/
  * Writing /procedures/ that work on both /scalars/ and /arrays/

*** DONE 3.1 Toward higher app complexity - 58
CLOSED: [2024-09-06 Fri 20:26]
**** 3.1.1 Refactoring the tsunami simulator - 58
**** 3.1.2 Revisiting the cold front problem - 61
- *Experiment a bit*

**** 3.1.3 An overview of Fortran program units - 63
- Figure 3.5 Overview of a function and a subroutine, and how they're invoked
  from the main program

- ~contains~
  Figure 3.6 Defining and accessing an external function and subroutine in the main program

*** DONE 3.2 Don't repeat yourself, use procedures - 65
CLOSED: [2024-09-06 Fri 21:25]
**** 3.2.1 Your first function - 65
***** DEFINING A FUNCTION
***** INVOKING THE FUNCTION
- *Actual and dummy arguments*
  * /Actual arguments/ are call /arguments/ or /actual arguments/ in other languages.
  * /dummy arguments/ are call /parameters/ or /formal arguments/ in other languages.

***** SPECIFYING THE INTENT OF THE ARGUMENTS
- The ~intent~ /attribute/ informs the compiler about the semantic purpose of the
  arguments, and it can take three different values:
  - ~intent(in)~
    input, won't change inside the /procedure/.

  - ~intent(out)~
    output

  - ~intent(in out)~
    input and output. Its value can be modified inside the /procedure/.

- Like ~implicit none~, specifying the ~intent~ is *optional* but _strongly
  recommended_.

- =IMPORTANT=
  I mentioned earlier that ~function~'s are best suited for calculations that don’t
  cause side effects, whereas ~subroutine~'s are more appropriate when we need to
  modify variables in-place.

  * *These are best practices, RATHER THAN hard rules*:
    Fortran allows ~intent(in out)~ and ~intent(out)~ arguments for /functions/
    as well as /subroutines/, which means that functions could be used to modify
    variables in-place.

***** WHERE TO DEFINE A FUNCTION
_BEFORE_ /modules/ were introduced by the _Fortran 90 standard_, it was common
for functions to be defined *in their own file*.

- State-of-the-art
  linear algebra libraries like BLAS (Basic Linear Algebra Subprograms, https://www.openblas.net) or
  LAPACK (Linear Algebra PACKage, http://www.netlib.org/lapack)
  are still organized in the *one-procedure-per-file model*.

**** 3.2.2 Expressing finite difference as a function in the tsunami simulator - 70
- Listing 3.10 Delegating the finite differencing to a function
  #+begin_src fortran
    time_loop: do n = 1, num_time_steps
      dh = diff(h)

      do concurrent (i = 1:grid_size)
        h(i) = h(i) - c * dh(i) / dx * dt
      end do

      print *, n, h
    end do time_loop
  #+end_src

- Listing 3.11 Finite difference calculation expressed as a function
  #+begin_src fortran
    function diff(x) result(dx)
      real, intent(in) :: x(:)
      real :: dx(size(x))
      integer :: im
      im = size(x)
      dx(1) = x(1) - x(im)
      dx(2:im) = x(2:im) - x(1:im-1)
    end function diff
  #+end_src

- Listing 3.12 Solving the advection equation with a single expression
  #+begin_src fortran
    time_loop: do n = 1, num_time_steps
      h = h - c * diff(h) / dx * dt
      print *, n, h
    end do time_loop
  #+end_src

*** DONE 3.3 Modifying program state with subroutines - 72
CLOSED: [2024-09-06 Fri 21:42]
**** 3.3.1 Defining and calling a subroutine - 72
- Listing 3.13 A subroutine that calculates the sum of two integers
  #+begin_src fortran
    subroutine add(a, b, res)
      integer, intent(in) :: a, b
      integer, intent(out) :: res
      res = a + b
    end subroutine add
  #+end_src

- *Exercise 1: Modifying state with a subroutine*

**** 3.3.2 When do you use a subroutine over a function? - 74
- *TIP* ALWAYS use a /function/, UNLESS you have to use a /subroutine/.

- _Technically_,
  Fortran _ALLOWS_ you to have ~intent(out)~ and ~intent(in out)~ arguments in
  ~function~'s. This kind of ~function~ would both return its normal result and
  modify one or more of its arguments in place.

  * This inevitably creates side effects that are difficult to debug, and it
    *HINDERS the compiler from optimizing the program.*

  * There's even a feature of the language designed to prevent side effects:
    /pure procedures/.
    =IMPORTANT= =TODO= =TODO=

    + In practice, /pure procedures/ allow you to write code that the compiler
      can
      - safely optimize, and
      - that POTENTIALLY can even _be executed out of order_.

**** 3.3.3 Initializing water height in the tsunami simulator - 75
Listing 3.16 A subroutine to initialize an array with a Gaussian shape
#+begin_src fortran
  subroutine set_gaussian(x, icenter, decay)
    real, intent(in out) :: x(:)
    integer, intent(in) :: icenter
    real, intent(in) :: decay
    integer :: i
    do concurrent(i = 1:size(x))
      x(i) = exp(-decay * (i - icenter)**2)
    end do
  end subroutine set_gaussian
#+end_src

*** DONE 3.4 Writing pure procedures to avoid side effects - 76
CLOSED: [2024-09-07 Sat 14:10]
- Fortran lets you define a function or a subroutine in a way that prevents /side
  effects/.

- A /pure procedure/ allows you to write code that won't affect the state of the
  program outside of the /procedure/, aside from the result that it returns.
  * If the code somehow violates this restriction, the compiler will report an error.

**** DONE 3.4.1 What is a pure procedure? - 76
CLOSED: [2024-09-07 Sat 13:59]
- A Fortran /procedure/ is /pure/ when it doesn't cause
  _ANY *observable* /side effects/,_
  such as I/O or modifying the value of a variable declared outside of the
  /procedure/.

- To define a /procedure/ as /pure/, simply add the ~pure~ attribute to its
  ~function~ or ~subroutine~ statement, as shown in the following listing.
  * Example:
    #+NAME: Listing 3.17 Defining a pure, side effect-free function
    #+begin_src fortran
      pure integer function sum(a, b)
        integer, intent(in) :: a, b
        sum = a + b
      end function sum
    #+end_src

**** DONE 3.4.2 Some restrictions on pure procedures - 77
CLOSED: [2024-09-07 Sat 14:06]
- A /pure procedure/,
  while advantageous from both program design and compiler optimization perspectives,
  does come with a number of _restrictions_:
  * If it's a function, it can't alter its input arguments.
    This implies that all /dummy arguments/ must be declared with the
    ~intent(in)~ attribute.

  * It can read /global variables/ (for the /main program/ or /module/),
    but it *can't alter* them.

  * It can invoke ONLY /pure procedures/.

  * *It can't contain the ~stop~ statement* -- this would stop the execution of
    the whole program, and is thus a /side effect/.

- There are several _MORE restrictions_ on /pure procedures/ that are more
  situational and that you're less likely to encounter.
  =TODO=
  We'll revisit this topic later in the book as we encounter these edge cases.

**** DONE 3.4.3 Why are pure functions important? - 77
CLOSED: [2024-09-07 Sat 14:10]
- Including a ~pure~ attribute in your /function/ and /subroutine/ statements
  forces you to write /side effect-free/ code. This has _TWO principal *benefits*:_
  * Side effect-free code is easier to debug.

  * It allows the compiler to execute the /procedure/ in the most efficient way.
    + A good compiler on a multicore system can even execute a /pure procedure/
      in parallel, IF that would be more efficient.

*** DONE 3.5 Writing procedures that operate on both scalars and arrays - 77
CLOSED: [2024-09-07 Sat 14:24]
- When a /procedure/ is defined to operate on _scalar arguments_, it's relatively
  straightforward to make it work with _array arguments_ as well.
  * For example, recall our /pure function/ ~sum~ from the previous subsection:
    #+begin_src fortran
      pure integer function sum(a, b)
        integer, intent(in) :: a, b
        sum = a + b
      end function sum
    #+end_src

- ~elemental~ automatically allows the scalar dummy arguments to be treated as
  arrays, if the arguments passed in are arrays. The result of the procedure then
  takes the same shape as the input arrays.
  * Example,
    #+begin_src fortran
      pure elemental integer function sum(a, b)
        integer, intent(in) :: a, b
        sum = a + b
      end function sum
    #+end_src

- If you pass multiple arrays as arguments to an /elemental procedure/,
  _they all have to be of conforming shape._

- *Exercise 2: Writing an elemental function that operates on both scalars and arrays*

- =VERY IMPORTANT=
  When you use the ~elemental~ attribute to define a /procedure/, it's *automatically*
  defined as ~pure~, *EVEN if ~pure~ is NOT EXPLICITLY specified*.
  * _It is, however, good practice to specify both attributes for clarity._

- *Impure elemental?*

  *Since Fortran 2008 standard*, =from Jian= most Fortran project does *NOT* use
  this standard.

  * This feature is specifically designed to allow /elemental behavior/ for
    /nonpure procedures/.

    =VERY IMPORTANT=
    In practice, you'd want to use ~impure elemental~ whenever you have a function
    that operates on both scalars and arrays but needs functionality that's *not
    permitted in* /pure procedures/. These include
    + I/O to and from screen or external files,
    + calling C functions, or
    + exchanging data with other parallel processors.

*** DONE 3.6 Procedures with optional arguments - 79
CLOSED: [2024-09-07 Sat 20:31]
#+NAME: Listing 3.18 Example of a subroutine using an optional input argument
#+begin_src fortran
  subroutine add(a, b, res, debug)
    integer, intent(in) :: a, b
    integer, intent(out) :: res
    logical, intent(in), optional :: debug

    if (present(debug)) then
      if (debug) then
        print *, 'DEBUG: subroutine add, a = ', a
        print *, 'DEBUG: subroutine add, b = ', b
      end if
    end if

    res = a + b

    if (present(debug)) then
      if (debug) print *, &
      'DEBUG: subroutine add, res = ', res
    end if
  end subroutine add
#+end_src
- Use ~optional~ to declare:
  #+begin_src fortran
  logical, intent(in), optional :: debug
  #+end_src

- Use ~present~ to check:
  #+begin_src fortran
    if (present(debug)) then
      ...
  #+end_src

- Usage:
  #+begin_src fortran
    call add(3, 5, res)
    call add(3, 5, res, .true.)
    call add(3, 5, res, debug=.true.)
  #+end_src

*** DONE 3.7 Tsunami simulator: Putting it all together - 81
CLOSED: [2024-09-07 Sat 20:31]
- Listing 3.19 The updated complete code of the tsunami simulator

*** TODO 3.8 Answer key - 82
**** 3.8.1 Exercise 1: Modifying state with a subroutine - 82
**** 3.8.2 Exercise 2: Writing an elemental function that operates on both scalars and arrays - 83

*** DONE 3.9 New Fortran elements, at a glance - 83
CLOSED: [2024-09-07 Sat 20:42]
- ~function~, ~end function~
- ~subroutine~, ~end subroutine~
- ~contains~
- ~call~
- ~intent~
  * ~intent(in)~
  * ~intent(out)~
  * ~intent(in out)~

- ~pure~
- ~elemental~
  * By default ~pure~. Same as ~pure elemental

- ~optional~
- Built-in functions:
  * ~real~
  * ~size~
  * ~present~

*** TODO 3.10 Further reading - 84
functional-fortran: https://wavebitscientific.github.io/functional-fortran/

**** Summary - =TODO: RE-ORG=
- Procedures allow you to organize code into self-contained units of functionality,
  which you can then reuse whenever needed.

- Fortran has two kinds of procedures: functions and subroutines.

- Functions are invoked from expressions and return only one value as a result.
  They’re thus best suited for minimal bits of calculation that don’t cause any
  side effects.

- Subroutines are invoked using a call statement; they can’t be invoked in
  expressions but can return any number of arguments as a result. In contrast to
  functions, subroutines are appropriate whenever you need to return more than
  one variable as a result, or for operations that cause side effects, such as
  modifying variables in-place and I/O.

- You can define functions or subroutines as pure to prevent side effects. In
  general, this will allow you to write code that’s easier to understand and
  debug, as well as easier for the compiler to optimize.

- You can also define functions or subroutines as elemental, which allows them to
  operate on both scalars and arrays of any rank and size.

- Functions and subroutines are your first layer of abstraction—design them
  carefully and use them only if they make your program easier to read and
  understand.

** TODO 4 Organizing your Fortran code using modules - 85
- This chapter covers
  * Accessing /variables/ and /procedures/ in /modules/
  * Writing your own custom /module/
  * Refactoring the tsunami simulator with /modules/

- /Modules/ allow you to organize /variable/ and /procedure/ definitions in a
  meaningful way, and make them _accessible_ for use in /programs/,
  /procedures/, or other /modules/.

- _Modern Fortran libraries_ are typically organized in one or more /modules/.

- Large applications define most functionality in /modules/, with only the
  top-level code being defined in the main program.

- Fortran comes with a few /built-in modules/, so you'll first learn how to access
  them in your programs.

- As we refactor our tsunami simulator to use /modules/, we'll use that opportunity
  to expand it with more physics terms. Specifically,
  * we'll allow the simulated water to respond to gravity, and
  * we'll make sure that the volume of water is conserved.

  Considering these factors will allow for more realistic fluid-flow
  simulations.

  + In the process, you'll learn how to control what /variables/ and /procedures/
    get imported from /modules/, as well as _how to *AVOID* potential name conflicts_.

*** DONE 4.1 Accessing a module - 86
CLOSED: [2024-09-07 Sat 22:33]
**** 4.1.1 Getting compiler version and options - 86
- Q :: Once you have a compiled program executable, it's not obvious how it was
       compiled. Specifically, what compiler was used, and were any compiler
       options used -- for example, for debugging or optimization?

- A :: Fortran's ~iso_fortran_env~ /module/ provides two functions that allow you to
       get this information at runtime: ~compiler_version~ and ~compiler_options~.
       You get the idea what each of these functions does.

- Listing 4.1 Printing the compiler version and options at runtime
  #+begin_src fortran
    program print_compiler_info
      use iso_fortran_env
      implicit none
      print *, 'Compiler version: ', compiler_version()
      print *, 'Compiler options: ', compiler_options()
    end program print_compiler_info
  #+end_src
  * This ~use~ statement imports *EVERY* entity that's defined in the /module/.

  * You must place the ~use~ statement
    _AFTER_ the ~program~ statement (or the ~function~ or ~subroutine~ statement) and
    _BEFORE_ the ~implicit none~ statement, or any other /declarative statements/.

- Here, I added the ~-fcheck=all -g -O0 -fbacktrace~ option to compile the program:
  *These options are specific to _gfortran_ and vary between compiler vendors.*

  * ~-fcheck=all~ _enables all runtime checks_, such as exceeding array bounds.

  * ~-g~ compiles the program with additional instructions that _allow it to be
    run by a debugger_.

  * ~-O0~ _disables any optimizations_ by setting the optimization level to zero.

  * ~-fbacktrace~ will cause the program to _print a useful traceback_ in case of
    a runtime failure, telling you where in the program the error occurred.

- *Built-in Fortran modules*
  * Fortran provides _FIVE /built-in modules/:_
    + ~iso_fortran_env~
    + ~iso_c_binding~
    + ~ieee_arithmetic~
    + ~ieee_exceptions~
    + ~ieee_features~

  * ~iso_fortran_env~ provides useful /procedures/ and /parameters/ that we'll
    explore in this chapter, as well as a few others we'll explore in chapter 11.
    =TODO=

  * ~iso_c_binding~ provides facilities to _INTERFACE C functions and data structures._
    =TODO= We'll explore that in detail in chapter 12.

  * The latter THREE /modules/ provide facilities specific to floating-point
    arithmetic and *AREN'T* generally as useful as the first two.

**** 4.1.2 Using portable data types - 89
- In chapter 2, I mentioned that variables of /built-in types/ can be _explicitly
  and portably_ declared using specific /type kinds/.

- /Type kind parameters/ DETERMINE the space that /numeric variables/ occupy in
  memory, which in turn limits the range for integers, and the range and
  precision for real and complex numbers.

- Most Fortran compilers by default declare 4-byte-long integers and reals,
  equivalent to ~int~ and ~float~ in C, respectively.

  _HOWEVER_, *the standard _doesn't guarantee_ that the size will be the same
  between different systems and compilers.* This is where the ~iso_fortran_env~
  module comes in.

  * It provides, among other things, a set of parameters you can use to specify
    the size of numeric data types (table 4.1).

    + Table 4.1 A summary of Fortran's built-in numeric type kinds in
      ~iso_fortran_env~
      | Type kind | Type          | Size (bytes) | C-equivalent |
      |-----------+---------------+--------------+--------------|
      | int8      | integer       |            1 | None         |
      | int16     | integer       |            2 | short        |
      | int32     | integer       |            4 | int          |
      | int64     | integer       |            8 | long         |
      | real32    | real, complex |            4 | float        |
      | real64    | real, complex |            8 | double       |
      | real128   | real, complex |           16 | long double  |

- These /type kinds/ are defined in the standard and are guaranteed to have a
  specified size in memory.
  * Most commonly used Fortran compilers, such as GNU _gfortran_ and Intel _ifort_,
    fully support these /type kinds/.

  * _If your compiler doesn't implement a standard-defined type kind, it will
    raise a compile-time error._

  * The standard guarantees portability of data types
    in terms of the memory that they occupy (32 bits, 64 bits, and so on)
    BUT *NOT* in terms of their range (minimum and maximum values) and precision
    (how many significant digits can be represented).

  * Unlike C, Fortran does *NOT* have /unsigned integer types/.

- =TODO: NEXT= More on Fortran interoperability with C in chapter 11.

- Example:
  #+begin_src fortran
    use iso_fortran_env

    integer(kind=int32) :: n
    real(kind=real32) :: dt
  #+end_src
  * ~kind~ is optional:
    #+begin_src fortran
      integer(int32) :: n
      real(real32) :: dt
    #+end_src

- =VERY IMPORTANT=
  Page 90
  All commonly used Fortran compilers and platforms, ~integer~ and
  ~integer(int32)~ can be used interchangebly.

- *TIP*
  Always use the /PORTABLE type kind parameters/ provided by ~iso_fortran_env~ to
  declare your variables, at least for your ~real~ and ~complex~ variables.

- Imports only these entities from the module
  ~use iso_fortran_env, only: int32, real32~

- *Exercise 1: Using portable type kinds in the tsunami simulator*

*** TODO 4.2 Creating your first module - 91
**** 4.2.1 The structure of a custom module - 92
**** 4.2.2 Defining a module - 93
**** 4.2.3 Compiling Fortran modules - 95
- *Exercise 2: Define the set_gaussian subroutine in a module*

**** 4.2.4 Controlling access to variables and procedures - 97
**** 4.2.5 Putting it all together in the tsunami simulator - 98

*** TODO 4.3 Toward realistic wave simulations - 99
**** 4.3.1 A brief look at the physics - 101
**** 4.3.2 Updating the finite difference calculation - 102
**** 4.3.3 Renaming imported entities to avoid name conflict - 104
**** 4.3.4 The complete code - 105

*** TODO 4.4 Answer key - 107
**** 4.4.1 Exercise 1: Using portable type kinds in the tsunami simulator - 107
**** 4.4.2 Exercise 2: Defining the set_gaussian subroutine in a module - 107

*** TODO 4.5 New Fortran elements, at a glance - 108
*** TODO 4.6 Further reading - 108
**** Summary - 109

** TODO 5 Analyzing time series data with arrays - 110
- This chapter covers
  * Analyzing stock prices with Fortran arrays
  * Declaring, allocating, and initializing arrays
  * Using whole-array arithmetic to quantify stock performance and risk

- array :: a sequence of data elements that are of the same type and contiguous
           in memory.

- /Whole-array operators and arithmetic/ were introduced in Fortran 90.

- For this chapter, we'll _take a small break_ from the tsunami simulator and
  EXPLORE Fortran arrays by writing a stock price analysis app.

*** 5.1 Analyzing stock prices with Fortran arrays - 111
**** 5.1.1 Objectives for this exercise - 111
- In this section, we'll set tangible goals for this exercise:
  * Find the best and worst performing stocks.
  * Identify risky stocks.
  * Identify good times to buy and sell.

**** 5.1.2 About the data - 112
**** 5.1.3 Getting the data and code - 114
- *Downloading more stock data*

*** TODO 5.2 Finding the best and worst performing stocks - 114
**** DONE 5.2.1 Declaring arrays - 116
CLOSED: [2024-09-08 Sun 00:09]
- ~real, allocatable :: h(:)~

- *When do we use dynamic over static arrays?*

- ~character(len=:), allocatable :: time(:)~
  Here ~character(len=:)~ means we don't speicify the length ahead of time.
  =TODO: ???=

- *Specifying the length of character strings*
  ~character(4)~ is a shorthand for ~character(len=4)~.
  ~character~ is equivalent to ~character(1)~.

**** DONE 5.2.2 Array constructors - 118
CLOSED: [2024-09-08 Sun 00:09]
- Initialize from a constant array:
  ~integer :: a(5) = [1, 2, 3, 4, 5]~

- *Alternative syntax for array literals*
  ~integer :: a(5) = (/1, 2, 3, 4, 5/)~
  Since this is more verbose, it is rarely used.

- Initialize an array on the declaration line is good.
  _HOWEVER_, there's one exception case in which you're not allowed to do this:
  /pure procedures/.

  In that case, you have no choice but to declare and initialize in separate
  statements:
  #+begin_src fortran
    integer :: a(5)
    a = [1, 2, 3, 4, 5]
  #+end_src
  This restriction stems from a _HISTORICAL feature_ of Fortran called
  /implicit save/ behavior.

- *Implicit save* =TODO: note= =CAVEAT=

- A shorthand for ~do~ loop.
  This is very useful for constructing an array.
  #+begin_src fortran
    a = [(i, i = 1, 100)]

    b = [(sin(2 * pi * i / 1000.), i = 0, 1000)]
  #+end_src

- Create empty array:
  ~[integer ::]~ or ~[real ::]~
  =TODO: ???=
  These could be useful if invoking a /generator/ -- a function that appends an
  element to an array on every call.

- *Combining different numeric types in expressions*
  * Two simple rules:
    1. The expression is first evaluated to the strongest (most precise) type.
       + For example,
         - multiplying a real with an integer always results in a real,

         - multiplying a complex number with either a real or an integer
           always results in a complex number.

         - Same goes for kinds of different precision—adding a real32 to a real64
           results in a real64 value.

    2. If you're _assigning_ the result of the expression to a /variable/, its
       /type/ is _AUTOMATICALLY promoted (or demoted!)_ to the /type/ of the
       /variable/.

**** TODO 5.2.3 Reading stock data from files - 121
**** TODO 5.2.4 Allocating arrays of a certain size or range - 122
- *Inquiring about array bounds*

**** TODO 5.2.5 Allocating an array from another array - 123
**** TODO 5.2.6 Automatic allocation on assignment - 123
**** TODO 5.2.7 Cleaning up after use - 124
- *Automatic deallocation*
- *Careful with frequent allocation!*

**** TODO 5.2.8 Checking for allocation status - 126
**** TODO 5.2.9 Catching allocation and deallocation errors - 126
- *Exercise 1: Convenience (de)allocator subroutines*

**** TODO 5.2.10 Implementing the CSV reader subroutine - 127
- *Getting the number of lines in a text file*

**** TODO 5.2.11 Indexing and slicing arrays - 129
- *Exercise 2: Reversing an array*
- *Referencing array elements out of bounds*

*** TODO 5.3 Identifying risky stocks - 132
- *Exercise 3: Calculating moving average and standard deviation*

*** TODO 5.4 Finding good times to buy and sell - 135
- *Plotting the results*

*** TODO 5.5 Answer key - 139
**** 5.5.1 Exercise 1: Convenience (de)allocator subroutines - 139
**** 5.5.2 Exercise 2: Reversing an array - 140
**** 5.5.3 Exercise 3: Calculating moving average and standard deviation - 140

*** TODO 5.6 New Fortran elements, at a glance - 141
*** TODO 5.7 Further reading - 141
**** Summary - 141

** TODO 6 Reading, writing, and formatting your data 143
- This chapter covers
  * Reading from the keyboard and writing to the screen
  * Standard input, output, and error streams
  * Formatting numbers and text
  * Writing data to files on disk

*** 6.1 Your first I/O: Input from the keyboard and output to the screen - 144
**** 6.1.1 The simplest I/O - 144
- *Removing trailing blanks from character strings*
- *Passing data from other programs*

**** 6.1.2 Reading and writing multiple variables at once - 147
**** 6.1.3 Standard input, output, and error - 148
- *What's an I/O unit?*
- *Better logging*

*** 6.2 Formatting numbers and text - 151
**** 6.2.1 Designing the aircraft dashboard - 151
**** 6.2.2 Formatting strings, broken down - 152
***** FORMATTING REAL NUMBERS
***** FORMATTING INTEGERS
***** FORMATTING LOGICAL AND TEXT VALUES

**** 6.2.3 Format statements in legacy Fortran code - 157

*** 6.3 Writing to files on disk: A minimal note-taking app - 157
**** 6.3.1 Opening a file and writing to it - 158
- *Fixed-length or allocatable character variables?*

**** 6.3.2 Opening a file - 159
- *Exercise: Redirect stdout and stderr to files*

**** 6.3.3 Writing to a file - 161
- *Flushing the output buffer to a file*

**** 6.3.4 Appending to a file - 162
- *Rewinding a file*

**** 6.3.5 Opening files in read-only or write-only mode - 163
**** 6.3.6 Checking whether a file exists - 164
- *Nonadvancing I/O*

**** 6.3.7 Error handling and closing the file - 167

*** 6.4 Answer key - 168
**** 6.4.1 Exercise: Redirect stdout and stderr to files - 168

*** 6.5 New Fortran elements, at a glance - 169
**** Summary

* TODO PART 3 ADVANCED FORTRAN USE - 171
** 7 Going parallel with Fortran coarrays - 173
*** 7.1 Why write parallel programs? - 174
*** 7.2 Processing real-world weather buoy data - 175
**** About the data - 176
**** Getting the data and code - 178
**** Objectives - 178
**** Serial implementation of the program - 179

*** 7.3 Parallel processing with images and coarrays - 181
**** Fortran images - 182
**** Getting information about the images - 183
**** Telling images what to do - 184
**** Gathering all data to a single image - 186

*** 7.4 Coarrays and synchronization, explained - 187
**** Declaring coarrays - 188
**** Allocating dynamic coarrays - 188
**** Sending and receiving data - 189
**** Controlling the order of image execution - 191

*** 7.5 Toward the parallel tsunami simulator - 192
**** Implementation strategy - 192
**** Finding the indices of neighbor images - 194
**** Allocating the coarrays - 195
**** The main time loop - 196

*** 7.6 Answer key - 199
**** Exercise 1: Finding the array subranges on each image - 199
**** Exercise 2: Writing a function that returns the indices of neighbor images - 200
O
*** 7.7 New Fortran elements, at a glance - 201
*** 7.8 Further reading - 201

** 8 Working with abstract data using derived types - 202
*** 8.1 Recasting the tsunami simulator with derived types - 203
*** 8.2 Defining, declaring, and initializing derived types - 206
**** Defining a derived type - 209
**** Instantiating a derived type - 210
**** Accessing derived type components - 212
**** Positional vs. keyword arguments in derived type constructors - 212
**** Providing default values for derived type components - 214
**** Writing a custom type constructor - 215
**** Custom type constructor for the Field type - 218

*** 8.3 Binding procedures to a derived type - 220
**** Your first type-bound method - 220
**** Type-bound methods for the Field type - 221
**** Controlling access to type components and methods - 222
**** Bringing it all together - 224

*** 8.4 Extending tsunami to two dimensions - 224
**** Going from 1-D to 2-D arrays - 225
**** Updating the equation set - 226
**** Finite differences in x and y - 226
**** Passing a class instance to diffx and diffy functions - 228
**** Derived type implementation of the tsunami solver - 229

*** 8.5 Answer key - 231
**** Exercise 1: Working with private components - 231
**** Exercise 2: Invoking a type-bound method from an array of instances - 233
**** Exercise 3: Computing finite difference in y direction. - 233

*** 8.6 New Fortran elements, at a glance - 234
*** 8.7 Further reading - 235

** 9 Generic procedures and operators for any data type - 236
*** 9.1 Analyzing weather data of different types - 237
**** About the data - 238
**** Objectives - 241
**** Strategy for this exercise - 242

*** 9.2 Type systems and generic procedures - 242
**** Static versus strong typing - 242

*** 9.3 Writing your first generic procedure - 243
**** The problem with strong typing - 243
**** Writing the specific functions - 244
**** Writing the generic interface - 247
**** Results and complete program - 251

*** 9.4 Built-in and custom operators - 253
**** What’s an operator? - 253
**** Things to do with operators - 253
**** Fortran’s built-in operators - 255
**** Operator precedence - 257
**** Writing custom operators - 257
**** Redefining built-in operators - 258

*** 9.5 Generic procedures and operators in the tsunami simulator - 259
**** Writing user-defined operators for the Field type - 259

*** 9.6 Answer key - 260
**** Exercise 1: Specific average function for a derived type - 260
**** Exercise 2: Defining a new string concatenation operator - 262

*** 9.7 New Fortran elements, at a glance - 263

** 10 User-defined operators for derived types - 264
*** 10.1 Happy Birthday! A countdown app - 265
**** Some basic specification - 265
**** Implementation strategy - 266

*** 10.2 Getting user input and current time - 266
**** Your first datetime class - 266
**** Reading user input - 267
**** Getting current date and time - 271

*** 10.3 Calculating the difference between two times - 272
**** Modeling a time interval - 273
**** Implementing a custom subtraction operator - 273
**** Time difference algorithm - 275
**** The complete program - 280

*** 10.4 Overriding operators in the tsunami simulator - 282
**** A refresher on the Field class - 283
**** Implementing the arithmetic for the Field class - 284
**** Synchronizing parallel images on assignment - 286

*** 10.5 Answer key - 288
**** Exercise 1: Validating user input - 288
**** Exercise 2: Leap year in the Gregorian calendar - 289
**** Exercise 3: Implementing the addition for the Field type - 289

*** 10.6 New Fortran elements, at a glance - 290

* TODO PART 4 THE FINAL STRETCH - 291
** 11 Interoperability with C: Exposing your app to the web - 293
*** 11.1 Interfacing C: Writing a minimal TCP client and server - 294
**** Introducing networking to Fortran - 295
**** Installing libdill - 297

*** 11.2 TCP server program: Receiving network connections - 297
**** IP address data structures - 299
**** Initializing the IP address structure - 301
**** Checking IP address values - 306
**** Intermezzo: Matching compatible C and Fortran data types - 308
**** Creating a socket and listening for connections - 310
**** Accepting incoming connections to a socket - 311
**** Sending a TCP message to the client - 312
**** Closing a connection - 315

*** 11.3 TCP client program: Connecting to a remote server - 317
**** Connecting to a remote socket - 317
**** Receiving a message - 319
**** The complete client program - 321

*** 11.4 Some interesting mixed Fortran-C projects - 322
*** 11.5 Answer key - 322
**** Exercise 1: The Fortran interface to ipaddr_port - 322
**** Exercis 2: Fortran interfaces to suffix_detach and tcp_close - 323

*** 11.6 New Fortran elements, at a glance - 324
*** 11.7 Further reading - 324

** 12 Advanced parallelism with teams, events, and collectives - 326
*** 12.1 From coarrays to teams, events, and collectives - 327
*** 12.2 Grouping images into teams with common tasks - 328
**** Teams in the tsunami simulator - 329
**** Forming new teams - 331
**** Changing execution between teams - 332
**** Synchronizing teams and exchanging data - 335

*** 12.3 Posting and waiting for events - 338
**** A push notification example - 339
**** Posting an event - 341
**** Waiting for an event - 341
**** Counting event posts - 342

*** 12.4 Distributed computing using collectives - 343
**** Computing the minimum and maximum of distributed arrays - 343
**** Collective subroutines syntax - 345
**** Broadcasting values to other images - 346

*** 12.5 Answer key - 347
**** Exercise 1: Hunters and gatherers - 347
**** Exercise 2: Tsunami time step logging using events - 350
**** Exercise 3: Calculating the global mean of water height - 351

*** 12.6 New Fortran elements, at a glance - 353
*** 12.7 Further reading - 353

* TODO appendix A Setting up the Fortran development environment - 355
* TODO appendix B From calculus to code - 361
* TODO appendix C Concluding remarks - 366
* index - 381
