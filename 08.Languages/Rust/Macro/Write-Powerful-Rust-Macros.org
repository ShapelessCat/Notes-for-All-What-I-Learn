#+TITLE: Write Powerful Rust Macros
#+AUTHORS: Sam Van Overmeire
#+YEAR: 2024
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* preface - xi
* acknowledgments - xii
* about this book - xiv
* about the author - xvii
* about the cover illustration - xviii
* DONE 1 Going meta - 1
CLOSED: [2024-09-17 Tue 21:57]
- This chapter covers
  * *WHAT* /metaprogramming/ is
  * /Metaprogramming/ in Rust
  * *WHEN* to use /macros/
  * *WHAT* this book will teach you

- When you want to write a macro,
  * you need knowledge of testing and debugging.
  * You have to know how to set up a library because you cannot write a /procedural
    macro/ without creating a library.
  * Some knowledge about Rust
    + internals,
    + compilation,
    + types,
    + code organization,
    + pattern matching, and
    + parsing also comes in handy.

  Thus, teaching about macros allows me to talk about a variety of other
  programming topics. We will be learning about Rust macros and using them to
  explore other subjects.

- Let's take a step back and start from the beginning.

** 1.1 A day in the life of a Rust developer - 2
- Even when writing the simplest of Rust code, you just _CANNOT STOP_ using /macros/.
  You are surrounded by the fruits of Rust's metaprogramming.

** 1.2 What is metaprogramming? - 3
** 1.3 Metaprogramming in Rust - 4
- /Macros/ are used extensively in Rust, and it hard to imagine Rust code without /macros/.

- /Rust macros/ are
  * NOT just some /syntactic sugar/
  * BUT _core functionality_.

- For /Rust declarative macros/, /hygiene/ is part of that safety, avoiding /clashes
  with names/ used elsewhere in your code.

- /Macros in Rust/ are
  (a) more localized and
  (b) run at compile time,
  allowing for easier inspection and better verification.
  * This is clearer if compared with Spring's.

*** 1.3.1 Macro galore - 5
*** 1.3.2 Appropriate use cases - 6
*** 1.3.3 Unfit for purpose: When not to use macros - 10

** 1.4 Approach of this book - 10
** 1.5 Exercise - 11

* TODO 2 Declarative macros - 12
- This chapter covers
  * *WRITING* /declarative macros/

  * *AVOIDING* boilerplate and duplication,
    *IMPLEMENTING* /newtypes/,
    *WRITING* simple /domain specific languages/, and
    *COMPOSING* functions

  * *UNDERSTANDING* the ~lazy_static~ crate

- /Declarative macros/:
  these macros have a syntax that will immediately remind you of pattern matching,
  with a COMBINATION of /matchers/ and /transcribers/.
  * The /matchers/ contain what you want to match against;
  * the /transcriber/ has the code you will generate when you find that match.
  It's just that simple.

** 2.1 Creating vectors - 13
*** 2.1.1 Syntax basics - 13
- For both /matcher/ and /transcriber/, you have your choice of brackets:
  * ~()~
  * ~{}~
  * ~[]~

- For both /matcher/ and /transcriber/, you have your choice of brackets:

- Each matcher-transcriber pair should be followed by a semicolon, except the
  last one, for which the semicolon is optional.

*** 2.1.2 Declaring and exporting declarative macros - 14
- During /macro invocation/ you can have any bracket you like, as long as it is
  * normal
  * curly
  * square

- All the following are legal:
  * ~vec![]~
  * ~vec!()~
  * ~vec!{}~

*** 2.1.3 The first matcher explained - 15
*** 2.1.4 Nonemtpy matchers - 15
- Code snippet, second to the last branch:
  #+begin_src rust
    {$x:expr} => {
        {
            let mut v = Vec::new();
            v.push($x);
            v
        }
    };
  #+end_src

- macro variables :: variables in the ~$name~ pattern that show up in /declarative
  macro/ /matchers/.

- Besides /expressions/, which are a common target for matching, you can also match
  * identifiers,
  * literals,
  * types,
  * and so on.

**** Metavariables
- ~expr~ is called a /metavariable/ in Rust lingo, or /fragment specifier/.

- The _MOST POWERFUL_ of these /metavariables/ is ~tt~ (~TokenTree~), and it will
  accept almost anything you pass to it.
  * That's a powerful option,
    BUT its comprehensiveness can also be a downside!

- =IMPORTANT=
  The following is a list of all the /fragment specifiers/:
  * ~block~ -- A block expression; that is, statements between curly braces.

  * ~expr~ -- An expression; a very wide variety of things within Rust.

  * ~ident~ -- An identifier or keyword.
    + For example,
      the start of a function declaration (fn hello) has a keyword followed by
      an identifier, and we can capture them both by using ~ident~ twice.

  * ~item~ -- Things like /structs/, /enums/, /imports/ ("use declarations").

  * ~lifetime~ -- A Rust /lifetime/ (~'a~).

  * ~literal~ -- A /literal/, like a number or a character.

  * ~meta~ -- The content of an /attribute/, so ~Clone~ or ~rename = "true"~.
    You get a good idea of what an /attribute/ might contain in later chapters.

  * ~pat~ -- A /pattern/. ~1 | 2 | 3~ is one example.

  * ~pat_param~ -- Similar to ~pat~, except it can have ~|~ as a separator.
    So the rule ~($first:pat_param | $second:ident)~ will work, but ~($first:pat |
    $second:ident)~ tells you that ~|~ is not allowed after ~pat~.
    This also means you need to do some extra work to parse ~1 | 2 | 3~ with
    ~pat_param~ (as it sees three separate tokens instead of one).

  * ~path~ -- A /path/; things like ~::A::B::C~, or ~Self::method~.

  * ~stmt~ -- A /statement/; for example, an assignment (~let foo = "bar"~).

  * ~tt~ -- A ~TokenTree~; see the previous explanation.

  * ~ty~ -- A /type/, for example, ~String~.

  * ~vis~ -- A /visibility modifier/; ~pub~ comes to mind.

- Code snippet, last branch:
  #+begin_src rust
    $[($x:expr),+] => (
        {
            let mut v = Vec::new();
            $(
                v.push($x);
            )+
            v
        }
    );
  #+end_src
  * Like the ~+~ in this example, you may also need ~?~ and ~*~ somewhere.
    It is easy to guess their meanings, just like in regex.

  * An open bug: https://github.com/rust-lang/rust/issues/61053
    =from Jian: Keep an eye on this issue!!!=
    You can use any repetition operator you want within the /transcriber/,
    *regardless of the one in your /matcher/.*
    This means code below can expand as the code above
    #+begin_src rust
      $[($x:expr),+] => (
          {
              let mut v = Vec::new();
              $(
                  v.push($x);
              )?
              v
          }
      );
    #+end_src

    + If you want to make sure your code won't break because of this in a future
      version of the language, you can add the ~#![deny(meta_variable_misuse)]~
      lint to your file, which may, however, trigger false positives.
      =IMPORTANT=

  * _NOTE_:
    By now it might be obvious that the _THIRD_ matcher-transcriber pair is
    covered by this pair. But that additional pair made it easier to explain
    things step by step.

** 2.2 Use cases - 19 =TODO: NOTE=
*** 2.2.1 Varargs and default arguments - 19
*** 2.2.2 More than one way to expand code - 20
=IMPORTANT=

Both macros (in ~std~) mentioned in this section is unstable in Rust 1.80.1.
Need ~rustup default nightly~ or run commands with ~cargo +nightly your-command~.

- The ~trace_macro~
  #+begin_src rust
    #![feature(trace_macros)]     // #1

    use crate::greeting::base_greeting_fn;

    #[macro_use]
    mod greeting;

    fn main() {
        trace_macros!(true);      // #2
        let _greet = greeting!("Sam", "Heya");
        let _greet_with_default = greeting!("Sam");
        trace_macros!(false);     // #3
    }
  #+end_src
  * #1 Adds the unstable trace macros feature
  * #2 Activates the trace macros
  * #3 Deactivates the trace macros

  Output:
  #+begin_src text
    --> ch2-trace-macros/src/main.rs:9:18
      |
    9 |     let _greet = greeting!("Sam", "Heya");
      |                  ^^^^^^^^^^^^^^^^^^^^^^^^
      |
      = note: expanding `greeting! { "Sam", "Heya" }`
      = note: to `greeting("Sam", "Heya")`

    --> ch2-trace-macros/src/main.rs:10:31
       |
    10 |     let _greet_with_default = greeting!("Sam");
       |                               ^^^^^^^^^^^^^^^^
       |
       = note: expanding `greeting! { "Sam" }`
       = note: to `greeting("Sam", "Hello")`
  #+end_src

- The ~log_syntax~
  #+begin_src rust
    macro_rules! greeting {
        ($name:literal) => {
            base_greeting_fn($name,"Hello")
        };
        ($name:literal,$greeting:literal) => {
            base_greeting_fn($name,$greeting)
        };
        (test $name:literal) => {{                              // #1
            log_syntax!("The name passed to test is ", $name);  // #2
            println!("Returning default greeting");
            base_greeting_fn($name,"Hello")
        }}
    }
  #+end_src
  * #1 Double braces because we want to surround this generated code with ~{ }~,
       thereby creating just a single expression as our output

  * #2 We are using ~log_syntax!~ to log our input.

  #+begin_src rust
    #![feature(trace_macros)]
    #![feature(log_syntax)]                                    // #1

    use crate::greeting::base_greeting_fn;
    #[macro_use]
    mod greeting;

    fn main() {
        trace_macros!(true);
        let _greet = greeting!("Sam", "Heya");
        let _greet_with_default = greeting!("Sam");
        let _greet_with_default_test = greeting!(test "Sam");  // #2
        trace_macros!(false);
    }
  #+end_src

*** 2.2.3 Newtypes - 23 =TODO: one issue to be resolved=
- =TODO= Listing 2.11 A recursive fumble

*** 2.2.4 DSLs - 28
- Two simple examples from the standard library are ~println!~ and ~format!~,
  which offer a special syntax using curly braces to determine how to print
  specified variables.

*** 2.2.5 Composing is easy - 31
*** 2.2.6 Currying, on the other hand . . . - 34
*** 2.2.7 Hygiene is something to consider as well - 35

** TODO 2.3 From the real world - 36
** 2.4 Exercises - 38
1. Solution:
   #+begin_src rust
     macro_rules! hello_world {
         ($something:ty) => {
             impl $something {
                 fn hello_world(&self) {
                     println!("Hello world")
                 }
             }
         };
     }

     struct Example {}
     hello_world!(Example);

     fn main() {
         let e = Example {};
         e.hello_world(); // prints "Hello world"
     }
   #+end_src

*** Summary
- /Declarative macros/ are the first group of macros that Rust has to offer.

- They consist of one or more pairs of /matchers/ and /transcribers/.

- The /matcher/ has to match the content that was passed into the macro when it
  was invoked.

- If there is a match, the code inside the /transcriber/ will be written to where
  the macro was invoked.

- Pieces of input can be captured in the /matcher/ and used in the /transcriber/.

- /Macros/ can _call themselves_ to avoid duplication and to allow for more
  complex scenarios.

- To use macros outside the file where they were defined, you will need to export
  them: ~#[macro_export]~

- /Declarative macros/ have /hygiene/, which means local identifiers do not
  collide with external ones.

- There are several use cases for /declarative macros/:
  1. avoiding duplication and boilerplate is a major one.
  2. Another is doing things that are hard, or impossible, to do otherwise, like
     * default arguments,
     * varargs, or
     * DSLs.

- If /declarative macros/ fall short, you still have /procedural macros/ waiting
  in the corridor to assist you with even more powerful weapons.

* TODO 3 A “Hello, World” procedural macro - 41
- This chapter covers
  * *SETTING UP* a /procedural macro/
  * Getting the name of a ~struct~ by _PARSING a stream of tokens_
  * Generating hardcoded output
  * Using /variables/ in generated code
  * Inspecting generated code with ~cargo expand~
  * Writing a macro *WITHOUT* help from ~syn~ and ~quote~
  * _UNDERSTANDING HOW_ /Rust's internal macros/ are *SPECIAL*

- /Declarative macros/ offer a /domain-specific language (DSL)/ that allows you
  to generate code based on a combination of /matchers/ and /transcribers/.

- /Procedural macros/, on the other hand, deal with _lower-level information_.
  They receive a _stream of tokens_ containing *every detail* of the code you
  want to work with.

** 3.1 Basic setup of a procedural macro project - 42
_WE START SIMPLE_:
with a /macro/ that adds a ~"Hello, World"~ printing /method/ to a ~struct~ or
~enum~ (see figure 3.1 for the project setup).

- Adding new functionality to a ~struct~ is *a good use case* for a /derive macro/.

- =IMPORTANT=
  1. Figure 3.1 Basic setup of a procedural macro project
  2. Figure 3.2 Our project structure

- =from Jian=
  The code in "Listing 3.4 The initial main.rs file from the outer application"
  *the old style*
  #+begin_src rust
    #[macro_use]
    extern crate hello_world_macro;
  #+end_src

  can be replaced by

  *the newer (Rust 2018) style*
  #+begin_src rust
    use hello_world_macro::Hello;
  #+end_src

- =IMPORTANT=
  NOTE:
  * ~cargo generate~ (https://github.com/cargo-generate/cargo-generate) with a
    template (https://github.com/waynr/proc-macro-template) for generating macro
    setups.

  * You can use the =util/create_setup.sh= script in this book code repository
    (https://github.com/VanOvermeire/rust-macros-book), which automatically sets
    up projects in the various styles used in this book.

** 3.2 Analyzing the procedural macro setup - 45
- *A HIGH-LEVEL OVERVIEW*
  * There are two steps involved: /lexing/ and /parsing/.
    + Lexing :: also called /tokenization/, is the first step and is used to
                _TURN_ your code as a raw text stream
                _INTO_ a stream of tokens.

    + Example,
      pass the expression ~1 + 11~ to a /macro/, and the resulting stream will
      look like this (ignoring /spans/ and /suffixes/ for now):
      #+begin_src text
        TokenStream [
          Literal { kind: Integer, symbol: "1" },
          Punct { ch: '+', spacing: Alone },
          Literal { kind: Integer, symbol: "11" }
        ]
      #+end_src

    + Parsing :: turns this information into an /Abstract Syntax Tree
                 (AST; http://mng.bz/5lKZ)/, a tree-like representation of all
                 relevant data in your program.

  * You can find more information in
    + The Rust Compiler Development Guide (https://rustc-dev-guide.rust-lang.org/),
    + The Little Book of Rust Macros (https://veykril.github.io/tlborm/), and
    + The Rust Reference (https://doc.rust-lang.org/stable/reference/).

- When the macro in =hello-world-macro/lib.rs= generate invalid Rust code
  #+begin_src rust
    #[proc_macro_derive(Hello)]
    pub fn hello(item: TokenStream) -> TokenStream {
        let add_hello_world = quote! {
            fn this should not work () {}
        };

        add_hello_world.into()
    }
  #+end_src
  - Run ~cargo check~ in =hello-world-macro=,
    since the compiler doesn't know the context of using this macro,
    event if the code in ~quote! { .. }~ is invalid, it may work in a target
    context.

  - Run ~cargo check~ in project root,
    this time ~cargo check~ can check the expanded code, find the invalid code,
    and report.

** 3.3 Generating output - 48
** 3.4 Experimenting with our code - 50
- NOTE:
  Though /unions/ are a valid /derive target/, they do _NOT_ feature in this
  book, mostly because they are much less ubiquitous than structs and enums,
  existing almost solely for compatibility with C over a foreign function
  interface (FFI).

** 3.5 ~cargo expand~ - 51
- ~cargo install cargo-expand~

- Run ~cargo expand~ in the root of the application directory or the =src= folder.
  All macro can be expanded,
  *EXCEPT* that ~format_args!~ was not expanded.
  =WIP bugfix=
  That's a Rust problem [https://github.com/dtolnay/cargo-expand/issues/173],
  and fixing it is a work in progress.

- ~cargo expand~ is a useful tool for a visual inspection of our code, and
  *it runs even when our output is invalid, making it useful for debugging
  compilation problems.*

** 3.6 The same macro -- without ~syn~ and ~quote~ - 52
The ~quote~ and ~syn~ libraries are very useful _but not strictly necessary_ for
writing macros.

- Listing 3.11 Without syn and quote
  #+begin_src rust
    use proc_macro::{TokenStream, TokenTree};

    #[proc_macro_derive(Hello)]
    pub fn hello_alt(item: TokenStream) -> TokenStream {
        fn ident_name(item: TokenTree) -> String {
            match item {
                TokenTree::Ident(i) => i.to_string(),            // #1
                    _ => panic!("no ident")
            }
        }
        let name = ident_name(item.into_iter().nth(1).unwrap()); // #2

        format!("impl {} {{ fn hello_world(&self) \
        {{ println!(\"Hello, World\\") }} }} ", name
            ).parse()
            .unwrap()                                            // #3
    }
  #+end_src
  * To retrieve the ~name~, we iterate over the incoming stream and take the
    second element with ~nth(1)~.

    + That ~item~ is a ~TokenTree~ containing the _name of the struct or enum._
      - The first element, contained in ~nth(0)~, has the type (i.e., ~struct~
        or ~enum~) and is not relevant in this situation -- so we skip it.

  * DEFINITION:
    + A ~TokenTree~ sits somewhere between a ~TokenStream~ and simple /tokens/.
      Basically,
      a ~TokenStream~ is _a sequence of ~TokenTree~'s,_ which are themselves
      (recursively) _COMPOSED of_ more /trees/ and/or /tokens/.

      - This is why we can iterate over our stream, pick an element, and assure
        Rust that the type is ~TokenTree~.

      - The ~tt~ /fragment specifier/ for
        /declarative macros/, which we encountered in the previous chapter, is
        also a ~TokenTree~.

  * To generate output,
    we use the ~format~ macro to _inject_ our ~name~ variable in a string.

  * For the transformation from string to ~TokenStream~, we can use ~parse~.
    We expect this to work, so we just use an ~unwrap~ on the ~Result~ that our
    parsing returns.

- Compilation speed is a reason why you might want to *opt out* of using ~syn~.
  While it is a very powerful library, it is also big and slow to compile.

  * So
    _IF_ our example was a real macro, and we _ONLY_ needed the _name_ of the
    struct/enum, our naive example would compile *a lot faster*.

  * Several libraries try to offer a *lightweight alternative* to ~syn~ --
    ~venial~ (https://github.com/PoignardAzur/venial), for example.
    =TODO: Other libraries???=

  * Listing 3.12 Using a lightweight parser like ~venial~
    #+begin_src rust
      use quote::quote;
      use proc_macro::TokenStream;
      use venial::{parse_declaration, Declaration, Struct, Enum};

      #[proc_macro_derive(Hello)]
      pub fn hello(item: TokenStream) -> TokenStream {
          let declaration = parse_declaration(item.into()).unwrap();

          let name = match declaration {
              Declaration::Struct(Struct { name, .. }) => name,
              Declaration::Enum(Enum { name, .. }) => name,
              _ => panic!("only implemented for struct and enum")
          };

          let add_hello_world = quote! {
              impl #name {
                  fn hello_world(&self) {
                      println!("Hello, World")
                  }
              }
          };

          add_hello_world.into()
      }

    #+end_src
    + From the AUTHOR:
      Even in this simple example, build times measured with cargo ~build --timings~
      *DROP from 3.1 seconds to 1.8 on my machine*.

    + =IMPORTANT=
      Once you are familiar with how it handles the ~TokenStream~ parsing,
      switching to a lightweight alternative should not be too hard: many of the
      parsing concepts are always the same.

** 3.7 From the real world - 54
1. The developers of Rocket (https://rocket.rs/) are actually kind enough to
   _TEACH_ you that /macros/ can be imported in two ways (the ones we described
   in this chapter):
   #+begin_src rust
     //! And to import all macros, attributes, and derives via `#[macro_use]`
     //! in the crate root:
     //!
     //! ```rust
     //! #[macro_use] extern crate rocket;
     //! # #[get("/")] fn hello() { }
     //! # fn main() { rocket::build().mount("/", routes![hello]); }
     //! ```
     //!
     //! Or, alternatively, selectively import from the top-level scope:
     //!
     //! ```rust
     //! # extern crate rocket;
     //!
     //! use rocket::{get, routes};
     //! # #[get("/")] fn hello() { }
     //! # fn main() { rocket::build().mount("/", routes![hello]); }
     //!
   #+end_src

2. You may also be wondering
   * Q :: _HOW_ the /standard library/ _parses_ and _outputs_ /macros/,
          since it cannot use external libraries like ~syn~ and ~quote~.

   * A :: Instead, the standard library uses built-ins with similar concepts and
          names.

     + For example,
       - ~rustc_ast~, the /Rust abstract syntax tree/, is used for *parsing input*.
       - ~rustc_expand~, *outputting* code is done with it.
       - ~rustc_span~ contains utilities like ~Ident~ and ~Span~.

     It is both familiar and alien when you are used to working with ~syn~
     and ~quote~. *But it is not meant for external usage.*

3. SINCE /procedural macros/ have to be placed in a library, in the root of the
   crate,

   =lib.rs= is a great starting point for exploring other people's /procedural macro/ code.

   You will see what macros they have and can dig in when needed.

** TODO 3.8 Exercises - 55
*** TODO Summary

* TODO 4 Making fields public with attribute macros - 57
- This chapter covers
  * Understanding the _DIFFERENCES_ between /derive macros/ and /attribute macros/

  * Finding /field/ information in the /abstract syntax tree/

  * Retrieving /fields/ by using matching

  * Retrieving /fields/ with a custom struct =???=

  * Retrieving /fields/ with a custom struct and a ~Parse~ implementation

  * Adding multiple outputs in ~quote~

  * Debugging macros with log statements

  * Understanding the no-panic crate

- Chapter target macro:
  * _BACKGROUND_:
    Rust likes to hide information.
    A /function/, /struct/, or /enum/ is _private by default_, and the same goes
    for the /fields/ of a /struct/.

  * _QUESTION_:
    "information hiding," a primary reason for keeping /fields/ in a
    struct/class private, is not applicable when your _ONLY value is exposing
    the information contained in fields._

    Sometimes, you need to define a /struct/ ONLY as a data wrapper, for
    example, /Data Transfer Objects (DTOs)/.

  * _PLAN_:
    1. Make a ~strcut~ _public_.
    2. Make each field of this ~strcut~ _public_.

- To resolve this chapter target macro, We need to modify what is already there.
  So /derive macros/ are out, and /attribute macros/ are in.

- Writing the library and code for an /attribute macro/ is _QUITE SIMILAR_ to
  creating a /derive macro/. But there are DIFFERENCES as well:
  * an /attribute macro/ also receives a ~TokenStream~ containing additional
    attributes (if any).
    + =from Jian= Example
      #+begin_src rust
        #[proc_macro_attribute]
        pub fn name_of_the_attribute(attr: TokenStream, item: TokenStream) -> TokenStream {
            ...
        }
      #+end_src

  * And, more importantly for this chapter, its output tokens will *replace*
    the input.

** 4.1 Setup of an attribute macro project - 58
- Figure 4.1 The signature of an attribute macro

** 4.2 Attribute macros vs. derive macros - 59
** 4.3 First steps in public visibility - 60
** 4.4 Getting and using fields - 61
- The type works because /attribute macro/ and /derive macro/ _SHARE_ some
  important input targets:
  * /structs/
  * /enums/
  * /unions/

- While /attribute macros/ can also target /traits/ and /functions/,
  that's _NOT_ currently important to us.
  * If you prefer a more fitting type, ~syn::ItemStruct~ should be a drop-in
    replacement, but it does have the downside that it is hidden behind the
    ~"full"~ feature flag. So we would need to change our ~syn~ import to use
    it.

- ~DeriveInput~:
  #+begin_src rust
    pub struct DeriveInput {
        pub attrs: Vec<Attribute>,
        pub vis: Visibility,
        pub ident: Ident,
        pub generics: Generics,
        pub data: Data,
    }
  #+end_src
  * ~Data~
    #+begin_src rust
      pub enum Data {
          Struct(DataStruct),
          Enum(DataEnum),
          Union(DataUnion),
      }
    #+end_src
    + ~DataStruct~
      #+begin_src rust
        pub struct DataStruct {
            pub struct_token: Token![struct],
            pub fields: Fields,
            pub semi_token: Option<Token![;]>,
        }
      #+end_src

- Figure 4.2 Finding the roots of the world tree: from DeriveInput to Fields for
  our Example struct

** 4.5 Possible extensions - 66
- There are lots of ways we could now *EXTEND* our macro to make it _more useful_.
  For example,
  * Make our macro work for ~enum~.

    + Do remember that the /variants/ of an /enum/ are *AUTOMATICALLY public*
      _when the enum itself is public_, meaning it is probably easier to just add
      ~pub~ to an /enum/ rather than using a custom macro.

  * Handle /unamed fields/ in tuple struct.

  * Handle to structs like ~struct Empty;~.

  * There are a few more potential problems (besides not handling /Unions/).
    For example, our macro won't make fields of nested structs public. As luck
    would have it, just adding ~#[public]~ to the nested items is an easy fix.
    =from Jian= I also think this is the right way: manually do this.

  * The way we use until will strip all other attributes, which is bad.
    + Try adding a ~#[derive(Debug)]~ below our annotation and running
      ~cargo expand~. Do you see how the additional annotation vanishes into
      thin air?

    + *As /macros/ are executed in order, from top to bottom,*
      =Temporary solution, not a fundamental one:=
      the simple workaround is adding the derive _ABOVE_ our ~#[public]~.
      Now everything will work as expected. Except—please do not do this.

      - _INSTEAD_,
        do things the proper way and
        1. retrieve and
        2. reattach
        all the available attributes

  * Handle the /generics/ in /structs/ and /enums/.

- =from Jian=
  Use in-place way, most of the above cases can be handled automatically.
  See my solution in _Exercises_.

** 4.6 More than one way to parse a stream - 67
A more "struct-focused" approach.

*** 4.6.1 Delegating tasks to a custom struct - 67
- Start by adding a dependency to _proc-macro2_, which we will need shortly.

- Listing 4.10 Two familiar dependencies in our library toml file and a new one
  #+begin_src rust
    [dependencies]
    quote = "1.0.33"
    syn = "2.0.39"
    proc-macro2 = "1.0.69"
  #+end_src

- Now take a look at the new implementation. *There are two big changes*:
  * _INSTEAD OF_ using the primitives from ~syn~ directly,
    we have our /struct/ *gather/organize* all required information (i.e., name
    and type).
    + By convention,
      1. a /method/ called ~new~ should be used for _creating a struct_, so we
         create one and call it when iterating over our fields.

      2. ~map(StructField::new)~ is a convenient shorthand -- also known as point-free
         style -- for ~map(|f| StructField::new(f))~.

- _Listing 4.11 An implementation that uses structs to do most of the gluing_
  #+begin_src rust
    use proc_macro::TokenStream;
    use quote::{quote, ToTokens};
    // previous imports

    struct StructField {
        name: Ident,
        ty: Type,
    }

    impl StructField {
        fn new(field: &Field) -> Self {
            Self {
                name: field.ident.as_ref().unwrap().clone(),
                ty: field.ty.clone(),
            }
        }
    }

    impl ToTokens for StructField {
        fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {
            let n = &self.name;
            let t = &self.ty;
            quote!(pub #n: #t).to_tokens(tokens)
        }
    }

    #[proc_macro_attribute]
    pub fn public(_attr: TokenStream, item: TokenStream) -> TokenStream {
        // unchanged: get fields
        let builder_fields = fields.iter().map(StructField::new);
        // unchanged: quote for output
        // ...
    }
  #+end_src
  ~quote~ doesn't automatically know how to transform ~StructField~ into
  ~TokenStream~, and _this is why we need ~impl ToTokens for StructField~._

- This is more code -- and complexity -- than we had before, but there are positives
  as well:
  * There is a _separation of concerns_: we have made a struct responsible for
    the retrieval and outputting of a field.

  * This can _enable reuse_ and could prove to be _more readable and structured_.
    + In this basic example, it is probably overengineering, but some structuring
      of data into structs might prove useful in a bigger procedural macro.
      =from Jian= This is a book for education, and this a way we need to know.

*** 4.6.2 Implementing the ~Parse~ trait - 69 =TODO: learn more about APIs mentioned in this section=
- We could go one step further and incorporate an additional built-in from ~syn~,
  the ~Parse~ /trait/, which is used for changing a ~TokenStream~ into a /struct/
  or /enum/.

  In the next code listing, we add an implementation of this /trait/ and its
  /method/ ~parse~, which receives ~syn::parse::ParseStream~ as ~input~. Just
  think of that as a sort of ~TokenStream~.

- Listing 4.12 Parsing instead of using new
  #+begin_src rust
    // imports

    struct StructField {
        name: Ident,
        ty: Ident, // #1
    }

    // ToTokens implementation remains unchanged

    impl Parse for StructField { // #2
        fn parse(input: ParseStream) -> Result<Self, syn::Error> {
            let _vis: Result<Visibility, _> = input.parse(); // #3
            let list = Punctuated::<Ident, Colon>::parse_terminated(input)
                .unwrap(); // #4

            Ok(StructField {
                name: list.first().unwrap().clone(), // #5
                ty: list.last().unwrap().clone(),
            })
    }

    #[proc_macro_attribute]
    pub fn public(_attr: TokenStream, item: TokenStream) -> TokenStream {
        // unchanged
        let builder_fields = fields.iter() // #6
            .map(|f| {
                syn::parse2::<StructField>(f.to_token_stream())
                    .unwrap()
            });
        // unchanged
    }
  #+end_src
  1. Instead of ~Type~, ~ty~ is now an ~Ident~, because that is what we are
     receiving from our ~Parse~.

  2. The ~new~ method has been made redundant by ~parse~.

  3. We try to parse the visibility into a variable of type ~Result<Visibility, _>~
     to get rid of it, _moving the pointer to the next token._

  4. A field without visibility is a kind of ~Punctuated~,
     so we call ~parse_terminated~ to parse the rest of the field.

  5. The first element should be the name and
     the type should be last.
     Because we parsed the field as identifiers separated by a colon, ~ty~ is now
     ~Ident~.

  6. Iterates over the fields and uses ~parse2~.
     The ~Result~ might be any number of things, so we have to say that we want
     a ~StructField~.

- _NOTE_: =IMPORTANT=
  Perhaps you thought visibility was an optional part of the field definition,
  which is certainly what I used to think.

  But look back at the AST diagrams and source code:
  ~ParseStream~ always has a ~Visibility~.
  * By default, it's just ~Inherited~, which, according to the documentation,
    "usually means private."

- *CAUTION*:
  Here the code in Listing 4.12 assume named fields, which is not always true.

- =IMPORTANT=
  _NOTE_:
  * Q :: Why ~parse2~?
  * A ::
    + ~parse~ also exists and is very similar, but it accepts an _ORDINARY_
      ~TokenStream~,
    + whereas ~parse2~ takes the ~proc_macro2~ variant (hence the names).

  * By the way, ~parse_macro_input!~ is just /syntactic sugar/ for ~parse~.

- =TODO: NEXT SECTION=
  ~.map(|f| parse2::<StructField>(f.to_token_stream())~ is _NOT GREAT_, though.
  We have some nicely parsed data from ~syn~, and we are turning it back into a
  ~TokenStream~.

  =IMPORTANT=
  You could *AVOID* this ugliness by, for example, _parsing all the fields (or
  the entire input)_ into custom structs instead of parsing every individual
  field.

*** 4.6.3 Going low, low, low with cursor - 71
- As a final example, we could also have chosen ~cursor~ for *low-level control*
  over our parsing:
  #+begin_src rust
    impl Parse for StructField {
        fn parse(input: ParseStream) -> Result<Self, syn::Error> {
            let first = input.cursor().ident().unwrap();

            let res = if first.0.to_string().contains("pub") {
                let second = first.1.ident().unwrap();
                let third = second.1.punct().unwrap().1.ident().unwrap();
                Ok(StructField {
                    name: second.0,
                    ty: third.0,
                })
            } else {
                let second = first.1.punct().unwrap().1.ident().unwrap();
                Ok(StructField {
                    name: first.0,
                    ty: second.0,
                })
            };

            let _: Result<proc_macro2::TokenStream, _> = input.parse();
            res
        }
    }
  #+end_src
  * The final ~let _: Result<proc_macro2::TokenStream, _> = input.parse();~ is
    tricky, though.

    ~cursor~ is giving us _IMMUTABLE access_ to the existing stream.

    + This is great, *EXCEPT* that after calling your parsing method, ~parse2~
      does a check to make sure there's nothing left unhandled inside your stream.

    + And, in our case, we did not -- could not, even -- change anything, so we
      will get a confusing ~Error("unexpected token")~ error. So we just call
      ~parse~ and make it give back a ~Result~, which we ignore. This is a bit
      similar to ignoring the visibility in our previous example (listing 4.12).

- What style should you prefer? It depends.

  * *Functions and matching* are relatively easy and seem ideal for smaller macros
    or writing a proof of concept.

  * *Structs* can give additional structure to your solution and offer a nice way
    to *delegate responsibility*:
    every struct does a bit of the parsing and outputting.

    + They are also very useful when you are passing things into macros that do
      _not count as proper Rust code, like DSLs._

    + Default parsers are obviously not well equipped to deal with seemingly
      random input that only has meaning within your particular domain. So
      instead, you write your own /structs/ and capture relevant information.

  * ~cursor~, meanwhile, gives *low-level control* and a lot of power, but it is
    _VERBOSE and LESS EASY TO USE_. *It should probably NOT be your FIRST CHOICE.*

- In this book, many chapters focus on _functions as the glue for building macros,_
  BECAUSE this style is convenient for brief examples.

  _BUT_
  BECAUSE structs are often used "in the wild," we will also have examples using
  that style.

** 4.7 Even more ways to develop and debug - 72
- We learned ~cargo expand~.

- ~syn = { version = "2.0.39", features=["extra-traits"]}~,
  and then you can do ~eprintln!("{:#?}", &ast);~
  * =from Jian=
    You can use the output to debug and learn the structure of your specific
    token stream.

** TODO 4.8 From the real world - 73
** DONE 4.9 Exercises - 76
CLOSED: [2024-09-20 Fri 23:15]
- Follow the hints from the author and the code provided by the author is good
  for study. This is works perfect for both /dervie macro/ and /attribute
  macro/.
  _HOWEVER_, since /attribute macro/ need modify existing code, do in-place
  modification may make the code concise. Here is my solution:
  #+begin_src rust
    use quote::quote;
    use proc_macro::TokenStream;
    use syn::spanned::Spanned;
    use syn::token::Pub;
    use syn::{parse_macro_input, DataStruct, DeriveInput, Visibility};
    use syn::Data::{Enum, Struct};

    #[proc_macro_attribute]
    pub fn public(_attr: TokenStream, item: TokenStream) -> TokenStream {
        let make_pub = |v: &mut Visibility| {
            *v = Visibility::Public(Pub(v.span()))
        };
        let mut ast = parse_macro_input!(item as DeriveInput);
        // Modify whole item accessibility
        make_pub(&mut ast.vis);
        // Modify item struct fields or enum variants accessibility
        match ast.data {
            Struct(
                DataStruct {
                    ref mut fields, ..
                }
            ) => fields.iter_mut().for_each(|f| {
                make_pub(&mut f.vis);
            }),
            Enum(_) => (),
            _ => unimplemented!("only works for structs with named fields"),
        }
        (quote! { #ast }).into()
    }
  #+end_src

*** Summary
- *LIKE* /derive macros/, /attribute macros/ can be used on /enums/, /structs/, and
  /unions/.
  ADDITIONALLY, they can be added to /traits/ and /functions/.

- *UNLIKE* /derive macros/, /attribute macros/ *overwrite* their input, making it
  possible to change existing code.

- /Attribute macros/ get their name from defining a new custom attribute.

- We can use the ~syn~ parsing result (our AST) to retrieve all kinds of information,
  like the /fields/ of a /struct/.

- ~quote~ allows us to *combine* multiple token streams *into* a single output.

- We can use /matching/ and /functions/ to *glue* together our parsing and outputting.

- For more structure and larger macros,
  you might consider
  1. creating custom structs and
  2. delegating the parsing and outputting to them.

* TODO 5 Hiding information and creating mini-DSLs with function-like macros - 78 - _START HERE_
- This chapter covers
  * Hiding information to improve code
  * Using /function-like macros/ to modify and extend code
  * Using /function-like macros/ to manipulate /structs/ and /functions/
  * *Debugging* /macros/ by getting the compiler or IDE to help you
  * Writing DSLs with flexible /function-like macros/
  * Deciding what /macro/ fits a use case

** 5.1 Hiding information - 79
*** 5.1.1 Setup of the information-hiding macro - 79
*** 5.1.2 Recreating the ~struct~ - 81
*** 5.1.3 Generating the helper methods - 83

** 5.2 Debugging by writing normal code - 88
** 5.3 Composing - 89
** 5.4 Anything you can do, I can do better - 93
** 5.5 From the real world - 94
** 5.6 Exercises - 96
*** Summary

* TODO 6 Testing a builder macro - 97
- This chapter covers
  * Writing a /derive macro/ that will generate a builder for /structs/

  * Creating /white-box tests/ to verify the behavior of functions within your
    /macro/

  * Using /black-box tests/ that take an outside view of your code

  * Deciding what types of tests are most useful for your /macro/

** 6.1 Builder macro project setup - 99
** 6.2 Fleshing out the structure of our setup - 101
** 6.3 Adding white-box unit tests - 103
** 6.4 Black-box unit tests - 105
*** 6.4.1 A happy path test - 105
*** 6.4.2 A happy path test with an actual property - 107
*** 6.4.3 Testing enables refactoring - 112
*** 6.4.4 Further improvements and testing - 116
*** 6.4.5 An alternative approach - 119
*** 6.4.6 Unhappy path - 122

** 6.5 What kinds of unit tests do I need? - 123
** 6.6 Beyond unit tests - 124
** 6.7 From the real world - 126
** 6.8 Exercises - 127

* TODO 7 From panic to result: Error handling - 128
- This chapter covers
  * Understanding the _DIFFERENCE_ between /pure and impure functions/
  * Understanding the _DOWNSIDES_ of _breaking control flow_
  * Using ~Result~ for better error handling
  * Writing macros to manipulate /function signatures/ and /return values/
  * Mutating the received ~TokenStream~ as an alternative to creating a new one
  * Creating better error messages with ~syn::Error~ or ~proc_macro_error~

** 7.1 Errors and control flow - 129
** 7.2 Pure and impure functions - 130
** 7.3 Alternatives to exceptions - 132
** 7.4 Rust's ~Result~ and panics - 135
** 7.5 Setup of the panic project - 137
** 7.6 Mutable or immutable returns - 139
** 7.7 Getting results - 140
** 7.8 Don't panic - 145
*** 7.8.1 Changing the ~panic~ into a ~Result~ - 145
*** 7.8.2 Debugging observations - 148

** 7.9 Error-handling flavors - 149
*** 7.9.1 Using ~syn~ for error handling - 150
*** 7.9.2 Using ~proc_macro_error~ for error handling - 155
*** 7.9.3 Deciding between ~syn~ and ~proc_macro_error~ - 159

** 7.10 From the real world - 159
** 7.11 Exercises - 162
*** Summary

* TODO 8 Builder with attributes - 163
- This chapter covers
  * Working with /field-level custom attributes/ to *RENAME* /methods/
  * Using /root-level custom attributes/ to *DECIDE* on error handling
  * Making a builder easier to use with /type state/ =???=
  * Exploring _HOW_ /derive and attribute macros/ DIFFER
  * Parsing (document) attributes inside /function-like macros/

** 8.1 A rename attribute - 164
*** 8.1.1 Testing the new attribute - 164
*** 8.1.2 Implementing the attribute's behavior - 165
*** 8.1.3 Parsing variations - 168

** 8.2 Alternative naming for attributes - 170
** 8.3 Sensible defaults - 173
** 8.4 A better error message for defaults - 177
** 8.5 Build back better - 179
*** 8.5.1 Avoiding illegal states and the type state pattern - 179
*** 8.5.2 Combining the builder pattern with type state - 182

** 8.6 Avoiding scattered conditionals - 190
** 8.7 Attribute tokens and attributes - 192
** 8.8 Other attributes - 197
** 8.9 From the real world - 199
** 8.10 Exercises - 201
*** Summary

* TODO 9 Writing an infrastructure DSL - 203
- This chapter covers
  * _Grasping_ the ideas behind /Infrastructure as Code/

  * _Parsing_ a custom syntax with /structs/ and keywords

  * Thinking about parsing _tradeoffs_

  * _Avoiding duplication_ by *combining* /procedural and declarative macros/

  * _CALLING_ /asynchronous functions/ in a /macro/ and
    _CREATING_ cloud resources

** 9.1 What is IaC? What is AWS? - 204
** 9.2 How our DSL works - 205
** 9.3 Parsing our input - 207
*** 9.3.1 Project setup and usage examples - 207
*** 9.3.2 Implementing the ~Parse~ trait for our structs - 209

** 9.4 Two alternative parsing approaches - 215
*** 9.4.1 Using ~Punctuated~ with a custom ~struct~ - 215
*** 9.4.2 Using ~Punctuated~ with a custom ~enum~ and builder - 218

** 9.5 Actually creating the services - 221
** 9.6 The two AWS clients - 225
** 9.7 Errors and declarative macros - 229
** 9.8 The right kind of testing - 231
** 9.9 From the real world - 231
** 9.10 Exercises - 234
*** Summary

* TODO 10 Macros and the outside world - 235
- This chapter covers
  * Using a single library to expose MULTIPLE /macros/
  * _ADDING_ or _DISABLING_ functionality with /features/ =TODO: !!!=
  * Using /attributes/ for control over what code will be generated  =TODO: !!!=
  * Documenting and publishing a /macro library/
  * Moving on to explore interesting macro subjects _beyond this book_

** 10.1 A function-like configuration macro - 236
*** 10.1.1 Macro project structure - 236
*** 10.1.2 Code overview - 237
*** 10.1.3 Using full paths - 240

** 10.2 Adding another macro - 242
** 10.3 Features - 243
** 10.4 Documenting a macro - 248
** 10.5 Publishing our macro - 250
** 10.6 From the real world - 253
** 10.7 Where to go from here - 258
** 10.8 Exercises - 258
*** Summary

* TODO appendix Exercise solutions - 259
** Chapter 2
** Chapter 3
** Chapter 4
** Chapter 5
** Chapter 6
** Chapter 7
** Chapter 8
** Chapter 9
** Chapter 10

* index - 291
