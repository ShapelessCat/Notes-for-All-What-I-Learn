#+TITLE: Effective Rust
#+AUTHOR: David Drysdale
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* DONE Preface - v
CLOSED: [2024-12-09 Mon 17:42]
** Rust Version - vi
2018 and 2021

* TODO 1. Types - 1
This first chapter of this book covers advice that revolves around Rust's type
system.

- One core part of this is /Rust's ~enum~ type/ allows for /algebraic data types/.

- The Items in this chapter cover
  1. the fundamental types that the language provides and
  2. how to combine them into data structures that precisely express the
     semantics of your program.

- This chapter also describes some of the ubiquitous data structures that are
  provided by Rust's standard library:
  * ~Option~
  * ~Result~
  * ~Error~
  * ~Iterator~

- Note that Items that involve Rust /traits/ are covered in the following
  chapter, but there is necessarily a degree of overlap with the Items in this
  chapter, because _/traits/ describe the behavior of /types/._

** DONE Item 1: Use the type system to express your data structures - 2
CLOSED: [2024-12-15 Sun 16:27]
*** Fundamental Types - 2
*** Aggregate Types - 4
- Arrays
- Tuples
- Structs

*** ~enum~'s - 5
#+begin_src rust
  enum HttpResultCode {
      Ok = 200,
      NotFound = 404,
      Teapot = 418,
  }
#+end_src

- Use it to improve readability and maintainability:
  Improve
  ~print_page(/* both_sides = */ true, /* color */ false);~
  by introducing enums:
  #+begin_src rust
    pub enum Sides {
        Both,
        Single,
    }

    pub enum Output {
        BlackAndWhite,
        Color,
    }

    pub fn print_page(sides: Sides, color: Output) {
        // ...
    }
  #+end_src

  * Using the ~newtype pattern~ - see Item 6 - to wrap a ~bool~ also achieves
    type safety and maintainability; it's generally best to use the /newtype
    pattern/ if the semantics will always be _Boolean_, and to use an enum if
    there's a chance that a new alternative—e.g.,
    ~Sides::BothAlternateOrientation~ - could arise in the future.

- Footnote 3:
  =TODO=: Item 21 - ~non_exhaustive~ enum.

*** ~enum~'s with Fields - 7
_The true power of Rust's enum feature_
comes from
the fact that _each /variant/ can have data that comes along with it,_ making it
an /aggregate type/ that acts as /an algebraic data type (ADT)/.

- Use _enum with fields_ to *make invalid states inexpressible in your types*.

  * Undesired behavior
    #+begin_src rust
      pub struct DisplayProps {
          pub x: u32,
          pub y: u32,
          pub monochrome: bool,
          // `fg_color` must be (0, 0, 0) if `monochrome` is true.
          pub fg_color: RgbColor,
      }
    #+end_src

  * Fixed
    #+begin_src rust
      pub enum Color {
          Monochrome,
          Foreground(RgbColor),
      }
      pub struct DisplayProps {
          pub x: u32,
          pub y: u32,
          pub color: Color,
      }
    #+end_src

  =from Jian=:
  I think many famous Rust libraries like ~syn~ doesn't do this!!!

*** Ubiquitous ~enum~ Types - 8
**** ~Option<T>~ - 9
Use this type and never fall back to using sentinel values like ~-1~ or
~nullptr~ in C++.

**** ~Result<T, E>~ - 9
- Q :: If a function fails, how should that failure be reported?
- A :: Historically, special sentinel values (e.g., -errno return values from
       Linux system calls) or global variables (~errno~ for POSIX systems) were
       used.

** DONE Item 2: Use the type system to express common behavior - 10
CLOSED: [2024-12-16 Mon 22:23]
_Item 1_ discussed *how to express data structures in the /type system/;*
_this Item_ moves on to discuss *the encoding of _behavior_ in Rust's type
system*.

- The mechanisms described in this Item will generally feel familiar, as they all
  have direct analogs in other languages:

  * /Functions/

  * /Methods/

  * /Function pointers/ =???=
    Supported by most languages in the C family, including C++ and Go, as a
    mechanism that allows an extra level of indirection when invoking other code.

  * /Closures/

  * /Traits/

  Of course, all of these mechanisms have Rust-specific details that this Item
  will cover.

- Of the preceding list, /traits/ have the most significance for this book.
  _Chapter 2_ focuses on Items that give advice on _designing and implementing
  traits_, but their pervasiveness means that they crop up frequently in the
  other Items in this chapter too.

*** DONE Functions and Methods - 10
CLOSED: [2024-12-15 Sun 21:17]
*** DONE Function Pointers - 12 - =TODO: Read the book corresponding section=
CLOSED: [2024-12-15 Sun 22:35]
- /Functions/ and /methods/ have their names, but they can't vary at runtime.

- To satisfy the requirement of varying at runtime, /function pointer/ is a
  solution.

- Function Pointer :: a pointer to (just) some code, with a type that reflects
  the signature of the function.
  * Example 1:
    #+begin_src rust
      fn sum(x: i32, y: i32) -> i32 {
          x + y
      }

      fn sub(x: i32, y: i32) -> i32 {
          x - y
      }
      // Explicit coercion to `fn` type is required...
      let mut op: fn(i32, i32) -> i32 = sum;
      // ...
      op = if condition {
          sum
      } else {
          sub
      }
      // ...
    #+end_src

  * Example 2:
    #+begin_src rust
      // `fn` types implement `Copy`
      let op1 = op;
      let op2 = op;

      // `fn` types implement `Eq`, this compile, but the compiler will warning you.
      // It suggests to use the std::ptr::fn_addr_eq function.
      assert!(op1 == op2);

      // `fn` implements `std::fmt::Pointer`, used by the {:p} format specifier.
      println!("op = {:p}", op);
      // Example output: "op = 0x101e9aeb0"
    #+end_src

- =IMPORTANT=
  One technical detail to _WATCH OUT FOR_:
  *explicit coercion to a ~fn~ type is needed*,
  because just using the name of a function doesn't give you something of ~fn~
  type:
  =DOES NOT COMPILE!!!=
  #+begin_src rust
    let op1 = sum;
    let op2 = sum;

    // Both op1 and op2 are of a type that cannot be named in user code,
    // and this internal type does not implement `Eq`.
    assert!(std::ptr::fn_addr_eq(op1, op2));
  #+end_src
  Instead, the _compiler error_ indicates that the type is something like
  ~fn(i32, i32) -> i32 {main::sum}~, *a type that's entirely internal to the
  compiler (i.e., could not be written in user code)* and that identifies the
  specific function as well as its signature.

  To put it another way, the type of ~sum~ encodes both
  * _the function's signature_ and
  * its _location_
  *for optimization reasons*; this type can be AUTOMATICALLY coerced (Item 5) to
  a ~fn~ type.
  
*** DONE Closures - 13
CLOSED: [2024-12-15 Sun 23:26]
- The bare /function pointers/ are limiting,
  BECAUSE the _only inputs_ available to the invoked function are those that are
  _explicitly passed as parameter values_.
  * Example:
    #+begin_src rust
      // In real code, an `Iterator` method would be more appropriate.
      pub fn modify_all(data: &mut [u32], mutator: fn(u32) -> u32) {
          for value in data {
              *value = mutator(*value);
          }
      }

      fn add2(v: u32) -> u32 {
          v + 2
      }

      let mut data = vec![1, 2, 3];
      modify_all(&mut data, add2);
      assert_eq!(data, vec![3, 4, 5]);
    #+end_src

  However, a /function pointer/ can't rely on any addtional state from the
  environment.

  =DOES NOT COMPILE=
  #+begin_src rust
    let amount_to_add = 3;

    fn add_n(v: u32) -> u32 {
        v + amount_to_add
    }

    let mut data = vec![1, 2, 3];
    modify_all(&mut data, add_n);
    assert_eq!(data, vec![3, 4, 5]);
  #+end_src
  The compilation error tells you you can use /closure/.

- A /closure/ can capture parts of the environment around it.

- A /closure/ can't be used where a /function pointer/ is explicitly expected.
  Use generics and the right bound can make your function accept both /closure/
  and /function pointer/.
  * Example:
    #+begin_src rust
      pub fn modify_all<F>(data: &mut [u32], mut mutator: F)
      where
          F: FnMut(u32) -> u32,
      {
          for value in data {
              ,*value = mutator(*value);
          }
      }
    #+end_src

- Rust has three different traits, which between them express some distinctions
  around this environment-cpaturing behavior:
  * ~FnOnce~, often combined with ~move~
  * ~FnMut~
  * ~Fn~

  The compiler *AUTOMATICALLY implements* the appropriate subset of these ~Fn*~
  traits for any lambda expression in the code; *it's NOT possible* to manually
  implement any of these traits (unlike C++'s ~operator()~ overload).
  * footnote4
    At least not in stable Rust at the time of writing.
    =from Jian: Keep an eye on this=
    The ~unboxed_closures~ and ~fn_traits~ experimental features may change this
    in the future.

- Any (not-~unsafe~) ~fn~ type automatically implements _ALL of the Fn* traits_,
  because it borrows nothing from the environment.

- As a result, when writing code that accepts /closures/, _use the most general
  Fn* trait that works_, to allow the greatest flexibility for callers.

*** DONE Traits - 17
CLOSED: [2024-12-16 Mon 22:23]
- The ~Fn*~ traits are more flexible than BARE /function pointers/,
  BUT
  they can still describe only the behavior of a single function, and even then
  only in terms of the function's signature.

- This section will talk about /traits/ in general.

- Prefer accepting /trait/ types over /concrete types/ if future flexibility is
  anticipated.

- =Important=
  _Use /marker traits/ to distinguish behaviors that cannot be expressed in the
  trait function signatures._

  * A /mark trait/ acts as a promise from the implementer.

  * For example,
    assume there is a ~Sort~ trait for sorting collections; an implementation
    might be *stable* (elements that compare the same will appear in the same
    order before and after the sort), but *there's no way to express this in the
    sort method arguments*.

    Define a /mark trait/, and then the implementer should use it. It is the
    implementer's duty to guarantee this.
    #+begin_src rust
      pub trait Sort {
          /// Rearrange contents into sorted order.
          fn sort(&mut self);
      }

      // Marker trait to indicate that a [`Sort`] sorts stably.
      pub trait StableSort: Sort {}
    #+end_src

- Once behavior has been encapsulated into Rust's type system as a trait, it can
  be used in _TWO ways_:
  * trait bound :: constrains what types are acceptable for a generic
    data type or function *at compile time*

  * trait object :: constrains what types can be stored or passed to a
    function *at runtime*

**** Trait bounds - 18
- The /trait bounds/ check happens at compile time, when the /generic/ is
  /monomorphized/.

- =IMPORTANT=
  The advice here is to use /trait bounds/ to express requirements on the types
  used in generics

  This is an easy advice to follow - the compiler will force you to comply with
  it regardless.

**** Trait objects - 19
- A /trait object/ is the other way to make use of the encapsulation defined by
  a trait, but here, different possible implementations of the trait are chosen
  _at /runtime/ rather than /compile time/._

  * This /dynamic dispatch/ is analogous to using /virtual functions/ in C++,
    and under the covers, Rust has “vtable” objects that are roughly analogous
    to those in C++.

- This _dynamic aspect_ of /trait objects/ also means that they always have to
  *be handled indirectly*, via
  * a /reference/ (e.g., ~&dyn Trait~) or
  * a pointer (e.g., ~Box<dyn Trait>~) of some kind.

  _REASON_:
  the *size* of _the object implementing the trait_ *isn't known at compile
  time* - it could be a giant struct or a tiny enum - so _there's *no way* to
  allocate the right amount of space for a bare /trait object/._

- =IMPORTANT=
- object safety ::
  Because of _Not knowing the size of the concrete object_, two contraints
  exists for /trait objects/
  * no use of ~Self~ in return type or arguments
    + _REASON_:
      the compiled-in-advance code that uses the /trait object/ would have no idea
      how big that ~Self~ might be.

  * no generic functions
    + _REASON_:
      A trait that has a /generic function/ ~fn some_fn<T>(t:T)~ allows for the
      possibility of an *infinite number of implemented functions*, for all of the
      different types ~T~ that might exist.

      This is fine for a trait used as a /trait bound/ because of
      /monomorphization/ _at compile time_, but this is not fine for /trait
      object/: the code available at compile time has to cope with all possible
      ~T~'s that might arrive _at runtime_.

** DONE Item 3: Prefer ~Option~ and ~Result~ transforms over explicit ~match~ expressions - 20
CLOSED: [2024-12-17 Tue 00:38]
- ~Result~ also has a ~#[must_use]~ attribute to nudge library users in the
  right direction. This means use
  #+begin_src rust
    let _ = ...
  #+end_src
  to bind a ~Result~ value but not using it triggers a _compilation warning_.

- ~.map_err()~
  or
  simply error type conversion with ~From~ if it has been implemented.

- =IMPORTANT=
  Figure 1-1. Option and Result transformations

- ~as_ref()~ method on ~Option~.
  * footnote8:
    Note that this method is separate from the ~AsRef~ trait, even though the
    method name is the same.

*** Things to Remember - 25

** TODO Item 4: Prefer idiomatic ~Error~ types - 25 - =TODO: take notes=
The last Item stopped short of discussing
_HOW BEST TO HANDLE the variety of different error types ~E~ that arise as the
second type argument of a ~Result<T, E>~;_
that's the subject of this Item

*This is relevant only when there are a variety of _DIFFERENT error types_ in
play.*

*** The Error Trait - 26
*** Minimal Errors - 26
*** Nested Errors - 29
Library ~thiserror~

*** Trait Objects - 31
Library ~anyhow~

*** Libraries Versus Applications - 33
*** Things to Remember - 33

** DONE Item 5: Understand type conversions - 34
CLOSED: [2024-12-26 Thu 16:02]
- /Rust type conversions/ fall into THREE categories:
  * _Manual_: User-defined type conversions provided by implementing the ~From~
    and ~Into~ traits

  * _Semi-automatic_: Explicit casts between values using the ~as~ keyword

  * _Automatic_: Implicit coercion into a new type

- The majority of this Item _FOCUSES ON the *first* of these_, manual
  conversions of types,
  BECAUSE
  the latter two mostly don't apply to conversions of user-defined types.

  * There are a couple of _EXCEPTIONS_ to this, so sections at the end of the
    Item discuss /casting/ and /coercion/ - INCLUDING
    _how they can apply to a user-defined type_.

- Note that in contrast to many older languages,
  _Rust does *NOT* perform AUTOMATIC conversion between /numeric types/._

*** DONE User-Defined Type Conversions - 34
CLOSED: [2024-12-26 Thu 15:45]
As with other features of the language (Item 10),
_the ability to PERFORM CONVERSIONS between values of different user-defined
types is encapsulated as a set of related /generic traits/._

- For 4 relevant traits:
  * ~From<T>~
  * ~TryFrom<T>~
  * ~Into<T>~
  * ~TryInto<T>~

- If it's possible for a conversion to fail,
  1. the ~Try...~-prefixed traits are the first choice,
  2. ignore the possibility of error (e.g., with ~.unwrap()~) is an alternative,
     but that needs to be deliberate choice, and in most cases it's best to leave
     that choice to the caller.

- Symmetry:
  ~T~ can implement ~Into<U>~ <===> ~U~ can implement ~From<T>~.
  * Advice for ~impl~: implement the ~From~ trait for conversions.
  * Rust can automatically provide ~Into~ if a corresponding ~From~ is provided.
  * Advice for using as /bounds/:
    If you're consuming one of these two traits, as a trait bound on a new
    generic of your own, then the advice is reversed: _use the ~Into~ trait for
    trait bounds._
    + Rationale:
      That way, the /bound/ will be satisfied both by things that directly
      implement ~Into~ and by things that only directly implement ~From~.
      - =from Jian=
        This is also because the existence of the /blanket implementation/:
        #+begin_src rust
          impl<T, U> Into<U> for T
          where
              U: From<T>,
          {
              fn into(self) -> U {
                  U::from(self)
              }
          }
        #+end_src

        Since ~impl<T> From<T> for T~ exists, the ~U~ above can be ~T~.

- /Blanket implementation/ for ~TryFrom~ but infallible if ~Into~ in the
  opposite direction exists:
  #+begin_src rust
    impl<T, U> TryFrom<U> for T
    where
        U: Into<T>,
    {
        type Error = Infallible;

        #[inline]
        fn try_from(value: U) -> Result<Self, Self::Error> {
            Ok(U::into(value))
        }
    }
  #+end_src
  * footnote 13:
    For now - this is likely to be replaced with the ~!~ "never" type in a
    future version of Rust.

- How to make a /newtype/ behave likes its inner type:
  #+begin_src rust
    #[derive(Clone, Copy, Debug)]
    pub struct IanaAllocated(pub u64);

    impl From<u64> for IanaAllocated {
        fn from(v: u64) -> Self {
            Self(v)
        }
    }

    pub fn is_iana_reserved<T>(s: T) -> bool
    where
        T: Into<IanaAllocated>,
    {
        let s = s.into();
        s.0 == 0 || s.0 == 65535
    }

    let s = IanaAllocated(1);
    println!("{:?} reserved? {}", s, is_iana_reserved(s));
  #+end_src

- Rust code sometimes appears to be doing /implicit casts/ between types:
  the combination of ~From<T>~ implementations and ~Into<T>~ trait /bounds/
  leads to code that appears to magically convert at the call site (but is still
  doing *safe, explicit*, conversions under the covers).

*** DONE Casts - 38
CLOSED: [2024-12-26 Thu 15:54]
For _consistency and safety_, you should prefer ~from~ / ~into~ conversions over
~as~ casts, unless you understand and need the precise /casting semantics/ (e.g.,
for _C interoperability_).

=TODO= This advice can be reinforced by Clippy (Item 29),
which includes several lints about as conversions; however, these lints are
disabled by default.

- The ~as~ also allow /lossy conversions/, but ~Into~ and ~From~ doesn't.
  Only ~TryInto~ and ~TryFrom~ can be implemented for /lossy conversions/.

*** DONE Coercion - 39
CLOSED: [2024-12-26 Thu 16:02]
- The /explicit ~as~ casts/ described in the previous section are a *superset*
  of the /implicit coercions/ that the compiler will silently perform:
  _any coercion can be forced with an explicit ~as~, but the converse is not
  true._

- _MOST_ /coercions/ involve _SILENT conversions_ of /pointer/ and /reference/
  types in ways that are sensible and convenient for the programmer, such as
  converting the following:
  * A /mutable reference/ to an /immutable reference/ (so you can use a ~&mut T~
    as the argument to a function that takes a ~&T~)

  * A /reference/ to a /raw pointer/ (this *isn't* ~unsafe~ - the unsafety
    happens at the point where you're foolish enough to /dereference/ a raw
    /pointer/)

  * A /closure/ that happens to _NOT capture_ any variables into a bare /function
    pointer/ (Item 2)

  * An /array/ to a /slice/

  * A _concrete item_ to a /trait object/, for a ~trait~ that the concrete item
    implements

  * An item /lifetime/ to a "SHORTER" one (Item 14)
    + footnote 15:
      Rust refers to these conversions as "subtyping," but it's _quite different_
      from the definition of "subtyping" used in object-oriented languages.

** DONE Item 6: Embrace the newtype pattern - 40
CLOSED: [2024-12-27 Fri 15:10]
- Newtype pattern :: tuple structs that have only one no name field that holds
  exactly the same range of values as the enclosed type.
  * The simplest use of the /newtype pattern/ is to indicate additional
    semantics for a type.

- /Type aliases/ are effectively just documentation; they're a stronger hint
  than the doc comments of the previous version, but nothing stops misusing it
  -- /type aliases/ are for developer and documentation, not for Rust compiler,
  which can't help to check the additional semantics.

- Example:
  #+begin_src rust
    /// Units for force.
    pub struct PoundForceSeconds(pub f64);

    /// Fire the thrusters. Returns generated impulse.
    pub fn thruster_impulse(direction: Direction) -> PoundForceSeconds {
        // ...
        return PoundForceSeconds(42.0);
    }

    /// Units for force.
    pub struct NewtonSeconds(pub f64);

    /// Update trajectory model for impulse.
    pub fn update_trajectory(force: NewtonSeconds) {
        // ...
    }

    impl From<PoundForceSeconds> for NewtonSeconds {
        fn from(val: PoundForceSeconds) -> NewtonSeconds {
            NewtonSeconds(4.448222 * val.0)
        }
    }

    let thruster_force: PoundForceSeconds = thruster_impulse(direction);
    let new_direction = update_trajectory(thruster_force.into());
  #+end_src

- If *size efficiency* or *binary compatibility* is a concern, then the
  ~#[repr(transparent)]~ attribute ensures that a newtype has _the same
  representation in memory as the inner type._

*** DONE Bypassing the Orphan Rule for Traits - 43
CLOSED: [2024-12-27 Fri 14:32]
- The reason for the orphan rule restriction is due to the risk of ambiguity:
  if two different crates in the dependency graph (Item 25) were both to (say)
  ~impl std::fmt::Display~ for ~rand::rngs::StdRng~, then the compiler/linker
  has no way to choose between them.

- The orphan rule restriction can frequently lead to frustration:
  for example, if you're trying to _serialize data that includes a type from
  another crate_, the /orphan rule/ prevents you from writing
  ~impl serde::Serialize for somecrate::SomeType~.
  * Use /newtype pattern/ to achieve this:
    #+begin_src rust
      struct MyRng(rand::rngs::StdRng);

      impl fmt::Display for MyRng {
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
              write!(f, "<MyRng instance>")
          }
      }
    #+end_src

*** DONE Newtype Limitations - 18
CLOSED: [2024-12-27 Fri 15:10]
- The /newtype pattern/ solves these _TWO classes of problems_ -
  * preventing unit conversions
  * bypassing the orphan rule

  but it does come with some awkwardness:
  _every operation that involves the /newtype/ needs to *forward to* the /inner
  type/._

- Need to call methods on ~newtype.0~.
  * If you just refactor you code and use /newtype pattern/, the compiler can
    tell you where to use ~newtype.0~ rather than ~newtype~ itself.

- The more significant awkwardness is that _any trait implementations on the
  /inner type/ are lost_.
  * For /derivable traits/, newtype declaration ends up with lots of ~derive~'s.

  * For more sophisticated traits, some forwarding boilerplate is needed to
    recover the /inner type/'s implementation.
    + Implement a trait, and use ~newtype.0~ that implemented the same trait is
      a simple case.

** TODO Item 7: Use builders for complex types - 45
** TODO Item 8: Familiarize yourself with reference and pointer types - 51 - =Only Partial Note=
- _For programming in general_,
  a /reference/ is a way to indirectly access some data structure, separately
  from whatever variable owns that data structure.

  * _In practice_,
    this is usually implemented as a /pointer/: a number whose value is the
    _address in memory_ of the data structure.

- A modern CPU will typically police a few constraints on /pointers/ -
  the _memory address_
  * should be in a *VALID range of memory (whether virtual or physical)* and
  * *MAY* need to be *aligned* (e.g., a 4-byte integer value might be accessible
    _only if_ its address is a multiple of 4).

- However, _higher-level programming languages_ usually *encode more information
  about /pointers/ in their _type systems_.*

  * In C-derived languages, including Rust, /pointers/ have a /type/ that indicates
    + what kind of data structure is expected to be present at the pointed-to
      memory address.

    This allows the code to INTERPRET
    the CONTENTS of memory _at that address_ and _in the memory following that
    address_.

- This *BASIC* level of /pointer/ information -
  _putative memory location_ and
  _expected data structure layout_ - is represented in Rust as a /raw pointer/.

  However, _safe Rust_ code does *NOT use* /raw pointers/, because Rust provides
  richer reference and pointer types that provide additional safety guarantees
  and constraints.

- This Item discusses the /reference and pointer types/ used in _safe Rust_.
  * =TODO= /raw pointers/ are relegated to _Item 16_ (which discusses unsafe code).

*** DONE Rust References - 52
CLOSED: [2024-12-26 Thu 23:06]
- The most ubiquitous _pointer-like type_ in Rust is the /reference/, with a
  type that is written as ~&T~ for some type ~T~. Although this is *a pointer
  value under the covers*, the compiler _ENSURES that various rules around its
  use are observed_:
  * it MUST ALWAYS point to a _valid_, _correctly aligned_ instance of the
    relevant type ~T~,
    whose /lifetime/ (_Item 14_) extends beyond its use, and
    it must satisfy the /borrow checking rules/ (_Item 15_).

    + These additional constraints are always implied by the term /reference/ in
      Rust, and so the bare term pointer is generally rare.

    + /C++'s reference/ is similar, but no /lifetimes/.
      #+Comment: Undesired behavior
      #+begin_src cpp
        // C++
        const int& dangle() {
          int x = 32; // on the stack, overwritten later
          return x; // return reference to stack variable!
        }
      #+end_src

      #+Comment: Does NOT Compile
      #+begin_src rust
        fn dangle() -> &'static i64 {
            let x: i64 = 32; // on the stack
            &x
        }
      #+end_src

- The compiler
  CONVERTS Rust code that uses /references/
  INTO machine code that uses simple /pointers/, which are _eight bytes in size
  on a 64-bit platform (which this Item assumes throughout)_.

- A /Rust reference/ CAN refer to items that are located either on the /stack/
  or on the /heap/.

  * Rust allocates items _on the stack BY DEFAULT,_
    BUT the ~Box<T>~ pointer type (roughly equivalent to C++'s
    ~std::unique_ptr<T>~) FORCES /allocation/ to occur on the /heap/, which in
    turn means that _the allocated item can *outlive* the scope of the current
    block._

    _Under the covers_, ~Box<T>~ is also _a simple eight-byte pointer value_:
    #+begin_src rust
      let box_pt = Box::new(Point { x: 10, y: 20 });
    #+end_src

*** TODO Pointer Traits - 54
- ~DeRef~
- ~AsRef~ and ~AsMut~

*** TODO Fat Pointer Types - 56
Rust has _TWO_ *built-in* /fat pointer types/:
/slices/ and /trait objects/.

These are types that *ACT AS* /pointers/
BUT _HOLD *ADDITIONAL* information_ about the thing they are pointing to.

**** Slices - 56
**** Trait objects - 58

*** DONE More Pointer Traits - 59
CLOSED: [2024-12-26 Thu 23:40]
- ~Pointer~ which formats a /pointer/ value for output.
  It is helpful for low-level debugging.
  Formater specifier ~{:p}~.

- ~Borrow~ has a method ~borrow~, and ~BorrowMut~ has a method ~borrow_mut~.
  Same signature as the equivalent ~AsRef~ / ~AsMut~ /trait methods/.

  * The *key difference in intents* between these traits is visible via the
    /blanket implementations/ that the standard library provides.

    + Given an arbitrary
      - /Rust reference/ ~&T~, there's a /blanket implementation/ of both
        ~AsRef~ and ~Borrow~;

      - /Rust mutable reference/ ~&mut T~, there's a /blanket implementation/ of
        both ~AsMut~ and ~BorrowMut~.

    However, ~Borrow~ also has a /blanket implementation/ for /non-reference
    types/: ~impl<T> Borrow<T> for T~.

    *This means that a /method/ accepting the ~Borrow~ trait _CAN_ cope equally
    with instances of ~T~ as well as references-to-~T~*. For example,
    #+begin_src rust
      fn add_four<T: std::borrow::Borrow<i32>>(v: T) -> i32 {
          v.borrow() + 4
      }
      assert_eq!(add_four(&2), 6);
      assert_eq!(add_four(2), 6);
    #+end_src

- _The standard library's container types_ have more realistic uses of ~Borrow~.
  * Example, ~HashMap::get~.

- The ~ToOwned~ trait _builds on_ the ~Borrow~ trait, adding a ~to_owned()~
  method that produces a new owned item of the underlying type.
  * This is a *generalization of the ~Clone~ trait*:
    where ~Clone~ specifically requires a Rust reference ~&T~,
    ~ToOwned~ instead copes with things that implement ~Borrow~.

- This gives a couple of possibilities for _HANDLING BOTH_ /references/ and
  /moved items/ *in a unified way*:
  * A function that operates on /references/ to some type can accept ~Borrow~
    so that it can also be called with /moved items/ as well as /references/.

  * A function that operates on /owned items/ of some type can accept ~ToOwned~
    so that it can also be called with /references to items/ as well as /moved
    items/; ANY /references/ passed to it will _be REPLICATED into a LOCALLY
    OWNED item_.

- ~Cow~ is NOT a /pointer type/,
  BUT provides an _alternative way_ to dealing with the same kind of situation.

*** TODO Smart Pointer Types - 60

** DONE Item 9: Consider using iterator transforms instead of explicit loops - 64
CLOSED: [2025-01-03 Fri 09:42]
- History:
  1. The B language had only ~while (condition) { ... }~ loop.

  2. The C language introduces the ~for~ loop to iterate through indexes.
     #+begin_src c
       // C code
       int i;
       for (i = 0; i < len; i++) {
         Item item = collection[i];
         // body
        }
     #+end_src

  3. The C++ language introduce the ~for~ loop that can move the index variable inside the loop scope.
     #+begin_src cpp
       // C++98 code
       for (int i = 0; i < len; i++) {
         Item item = collection[i];
         // body
        }
     #+end_src
     C also adopted this syntax in C99.

  4. Tracking the logistics that are required to reach that item (~index++~ or
     ~++it~) is mostly an irrelevant detail. This realization produced _TWO_
     core concepts:
     * /Iterators/:
       A type whose purpose is to _repeatedly emit the next item of a
       container_, until exhausted.

     * /For-each loops/:
       A compact loop expression for
       1. iterating over all of the items in a container,
       2. binding a loop variable to the item rather than to the details of
          reaching that item.
       #+begin_src cpp
         // C+11 code
         for (Item& item : collection) {
           // ...
         }
       #+end_src
       /For-each loops/ were added to _Java 1.5_ and _C++11_.

  5. Rust introduces next level abstraction: allowing the whole loop to be
     expressed as an /iterator transform/ (sometimes also referred to as an
     /iterator adaptor/).
     * Comparison:
       + C-like style Rust iteration:
         #+begin_src rust
           let values: Vec<u64> = vec![1, 1, 2, 3, 5 /* ... */];

           let mut even_sum_squares = 0;
           let mut even_count = 0;
           for i in 0..values.len() {
               if values[i] % 2 != 0 {
                   continue;
               }
               even_sum_squares += values[i] * values[i];
               even_count += 1;
               if even_count == 5 {
                   break;
               }
           }
         #+end_src

       + Rust iteration:
         #+begin_src rust
           let even_sum_squares: u64 = values
               .iter() // 1
               .filter(|x| *x % 2 == 0) // 2
               .take(5) // 2
               .map(|x| x * x) // 2
               .sum(); // 3
         #+end_src

     * /Iterator transformation expressions/ like this can roughly be broken down
       into _THREE parts_:
       1) An /initial source iterator/, from an instance of a type that implements
          one of Rust's iterator traits
       2) A sequence of /iterator transforms/
       3) A final /consumer method/ to combine the results of the iteration into
          a final value

       The _FIRST TWO_ of these parts effectively *move functionality out of the
       loop body and into the for expression;*

       the _LAST_ *removes the need for the for statement altogether*.

*** DONE Iterator Traits - 66
CLOSED: [2024-12-27 Fri 21:16]
~Iterator~ with a ~next~ method.
~IntoIterator~ with a ~into_iter~ method.

- iterable ::

- The compiler will automatically use the ~IntoIterator~ trait for expressions
  of the form:
  #+begin_src rust
    for item in collection {
        // body
    }
  #+end_src

  effectively converting them to code roughly like:
  #+begin_src rust
    let mut iter = collection.into_iter();
    while let Some(item) = iter.next() {
        // body
    }
  #+end_src

- To keep things running smoothly, there's also an implementation of
  ~IntoIterator~ for any ~Iterator~, which just returns ~self~; after all, it's
  easy to convert an ~Iterator~ into an ~Iterator~!

- Often, all-consuming behavior is often undesired; some kind of /borrow/ of the
  iterated items is needed.

  If a collection being iterated over is prefixed with ~&~:
  #+begin_src rust
    // Deliberately not `Copy`
    #[derive(Clone, Debug, Eq, PartialEq)]
    struct Thing(u64);

    let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];

    for item in &collection {
        println!("{}", item.0);
    }
    println!("collection still around {collection:?}");
  #+end_src
  then the Rust compiler will look for an implementation of ~IntoIterator~ for
  the type ~&Collection~. _Properly designed collection types will provide such
  an implementation;_ this implementation will *still consume ~Self~, but now
  Self is ~&Collection~ rather than ~Collection~,* and the associated ~Item~ type
  will be a reference ~&Thing~.

  This leaves the collection _intact after iteration_, and the equivalent expanded
  code is as follows:
  #+begin_src rust
    let mut iter = (&collection).into_iter();
    while let Some(item) = iter.next() {
        println!("{}", item.0);
    }
  #+end_src
  Similar for ~for item in &mut collection {~.

- BY CONVENTION,
  standard containers also provide an ~iter()~ method that returns an /iterator/
  over /references/ to the underlying item, and an equivalent ~iter_mut()~ method,
  if appropriate, with the same behavior as just described.

  * These methods can be used in ~for~ loops BUT have a more obvious benefit when
    used as the start of an /iterator transformation/:
    #+begin_src rust
      let result: u64 = (&collection).into_iter().map(|thing| thing.0).sum();
    #+end_src

    becomes

    #+begin_src rust
      let result: u64 = collection.iter().map(|thing| thing.0).sum();
    #+end_src

*** DONE Iterator Transforms - 68
CLOSED: [2024-12-27 Fri 21:16]
The ~Iterator~ trait has a single required method (~next~)
BUT also provides /default implementations/ (_Item 13_) of a large number of
other methods that perform transformations on an /iterator/.

- Some of these /transformations/ AFFECT the _overall iteration process_:
  * ~take(n)~
  * ~skip(n)~
  * ~step_by(n)~
  * ~chain(other)~
  * ~cycle()~
  * ~rev()~

- Other /transformations/ AFFECT the nature of the ~Item~ that's the subject of
  the ~Iterator~:
  * ~map(|item| {...})~
  * ~cloned()~
  * ~copied()~
  * ~enumerate()~
  * ~zip(it)~

- Yet other /transformations/ perform _FILTERING_ on the Items being emitted by
  the ~Iterator~:
  * ~filter(|item| {...})~
  * ~take_while()~
  * ~skip_while()~

- ~flatten()~: deals with an /iterator/ whose items are themselves /iterators/,
  flattening the result. Useful when a stream of ~Option~ / ~Result~ show up.

*** DONE Iterator Consumers - 70
CLOSED: [2025-01-02 Thu 17:19]
The previous two sections described
1. how to obtain an iterator
2. how to transform it into exactly the right shape for precise iteration.

This precisely targeted iteration could happen as an _EXPLICIT for-each loop_:
#+begin_src rust
  let mut even_sum_squares = 0;

  for value in values.iter().filter(|x| *x % 2 == 0).take(5) {
      even_sum_squres += value * value
  }
#+end_src

However, the large collection of ~Iterator~ /methods/ includes many that allow
an iteration to be consumed in a single method call, _removing the need for an
EXPLICIT ~for~ loop._

- The most general method of consuming an iterator is ~.for_each(|item| {...})~.

- Example:
  #+begin_src rust
    let mut even_sum_squares = 0;
    values
        .iter()
        .filter(|x| *x % 2 == 0)
        .take(5)
        .for_each(|value| {
            // closure needs a mutable reference to state elsewhere
            even_sum_squares += value * value;
        });
  #+end_src

- However, if the body of the ~for~ loop _matches one of a number of common
  patterns_, there are more *SPECIFIC* iterator-consuming methods that are clearer,
  shorter, and more idiomatic.

  * Patterns include shortcuts for building a single value out of the collection:
    + ~sum()~
    + ~product()~
    + ~min()~
    + ~max()~
    + ~min_by(f)~
    + ~max_by(f)~
    + ~reduce(f)~
    + ~fold(f)~, a generalization of ~reduce~.
    + ~scan(init, f)~ =TODO: try it=

  * Selects a single value out of the collection:
    + ~find(p)~
    + ~position(p)~
    + ~nth(n)~

  * Tests against every item in the collection:
    + ~any(p)~
    + ~all(p)~
    In either case, /iteration/
    _will *TERMINATE EARLY* IF the relevant counterexample is found_.

  * There are methods that _allow for the possibility of failure_ in the /closures/
    used with each item.

    In each case, if a /closure/ returns a failure for an item, _the /iteration/
    is terminated and the operation as a whole returns the first failure_:
    + ~try_for_each(f)~
    + ~try_fold(f)~
    + ~try_find(f)~

  * Finally, there are methods that accumulate all of the iterated items into a
    new collection. The most important of these is ~collect()~, which can be
    used to build a new instance of any collection type that implements the
    ~FromIterator~ trait.

- The ~FromIterator~ trait is implemented for all of the standard library
  collection types (~Vec~, ~HashMap~, ~BTreeSet~, etc.), but this ubiquity also
  means that you often *have to use explicit types*, because otherwise the
  compiler can't figure out what you're trying to assemble.

- Besides /range/, other (more obscure) collection-producing methods include the
  following:
  * ~unzip()~
  * ~partition(p)~

- =TODO= =REVIEW=
  =TODO=
  =TODO=
  However, it's also the case that an old-style loop might not be subject to
  additional bounds checks compared to the equivalent iterator transformation.
  The Rust compiler and optimizer is very good at analyzing the code
  surrounding a slice access to determine whether it's safe to skip the bounds
  checks; _Sergey “Shnatsel” Davidoff's 2023 article explores the subtleties
  involved._

*** DONE Building Collections from ~Result~ Values - 73 - =IMPORTANT=
CLOSED: [2025-01-02 Thu 17:25]
There is another version of ~collect~ can help to collect result from the
~Result::Ok~ variants. For forcing use this version, a turbofish
(~::<Result<Vec<_>, _>>~) is required:
#+begin_src rust
  let result: Vec<u8> = inputs
      .into_iter()
      .map(|v| <u8>::try_from(v))
      .collect::<Result<Vec<_>, _>>()?;
#+end_src

Combining this with the question mark operator gives useful behavior:
- If the iteration encounters an error value, that error value is emitted to the
  caller and iteration stops.
- If no errors are encountered, the remainder of the code can deal with a
  sensible collection of values of the right type.

*** DONE Loop Transformation - 74
CLOSED: [2025-01-02 Thu 17:29]
*** DONE When Explicit Is Better - 76
CLOSED: [2025-01-03 Fri 09:41]
This Item has highlighted the advantages of iterator transformations,
particularly with respect to concision and clarity.

- Q :: So when are /iterator transformations/ *NOT appropriate or idiomatic*?

- A ::
  * If the loop body is *large* and/or *multifunctional*,
    it makes sense to keep it as an explicit body rather than squeezing it into
    a /closure/.
    =from Jian=
    + I think there is no good and simple way to handle *multifunctional* body
      with /iterator transformation/, which can do it, but not good for
      readability in my opinion.

    + For *large* body, if further abstraction can be done, /iterator
      transformations/ can be a good way.

  * If the loop body _involves error conditions that result in early
    termination_ of the surrounding function, these are often best kept
    explicit - the ~try_..()~ methods help only a little.

    However, ~collect()~'s ability to convert _a collection of ~Result~ values_
    into _a ~Result~ holding a collection of values_ often allows error
    conditions to still be handled with the ~?~ operator.
    =from Jian=
    A poor man version of ~Traverse~ /typeclass/.

  * If *performance is vital*, an /iterator transform/ that involves a /closure/
    _should get optimized_ so that it is just as fast as the equivalent explicit
    code.

    _BUT_ if performance of a core loop is that important, *measure different
    variants and tune appropriately*:
    + Be careful to ensure that your measurements reflect real-world
      performance - the compiler's optimizer can give overoptimistic results on
      test data (as described in _Item 30_).

    + =IMPORTANT=
      _The Godbolt compiler explorer is an amazing tool for exploring what the
      compiler spits out._

- Most importantly,
  _don't convert a loop into an iteration transformation if the conversion is
  forced or awkward_.

  This is a matter of taste to be sure - but be aware that your taste is likely
  to change as you become more familiar with the functional style.

* TODO 2. Traits - 77
** Item 10: Familiarize yourself with standard traits - 77
Rust encodes key behavioral aspects of its type system in the type system
itself, through a collection of fine-grained standard traits that describe those
behaviors (see Item 2)

- It's important to be familiar with the most common of these standard traits so
  that the available behaviors of a type definition can be immediately
  understood.

*** TODO Common Standard Traits - 78 - =START HERE!!! Missing Details!!!=
*ALL* of these traits *can be derived*:
**** ~Clone~

**** ~Copy~

**** ~Default~

**** ~PartialEq~ and ~Eq~

**** ~PartialOrd~ and ~Ord~

**** ~Hash~
Items of this type can produce a /STABLE hash/ of their contents when asked.

**** ~Debug~ and ~Display~

*** DONE Standard Traits Covered Elsewhere - 86
CLOSED: [2024-12-27 Fri 00:02]
Other standard traits that are less ubiquitous than traits discussed in the
previous section.

Of these additional standard traits, the following are the most important, but
they are covered in other Items and so are not covered here in depth:

- ~Fn~, ~FnOnce~, and ~FnMut~
  Items implementing these traits
  REPRESENT /closures/ that can be invoked.
  _See Item 2._

- ~Error~
  Items implementing this trait
  * _represent error information that can be displayed to users or programmers_,
    and
  * that may hold nested suberror information.
  _See Item 4._

- ~Drop~
  Items implementing this trait
  _perform processing when they are destroyed,_ which is essential for /RAII
  patterns/.
  _See Item 11._

- ~From~ and ~TryFrom~
  _See Item 5._

- ~Deref~ and ~DerefMut~
  Items implementing these traits are /pointer-like objects/ that can be
  /dereferenced/ to get access to an inner item.
  _See Item 8._

- ~Iterator~ and friends
  Items implementing these traits represent collections that can be iterated
  over.
  _See Item 9._

- ~Send~
  Items implementing this trait are _SAFE to TRANSFER BETWEEN multiple
  /threads/._
  _See Item 17._

- ~Sync~
  Items implementing this trait are _SAFE to be REFERENCED by multiple
  /threads/._
  _See Item 17._

*NONE of these traits are deriveable.*
BUT ~Send~ and ~Sync~ _may be automatically implemented by the compiler._

*** DONE Operator Overloads - 87
CLOSED: [2024-12-27 Fri 00:06]
- Rust allows various _built-in_ /unary and binary operators/ to be *overloaded*
  for /user-defined types/, by implementing various standard traits from the
  ~std::ops~ module.

  * These traits =IMPORTANT=
    + are *NOT derivable* and
    + are typically needed *ONLY* for types that represent “algebraic” objects,
      where there is a natural interpretation of these operators.

- =IMPORTANT=
  However, experience from C++ has shown that it's best to *avoid* overloading
  operators for unrelated types as it often leads to code that is _hard to maintain_
  and has unexpected performance properties (e.g., x + y silently invokes an
  expensive O(N) method).

  * To comply with the principle of least astonishment, if you implement any operator
    overloads, you should implement a *COHERENT* set of operator overloads.
    + For example,
      if x + y has an overload (~Add~), and -y (~Neg~) does too, then you should
      also implement x - y (~Sub~) and make sure it gives the same answer as x +
      (-y).

- The items passed to the operator overload traits are *moved*, which means that
  /non-~Copy~ types/ will be consumed by default.

  * Adding implementations for ~&'a MyType~ _can help_ with this
    BUT requires more boilerplate to cover all of the possibilities (e.g., there
    are _4 = 2 × 2 possibilities_ for combining reference/non-reference arguments
    to a binary operator).

*** DONE Summary
CLOSED: [2024-12-27 Fri 00:09]
=Review=

** Item 11: Implement the ~Drop~ trait for RAII patterns - 89
** DONE Item 12: Understand the trade-offs between generics and trait objects - 93
CLOSED: [2024-08-28 Wed 23:16]
- _Item 2_ described the use of traits to encapsulate behavior in the type system,
  as a collection of related methods, and observed that there are _TWO_ ways to
  make use of traits:
  * as /trait bounds/ for generics or
  * in /trait objects/.

  This Item explores the trade-offs between these two possibilities.

- As a running example, consider a /trait/ that covers functionality for displaying
  graphical objects:
  #+begin_src rust
    #[derive(Debug, Copy, Clone)]
    pub struct Point {
        x: i64,
        y: i64,
    }

    #[derive(Debug, Copy, Clone)]
    pub struct Bounds {
        top_left: Point,
        bottom_right: Point,
    }

    /// Calculate the overlap between two rectangles, or `None` if there is no
    /// overlap.
    fn overlap(a: Bounds, b: Bounds) -> Option<Bounds> {
        // ...
    }

    /// Trait for objects that can be drawn graphically.
    pub trait Draw {
        /// Return the bounding rectangle that encompasses the object.
        fn bounds(&self) -> Bounds;
        // ...
    }
  #+end_src

*** Generics
- Specific uses of the generic code are generated at /compile time/ -- a process
  known as
  * /monomorphization/ in Rust, and
  * /template instantiation/ in C++.

- Unlike C++, Rust explicitly encodes the expectations for the type ~T~ in the
  /type system/, in the form of /trait bounds/ for the /generic/.

- For the example, a /generic function/ that uses the trait's ~bounds()~ method
  has an explicit ~Draw~ /trait bound/, *THREE* ways in syntax (same effect):
  1. Bound in ~where~ clause:
     #+begin_src rust
       pub fn on_screen<T>(draw: &T) -> bool
       where
           T: Draw,
       {
           overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
       }
     #+end_src

  2. Bound in ~where~ clause:
     #+begin_src rust
       pub fn on_screen<T: Draw>(draw: &T) -> bool {
           overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
       }
     #+end_src

  3. Bound in ~where~ clause:
     #+begin_src rust
       pub fn on_screen(draw: &impl Draw) -> bool {
           overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
       }
     #+end_src

- The programmer writes a _SINGLE_ /generic function/, but the compiler outputs a
  _DIFFERENT_ monomorphized version of that function for every different type that
  the function is invoked with.

*** Trait Objects
In comparison, /trait objects/ are /fat pointers/ (_Item 8_) that combine a
pointer to the underlying concrete item with a pointer to a /vtable/ that in
turn holds /function pointers/ for all of the /trait implementation's methods/,
as depicted in Figure 2-1:
#+begin_src rust
  let square = Square {
      top_left: Point { x: 1, y: 2 },
      size: 2,
  };

  let draw: &dyn Draw = &square;
#+end_src

This means that a function that accepts a /trait object/ _doesn't need to be
/generic/ and doesn't need /monomorphization/._

#+begin_src rust
  /// Indicate whether an object is on-screen.
  pub fn on_screen(draw: &dyn Draw) -> bool {
      overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
  }

  // Calls `on_screen(&dyn Draw) -> bool`.
  let visible = on_screen(&square);
  // Also calls `on_screen(&dyn Draw) -> bool`.
  let visible = on_screen(&circle);
#+end_src

*** Basic Comparisons
- These basic facts already allow some immediate comparisons between the two
  possibilities:
  * /Generics/ are likely to lead to *bigger code sizes*,
    because
    1. the compiler generates a fresh copy (~on_screen::<T>(&T)~) of the code for
       *EVERY* type ~T~ that uses the generic version of the ~on_screen~ function.

    2. In contrast, the /trait object/ version (~on_screen(&dyn T)~) of the
       function needs only *a single instance*.

  * _Invoking a trait method from a generic_ will generally be ever-so-slightly
    *faster than* _invoking it from code that uses a trait object,_
    BECAUSE
    the latter needs to perform *TWO* dereferences to find the location of the
    code (/trait object/ to /vtable/, /vtable/ to /implementation location/).
    + =from Jian=
      Another more significant *PENALTY* for /trait object/:
      CAN'T inline. Many optimization can't be applied a piece of code can't be
      inlined.

  * /Compile times/ for /generics/ are likely to be *LONGER*, as
    + the compiler is building more code and
    + the linker has more work to do to fold duplicates.

- *An extra flexibility for /generics/:*
  A more significant difference is that /generic trait bounds/ can be used to
  conditionally make different functionality available, depending on whether the
  /type parameter/ implements *MULTIPLE* /traits/:

  * The /trait object/ equivalent is much more awkward.
    To make life easier, you need to define a TEMPORARY /trait/, together with a
    /blanket implementation/:
    #+begin_src rust
      trait DebugDraw: Debug + Draw {}

      /// Blanket implementation applies whenever the individual traits
      /// are implemented.
      impl<T: Debug + Draw> DebugDraw for T {}
    #+end_src
    However, if there are *MULTIPLE* combinations of distinct traits, it's clear
    that the combinatorics of this approach rapidly become unwieldy!

*** More Trait Bounds
- In addition to using /trait bounds/ to RESTRICT what /type parameters/ are
  acceptable for a /generic function/, you can also apply them to /trait
  definitions/ themselves:
  #+begin_src rust
    /// Anything that implements `Shape` must also implement `Draw`.
    trait Shape: Draw {
        /// Render that portion of the shape that falls within `bounds`.
        fn render_in(&self, bounds: Bounds);

        /// Render the shape.
        fn render(&self) {
            // Default implementation renders that portion of the shape
            // that falls within the screen area.
            if let Some(visible) = overlap(SCREEN_BOUNDS, self.bounds()) {
                self.render_in(visible);
            }
        }
    }
  #+end_src
  In this example, the ~render()~ method's /default implementation/ (_Item 13_)
  makes use of the /trait bound/, relying on the availability of the ~bounds()~
  method from ~Draw~.

- Under the covers, trait objects for traits that have trait bounds:
  #+begin_src rust
    let square = Square {
        top_left: Point { x: 1, y: 2 },
        size: 2,
    };
    let draw: &dyn Draw = &square;
    let shape: &dyn Shape = &square;
  #+end_src
  * have a single combined /vtable/ that includes
    + the methods of the /top-level trait/, plus
    + the methods of all of the /trait bounds/.

  * This is shown in Figure 2-2: the /vtable/ for ~Shape~ includes the ~bounds~
    method from the ~Draw~ /trait/, as well as the two methods from the ~Shape~
    /trait/ itself.

- =IMPORTANT=
  _At the time of writing (and as of Rust 1.70),_
  this means that there is *no way* to “upcast” from ~Shape~ to ~Draw~,
  BECAUSE
  the (pure) ~Draw~ /vtable/ *can't be recovered at runtime;*
  there is no way to convert between related /trait objects/,
  which in turn means there is *NO* /Liskov substitution/.

  =CAUTION=
  =TODO=
  However, this is likely to change in later versions of Rust --
  see _Item 19_ for more on this.

- *SUMMARY*:
  * *Trait object*
    Repeating the same point in different words, a method that accepts a ~Shape~
    /trait object/ has the following _CHARACTERISTICS_:
    + It *CAN* make use of methods from ~Draw~ (because ~Shape~ also-implements
      ~Draw~, and because the relevant /function pointers/ are present in the
      ~Shape~ /vtable/).

    + It *CANNOT (yet) pass* the /trait object/ onto another method that expects
      a ~Draw~ /trait object/ (because ~Shape~ *is-not* ~Draw~, and because the
      ~Draw~ /vtable/ isn't available).

 * *Generic method*
   In contrast, a /generic method/ that accepts items that implement ~Shape~ has
   these _CHARACTERISTICS_:
   • It *CAN* use methods from ~Draw~.
   • It *CAN PASS* the item on to another /generic method/ that has a ~Draw~
     /trait bound/, because the /trait bound/ is monomorphized at compile time
   to use the ~Draw~ methods of the concrete type.

*** Trait Object Safety
- Another restriction on /trait objects/ is the requirement for /object safety/:
  only /traits/ that comply with the following TWO rules can be used as /trait
  objects/:
  * The trait's methods *MUST NOT* be /generic/.
  * The trait's methods *MUST NOT* involve a type that includes ~Self~,
    except for the /receiver/ (the object on which the method is invoked).
    +  At the time of writing, the restriction on methods that return ~Self~
      includes types like ~Box<Self>~ that could be safely stored on the stack;
      this restriction might be relaxed in the future.

- _The first restriction_ is easy to understand:
  a /generic method/ ~f~ is really an *infinite* set of methods, potentially
  encompassing ~f::<i16>~, ~f::<i32>~, ~f::<i64>~, ~f::<u8>~, etc. The /trait
  object/'s ~vtable~, on the other hand, is very much a *finite* collection of
  /function pointers/, and so it's not possible to fit the infinite set of
  monomorphized implementations into it.

- _The second restriction_ is a little bit more subtle but tends to be the
  restriction that's hit more often in practice -- traits that impose ~Copy~ or
  ~Clone~ /trait bounds/ (_Item 10_) immediately fall under this rule, because
  they return ~Self~. To see why it's disallowed, consider code that has a /trait
  object/ in its hands; what happens if that code calls (say) ~let y = x.clone()?~
  The calling code needs to reserve enough space for ~y~ on the stack, but it has
  no idea of the size of ~y~ because ~Self~ is an arbitrary type. As a result,
  return types that mention ~Self~ lead to a trait that is not object safe.

  * There is an _EXCEPTION_ to this _second restriction_.
    A method returning some ~Self~-related type does not affect /object safety/
    _IF_
    ~Self~ comes with an explicit restriction to types _whose size is known at
    compile time,_ indicated by the ~Sized~ marker trait as a /trait bound/:
    #+begin_src rust
      /// A `Stamp` can be copied and drawn multiple times.
      trait Stamp: Draw {
          fn make_copy(&self) -> Self
          where
              Self: Sized;
      }

      let square = Square {
              top_left: Point { x: 1, y: 2 },
              size: 2,
      };

      // `Square` implements `Stamp`, so it can call `make_copy()`.
      let copy = square.make_copy();

      // Because the `Self` -- returning method has a `Sized` trait bound,
      // creating a `Stamp` trait object is possible.
      let stamp: &dyn Stamp = &square;
    #+end_src
    This /trait bound/ means that the method *CAN'T be used with /trait objects/
    anyway,* BECAUSE /trait objects/ refer to something that's of unknown size
    (~dyn Trait~), and so the method is irrelevant for /object safety/:
    =DOES NOT COMPILE=
    #+begin_src rust
      // However, the method can't be invoked via a trait object.
      let copy = stamp.make_copy();

      // error: the `make_copy` method cannot be invoked on a trait object
      //    --> src/main.rs:397:22
      //     |
      // 353 |         Self: Sized;
      //     |               ----- this has a `Sized` requirement
      // ...
      // 397 | let copy = stamp.make_copy();
      //     |                  ^^^^^^^^^
    #+end_src

*** Trade-Offs
The balance of factors so far suggests that you should _PREFER /generics/ TO
/trait objects/,_ but there are situations where /trait objects/ are the right
tool for the job.

- The first is a practical consideration:
  if _generated code size_ or _compilation time_ is a CONCERN,
  then /trait objects/ will perform better (as described earlier in this Item).

- A more theoretical aspect that leads toward /trait objects/ is that they
  fundamentally involve /type erasure/:
  information about the _CONCRETE type_ is *LOST* in the conversion to a /trait
  object/.

  This can be a downside (see _Item 19_),
  BUT it can also be useful because it allows for _collections of heterogeneous
  objects_ -- BECAUSE the code just relies on the methods of the /trait/, it can
  invoke and combine the methods of items that have DIFFERENT _concrete types_.

  * The traditional OO example of rendering a list of shapes is one example of this:
    the same ~render()~ method could be used for squares, circles, ellipses, and
    stars in the same loop:
    #+begin_src rust
      let shapes: Vec<&dyn Shape> = vec![&square, &circle];
      for shape in shapes {
          shape.render()
      }
    #+end_src

- A much more obscure potential ADVANTAGE for /trait objects/ is when the
  available types are *NOT known at /compile time/.* If new code is _dynamically
  loaded at /runtime/ (e.g., via ~dlopen(3)~)_, then items that implement
  /traits/ in the new code can be invoked only via a /trait object/, because
  there's no source code to monomorphize over.

** DONE Item 13: Use default implementations to minimize required trait methods - 103
CLOSED: [2024-08-27 Tue 00:25]
- =From Jian=
  This is similar in Rust and in other languages whose interfaces
  ALLOW /default method implementation/.

- /Trait methods/ can impose /trait bounds/, indicating that a method is ONLY
  available if the types involved implement particular traits.

* TODO 3. Concepts - 105
This chapter
- The focus of the first two Items in this chapter:
  * /borrow checker/
  * /lifetime checks/

- The other _Items_ in this chapter cover concepts that are easier to grasp but
  are nevertheless a bit different from writing code in other languages. This
  includes the following:
  • _Advice on Rust's ~unsafe~ mode_ and _how to avoid it_ (Item 16)
  • Good news and bad news about writing _multithreaded code in Rust_ (Item 17)
  • Advice on avoiding /runtime aborts/ (Item 18) =TODO: ???=
  • Information about Rust's approach to /reflection/ (Item 19)
  • Advice on balancing optimization against maintainability (Item 20) =IMPORTANT=

** DONE Item 14: Understand lifetimes - 106 - =TODO: RE-READ, NOTE=
CLOSED: [2024-09-12 Thu 00:09]
This Item describes Rust's /lifetime/'s, which are _a more precise formulation of
a concept_ that existed in previous compiled languages like C and C++ -- in practice
if not in theory.

- =TODO=
  /Lifetime/'s are a required input for the /borrow checker/ described in _Item 15_;
  * taken together, these features form _the heart of Rust's memory safety
    guarantees._

*** Introduction to the Stack
- /Lifetime/'s _are FUNDAMENTALLY related to_ the /stack/,
  so a quick introduction/reminder is in order.

- While a program is running, the /memory/ that it uses is divided up into different
  chunks, sometimes called /segments/.

  * Some of these chunks are a *fixed size*,
    such as the ones that hold
    + the program code or
    + the program's global data,

  * Two of the chunks -- the /heap/ and the /stack/ -- *change size* as the program
    runs.

    To allow for this, they are typically arranged at *opposite ends* of the
    program's /virtual memory space/, so one can grow downward and the other can
    grow upward (at least until your program runs out of memory and crashes), as
    summarized in Figure 3-1.
    + _Figure 3-1. Program memory layout,
      including /heap/ growing up and /stack/ growing down_

- Of these two dynamically sized chunks, the /stack/ is used to hold _state_
  related to the currently executing function. This _state_ can include these
  elements:
  * The /parameters/ passed to the function
  * The /local variables/ used in the function
  * /Temporary values/ calculated within the function
  * The /return address/ within the code of the function's caller

- When a function is called, ~f()~, a new /stack frame/ is added to the /stack/,
  beyond where the /stack frame/ for the calling function ends, and the CPU
  normally updates a register -- the stack pointer -- to point to the new stack
  frame.

*** Evolution of Lifetimes
*** Scope of a Lifetime
*** Algebra of Lifetimes
- lifetime elision rules

*** DONE Lifetime Elision Rules
CLOSED: [2024-09-11 Wed 23:37]
Here's a summary of the /lifetime elision rules/ for functions:

- One input, one or more outputs:
  assume outputs have the “same” lifetime as the input:
  #+begin_src rust
    fn f(x: &Item) -> (&Item, &Item)
    // ... is equivalent to ...
    fn f<'a>(x: &'a Item) -> (&'a Item, &'a Item)
  #+end_src

- Multiple inputs, no output:
  assume all the inputs have different lifetimes:
  #+begin_src rust
    fn f(x: &Item, y: &Item, z: &Item) -> i32
    // ... is equivalent to ...
    fn f<'a, 'b, 'c>(x: &'a Item, y: &'b Item, z: &'c Item) -> i32
  #+end_src

- Multiple inputs including ~&self~, one or more outputs:
  assume output lifetime(s) are the "same" as ~&self~'s lifetime:
  #+begin_src rust
    fn f(&self, y: &Item, z: &Item) -> &Thing
    // ... is equivalent to ...
    fn f(&'a self, y: &'b Item, z: &'c Item) -> &'a Thing
  #+end_src

*** TODO The ~'static~ Lifetime
- One case that has not been covered till now:
  * Q :: What happens if there are no input lifetimes, but the output return value
         includes a reference anyway?

  * A :: The only allowed possibility is for the returned /reference/ to have a
    /lifetime/ that's guaranteed to _never go out of scope:_ ~'static~, which is
    also the only /lifetime/ that has a specific name rather than an arbitrary
    placeholder name.

- The Rust compiler guarantees that a ~static~ item always
  * has the *SAME address* for the entire duration of the program and
  * never moves.

  This means that a /reference/ to a /static/ item has a ~'static~ /lifetime/,
  logically enough.

- In many cases, a reference to a const item will also be promoted to have a 'static
  lifetime, but there are a couple of minor complications to be aware of. The first is that
  this promotion doesn’t happen if the type involved has a destructor or interior
  mutability
  =TODO: NOTE=

*** Lifetimes and the Heap
*** Lifetimes in Data Structures
*** Anonymous Lifetimes
*** Things to Remember

** DONE Item 15: Understand the borrow checker - 123 - =TODO: RE-READ, NOTE=
CLOSED: [2025-01-03 Fri 18:49]
- The borrowing mechanism involves _the CREATION and USE of /references/,_
  subject to rules policed by the /borrow checker/.

- Under the covers, Rust's /references/ use the _same kind_ of /pointer values/
  (Item 8) that are so prevalent in C or C++ code but are girded with rules and
  restrictions to make sure that the sins of C/C++ are avoided. As a quick
  comparison:
  * Like a C/C++ pointer, a Rust reference is created with an ampersand: ~&value~.

  * Like a C++ reference, a Rust reference can never be ~nullptr~.

  * Like a C/C++ pointer or reference, a Rust reference can be modified after
    creation to refer to something different.

  * _UNLIKE_ C++, producing a /reference/ from a value _ALWAYS_ involves an
    *EXPLICIT* (~&~) conversion --
    if you see code like ~f(value)~, you know that ~f~ is receiving /ownership/ of
    the value. (However, it may be /ownership/ of a copy of the item, if the
    value's type implements ~Copy~ -- see Item 10.)

  * _UNLIKE_ C/C++, the _mutability_ of a newly created /reference/ is _ALWAYS_
    *EXPLICIT* (~&mut~).
    If you see code like ~f(&value)~, you know that value won't be modified
    (i.e., is ~const~ in C/C++ terminology). Only expressions like ~f(&mut value)~
    have the potential to change the contents of ~value~.
    + footnote2:
      Note that all bets are off with expressions like ~m!(value)~ that involve a
      /macro/ (_Item 28_), BECAUSE that can expand to arbitrary code.

- The MOST IMPORTANT *DIFFERENCE* between _a C/C++ pointer_ and a /Rust reference/
  is indicated by the term /borrow/:
  + you CAN take a /reference (pointer)/ to an item,
    but you CAN'T keep that /reference/ forever.
    - In particular, you can't keep it longer than the /lifetime/ of the
      underlying item, as tracked by the compiler and explored in _Item 14_.

- =IMPORTANT=
  These RESTRICTIONS on the use of /references/
  * enable Rust to make its _memory safety guarantees_,
  * BUT they also mean that you have to
    + accept the _cognitive costs_ of the /borrow rules/, and
    + accept that it will change how you design your software -- particularly its
      data structures.

- _This Item_
  1. starts by describing what Rust /references/ can do, and the /borrow checker/'s
     rules for using them.

  2. The rest of _the Item_ focuses on dealing with the consequences of those rules:
     _HOW TO_
     refactor,
     rework, and
     redesign your code
     _SO THAT_ you can win fights against the /borrow checker/.

*** DONE Access Control
CLOSED: [2025-01-03 Fri 14:53]
- There are _THREE_ ways to access the contents of a Rust item: via
  * the item's /owner/ (~item~),
  * a /reference/ (~&item~), or
  * a /mutable reference/ (~&mut item~).

- Each of these ways of accessing the item comes with different powers over the
  item. Putting things roughly in terms of the CRUD (create/read/update/delete)
  model for storage (using Rust's /drop/ terminology in place of _delete_):
  * The /owner/ of an item gets to _create_ it, _read_ from it, _update_ it, and
    _drop_ it.

  * A /mutable reference/ can be used to _read_ from the underlying item and
    _update_ it.

  * A (normal) /reference/ can be used only to _read_ from the underlying item.

- There's an important _Rust-specific aspect_ to these _data access rules_:
  *only the item's /owner/ can /move/ the item.*
  * This makes sense
    IF you think of a /move/ as being some combination of
    1. _CREATING_ (in the new location) and
    2. _DROPPING_ the item's memory (at the old location).

- This can lead to some _ODDITIES_ for code that has a /mutable reference/ to an
  item. For example, it's OK to overwrite an ~Option~:
  #+CANNOT_COMPILE
  #+begin_src rust
    /// Some data structure used by the code.
    #[derive(Debug)]
    pub struct Item {
        pub contents: i64,
    }
    /// Replace the content of `item` with `val`.
    pub fn replace(item: &mut Option<Item>, val: Item) {
        *item = Some(val);
    }
  #+end_src

  BUT a modification to also return the previous value falls foul of the move
  restriction:

  Use the idea from the last note entry:
  #+CANNOT_COMPILE
  #+begin_src rust
    /// Replace the content of `item` with `val`, returning the previous
    /// contents.
    pub fn replace(item: &mut Option<Item>, val: Item) -> Option<Item> {
        let previous = *item; // move out
        *item = Some(val); // replace
        previous
    }

    // error[E0507]: cannot move out of `*item` which is behind a mutable reference
    //   --> src/main.rs:34:24
    //    |
    // 34 | let previous = *item; // move out
    //    | ^^^^^ move occurs because `*item` has type
    //    | `Option<inner::Item>`, which does not
    //    | implement the `Copy` trait
    //    |
    // help: consider removing the dereference here
    //    |
    // 34 - let previous = *item; // move out
    // 34 + let previous = item; // move out
    //    |
  #+end_src

  1. The error message is not helpful

  2. Although it's VALID to _read_ from a /mutable reference/, this code is attempting
     to /move/ the value out, just _prior to_ replacing the /moved value/ with a
     new value -- in an attempt to *avoid making a copy* of the original value.

     The borrow checker has to be conservative and notices that there's a moment
     between the two lines when the /mutable reference/ isn't referring to a
     valid value.
     =from Jian= This is reasonable -- it is the duty of borrow checker.

     _HOWEVER_,
     As humans, we can see that this combined operation --
     _extracting the old value_ and _replacing it with a new value_ --
     is both safe and useful, so the standard library provides the
     ~std::mem::replace~ function to perform it. Under the covers, ~replace~ uses
     ~unsafe~ (as per _Item 16_) to perform the ~swap~ in one go:
     #+begin_src rust
       /// Replace the content of `item` with `val`, returning the previous
       /// contents.
       pub fn replace(item: &mut Option<Item>, val: Item) -> Option<Item> {
           std::mem::replace(item, Some(val)) // returns previous value
       }
     #+end_src
     For ~Option~, this is a common pattern, therefore ~Option~ actual has a
     replace /method/: ~pub const fn replace(&mut self, value: T) -> Option<T>~.

*** DONE Borrow Rules
CLOSED: [2025-01-03 Fri 14:53]
- There are _TWO key rules_ to remember WHEN _borrowing references in Rust_.

  * Rule 1 ::
    The /scope/ of ANY /reference/ must be smaller than the /lifetime/ of the
    item that it refers to.
    + /Lifetimes/ are explored in detail in _Item 14_, but it's worth noting
      that the compiler has special behavior for /reference lifetimes/; the
      /non-lexical lifetimes/ feature allows reference lifetimes to be shrunk so
      they end at the point of last use, rather than the enclosing block.

  * Rule 2 ::
    For /borrowing references/ is that, in addition to the /owner/ of an item,
    there can be either of the following:
    + *Any number* of /immutable references/ to the item
    + *A single* /mutable reference/ to the item

- These borrowing rules allow the compiler to *make better decisions around
  /aliasing/:*
  * aliasing :: tracking when two different pointers may or may not refer to the
    same underlying item in memory.
    =from Jian= _Here the /aliasing/ is an important concept in compiler theory!!!_

- If the compiler can be sure (as in Rust) that the memory location pointed to
  by a collection of /immutable references/ *cannot be altered via an aliased
  /mutable reference/,* then it can generate code that has the following
  advantages:
  * _It's better optimized_
    Values can be, for example, cached in registers, secure in the knowledge
    that the underlying memory contents will not change in the meantime.

  * _It's safer_
    /Data races/ arising from _unsynchronized access to memory between /threads/
    (Item 17)_ are *NOT possible*.

*** TODO Owner Operations
*** TODO Winning Fights Against the Borrow Checker - =RE-READ, TAKE NOTE=
**** Local code refactoring
**** Data structure design
**** Smart pointers
**** Self-referential data structures

*** DONE Things to Remember
CLOSED: [2025-01-03 Fri 18:48]
- Rust's /references/ are _borrowed,_ indicating that they cannot be held forever.

- The /borrow checker/ allows _MULTIPLE immutable references_ or _A SINGLE mutable
  reference_ to an item *but NOT both*.

  The /lifetime/ of a /reference/ stops at the point of last use, rather than at
  the end of the enclosing scope, due to /non-lexical lifetimes/.

- Errors from the /borrow checker/ can be dealt with in various ways:
  * Adding an additional ~{ ... }~ /scope/ can *reduce* the extent of a value's
    lifetime.

  * Adding /a named local variable/ for a value *extends* the value's /lifetime/
    to the end of the scope.

  * TEMPORARILY adding multiple local variables can help _narrow down_ what the
    /borrow checker/ is complaining about.
    =from Jian and this book=
    Use this way to debug and get rid of the complaining from /borrow checker/
    if possible.

- /Rust's smart pointer type/s provide ways *around* /the borrow checker's
  rules/ and so are useful for /interconnected data structures/.

- However, /self-referential data structures/ remain awkward to deal with in Rust.
  Need ~Pin~ or use some libraries like _ouroborous_.
  =TODO= =TODO= =TODO: Learn this library=

** TODO Item 16: Avoid writing ~unsafe~ code - 142
** TODO Item 17: Be wary of shared-state parallelism - 145
- The official documentation describes Rust as enabling "fearless concurrency",
  but this Item will explore why (sadly) there are still some reasons to be
  afraid of concurrency, even in Rust.

- This Item is specific to shared-state parallelism: where different threads of
  execution communicate with each other by sharing memory. Sharing state between
  threads generally comes with two terrible problems, regardless of the language
  involved:
  * Data races: can lead to corrupted data.

  * Deadlocks: can lead to your program grinding to a halt.

*** Data Races
**** Data races in C++
**** Data races in Rust
**** Standard marker traits

*** Deadlocks
*** Advice

** DONE Item 18: Don't panic - 159
CLOSED: [2025-01-12 Sun 15:25]
The title of this Item would be more accurately described as
_prefer returning a ~Result~ to using ~panic!~ (but don't panic is much
catchier)_.

- /rust's panic mechanism/ is primarily designed for *UNRECOVERABLE bugs* in your
  program, and _BY DEFAULT_ it *TERMINATES the thread* that issues the ~panic!~.

  *However, there are _alternatives_ to this DEFAULT.*

- IT SEEMS ~std::panic::catch_unwind~ as a way to simulate /exceptions/, because
  it appears to provide a mechanism for _catching panics_ at a point further up
  the /call stack/.
  #+begin_src rust
    fn divide(a: i64, b: i64) -> i64 {
        if b == 0 {
            panic!("Cowardly refusing to divide by zero!");
        }
        a / b
    }

    fn divide_recover(a: i64, b: i64, default: i64) -> i64 {
        let result = std::panic::catch_unwind(|| divide(a, b));
        match result {
            Ok(x) => x,
            Err(_) => default,
        }
    }

    fn main() {
        let result = divide_recover(0, 0, 42);
        println!("result = {result}"); // result = 42
    }
  #+end_src

  However, *this appearance is deceptive*.

  * /panics/ don't always /unwind/; there is a compiler option (which is also
    accessible via a =Cargo.toml= profile setting) that shifts panic behavior so
    that it immediately aborts the process:
    #+begin_src text
      thread 'main' panicked at 'Cowardly refusing to divide by zero!', main.rs:11:9
      note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
      /bin/sh: line 1: 29100 Abort trap: 6 cargo run --release
    #+end_src

    This leaves any attempt to _simulate exceptions_ *entirely at the mercy of the
    wider project settings.*

  * =IMPORTANT=
    A more subtle problem that's surfaced by /panic handling/ is /exception safety/:
    if a /panic/ occurs _MIDWAY through an operation on a data structure_, it
    removes any guarantees that the data structure has been left in a
    self-consistent state.

    Preserving internal invariants in the presence of exceptions has been known
    to be *extremely difficult* SINCE the 1990s; this is one of the main reasons
    why _Google (famously) bans the use of exceptions in its C++ code._

- Q :: What's the _alternative_ to ~panic!~ for dealing with error conditions?

- A ::
  * For library code,
    make the error _someone else's problem_ by returning a ~Result~.
    The library users should make their decisions.
    + Use ~panic!~ in library code is OK, if the error is rare and you don't
      want users to have to litter their code with ~.unwrap()~ calls.

  * It is OK to ~panic!~ if you have control of ~main~;
    at that point, no further caller that the buck could be passed to.

- Use cases:
  * If an error situation should occur
    ONLY BECAUSE (say) _internal data is corrupted_, RATHER THAN as a result of
    invalid inputs,
    THEN _triggering a ~panic!~ is legitimate._

  * It can even be occasionally useful to
    allow panics that
    CAN be triggered by invalid input
    BUT where such invalid inputs are out of the ordinary.

    This works best when the relevant entrypoints come in pairs:
    + An “infallible” version whose signature implies it always succeeds (and
      which panics if it can't succeed)
      - The _Rust's API guidelines_ suggest that the ~panic!~ should be
        documented in a specific section of the inline documentation (_Item
        27_).

    + A “fallible” version that returns a ~Result~
      - Examples:
        ~String::from_utf8_unchecked~ and ~String::from_utf8~ entrypoints
        (although in this case, the /panics/ are actually deferred to the point
        where a ~String~ constructed from invalid input gets used).

- Assuming that you are trying to comply with the advice in this Item, there are
  a few things to bear in mind. The first is that _panics can appear in different
  guises_; avoiding ~panic!~ also involves avoiding the following:
  * ~unwrap()~ and ~unwrap_err()~
  * ~expect()~ and ~expect_err()~
  * ~unreachable!()~

- Harder to spot are things like these:
  * ~slice[index]~ when the index is out of range
  * ~x / y~ when ~y~ is zero

- =from Jian=:
  Good engineering should reduce the cognitive cost of developers and help them
  focus on creative parts, and let the machine do the repetitive parts.

  Following this idea, working with /panics/:
  =from this book=
  * a plan that involves _constant vigilance of humans_ is never a good idea.

  * However, _constant vigilance of machines_ is another matter:
    adding a check to your /continuous integration/ (see _Item 32_) system that
    spots new, potentially panicking code is much more reliable.

    + A simple version could be a simple grep for the most common panicking
      entrypoints (as shown previously);

    + a more thorough check could involve additional tooling from the Rust
      ecosystem (_Item 31_), such as setting up a /build variant/ that pulls in
      the ~no_panic~ crate.
      =TODO: Learn the no_panic library=

** TODO Item 19: Avoid reflection - 162
- Programmers coming to Rust from other languages are often used to reaching for
  reflection as a tool in their toolbox. They can waste a lot of time trying to
  implement reflection-based designs in Rust, only to discover that what they're
  attempting can only be done poorly, if at all. This Item hopes to save that
  time wasted exploring dead ends, by describing what Rust does and doesn't have
  in the way of reflection, and what can be used instead.

- Reflection is the ability of a program to examine itself at runtime. Given an
  item at runtime, it covers these questions:
  * What information can be determined about the item’s type?
  * What can be done with that information?

*** Upcasting in Future Versions of Rust

** TODO Item 20: Avoid the temptation to over-optimize - 169 - =NOTE=
*** Data Structures and Allocation
*** Who's Afraid of the Big Bad Copy?
*** References and Smart Pointers

* DONE 4. Dependencies - 175 - =TODO: NOTE=
CLOSED: [2024-12-25 Wed 19:21]
- It's usually still easier to reuse existing code than to write it yourself,
  BUT
  there are potential pitfalls and risks that come along with dependencies on
  someone else's code. _This chapter of the book will help you be aware of these._

- The focus is specifically on Rust, and with it the use of the _cargo_ tool, but
  many of the concerns, topics, and issues covered apply equally well to other
  toolchains (and other languages).

** DONE Item 21: Understand what semantic versioning promises - 176
CLOSED: [2024-12-17 Tue 16:26]
- Most commonly used variants:
  * 1.2.3  :=  >=1.2.3, <2.0.0

- When choosing dependency versions, Cargo will generally pick the *LARGEST*
  version that's within the combination of all of these semver ranges.

- Because semantic versioning is at the _HEART_ of cargo's dependency resolution
  process, this _Item_ explores more details about what semver means.

*** DONE Semver Essentials
CLOSED: [2024-08-29 Thu 14:27]
- One rule that _Cargo_ does *NOT* follow strictly:
  In the _Semantic Versioning 2.0.0_ standard:
  #+begin_quote
  4. Major version zero (0.y.z) is for initial development. Anything MAY change
     at any time. The public API SHOULD NOT be considered stable.
  #+end_quote

  =IMPORTANT=
  =Cargo's own modified semver rule=
  Cargo adapts this last rule slightly, “left-shifting” the earlier rules so that
  changes in the leftmost non-zero component indicate incompatible changes. This
  means that 0.2.3 to 0.3.0 can include an incompatible API change, as can 0.0.4
  to 0.0.5.

*** DONE Semver for Crate Authors
CLOSED: [2024-12-17 Tue 13:40]
#+begin_quote
In theory, theory is the same as practice. In practice, it's not.
#+end_quote

- As a crate author, the first of these rules is easy to comply with, in theory:
  if you touch anything, you need a new release.

- The crates.io registry will *REJECT* a second attempt to publish the same
  crate version.

- The semver specification covers API compatibility, so if you make a minor change to
  behavior that _doesn't alter the API_, then a /patch version/ update should be
  all that's needed.
  * However, if your crate is widely depended on, then in practice you may need
    to be aware of *Hyrum's Law*:
    #+begin_quote
    Regardless of how minor a change you make to the code, someone out there is
    likely to depend on the old behavior—even if the API is unchanged.
    #+end_quote

- _The Cargo book_ goes into considerable detail as to what is and is not back
  compatible. There are a few areas worth highlighting:
  =TODO: NOTE=

- An obvious corollary of the rules is this:
  the fewer public items a crate has, the fewer things there are that can induce
  an incompatible change (_Item 22_).

- Hopefully (_Item 31_) tooliing will arrive to make the process easier:
  * _footnote3_:
    cargo-semver-checks is a tool that attemps to do something along the cargo
    rules for backward compatibility.

- Follow these steps to make an incompatible major version change:
  1. Release a minor version update that includes the new version of the API and
     that marks the older variant as ~deprecated~, including an indication of how
     to migrate.

  2. Release a major version update that removes the deprecated parts of the API.

- =IMPORTANT=
  =IMPORTANT=
  =IMPORTANT=
  A more subtle point is _make breaking changes breaking_.

  If your crate is changing its behavior in a way that's actually incompatible
  for existing users but that could reuse the same API: *don't*.
  Force a change in /types/ (and a major version bump) to ensure that users
  can't inadvertently use the new version incorrectly.

- =TODO=
  For the less tangible parts of your API - such as the MSRV or the license -
  consider setting up a CI check (Item 32) that detects changes, using tooling
  (e.g., cargo-deny; see Item 25) as needed

- =IMPORTANT=
  Finally, don't be afraid of version 1.0.0
  BECAUSE
  it's a commitment that your API is now fixed.
  * Lots of crates fall into the trap of staying at version 0.x forever,
    BUT
    that *REDUCES* the already-limited expressivity of semver _FROM_ three
    categories (major/ minor/patch) _TO_ two (effective-major/effective-minor).

*** DONE Semver for Crate Users
CLOSED: [2024-12-17 Tue 16:26]
- Avoid wildcard dependency version like ~"*"~ or ~"0.*"~.

- As a result, you need to either accept the risks of being stuck on an old
  version or eventually follow major version upgrades to your dependencies.
  * Tools such as ~cargo update~ or _Dependabot (Item 31)_ can let you know when
    updates are available; you can then schedule the upgrade for a time that's
    convenient for you.
    =TODO=

*** DONE Discussion
CLOSED: [2024-12-17 Tue 16:20]
- *Semantic versioning has a cost*:
  every change to a crate has to be assessed against its criteria, to decide the
  appropriate type of version bump.

  * Semantic versioning is also a blunt tool:
    *AT BEST*, it reflects a crate owner's guess as to which of three categories
    the current release falls into.
    + NOT everyone gets it right,
      NOT everything is clear-cut about exactly what “right” means, and

    + even if you get it right, there's always a chance you may fall foul of
      /Hyrum's Law/.

- However, /semver/ is the only game in town for anyone who doesn't have the luxury of
  working in an environment like Google's highly tested gigantic internal monorepo.

  =IMPORTANT=
  As such, _understanding its concepts and limitations is necessary for managing
  dependencies._

** DONE Item 22: Minimize visibility - 181
CLOSED: [2024-12-23 Mon 16:19]
*** Visibility Syntax
- _Rust's basic unit of visibility is the /module/._
  _BY DEFAULT_, a module's items (types, methods, constants) are *private* and
  accessible only to code in the _same module_ and _its submodules_.
  * Exceptions exist:
    + ~enum~ auto make its variants public.
    + a trait public auto makes the trait's methods public.

- The most common visibility marker is the _BARE_ ~pub~ keyword, which makes the
  item visible to anything that's able to see the /module/ it's in.
  * That last detail is important:
    if a ~somecrate::somemodule~ /module/ isn't visible to other code in the
    first place, anything that's ~pub~ inside it _is still *NOT* visible_.

- However, there are also some more-specific variants of pub that allow the
  scope of the visibility to be constrained. In descending order of usefulness,
  these are as follows:
  * ~pub(crate)~

  * ~pub(super)~
    Accessible to the parent module of the current module and its submodules.
    + Occasionally useful for selectively increasing visibility in a crate that
      has a *DEEP* module structure.

    + It's also the effective visibility level for /modules/:
      a plain ~mod mymodule~ is visible to
      its parent
      - module or
      - crate and
      - the corresponding submodules

  * ~pub(in <path>)~
    Accessible to code in ~<path>~, which has to be a description of some
    _ANCESTOR module_ of the _CURRENT module_.

    =TODO= =???=
    This can occasionally be useful for organizing source code, because it
    allows subsets of functionality to be moved into submod‐ ules that aren't
    necessarily visible in the public API.

    =TODO= =???=
    EXAMPLE

  * ~pub(self)~
    Equivalent to ~pub(in self)~, which is equivalent to _NOT being ~pub~._ Uses
    for this are very obscure, such as reducing the number of special cases
    needed *in codegeneration macros*.

*** Visibility Semantics
- No guarantee can be given to
  make a public item private WITHOUT breaking any code that uses the crate.

- Prefer privacy is that it keeps your options open - the more things that are
  exposed, the more things there are that need to stay fixed for the future
  (absent an incompatible change).

- Of course,
  this is a concern only for _library_ code that potentially has multiple users
  and a long lifespan.

** DONE Item 23: Avoid wildcard imports - 186
CLOSED: [2024-12-23 Mon 22:13]
This advice is common for almost every language, if not all.

Here we talk about some aspects of this in Rust that may not exist in other
languages:

- The names in from a /wildcard import/ are treated as being *lower priority*,
  so any matching names that are in your code take precedence:
  #+begin_src rust
    use bytes::*;

    // Local `Bytes` type does not clash with `bytes::Bytes`.
    struct Bytes(Vec<u8>);
  #+end_src

- If you add a new method to your trait and implement it for a type, your
  exiting code may break, becuase the that type may have same name method from
  other trait(s).

- EXECPTIONS:
  - If *you do control the source of the wildcard import,* then the previously
    mentioned concerns disappear.
    * For example,
      + It's common for a ~test~~ module to do ~use super::*;~.

      + It's also possible for crates that use /modules/ primarily as a way of
        dividing up code to have a wildcard import from an /internal module/:
        #+begin_src rust
          mod thing;

          pub use thing::*;
        #+end_src

  - The prelude module pattern:
    Some crates have a convention that common items for the crate are
    re-exported from a /prelude/ module, which is explicitly intended to be
    wildcard imported:
    #+begin_src rust
      use thing::prelude::*;
    #+end_src
    Although _in theory_ the same concerns apply in this case,
    _in practice_ such a /prelude/ module is likely to be carefully curated, and
    higher convenience may outweigh a small risk of future problems.

- If, for some reason, you don't follow the advice in this Item,
  _consider pinning dependencies that you wildcard import to a precise version_

** DONE Item 24: Re-export dependencies whose types appear in your API - 188
CLOSED: [2024-12-25 Wed 19:21]
The title of this Item is a little convoluted, but working through an example
will make things clearer.

- *re-export dependencies whose types appear in your API.*

- Assume your code depends on a 3rd-party crate (version A), the types from that
  crate appears in the public API of your code - this often happens when that
  3rd-party crate is widely used, like ~rng~. Back-compatible can be broken if
  a project depends on your crate also depends on an incompatible 3rd-party crate
  (version A).

  To resolve this issue, the 3rd-party library author should explicitly
  *re-export* either of the following:
  * The types involved in the API
  * The entire dependency crate
    _Re-export the version of `rand` used in this crate's API._
    #+begin_src rust
      pub use rand;
    #+end_src

** TODO Item 25: Manage your dependency graph - 191 - =TODO: Reread, Take Note, and Experiment=
- /dependency graph/

*** Version Specification - 193
*** Solving Problems with Tooling - 194
*** What to Depend On - 195
*** Things to Remember - 196

** TODO Item 26: Be wary of feature creep - 197 - =TODO: NOTE=
Rust allows the same codebase to support a variety of different configurations
via Cargo's /feature/ mechanism, which is _BUILT ON TOP OF a lower-level
mechanism for /conditional compilation/._

HOWEVER, the /feature/ mechanism has a few *subtleties* to be aware of, which
this Item explores.

*** DONE Conditional Compilation
CLOSED: [2024-12-25 Wed 16:24]
- Rust /conditional compilation/ is controlled by ~cfg~ (and ~cfg_attr~)
  attributes.

  * These attributes govern whether the thing - /function/, /line/, /block/,
    etc.- that they are attached to is included in the compiled source code or
    not (which is in contrast to _C/C++’s *line-based* preprocessor_).

  * The /conditional inclusion/ is controlled by configuration options that are
    + either plain names (e.g., ~test~)
    + or pairs of names and values (e.g., ~panic = "abort"~)
      - Note that the this variants of config options are *multivalued* - it's
        possible to set more than one value for the same name:
        #+begin_src rust
          // Build with `RUSTFLAGS` set to:
          // '--cfg myname="a" --cfg myname="b"'

          #[cfg(myname = "a")]
          println!("cfg(myname = 'a') is set");
          #[cfg(myname = "b")]
          println!("cfg(myname = 'b') is set");

          // cfg(myname = 'a') is set
          // cfg(myname = 'b') is set
        #+end_src

- The *most commonly used* config values are those that _the toolchain populates
  AUTOMATICALLY_, with values that describe the /target environment/ for the
  build. These include
  * the OS (~target_os~),
  * CPU architecture (~target_arch~),
  * pointer width (~target_pointer_width~), and
  * endianness (~target_endian~).

  This allows for code portability, where /features/ that are specific to some
  particular target are compiled in only when building for that target.

- The standard ~target_has_atomic~ option also provides an example of the
  _MULTIVALUED nature of config values_:
  both ~[cfg(target_has_atomic = "32")]~ and ~[cfg(target_has_atomic = "64")]~
  will be set for targets that support both 32-bit and 64-bit /atomic operations/.
  (For more information on /atomics/, see Chapter 2 of Mara Bos's Rust Atomics
  and Locks [O’Reilly].)

*** TODO Features
*** TODO Things to Remember

* TODO 5. Tooling - 203
** TODO Item 27: Document public interfaces - 203 - =NOTE=
=from Jian= Read *the rustdoc book*

Write doc comments for all exposed API elements.

- The particulars of Rust's documentation comment format - *Markdown-based*,
  delimited with ~///~ or ~//!~.
  * There are some specific details about the format that are worth highlighting:
    + Use a code font for code
    + Add copious cross-references
      - Example:
        The ~[`...`]~ in the comment below
        #+begin_src rust
          /// Calculate the [`BoundingBox`] that exactly encompasses a pair
          /// of [`BoundingBox`] objects.
          pub fn union(a: &BoundingBox, b: &BoundingBox) -> BoundingBox {
              // ...
          }
        #+end_src

    + Consider including example code
      Adding an ~# Examples~ section with sample code can be helpful.
      - Note that sample code in doc comments gets compiled and executed when
        you run cargo test (see _Item 30_), which helps it stay in sync with the
        code it's demonstrating.

    + *Document /panics/ and ~unsafe~ constraits*
      - If there are _inputs that cause a function to /panic/,_
        document (in a ~# Panics~ section) the preconditions that are required
        to avoid the ~panic!~.

      - Similarly, document (in a ~# Safety~ section) any requirements for
        ~unsafe~ code.

- Learn from the documentation for Rust's standard library.

*** Tooling
- The Markdown format that's used for documentation comments results in elegant
  output, but this also means that there is an explicit conversion step
  (~cargo doc~).

  _This in turn raises the possibility that something goes wrong along the way_.

  * =IMPORTANT=
    The simplest advice for this is just to
    read the rendered documentation after writing it, by running
    + ~cargo doc --open~ or
    + ~cargo doc --no-deps --open~ to restrict the generated documentation to
      just the current crate.

- You could also check that all the generated hyperlinks are valid, but that's a
  job more suited to a machine—via the ~broken_intra_doc_links~ crate attribute:
  #+begin_src rust
    #![deny(broken_intra_doc_links)]

    /// The bounding box for a [`Polygone`].
    #[derive(Clone, Debug)]
    pub struct BoundingBox {
        // ...
    }
  #+end_src
  With this attribute enabled, ~cargo doc~ will detect invalid links, the
  ~[`Polygone`]~.

- Another use attribute ~#![warn(missing_docs)]~.
  * _pros_: the compiler will emit a warning for every undocumented public item.

  * _cons_: there's a risk that enabling this option will lead to poor-quality
    documentation comments that are rushed out just to get the compiler to shut
    up - more on this to come.

- =IMPORTANT=
  =from Jian=
  * For current Rust (2024-01-17), should use
    ~#![deny(rust_doc::broken_intra_doc_links)]~.

  * Always use
    ~#![deny(rust_doc::broken_intra_doc_links)]~
    ~#![deny(missing_docs)]~
    because they can point out where the doc is missing!

- =IMPORTANT=
  As ever, any tooling that detects potential problems should form a part of
  your /CI system/ (_Item 32_), to catch any regressions that creep in.

*** Additional Documentation Locations
The output from ~cargo doc~ is the primary place where your crate is documented,
but it's not the only place - other parts of a Cargo project can help users
figure out how to use your code.

- _The =examples/= subdirectory of a Cargo project_ can hold the code for
  *standalone* binaries that make use of your crate.

  These programs are built and run _very similarly to integration tests (Item
  30)_ but are specifically intended to hold example code that illustrates the
  correct use of your crate’s interface.
  =from Jian's summary=
  *primary purpose* teach the users how to use this crate.

- On a related note, bear in mind that _the integration tests under the =tests/=
  subdirectory_ can also serve as examples for the confused user, even though
  their
  *primary purpose* is to test the crate's external interface.

*** Published Crate Documentation
- As a result, the home page for a crate shows different content in each location:
  * _docs.rs_
    Shows the top-level page from the output of cargo doc, as generated from ~//!~
    comments in the top-level =src/lib.rs= file.

  * _crates.io_
    Shows the content of any top-level *README.md* file that’s included in the
    project's repo.

*** TODO What Not to Document - =IMPORTANT= =NOTE=
WHEN a project requires that documentation be included for all public items (as
mentioned in the first section),
_it's very easy to fall into the trap of having documentation that’s a POINTLESS
WASTE of valuable pixels._

- Having the compiler warn about missing doc comments is only a proxy for what
  you really want—useful documentation—and is likely to incentivize programmers
  to do the minimum needed to silence the warning.

- =IMPORTANT=
  =Criterion for deciding is a document should be added=
  * _GOOD doc comments_ are a boon that helps users understand the code they're
    using;

  * _BAD doc comments_
    + *impose a maintenance burden* and
    + *increase the chance of user confusion when they get out of sync with the
      code*.

  _So how to distinguish between the two?_

- *The primary advice*
  is to *avoid repeating* in text something that's clear from the code.

  * Item 1 exhorted you to encode as much semantics as possible into Rust's type
    system. Try your best to do so.
    =from Jian=
    Naming is another important documentation.

- Returning to the previous example, an overly verbose documentation comment
  might be as follows:
  =CODE=

  * This comment repeats many details that are clear from the function signature,
    to no benefit.

  * Worse, consider what’s likely to happen if the code gets refactored to store
    the result in one of the original arguments (which would be a breaking change;
    see _Item 21_). No compiler or tool complains that the comment isn’t updated to
    match, so it’s easy to end up with an out-of-sync comment:
    =CODE=

- In contrast, the original comment survives the refactoring unscathed, because
  its text describes behavior, not syntactic details:
  =CODE=

- The mirror image of the preceding advice also helps improve documentation:
  include in text anything that’s not clear from the code. This includes
  preconditions, invariants, panics, error conditions, and anything else that
  might surprise a user; if your code can’t comply with the principle of least
  astonishment, make sure that the surprises are documented so you can at least
  say, “I told you so.”

- Another common failure mode is when doc comments describe how some other code
  uses a method, rather than what the method does:
  =CODE=

  * Comments like this are almost guaranteed to get out of sync: when the using
    code (here, hits.rs) changes, the comment that describes the behavior is
    nowhere nearby.

  * Rewording the comment to focus more on the why makes it more robust to future changes:
    =CODE=

- When writing software, it’s good advice to “program in the future tense”:3
  structure the code to accommodate future changes. The same principle is true
  for documentation: focusing on the semantics, the whys and the why nots,
  gives text that is more likely to remain helpful in the long run.

*** Things to Remember

** TODO Item 28: Use macros judiciously - 209
*** Declarative Macros
*** Procedural Macros
**** Function-like macros
**** Attribute macros
**** Derive macros

*** When to Use Macros
*** Disadvantages of Macros
*** Advice

** TODO Item 29: Listen to Clippy - 223 - =NOTE=
- _Clippy_ is an additional component for Cargo (~cargo clippy~) that emits
  warnings about your Rust usage, across a variety of categories:
  * _Correctness_
    Warns about common programming errors

  * _Idiom_
    Warns about code constructs that aren't quite in standard Rust style

  * _Concision_
    Points out variations on the code that are more compact

  * _Performance_
    Suggests alternatives that avoid unnecessary processing or allocation

  * _Readability_
    Describes alterations to the code that would make it easier for humans to read
    and understand

- _Clippy warning comes with a linke to a webpage describing the error_
  _The text also describes known problems with the lint_
  This is important, and you can read that webpage to decide follow the lint
  advice or not.

- Disable a lint warning for a particular item: ~#[allow(clippy::some_lint)]~
- Disable a lint for the entire crate ~#![allow(clippy::some_lint)]~ with an
  extra ~!~, at the top level.

- Whether you choose to fix or disable the warnings,
  you should make your code *Clippy-warning free*.

- Clippy's warnings are particularly helpful when you're learning Rust,
  _BECAUSE_
  they reveal gotchas you might not have noticed and help you become familiar
  with Rust idiom.

- Many of the _Items_ in this book also have corresponding _Clippy warnings_,
  when it's possible to mechanically check the relevant concern:
  * Item 1
  * Item 3
  * Item 3
  * Item 5
  * Item 5
  * Item 8
  * Item 9
  * Item 10
  * Item 18
  * Item 21
  * Item 23
  * Item 24 and 25
  * Item 26
  * Item 26
  * Item 27

** DONE Item 30: Write more than unit tests - 227 - =NOTE=
CLOSED: [2025-01-13 Mon 21:44]
This Item assumes that you're already signed up to write tests for your code.

- /Unit tests/ and /integration tests/, described in the next two sections, are
  the key forms of tests.

  However, the _Rust toolchain_, and _extensions to the toolchain_, allow for
  _various other types of tests_.

  This Item describes their DISTINCT _logistics_ and _rationales_.

*** DONE Unit Tests - 227
CLOSED: [2025-01-13 Mon 20:32]
- The _most common form of test_ for Rust code is a /unit test/, which might
  look something like this:
  #+begin_src rust
    // ... (code defining `nat_subtract*` functions for natural
    // number subtraction)
    #[cfg(test)]
    mod tests {
        use super::*;
        #[test]
        fn test_nat_subtract() {
            assert_eq!(nat_subtract(4, 3).unwrap(), 1);
            assert_eq!(nat_subtract(4, 5), None);
        }
        #[should_panic]
        #[test]
        fn test_something_that_panics() {
            nat_subtract_unchecked(4, 5);
        }
    }
  #+end_src
  Some aspects of this example will appear in every /unit test/:
  * A COLLECTION of /unit test functions/.
  * EACH /test function/ is marked with the ~#[test]~ attribute.
  * The /module/ holding the /test functions/ is annotated with a ~#[cfg(test)]~
    attribute, so the code _gets built *ONLY* in test configurations._

- Other aspects of this example illustrate things that are _OPTIONAL_ and may be
  relevant only for particular tests:
  * The test code here is held in a SEPARATE /module/, conventionally called
    ~tests~ or ~test~.

    + This /module/ may be *inline* (as here) or *held in a separate ~tests.rs~
      file*.

      Using a *SEPARATE file* for /the test module/ has the advantage that it's
      easier to spot whether code that uses a function is test code or “real”
      code.

  * The /test module/ might have a wildcard use ~super::*~ to pull in everything
    from the /parent module/ under test.

    This makes it more convenient to add tests (and is an *EXCEPTION* to the
    general advice in _Item 23_ to avoid wildcard imports).

  * The _normal visibility rules_ for /modules/ mean that a unit test has the
    ability to use anything from the parent module, whether it is ~pub~ or not.

  * The test code makes use of ~expect()~ or ~unwrap()~ for its expected results.
    Also use ~assert_eq!~. /panic/ is not a problem in tests.

  * ~#[should_panic]~

- However, if your code relies on specific functionality from your /dependencies/,
  *it can be helpful to include BASIC TESTS of that functionality.*

  It is an early warning system that indicates whether the behavior has changed
  when you update that dependency. Also, sometimes, a dependency may violate
  semantic versioning conventions -- early detection can help to avoid damage.

*** DONE Integration Tests - 229
CLOSED: [2025-01-13 Mon 20:32]
- The other common form of test included with a Rust project is /integration
  tests/, held under =tests/=. Each file in that directory is run as a SEPARATE
  test program that executes all of the functions marked with ~#[test]~.

- /Integration tests/ do NOT have access to _crate internals_ and so act as
  behavior tests that can exercise _ONLY the public API_ of the crate.

*** DONE Doc Tests - 229
CLOSED: [2025-01-13 Mon 20:40]
- _Item 27_ described the inclusion of short code samples in documentation
  comments, to illustrate _the use of a particular public API item._

  Each such chunk of code is enclosed in an *implicit* ~fn main() { ... }~ and
  run as part of ~cargo test~, effectively making it an _ADDITIONAL test case_
  for your code, known as a /doc test/. /Individual tests/ can also be executed
  selectively by running ~cargo test --doc <item-name>~.

- =IMPORTANT=
  =from Jian= A reason why do we need /doc tests/.
  Regularly running tests as part of your CI environment (_Item 32_) ensures that
  your code samples don't drift too far from the current reality of your API.

*** DONE Examples - 229
CLOSED: [2025-01-13 Mon 21:02]
_Item 27_ also described the ability to provide _example programs_ that
exercise your public API.

- Each Rust file under =examples/= (or each _subdirectory_ under =examples/=
  that includes a =main.rs=) can be run as a STANDALONE BINARY with
  ~cargo run -- example <name>~ or ~cargo test --example <name>~.

- These programs have access to *ONLY* _the public API_ of your crate and are
  intended to _ILLUSTRATE the use of your API as a whole_.

  Examples are *NOT* specifically designated as test code (no ~#[test]~, no
  ~#[cfg(test)]~), and they're a poor place to put code that exercises obscure
  nooks and crannies of your crate - particularly as examples are *NOT run by
  ~cargo test~ BY DEFAULT*.

- NEVERTHELESS, it's a good idea to ensure that your CI system (_Item 32_)
  builds and runs all the associated examples for a crate (with ~cargo test
  --examples~), because it can act as a good _early warning system_ for
  regressions that are likely to affect lots of users.

  + As noted, if your examples demonstrate mainline use of your API, then a
    failure in the examples implies that something significant is wrong:
    * If it's a genuine bug, then it's likely to affect lots of users -
      =IMPORTANT=
      _the very nature of example code means that users are likely to have
      copied, pasted, and adapted the example._

    * IF it's _an intended change to the API_,
      then the examples *need to be updated* to match.

      _A change to the API also IMPLIES a *backward incompatibility*,_
      =IMPORTANT=
      so if the crate is published, then the semantic version number needs a
      corresponding update to indicate this (_Item 21_).

- The likelihood of users copying and pasting _example code_ means that it should
  have a *different style* than _test code_.

  =REMEMBER=
  In line with _Item 18_, you should set a good example for your users by
  avoiding ~unwrap()~ calls for ~Result~'s. Instead, make each example's
  ~main()~ function return something like ~Result<(), Box<dyn Error>>~, and then
  use the /question mark operator/ THROUGHOUT (_Item 3_).

*** TODO Benchmarks - =TODO: NOTE=
- Item 20 attempts to persuade you that fully optimizing the performance of your
  code isn’t always necessary. Nevertheless, there are definitely times when
  performance is critical, and if that’s the case, then it’s a good idea to
  measure and track that perfor‐ mance. Having benchmarks that are run regularly
  (e.g., as part of CI; Item 32) allows you to detect when changes to the code
  or the toolchains adversely affect that performance.

- The ~cargo bench~ command runs special test cases that repeatedly perform an
  operation, and emits average timing information for the operation. At the time
  of writing, support for benchmarks is not stable, so the precise command may
  need to be cargo +nightly bench. (Rust’s unstable features, including the test
  feature used here, are described in The Unstable Book.)

- However, there's a danger that compiler optimizations may give misleading
  results, particularly if you restrict the operation that's being performed to
  a small subset of the real code. Consider a simple arithmetic function:
  #+begin_src rust
    pub fn factorial(n: u128) -> u128 {
        match n {
            0 => 1,
            n => n * factorial(n - 1),
        }
    }
  #+end_src

  A naive benchmark for this code:
  #+begin_src rust
    #![feature(test)]
    extern crate test;

    #[bench]
    fn bench_factorial(b: &mut test::Bencher) {
        b.iter(|| {
            let result = factorial(15);
            assert_eq!(result, 1_307_674_368_000);
        });
    }
  #+end_src

  gives incredibly positive results:
  #+begin_src text
    test bench_factorial ... bench: 0 ns/iter (+/- 0)
  #+end_src

- With fixed inputs and a small amount of code under test, the compiler is able
  to optimize away the iteration and directly emit the result, leading to an
  unrealistically optimistic result.

- The ~std::hint::black_box~ function can help with this; it's an identity function
  whose implementation the compiler is “encouraged, but not required” (their
  italics) to pessimize.

- Moving the benchmark code to use this hint:
  #+begin_src rust
    #[bench]
    fn bench_factorial(b: &mut test::Bencher) {
        b.iter(|| {
            let result = factorial(std::hint::black_box(15));
            assert_eq!(result, 1_307_674_368_000);
        });
    }
  #+end_src

  gives more realistic results:
  #+begin_src text
    test blackboxed::bench_factorial ... bench: 16 ns/iter (+/- 3)
  #+end_src

- The Godbolt compiler explorer can also help by showing the actual machine code
  emitted by the compiler, which may make it obvious when the compiler has
  performed optimizations that would be unrealistic for code running a real
  scenario.

- =IMPORTANT=
  Finally, if you are including benchmarks for your Rust code, the ~criterion~
  crate may provide an alternative to the standard ~test::bench::Bencher~
  functionality that is more convenient (it runs with stable Rust) and more
  fully featured (it has support for _statistics_ and _graphs_).

*** TODO Fuzz Testing - 231 - =TODO: RE-READ and NOTE=
*** DONE Testing Advice - 234
CLOSED: [2025-01-13 Mon 21:43]
- An Item about testing WOULDN'T BE COMPLETE WITHOUT
  _repeating some common advice (which is mostly not Rust-specific)_:
  * Run all your tests in CI on every change
    + with the *EXCEPTION* of /fuzz tests/.

  * When you're fixing a bug, write a test that exhibits the bug *BEFORE* fixing
    the bug.

    That way you can be sure that
    + the bug is fixed and
    + =IMPORTANT= that it won't be accidentally reintroduced in the future.

  * If your crate has /features/ (_Item 26_), run tests over *every possible
    combination* of available features.

  * More generally, if your crate includes any config-specific code (e.g.,
    ~#[cfg(target_os = "windows")]~), run tests for every platform that has
    distinct code.

- This Item has covered a lot of different types of tests,
  so it's up to you to decide how much each of them is relevant and worthwhile
  for your project.

- If you have a lot of test code and you are publishing your crate to crates.io,
  then you might need to consider which of the tests make sense to include in
  the published crate.

  1. _BY DEFAULT,_
     cargo will include /unit tests/, /integration tests/, /benchmarks/, and
     /examples/ (but *not* /fuzz tests/, because the cargo-fuzz tools store these
     as a separate crate in a subdirectory), which may be *more than end users
     need*.

  2. If that's the case, you can
     * either ~exclude~ some of the files or
     * (for /behavior tests/) MOVE the tests OUT of the crate and into a
       *SEPARATE* /test crate/.

*** TODO Things to Remember - 234

** TODO Item 31: Take advantage of the tooling ecosystem - 235
*** Tools to Remember

** TODO Item 32: Set up a continuous integration (CI) system - 237
*** CI Steps
*** CI Principles
*** Public CI Systems

* TODO 6. Beyond Standard Rust - 243
** Item 33: Consider making library code ~no_std~ compatible - 243
*** ~core~
*** ~alloc~
*** Writing Code for ~no_std~
*** Fallible Allocation
*** Things to Remember

** Item 34: Control what crosses FFI boundaries - 249
*** Invoking C Functions from Rust
**** Linking logistics
**** Code concerns
**** Name mangling

*** Accessing C Data from Rust
*** Lifetimes
*** Invoking Rust from C
*** Things to Remember

** Item 35: Prefer bindgen to manual FFI mappings - 261
*** Beyond C

* Afterword - 265
* Index - 267
