#+TITLE: Effective Rust
#+AUTHOR: David Drysdale
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Preface - v
* 1. Types - 1
** Item 1: Use the type system to express your data structures - 2
** Item 2: Use the type system to express common behavior - 10
** Item 3: Prefer ~Option~ and ~Result~ transforms over explicit ~match~ expressions - 20
** Item 4: Prefer idiomatic ~Error~ types - 25
** Item 5: Understand type conversions - 34
** Item 6: Embrace the newtype pattern - 40
** Item 7: Use builders for complex types - 45
** Item 8: Familiarize yourself with reference and pointer types - 51
** Item 9: Consider using iterator transforms instead of explicit loops - 64

* 2. Traits - 77
** Item 10: Familiarize yourself with standard traits - 77
Rust encodes key behavioral aspects of its type system in the type system
itself, through a collection of fine-grained standard traits that describe those
behaviors (see Item 2)

*** Common Standard Traits
**** ~Clone~
**** ~Copy~
**** ~Default~
**** ~PartialEq~ and ~Eq~
**** ~PartialOrd~ and ~Ord~
**** ~Hash~
**** ~Debug~ and ~Display~

*** Standard Traits Covered Elsewhere
*** Operator Overloads
- Rust allows various built-in unary and binary operators to be overloaded for
  /user-defined types/, by implementing various standard traits from the
  ~std::ops~ module.

  * These traits
    + are *NOT derivable* and
    + are typically needed *ONLY* for types that represent “algebraic” objects,
      where there is a natural interpretation of these operators.

- However, experience from C++ has shown that it's best to *avoid* overloading
  operators for unrelated types as it often leads to code that is _hard to maintain_
  and has unexpected performance properties (e.g., x + y silently invokes an
  expensive O(N) method).

  * To comply with the principle of least astonishment, if you implement any operator
    overloads, you should implement a *COHERENT* set of operator overloads.
    + For example,
      if x + y has an overload (Add), and -y (Neg) does too, then you should also
      implement x - y (Sub) and make sure it gives the same answer as x + (-y).

- The items passed to the operator overload traits are *moved*, which means that
  nonCopy types will be consumed by default. Adding implementations for ~&'a
  MyType~ can help with this but requires more boilerplate to cover all of the
  possibilities (e.g., there are 4 = 2 × 2 possibilities for combining
  reference/non-reference arguments to a binary operator).

*** Summary

** Item 11: Implement the ~Drop~ trait for RAII patterns - 89
** TODO Item 12: Understand the trade-offs between generics and trait objects - 93
- _Item 2_ described the use of traits to encapsulate behavior in the type system,
  as a collection of related methods, and observed that there are _TWO_ ways to
  make use of traits:
  * as /trait bounds/ for generics or
  * in /trait objects/.

  This Item explores the trade-offs between these two possibilities.

- As a running example, consider a /trait/ that covers functionality for displaying
  graphical objects:
  #+begin_src rust
    #[derive(Debug, Copy, Clone)]
    pub struct Point {
        x: i64,
        y: i64,
    }

    #[derive(Debug, Copy, Clone)]
    pub struct Bounds {
        top_left: Point,
        bottom_right: Point,
    }

    /// Calculate the overlap between two rectangles, or `None` if there is no
    /// overlap.
    fn overlap(a: Bounds, b: Bounds) -> Option<Bounds> {
        // ...
    }

    /// Trait for objects that can be drawn graphically.
    pub trait Draw {
        /// Return the bounding rectangle that encompasses the object.
        fn bounds(&self) -> Bounds;
        // ...
    }
  #+end_src

*** Generics
- Specific uses of the generic code are generated at /compile time/ -- a process
  known as
  * /monomorphization/ in Rust, and
  * /template instantiation/ in C++.

- Unlike C++, Rust explicitly encodes the expectations for the type ~T~ in the
  /type system/, in the form of /trait bounds/ for the /generic/.

- For the example, a /generic function/ that uses the trait's ~bounds()~ method
  has an explicit ~Draw~ /trait bound/, *THREE* ways in syntax (same effect):
  1. Bound in ~where~ clause:
     #+begin_src rust
       pub fn on_screen<T>(draw: &T) -> bool
       where
           T: Draw,
       {
           overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
       }
     #+end_src

  2. Bound in ~where~ clause:
     #+begin_src rust
       pub fn on_screen<T: Draw>(draw: &T) -> bool {
           overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
       }
     #+end_src

  3. Bound in ~where~ clause:
     #+begin_src rust
       pub fn on_screen(draw: &impl Draw) -> bool {
           overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
       }
     #+end_src

- The programmer writes a _SINGLE_ /generic function/, but the compiler outputs a
  _DIFFERENT_ monomorphized version of that function for every different type that
  the function is invoked with.

*** Trait Objects
In comparison, /trait objects/ are /fat pointers/ (_Item 8_) that combine a
pointer to the underlying concrete item with a pointer to a /vtable/ that in
turn holds /function pointers/ for all of the /trait implementation's methods/,
as depicted in Figure 2-1:
#+begin_src rust
  let square = Square {
      top_left: Point { x: 1, y: 2 },
      size: 2,
  };

  let draw: &dyn Draw = &square;
#+end_src

This means that a function that accepts a /trait object/ _doesn't need to be
/generic/ and doesn't need /monomorphization/._

#+begin_src rust
  /// Indicate whether an object is on-screen.
  pub fn on_screen(draw: &dyn Draw) -> bool {
      overlap(SCREEN_BOUNDS, draw.bounds()).is_some()
  }

  // Calls `on_screen(&dyn Draw) -> bool`.
  let visible = on_screen(&square);
  // Also calls `on_screen(&dyn Draw) -> bool`.
  let visible = on_screen(&circle);
#+end_src

*** Basic Comparisons
- These basic facts already allow some immediate comparisons between the two
  possibilities:
  * Generics are likely to lead to bigger code sizes, because the compiler
    generates a fresh copy (on_screen::<T>(&T)) of the code for every type T that
    uses the generic version of the on_screen function. In contrast, the trait
    object version (on_screen(&dyn T)) of the function needs only a single
    instance.

  * Invoking a trait method from a generic will generally be ever-so-slightly
    faster than invoking it from code that uses a trait object, because the
    latter needs to perform two dereferences to find the location of the code
    (trait object to vtable, vtable to implementation location).

  * Compile times for generics are likely to be longer, as the compiler is
    building more code and the linker has more work to do to fold duplicates.

*** More Trait Bounds
*** Trait Object Safety
*** Trade-Offs

** DONE Item 13: Use default implementations to minimize required trait methods - 103
CLOSED: [2024-08-27 Tue 00:25]
- =From Jian=
  This is similar in Rust and in other languages whose interfaces
  ALLOW /default method implementation/.

- /Trait methods/ can impose /trait bounds/, indicating that a method is ONLY
  available if the types involved implement particular traits.

* 3. Concepts - 105
** Item 14: Understand lifetimes - 106
*** Introduction to the Stack
*** Evolution of Lifetimes
*** Scope of a Lifetime
*** Algebra of Lifetimes
*** Lifetime Elision Rules
*** The ~'static~ Lifetime
*** Lifetimes and the Heap
*** Lifetimes in Data Structures
*** Anonymous Lifetimes
*** Things to Remember

** Item 15: Understand the borrow checker - 123
*** Access Control
*** Borrow Rules
*** Owner Operations
*** Winning Fights Against the Borrow Checker
**** Local code refactoring
**** Data structure design
**** Smart pointers
**** Self-referential data structures

*** Things to Remember

** Item 16: Avoid writing ~unsafe~ code - 142
** Item 17: Be wary of shared-state parallelism - 145
*** Data Races
**** Data races in C++
**** Data races in Rust
**** Standard marker traits

*** Deadlocks
*** Advice

** Item 18: Don't panic - 159
** Item 19: Avoid reflection - 162
*** Upcasting in Future Versions of Rust

** Item 20: Avoid the temptation to over-optimize - 169
*** Data Structures and Allocation
*** Who’s Afraid of the Big Bad Copy?
*** References and Smart Pointers

* 4. Dependencies - 175
** Item 21: Understand what semantic versioning promises - 176
*** Semver Essentials
*** Semver for Crate Authors
*** Semver for Crate Users
*** Discussion

** Item 22: Minimize visibility - 181
*** Visibility Syntax
*** Visibility Semantics

** Item 23: Avoid wildcard imports - 186
** Item 24: Re-export dependencies whose types appear in your API - 188
** Item 25: Manage your dependency graph - 191
*** Version Specification
*** Solving Problems with Tooling
*** What to Depend On
*** Things to Remember

** Item 26: Be wary of feature creep - 197
*** Conditional Compilation
*** Features
*** Things to Remember

* 5. Tooling - 203
** Item 27: Document public interfaces - 203
*** Tooling
*** Additional Documentation Locations
*** Published Crate Documentation
*** What Not to Document
*** Things to Remember

** Item 28: Use macros judiciously - 209
*** Declarative Macros
*** Procedural Macros
**** Function-like macros
**** Attribute macros
**** Derive macros

*** When to Use Macros
*** Disadvantages of Macros
*** Advice

** Item 29: Listen to Clippy - 223
** Item 30: Write more than unit tests - 227
*** Unit Tests
*** Integration Tests
*** Doc Tests
*** Examples
*** Benchmarks
*** Fuzz Testing
*** Testing Advice
*** Things to Remember

** Item 31: Take advantage of the tooling ecosystem - 235
*** Tools to Remember

** Item 32: Set up a continuous integration (CI) system - 237
*** CI Steps
*** CI Principles
*** Public CI Systems

* 6. Beyond Standard Rust - 243
** Item 33: Consider making library code ~no_std~ compatible - 243
*** ~core~
*** ~alloc~
*** Writing Code for ~no_std~
*** Fallible Allocation
*** Things to Remember

** Item 34: Control what crosses FFI boundaries - 249
*** Invoking C Functions from Rust
**** Linking logistics
**** Code concerns
**** Name mangling

*** Accessing C Data from Rust
*** Lifetimes
*** Invoking Rust from C
*** Things to Remember

** Item 35: Prefer bindgen to manual FFI mappings - 261
*** Beyond C

* Afterword - 265
* Index - 267
