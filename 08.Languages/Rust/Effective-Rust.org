#+TITLE: Effective Rust
#+AUTHOR: David Drysdale
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* TODO Preface - v
* TODO 1. Types - 1 - READING
- The Items in this chapter cover
  * the fundamental types that the language provides and
  * how to combine them into data structures that _precisely express the semantics
    of your program._

- =IMPORTANT=
  This concept of *encoding behavior into the type system*
  helps to
  _reduce the amount of checking and error path code that's required,_

  BECAUSE invalid states are rejected by the toolchain at /compile time/ rather
  than by the program at /runtime/.

- This chapter also describes
  some of the ubiquitous data structures that are provided by Rust's standard library:
  * ~Option~'s,
  * ~Result~'s,
  * ~Error~'s and
  * ~Iterator~'s.

  Familiarity with these standard tools will help you write idiomatic Rust that
  is efficient and compact— in particular, they allow use of Rust’s question
  mark operator, which supports error handling that is unobtrusive but still
  type-safe.

- This chapter has a degree of overlap with next chapter (about Rust /traits/),
  *because /traits/ describe the behavior of /types/.*

** TODO Item 1: Use the type system to express your data structures - 2
*** Fundamental Types
*** Aggregate Types
*** enums
*** enums with Fields
*** Ubiquitous enum Types
**** ~Option<T>~
**** ~Result<T, E>~

** TODO Item 2: Use the type system to express common behavior - 10
*** Functions and Methods
*** Function Pointers
*** Closures
*** Traits
**** Trait bounds
**** Trait objects

** TODO Item 3: Prefer ~Option~ and ~Result~ transforms over explicit ~match~ expressions - 20
*** Things to Remember

** TODO Item 4: Prefer idiomatic ~Error~ types - 25
*** The ~Error~ Trait
*** Minimal Errors
*** Nested Errors
*** Trait Objects
*** Libraries Versus Applications
*** Things to Remember

** TODO Item 5: Understand type conversions - 34
*** User-Defined Type Conversions
*** Casts
*** Coercion

** TODO Item 6: Embrace the newtype pattern - 40
*** Bypassing the Orphan Rule for Traits
*** Newtype Limitations

** DONE Item 7: Use builders for complex types - 45
CLOSED: [2024-08-20 Tue 00:17]
- Rust insists that all fields in a struct must be filled in when a new instance
  of that struct is created. This
  * keeps the code safe by ensuring that there are never any uninitialized values
  * BUT does lead to more verbose boilerplate code than is ideal.

- For example, any optional fields have to be explicitly marked as absent with ~None~:
  #+begin_src rust
    /// Phone number in E164 format.
    #[derive(Debug, Clone)]
    pub struct PhoneNumberE164(pub String);

    #[derive(Debug, Default)]
    pub struct Details {
        pub given_name: String,
        pub preferred_name: Option<String>,
        pub middle_name: Option<String>,
        pub family_name: String,
        pub mobile_phone: Option<PhoneNumberE164>,
    }

    // ...

    let dizzy = Details {
        given_name: "Dizzy".to_owned(),
        preferred_name: None,
        middle_name: None,
        family_name: "Mixer".to_owned(),
        mobile_phone: None,
    };
  #+end_src
  * =IMPORTANT=
    _This boilerplate code is also brittle, in the sense that_
    a future change that adds a new field to the struct requires an update to
    every place that builds the structure.

  * The boilerplate can be significantly reduced by implementing and using the
    ~Default~ trait, as described in *Item 10*:
    #+begin_src rust
      let dizzy = Details {
          given_name: "Dizzy".to_owned(),
          family_name: "Mixer".to_owned(),
          ..Default::default()
      };
    #+end_src
    1. However, automatically derive implementation of ~Default~ requires all of
       the field types implement the ~Default~ trait. This is not always true.
       - For instance, this doesn't work for a modified ~Details~:
         #+begin_src rust
           // Can't compile!!!
           #[derive(Debug, Default)]
           pub struct Details {
               pub given_name: String,
               pub preferred_name: Option<String>,
               pub middle_name: Option<String>,
               pub family_name: String,
               pub mobile_phone: Option<PhoneNumberE164>,
               pub date_of_birth: time::Date,
               pub last_seen: Option<time::OffsetDateTime>,
           }
         #+end_src
         This can't compile have two reasons:
         * _SYNTAX reason_: orphan rule
         * _LOGICAL reason_: using a default value for date of birth is going to be
           wrong almost all of the time.

    2. The absence of ~Default~ means that all of the fields have to be filled out manually:
       #+begin_src rust
         let bob = Details {
             given_name: "Robert".to_owned(),
             preferred_name: Some("Bob".to_owned()),
             middle_name: Some("the".to_owned()),
             family_name: "Builder".to_owned(),
             mobile_phone: None,
             date_of_birth: time::Date::from_calendar_date(
                 1998,
                 time::Month::November,
                 28,
             )
             .unwrap(),
             last_seen: None,
         };
       #+end_src
       *These ergonomics can be improved if you implement the /builder pattern/
       for complex data structures.*

- _Version 0_:
  The simplest variant of the builder pattern:
  #+begin_src rust
    pub struct DetailsBuilder(Details);

    impl DetailsBuilder {
        /// Start building a new [`Details`] object.
        pub fn new(
            given_name: &str,
            family_name: &str,
            date_of_birth: time::Date,
        ) -> Self {
            DetailsBuilder(Details {
                given_name: given_name.to_owned(),
                preferred_name: None,
                middle_name: None,
                family_name: family_name.to_owned(),
                mobile_phone: None,
                date_of_birth,
                last_seen: None,
            })
        }
    }
  #+end_src

  The builder type, here it is ~DetailsBuilder~, can then be equipped with
  /helper methods/ that fill out the nascent item's fields.

  * Each such method consumes ~self~ but emits a new ~Self~, allowing different
    construction methods to be _chained_:
    #+begin_src rust
      impl DetailsBuilder {
          // pub fn new(...) ...


          // setter-like helper methods

          /// Set the preferred name.
          pub fn preferred_name(mut self, preferred_name: &str) -> Self {
              self.0.preferred_name = Some(preferred_name.to_owned());
              self
          }

          /// Set the middle name.
          pub fn middle_name(mut self, middle_name: &str) -> Self {
              self.0.middle_name = Some(middle_name.to_owned());
              self
          }

          // other helper methods
          /// Update the `last_seen` field to the current date/time.
          pub fn just_seen(mut self) -> Self {
              self.0.last_seen = Some(time::OffsetDateTime::now_utc());
              self
          }
      }
    #+end_src

  * The final method to be invoked for the builder consumes the builder and emits
    the built item:
    #+begin_src rust
      // impl DetailsBuilder


      /// Consume the builder object and return a fully built [`Details`]
      /// object.
      pub fn build(self) -> Details {
          self.0
      }
    #+end_src
    *The all-consuming nature of this style of builder leads to a couple of wrinkles.*

    1. The first is that separating out stages of the build process can't be done
       on its own:
       #+begin_src rust
         // Does not compile

         let builder = DetailsBuilder::new(
             "Robert",
             "Builder",
             time::Date::from_calendar_date(1998, time::Month::November, 28)
                 .unwrap(),
         );
         if informal {
             builder.preferred_name("Bob");
         }
         let bob = builder.build();
       #+end_src

       Here is the workaround:
       #+begin_src rust
         let mut builder = DetailsBuilder::new(
             "Robert",
             "Builder",
             time::Date::from_calendar_date(1998, time::Month::November, 28)
                 .unwrap(),
         );
         if informal {
             builder = builder.preferred_name("Bob");
         }
         let bob = builder.build();
       #+end_src

    2. The other downside to the all-consuming nature of this builder is that only
       one item can be built; trying to create multiple instances by repeatedly
       calling ~build()~ on the same builder *FALLS* foul of the compiler, as you'd
       expect.

- _Version 1_:
  Change all helper function signatures, except the ~build~ function's, to ~&mut
  self -> &mut Self~.

  This can help remove self-assignment in separate build stages,
  #+begin_src rust
    let mut builder = DetailsBuilder::new(
        "Robert",
        "Builder",
        time::Date::from_calendar_date(1998, time::Month::November, 28)
            .unwrap(),
    );
    if informal {
        builder.preferred_name("Bob"); // no `builder = ...`
    }
    let bob = builder.build();
  #+end_src

  but it also make it *impossible to chain* the construction of the /builder/
  together with invocation of its setter methods:
  #+begin_src rust
    // Can't compile

    let builder = DetailsBuilder::new(
        "Robert",
        "Builder",
        time::Date::from_calendar_date(1998, time::Month::November, 28)
            .unwrap(),
    )
    .middle_name("the")
    .just_seen();

    let bob = builder.build();
  #+end_src

  Compilation error:
  #+begin_src text
    error[E0716]: temporary value dropped while borrowed
       --> src/main.rs:265:19
        |
    265 |       let builder = DetailsBuilder::new(
        |  ___________________^
    266 | |         "Robert",
    267 | |         "Builder",
    268 | |         time::Date::from_calendar_date(1998, time::Month::November, 28)
    269 | |              .unwrap(),
    270 | |     )
        | |_____^ creates a temporary value which is freed while still in use
    271 |       .middle_name("the")
    272 | |     .just_seen();
        |                   - temporary value is freed at the end of this statement
    273 |       let bob = builder.build();
        |                 --------------- borrow later used here
        |
        = note: consider using a `let` binding to create a longer lived value
  #+end_src

- _Version 2_:
  As indicated by the compiler error in Version 1, you can work around this by
  letting the builder item have a name:
  #+begin_src rust
    let mut builder = DetailsBuilder::new(
        "Robert",
        "Builder",
        time::Date::from_calendar_date(1998, time::Month::November, 28)
            .unwrap(),
    );
    builder.middle_name("the").just_seen();
    if informal {
        builder.preferred_name("Bob");
    }
    let bob = builder.build();
  #+end_src
  _This mutating builder variant also allows for building multiple items._
  Of course, ~build~ method implementation need change because of its signature change:
  #+begin_src rust
    /// Construct a fully built [`Details`] object.
    pub fn build(&self) -> Details {
        // ...
    }
  #+end_src

  The implementation of this *repeatable* ~build()~ method then has to construct
  a fresh item on each invocation.
  * If the underlying item implements ~Clone~, this is easy -- the builder can
    hold a template and ~clone()~ it for each build.

  * If the underlying item doesn't implement ~Clone~, then the builder needs to
    have enough state to be able to manually construct an instance of the
    underlying item on each call to ~build()~.
    =IMPORTANT=
    =???=
    =TODO: Need examples=

- With any style of builder pattern, the boilerplate code is now *confined to one
  place* -- the builder -- rather than being needed at every place that uses the
  underlying type.

- The boilerplate that remains can potentially be reduced still further by use of
  a /macro/ (Item 28),

  =TODO=
  =TODO=
  =TODO=
  _BUT_ if you go down this road, you should also check whether there's an
  existing crate (such as the *derive_builder* crate, in particular) that
  provides what's needed -- assuming that you're happy to take a dependency on
  it (Item 25).

** TODO Item 8: Familiarize yourself with reference and pointer types - 51
*** Rust References
*** Pointer Traits
*** Fat Pointer Types
**** Slices
**** Trait objects

*** More Pointer Traits
*** Smart Pointer Types

** TODO Item 9: Consider using iterator transforms instead of explicit loops - 64
*** Iterator Traits
*** Iterator Transforms
*** Iterator Consumers
*** Building Collections from ~Result~ Values
*** Loop Transformation
*** When Explicit Is Better

* TODO 2. Traits - 77
** Item 10: Familiarize yourself with standard traits - 77
*** Common Standard Traits
**** ~Clone~
**** ~Copy~
**** ~Default~
**** ~PartialEq~ and ~Eq~
**** ~PartialOrd~ and ~Ord~
**** ~Hash~
**** ~Debug~ and ~Display~

*** Standard Traits Covered Elsewhere
*** Operator Overloads
*** Summary

** Item 11: Implement the ~Drop~ trait for RAII patterns - 89
** Item 12: Understand the trade-offs between generics and trait objects - 93
*** Generics
*** Trait Objects
*** Basic Comparisons
*** More Trait Bounds
*** Trait Object Safety
*** Trade-Offs

** Item 13: Use default implementations to minimize required trait methods - 103

* 3. Concepts - 105
** Item 14: Understand lifetimes - 106
** Item 15: Understand the borrow checker - 123
** Item 16: Avoid writing ~unsafe~ code - 142
** Item 17: Be wary of shared-state parallelism - 145
** Item 18: Don't panic - 159
** Item 19: Avoid reflection - 162
** Item 20: Avoid the temptation to over-optimize - 169

* 4. Dependencies - 175
** Item 21: Understand what semantic versioning promises - 176
** Item 22: Minimize visibility - 181
** Item 23: Avoid wildcard imports - 186
** Item 24: Re-export dependencies whose types appear in your API - 188
** Item 25: Manage your dependency graph - 191
** Item 26: Be wary of feature creep - 197

* 5. Tooling - 203
** Item 27: Document public interfaces - 203
** Item 28: Use macros judiciously - 209
** Item 29: Listen to Clippy - 223
** Item 30: Write more than unit tests - 227
** Item 31: Take advantage of the tooling ecosystem - 235
** Item 32: Set up a continuous integration (CI) system - 237

* 6. Beyond Standard Rust - 243
** Item 33: Consider making library code ~no_std~ compatible - 243
** Item 34: Control what crosses FFI boundaries - 249
** Item 35: Prefer bindgen to manual FFI mappings - 261

* Afterword - 265
* Index - 267
