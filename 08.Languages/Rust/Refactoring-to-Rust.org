#+TITLE: Refactoring to Rust
#+VERSION: 2025
#+AUTHOR: Lily Mara, Joel Holmes
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

** preface - xi
** acknowledgments - xii
** about this book - xiv
** about the authors - xvii
** about the cover illustration - xviii

* TODO 1 Why refactor to Rust - 1
** 1.1 What is refactoring? - 2
** 1.2 What is Rust? - 4
** 1.3 Why Rust? - 4
** 1.4 Should you refactor to Rust? - 5
*** Performance - 5
*** Memory safety - 7
*** Maintainability - 7

** 1.5 When not to refactor to Rust - 9
** 1.6 How does it work? - 9
** 1.7 What will you learn in this book? - 11
*** Calling Rust functions directly from your program - 11
*** Communicating with a Rust service over the network - 12

** 1.8 Who is this book for? - 13
** 1.9 What tools do you need to get started? - 13

* TODO 2 An overview of Rust - 15
** 2.1 Ownership and borrowing - 16
** 2.2 Memory management in other languages - 19
** 2.3 Lifetimes - 23
*** References and borrowing - 26
*** Controlling mutability - 28
*** References and lifetimes - 30

** 2.4 Rust's string types - 33
*** Mutable strings - 34

** 2.5 Enums and error handling - 37
*** Enums - 37
*** Error handling with enums - 41
*** The unit type - 43
*** Error types - 45
*** Transforming errors - 49
*** Panicking with errors - 53

* TODO 3 Introduction to C FFI and unsafe Rust - 60
** 3.1 Unsafe Rust - 61
*** Raw pointers - 61

** 3.2 C Foreign Function Interface - 64
*** Including a crate - 68
*** Creating a dynamic library with Rust - 70
*** Solving arithmetic expressions in Rust - 77
*** The Display trait - 87

* TODO 4 Advanced FFI - 93
** 4.1 Downloading the NGINX source code - 94
** 4.2 Creating the NGINX module - 94
** 4.3 Linking C to Rust - 98
*** Build scripts - 100
*** bindgen - 103

** 4.4 Reading the NGINX request - 109
*** Lifetime annotations - 115
*** Lifetime annotations in our
*** NGINX plugin - 120

** 4.5 Using our calculator library - 124
** 4.6 Writing the HTTP response - 128

* TODO 5 Structuring Rust libraries - 138
** 5.1 Modules - 138
*** Who cares? - 142
*** Multiple files - 143

** 5.2 Paths - 146
*** Relative vs. absolute pathspaths - 147
*** Path aliases - 155

** 5.3 Upward visibility - 159

* TODO 6 Integrating with dynamic languages - 164
** 6.1 Data processing in Python - 164
** 6.2 Planning the move - 165
** 6.3 JSON Parsing - 166
** 6.4 Writing a Python extension module in Rust - 171
** 6.5 Benchmarking in Rust - 176
** 6.6 Optimized builds - 184

* TODO 7 Testing your Rust integrations - 187
** 7.1 Writing tests with Rust - 187
*** Documentation tests - 193
*** Adding tests to existing code - 198

** 7.2 Testing Rust code using Python - 202
*** Monkey patching - 206

* TODO 8 Asynchronous Python with Rust - 212
** 8.1 Generating a Mandelbrot set in Python - 213
** 8.2 Scaling - 215
** 8.3 Asyncio - 218
** 8.4 Threading - 220
** 8.5 Global Interpreter Lock - 223
** 8.6 PyO3 - 224

* TODO 9 WebAssembly for refactoring JavaScript - 229
** 9.1 What is WebAssembly? - 230
** 9.2 Moving from JavaScript to Rust - 231
** 9.3 Rust in the browser - 232
*** Requesting data - 232
*** Compiling to Wasm - 235
*** Loading Wasm in the browser - 237

** 9.4 Creating a React component - 238
** 9.5 Web components entirely in Rust - 241
** 9.6 Refactoring JavaScript revisited - 247

* TODO 10 WebAssembly interface for refactoring - 249
** 10.1 WASI universal runtime - 252
** 10.2 From the browser to the machine - 255
** 10.3 Wasm library - 261
** 10.4 Consuming Wasm - 262
** 10.5 More Wasm - 267
** 10.6 Wasm memory - 270
** 10.7 Just the beginning - 275

* index - 277
