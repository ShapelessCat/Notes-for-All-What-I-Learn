#+TITLE: The Rust Reference
#+STARTUP: indent
#+STARTUP: overview
#+STARTUP: entitiespretty

* Introduction
* 1. Notation
* 2. Lexical structure
** 2.1. Input format
** 2.2. Keywords
** 2.3. Identifiers
** 2.4. Comments
** 2.5. Whitespace
** 2.6. Tokens

* 3. Macros
** 3.1. Macros By Example
** 3.2. Procedural Macros

* 4. Crates and source files
* 5. Conditional compilation
* 6. Items
** 6.1. Modules
** 6.2. Extern crates
** 6.3. Use declarations
** 6.4. Functions
** 6.5. Type aliases
** 6.6. Structs
** 6.7. Enumerations
** 6.8. Unions
** 6.9. Constant items
** 6.10. Static items
** 6.11. Traits
** 6.12. Implementations
** 6.13. External blocks
** 6.14. Generic parameters
** 6.15. Associated Items

* 7. Attributes
** 7.1. Testing
** 7.2. Derive
** 7.3. Diagnostics
** 7.4. Code generation
** 7.5. Limits
** 7.6. Type System
** 7.7. Debugger

* 8. Statements and expressions
** 8.1. Statements
** 8.2. Expressions
*** 8.2.1. Literal expressions
*** 8.2.2. Path expressions
*** 8.2.3. Block expressions
*** 8.2.4. Operator expressions
*** 8.2.5. Grouped expressions
*** 8.2.6. Array and index expressions
*** 8.2.7. Tuple and index expressions
*** 8.2.8. Struct expressions
*** 8.2.9. Call expressions
*** 8.2.10. Method call expressions
*** 8.2.11. Field access expressions
*** 8.2.12. Closure expressions
*** 8.2.13. Loop expressions
*** 8.2.14. Range expressions
*** 8.2.15. If and if let expressions
*** 8.2.16. Match expressions
*** 8.2.17. Return expressions
*** 8.2.18. Await expressions
*** 8.2.19. Underscore expressions

* 9. Patterns
* 10. Type system
** 10.1. Types
*** 10.1.1. Boolean type
*** 10.1.2. Numeric types
*** 10.1.3. Textual types
*** 10.1.4. Never type
*** 10.1.5. Tuple types
*** 10.1.6. Array types
*** 10.1.7. Slice types
*** 10.1.8. Struct types
*** 10.1.9. Enumerated types
*** 10.1.10. Union types
*** 10.1.11. Function item types
*** 10.1.12. Closure types
*** 10.1.13. Pointer types
*** 10.1.14. Function pointer types
*** 10.1.15. Trait object types
*** 10.1.16. Impl trait type
*** 10.1.17. Type parameters
*** 10.1.18. Inferred type
** 10.2. Dynamically Sized Types
** 10.3. Type layout
** 10.4. Interior mutability
** 10.5. Subtyping and Variance
** 10.6. Trait and lifetime bounds
** 10.7. Type coercions
** 10.8. Destructors
** 10.9. Lifetime elision

* 11. Special types and traits
* 12. Names
** 12.1. Namespaces
** 12.2. Scopes
** 12.3. Preludes
** 12.4. Paths
** 12.5. Name resolution
** 12.6. Visibility and privacy

* 13. Memory model
** 13.1. Memory allocation and lifetime
** 13.2. Variables

* 14. Linkage
* 15. Inline assembly
* 16. Unsafety
** 16.1. The unsafe keyword
** 16.2. Behavior considered undefined
** 16.3. Behavior not considered unsafe

* 17. Constant Evaluation
* 18. Application Binary Interface
* 19. The Rust runtime
* 20. Appendices
** 20.1. Macro Follow-Set Ambiguity Formal Specification
** 20.2. Influences
** 20.3. Glossary
