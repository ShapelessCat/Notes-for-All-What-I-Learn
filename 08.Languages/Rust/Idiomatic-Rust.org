#+TITLE: Idiomatic Rust
#+SUBTITLE: Code like a Rustacean
#+AUTHOR: Brenden Matthews
#+YEAR: 2024
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

** preface - xi
- Internet Relay Chat (IRC)
- =en= infancy
- =en= grateful

** acknowledgments - xii
** about this book - xiv
- This book grew out of my other book, Code Like a Pro in Rust (Manning Publications, 2024).

*** How is this book different?
*** Who should read this book?
*** How this book is organized
*** How to read this book
This book is organized into four parts, each consisting of chapters that cover a
specific aspect of Rust programming.
- Part 1 is a review of Rust’s core features and building blocks:
  * Chapter 1 discusses the content of the book and introduces design patterns.
  * Chapter 2 presents the basic building blocks of Rust.
  * Chapter 3 reviews pattern matching and functional programming.

- Part 2 goes into detail on Rust’s core patterns and library design:
  * Chapter 4 introduces core patterns in Rust.
  * Chapter 5 presents Rust design patterns.
  * Chapter 6 discusses library design.

- Part 3 covers more advanced patterns in Rust:
  * Chapter 7 discusses advanced techniques and patterns in Rust.
  * Chapter 8 builds on the topics in chapter 7.

- Part 4 discusses how to avoid problems and build robust software:
  * Chapter 9 discusses immutability and how it’s used in Rust.
  * Chapter 10 presents several antipatterns and shows how to avoid them.

*** About the code
*** liveBook discussion forum

** about the author - xviii
** about the cover illustration - xix

* DONE PART 1 BUILDING BLOCKS - 1
CLOSED: [2024-10-06 Sun 23:19]
- =en= at our disposal effectively

** 1 Rust-y patterns - 3
- This chapter covers
  * What this book covers
  * What design patterns are
  * Why this book is different
  * Tools you’ll need

- =TODO=
  Reading code is often more challenging than writing code.

- We can take advantage of millions of years of evolution by teaching our brains
  which /patterns/ to recognize, short-circuiting the challenge of judging code
  quality.
  =GOOD QUOTE=

- =en= a curated experience

*** 1.1 What this book covers - 4
- =en= grok
- =en= mental gymnastics
- =en= cruft
- =en= foster

*** 1.2 What design patterns are - 5
- I refer to
  _techniques_,
  _idioms_, and
  _conventions_
  that are widely used and understood by the Rust community as /patterns/.

- I use /patterns/ and /design patterns/ *interchangeably* _throughout this
  book_, but I generally refer to patterns as a subset of design patterns.

- I'll focus on *TWO* key points:
  * idioms :: generally relate to the _code_ itself
  * patterns :: generally relate to the _design and architecture_ of your software.
    + Another way to say the same thing:
      /patterns/ are composed of /idioms/.

- =en= march to the beat of your own drum

*** 1.3 Why this book is different - 8
- =en= mimicry

- Rust's unique language features require a little more thought
  WHEN it comes to _API design and the act of building high-quality code_.
  In particular, we have to think harder about
  HOW we
  * manage memory and object lifetimes,
  * pass values between contexts,
  * avoid race conditions, and
  * ensure that our APIs are ergonomic.

- Rust is full of greenfield opportunities to _create or discover_ *new* /patterns/,
  which will certainly evolve after this book is published.
  * Rust's abstractions SIMULTANEOUSLY
    1. unlock new patterns and
    2. make old patterns obsolete.

*** 1.4 Tools you'll need - 9
- Table 1.1 Required tools
  * _git_
  * _rustup_
  * _gcc_ or _clang_

- Summary
  * Good design patterns are reusable, broadly applicable, and capable of solving
    common programming problems.

  * The hallmarks of a good design pattern are that it becomes widely adopted over
    time and is easy to understand and reason about.

  * An antipattern is a design pattern that’s poorly understood, underspecified, or
    considered harmful.

  * This book presents Rust-specific design patterns that take advantage of the
    unique features provided by the Rust language and its tooling.

  * You need an up-to-date installation of Rust, Git, and a modern compiler such as
    GNU’s GCC or LLVM’s Clang.

  * To get the most out of this book, follow along with the code samples at
    https://github.com/brndnmtthws/idiomatic-rust-book.

** 2 Rust's basic building blocks - 10
- This chapter covers
  * Exploring the core Rust patterns
  * Diving into Rust generics
  * Exploring traits
  * Combining generics and traits
  * Deriving traits automatically

*** DONE 2.1 Generics - 11
CLOSED: [2024-10-06 Sun 12:37]
=en= kludgy

**** 2.1.1 A Turing-complete type system - 11
- One example of _using types for computation_ is a _Minsky machine_ implemented
  with Rust's type system, which you can find at https://github.com/paholg/minsky.
  =IMPORTANT=

  * A _Minsky machine_ is a simple _register-based counter machine_ that is
    computationally equivalent to a /Turing machine/, and we can think of a
    _Minsky machine_ as analogous to a simple CPU. Thus, if we can build a
    _Minsky machine_ using Rust's type system, we can effectively use Rust's
    type system to compute anything that's computable.

**** 2.1.2 Why generics? - 12
**** 2.1.3 Basics of generics - 12
**** 2.1.4 Exploring Rust's ~Option~ - 15
**** 2.1.5 Marker structs and phantom types - 15
We can add a /phantom field/ to let the compiler know that we want the
parameter, but we only care about the value at compile time and thus don't need
to store it in the struct.

- Lifetimes and ~'static~
  =IMPORTANT=
  * All /string literals/ have a ~'static~ /lifetime/, so we don't necessarily
    need to specify a /lifetime/ for them.

  * If you're returning a /string literal/ from a function, you can return it as a
    ~&'static str~ if you want to specify the /lifetime/ explicitly.

  * Including the ~'static~ /lifetime/ for a ~string literal~ is optional,
    _BUT_ including it can be advantageous if you're returning a /string
    literal/ from a function because the /lifetime/ makes it clear that the
    /string literal/ will be valid for the duration of the program.

**** 2.1.6 Generic parameter trait bounds - 18

*** DONE 2.2 Traits - 18
CLOSED: [2024-10-06 Sun 14:04]
- With that power comes responsibility.
  Traits come with two significant downsides:
  * /trait pollution/
  * /trait duplication/
  =NEXT= We'll discuss how to avoid these problems.

- Traits allow you to _define shared functionality for Rust types_.
  1. Instances of types (objects) contain state (such as a struct), and
  2. traits define functionality on top of that state in a generic way
     not tied to any particular type.

- /Traits/ aren't unique to Rust.
  They first appeared in a somewhat obscure programming language called _Self_.
  Several other languages offer /traits/:
  * Scala
  * Julia
  * TypeScript
  * Kotlin (as interfaces)
  * Haskell (as type classes)
  * Swift (as protocol extensions)

**** 2.2.1 Why traits are not object-oriented programming - 19
- =from Jian=
  The author doesn't have a clear understanding between the concepts /OOP/ and
  /inheritance/. Let's ignore this subsection.

**** 2.2.2 What's in a trait? - 19
- Although _trait implementations_ are CONCRETE, you can also provide /blanket
  implementations of traits/ that apply to all types that satisfy the blanket
  conditions.

- In *OOP*, relationships are defined in terms of the objects themselves.

  In *trait programming*, relationships are defined in terms of which traits an
  object implements rather than which object the behavior is implemented for

  -- a subtle but crucial distinction.

- *NOTE*
  Trying to map these concepts 1:1 *doesn't make sense* in practice;
  traits require a different approach.
  It's best to free your mind and *discard* the gospel of OOP.

**** 2.2.3 Understanding traits by examining object-oriented code - 21
- Just compare the code from C++ and Rust:
  * The C++ way, use /inheritance/:
    #+begin_src cpp
      class Rectangle {
      protected:
        int width;
        int height;

      public:
        Rectangle(int width, int height) : width(width), height(height) {}
        int get_area() { return width * height; }
        int get_width() { return width; }
        int get_height() { return height; }
      };

      class Square : public Rectangle {
      public:
        Square(int length) : Rectangle(length, length) {}
        int get_length() { return width; }
      };
    #+end_src

  * The Rust way, use /trait/:
    #+begin_src rust
      struct Rectangle {
          width: i32,
          height: i32,
      }

      impl Rectangle {
          pub fn new(width: i32, height: i32) -> Self {
              Self { width, height }
          }
      }

      struct Square {
          length: i32,
      }

      impl Square {
          pub fn new(length: i32) -> Self {
              Self { length }
          }
          pub fn get_length(&self) -> i32 {
              self.length
          }
      }

      pub trait Rectangular {
          fn get_width(&self) -> i32;
          fn get_height(&self) -> i32;
          fn get_area(&self) -> i32;
      }

      impl Rectangular for Rectangle {
          fn get_width(&self) -> i32 {
              self.width
          }

          fn get_height(&self) -> i32 {
              self.height
          }

          fn get_area(&self) -> i32 {
              self.width * self.height
          }
      }

      impl Rectangular for Square {
          fn get_width(&self) -> i32 {
              self.length
          }

          fn get_height(&self) -> i32 {
              self.length
          }

          fn get_area(&self) -> i32 {
              self.length * self.length
          }
      }
    #+end_src

- =IMPORTANT=
  The Rust version seems a bit lengthy at first.
  We have to implement the ~Rectangular~ /trait/ _TWICE_ in a way that appears
  to violate DRY. But we’ve done something fundamental:
  *separated the state* (in this case, the dimensions) from the functionality of
  providing width, height, area, and so on.

  * As complexity grows,
    this separation of concerns scales much better.

**** 2.2.4 Combining generics and traits - 24
/Trait pollution/ occurs when you have too many traits.

/Trait duplication/ occurs when multiple traits provide the same (or similar) functionality.
Common programming patterns probably have an existing trait, and whenever
possible, it's best to reuse or build atop existing traits.

Third-party libraries often define their own traits and sometimes even competing
traits, and _you can spend a lot of time writing GLUE code to BRIDGE your code,
one library's traits, and another library's traits._

**** 2.2.5 Deriving traits automatically - 28
**** 2.2.6 Trait objects - 29
- =en= behest

- Example:
  =from Jian= The last line, the commented one, is important
  #+begin_src rust
    trait MyTrait {
        fn trait_hello(&self);
    }

    struct MyStruct1;
    impl MyStruct1 {
        fn struct_hello(&self) {
            println!("Hello, world! from MyStruct1");
        }
    }

    struct MyStruct2;
    impl MyStruct2 {
        fn struct_hello(&self) {
            println!("Hello, world! from MyStruct2");
        }
    }

    impl MyTrait for MyStruct1 {
        fn trait_hello(&self) {
            self.struct_hello();
        }
    }

    impl MyTrait for MyStruct2 {
        fn trait_hello(&self) {
            self.struct_hello();
        }
    }

    fn main() {
        let mut v = Vec::<Box<dyn MyTrait>>::new();
        v.push(Box::new(MyStruct1 {}));
        v.push(Box::new(MyStruct2 {}));
        v.iter().for_each(|i| i.trait_hello());
        // v.iter().for_each(|i| i.struct_hello()); error!
    }
  #+end_src

- We *CAN'T* store a /trait/ as an object directly
  because /trait objects/ are unsized (they don't implement the ~Sized~ trait).

  * We *could not* have ~Vec<dyn MyTrait>~, for example, because ~Vec~ does not know
    how to create /unsized objects/.

    A ~Box~, on the other hand, *decouples* /allocation/ from _the containment
    of the element_. That is, when we create an object with ~Box~, we provide
    the concrete type at the time of construction; then the compiler can
    *AUTOMATICALLY* _CAST the object to the /trait object/ type (that is, from
    ~Box<MyStruct1>~ to ~Box<dyn MyTrait>~)_ when we pass or assign the object.

- *Downcasting trait objects* =IMPORTANT=
  Aside from the overhead of /vtables/,
  _ONE LIMITATION_ of /trait objects/ is that we can call methods only on the
  /trait/, not the /concrete type/.

  - _Target_: *downcast* a /trait object/ to the corresponding _CONCRETE type_.

  - _Methodology_:
    * If we want to coerce a /trait object/ into a _concrete type_,
      we can do so by using a _downcast_.

      We can use ~Box~, ~Rc~, and ~Arc~ to perform a _downcast_, and the ~Any~
      trait provides a method to _downcast_.

    * _If we want to obtain a /reference/, however, we need to use ~Any~;_
      the ~downcast()~ method on ~Box~, ~Rc~, and ~Arc~ will *consume the object*,
      but ~Any~ provides ~downcast_ref()~, which returns a /reference/.

  - The ~Any~ trait is *derived AUTOMATICALLY* for _any types_ that have a
    ~'static~ bound, which means that _they are free of nonstatic references,_
    so this trick works *ONLY for* objects that are ~dyn Any + 'static~.

  - To _get an ~Any~ object on our /trait object/,_
    we must first provide a way to get the ~Any~ object out from inside the ~Box~.

    1. We *can't* simply call ~downcast_ref()~ on ~Box<dyn MyTrait>~ because ~Box~
       itself implements ~Any~, and we'll get the wrong object.
    2. Instead, we have to add an ~as_any()~ method to our /trait/ to give us the
       inner object.

    We can update our code like so:
    #+begin_src rust
      trait MyTrait {
          fn trait_hello(&self);
          fn as_any(&self) -> &dyn Any;
      }

      impl MyTrait for MyStruct1 {
          fn trait_hello(&self) {
              self.struct_hello();
          }

          fn as_any(&self) -> &dyn Any {
              self
          }
      }

      impl MyTrait for MyStruct2 {
          fn trait_hello(&self) {
              self.struct_hello();
          }

          fn as_any(&self) -> &dyn Any {
              self
          }
      }

      fn main() {
          println!("With a downcast:");
          v.iter().for_each(|i| {
              if let Some(obj) = i.as_any().downcast_ref::<MyStruct1>() {
                  obj.struct_hello();
              }
              if let Some(obj) = i.as_any().downcast_ref::<MyStruct2>() {
                  obj.struct_hello();
              }
          });
      }
    #+end_src

  - =IMPORTANT= =TODO=
    Last, several /crates/ provide _more advanced downcasting features_,
    such as
    * _downcast_
    * _downcast-rs_
    * ~Anyhow~
    I discuss crates in detail in chapter 4. =TODO= =NEXT=

*** DONE Summary
CLOSED: [2024-10-06 Sun 14:04]

** 3 Code flow - 34 - =TODO=
- This chapter covers
  * Discussing pattern matching
  * Handling errors with pattern matching
  * Reviewing Rust’s functional programming patterns

*** 3.1 A tour of pattern matching - 35
- /Pattern matching/ is a _run-time feature_ that enables a variety of lovely
  code flow patterns.

- =en= potent

- /Pattern matching/ likely saw its first widespread use in _Prolog_ and is an
  essential feature of /functional languages/ such as
  * _Haskell_
  * _Scala_
  * _Erlang_ (itself influenced by and initially implemented in _Prolog_)
  * _Elixir_
  * _OCaml_

**** 3.1.1 Basics of pattern matching - 35
- Match range: ~4..=10~

- Match tuple of any length: ~(first, ..)~, ~(.., last)~

- You *can't match* _values of different types_ within a match statement.
  All match cases or branches within the same ~match {}~ block should apply to
  the same type.

**** 3.1.2 Clean matches with the ~?~ operator - 40
The ~?~ operator allows us to flatten our code considerably, which improves
readability.

*** TODO 3.2 Functional Rust - 43 - =TODO: TAKE NOTE FOR 3.2.3 AND 3.2.4=
- For a deep dive into /functional programming/,
  _Grokking Functional Programming_ by Michał Płachta
  (https://www.manning.com/books/grokking-functional-programming) provides an
  excellent overview.

  =TODO: READ=

**** 3.2.1 Basics of functional programming in Rust - 43
**** 3.2.2 Closure variable capture - 45
Three traits: ~Fn~, ~FnMut~, and ~FnOnce~.

**** TODO 3.2.3 Examining iterators - 46 - =IMPORTANT=
#+begin_src rust
  trait Iterator {
      type Item;
      fn next(&mut self) -> Option<Self::Item>;
  }
#+end_src

- ~Rc~ and ~RefCell~  - =IMPORTANT=

**** TODO 3.2.4 Obtaining an iterator with ~iter()~, ~into_iter()~, and ~iter_mut()~ - 50
- *Lifetimes*

**** 3.2.5 Iterator features - 58
- /Rust's memory model/ does make it trickier to perform specific tasks in Rust
  that may be trivial in other languages,
  _BUT_ almost no other language can compete with Rust in terms of features,
  safety, and performance.

*** Summary - 61
- /Pattern matching/ allows us to unpack data structures and handle a variety of
  scenarios in a _MUCH CLEANER way than_ using combinations of if/else statements.

- We can use /pattern matching/ with the ~?~ operator to handle errors gracefully
  and ~unwrap~ or _destructure_ values.

- We can _destructure nested structs and enums_ when /pattern matching/, and we
  can also _match on values_.

- Rust encourages functional programming patterns, particularly with /closures/
  and /iterators/. Learning these patterns will help you use Rust effectively.

- /Iterators/ use a /fluent interface/, and along with /closures/, we can easily
  express _operations and mutations_ on data structures.

- /Iterators/ typically hold a reference to the data (such as borrowed data) or
  use a /move/ to move the items out of the underlying sequence.

- Usually, (=IMPORTANT= _This is convention, but almost all libraries follow this_!)
  the ~iter()~ method returns an /iterator/ with /references/, and
  ~into_iter()~ gives us an /iterator/ that takes _ownership with a move_.

* TODO PART 2 CORE PATTERNS - 63
** DONE 4 Introductory patterns - 65
CLOSED: [2024-10-04 Fri 21:13]
- This chapter covers
  * Understanding _resource acquisition_ is _initialization_
  * Passing arguments by value versus reference
  * Using constructors
  * Understanding object member visibility and access
  * Handling errors
  * Global state handling with =lazy-static.rs=, ~OnceCell~, and ~static_init~

- This chapter _FOCUSES ON_ *bite-size patterns*, which we'll use a lot.

- You'll quickly find when working with Rust that the standard library is somewhat
  bare and doesn't include many of the features you might expect from a modern
  language. *These limits are by design;* the Rust team chose to keep the standard
  library minimal and instead rely on crates to provide additional functionality.
  This approach has SEVERAL BENEFITS:
  * The standard library is smaller and easier to maintain.
  * The standard library is more stable and less likely to change.
  * The standard library is more focused on core functionality.
  * The community can build and maintain separate competing crates for specialized
    functionality, allowing developers to choose the most suitable crate for
    their needs.

*** TODO 4.1 Resource acquisition is initialization - 66 - =NOTE=
- /Resource acquisition is initialization (RAII)/

- /RAII/ originated with C++ and is arguably one of the most important modern
  programming idioms.

- /RAII/ is a key feature in Rust:
  it allows us to confidently implement a variety of other patterns and
  plays a critical role in Rust’s safety features.

- Q :: WHY RAII is a pattern rather than an idiom?
- A :: It's a formalized way of handling resources in a program, as opposed to a
       more informal way of formatting code (an idiom).
  * Additionally, /RAII/ affects the overall program structure and architecture,
    which is more in line with a pattern than an /idiom/.

**** TODO 4.1.1 Understanding RAII in C and C++ - 66
- *Scoping in C*

**** TODO 4.1.2 A tour of RAII in Rust - 70
**** TODO 4.1.3 Summarizing RAII in Rust - 72

*** DONE 4.2 Passing arguments by value vs. reference - 74
CLOSED: [2024-10-02 Wed 15:26]
**** 4.2.1 Passing by value - 74
**** 4.2.2 Passing by reference - 75
- *Why is it impossible to mutate Rust strings in place?*
  * _In-place string manipulation in Rust isn't easy._
    + The REASON:
      /strings/ in Rust are always _valid UTF-8_, which means that characters
      could span multiple bytes or be composed of /grapheme clusters/ in the
      Unicode standard.

    + grapheme :: the smallest unit of a writing system,
      - It could be
        * an ordinary character (such as the letter a), or
        * a character that includes an accent such as é or an emoji character.

    + Because /grapheme clusters/ can span multiple Unicode characters and
      multiple bytes, it's quite complicated to handle them correctly, so the
      Rust standard library does not support handling them directly.

      * Instead, you need to use a crate such as unicode-segmentation
        (https://crates.io/crates/unicode-segmentation).
        =IMPORTANT=

  * If you need to update a string in place by manipulating its bytes, you have
    two options:
    1. You can use an ~unsafe~ method, such as ~String::as_mut_vec()~ or
       ~str::as_bytes_mut()~, which returns /references/ to the _underlying
       bytes_.

    2. You can use the std::mem::take function to gain access to the underlying
       bytes of a string and manipulate a buffer directly.

    *The first method is preferred*, as it doesn't require ~unsafe~ code,
    BUT in either case, you need to consider how to handle UTF-8 characters
    safely.

**** 4.2.3 When to do what: Passing by value vs. reference - 77
- *Figure 4.3 Deciding how to handle arguments*
  =IMPORTANT=

*** DONE 4.3 Constructors - 78
CLOSED: [2024-10-03 Thu 18:04]
Strictly speaking, Rust does *NOT* have a formal notion of a /constructor/ in
the same way that languages such as C++, C#, and Java do.

- In Rust, a /constructor/ is merely a /design pattern/ in which you create a
  /method/, typically called ~new()~, that accepts any number of initialization
  arguments and returns a new object immediately after creation.

- =NOTE=
- In Rust, ~new()~ *TYPICALLY* takes _no arguments_ and returns _an empty object_,
  as is the case with ~Vec::new()~, which returns an empty vector.
  * =from Jian=
    It depends. Sometimes, ~#[derive(Default)]~ of ~impl Default for OurType~ is
    semantically better! However, it is clear that for vector, ~Vec::new()~ is
    better than ~Vec::default()~ in semantics.

  * There's no rule against including initialization arguments with ~new()~,
    BUT
    =IMPORTANT=
    *it's common to implement the ~From~ trait instead when you want to create a
    new object from another object.*

  This approach makes sense only when a 1:1 mapping exists (when ~String::from(…)~
  constructs a new string, for example).

- Because Rust *doesn't permit* /function overloading/, you can create only one
  method called ~new()~, so think carefully about what you want this function to
  do.
  * In most cases, the function should provide the minimally necessary behavior,
    such as returning a new empty object (as with ~Vec::new()~) with the minimum
    required arguments.

- *NOTE*
  If your set of initialization arguments grows in complexity, you probably want
  to use the /builder pattern/, =TODO= which we'll discuss in chapter 5.

*** DONE 4.4 Object-member visibility and access - 80
CLOSED: [2024-10-03 Thu 21:07]
- Rust generally _defaults to private visibility_.

- Optionally, you can make entities public with the ~pub~ keyword.

- Q :: When would you want to make struct field(s) public?
- A :: Generally, you wouldn't want to do this except when you have data
       containers with no methods and their only purpose is to contain data.
  * Most of the time, you want to
    + control access to members with /accessors/ (methods that _fetch_ private
      members) and
    + modify members with /mutators/ (methods that allow you to _mutate_ private
      members).

- /Accessors/ and /mutators/ are often called _getters_ and _setters_,
  though in Rust, it's important to distinguish between _setting a value (such
  as a move)_ and _mutating a value in place_.

- *TIP*:
  * Create getters and setters for each member through rust-analyzer.
  * rust-analyzer section in _Code Like a Pro in Rust_.

- ~std::mem::replace~
  This approach prevents cloning and duplication, which is an excellent little
  optimization.
  =IMPORTANT=

*** DONE 4.5 Error handling - 82
CLOSED: [2024-10-03 Thu 21:27]
- The standard library also has an _error trait_, ~std::error::Error~,
  that you can implement for your own error types, but its use is _optional_.
  * In practice, implementing ~std::error::Error~ for custom error types is
    *UNCOMMON*.

- Listing 4.11 Reading the nth line from a file
  #+begin_src rust
    use std::path::Path;

    #[derive(Debug)]
    pub enum Error {
        Io(std::io::Error),
        BadLineArgument(usize),
    }

    impl From<std::io::Error> for Error {
        fn from(error: std::io::Error) -> Self {
            Self::Io(error)
        }
    }

    fn read_nth_line(path: &Path, n: usize) -> Result<String, Error> {
        use std::fs::File;
        use std::io::{BufRead, BufReader};
        let file = File::open(path)?;
        let mut reader_lines = BufReader::new(file).lines();
        reader_lines
            .nth(n - 1)
            .map(|result| result.map_err(|err| err.into()))
            .unwrap_or_else(|| Err(Error::BadLineArgument(n)))
    }
  #+end_src

- In most cases, you'll want to create an error type for your library or
  application to encapsulate all the errors it may return, and in many cases,
  you simply want to return the underlying error unaltered.
  =IMPORTANT=
  ~anyhow~???

*** TODO 4.6 Global state - 85 - =NOTE=
**** 4.6.1 lazy-static.rs - 87
**** 4.6.2 ~once_cell~ - 88
**** 4.6.3 ~static_init~ - 89
**** 4.6.4 ~std::cell::OnceCell~ - 89

** DONE 5 Design patterns: Beyond the basics - 91
CLOSED: [2024-10-04 Fri 21:13]
- This chapter covers
  * Metaprogramming with macros
  * Implementing the builder pattern in Rust
  * Building fluent interfaces
  * Observing the observer pattern
  * Understanding the command pattern
  * Exploring the newtype pattern

*** 5.1 Metaprogramming with macros - 92 - =NOTE=
**** 5.1.1 A basic declarative macro in Rust - 93
**** 5.1.2 When to use macros - 94
**** 5.1.3 Using macros to write mini-DSLs - 99
**** 5.1.4 Using macros for DRY - 103

*** 5.2 Optional function arguments - 103 - =NOTE=
**** 5.2.1 Examining optional arguments in Python - 103
**** 5.2.2 Examining optional arguments in C++ - 104
**** 5.2.3 Optional arguments in Rust or the lack thereof - 104
**** 5.2.4 Emulating optional arguments with traits - 104

*** 5.3 Builder pattern - 107
=from Jian=
This section show a builder pattern without fluent interface.
Next section will add the fluent interface.
In practice, most builder pattern implementation incorporate fluent interface.

**** 5.3.1 Implementing the builder pattern - 107
**** 5.3.2 Enhancing our builder with traits - 109
**** 5.3.3 Enhancing our builder with macros - 110

*** DONE 5.4 Fluent interface pattern - 113
CLOSED: [2024-10-04 Fri 19:40]
*Method chaining*

This section modify the builder pattern code in previous section, and make its
interface fluent.

- One example in Rust: the ~Iterator~

**** 5.4.1 A fluent builder - 114
- *Initializing structs with the spread syntax*

**** 5.4.2 Test-driving our fluent builder - 117

*** DONE 5.5 Observer pattern - 117 - =NOTE=
CLOSED: [2024-10-04 Fri 20:47]
- The /observer pattern/ (along with its variations) is widely used to enable
  objects to observe changes in other objects.

- Observer is often necessary in systems that perform any kind of event processing
  or event handling, such as networked services.

**** 5.5.1 Why not callbacks - 117
- Before we dive deeper into the observer pattern, let’s discuss callbacks. Some
  languages (notably JavaScript) make heavy use of callbacks, which can lead to
  a situation known as callback hell, with deeply nested callbacks within
  callbacks creating difficult-to-understand code. Someone went so far as to
  create the website http://callbackhell.com to describe this problem and
  propose some solutions.

**** 5.5.2 Implementing an observer - 118

*** TODO 5.6 Command pattern - 121
- command pattern ::
  1. stores state or instructions in one structure
  2. and then applies changes later.

**** 5.6.1 Defining the command pattern - 121
**** 5.6.2 Implementing the command pattern - 121

*** DONE 5.7 Newtype pattern - 124
CLOSED: [2024-10-04 Fri 21:08]
- *NOTE*
  * =from Jian= Not correct for the origin of /newtype pattern.
  * =from Jian= It seems the author doesn't have enough modern programming
                language knowledge/experience before using Rust.

- =from Jian=
  *Defect!!!*
  Should mention newtype pattern used as a workaround for /orphan rule/.

- *Conversion method naming idioms: as_…(), to_…(), and into()*
  * Not strict, just a convention, though most libraries adhere to:
    + ~as_…()~:
      Low-cost conversions such as ~as_ref()~ from the ~AsRef~ trait.

    + ~to_…()~
      Higher-cost conversions such as ~to_string()~ from ~ToString~.

    + ~into()~
      Higher-cost conversions from ~Into~ / ~From~.

  * One notable *EXCEPTION* is the use of ~borrow()~ from the ~Borrow~ trait,
    which behaves *similarly to* ~as_ref()~ from ~AsRef~ except that it returns
    a /reference object/ (a pattern we'll discuss in chapter 7 =TODO=) rather than a
    /plain reference/ (~Ref<', T>~ versus ~&T~).
    + ~std::cell::RefCell~, for example, provides ~borrow()~ BUT NOT ~as_ref()~
      because of _the additional OVERHEAD introduced by /run-time borrow
      checking/._

**** DONE Summary - 127
CLOSED: [2024-10-04 Fri 21:13]

** TODO 6 Designing a library - 128
- This chapter covers
  * Thinking about how to design a great library
  * Making beautiful interfaces
  * Being correct and avoiding unexpected behavior
  * Exploring Rust library ergonomics and patterns

*** 6.1 Meditate on good library design - 129
*** 6.2 Do one thing, do it well, and do it correctly - 129
*** 6.3 Avoid excessive abstraction - 130
*** 6.4 Stick to basic types - 130
*** 6.5 Use the tools - 131
*** 6.6 Good artists copy; great artists steal (from the standard library) - 132
*** 6.7 Document everything, and provide examples - 132
*** 6.8 Don't break the user's code - 132
*** 6.9 Think of the state - 133
*** 6.10 Consider the aesthetics - 134
*** 6.11 Examining Rust library ergonomics - 134
**** 6.11.1 Revisiting linked lists - 134
**** 6.11.2 Using =rustdoc= to improve our API design - 135
**** 6.11.3 Improving our linked list with more tests - 143
**** 6.11.4 Making our library easier for others to debug - 145

* TODO PART 3 ADVANCED PATTERNS - 149
** DONE 7 Using traits, generics, and structs for specialized tasks - 151
CLOSED: [2024-10-05 Sat 21:34]
- This chapter covers
  * Using /const generics/
  * Applying traits to external crate types
  * Extending types with extension traits
  * Implementing /blanket traits/
  * Using /marker traits/ to mark types with attributes
  * Tagging with structs
  * Providing access to internal data with /reference objects/ =TODO: ???=

*** DONE 7.1 Const generics - 152
CLOSED: [2024-10-04 Fri 21:28]
/Const generics/ make it easy to build _CUSTOM array-based types with fixed
lengths_, which can save a lot of boilerplate.

- If there is no /const generics/, we can't define a type like
  #+begin_src rust
    #[derive(Debug)]
    struct Buffer<T, const LENGTH: usize> {
        buf: [T; LENGTH],
    }
  #+end_src
  then we have to define several buffer types, and each contains one specific
  length inner array like
  #+begin_src rust
    struct Buffer256<T> {
        buf: [T; 256]
    }

    struct Buffer512<T> {
        buf: [T; 512]
    }
  #+end_src

- A useful ~From~ implementation for our ~Buffer~:
  #+begin_src rust
    impl<T, const LENGTH: usize> From<[T; LENGTH]> for Buffer<T, LENGTH> {
        fn from(buf: [T; LENGTH]) -> Self {
            Buffer { buf }
        }
    }
  #+end_src

*** DONE 7.2 Implementing traits for external crate types - 154
CLOSED: [2024-10-04 Fri 21:43]
=from Jian=
The start 3 paragraphs before 7.2.1 subsection start is *very unclear and
misleading!!!*

=from Jian=
Should mention the /orphan rule/. The original text says "you cannot implement
a trait for types outside your crate", which is confusing! This "cannot"
is true only when both trait(s) and type(s) are not in yours crate.

**** 7.2.1 Wrapper structs - 154
Use newtype pattern, and this time this new type is in your crate, and no matter
where is the trait, you can implement it for your wrapped type.

#+begin_src rust
  // The original type is `Vec<T>`
  struct WrappedVec<T>(Vec<T>);
#+end_src

- Not good enough:
  Even though ~WrappedVec<T>~ is effectively ~Vec<T>~, the methods of ~Vec<T>~
  can't be called from ~WrappedVec<T>~.
  * =NEXT Subsection= resolve this issue.

**** 7.2.2 Using ~Deref~ to unwrap a wrapped struct - 154
#+begin_src rust
  impl<T> Deref for WrappedVec<T> {
      type Target = Vec<T>;
      fn deref(&self) -> &Self::Target {
          &self.0
      }
  }
#+end_src
*Some _LIMITATIONS_ exist, however.*

- For one, we can't use methods that take ~self~ by value, such as ~into_iter()~.
  * Solution:
    #+begin_src rust
      impl<T> WrappedVec<T> {
          fn into_iter(self) -> IntoIter<T> {
              self.0.into_iter()
          }
      }
    #+end_src

- To call ~Vec~ methods that take ~&mut self~, you need to implement the ~DerefMut~
  trait.

*** DONE 7.3 Extension traits - 155
CLOSED: [2024-10-04 Fri 21:51]
- /Extension traits/ are /traits/ that add functionality to types and traits
  outside the crate in which they’re defined.

- /Extension traits/ typically follow a *naming convention* that uses the ~Ext~
  postfix.

- Two ways:
  * Define your own new extension trait and implement it for _a type_:
    #+begin_src rust
      impl<T> ReverseExt<T> for Vec<T>
      where
          T: Clone,
      {
          fn reversed(&self) -> Vec<T> {
              self.iter().rev().cloned().collect()
          }
      }
    #+end_src
    *SIMPLE!*

  * Extend a existing trait and implement it for _a type or type parameter_:
    =IMPORTANT=
    #+begin_src rust
      pub trait DoubleEndedIteratorExt: DoubleEndedIterator {
          fn to_reversed<'a, T>(self) -> Vec<T>
          where
              T: 'a + Clone,
              Self: Sized + Iterator<Item = &'a T>;
      }

      impl<I: DoubleEndedIterator> DoubleEndedIteratorExt for I {
          fn to_reversed<'a, T>(self) -> Vec<T>
          where
              T: 'a + Clone,
              Self: Sized + Iterator<Item = &'a T>,
          {
              self.rev().cloned().collect()
          }
      }
    #+end_src
    *FLEXIBLE and POWERFUL!*

    One nice result of _applying an extension trait to another trait_ (as
    opposed to a type directly) is that we can use this trait on any type that
    implements the ~DoubleEndedIterator~ trait, which includes ~Vec~, ~slices~,
    and ~std::collections::LinkedList~, among others.

*** DONE 7.4 Blanket traits - 157
CLOSED: [2024-10-04 Fri 22:11]
/Blanket trait implementation/ is used to quickly and easily implement a trait
for all types that satisfy our criteria.

- =from Jian=
  From the target of the /blanket trait implementation/, it is easy to see that
  the target type should be generic.

- Example from std:
  #+begin_src rust
    impl<T: Display> ToString for T {
        // ...
    }
  #+end_src

- A /blanket trait implementation/ for the ~Buffer<T, LENGTH>~ we defined:
  #+begin_src rust
    impl<T: Default + Copy, const LENGTH: usize> From<Vec<T>>
        for Buffer<T, LENGTH>
    {
        fn from(v: Vec<T>) -> Self {
            assert_eq!(LENGTH, v.len());
            let mut ret = Self {
                buf: [T::default(); LENGTH],
            };
            ret.buf.copy_from_slice(&v);
            ret
        }
    }
  #+end_src

- _For library authors_,
  /blanket trait implementations/ improve the usability of a library.

  * We don't need to stress about providing the most generic implementation or
    every imaginable concrete implementation.
    _RATHER_, we should focus on handling the most common cases, as we did by
    providing ~From~ for ~Vec~.

*** DONE 7.5 Marker traits - 159
CLOSED: [2024-10-05 Sat 00:16]
- /Marker traits/ are _abstract traits_ that mark or indicate features or
  attributes about a type in Rust without necessarily providing any behaviors.
  * /Marker traits/ are often denoted by their absence of methods.

- Example:
  One form of a /marker trait/ provides _a /blanket implementation/ that
  COMBINES other /traits/._
  If we want a shorthand way to indicate that a particular type implements a
  given set of traits, for example, we can mark it accordingly.
  #+begin_src rust
    #[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    struct KitchenSink;

    trait FullFeatured {}

    impl<T> FullFeatured for T where
        T: Clone
            + Copy
            + std::fmt::Debug
            + Default
            + Eq
            + std::hash::Hash
            + Ord
            + PartialEq
            + PartialOrd
    {
    }

    #[derive(Debug)]
    struct Container<T: FullFeatured> {
        t: T,
    }

    fn main() {
        // TEST
        let container = Container { t: KitchenSink {} };
        println!("{:?}", container);
    }
  #+end_src

- /Marker traits/ don't have to be empty, _though they often are_.
  *As a general rule, /marker traits/ should be empty (contain NO /methods/ or
  /types/).*

- *Supertraits*
  * =TODO=
    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    Find more articles about
    /supertrait/ vs. /blanket implementations through marker trait/

  * supertraits :: traits that composed of other traits.
    + Example:
      #+begin_src rust
        trait CloneAndDebug: Clone + Debug {}
      #+end_src

  * /Trait bounds/ can become quite complex, and we can use /supertraits/ to
    consolidate a list of required traits.

  * The *DIFFERENCE* between using /supertraits/ and _providing blanket
    implementations with trait bounds (as we did with ~FullFeatured~)_:
    =IMPORTANT=
    =from Jian= I don't think the difference below is clear enough. Need a good
                example!!!

    + /supertraits/ give us slightly _LESS flexibility_ (due to compiler strictness)
      and a little _MORE convenience_.

    + Using a /blanket implementation/ (through a /mark trait/) instead allows us
      to make special exceptions for specific types. We can still derive our
      ~FullFeatured~ trait for any type, but the compiler won't enforce anything
      as it will with ~supertraits~.

  * When *CHOOSING between* /supertraits/ and explicit implementations using
    /trait bounds/, as with ~FullFeatured~,
    + _You should *PREFER* /supertraits/ if all you need is an alias for a set of
      existing traits._
      Also, /supertraits/ allow us to provide /default implementations/ for /trait
      methods/ that use /dependent traits/.
      =from Jian=
      We can't do this through blanket implementations and /mark traits/
      (recommended: no member!).

*** DONE 7.6 Struct tagging - 161
CLOSED: [2024-10-05 Sat 00:42]
#+begin_src rust
  use std::fmt::Debug;

  trait BuildState {}

  #[derive(Default, Debug)]
  struct LightBulb<State: BulbState> {
      phantom: PhantomData<T>,
  }

  #[derive(Default, Debug)]
  struct On;
  #[derive(Default, Debug)]
  struct Off;

  impl BulbState for On {}
  impl BulbState for Off {}

  impl LightBulb<On> {
      fn turn_off(self) -> LightBulb<Off> {
          LightBulb::<Off>::default()
      }

      fn state(&self) -> &str {
          "on"
      }
  }

  impl LightBulb<Off> {
      fn turn_on(self) -> LightBulb<On> {
          LightBulb::<On>::default()
      }

      fn state(&self) -> &str {
          "off"
      }
  }

  fn main() {
      let lightbulb = LightBulb::<Off>::default();
      println!("Bulb is {}", lightbulb.state());

      let lightbulb = lightbulb.turn_on();
      println!("Bulb is {}", lightbulb.state());

      let lightbulb = lightbulb.turn_off();
      println!("Bulb is {}", lightbulb.state());
  }
#+end_src

- struct tagging :: use /structs/ to _tag or mark generic types_ (those with
  generic parameters).

- With /struct tagging/, we can use /empty structs/ (also called /unit structs/)
  to tag a generic type by including the tag as an _UNUSED_ type parameter; the
  tag itself contains _no state_ and _may never be instantiated_.

- Like /marker traits/, the _structs we use for tagging_ are *typically empty*;
  _they're used to define *state* within the TYPE SYSTEM itself._
  * =from Jian=
    A typelevel programming:
    1. an abstraction intended to hold state (in this case, a struct),
       we're *not holding any runtime state* within the struct;

    2. instead, we're enabling the struct to be used as a /generic type parameter/.

- =IMPORTANT=
  Becaure this way depends on type, not value, compiler can help us a lot and
  detect error at compile-time.

*** DONE 7.7 Reference objects - 163
CLOSED: [2024-10-05 Sat 21:29]
- /Reference objects/ provide a reference to _interior data_.
  We may want to use a /reference object/ to
  *PERMIT* _partial borrowing of interior data WITHOUT providing public access._

  * In other words,
    we can *wrap* the _private interior data_ in a _public reference object_ to
    *avoid* introducing a leaky abstraction or making the internal data public.

  * /Reference objects/ typically use *the ~Ref~ postfix* in their name, which
    identifies them as holding references.

- Example:
  #+begin_src rust
    #[derive(Debug)]
    struct Student {
        name: String,
        id: u32,
    }

    impl Student {
        fn new(name: String, id: u32) -> Self {
            Self { name, id }
        }
        fn name(&self) -> &str {
            self.name.as_ref()
        }
        fn id(&self) -> u32 {
            self.id
        }
    }

    impl<'a> Student {
        fn to_ref(&'a self) -> StudentRef<'a> {
            StudentRef::new(self)
        }
    }

    #[derive(Debug)]
    pub struct StudentList {
        students: Vec<Student>,
    }

    impl StudentList {
        pub fn new(students: &[(&str, u32)]) -> Self {
            Self {
                students: students
                    .iter()
                    .map(|(name, id)| {
                        Student::new((*name).into(), *id)
                    })
                    .collect(),
            }
        }
    }

    impl<'a> StudentList {
        fn find<F: Fn(&&Student) -> bool>(
            &'a self,
            pred: F,
        ) -> Option<StudentRef<'a>> {
            self.students.iter()
                .find(pred)
                .map(Student::to_ref)
        }
        pub fn find_student_by_id(&'a self, id: u32) -> Option<StudentRef<'a>> {
            self.find(|s| s.id() == id)
        }
        pub fn find_student_by_name(
            &'a self,
            name: &str,
        ) -> Option<StudentRef<'a>> {
            self.find(|s| s.name() == name)
        }
    }

    #[derive(Debug)]
    pub struct StudentRef<'a> {
        student: &'a Student,
    }

    impl<'a> StudentRef<'a> {
        fn new(student: &'a Student) -> Self {
            Self { student }
        }
    }

    impl<'a> PartialEq for StudentRef<'a> {
        fn eq(&self, other: &Self) -> bool {
            self.student.id() == other.student.id()
        }
    }
  #+end_src

- It’s possible to create /mutable reference objects/.
  =as an exercise=

*** DONE Summary
CLOSED: [2024-10-05 Sat 21:34]
- /Const generics/ allow us to _use constant values as type parameters_,
  unlocking features such as fixed-length arrays of arbitrary size.

- It's not possible to implement a trait for types outside our crate, but we can
  work around this limitation using wrapper structs (newtype pattern) and the
  ~Deref~ and ~DerefMut~ traits.

- /Extension traits/ extend or alter the behavior of external types or traits,
  such as the standard library.

- We can implement a trait automatically for any combination of types by using
  generic implementations, known as /blanket traits/.

- /Marker traits/ let us mark or denote types that have certain features or
  attributes, such as combining several other traits.

- We can _use empty (or unit) structs to tag generic types_ by using the structs
  themselves as tags.

- /Reference objects/ provide access to _private interior data_
  *WITHOUT*
  transferring ownership or exposing internal private objects.

** TODO 8 State machines, coroutines, macros, and preludes - 169 - =START HERE!!!=
- This chapter covers
  * Using traits to construct state machines
  * Writing pausable functions with coroutines
  * Implementing procedural macros
  * Providing preludes to improve the usability of your crates

- State machines are robust ways to model stateful systems, and as we'll see in
  this chapter, it’s surprisingly easy to build type-safe state machines in Rust.

- /Rust's coroutines/ is like /Python's generators/.

*** DONE 8.1 Trait state machine - 170 - =TODO: Practice=
CLOSED: [2024-10-05 Sat 23:00]
- Now that we've explored /traits/ and /generics/,
  we can start building some interesting abstractions on top of Rust's type
  system.

- A /state machine/ usually consists of
  1. a list of _states_ and
  2. a set of _transitions between states_.

- Only valid transitions can be performed.
  Rust's type system enforces those rules.
  =from Jian= of course, by design and by language features

- =IMPORTANT=
  Figure 8.1 Modeling a user session with a state machine

- Code:
  #+begin_src rust
    pub trait SessionState {}

    #[derive(Debug, Default)]
    pub struct Session<State: SessionState = Initial> {
        session_id: Uuid,
        props: HashMap<String, String>,
        phantom: PhantomData<State>,
    }

    #[derive(Debug, Default)]
    pub struct Initial;

    #[derive(Debug, Default)]
    pub struct Anonymous;

    #[derive(Debug, Default)]
    pub struct Authenticated;

    #[derive(Debug, Default)]
    pub struct LoggedOut;

    impl SessionState for Initial {}
    impl SessionState for Anonymous {}
    impl SessionState for Authenticated {}
    impl SessionState for LoggedOut {}

    #[derive(Debug)]
    pub enum ResumeResult {
        Invalid,
        Anonymous(Session<Anonymous>),
        Authenticated(Session<Authenticated>),
    }

    impl Session<Initial> {
        /// Returns a new session, defaulting to the anonymous state
        pub fn new() -> Session<Anonymous> {
            Session::<Anonymous> {
                session_id: Uuid::new_v4(),
                props: HashMap::new(),
                phantom: PhantomData,
            }
        }

        /// Returns the result of resuming this session from an existing ID.
        pub fn resume_from(session_id: Uuid) -> ResumeResult {
            ResumeResult::Authenticated(
                Session::<Authenticated> {
                    session_id,
                    props: HashMap::new(),
                    phantom: PhantomData,
                }
            )
        }
    }

    impl Session<Anonymous> {
        pub fn authenticate(
            self,
            username: &str,
            password: &str,
        ) -> Result<Session<Authenticated>,
                    Session<Anonymous>> {
            // ...
            if !username.is_empty()
                && !password.is_empty() {
                    Ok(Session::<Authenticated> {
                        session_id: self.session_id,
                        props: HashMap::new(),
                        phantom: PhantomData,
                    })
                } else {
                    Err(self)
                }
        }
    }

    impl Session<Authenticated> {
        pub fn update_property(
            &mut self,
            key: &str,
            value: &str,
        ) {
            if let Some(prop) = self.props.get_mut(key) {
                *prop = value.to_string();
            } else {
                self.props.insert(key.to_string(), value.to_string());
            }
            // ...
        }

        pub fn logout(self) -> Session<LoggedOut> {
            // ...
            Session {
                session_id: Uuid::nil(),
                props: HashMap::new(),
                phantom: PhantomData,
            }
        }
    }

    fn main() {
        let session = Session::new();
        println!("{:?}", session);
        if let Ok(mut session) =
            session.authenticate("username", "password")
        {
            session.update_property("key", "value");
            println!("{:?}", session);
            let session = session.logout();
            println!("{:?}", session);
        }
    }

    // Session { session_id: f0981fc3-3761-407f-b037-8759535acf87, props: {}, phantom: PhantomData }
    // Session { session_id: f0981fc3-3761-407f-b037-8759535acf87, props: {"some.preference.bool": "true"}, phantom: PhantomData }
    // Session { session_id: 00000000-0000-0000-0000-000000000000, props: {}, phantom: PhantomData }
  #+end_src

*** TODO 8.2 Coroutines - 173 - =RE-READ=
- *On the origins of coroutines*
  =TODO= TAKE NOTE!!!

*** DONE 8.3 Procedural macros - 178
CLOSED: [2024-10-05 Sat 23:13]
- *TIP*
  For a real-life example of /procedural macros/ in action, check out the
  _rocket_ crate, which makes extensive use of /procedural macros/ for its Rust
  web framework.
  =from Jian= Learn from _rocket_ codebase.

*** DONE 8.4 Preludes - 182
CLOSED: [2024-10-06 Sun 00:22]
- When we're writing libraries, we can provide /preludes/ to make it easy for
  people to get the most out of our library.

- Some /preludes/, provided by the Rust language itself, are imported
  automatically, such as the standard library preludes.
  * _BUT_ I'm going to talk specifically about adding /preludes/ to our crates
    rather than those from Rust.

- /Preludes/ are implemented by means of *re-exports*,
  which is a way of *exporting* symbols *from another* /module/ or /crate/.

- When we re-export with a ~pub use ...;~ statement, the symbols imported by that
  ~use~ can be imported from outside that /module/.

- Many libraries provide an EXPLICIT /prelude/ /module/ (usually named ~prelude~)
  within their crates, and you would import from it as follows:
  ~use mylib::prelude::*;~

- Using a _SEPARATE /prelude/ module_ is one way to *avoid polluting* the
  /namespace/.

- Example:
  #+begin_src text
    $ tree
    .
    ├── Cargo.lock
    ├── Cargo.toml
    └── src
      ├── a.rs
      ├── b.rs
      ├── lib.rs
      └── prelude.rs
  #+end_src
  1. In =lib.rs=:
     #+begin_src rust
       pub mod prelude
     #+end_src

  2. In =prelude.rs=:
     #+begin_src rust
       pub use crate::a::InnerA;
       pub use crate::b::InnerB;
       pub use crate::TopLevelStruct;
       // Or
       // pub use crate::TopLevelStruct as AltStruct;
     #+end_src

  * Then in other crates, you can
    #+begin_src rust
      use mylib::prelude::*;
    #+end_src

- =IMPORTANT=
  Authors frequently export dependencies from third-party crates to make their
  crates easier to use.

- =IMPORTANT=
  As a general rule of thumb,
  *you shouldn't need them
  UNLESS your crate provides lots of traits as part of its core functionality.*

*** TODO Summary - 185
- Combining what we've learned about /generics/ and /traits/,
  we can build abstractions such as /state machines/ on top of /Rust's type
  system/.

- =TODO=
  Coroutines are an experimental Rust feature, similar to Python’s generators,
  that provides an alternative way to express pausable functions that can yield
  data.

- /Procedural macros/ enable language extensions and metaprogramming well
  beyond what /declarative macros/ can do.

- We can provide /preludes/ for our libraries to make them a little _more
  userfriendly_ by re-exporting the most useful parts of our library under one
  module (usually named ~prelude~).

* TODO PART 4 PROBLEM AVOIDANCE - 187
** TODO 9 Immutability - 189
- This chapter covers
  * Understanding the benefits of /immutability/
  * Thinking in terms of /immutable/ data and how it works in Rust
  * Using traits to make _nearly anything_ /immutable/
  * Exploring /crates/ that provide /immutable/ data structures

*** 9.1 The benefits of immutability - 190
*** 9.2 Why immutability is not a magic bullet - 192
*** 9.3 How to think about immutable data - 192
*** 9.4 Understanding immutability in Rust - 193
*** 9.5 Reviewing the basics of immutability in Rust - 194
*** 9.6 Using traits to make (almost) anything immutable - 197
*** 9.7 Using Cow for immutability - 198
*** 9.8 Using crates for immutable data structures - 201
**** 9.8.1 Using im - 201
**** 9.8.2 Using rpds - 202

** TODO 10 Antipatterns - 205
- This chapter covers
  * Discussing programming antipatterns
  * Reviewing common antipatterns in Rust
  * Recognizing when to use and when to avoid contentious patterns

- Antipatterns :: programming practices that are considered _HARMFUL_
  IN specific contexts OR all circumstances

- /Antipatterns/ are often the result of
  * a misunderstanding of languages or
  * a lack of experience with a particular technology stack.

- *In this chapter, we'll discuss some COMMON /antipatterns/ in Rust and _how to
  avoid them_.*

- *As Rust evolves*, if a pattern is an antipattern in some context *may change*,
  so staying up to date with the latest best practices is essential for writing
  Rust effectively.
  =IMPORTANT=

*** DONE 10.1 What is an antipattern? - 206
CLOSED: [2024-10-06 Sun 23:36]
- =en= weasel word, pejoratively

- Forget about some very personal opinion, we should only talk about practices
  that are *OBJECTIVELY bad*, such as when it's unsafe, inefficient, or difficult
  to maintain.

*** 10.2 Using ~unsafe~ - 207
**** 10.2.1 What does ~unsafe~ do? - 208
**** 10.2.2 Where can you use ~unsafe~? - 209
**** 10.2.3 When should you use ~unsafe~? - 211
**** 10.2.4 Should you worry about ~unsafe~? - 211

*** DONE 10.3 Using ~unwrap()~ - 212
CLOSED: [2024-10-05 Sat 21:54]
~unwrap()~ isn't always an antipattern, but it’s often a code smell.

- Avoid using ~unwrap()~ relatively easily by replacing it with one or more of
  the following methods:
  * ~expect()~
    + Using ~expect()~ is functionally equivalent to using an assertion, such as
      ~assert!(value.is_some())~.

  * ~map()~

  * ~and_then()~
    This method allows you to *chain* ~Option~ or ~Result~ values,
    *avoiding* deeply nested match or ~if let~ statements.

  * ~unwrap_or()~
    Provide a default value when the value is ~None~ or ~Err~.

  * ~?~

*** DONE 10.4 Not using ~Vec~ - 212
CLOSED: [2024-10-07 Mon 00:01]
The ~Vec~ type, a _dynamic array_ that's one of the most commonly used types in
Rust, is a good choice for most use cases.

Many people make the mistake of not using ~Vec~, instead attempting to optimize
their code by writing custom data structures or reaching for maps, sets, trees,
or linked lists.

- *NOTE*
  The benchmarks use a *nightly-only benchmarking feature*, and to run these
  benchmarks, _you must use the ~cargo bench~ command (as opposed to
  ~cargo test~)._

- Listing 10.7 Benchmarking Vec, HashSet, and LinkedList for appending
  #+begin_src rust
    #[bench]
    fn vec_append(b: &mut Bencher) {
        b.iter(|| {
            let mut nums: Vec<i32> = Vec::new();
            for n in 0..1_000_000 {
                nums.push(n);
            }
        });
    }

    #[bench]
    fn list_append(b: &mut Bencher) {
        b.iter(|| {
            let mut nums: LinkedList<i32> = LinkedList::new();
            for n in 0..1_000_000 {
                nums.push_back(n);
            }
        });
    }

    #[bench]
    fn set_append(b: &mut Bencher) {
        b.iter(|| {
            let mut nums: HashSet<i32> = HashSet::new();
            for n in 0..1_000_000 {
                nums.insert(n);
            }
        });
    }
  #+end_src

- If we can set the /capacity/ of a vector in advance, its performance can be
  much better for operations that can introduce many memory allocations when
  using the default /capacity/.

- *Rust's benchmarking tools*
  Rust provides a _built-in benchmarking tool_ that allows you to write
  benchmarks quickly the way you'd write a unit test.

  * Currently, this feature is available only in _nightly Rust_.

  * Using the ~#[bench]~ attribute.
    You can define a /unit test/ that benchmarks any operation, LIKE any regular
    unit test.

  * =IMPORTANT=
    The benchmarking tool
    1. runs the benchmark multiple times and
    2. provides the median time to run the benchmark and the standard deviation.

  * Example:
    #+begin_src rust
      #![feature(test)]

      #[cfg(test)]
      mod test {
          extern crate test;
          use test::Bencher;

          #[bench]
          fn hello_world_10_times(b: &mut Bencher) {
              b.iter(|| {
                  for _ in 0..10 {
                      println!("Hello, world!");
                  }
              });
          }
      }
    #+end_src

  * Running the ~cargo bench~ command compiles the code *in release mode* and
    executes the benchmarks. ~cargo bench~ takes arguments _SIMILAR TO_ the
    ~cargo test~ command, allowing you to _FILTER benchmarks by name_ or _run
    ONLY SPECIFIC benchmarks_.

    When you run ~cargo bench~, Rust's test library runs the code within
    ~Bencher::iter()~ per the following rules to obtain a stable result:

    1. The benchmark is run 50 times, and a summary of the results is calculated.

    2. The outliers are removed from the results (the fastest and slowest 5% of
       the results).

    3. The benchmark is run again 50 times, and the results are calculated.

    4. If either of the following conditions is met, the results are returned:
       + The standard deviation of the results is less than 100 milliseconds.
       + The benchmark has been running for more than 3 seconds.

    5. If neither condition is met, the benchmark runs again from step 1.

  * Q :: How to avoid long-run benchmarks when step 4 can't be satisfied several times?
    =from Jian=

  * =IMPORTANT=
    If you want to run benchmarks in _stable Rust_, you can use the
    _Criterion.rs crate_ (documented at
    https://bheisler.github.io/criterion.rs/book), which provides a feature-rich
    benchmarking tool. Criterion.rs is a Rust port of Haskell's Criterion
    library.

- =IMPORTANT=
  ~Vec~ benefits from being a contiguous block of memory, which makes it
  *cache-friendly* in most modern CPUs and gives the compiler opportunities to
  optimize operations at the instruction level.

*** DONE 10.5 Too many clones - 216
CLOSED: [2024-10-05 Sat 22:21]
*** 10.6 Using ~Deref~ to emulate polymorphism - 217
*** 10.7 Global data and singletons - 221
*** DONE 10.8 Too many smart pointers - 221
CLOSED: [2024-10-07 Mon 13:42]
- Rust provides the following core smart-pointer types:
  * ~Box~ - A smart pointer that
    + provides *heap allocation and deallocation*
    + allows you to *move values between scopes*
    + enables you to *hold values whose size isn't known at compile time within
      objects that have a fixed size (such as ~Sized~)*.

  * ~Rc~ - A reference-counted smart pointer that
    + allows *multiple owners or shared ownership of a value*
    + also provides the features of ~Box~.

  * ~Arc~ - An *atomic* reference-counted smart pointer that
    + allows *multiple owners of a value _ACROSS_ threads*,
    + providing the features of ~Rc~ and ~Box~ *in a thread-safe manner*.

    ~Arc~ doesn't synchronize the value itself; its synchronization is only for
    the reference count.

- Additionally, ~RefCell~ and ~Cell~ provide /interior mutability/ and are often
  used *in conjunction with ~Rc~ and ~Arc~.*
  1. ~Rc~ and ~Arc~
     _allow_ you to share ownership of a value
     BUT _don't allow_ you to mutate the value.

  2. ~RefCell~ and ~Cell~
     _allow_ you to mutate the value
     BUT _don't allow_ you to share ownership of the value

- *If you use smart pointers as an escape hatch to avoid the borrow checker, you
  should reconsider your design.*

  * A good rule of thumb is to try to write code without smart pointers and add
    them as required.

*** 10.9 Where to go from here - 223
*** Summary - 223

** DONE appendix - Installing Rust - 225
CLOSED: [2024-10-02 Wed 00:39]
*** A.1 Installing tools for this book
**** A.1.1 Installing tools for macOS using Homebrew
**** A.1.2 Installing tools for Linux systems
Install some prerequisite and then run
~$ rustup toolchain install stable nightly~

**** A.1.3 Installing tools for Windows

*** A.2 Managing rustc and other Rust components with rustup
- At a minimum, I recommend that you install the stable and nightly channels of
  Rust.

**** A.2.1 Installing rustc and other components
#+begin_src shell
  # Install stable Rust and make it the default toolchain
  $ rustup default stable

  #...

  # Install nightly Rust
  $ rustup toolchain install nightly

  $ rustup component add clippy rustfmt
#+end_src

**** A.2.2 Switching default toolchains with rustup
#+begin_src shell
  # Switch to stable toolchain
  $ rustup default stable

  # Switch to nightly toolchain
  $ rustup default nightly
#+end_src
**** A.2.3 Updating Rust components
~rustup update~

- It's recommended you avoid upgrading _nightly_ version too frequently (i.e.,
  daily) because you're more likely to run into problems.

** index - 229
