#+TITLE: Idiomatic Rust
#+SUBTITLE: Code like a Rustacean
#+AUTHOR: Brenden Matthews
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

** preface - xi
** acknowledgments - xii
** about this book - xiv
** about the author - xviii
** about the cover illustration - xix

* PART 1 BUILDING BLOCKS - 1
** 1 Rust-y patterns - 3
*** 1.1 What this book covers - 4
*** 1.2 What design patterns are - 5
*** 1.3 Why this book is different - 8
*** 1.4 Tools you'll need - 9

** 2 Rust’s basic building blocks - 10
*** 2.1 Generics - 11
**** A Turing-complete type system - 11
**** Why generics? - 12
**** Basics of generics - 12
**** Exploring Rust's ~Option~ - 15
**** Marker structs and phantom types - 15
**** Generic parameter trait bounds - 18

*** 2.2 Traits - 18
**** Why traits are not object-oriented programming - 19
**** What’s in a trait? - 19
**** Understanding traits by examining object-oriented code - 21
**** Combining generics and traits - 24
**** Deriving traits automatically - 28
**** Trait objects - 29

** 3 Code flow - 34
*** 3.1 A tour of pattern matching - 35
**** Basics of pattern matching - 35
**** Clean matches with the ? operator - 40

*** 3.2 Functional Rust - 43
**** Basics of functional programming in Rust - 43
**** Closure variable capture - 45
**** Examining iterators - 46
**** Obtaining an iterator with iter(), into_iter(), and iter_mut() - 50
**** Iterator features - 58

* PART 2 CORE PATTERNS - 63
** 4 Introductory patterns - 65
*** 4.1 Resource acquisition is initialization - 66
**** Understanding RAII in C and C++ - 66
**** A tour of RAII in Rust - 70
**** Summarizing RAII in Rust - 72

*** 4.2 Passing arguments by value vs. reference - 74
**** Passing by value - 74
**** Passing by reference - 75
**** When to do what: Passing by value vs. reference - 77

*** 4.3 Constructors - 78
*** 4.4 Object-member visibility and access - 80
*** 4.5 Error handling - 82
*** 4.6 Global state - 85
**** lazy-static.rs - 87
**** once_cell - 88
**** static_init - 89
**** std::cell::OnceCell - 89

** 5 Design patterns: Beyond the basics - 91
*** 5.1 Metaprogramming with macros - 92
**** A basic declarative macro in Rust - 93
**** When to use macros - 94
**** Using macros to write mini-DSLs - 99
**** Using macros for DRY - 103

*** 5.2 Optional function arguments - 103
**** Examining optional arguments in Python - 103
**** Examining optional arguments in C++ - 104
**** Optional arguments in Rust or the lack thereof - 104
**** Emulating optional arguments with traits - 104

*** 5.3 Builder pattern - 107
**** Implementing the builder pattern - 107
**** Enhancing our builder with traits - 109
**** Enhancing our builder with macros - 110

*** 5.4 Fluent interface pattern - 113
**** A fluent builder - 114
**** Test-driving our fluent builder - 117

*** 5.5 Observer pattern - 117
**** Why not callbacks - 117
**** Implementing an observer - 118

*** 5.6 Common pattern - 121
**** Defining the command pattern - 121
**** Implementing the command pattern - 121

*** 5.7 Newtype pattern - 124

** 6 Designing a library - 128
*** 6.1 Meditate on good library design - 129
*** 6.2 Do one thing, do it well, and do it correctly - 129
*** 6.3 Avoid excessive abstraction - 130
*** 6.4 Stick to basic types - 130
*** 6.5 Use the tools - 131
*** 6.6 Good artists copy; great artists steal (from the standard library) - 132
*** 6.7 Document everything, and provide examples - 132
*** 6.8 Don’t break the user’s code - 132
*** 6.9 Think of the state - 133
*** 6.10 Consider the aesthetics - 134
*** 6.11 Examining Rust library ergonomics - 134
**** Revisiting linked lists - 134
**** Using rustdoc to improve our API design - 135
**** Improving our linked list with more tests - 143
**** Making our library easier for others to debug - 145

* TODO PART 3 ADVANCED PATTERNS - 149
* TODO PART 4 PROBLEM AVOIDANCE - 187
