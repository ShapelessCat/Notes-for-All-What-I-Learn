#+TITLE: Idiomatic Rust
#+SUBTITLE: Code like a Rustacean
#+AUTHOR: Brenden Matthews
#+YEAR: 2024
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

** preface - xi
- Internet Relay Chat (IRC)
- =en= infancy
- =en= grateful

** acknowledgments - xii
** about this book - xiv
- This book grew out of my other book, Code Like a Pro in Rust (Manning Publications, 2024).

*** How is this book different?
*** Who should read this book?
*** How this book is organized
*** How to read this book
This book is organized into four parts, each consisting of chapters that cover a
specific aspect of Rust programming.
- Part 1 is a review of Rust’s core features and building blocks:
  * Chapter 1 discusses the content of the book and introduces design patterns.
  * Chapter 2 presents the basic building blocks of Rust.
  * Chapter 3 reviews pattern matching and functional programming.

- Part 2 goes into detail on Rust’s core patterns and library design:
  * Chapter 4 introduces core patterns in Rust.
  * Chapter 5 presents Rust design patterns.
  * Chapter 6 discusses library design.

- Part 3 covers more advanced patterns in Rust:
  * Chapter 7 discusses advanced techniques and patterns in Rust.
  * Chapter 8 builds on the topics in chapter 7.

- Part 4 discusses how to avoid problems and build robust software:
  * Chapter 9 discusses immutability and how it’s used in Rust.
  * Chapter 10 presents several antipatterns and shows how to avoid them.

*** About the code
*** liveBook discussion forum

** about the author - xviii
** about the cover illustration - xix

* TODO PART 1 BUILDING BLOCKS - 1
- =en= at our disposal effectively

** 1 Rust-y patterns - 3
- This chapter covers
  * What this book covers
  * What design patterns are
  * Why this book is different
  * Tools you’ll need

- =TODO=
  Reading code is often more challenging than writing code.

- We can take advantage of millions of years of evolution by teaching our brains
  which /patterns/ to recognize, short-circuiting the challenge of judging code
  quality.
  =GOOD QUOTE=

- =en= a curated experience

*** 1.1 What this book covers - 4
- =en= grok
- =en= mental gymnastics
- =en= cruft
- =en= foster

*** 1.2 What design patterns are - 5
- I refer to
  _techniques_,
  _idioms_, and
  _conventions_
  that are widely used and understood by the Rust community as /patterns/.

- I use /patterns/ and /design patterns/ *interchangeably* _throughout this
  book_, but I generally refer to patterns as a subset of design patterns.

- I'll focus on *TWO* key points:
  * idioms :: generally relate to the _code_ itself
  * patterns :: generally relate to the _design and architecture_ of your software.
    + Another way to say the same thing:
      /patterns/ are composed of /idioms/.

- =en= march to the beat of your own drum

*** 1.3 Why this book is different - 8
- =en= mimicry

- Rust's unique language features require a little more thought
  WHEN it comes to _API design and the act of building high-quality code_.
  In particular, we have to think harder about
  HOW we
  * manage memory and object lifetimes,
  * pass values between contexts,
  * avoid race conditions, and
  * ensure that our APIs are ergonomic.

- Rust is full of greenfield opportunities to _create or discover_ *new* /patterns/,
  which will certainly evolve after this book is published.
  * Rust's abstractions SIMULTANEOUSLY
    1. unlock new patterns and
    2. make old patterns obsolete.

*** 1.4 Tools you'll need - 9
- Table 1.1 Required tools
  * _git_
  * _rustup_
  * _gcc_ or _clang_

- Summary
  * Good design patterns are reusable, broadly applicable, and capable of solving
    common programming problems.

  * The hallmarks of a good design pattern are that it becomes widely adopted over
    time and is easy to understand and reason about.

  * An antipattern is a design pattern that’s poorly understood, underspecified, or
    considered harmful.

  * This book presents Rust-specific design patterns that take advantage of the
    unique features provided by the Rust language and its tooling.

  * You need an up-to-date installation of Rust, Git, and a modern compiler such as
    GNU’s GCC or LLVM’s Clang.

  * To get the most out of this book, follow along with the code samples at
    https://github.com/brndnmtthws/idiomatic-rust-book.

** 2 Rust's basic building blocks - 10
- This chapter covers
  * Exploring the core Rust patterns
  * Diving into Rust generics
  * Exploring traits
  * Combining generics and traits
  * Deriving traits automatically

*** 2.1 Generics - 11
**** A Turing-complete type system - 11
**** Why generics? - 12
**** Basics of generics - 12
**** Exploring Rust's ~Option~ - 15
**** Marker structs and phantom types - 15
**** Generic parameter trait bounds - 18

*** 2.2 Traits - 18
**** Why traits are not object-oriented programming - 19
**** What’s in a trait? - 19
**** Understanding traits by examining object-oriented code - 21
**** Combining generics and traits - 24
**** Deriving traits automatically - 28
**** Trait objects - 29

** 3 Code flow - 34
- This chapter covers
  * Discussing pattern matching
  * Handling errors with pattern matching
  * Reviewing Rust’s functional programming patterns

*** 3.1 A tour of pattern matching - 35
**** Basics of pattern matching - 35
**** Clean matches with the ~?~ operator - 40

*** 3.2 Functional Rust - 43
**** Basics of functional programming in Rust - 43
**** Closure variable capture - 45
**** Examining iterators - 46
**** Obtaining an iterator with ~iter()~, ~into_iter()~, and ~iter_mut()~ - 50
**** Iterator features - 58

* TODO PART 2 CORE PATTERNS - 63
** 4 Introductory patterns - 65
- This chapter covers
  * Understanding _resource acquisition_ is _initialization_
  * Passing arguments by value versus reference
  * Using constructors
  * Understanding object member visibility and access
  * Handling errors
  * Global state handling with =lazy-static.rs=, ~OnceCell~, and ~static_init~

- This chapter _FOCUSES ON_ *bite-size patterns*, which we'll use a lot.

- You'll quickly find when working with Rust that the standard library is somewhat
  bare and doesn't include many of the features you might expect from a modern
  language. *These limits are by design;* the Rust team chose to keep the standard
  library minimal and instead rely on crates to provide additional functionality.
  This approach has SEVERAL BENEFITS:
  * The standard library is smaller and easier to maintain.
  * The standard library is more stable and less likely to change.
  * The standard library is more focused on core functionality.
  * The community can build and maintain separate competing crates for specialized
    functionality, allowing developers to choose the most suitable crate for
    their needs.

*** TODO 4.1 Resource acquisition is initialization - 66
- Resource acquisition is initialization (RAII)

**** 4.1.1 Understanding RAII in C and C++ - 66
- *Scoping in C*

**** 4.1.2 A tour of RAII in Rust - 70
**** 4.1.3 Summarizing RAII in Rust - 72

*** TODO 4.2 Passing arguments by value vs. reference - 74
**** 4.2.1 Passing by value - 74
**** 4.2.2 Passing by reference - 75
- *Why is it impossible to mutate Rust strings in place?*

**** 4.2.3 When to do what: Passing by value vs. reference - 77

*** TODO 4.3 Constructors - 78
*** TODO 4.4 Object-member visibility and access - 80
*** TODO 4.5 Error handling - 82
*** TODO 4.6 Global state - 85
**** 4.6.1 lazy-static.rs - 87
**** 4.6.2 ~once_cell~ - 88
**** 4.6.3 ~static_init~ - 89
**** 4.6.4 ~std::cell::OnceCell~ - 89

** 5 Design patterns: Beyond the basics - 91
- This chapter covers
  * Metaprogramming with macros
  * Implementing the builder pattern in Rust
  * Building fluent interfaces
  * Observing the observer pattern
  * Understanding the command pattern
  * Exploring the newtype pattern

*** 5.1 Metaprogramming with macros - 92
**** 5.1.1 A basic declarative macro in Rust - 93
**** 5.1.2 When to use macros - 94
**** 5.1.3 Using macros to write mini-DSLs - 99
**** 5.1.4 Using macros for DRY - 103

*** 5.2 Optional function arguments - 103
**** 5.2.1 Examining optional arguments in Python - 103
**** 5.2.2 Examining optional arguments in C++ - 104
**** 5.2.3 Optional arguments in Rust or the lack thereof - 104
**** 5.2.4 Emulating optional arguments with traits - 104

*** 5.3 Builder pattern - 107
**** 5.3.1 Implementing the builder pattern - 107
**** 5.3.2 Enhancing our builder with traits - 109
**** 5.3.3 Enhancing our builder with macros - 110

*** 5.4 Fluent interface pattern - 113
**** 5.4.1 A fluent builder - 114
- *Initializing structs with the spread syntax*

**** 5.4.2 Test-driving our fluent builder - 117

*** 5.5 Observer pattern - 117
**** 5.5.1 Why not callbacks - 117
**** 5.5.2 Implementing an observer - 118

*** 5.6 Common pattern - 121
**** 5.6.1 Defining the command pattern - 121
**** 5.6.2 Implementing the command pattern - 121

*** 5.7 Newtype pattern - 124
- *Conversion method naming idioms: as_…(), to_…(), and into()*

** 6 Designing a library - 128
- This chapter covers
  * Thinking about how to design a great library
  * Making beautiful interfaces
  * Being correct and avoiding unexpected behavior
  * Exploring Rust library ergonomics and patterns

*** 6.1 Meditate on good library design - 129
*** 6.2 Do one thing, do it well, and do it correctly - 129
*** 6.3 Avoid excessive abstraction - 130
*** 6.4 Stick to basic types - 130
*** 6.5 Use the tools - 131
*** 6.6 Good artists copy; great artists steal (from the standard library) - 132
*** 6.7 Document everything, and provide examples - 132
*** 6.8 Don't break the user's code - 132
*** 6.9 Think of the state - 133
*** 6.10 Consider the aesthetics - 134
*** 6.11 Examining Rust library ergonomics - 134
**** 6.11.1 Revisiting linked lists - 134
**** 6.11.2 Using =rustdoc= to improve our API design - 135
**** 6.11.3 Improving our linked list with more tests - 143
**** 6.11.4 Making our library easier for others to debug - 145

* TODO PART 3 ADVANCED PATTERNS - 149
** 7 Using traits, generics, and structs for specialized tasks - 151
- This chapter covers
  * Using const generics
  * Applying traits to external crate types
  * Extending types with extension traits
  * Implementing blanket traits
  * Using marker traits to mark types with attributes
  * Tagging with structs
  * Providing access to internal data with reference objects

*** 7.1 Const generics - 152
*** 7.2 Implementing traits for external crate types - 154
**** 7.2.1 Wrapper structs - 154
**** 7.2.2 Using Deref to unwrap a wrapped struct - 154

*** 7.3 Extension traits - 155
*** 7.4 Blanket traits - 157
*** 7.5 Marker traits - 159
- *Supertraits*

*** 7.6 Struct tagging - 161
*** 7.7 Reference objects - 163

** 8 State machines, coroutines, macros, and preludes - 169
- This chapter covers
  * Using traits to construct state machines
  * Writing pausable functions with coroutines
  * Implementing procedural macros
  * Providing preludes to improve the usability of your crates

*** 8.1 Trait state machine - 170
*** 8.2 Coroutines - 173
- *On the origins of coroutines*

*** 8.3 Procedural macros - 178
*** 8.4 Preludes - 182

* TODO PART 4 PROBLEM AVOIDANCE - 187
** 9 Immutability - 189
- This chapter covers
  * Understanding the benefits of immutability
  * Thinking in terms of immutable data and how it works in Rust
  * Using traits to make nearly anything immutable
  * Exploring crates that provide immutable data structures

*** 9.1 The benefits of immutability - 190
*** 9.2 Why immutability is not a magic bullet - 192
*** 9.3 How to think about immutable data - 192
*** 9.4 Understanding immutability in Rust - 193
*** 9.5 Reviewing the basics of immutability in Rust - 194
*** 9.6 Using traits to make (almost) anything immutable - 197
*** 9.7 Using Cow for immutability - 198
*** 9.8 Using crates for immutable data structures - 201
**** 9.8.1 Using im - 201
**** 9.8.2 Using rpds - 202

** 10 Antipatterns - 205
- This chapter covers
  * Discussing programming antipatterns
  * Reviewing common antipatterns in Rust
  * Recognizing when to use and when to avoid contentious patterns

*** 10.1 What is an antipattern? - 206
*** 10.2 Using ~unsafe~ - 207
**** 10.2.1 What does ~unsafe~ do? - 208
**** 10.2.2 Where can you use ~unsafe~? - 209
**** 10.2.3 When should you use ~unsafe~? - 211
**** 10.2.4 Should you worry about ~unsafe~? - 211

*** 10.3 Using ~unwrap()~ - 212
*** 10.4 Not using ~Vec~ - 212
- *Rust’s benchmarking tools*

*** 10.5 Too many clones - 216
*** 10.6 Using ~Deref~ to emulate polymorphism - 217
*** 10.7 Global data and singletons - 221
*** 10.8 Too many smart pointers - 221
*** 10.9 Where to go from here - 223

** DONE appendix - Installing Rust - 225
CLOSED: [2024-10-02 Wed 00:39]
*** A.1 Installing tools for this book
**** A.1.1 Installing tools for macOS using Homebrew
**** A.1.2 Installing tools for Linux systems
Install some prerequisite and then run
~$ rustup toolchain install stable nightly~

**** A.1.3 Installing tools for Windows

*** A.2 Managing rustc and other Rust components with rustup
- At a minimum, I recommend that you install the stable and nightly channels of
  Rust.

**** A.2.1 Installing rustc and other components
#+begin_src shell
  # Install stable Rust and make it the default toolchain
  $ rustup default stable

  #...

  # Install nightly Rust
  $ rustup toolchain install nightly

  $ rustup component add clippy rustfmt
#+end_src

**** A.2.2 Switching default toolchains with rustup
#+begin_src shell
  # Switch to stable toolchain
  $ rustup default stable

  # Switch to nightly toolchain
  $ rustup default nightly
#+end_src
**** A.2.3 Updating Rust components
~rustup update~

- It's recommended you avoid upgrading _nightly_ version too frequently (i.e.,
  daily) because you're more likely to run into problems.

** index - 229
