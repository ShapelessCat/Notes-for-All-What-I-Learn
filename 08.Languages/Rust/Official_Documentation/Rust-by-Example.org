#+TITLE: Rust By Example
#+STARTUP: overview
#+STARTUP: entitiespretty
#+STARTUP: indent

* Introduction
- Rust is a modern systems programming language _FOCUSING ON_
  safety,
  speed, and
  concurrency.

  It accomplishes these goals by being *memory safe without using garbage
  collection*.

- /Rust by Example (RBE)/ is a collection of runnable examples that illustrate
  various Rust concepts and standard libraries.

- Now let's begin!
  * Hello World - Start with a traditional Hello World program.

  * Primitives - Learn about signed integers, unsigned integers and other
                 primitives.

  * Custom Types - ~struct~ and ~enum~.

  * Variable Bindings - mutable bindings, scope, shadowing.

  * Types - Learn about changing and defining types.

  * Conversion - Convert between different types, such as strings, integers, and
                 floats.

  * Expressions - Learn about Expressions & how to use them.

  * Flow of Control - ~if~ / ~else~, ~for~, and others.

  * Functions - Learn about Methods, Closures and Higher Order Functions.

  * Modules - Organize code using modules

  * Crates - A crate is a compilation unit in Rust. Learn to create a library.

  * Cargo - Go through some basic features of the official Rust package
            management tool.

  * Attributes - An attribute is metadata applied to some module, crate or item.

  * Generics - Learn about writing a function or data type which can work for
               multiple types of arguments.

  * Scoping rules - Scopes play an important part in ownership, borrowing, and
                    lifetimes.

  * Traits - A trait is a collection of methods defined for an unknown type:
             ~Self~

  * Macros - Macros are a way of writing code that writes other code, which is
             known as metaprogramming.

  * Error handling - Learn Rust way of handling failures.

  * Std library types - Learn about some custom types provided by ~std~ library.

  * Std misc - More custom types for file handling, threads.

  * Testing - All sorts of testing in Rust.

  * Unsafe Operations - Learn about entering a block of unsafe operations.

  * Compatibility - Handling Rust's evolution and potential compatibility issues.

  * Meta - Documentation, Benchmarking.

* 1. Hello World
** 1.1. Comments
** TODO 1.2. Formatted print
- Printing is handled by a series of macros defined in ~std::fmt~ some of which
  are:
  * ~format!~: write formatted text to ~String~
  * ~print!~: same as ~format!~ but the text is printed to the console (~io::stdout~).
  * ~println!~: same as ~print!~ but a newline is appended.
  * ~eprint!~: same as ~print!~ but the text is printed to the standard error (~io::stderr~).
  * ~eprintln!~: same as ~eprint!~ but a newline is appended.

- *Activities*

*** 1.2.1. Debug
*** 1.2.2. Display
**** 1.2.2.1. Testcase: List

*** 1.2.3. Formatting

* 2. Primitives
** 2.1. Literals and operators
** 2.2. Tuples
** 2.3. Arrays and Slices

* 3. Custom Types
** 3.1. Structures
** 3.2. Enums
*** 3.2.1. use
*** 3.2.2. C-like
*** 3.2.3. Testcase: linked-list

** 3.3. constants

* 4. Variable Bindings
** 4.1. Mutability
** 4.2. Scope and Shadowing
** 4.3. Declare first

* 5. Types
** 5.1. Casting
** 5.2. Literals
** 5.3. Inference
** 5.4. Aliasing

* 6. Conversion
** 6.1. From and Into
** 6.2. To and from Strings

* 7. Expressions
* 8. Flow Control
** 8.1. if/else
** 8.2. loop
*** 8.2.1. Nesting and labels
*** 8.2.2. Returning from loops

** 8.3. while
** 8.4. for and range
** 8.5. match
*** 8.5.1. Destructuring
**** 8.5.1.1. tuples
**** 8.5.1.2. enums
**** 8.5.1.3. pointers/ref
**** 8.5.1.4. structs

*** 8.5.2. Guards
*** 8.5.3. Binding

** 8.6. if let
** 8.7. while let

* 9. Functions
** 9.1. Methods
** 9.2. Closures
*** 9.2.1. Capturing
*** 9.2.2. As input parameters
*** 9.2.3. Type anonymity
*** 9.2.4. Input functions
*** 9.2.5. As output parameters
*** 9.2.6. Examples in std
**** 9.2.6.1. Iterator::any
**** 9.2.6.2. Iterator::find

** 9.3. Higher Order Functions
** 9.4. Diverging functions

* 10. Modules
** 10.1. Visibility
** 10.2. Struct visibility
** 10.3. The use declaration
** 10.4. super and self
** 10.5. File hierarchy

* 11. Crates
** 11.1. Library
** 11.2. extern crate

* 12. Cargo
** 12.1. Dependencies
** 12.2. Conventions
** 12.3. Tests
** 12.4. Build Scripts

* 13. Attributes
** 13.1. dead_code
** 13.2. Crates
** 13.3. cfg
*** 13.3.1. Custom

* 14. Generics
** 14.1. Functions
** 14.2. Implementation
** 14.3. Traits
** 14.4. Bounds
*** 14.4.1. Testcase: empty bounds

** 14.5. Multiple bounds
** 14.6. Where clauses
** 14.7. New Type Idiom
** 14.8. Associated items
*** 14.8.1. The Problem
*** 14.8.2. Associated types

** 14.9. Phantom type parameters
*** 14.9.1. Testcase: unit clarification

* 15. Scoping rules
** 15.1. RAII
** 15.2. Ownership and moves
*** 15.2.1. Mutability

** 15.3. Borrowing
*** 15.3.1. Mutability
*** 15.3.2. Freezing
*** 15.3.3. Aliasing
*** 15.3.4. The ref pattern

** 15.4. Lifetimes
*** 15.4.1. Explicit annotation
*** 15.4.2. Functions
*** 15.4.3. Methods
*** 15.4.4. Structs
*** 15.4.5. Traits
*** 15.4.6. Bounds
*** 15.4.7. Coercion
*** 15.4.8. Static
*** 15.4.9. Elision

* 16. Traits
** 16.1. Derive
** 16.2. Operator Overloading
** 16.3. Drop
** 16.4. Iterators
** 16.5. Clone

* 17. ~macro_rules!~
** 17.1. Syntax
*** 17.1.1. Designators
*** 17.1.2. Overload
*** 17.1.3. Repeat

** 17.2. DRY (Don't Repeat Yourself)
** 17.3. DSL (Domain Specific Languages)
** 17.4. Variadics

* 18. Error handling
** 18.1. panic
** 18.2. Option & unwrap
*** 18.2.1. Combinators: map
*** 18.2.2. Combinators: and_then

** 18.3. Result
*** 18.3.1. map for Result
*** 18.3.2. aliases for Result
*** 18.3.3. Early returns
*** 18.3.4. Introducing ?

** 18.4. Multiple error types
*** 18.4.1. Pulling Results out of Options
*** 18.4.2. Defining an error type
*** 18.4.3. Boxing errors
*** 18.4.4. Other uses of ?
*** 18.4.5. Wrapping errors

** 18.5. Iterating over Results

* 19. Std library types
** 19.1. Box, stack and heap
** 19.2. Vectors
** 19.3. Strings
** 19.4. Option
** 19.5. Result
*** 19.5.1. ?

** 19.6. panic!
** 19.7. HashMap
*** 19.7.1. Alternate/custom key types
*** 19.7.2. HashSet

* 20. Std misc
** 20.1. Threads
*** 20.1.1. Testcase: map-reduce

** 20.2. Channels
** 20.3. Path
** 20.4. File I/O
*** 20.4.1. open
*** 20.4.2. create
*** 20.4.3. read lines

** 20.5. Child processes
*** 20.5.1. Pipes
*** 20.5.2. Wait

** 20.6. Filesystem Operations
** 20.7. Program arguments
*** 20.7.1. Argument parsing

** 20.8. Foreign Function Interface

* 21. Testing
** 21.1. Unit testing
** 21.2. Documentation testing
** 21.3. Integration testing
** 21.4. Dev-dependencies

* 22. Unsafe Operations
* 23. Compatibility
** 23.1. Raw identifiers

* 24. Meta
** 24.1. Documentation
