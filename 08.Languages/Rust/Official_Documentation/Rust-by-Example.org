#+TITLE: Rust By Example
#+STARTUP: overview
#+STARTUP: entitiespretty
#+STARTUP: indent

* Introduction
- Rust is a modern systems programming language _FOCUSING ON_
  safety,
  speed, and
  concurrency.

  It accomplishes these goals by being *memory safe without using garbage
  collection*.

- /Rust by Example (RBE)/ is a collection of runnable examples that illustrate
  various Rust concepts and standard libraries.

- Now let's begin!
  * Hello World - Start with a traditional Hello World program.

  * Primitives - Learn about signed integers, unsigned integers and other
                 primitives.

  * Custom Types - ~struct~ and ~enum~.

  * Variable Bindings - mutable bindings, scope, shadowing.

  * Types - Learn about changing and defining types.

  * Conversion - Convert between different types, such as strings, integers, and
                 floats.

  * Expressions - Learn about Expressions & how to use them.

  * Flow of Control - ~if~ / ~else~, ~for~, and others.

  * Functions - Learn about Methods, Closures and Higher Order Functions.

  * Modules - Organize code using modules

  * Crates - A crate is a compilation unit in Rust. Learn to create a library.

  * Cargo - Go through some basic features of the official Rust package
            management tool.

  * Attributes - An attribute is metadata applied to some module, crate or item.

  * Generics - Learn about writing a function or data type which can work for
               multiple types of arguments.

  * Scoping rules - Scopes play an important part in ownership, borrowing, and
                    lifetimes.

  * Traits - A trait is a collection of methods defined for an unknown type:
             ~Self~

  * Macros - Macros are a way of writing code that writes other code, which is
             known as metaprogramming.

  * Error handling - Learn Rust way of handling failures.

  * Std library types - Learn about some custom types provided by ~std~ library.

  * Std misc - More custom types for file handling, threads.

  * Testing - All sorts of testing in Rust.

  * Unsafe Operations - Learn about entering a block of unsafe operations.

  * Compatibility - Handling Rust's evolution and potential compatibility issues.

  * Meta - Documentation, Benchmarking.

* DONE 1. Hello World
CLOSED: [2024-09-28 Sat 21:57]
** DONE 1.1. Comments
CLOSED: [2024-09-28 Sat 15:11]
Any program requires comments, and Rust supports a few different varieties:

- Regular comments which are ignored by the compiler:
  * line comment:
    #+begin_src rust
      // Line comments which go to the end of the line.
    #+end_src

  * block comment:
    #+begin_src rust
      /* Block comments which go to the closing delimiter. */
    #+end_src

- Doc comments which are parsed into HTML library documentation:
  * Inner Documentation Comments:
    Document items such as functions, structs, enums, traits, etc.
    #+begin_src rust
      /// Generate library docs for the following item.
    #+end_src

  * Outer Documentation Comments:
    Document /modules/ or the /crate/ *as a whole*.
    #+begin_src rust
      //! Generate library docs for the enclosing item.
    #+end_src

** DONE 1.2. Formatted print
CLOSED: [2024-09-28 Sat 21:57]
- Printing is handled by a series of macros defined in ~std::fmt~ some of which
  are:
  * ~format!~: write formatted text to ~String~
  * ~print!~: same as ~format!~ but the text is printed to the console (~io::stdout~).
  * ~println!~: same as ~print!~ but a newline is appended.
  * ~eprint!~: same as ~print!~ but the text is printed to the standard error (~io::stderr~).
  * ~eprintln!~: same as ~eprint!~ but a newline is appended.

- ~std::fmt~ contains many /traits/ which govern _the display of text_.
  The base form of two important ones are listed below:
  * ~fmt::Debug~: Uses the ~{:?}~ marker.
    Format text for debugging purposes.

  * ~fmt::Display~: Uses the ~{}~ marker.
    Format text in a more elegant, user friendly fashion.

- Here, we used ~fmt::Display~ because the std library provides implementations for
  these types. To print text for custom types, more steps are required.

- Implementing the ~fmt::Display~ /trait/ *AUTOMATICALLY* implements the ~ToString~
  /trait/ which allows us to convert the type to ~String~.

- In line 43, ~#[allow(dead_code)]~ is an attribute which only applies to the
  /module/ after it.

- *Activities*

*** 1.2.1. ~Debug~
- _Automatic implementations_ are ONLY PROVIDED for types such as in the ~std~
  library. All others must be _MANUALLY implemented_ somehow.

- ~fmt::Display~ must be manually implemented.

- *ALL* ~std~ library types are automatically printable with ~{:?}~ too.

- So ~fmt::Debug~ definitely makes this printable but sacrifices some elegance.
  Rust also provides *"pretty printing"* with ~{:#?}~.

*** 1.2.2. ~Display~
- ~fmt::Display~ uses the ~{}~ marker.

- Since it is ambiguous about what is the ideal way to display some types, many types
  in ~std~ doesn't implement ~fmt::Display~.
  * ~fmt::Display~ is not implemented for any other generic containers.

- ~fmt::Binary~ uses the ~{:b}~ marker.

***** Activity

**** 1.2.2.1. Testcase: List

*** 1.2.3. Formatting
**** Activity

* DONE 2. Primitives
CLOSED: [2024-09-28 Sat 23:14]
*** Scalar Types
- Signed integers: ~i8~, ~i16~, ~i32~, ~i64~, ~i128~ and ~isize~ (pointer size)
- Unsigned integers: ~u8~, ~u16~, ~u32~, ~u64~, ~u128~ and ~usize~ (pointer size)
- Floating point: ~f32~, ~f64~
- ~char~ /Unicode scalar values/ like ~'a'~, ~'α'~ and ~'∞'~ (*4 bytes each*)
- ~bool~ either ~true~ or ~false~
- The /unit type/ ~()~, whose only possible value is an _empty tuple_: ~()~
  * Despite the value of a /unit type/ being a /tuple/, it is *NOT* considered a
    /compound type/ because it does not contain multiple values.

*** Compound Types
- Arrays like ~[1, 2, 3]~
- Tuples like ~(1, true)~

** DONE 2.1. Literals and operators
CLOSED: [2024-09-28 Sat 23:03]
- Prefixes for integer:
  * hexadecimal: ~0x~
  * octal: ~0o~
  * binary: ~0b~

** DONE 2.2. Tuples
CLOSED: [2024-09-28 Sat 23:05]
*** Activity

** DONE 2.3. Arrays and Slices
CLOSED: [2024-09-28 Sat 23:14]
- An /array/ is a collection of objects of the same type ~T~,
  stored in *contiguous memory*.
  * /Arrays/ are created using brackets ~[]~, and their _length_, which is *known
    at compile time*, is part of their /type signature/ ~[T; length]~.

- /Slices/ are _SIMILAR TO_ /arrays/, but their _length_ is *not known at compile
  time*.
  * Instead, a /slice/ is a _two-word object_:
    + the first word is a pointer to the data,
    + the second word is the length of the slice.
      - ~usize~, determined by the /processor architecture/, e.g. 64 bits on an
        x86-64.

  * /Slices/ can be used to borrow a section of an array and have the /type
    signature/ ~&[T]~.

* TODO 3. Custom Types
** 3.1. Structures
** 3.2. Enums
*** 3.2.1. ~use~
*** 3.2.2. C-like
*** 3.2.3. Testcase: linked-list

** 3.3. constants

* TODO 4. Variable Bindings
** 4.1. Mutability
** 4.2. Scope and Shadowing
** 4.3. Declare first
** 4.4. Freezing

* TODO 5. Types
** 5.1. Casting
** 5.2. Literals
** 5.3. Inference
** 5.4. Aliasing

* TODO 6. Conversion
** 6.1. ~From~ and ~Into~
** 6.2. ~TryFrom~ and ~TryInto~
** 6.3. To and from Strings

* TODO 7. Expressions
* TODO 8. Flow Control
** 8.1. ~if~ / ~else~
** 8.2. ~loop~
*** 8.2.1. Nesting and labels
*** 8.2.2. Returning from loops

** 8.3. ~while~
** 8.4. ~for~ and ~range~
** 8.5. ~match~
*** 8.5.1. Destructuring
**** 8.5.1.1. tuples
**** 8.5.1.2. arrays/slices
**** 8.5.1.3. enums
**** 8.5.1.4. pointers/ref
**** 8.5.1.5. structs

*** 8.5.2. Guards
*** 8.5.3. Binding

** 8.6. ~if let~
** 8.7. let-else
** 8.8. ~while let~

* TODO 9. Functions
** 9.1. Methods
** 9.2. Closures
*** 9.2.1. Capturing
*** 9.2.2. As input parameters
*** 9.2.3. Type anonymity
*** 9.2.4. Input functions
*** 9.2.5. As output parameters
*** 9.2.6. Examples in ~std~
**** 9.2.6.1. ~Iterator::any~
**** 9.2.6.2. Searching through iterators

** 9.3. Higher Order Functions
** 9.4. Diverging functions

* TODO 10. Modules
** 10.1. Visibility
** 10.2. Struct visibility
** 10.3. The ~use~ declaration
** 10.4. ~super~ and ~self~
** 10.5. File hierarchy

* TODO 11. Crates
** 11.1. Creating a Library
** 11.2. Using a Library

* TODO 12. Cargo
** 12.1. Dependencies
** 12.2. Conventions
** 12.3. Tests
** 12.4. Build Scripts

* TODO 13. Attributes
** 13.1. ~dead_code~
** 13.2. Crates
** 13.3. ~cfg~
*** 13.3.1. Custom

* TODO 14. Generics
** 14.1. Functions
** 14.2. Implementation
** 14.3. Traits
** 14.4. Bounds
*** 14.4.1. Testcase: empty bounds

** 14.5. Multiple bounds
** 14.6. Where clauses
** 14.7. New Type Idiom
** 14.8. Associated items
*** 14.8.1. The Problem
*** 14.8.2. Associated types

** 14.9. Phantom type parameters
*** 14.9.1. Testcase: unit clarification

* TODO 15. Scoping rules
** 15.1. RAII
** 15.2. Ownership and moves
*** 15.2.1. Mutability
*** 15.2.2. Partial moves

** 15.3. Borrowing
*** 15.3.1. Mutability
*** 15.3.2. Aliasing
*** 15.3.3. The ~ref~ pattern

** 15.4. Lifetimes
*** 15.4.1. Explicit annotation
*** 15.4.2. Functions
*** 15.4.3. Methods
*** 15.4.4. Structs
*** 15.4.5. Traits
*** 15.4.6. Bounds
*** 15.4.7. Coercion
*** 15.4.8. Static
*** 15.4.9. Elision

* TODO 16. Traits
** 16.1. Derive
** 16.2. Returning Traits with ~dyn~
** 16.3. Operator Overloading
** 16.4. ~Drop~
** 16.5. Iterators
** 16.6. ~impl~ Trait
** 16.7. ~Clone~
** 16.8. Supertraits
** 16.9. Disambiguating overlapping traits

* TODO 17. ~macro_rules!~
** 17.1. Syntax
*** 17.1.1. Designators
*** 17.1.2. Overload
*** 17.1.3. Repeat

** 17.2. DRY (Don't Repeat Yourself)
** 17.3. DSL (Domain Specific Languages)
** 17.4. Variadics

* TODO 18. Error handling
** 18.1. ~panic~
** 18.2 ~abort~ & ~unwind~
** 18.3. ~Option~ & ~unwrap~
*** 18.3.1. Unpacking options with ~?~
*** 18.3.2. Combinators: ~map~
*** 18.3.3. Combinators: ~and_then~
*** 18.3.4. Defaults: ~or~, ~or_else~, ~get_or_insert~, ~get_or_insert_with~

** 18.4. ~Result~
*** 18.4.1. ~map~ for ~Result~
*** 18.4.2. aliases for ~Result~
*** 18.4.3. Early returns
*** 18.4.4. Introducing ~?~

** 18.5. Multiple error types
*** 18.5.1. Pulling ~Result~'s out of ~Option~'s
*** 18.5.2. Defining an error type
*** 18.5.3. Boxing errors
*** 18.5.4. Other uses of ~?~
*** 18.5.5. Wrapping errors

** 18.6. Iterating over ~Result~'s

* TODO 19. Std library types
** 19.1. ~Box~, stack and heap
** 19.2. Vectors
** 19.3. Strings
** 19.4. ~Option~
** 19.5. ~Result~
*** 19.5.1. ~?~

** 19.6. ~panic!~
** 19.7. ~HashMap~
*** 19.7.1. Alternate/custom key types
*** 19.7.2. ~HashSet~

** 19.8. ~Rc~
** 19.9. ~Arc~

* TODO 20. Std misc
** 20.1. Threads
*** 20.1.1. Testcase: map-reduce

** 20.2. Channels
** 20.3. Path
** 20.4. File I/O
*** 20.4.1. open
*** 20.4.2. create
*** 20.4.3. ~read_lines~

** 20.5. Child processes
*** 20.5.1. Pipes
*** 20.5.2. Wait

** 20.6. Filesystem Operations
** 20.7. Program arguments
*** 20.7.1. Argument parsing

** 20.8. Foreign Function Interface

* TODO 21. Testing
** 21.1. Unit testing
** 21.2. Documentation testing
** 21.3. Integration testing
** 21.4. Dev-dependencies

* TODO 22. Unsafe Operations
** 22.1. Inline assembly

* TODO 23. Compatibility
** 23.1. Raw identifiers

* TODO 24. Meta
** 24.1. Documentation
** 24.2. Playground
