#+TITLE: Programming in Scala (2.12)
#+SUBTITLE: A comprehensive step-by-step guide
#+VERSION: 3rd
#+AUTHOR: Martin Odersky, Lex Spoon, Bill Venners
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* Contents
* List of Figures
* List of Tables
* List of Listings
* Foreword
  -

* Acknowledgments
* Introduction
* DONE 1 A Scalable Language
  CLOSED: [2017-10-24 Tue 18:37]
  The name Scala stands for "scalable language."

  - It runs on the standard Java platform and interoperates seamlessly with all
    Java libraries.

  - This initial chapter answers the question, "Why Scala?"

** DONE 1.1 A language that grows on you
   CLOSED: [2017-10-24 Tue 18:13]
   =Re-READ=
*** Growing new types
*** Growing new control constructs

** DONE 1.2 What makes Scala scalable?
   CLOSED: [2017-10-24 Tue 18:37]
*** Scala is object-oriented
*** Scala is functional
    Two main points:
    - First-class function
    - (Mostly) side-effect free

** DONE 1.3 Why Scala?
   CLOSED: [2017-10-24 Tue 00:53]
   People have their reasons why the like Scala.
   Four of the most important aspects will be discussed in this section:
   + compatibility
   + brevity
   + high-level abstractions
   + advanced static typing

*** DONE Scala is compatible
    CLOSED: [2017-10-24 Tue 00:28]
*** DONE Scala is concise
    CLOSED: [2017-10-24 Tue 00:28]
    Example:
    - Java version
      #+BEGIN_SRC java
        class MyClass {
            private int index;
            private String name;

            public MyClass(int index, String name) {
                this.index = index;
                this.name = name;
            }
        }
      #+END_SRC

    - Scala version
      #+BEGIN_SRC scala
        class MyClass(index: Int, name: String)
      #+END_SRC

*** DONE Scala is high-level
    CLOSED: [2017-10-24 Tue 00:36]
    - Example
      - Java (< 8) version

        #+BEGIN_SRC java
          // Before Java 8
          boolean nameHasUpperCase = false;

          for (int i = 0; i < name.length(); ++i) {
              if (Character.isUpperCase(name.charAt(i))) {
                  nameHasUpperCase = true;
                  break;
              }
          }
        #+END_SRC

      - Java 8+ version
        #+BEGIN_SRC java
          boolean nameHasUpperCase =
              name.chars().anyMatch(
                  (int c) -> Character.isUpperCase((char) c)
              );
        #+END_SRC

      - Scala version
        #+BEGIN_SRC scala
          val nameHasUpperCase = name.exists(_.isUpper)
        #+END_SRC

*** DONE Scala is statically typed
    CLOSED: [2017-10-24 Tue 00:52]
    - It allows you to parameterize types with generics, to combine types using
      /intersections/, and to hide details of types using /abstract types/.
      =TODO=

    - Static types do NOT mean verbose and inflexible, but some specific type
      systems are.

      This is why Alan Kay once remarked:
      "I'm NOT against types, but I don't know of any type systems that aren't a
      _complete pain_, so I still like dynamic typing.”
      (from footnote 14)

      However, the type system of Scala is good enough to say NOT COMPLETE PAIN,
      in fact, much better.

    - *Verifiable properties*
      + Edsger Dijkstra said, testing can only prove the presence of errors,
        never their absence.
        (footnote 15)

      + statically typed guarantees simple, however, which cannot be provided by
        testing.

    - *Safe refactorings*

    - *Documentation*
      + Unlike a normal comment, a type annotation can NEVER be out of date.

      + IDE's can use types as documentation to do something, and give you
        informative suggestions based on these info.

** DONE 1.4 Scala's roots
   CLOSED: [2017-10-24 Tue 00:14]
   Only a few features of Scala are genuinely new; most have been already
   applied in some form in other languages.

   Scala's innovations come primarily from how its constructs are put together.

   The list below cannot be exhaustive.

   - Surface level (Syntax):
     Scala <- Java / C# <- C / C++

   - Scala adopts Java's basic types, class libraries, execution model =TODO=.

   - Uniform object model:  =TODO=
     Scala <- Ruby <- Smalltalk

   - Universal nesting:
     Scala <- Algol, Simula, and, more recently, in Beta and gbeta =TODO=.

   - Uniform access principle:
     Eiffel

   - Functional programming:
     ML family

     + Higher-order functions in Scala's standard library: ML and Haskell

   - Implicit parameters were motivated by Haskell's type classes; they achieve
     analogous results in a more classical OO settings.
     =TODO=

   - Actor-based concurrency library (Akka):
     Erlang

   - Scala's type annotation is postfixed, which is good for type inference.
     It's hard for a compiler to do right thing if a prefixed type is omited.

     That's why C# 3.0 introduced ~var~ to tell compiler the programmer omit
     a type which need to be inferred.

** DONE 1.5 Conclusion
   CLOSED: [2017-10-24 Tue 00:14]

* DONE 2 First Steps in Scala - 64
  CLOSED: [2017-10-03 Tue 21:46]
  - footnote:
    This chapter Scala 2.11.7 is used,
    though 2.12 is written in the book cover.

** DONE Step 1. Learn to use the Scala interpreter - 64
   CLOSED: [2017-10-03 Tue 20:38]
  - The REPL evaluate the input expression, and save its value into a variable
    named in the pattern of ~resX~. The ~X~ here is a number. This variable can
    be re-used.
    #+BEGIN_SRC scala
      // scala> 1 + 2
      // res0: Int = 3

      // scala> res0 * 3
      // res1: Int = 9
    #+END_SRC

  - Meaningless value ~()~ won't be printed out
    #+BEGIN_SRC scala
      // scala> println("Hello, world!")
      // Hello, world!
    #+END_SRC

** DONE Step 2. Define some variables - 66
   CLOSED: [2017-10-03 Tue 20:55]
   - Declare a ~val~
     #+BEGIN_SRC scala
       // scala> val msg = "Hello, world!"
       // msg: String = Hello, world!

       //// You can't change the value of ~msg~.
       //// However, you can create a new one with the same (even with different type)
       //// to shadow the old one.

       // scala> msg = "Goodbye cruel world!"
       // <console>:8: error: reassignment to val
       //        msg = "Goodbye cruel world!"

       // scala> val msg = 3
       // msg: Int = 3
     #+END_SRC
     Scala doesn't have the feature of /same scope variable shadowing/ (=Jian create this name=).
     The shawdoing above is actually inner scope variable shadow the outer scope
     variable -- in Scala REPL, new input create a new inner scope.

     To be concrete, =See Section 7.7=
     1. this code cannot be compiled.
        #+BEGIN_SRC scala
          val a = 3
          val a = "String"
        #+END_SRC

     2. REPL actually create something like (=From Jian= guess):
        #+BEGIN_SRC scala
          val a = 3
          {
            val a = "String"
          }
        #+END_SRC

   - Declare a ~var~ and reassign a value to it
     #+BEGIN_SRC scala
       // scala> var greeting = "Hello, world!"
       // greeting: String = Hello, world!

       // scala> greeting = "Leave me alone, world!"
       // greeting: String = "Leave me alone, world!"
     #+END_SRC
     The "shadowing" metioned above also work with ~var~'s.

   - Scala strings are implemented by Java's ~String~ class.
     #+BEGIN_SRC scala
       // scala> val msg2: java.lang.String = "Hello again, world!"
       // msg2: String = Hello again, world!
     #+END_SRC

   -

** DONE Step 3. Define some functions - 68
   CLOSED: [2017-10-03 Tue 21:06]
   - Define some function:
     #+BEGIN_SRC scala
       // scala>
       def max(x: Int, y: Int): Int = {
         if (x > y) x
         else y
       }

       // max: (x: Int, y: Int) Int
     #+END_SRC

     =IMPORTANT= Scala compiler does NOT infer function parameter types, you must
     type them manually!!!

   - Figure 2.1 The basic form of a function definition in Scala.

   - The /result type/ is not always required to be explicitly typed.
     However, you must write it explicitly when you write a /recursive function/.

     Nevertheless, indicate function result types explicitly is usually a good
     idea.

   - The curly braces is only optional, when the defined function has a one
     statement/expression body.

   - Define a function of no parameter and only used for side effect.
     #+BEGIN_SRC scala
       scala> def greet() = println("Hello, world!")
       greet: ()Unit
     #+END_SRC

   - Scala's ~Unit~ type is similar to Java's ~void~ type;

     _in fact_, every ~void~ returning method in Java is mapped to a
     ~Unit~-returning method in Scala.

   - Quit the Scala REPL:
     use ~:quit~ or ~:q~ for short.

** DONE Step 4. Write some Scala scripts - 70
   CLOSED: [2017-10-03 Tue 21:12]
   - Type ~println("Hello, world, from a script!")~ into file =hello.scala=, and
     run it with ~$ scala hello.scala~

   - Similar script as the above, with command line argument(s).
     Type ~println("Hello, " + args(0) + "!")~ into file =helloarg.scala=, and
     run it with ~$ scala helloarg.scala planet~

   - ~//~ is the line comment characters of Scala.

   - ~/*~ and ~*/~ is the block comment characters of Scala.

** DONE Step 5. Loop with ~while~; decide with ~if~ - 71
   CLOSED: [2017-10-03 Tue 21:31]
   - block :: the code between the curly braces
              =From Jian= I think one statement/expression block with no curly
              braces is also exist. This definition is not rigorous.

   - The recommended indentation style for Scala: _TWO_ spaces.

   - Scala doesn't have ~i++~ and ~++i~.

** DONE Step 6. Iterate with ~foreach~ and ~for~ - 73
   CLOSED: [2017-10-03 Tue 21:45]
   - functional literal ::

   - Code that use ~foreach~ method to do the same thing as the code in the last
     section (use ~while~):
     #+BEGIN_SRC scala
       // pa.scala script
       args.foreach(arg => println(arg))
     #+END_SRC

     Run it with ~$ scala pa.scala Concise is nice~
     The output:
     #+BEGIN_SRC text
       Concise
       is
       nice
     #+END_SRC

   - =TODO= =IMPORTANT=
     If a function literal consists of one statement that takes a single
     argument, you need not explicitly name and specify the argument

     footnote:
     This shorthand, called a /partially applied function/, is described in
     Section 8.6.

     For example, ~args.foreach(println)~

   - The ~for~ in Scala (you won't see its full power until Section 7.3) =TODO=

   - footnote 11:
     You can say ="in"= for the ~<-~ symbol.
     You'd read ~for (arg <- args)~, therefore, as "for arg in args."

   - The ~arg~ in ~for (arg <- args)~ is ~val~, rather than ~var~.
     Two facts can prove this:
     + ~arg~ cannot be re-assigned inside the body of ~for~

     + actually, in ~(arg <- args)~ for each element of ~args~, a NEW ~arg~ will
       created and initialized to the element value.

       =From Jian= =TODO= I want to see the implementation of this.

** DONE Conclusion - 76
   CLOSED: [2017-10-03 Tue 21:46]

* DONE 3 Next Steps in Scala - 77
  CLOSED: [2017-10-05 Thu 05:16]
** DONE Step 7. Parameterize arrays with types - 77
   CLOSED: [2017-10-07 Sat 17:05]
   - parameterize :: Use values and/or types to "configure" an instance when use
                     ~new~ to construct (instantiate) it.

   - The type parameterization portion forms part of the type of the instance.
     The value parameterization portion doesn't.

   - The syntax ~0 to 2~ is implicitly transformed into the method call
     ~(0).to(2)~. However, this syntax only works if you explicitly specify the
     /receiver/ of the method call.

   - =IMPORTANT=
     Scala doesn't technically have /operator overloading/ (like Java),
     because it doesn't actually have operators in the traditional sense --
     instead, characters such as ~+~, ~-~, ~*~, and ~/~ can be used in method
     names.

     In Scala, their is no concept "operators" on describeing operations, only
     /methods/ (there is a concept /operators/, which is a kind of Scala's
     /identifiers/).

     Scala supports /method overloading/ just like Java, and the
     /method overloading/ of Scala includes overloading methods with names that is
     usually considered as /operator/ in the other languages.

   - Q: Why arrays are accessed with parentheses in Scala?

     A: Scala has fewer special cases than Java.

     For example,
     1. ~greetStrings(i)~ gets transformed into ~greetStrings.apply(i)~.

     2. ~greetStrings(0) = "Hello"~ gets transformed into
        ~greetStrings.update(0, "Hello")~

   - Moreover, this uniformity does NOT incur a significant performance cost.

** DONE Step 8. Use lists - 81
   CLOSED: [2017-10-04 Wed 22:31]
   - Applying functional philosophy to the world of objects means making objects
     immutable.

   - Scala ~Array~ is mutable.

     Scala ~List~ is immutable, and it is designed to enable a functional style
     of programming.

     Java ~List~ is mutable.

   - List concatenation: ~List(1, 2) ::: List(3, 4)~

   - =TODO= Why not append to lists?
     + Chapter 24, ~:+~

     + Build a list efficiently by appending elements:
       * prepend them and when you're done call ~reverse~.
       * Use ~ListBuffer~ which has an append operation, and then ~toList~

   - Useful methods of ~List~
     + ~aList.count(s \equal{}> s.length == 4)~
     + ~aList.drop(2)~
     + ~aList.dropRight(2)~
     + ~aList.exists(s \equal{}> s == "until")~
     + ~aList.forall(s \equal{}> s.endsWith("1"))~
     + ~aList.init~: all but the last element
     + ~aList.isEmpty~
     + ~aList.mkString(",")~

** DONE Step 9. Use tuples - 86
   CLOSED: [2017-10-04 Wed 22:41]
   - Example
     #+BEGIN_SRC scala
       val pair: Tuple2[Int, String] = (99, "Luftballons")
       println(pair._1)
       println(pair._2)
     #+END_SRC

   - footnote:
     Although conceptually you could create tuples of any length,
     currently the Scala library only defines them up to ~Tuple22~.

   - Accessing the elements of a tuple
     + Q: Why use ~pair._1~ rather ~pair(0)~?
       A: Because we can't implement it with the ~apply~ method -- different
          ~_N~ return different type value.

     + ~_N~ numbers are _one-based_, instead of _zero-based_.

       This is a tradition set by other languages with statically typed tuples,
       such as Haskell and ML.

** DONE Step 10. Use sets and maps - 87
   CLOSED: [2017-10-05 Thu 04:59]
   - Figure 3.2 Class hierarchy for Scala sets.
                          ~scala.collection.Set~
                               <<trait>>
                                  /|\
                      _____________|___________________
                      |                                |
       ~scala.collection.immutable.Set~    ~scala.collection.mutable.Set~
                  <<trait>>                        <<trait>>
                      |                                |
    ~scala.collection.immutable.HashSet~    ~scala.collection.mutable.HashSet~

   - When use ~+~, both mutable and immutable sets will return new sets.

   - Mutable sets offers ~+=~

   - Figure 3.3 Class hierarchy for Scala maps.
                          ~scala.collection.Map~
                               <<trait>>
                                  /|\
                      _____________|___________________
                      |                                |
       ~scala.collection.immutable.Map~    ~scala.collection.mutable.Map~
                  <<trait>>                        <<trait>>
                      |                                |
    ~scala.collection.immutable.HashMap~    ~scala.collection.mutable.HashMap~

** DONE Step 11. Learn to recognize the functional style - 92
   CLOSED: [2017-10-05 Thu 05:06]
** DONE Step 12. Read lines from a file - 95
   CLOSED: [2017-10-05 Thu 05:16]
   - Version 1
     #+BEGIN_SRC scala
       import scala.io.Source

       if (args.length > 0) {
         for (line <- Source.fromFile(args(0)).getLines())
           println(line.length + " " + line)
       }
       else
         Console.err.println("Please enter filename")
     #+END_SRC
     + the ~fromFile~ method returns a ~Source~ object.

     + the ~getLines~ method returns an ~Iterator[String]~.

   - Version 2 (better format)
     #+BEGIN_SRC scala
       import scala.io.Source

       def widthOfLength(s: String) = s.length.toString.length

       if (args.length > 0) {
         val lines = Source.fromFile(args(0)).getLines().toList

         val longestLine = lines.reduceLeft(
           (a, b) => if (a.length > b.length) a else b
         )
         val maxWidth = widthOfLength(longestLine)

         for (line <lines) {
           val numSpaces = maxWidth widthOfLength(line)
           val padding = " " * numSpaces
           println(padding + line.length + " | " + line)
         }
       }
       else
         Console.err.println("Please enter filename")
     #+END_SRC

** DONE Conclusion - 98
   CLOSED: [2017-10-05 Thu 05:16]
   - x

* DONE 4 Classes and Objects - 99
  CLOSED: [2017-10-02 Mon 22:31]
** DONE 4.1 Classes, fields, and methods - 99
   CLOSED: [2017-10-02 Mon 21:15]
   - members :: /fields/ and /methods/

   - /Fields/ are also known as /instance variables/,
     because every instance gets its own set of the variables.

   - ~private~ fields can ONLY be accessed by methods defined in the same class,
     all the code that can update the state will be localized to the class.

   - /Public/ is Scala's default access level. No ~public~ keyword.

   - Method parameters in Scala is that they are ~val~'s,

   - A good manner of coding:
     11:w:wExplicitly provide the result types of public methods.

   - /procedure/ :: A method that is executed only for its side effects.
                    Its type is ~Unit~.

** DONE 4.2 Semicolon inference - 104
   CLOSED: [2017-10-02 Mon 21:15]
   _The rules of semicolon inference_
   The precise rules for statement separation are surprisingly simple for
   how well they work. In short, a line ending is treated as a semicolon
   unless one of the following conditions is true:

   1. The line in question ends in a word that would not be legal as the end of a
      statement, such as a period or an infix operator.

   2. The next line begins with a word that cannot start a statement.

   3. The line ends while inside parentheses (...) or brackets [...], because
      these cannot contain multiple statements anyway.

** DONE 4.3 Singleton objects - 105
   CLOSED: [2017-10-02 Mon 22:31]
   - Classes in Scala cannot have static members -- one reason why we say Scala
     is more OO than Java.

   - singleton objects ::

   - The syntax used to define a /singleton object/ looks like a /class/
     definition, except replace the keyword ~class~ with ~object~.

   - companion object :: a /singleton object/ that shares the same name with a
        class (the /companion class/ of this /singleton object/).

   - One /companion class/ and its /companion object/ must be defined in the
     _SAME_ source file.

   - A class and its companion object can access each other's _private_ members.

   - (from footnote) ~new~ is used to instantiate classes.
     ~new~ does not have any relation with /singleton objects/.

     To be concrete:
     Suppose we have class ~A~ and its companion object ~A~. All the ~A~'s in the
     ~new A~ expression is the ~A~ _class_.

   - Defining a singleton object doesn't define a type (at the Scala level of
     abstraction) -- you can't make a value of it, unless its /companion class/
     is also given.

   - However, /singleton objects/ extend a superclass and can mix in traits.

     Given each /singleton object/ is an instance of its superclasses and
     mixed-in traits, you can
     + invoke its methods via these types,
     + refer to it from variables of these types,
     + pass it to methods expecting these types.

     =TODO=
     We’ll show some examples of singleton objects inheriting from classes and
     traits in Chapter 13

   - One difference between /classes/ and /singleton objects/:
     + /singleton objects/ CANNOT take parameters
     + /classes/ can.

     Because you can't instantiate a /singleton object/ with the ~new~ keyword,
     you have no way to pass parameters to it.

   - Each /singleton object/ is implemented as an instance of a /synthetic class/
     referenced from a static variable, so they have the same initialization
     semantics as Java statics.

     In particular, a singleton object is initialized the first time some code
     accesses it.

     =TODO=

   - standalone object :: A /singleton object/ that does NOT share the same name
        with a /companion class/.

   - The usage of /standalone object/:
     + collect related utility methods togethe
     + define an entry point to a Scala application (See next section =TODO=)
     + ......

** DONE 4.4 A Scala application - 108
   CLOSED: [2017-10-02 Mon 22:25]
   - To run a Scala program, you _MUST_ supply the name of a /standalone
     singleton object/ with a ~main~ method (you can freely name the ONLY
     parameter):
     #+BEGIN_SRC scala
       def main(args: Array[String]): Unit = {
         // ...
       }
     #+END_SRC

   - ANY /standalone object/ with a ~main~ method of the proper signature
     can be used as the /entry point/ into an application.

   - Example:
     #+BEGIN_SRC scala
       // In file Summer.scala
       import ChecksumAccumulator.calculate

       object Summer {
         def main(args: Array[String]) = {
           for (arg <args)
             println(arg + ": " + calculate(arg))
         }
       }
     #+END_SRC
     + The ~import~ line:
       You can think this ~import~ as similar to the /static import/ feature
       introduced in Java 5.
         One difference in Scala is that you can import members from any object.
       not just /singleton objects/

     + static import :: allow /members/ defined in a class as ~public static~ to
                        be used in Java code; _WITHOUT_ specifying the class in
                        which the /members/ are defined.

   - Scala _implicitly_ imports members of packages
     + ~java.lang~
     + ~scala~
     + ~Predef~ (in ~scala~)

   - In Scala, you can name =.scala= files anything you want, no matter what
     Scala classes or code you put in them.

     However, in general in the case of non-scripts, the Java way (name the
     =.java= file with the name of the class inside it) is recommended.

   - For the application of this section, we can compile with a command:
     ~$ scalac ChecksumAccumulator.scala Summer.scala~

     This compiles your source files, but there may be a perceptible delay
     before the compilation finishes. The reason is that every time the compiler
     starts up, it spends time scanning the contents of jar files and doing
     other initial work before it even looks at the fresh source files you
     submit to it.

     For this reason, the Scala distribution also includes a Scala compiler
     daemon called ~fsc~ (fast Scala compiler):
     ~$ fsc ChecksumAccumulator.scala Summer.scala~

   - The first time you run ~fsc~, it will create a local server daemon attached
     to a port on your computer. It will then send the list of files to compile
     to the daemon via the port, and the daemon will compile the files.
       The next time you run ~fsc~, the daemon will already be running, so ~fsc~
     will simply send the file list to the daemon, which will immediately
     compile the files.

     Using ~fsc~, you only need to wait for the Java runtime to startup the first
     time.

     If you ever want to stop the ~fsc~ daemon, you can do so with
     ~$ fsc -shutdown~.

   - After compilation, run it with two arguments:
     ~$ scala Summer of love~

** DONE 4.5 The ~App~ trait - 110
   CLOSED: [2017-10-02 Mon 22:31]
   #+BEGIN_SRC scala
     import ChecksumAccumulator.calculate

     object FallWinterSpringSummer extends App {
       for (season <- List("fall", "winter", "spring"))
         println(season + ": " + calculate(season))
     }
   #+END_SRC
   + No need to write the ~main~ function.
     =TODO= =??? WHY=

   + The object which extends ~App~ can access command-line arguments through
     the array of string ~args~.

** DONE 4.6 Conclusion - 111
   CLOSED: [2017-10-02 Mon 22:31]

* DONE 5 Basic Types and Operations - 112
  CLOSED: [2017-10-20 Fri 21:54]
** DONE 5.1 Some basic types - 112
   CLOSED: [2019-07-25 Thu 01:41]
   - Table 5.1 Some basic types
     | Basic type | Range                                                               |
     |------------+---------------------------------------------------------------------|
     | Byte       | 8-bit signed two's complement integer (-2^7 to 2^7 - 1, inclusive)    |
     | Short      | 16-bit signed two's complement integer (-2^15 to 2^15 - 1, inclusive) |
     | Int        | 32-bit signed two's complement integer (-2^31 to 2^31 - 1, inclusive) |
     | Long       | 64-bit signed two's complement integer (-2^63 to 2^63 - 1, inclusive) |
     | Char       | 16-bit unsigned Unicode character (0 to 2^16 - 1, inclusive)         |
     | String     | a sequence of Chars                                                 |
     | Float      | 32-bit IEEE 754 single-precision float                              |
     | Double     | 64-bit IEEE 754 double-precision float                              |
     | Boolean    | true or false                                                       |

     + Other than ~String~, which resides in package ~java.lang~, all the other
       types shown in Table 5.1 are members of package ~scala~.

   - ~Byte~, ~Short~, ~Int~, ~Long~, and ~Char~ are called /integral types/.

   - The /integral types/ plust ~Float~ and ~Double~ are called /numerical types/.

   - /Scala's basic types/ have the _exact same ranges_ as the corresponding types
     in Java.

     This enables the Scala compiler to transform instances of Scala
     /value types/, such as ~Int~ or ~Double~, down to Java /primitive types/ in
     the bytecodes it produces.

** DONE 5.2 Literals - 113
   CLOSED: [2017-10-12 Thu 03:16]
   - literal :: a way to write a constant value directly in code.

   - Scala does NOT support octal literals;
     integer literals that start with a 0, such as 031, do NOT compile.

*** DONE Integer literals
    CLOSED: [2017-10-05 Thu 13:20]
    - Integer literals :: for the types ~Int~, ~Long~, ~Short~, and ~Byte~ come
         in two forms:
      + decimal
      + hexadecimal - begin with ~0x~ or ~0X~

    - If an /integer literal/ ends in an ~L~ or ~l~, it is a ~Long~; otherwise it
      is an ~Int~.

    - NO suffix symbol for the literals of ~Short~ or ~Byte~.
      You must type them manually.
      #+BEGIN_SRC scala
        val little: Short = 367
        val littler: Byte = 38
      #+END_SRC

*** DONE Floating point literals
    CLOSED: [2017-10-05 Thu 20:22]
    - OPTIONALLY containing a decimal point.

    - OPTIONALLY followed by an ~E~ or ~e~ and an exponent.

    - Example
      #+BEGIN_SRC scala
        val big = 1.2345
        // big: Double = 1.2345

        val bigger = 1.2345e1
        // bigger: Double = 12.345

        val biggerStill = 1.23E45
        // biggerStill: Double = 1.23E47
      #+END_SRC

    - Suffixes for ~Float~ literal: ~F~ or ~f~

    - Suffixes for ~Double~ literal: ~D~ or ~d~

*** DONE Character literals
    CLOSED: [2017-10-05 Thu 20:22]
    - Example
      #+BEGIN_SRC scala
        val a = 'A'
        // a: Char = A

        val d = '\u0041'
        // d: Char = A
      #+END_SRC

    - In fact, Unicode characters can appear anywhere in a Scala program.
      #+BEGIN_SRC scala
        val B\u0041\u0044 = 1
        // BAD: Int = 1
      #+END_SRC

      This is not recommended.

    - Table 5.2 Special character literal escape sequences
      | Literal | Meaning                  |
      | ~\n~      | line feed (\u000A)       |
      | ~\b~      | backspace (\u0008)       |
      | ~\t~      | tab (\u0009)             |
      | ~\f~      | form feed (\u000C)       |
      | ~\r~      | carriage return (\u000D) |
      | ~\"~      | double quote (\u0022)    |
      | ~\'~      | single quote (\u0027)    |
      | ~\\~      | backslash (\u005C)       |

    - DB class
      2**(N/B) * ([log2 (N/B)] + 1)

*** DONE String literals
    CLOSED: [2017-10-05 Thu 20:28]
    - string literal :: characters surrounded by double quotes.

    - raw string :: characters surrounded by triple double quotes.

    - You can include anything except triple double quotes inside a /raw string/.
      #+BEGIN_SRC scala
        println("""Welcome to Ultamix 3000.
                   Type "HELP" for help.""")

        // Welcome to Ultamix 3000.
        //            Type "HELP" for help.
      #+END_SRC

    - Get rid of the leading spaces in the example above:
      #+BEGIN_SRC scala
        println("""|Welcome to Ultamix 3000.
                   |Type "HELP" for help.""".stripMargin)

        // Welcome to Ultamix 3000.
        // Type "HELP" for help.
      #+END_SRC

*** DONE Symbol literals
    CLOSED: [2017-10-12 Thu 03:16]
    - symbol literal :: Be written in the pattern of ~'symbolLiteral~, where the
                        sequence after the single quote ~'~ can be any
                        alphanumeric identifier.

    - Symbol literals are mapped to instances of the predefined class
      ~scala.Symbol~. Specifically, the literal ~'symbol~ will be expanded by the
      compiler to a factory method invocation: ~Symbol("symbol")~

    - Application scenario:
      where you would use just an identifier in a dynamically typed language.
      =TODO=

      - There is NOT MUCH you can do with a symbol, except find out its name:
        #+BEGIN_SRC scala
          val s = 'aSymbol
          // 'aSymbol

          val nm = s.name
          // aSymbol     //// a string
        #+END_SRC

      - Noteworthy:
        /symbols/ are /interned/.
        No matter how many times you write down a symbol literals, if they have
        the same sequence after ~'~, they are identical.

*** DONE Boolean literals
    CLOSED: [2017-10-05 Thu 13:36]
** DONE 5.3 String interpolation - 119
   CLOSED: [2017-10-06 Fri 01:45]
   - Example:
     #+BEGIN_SRC scala
       val name = "reader"
       println(s"Hello, $name!")
     #+END_SRC
     + The ~s"Hello, $name!"~ is a processed string literal.

     + The /s interpolator/ will
       1. evaluate each embedded expression
       2. invoke ~toString~ on each result
       3. replace the embedded expressions in the literal with those results

     + Here ~"Hello, reader!"~ is the same result as ~"Hello, " + name + "!"~.

   - In /string literals/, after the ~$~, Scala will interpret all characters up
     to the first non-identifier character as the expression.

     _If the expression includes nonidentifier characters, you must place it in
     curly braces_
     #+BEGIN_SRC scala
       s"The answer is ${6 * 7}."
       // The answer is 42.
     #+END_SRC

   - Two other /string interpolators/ provided by Scala:
     + ~raw~,
       which is like ~s~, except it does NOT recognize /character literal escape
       sequences/.
       #+BEGIN_SRC scala
         "No\\\\escape!"
         // No\\\\escape!
       #+END_SRC

     + ~f~, which allows you to attach printf-style formatting instructions to
       embedded expressions. It use the syntax specified by ~java.util.Formatter~.
       #+BEGIN_SRC scala
         f"${math.Pi}%.5f"
         // 3.14159
       #+END_SRC
       * if no formatting instruction, the ~f string interpolator~ will default
         to ~%s~.

   - In Scala, /string interpolation/ is implemented by rewriting code at compile
     time.

     The compiler will treat any expression consisting of an identifier followed
     immediately by the open double quote of a string literal as a string
     interpolator expression. (=From Jian= Here is also a definition to
     /string interpolation/)

     The ~s~, ~f~, and ~raw~ /string interpolators/ are implemented via this
     general mechanism.

     _Libraries and users can define other string interpolators for other purposes._

** DONE 5.4 Operators are methods - 121
   CLOSED: [2017-10-06 Fri 02:58]
   Scala provides a rich set of operators for its basic types.
   These operators are actually just a nice syntax for ordinary method calls.

   - For example,
     + ~1 + 2~ is actually ~1.+(2)~.
       In fact, ~Int~ contains several /overloaded/ ~+~ methods that take
       different parameter types.

     + ~s~ is a ~String~.
       ~s.indexOf('o')~ can be written as ~s indexOf 'o'~,
       ~s.indexOf('o', 5)~ can be written as ~s indexOf ('o', 5)~

     + ~7.toLong~ can be written as ~7 toLong~

     + ~(2.0).unary_-~ is usually written as ~-0.2~

   - In Scala operators are not special language syntax; any method can be an
     operator.

   - The _ONLY_ identifiers that can be used as /prefix operators/ are ~+~, ~-~,
     ~!~, and ~~~.

     This is why when you see, for example, ~p.unary_*~, you cannot write it as
     ~*p~. It ought to be written as ~*.p~

   - Convetions for no parameter methods:
     + always have ~()~ when a method is used for side effect.
     + call a method without taking ~()~ when no side effect.

** DONE 5.5 Arithmetic operations - 124
   CLOSED: [2017-10-06 Fri 02:00]
   - Example:
     #+BEGIN_SRC scala
       'b' - 'a'
       // 1

       11.0 % 4.0
       // 3.0
     #+END_SRC

   - =TODO= =RE-READ=
     The floating-point remainder you get with ~%~ is NOT the one defined by the
     IEEE 754 standard.

     The IEEE 754 remainder uses rounding division, not truncating division, in
     calculating the remainder, so it is quite different from the integer
     remainder operation.

     If you really want an IEEE 754 remainder, you can call ~IEEEremainder~ on
     ~scala.math~, as in:
     #+BEGIN_SRC scala
       math.IEEEremainder(11.0, 4.0)
       // -1.0
     #+END_SRC

   - The numeric types also offer unary prefix operators ~+~ (method ~unary_+~)
     and ~-~ (method ~unary_-~), which allow you to indicate whether a literal
     number is positive or negative, as in ~-3~ or ~+4.0~.
     #+BEGIN_SRC scala
       val neg = 1 + -3
       // -2

       val y = +3
       // 3

       -neg
       // 2
     #+END_SRC
     unary ~+~ exists solely for symmetry with unary ~-~, but has NO effect.

** DONE 5.6 Relational and logical operations - 125
   CLOSED: [2017-10-06 Fri 02:04]
   - short-circuit /logic and/ and /logic or/ (as in Java):
     + ~&&~
     + ~||~

   - non-short-circuit /logic and/ and /logic or/:
     + ~&~
     + ~|~

** DONE 5.7 Bitwise operations - 127
   CLOSED: [2017-10-06 Fri 02:09]
   - bitwise-and (~&~), bitwise-or (~|~), and bitwise-xor (~^~).

   - unary bitwise complement operator: ~~~, the method ~unary_~~

   - shift left (~<<~)
     shift righ (~>>~)
     unsigned shift righ (~>>>~)

** DONE 5.8 Object equality - 128
   CLOSED: [2017-10-06 Fri 02:18]
   - Use ~==~ and ~!=~

     You can even use them to compare against ~null~.
     NO exception will be throw, even if it seems ~null~ is the receiver.
     #+BEGIN_SRC scala
       List(1, 2, 3) == null
       // false


       null == List(1, 2, 3)
       // false
     #+END_SRC

     In the backgound, ~==~ first do ~null~ check to the receiver, and then call
     the ~equals~ method with the right hand side value.

   - =IMPORTANT=
     How Scala's ~==~ differs from Java's
     + Java's ~==~ do /value equality/ check for primitive type values.
       Java's ~==~ do /reference equality/ check for objects.

     + Scala's ~==~ is always used to do /value equality/ check.
       Scala's ~==~ use ~eq~ and ~ne~ to do /reference equality/ check.

       =TODO= Section 11.1 and 11.2

** DONE 5.9 Operator precedence and associativity - 130
   CLOSED: [2017-10-20 Fri 21:50]
   - Given that Scala doesn't have operators, per se, just a way to use methods
     in operator notation.

   - _Scala decides precedence based on the first character of the methods used in
     operator notation_ (there’s one exception to this rule) =TODO=

   - Table 5.3 Operator precedence =IMPORTANT=
     | (all other special characters) |
     | * / %                          |
     | + -                            |
     | :                              |
     | \equal{} !                            |
     | < >                            |
     | &                              |
     | ^                              |
     | \vert{}                              |
     | (all letters)                  |
     | (all assignment operators)     |

   - ONE EXCEPTION: /assignment operators/, which end in an equals character:
     If an operator ends in an equals character (~=~), and the operator is NOT
     one of the comparison operators ~<=~, ~>=~, ~==~, or ~!=~, then the
     precedence of the operator is the same as that of simple assignment (~=~).

   - The /associativity/ of an operator in Scala is determined by its
     _LAST character_.

   - NO MATTER what /associativity/ an operator has, however, its operands are
     _always evaluated left to right_.

   - If ~a~ is an expression that is _NOT_ just a simple reference to an
     immutable value, then ~a ::: b~ is more precisely treated as the following
     block: ~{ val x = a; b.:::(x) }~

   - This /associativity/ rule also plays a role when multiple operators of the
     _SAME precedence_ appear side by side.

     If the methods _end in_ ~:~, they are _grouped right to left_;
     otherwise, they are _grouped left to right_.
       For example, ~a ::: b ::: c~ is treated as ~a ::: (b ::: c)~.
     But ~a * b * c~, by contrast, is treated as ~(a * b) * c~.

** DONE 5.10 Rich wrappers - 133
   CLOSED: [2017-10-06 Fri 03:02]
   In Scala, you can call many more methods on its basic types than in Java.
   The reasons are:
   1. Scala defines "rich wrapper" classes for these types.

   2. Scala uses /implicit conversions/, and convert Java basic types to its
      class with "rich wrapper". Then more methods can be used.
      =TODO= /implicit conversions/ - Chapter 21

** DONE 5.11 Conclusion - 133
   CLOSED: [2017-10-20 Fri 21:54]
   =TODO=

* DONE 6 Functional Objects - 135
  CLOSED: [2017-10-07 Sat 17:49]
** DONE 6.1 A specification for class ~Rational~ - 135
   CLOSED: [2017-10-07 Sat 16:12]
   - At the end of this chapter you'll be able to do this with class ~Rational~:
     #+BEGIN_SRC scala
       val oneHalf = new Rational(1, 2)
       // onehalf: Rational = 1/2

       val twoThirds = new Rational(2, 3)
       // twoThirds: Rational = 2/3

       (oneHalf / 7) + (1 - twoThirds)
       // res0: Rational = 17/42
     #+END_SRC

** DONE 6.2 Constructing a ~Rational~ - 136
   CLOSED: [2017-10-07 Sat 16:12]
   - The Scala compiler will compile any code you place in the class body, which
     isn't part of a field or a method definition, into the primary constructor.
     #+BEGIN_SRC scala
       class Rational(n: Int, d: Int) {
         println("Created " + n + "/" + d)
       }

       new Rational(1, 2)
       // print out // Created 1/2
       // Rational@2591e0c9
     #+END_SRC

** DONE 6.3 Reimplementing the ~toString~ method - 138
   CLOSED: [2017-10-07 Sat 16:12]
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) {
       override def toString = n + "/" + d
     }
   #+END_SRC

** DONE 6.4 Checking preconditions - 139
   CLOSED: [2017-10-07 Sat 16:14]
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       override def toString = n + "/" + d
     }
   #+END_SRC
   - If ~d != 0~ is ~false~, an ~IllegalArgumentException~ will be thrown out.

** DONE 6.5 Adding fields - 139
   CLOSED: [2017-10-07 Sat 16:22]
   - The code before this section doesn't make the passed in ~n~ and ~d~ be
     fields.
     #+BEGIN_SRC scala
       // This will NOT compile
       class Rational(n: Int, d: Int) {
         require(d != 0)

         override def toString = n + "/" + d

         def add(that: Rational): Rational =
           new Rational(n * that.d + that.n * d, d * that.d)
       }

       // When compile
       // <console>:11: error: value d is not a member of Rational
       //            new Rational(n * that.d + that.n * d, d * that.d)
       //                                  ˆ
       // <console>:11: error: value d is not a member of Rational
       //            new Rational(n * that.d + that.n * d, d * that.d)
       //                                                           ˆ
     #+END_SRC

   - To create two fields for a ~Rational~ class:
     #+BEGIN_SRC scala
       class Rational(n: Int, d: Int) {
         require(d != 0)
         val numer: Int = n
         val denom: Int = d

         override def toString = numer + "/" + denom

         def add(that: Rational): Rational =
           new Rational(
             numer * that.denom + that.numer * denom,
             denom * that.denom
           )
       }
     #+END_SRC
     =TODO= In Section 10.6 you'll find out about /parametric fields/, which
     provide a shorthand for writing the same code.

** DONE 6.6 Self references - 141
   CLOSED: [2017-10-07 Sat 16:24]
   ~this~
** DONE 6.7 Auxiliary constructors - 142
   CLOSED: [2017-10-07 Sat 16:33]
   - auxiliary constructors :: constructors other than the primary constructor.

   - /Auxiliary constructors/ in Scala start with ~def this(...).~

   - Example
     #+BEGIN_SRC scala
       class Rational(n: Int, d: Int) {
         require(d != 0)
         val numer: Int = n
         val denom: Int = d

         def this(n: Int) = this(n, 1) // auxiliary constructor

         override def toString = numer + "/" + denom

         def add(that: Rational): Rational =
           new Rational(
             numer * that.denom + that.numer * denom,
             denom * that.denom
           )
       }
     #+END_SRC

   - In Scala, _EVERY_ /auxiliary constructor/ _MUST_ invoke another constructor
     of the same class _as its FIRST action_.
       In other words, the first statement in every /auxiliary constructor/ in
     every Scala class will have the form ~this(...)~.

     The net effect of this rule is that _EVERY_ constructor invocation in Scala
     will _end up eventually_ calling the /primary constructor/ of the class.

     The /primary constructor/ is thus _the single point of entry_ of a class.

   - The rule about constructor for Scala is more restrictive than Java's:
     + In Java, a constructor must either invoke another constructor of the same
       class, or directly invoke a constructor of the superclass, as its first
       action.

     + In Scala, ONLY the /primary constructor/ can invoke a superclass
       constructor.

** DONE 6.8 Private fields and methods - 144
   CLOSED: [2017-10-07 Sat 16:37]
   - Normalize a fraction to its equivalent reduced form (e.g. 66/42 -> 11/7):
     #+BEGIN_SRC scala
       class Rational(n: Int, d: Int) {
         require(d != 0)
         private val g = gcd(n.abs, d.abs)
         val numer = n / g
         val denom = d / g

         def this(n: Int) = this(n, 1)

         def add(that: Rational): Rational =
           new Rational(
             numer * that.denom + that.numer * denom,
             denom * that.denom
           )

         override def toString = numer + "/" + denom

         private def gcd(a: Int, b: Int): Int =
           if (b == 0) a else gcd(b, a % b)
       }
     #+END_SRC
     + Use ~g~ to modify the /initializers/.

** DONE 6.9 Defining operators - 145
   CLOSED: [2017-10-07 Sat 16:46]
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) {
       require(d != 0)

       private val g = gcd(n.abs, d.abs)
       val numer = n / g
       val denom = d / g

       def this(n: Int) = this(n, 1)

       def + (that: Rational): Rational =
         new Rational(
           numer * that.denom + that.numer * denom,
           denom * that.denom
         )

       def * (that: Rational): Rational =
         new Rational(numer * that.numer, denom * that.denom)

       override def toString = numer + "/" + denom

       private def gcd(a: Int, b: Int): Int =
         if (b == 0) a else gcd(b, a % b)
     }


     val x = new Rational(1, 2)
     val y = new Rational(2, 3)

     // About the precedence
     x + x + y
     // 5/6

     (x + x) * y
     // 2/3

     x + (x * y)
     // 5/6
   #+END_SRC

   - Read Section 5.9 for more about the /operator precedence/ topic.
     =TOOD=

** DONE 6.10 Identifiers in Scala - 147
   CLOSED: [2017-10-07 Sat 17:39]
   - alphanumeric identifier :: its definition is like the /identifier/ defintion
        of the C language.

        Only one difference, you can use ~$~ as a letter.
        _However_, ~$~ is used by the compiler. Programmers shouldn't create
        identifiers with ~$~ inside, which might lead to name clashes with
        identifiers generated by the Scala compiler. Though this will never
        affect the process of compilation, it will affect the correctness of the
        result of compilation.

   - Camel-case names of /fields/, /method parameters/, /local variables/, and
     /functions/ should start with a _lower case_ letter;

     Camel-case names of /classes/ and /traits/ should start with an _UPPER case_
     letter.

   - You shouldn't use _trailing underscore identifiers_, for some reason
     (=TODO=) ~val name_: Int = 1~ will trigger an compilation error, and the
     compiler thinks you create a name ~name_:~, rather than ~name_~.

     In this case, if you still want to create a ~name_~ name, you must add a
     space before ~:~.

   - ~val~'s remain constant after it is initialized, it is still a variable.
     For example, method parameters are used as ~val~ (though not write ~val~
     explicitly), the change everytime you call this method.

     A constant is more permanent. The naming convention of constant in Scala is
     the same as class names.

     Comparison between Java and Scala constant names convetion:
     + Java - ~X_OFFSET~

     + Scala - ~XOffset~

   - operator characters :: printable ASCII characters such as +, :, ?, ~ or #.

        =TODO= =Re-Read=
        Footnote 7: More precisely, an operator character belongs to the Unicode
        set of mathematical symbols(Sm) or other symbols(So), or to the 7-bit
        ASCII characters that are not letters, digits, parentheses, square
        brackets, curly braces, single or double quote, or an underscore,
        period, semi-colon, comma, or back tick character.

   - operator identifier :: it consists of one or more operator characters.

   - The Scala compiler will internally "mangle" /operator identifiers/ to turn
     them into legal Java identifiers with embedded ~$~ characters.

     For instance, the identifier ~:->~ would be represented internally as
     ~$colon$minus$greater~.

     If you ever wanted to access this identifier from Java code, you'd need to
     use this internal representation.

   - Because operator identifiers in Scala can become arbitrarily long, there is
     a small difference between Java and Scala. =TODO= =WHY=

     In Java, the input ~x<-y~ would be parsed as _four_ lexical symbols, so it
     would be equivalent to ~x < - y~.

     In Scala, ~<-~ would be parsed as a single identifier, giving ~x <- y~.

     If you want the first interpretation, you need to separate the ~<~ and ~-~
     the characters by a space.

     NOT a problem in practice.
     =TODO=

   - mixed identifier :: consists of an /alphanumeric identifier/, which is
        followed by an _underscore_ and an /operator identifier/.

        =TODO= MUST be an underscore and an operator indentifier ???????

     For example,
     + ~unary_+~
     + ~myvar_=~

     In addition, the /mixed identifier/ form ~myvar_=~ is generated by the Scala
     compiler to support /properties/ (more on that in Chapter 18).
     =TOOD=

   - literal identifier :: an ARBITRARY string enclosed in _back ticks_.
        For instance, ~`x`~, ~`<clinit>`~, ~`yield`~

     A typical use case is accessing the static ~yield~ method in Java's ~Thread~
     class. You cannot write ~Thread.yield()~ in Scala because ~yield~ is a
     /reserved word/ in Scala. However, you can still name the method in back
     ticks, e.g., ~Thread.`yield`()~.

** DONE 6.11 Method overloading - 150
   CLOSED: [2017-10-07 Sat 16:56]
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) {
       require(d != 0)

       private val g = gcd(n.abs, d.abs)
       val numer = n / g
       val denom = d / g

       def this(n: Int) = this(n, 1)

       def + (that: Rational): Rational =
         new Rational(
           numer * that.denom + that.numer * denom,
           denom * that.denom
         )

       def + (i: Int): Rational =
         new Rational(numer + i * denom, denom)

       def - (that: Rational): Rational =
         new Rational(
           numer * that.denom - that.numer * denom,
           denom * that.denom
         )

       def - (i: Int): Rational =
         new Rational(numer - i * denom, denom)

       def * (that: Rational): Rational =
         new Rational(numer * that.numer, denom * that.denom)

       def * (i: Int): Rational =
         new Rational(numer * i, denom)

       def / (that: Rational): Rational =
         new Rational(numer * that.denom, denom * that.numer)

       def / (i: Int): Rational =
         new Rational(numer, denom * i)

       override def toString = numer + "/" + denom

       private def gcd(a: Int, b: Int): Int =
         if (b == 0) a else gcd(b, a % b)
   #+END_SRC
** DONE 6.12 Implicit conversions - 152
   CLOSED: [2017-10-07 Sat 17:49]
   After finishing the method overloading in section 6.11, you can do ~r * 2~,
   but you cannot do ~2 * r~, of which the /receiver/ ~2~ doesn't have a
   overloaded method ~*~ with parameter type ~Rational~.

   Solution: You can create an /implicit conversion/ that automatically converts
   integers to rational numbers when needed.
   #+BEGIN_SRC scala
     implicit def intToRational(x: Int) = new Rational(x)

     // The you can do:

     val r = new Rational(2, 3)
     2 * r
     // 4/3

   #+END_SRC
   - An /implicit conversion/ works only when it's in scope.

   - If you place this /implicit method/ definition inside class ~Rational~, it
     will _NOT_ be in scope in the interpreter.

** DONE 6.13 A word of caution - 153
   CLOSED: [2017-10-07 Sat 17:44]
** DONE 6.14 Conclusion - 153
   CLOSED: [2017-10-07 Sat 17:42]
   - _TODO_: Chapter 30 - override ~equals~ and ~hashcode~

   - _TODO_: Chapter 21 - place implicit method definitions in a companion object
     for ~Rational~ so they can be more easily placed into scope when client
     programmers are working with Rationals.

* DONE 7 Built-in Control Structures - 155
  CLOSED: [2017-10-21 Sat 12:02]
  Programmers can use these result values to simplify their code, just as they
  use return values of functions. Without this facility, the programmer must
  create temporary variables just to hold results that are calculated inside a
  control structure. Removing these temporary variables makes the code a little
  simpler, and it also prevents many bugs where you set the variable in one
  branch but forget to set it in another.

  =From Jian= In Java, if not use the API added by Java 8 and 9, we often need
  to set a object value ~null~.

** DONE 7.1 If expressions - 156
   CLOSED: [2017-10-09 Mon 02:23]
   - equational reasoning :: with /reference transparency/ and /substitution
        rule/, we can do /equational reasoning/.

   - Compare the imperative way and the functional way of using ~if~:
     #+BEGIN_SRC scala
       var filename_i = "default.txt"
       if (!args.isEmpty)
         filename_i = args(0)

       val filename =
         if (!args.isEmpty) args(0)
         else "default.txt"
     #+END_SRC

   - Two advantages:
     + Use ~val~
     + Support /equational reasoning/

** DONE 7.2 While loops - 157
   CLOSED: [2017-10-09 Mon 02:41]
   - ~while~ and ~do ... while~. The type of their results is ~Unit~.
     They are imperative.
     #+BEGIN_SRC scala
       def gcdLoop(x: Long, y: Long): Long = {
         var a = x
         var b = y
         while (a != 0) {
           val temp = a
           a = b % a
           b = temp
         }
       }

       var line = ""
       do {
         line = readLine()
         println("Read: " + line)
       } while (line != "")
     #+END_SRC

   - The functional way (no ~while~ / ~do ...while~, and use recursion):
     #+BEGIN_SRC scala
       def gcd(x: Long, y: Long): Long =
         if (y == 0) x else gcd(y, x % y)
     #+END_SRC

** DONE 7.3 For expressions - 160
   CLOSED: [2017-10-09 Mon 03:32]
   ~for~ is versatile
*** DONE Iteration through collections
    CLOSED: [2017-10-09 Mon 03:14]
    - Examples
      #+BEGIN_SRC scala
        val filesHere: Array[File] = (new java.io.File(".")).listFiles

        for (file <- filesHere)
          println(file)
      #+END_SRC
      + The ~file <- filesHere~ syntax is called /generator/.

      #+BEGIN_SRC scala
        for (i <- 1 to 4)
          println("Iteration " + i)
      #+END_SRC
      + Use range ~1 to 4~

      + Use range that exclusive ~1 until 4~

*** DONE Filtering
    CLOSED: [2017-10-09 Mon 03:14]
    - One filter:
      #+BEGIN_SRC scala
        for (file <- filesHere if file.getName.endsWith(".scala"))
          println(file)
      #+END_SRC

    - Multiple filters:
      #+BEGIN_SRC scala
        for (
          file <- filesHere
          if file.isFile
          if file.getName.endsWith(".scala")
        ) println(file)
      #+END_SRC

*** DONE Nested iteration
    CLOSED: [2017-10-09 Mon 03:19]
    #+BEGIN_SRC scala
      def fileLines(file: java.io.File) =
        scala.io.Source.fromFile(file).getLines().toList

      def grep(pattern: String) =
        for (
          file <- filesHere
          if file.getName.endsWith(".scala");
          line <- fileLines(file)
          if line.trim.matches(pattern)
        ) println(file + ": " + line.trim)

      grep(".*gcd.*")
    #+END_SRC
    Pay attentoin to the location of ~;~

*** DONE Mid-stream variable bindings
    CLOSED: [2017-10-09 Mon 03:25]
    #+BEGIN_SRC scala
      def grep(pattern: String) =
        for {
          file <- filesHere
          if file.getName.endsWith(".scala")
          line <- fileLines(file)
          trimmed = line.trim
          if trimmed.matches(pattern)
        } println(file + ": " + trimmed)

      grep(".*gcd.*")
    #+END_SRC

*** DONE Producing a new collection
    CLOSED: [2017-10-09 Mon 03:32]
    #+BEGIN_SRC scala
      def scalaFiles =
        for {
          file <- filesHere
          if file.getName.endsWith(".scala")
        } yield file
    #+END_SRC

    The output collection type is the same as the input collection type, for
    instance, ~Array~ in ~Array~ out, and ~List~ in ~List~ out.

** DONE 7.4 Exception handling with ~try~ expressions - 165
   CLOSED: [2017-10-09 Mon 04:04]
*** DONE Throwing exceptions
    CLOSED: [2017-10-09 Mon 03:39]
    - ~throw~ is an expression that has a result type.
      #+BEGIN_SRC scala
        val half =
          if (n % 2 == 0)
            n / 2
          else
            throw new RuntimeExpression("n must be even")
      #+END_SRC
      + Technically, an exception throw has type ~Nothing~.
      + You can use a ~throw~ as an expression even though it will _NEVER actual-
        ly evaluate to anything_. =TOOD=
      + Type ~Nothing~ is discussed further in Section 11.3. =TODO=

*** DONE Catching exceptions
    CLOSED: [2017-10-09 Mon 03:50]
    - Scala's ~catch~ always uses /pattern matching/.
      #+BEGIN_SRC scala
        import java.io.FileReader
        import java.io.FileNotFoundException
        import java.io.IOException

        try {
          val f = new FileReader("input.txt")
          // Use and close file
        } catch {
          case ex: FileNotFoundException => ??? // Handle missing file
          case ex: IOException => ??? // Handl other I/O error
        }
      #+END_SRC

    - _Note_
      One difference you'll quickly notice in Scala is that, _UNLIKE_ Java,
      Scala does _NOT_ require you to ~catch~ /checked exceptions/ or _declare_
      them in a ~throws~ (Scala doesn't have this) clause.

      You can declare a /throws clause/ if you wish with the ~@throws~
      annotation, but it is not required. See Section 31.2 for more information
      on ~@throws~. =TODO=

    - =From Jian= Need to know more about Java's /checked exceptions/.

*** DONE The ~finally~ clause
    CLOSED: [2017-10-09 Mon 03:55]
    #+BEGIN_SRC scala
      import java.io.FileReader

      val file = new FileReader("input.txt")
      try {
        // Use the file
      } finally {
        file.close()  // Be sure to close the file
      }
    #+END_SRC

    - *Note*
      Listing 7.12 shows the idiomatic way to ensure a non-memory resource, such
      as a file, socket, or database connection, is closed. First you acquire
      the resource. Then you start a try block in which you use the resource.
      Lastly, you close the resource in a finally block. This idiom is the same
      in Scala as in Java;

      =TODO=
      alternatively, in Scala you can employ a technique called the
      /loan pattern/ to achieve the same goal more concisely. The loan pattern
      will be described in Section 9.4.

*** DONE Yielding a value
    CLOSED: [2017-10-09 Mon 04:02]
    - If you're familiar with Java, it’s worth noting that Scala’s behavior differs
      from Java only because Java’s ~try-finally~ does not result in a value. As
      in Java, if a finally clause includes an explicit return statement, or
      throws an exception, that return value or exception will “overrule” any
      previous one that originated in the try block or one of its catch clauses.
      For example, given this, rather contrived, function definition:
      =See Java specification or the book Java Puzzler=
      + code
        #+BEGIN_SRC scala
          // Always return 2
          def f(): Int = try return 1 finally return 2

          // Always return 1
          def g(): Int = try 1 finally 2
        #+END_SRC

      You usually don't want to return value in ~finally~ block.

** DONE 7.5 Match expressions - 169
   CLOSED: [2017-10-09 Mon 04:07]
** DONE 7.6 Living without ~break~ and ~continue~ - 171
   CLOSED: [2017-10-21 Sat 11:38]
   - The simplest and most straightfoward approach is to replace
     + every ~continue~ by an no-else ~if~
       (a ~if~ with side effect)

     + every ~break~ by a /boolean variable/ that indicates whether the enclosing
       ~while~ loop should continue
       (~var~ is required)

   - For example,
     + Original version (Java)
       #+BEGIN_SRC java
         int i = 0;
         boolean foundIt = false;

         while (i < args.length) {
             if (args[i].startsWith("-")) {
                 i = i + 1;
                 continue;
             }

             if (args[i].endsWith(".scala")) {
                 foundIt = true;
                 break;
             }

             i = i + 1;
         }
       #+END_SRC

     + No ~break~ No ~continue~ version (Scala)
       #+BEGIN_SRC scala
         var i = 0
         var foundIt = false

         while (i < args.length && !foundIt) {
           if (!args(i).startsWith("-")) {
             if (args(i).endsWith(".scala")) {
               foundIt = true
             }
           }
           i = i + 1
         }
       #+END_SRC

     + Even no ~var~ version (Scala)
       #+BEGIN_SRC scala
         def searchFrom(i: Int): Int =
           if (i >= args.length) -1
           else if (args(i).startsWith("-")) searchFrom(i + 1)
           else if (args(i).endsWith(".scala")) i
           else searchFrom(i + 1)

         val i = searchFrom(0)
       #+END_SRC
       /tail-calls/ are optimized automatically. =TODO= Section 8.9

   - The is no keyword ~break~ in Scala.
     If you still want to use it, use the class ~Breaks~ in the package
     ~scala.util.control~, which offers a ~break~ method and can be used to exit
     an enclosing block that's marked with ~breakable~.

     For exmaple, a program that repeatedly read non-empty lines from the
     standard input.
     #+BEGIN_SRC scala
       import scala.util.control.Breaks._
       import java.io._

       val in = new BufferedReader(new InputStreamReader(System.in))

       breakable {
         while (true) {
           println("? ")
           if (in.readLine() == "") break
         }
       }
     #+END_SRC

   - The ~Breaks~ class implements ~break~ _by throwing an exception_ that is
     caught by an enclosing application of the ~breakable~ method.

     Therefore, the call to ~break~ does NOT need to be in the same method as
     the call to ~breakable~. =TODO= =???=

** DONE 7.7 Variable scope - 173
   CLOSED: [2017-10-21 Sat 11:51]
   - It is almost identical to Java. Only one exception:
     + you can define variables of the same name in nested scopes.

   - One thing is also can be considered as a "exception":
     + Sometimes you use curly braces in place of parentheses.
       In this case, you won't create a new scope

   - The REPL is special, whe you type in REPL that
     #+BEGIN_SRC scala
       scala> val a = 1
       scala> val a = 2
       scala> println(a)  // 2
     #+END_SRC

     It acutally implicitly help you create nested code (scope):
     #+BEGIN_SRC scala
       val a = 1
       {
         val a = 2
         {
           println(a)
         }
       }
     #+END_SRC

** DONE 7.8 Refactoring imperative-style code - 177
   CLOSED: [2017-10-21 Sat 12:02]
   A functional way to create a multiplication table (see the last section for
   the imperative way version)
   #+BEGIN_SRC scala
     // Returns a row as a sequence
     def makeRowSeq(row: Int) =
       for {
         col <- 1 to 10
         prod = (row * col).toString
         padding = " " * (4 - prod.length)
       } yield padding + prod

     // Returns a row as a string
     def makeRow(row: Int) =
       makeRowSeq(row).mkString

     // Returns table as a string with one row per line
     def multiTable =
       (1 to 10).
         map(makeRow).
         mkString("\n")
   #+END_SRC

** DONE 7.9 Conclusion - 179
   CLOSED: [2017-10-21 Sat 12:02]

* DONE 8 Functions and Closures - 180
  CLOSED: [2017-10-09 Mon 19:57]
  In fact, Scala offers several ways to define functions that are _NOT present_
  in Java.
  + methods :: functions that are members of some object
  + nested functions
  + function literals
  + function values
  + ???

** DONE 8.1 Methods - 180
   CLOSED: [2017-10-09 Mon 04:22]
   #+BEGIN_SRC scala
     import scala.io.Source

     object LongLines {
       def processFile(filename: String, width: Int) = {
         val source = Source.fromFile(filename)
         for (line <- source.getLines())
           processLine(filename, width, line)
       }

       private def processLine(filename: String,
                               width: Int, line: String) = {
         if (line.length > width)
           println(filename + ": " + line.trim)
       }
     }

     object FindLongLines {
       def main(args: Array[String]) = {
         val width = args(0).toInt
         for (arg <- args.drop(1))
           LongLines.processFile(arg, width)
       }
     }
   #+END_SRC

   - The concept of a /function/ in Scala is more general than a /method/.
     =TODO=
     Scala's other ways to express functions will be explained in the following
     sections.

** DONE 8.2 Local functions - 182
   CLOSED: [2017-10-09 Mon 04:24]
** DONE 8.3 First-class functions - 184
   CLOSED: [2017-10-09 Mon 04:35]
   - A /function literal/ is compiled into a class that when instantiated at
     runtime is a /function value/.

     Thus the _distinction_ between /function literals/ and /values/:
     + /function literals/ exist _in the source code_,
       whereas
     + /function values/ exist as /objects/ _at runtime_.

     The distinction is much like that between /classes/ (source code) and
     /objects/ (runtime).

   - footnote 2:
     Every /function value/ is an instance of some class that extends one of
     several ~FunctionN~ traits in package scala, such as ~Function0~ for
     functions with no parameters, ~Function1~ for functions with one parameter,
     and so on.

     =From Jian= The string represention of a ~FunctionN~ type /function value/
     is ~<functionN>~

     Each ~FunctionN~ trait has an ~apply~ method used to invoke the function.

   - Examples:
     #+BEGIN_SRC scala
       val someNumbers = List(-11, -10, -5, 0, 5, 10)

       someNumbers.foreach((x: Int) => println(x))
       // -11
       // -10
       // -5
       // 0
       // 5
       // 10

       someNumbers.filter((x: Int) => x > 0)
       // List(5, 10)
     #+END_SRC

** DONE 8.4 Short forms of function literals - 186
   CLOSED: [2017-10-09 Mon 04:38]
   - target typing :: ...
                      type inference related -- you don't always need to
                      explicitly type the parameter(s).

   - No parenthese required for single input parameter that no explicit type.

** DONE 8.5 Placeholder syntax - 187
   CLOSED: [2017-10-09 Mon 04:50]
   - One parameter: ~someNumbers.filter(_ > 0)~

   - Multiple parameters:
     #+BEGIN_SRC scala
     val f = (_: Int) + (_: Int)
     #+END_SRC
     + If these parameters are NOT typed, a compilation error will happen.

     + Multiple underscores mean multiple parameters, NOT reuse of a single
       parameter repeatedly, and use them in the input order.

** DONE 8.6 Partially applied functions - 188
   CLOSED: [2017-10-09 Mon 19:57]
   - You could write ~someNumbers.foreach(println _)~, rather than
     + ~someNumbers.foreach(x => println(x))~
     + ~someNumbers.foreach(println(_))~

     Thus, the underscore in this case is
     + NOT a placeholder for a single parameter.
     + but a placeholder for an entire parameter list.

     When you use an underscore in this way, you are writing a /partially applied
     function/.

   - ~val b = sum(1, _: Int, 3)~

   - You can only use a function as a parameter directly in the place where the
     compiler knows a function is required:
     ~someNumbers.foreach(println)~

     However, ~val c = sum~ is illegal. You must write it in the way
     + ~val d = sum _~
       or
     + (=From Jian=) ~val d: (Int, Int, Int) => Int = sum~

     to tell the compiler ~d~ is a function.

** DONE 8.7 Closures - 191
   CLOSED: [2017-10-09 Mon 19:02]
   - free variable ::

   - bound variable ::

   - closure ::

   - closed term :: a function literal with no /free variables/, such as
                    ~(x: Int) => x + 1~

   - open term :: a function literal with /free variables/, such as
                  ~(x: Int) => x + more~

   - The /free variables/ can be both ~val~ or ~var~.
     =From Jian= this is different from Java.

** DONE 8.8 Special function call forms - 195
   CLOSED: [2017-10-09 Mon 05:16]
*** DONE Repeated parameters
    CLOSED: [2017-10-09 Mon 05:16]
    - Scala allows you to indicate that _the LAST parameter_ to a function may be
      _repeated_.

      Example:
      #+BEGIN_SRC scala
        def echo(args: String*) =
          for (arg <- args) println(arg)

        // echo: (args: String*)Unit
      #+END_SRC

      Inside the function, the type of the repeated parameter is an ~Array~ of
      the declared type of the parameter.

    - You can also pass an array of the appropriate type paremeters to a function
      that accept repeated paraemters. To accomplish this, use ~_*~
      #+BEGIN_SRC scala
        val arr = Array("What's", "up", "doc?")

        echo(arr: _*)
      #+END_SRC
      This ~_*~ tells the compiler to pass the element in this array
      one by one individually, not like an array.

*** DONE Named arguments
    CLOSED: [2017-10-09 Mon 05:07]
    #+BEGIN_SRC scala
      def speed(distance: Float, time: Float): Float =
        distance / time

      speed(100, 10)
      // 10.0

      speed(distance = 100, time = 10)
      // 10.0

      speed(time = 10, distance = 100)
      // 10.0
    #+END_SRC

    - =IMPORTANT=
      It is also possible to mix positional and named arguments.
      In that case, the positional arguments come first.

      Named arguments are most frequently used in combination with
      /default parameter values/.

*** DONE Default parameter values
    CLOSED: [2017-10-09 Mon 05:10]
    #+BEGIN_SRC scala
      def printTime(out: java.io.PrintStream = Console.out) =
        out.println("time = " + System.currentTimeMillis())
    #+END_SRC

    - /Default parameters/ are especially helpful when used in combination with
      /named parameters/.

** DONE 8.9 Tail recursion - 198
   CLOSED: [2017-10-09 Mon 19:46]
   - tail recursive ::

*** DONE Tracing tail-recursive functions
    CLOSED: [2017-10-09 Mon 19:31]
    - *Tail call optimization*

    - Example (=From Jian= I can't see stack info like this):
      #+BEGIN_SRC scala
        def bang(x: Int): Int =
          if (x == 0) throw new Exception("bang!")
          else bang(x - 1)

        // Only one stack
        bang(5)
        // java.lang.Exception: bang!
        //   at .bang(<console>:5)
        //   at .<init>(<console>:6) ...


        // scalac with `-g:notailcalls`
        bang(5)
        // java.lang.Exception.Exception: bang!
        //       at .bang(<console>:5)
        //       at .bang(<console>:5)
        //       at .bang(<console>:5)
        //       at .bang(<console>:5)
        //       at .bang(<console>:5)
        //       at .bang(<console>:5)
        //       at .<init>(<console>:6)
      #+END_SRC

*** DONE Limits of tail recursion
    CLOSED: [2017-10-09 Mon 19:44]
    The use of tail recursion in Scala is fairly limited because the JVM
    instruction set makes implementing more advanced forms of tail recursion
    very difficult.

    - Scala only optimizes directly recursive calls.
      It can't optimize mutually recursive functions.

    - You also won't get a tail-call optimization if the final call goes to a
      function value.
      #+BEGIN_SRC scala
        val funValue = nestedFun _

        def nestedFun(x: Int): Unit = {
          if (x != 0) {
            println(x)
            funValue(x - 1)
          }
        }
      #+END_SRC

    - Tail-call optimization is limited to situations where a method or nested
      function calls itself directly as its last operation, without going through
      a function vlaue or some other intermediary.

      =TODO= See Section 8.9 for more

** DONE 8.10 Conclusion - 202
   CLOSED: [2017-10-09 Mon 19:49]

* DONE 9 Control Abstraction - 203
  CLOSED: [2017-10-09 Mon 23:01]
 - Show you how to apply function values to create new control abstractions.

 - Learn about currying and by-name parameters.

** DONE 9.1 Reducing code duplication - 203
   CLOSED: [2017-10-09 Mon 20:21]
   - Non-higher-order functions compose
     + its common part (the no-change source code)
     + its non-common part (the passed in non-function values)

     It represent one algorithm

   - Higher-order functions compose
     + its common part (the no-change source code)
     + its non-common part (the passed in function values)

     _It represent one family of algorithms_:
       The common part is a kind of algorithm, and passed in function values
     also have other algorithms (which can be different every time you invoke
     this higher-order functions). This is why higher-order functions have extra
     capacity of expressiveness.

   - One benefit of higher-order functions is they enable you to create control
     abstractions that allow you to reduce code duplication.

   - Example:
     #+BEGIN_SRC scala
       object FileMatcher {
         private def filesHere = (new java.io.File(".")).listFiles

         private def filesMatching(matcher: String => Boolean) =
           for (file <filesHere;
                if matcher(file.getName))
           yield file

         def filesEnding(query: String) =
           filesMatching(_.endsWith(query))

         def filesContaining(query: String) =
           filesMatching(_.contains(query))

         def filesRegex(query: String) =
           filesMatching(_.matches(query))
       }
     #+END_SRC

** DONE 9.2 Simplifying client code - 207
   CLOSED: [2017-10-09 Mon 21:39]
   The previous example demonstrated that higher-order functions can help reduce
   code duplication as you implement an API.
   _Create an API with higher-order functions_

   Another important use of higher-order functions is to put them in an API
   itself to make client code more concise.
   _Use an higher-order function API to simplify you code_

   For instance, use the special-purpose looping methods of Scala's collection
   types:

   - use ~def containsNeg(nums: List[Int]) = nums.exists(_ < 0)~,
     rahter than define the body with loop and ~var~.

   - special-purpose looping :: (Many of these are listed in Table 3.1)
        (footnote 1: These special-purpose looping methods are defined in trait
         ~Traversable~, which is extended by ~List~, ~Set~, and ~Map~.
         =TODO= See Chapter 17 for a discussion.)

** DONE 9.3 Currying - 209
   CLOSED: [2017-10-09 Mon 20:55]
   - Use /currying/ you can make /control abstractions/ that you created feel
     more like language extensions.

   - Non-currying and currying:
     #+BEGIN_SRC scala
       def plainOldSum(x: Int, y: Int) = x + y

       plainOldSum(1, 2)


       def curriedSum(x: Int)(y: Int) = x + y

       curriedSum(1)(2)
     #+END_SRC

   - Create essential currying functions with or without /currying/ syntax:
     #+BEGIN_SRC scala
       def first(x: Int) = (y: Int) => x + y
       // first: (x: Int)Int => Int

       val second = first(1)
       // second: Int => Int = <funciton1>

       second(2)
       // 3


       val onePlus = curriedSum(1)_
       // oneplus: Int => Int = <function1>

       onePlus(2)
       // 3
     #+END_SRC

     =IMPORTANT= You can see the difference: The function created use the
     currying syntax when not fully applied, must use the
     ~partially applied function~ syntax.

** DONE 9.4 Writing new control structures - 211
   CLOSED: [2017-10-09 Mon 22:48]
   - loan pattern ::

   - The original version:
     #+BEGIN_SRC scala
       def withPrintWriter(file: File, op: PrintWriter => Unit) = {
         val writer = new PrintWriter(file)
         try {
           op(writer)
         } finally {
           writer.close()
         }
       }

       // Usage
       withPrintWriter(
         new File("date.txt"),
         writer => writer.println(new java.util.Date)
       )
     #+END_SRC

   - You can use ~{}~ instead of ~()~ in some scenarios
     #+BEGIN_SRC scala
       println("Hello, world!")

       println { "Hello, world!" }
     #+END_SRC
     The syntax use ~{}~ is like a build-in syntax structure.

   - You can't use ~,~ in curly braces block:
     #+BEGIN_SRC scala
       val g = "Hello, world!"
       g.substring { 7 , 9 }
       // <console>:1: error: ';' expected but ',' found.
       //        g.substring { 7, 9 }
       //                       ^

       g.substring(7, 9)
       // wo
     #+END_SRC

   - The modified version (NOT the final version. See the next section for the
     final version):
     #+BEGIN_SRC scala
       def withPrintWriter(file: File)(op: PrintWriter => Unit) = {
         val writer = new PrintWriter(file)
         try {
           op(writer)
         } finally {
           writer.close()
         }
       }

       // Usage
       withPrintWriter(new File("date.txt")) { writer =>
         writer.println(new java.util.Date)
       }
     #+END_SRC

** DONE 9.5 By-name parameters - 214
   CLOSED: [2017-10-09 Mon 22:05]
    - Use /by-name type/, put ~=>~ in front of a normal type.

    - A by-name type, in which the empty parameter list, ~()~, is left out, is
      only allowed for parameters.

      There is NO such thing as a by-name variable or a by-name field.
      (=From Jian= but there is ~lazy~ keyword, right???) =TOOD=

** DONE 9.6 Conclusion - 217
   CLOSED: [2017-10-09 Mon 23:01]

* DONE 10 Composition and Inheritance - 218
  CLOSED: [2018-04-05 Thu 02:47]
  - Chapter 6 introduced some basic object-oriented aspects of Scala.

    This chapter picks up where Chapter 6 left off and dives into Scala's support
    for object-oriented programming in much greater detail.

  - We'll compare two fundamental relationships between classes:
    /composition/ and /inheritance/.

    + /Composition/ means one class holds a reference to another, using the
      referenced class to help it fulfill its mission.

    + /Inheritance/ is the superclass/subclass relationship -- use the inherited
      members to fulfill its mission.

  - We'll also discuss:
    + /abstract classes/
    + /parameterless methods/
    + *extending* /classes/
    + *overriding* /methods/ and /fields/
    + /parametric fields/
    + *invoking* /superclass constructors/
    + /polymorphism/ and /dynamic binding/
    + /final members/ and /final classes/
    + /factory objects/ and /factory methods/

** DONE 10.1 A two-dimensional layout library - 218
   CLOSED: [2017-10-09 Mon 23:58]
   As a running example in this chapter, we'll create a /library/ for _building
   and rendering two-dimensional layout elements_.

   - /Factory method/ ~elem~ that construct new elements from passed data.
     The corresponding type is ~Element~
     ~def elem(s: String): Element~

   - =TODO=
     In this chapter, we’ll define classes that enable element objects to be
     constructed from arrays, lines, and rectangles. These basic element objects
     will be the simple parts.

   - We'll also define ~above~ and ~beside~ /methods/ in ~Element~.

     Usage Example:
     #+BEGIN_SRC scala
       val column1 = elem("hello") above elem("***")
       val column2 = elem("***") above elem("world")
       println(column1 beside column2)
       // hello ***
       //  *** world
     #+END_SRC

   - /Layout elements/ are a good example of a system in which objects can be
     _constructed from simple parts with the aid of *composing operators*._

     The /composing operators/ are also often called /combinators/ because the
     combine elements of some domain into new elements.

   - *Thinking in terms of /combinators/ is generally a good way to approach
     library design*: it pays to think about the fundamental ways to construct
     objects in an application domain.

   - You can construct a library by answering the questions below:

     + What are the simple objects?

     + In what ways can more interesting objects be constructed out of simpler ones?

     + How do combinators hang together?

     + What are the most general combinations?

     + Do they satisfy any interesting laws?

** DONE 10.2 Abstract classes - 219
   CLOSED: [2017-10-09 Mon 23:58]
   _NOTE editing is no longer required!!!_
   #+BEGIN_SRC scala
     abstract class Element {
       def contents: Array[String]
     }
   #+END_SRC
   - A /class/ with /abstract members/ *MUST* itself be declared ~abstract~

   - *UNLIKE* Java, _NO_ ~abstract~ modifier is necessary (or allowed) on /method/
     declarations.

   - Here we use two concepts: *declarations* and *definitions*.

     ~Element~
     + *declares* the /abstract method/ ~contents~,
     + does NOT *define* /concrete methods/.

** DONE 10.3 Defining parameterless methods - 220
   CLOSED: [2017-10-10 Tue 00:18]
   Add methods ~height~ and ~width~ to ~Element~.
   #+BEGIN_SRC scala
     abstract class Element {
       def contents: Array[String]
       def height: Int = contents.length
       def width: Int = if (height == 0) 0 else contents(0).length
     }
   #+END_SRC
   - We add a _constraint_ that:
     You cannot create an element with a ~height~ of _zero_ and a _non-zero_
     ~width~.

     The constraint is coded in the implementation of ~width~.

   - The three /methods/ we have now are all /parameterless methods/.

   - We can have /parameterless methods/ and /empty-paren methods/.

     We have conventions about where to use them:
     + use /parameterless methods/ when you will do some purely functional
       computation.

     + use /empty-paren methods/
       * when you do something with /side effect/, which is obvious -- you work
         with /side effect/ directly.

       * when you access some ~var~ -- you work with /side effect/ indirectly.

   - the uniform access principle :: that client code *should not* be affected by
        a decision to implement an /attribute/ as a /field/ or /method/.

     + Since /mutable states/ keep changing, they *CANNOT* be referenced by
       /fields/ which is pre-computed and cannot keep changing.

       Therefore, the /the uniform access principle/ is NOT workable to /mutable
       states/ -- always use this principle with /immutable values/.

   - From the performance point of view:
     + A /field/ is pre-computed and no change in the future
       * it is usually *faster* than a /method/.
       * it *requires memory* to save the pre-computed values.

     + A /method/ is required to access /mutable states/, their return values can
       keep changing.
       * they *CANNOT* be pre-computed
       * *NO* extra memory is required.

   - =From Jian=
     Java use the ~length~ field to access the /length/ of a /immutable object/.
     Java use the ~size~ method to access the /size/ of a /mutable object/.

** DONE 10.4 Extending classes - 223
   CLOSED: [2017-10-10 Tue 04:18]
   #+BEGIN_SRC scala
     class ArrayElement(conts: Array[String]) extends Element {
       def contents: Array[String] = conts
     }
   #+END_SRC
   - ~scala.AnyRef~ is the default /superclass/ if you leave out an ~extends~.
     It is the same as the /class/ ~java.lang.Object~ in Java platform.

   - ~extends~ clause has two effects:
     + ~ArrayElement~ /inherited/ *all non-private* members from class ~Element~.

     + it makes ~ArrayElement~ the /subclass/ of ~Element~, and, conversely,
       ~Element~ is the /superclass/ of ~ArrayElement~.

   - /Inheritance/ means that *all members* of the /superclass/ are also members
     of the subclass, with *TWO exceptions*:
     1. /private members/

     2. /overrideed members/ -- you have new definition, and you won't use the old
        one.

        Implements the abstract method in the subclasss is also a kind of
        /override/, though we often use a more specific word /implement/.

        =From Jian= I decide to add some comments to the /implemented method/, to
        _distinguish them from overriding exist concrete method_.

   - footnote 2:
     + One flaw: the returned array is mutable, clients could change it.
       One solution in a real world project: return a /defensive copy/ of the
       array instead. =TODO= =defensive copy ???=

     + No guarantee to the equal width of the strings in the passed in ~Array~.
       One solution is to use /precondition/ in the /primary constructor/.

   - /Subtyping/ means that a value of the /subclass/ can be used wherever a
     value of the /superclass/ is required. For example:
     ~val e: Element = new ArrayElement(Array("hello"))~

   - /composition/: use a field to hold a reference to other object.

     There is a /composition/ relation between ~ArrayElement~ and ~Array[String]~

     =From Jian=
     If the ~ArrayElement~ /constructor/ accept an ~Array[String]~ value, and
     transform it to some other object(s) and save it, it is NOT a /composition/,
     which is *NOT* the case we met.

** DONE 10.5 Overriding methods and fields - 225
   CLOSED: [2017-10-10 Tue 05:47]
   - About /methods/ and /fields/:
     + Scala has /uniform access principle/, and Java does _NOT_ have.

     + In Scala, /fields/ and /methods/ belong to the same namespace, which
       makes it possible for a /field/ to /override/ a /parameterless method/.

       On the other hand, Java can have a /field/ and a /method/ have the same
       name, but Scala forbid this.

   - The second point above
     + makes it possible for a /field/ to _override_ a /parameterless method/.

     + forbids define a field and method with the same name in the same class in
       Scala, whereas this is allowed in Java.

   - Generally, Scala has just _TWO_ namespaces for definitions in place of
     Java's _FOUR_.

     + Java's four namespaces:
       * fields
       * methods
       * types
       * packages.

     + Scala's two namespaces:
       * values (fields, methods, packages, and singleton objects)
       * types (class and trait names)

   - footnote 4:
     The reason that /packages/ share the same /namespace/ as /fields/ and
     /methods/ in Scala is to enable you to import /packages/ (in addition to
     just the names of types), as well as the /fields/ and /methods/ of
     /singleton objects/.

     =TODO=
     This is also something you can't do in Java. It will be described in
     Section 13.3.

** DONE 10.6 Defining parametric fields - 226
   CLOSED: [2017-10-10 Tue 05:56]
   - Combine the /default constructor/ with the header of the class declaration:
     #+BEGIN_SRC scala
     class ArrayElement(val contents: Array[String]) extends Element
     #+END_SRC
     + Here we implement the ~contents~ /parameterless method/ fo ~Element~ with
       the immutable /field/ ~contents~. Here we apply the /uniform access
       principle/.

   - Modifiers ~private~, ~protected~, and ~override~ can also be used.
     For example,
     #+BEGIN_SRC scala
       class Cat {
         val dangerous = false
       }

       class Tiger(
         override val dangerous: Boolean,
         private var age: Int
       ) extends Cat
     #+END_SRC

     + =From Jian= A better example required!
       It is wierd that ~Tiger~ is a subclass of ~Cat~!!!

** DONE 10.7 Invoking superclass constructors - 228
   CLOSED: [2017-10-10 Tue 06:08]
   #+BEGIN_SRC scala
     class LineElement(s: String) extends ArrayElements(Array(s)) {
       override def width = s.length
       override def height = 1
     }
   #+END_SRC

   - Invoke superclass constructors through the syntax
     ~extends ArrayElement(Array(s))~

** DONE 10.8 Using ~override~ modifiers - 229 =Re-Write some Notes=
   CLOSED: [2017-10-10 Tue 06:21]
   - The modifier ~override~
     + is *optional* if a member /implements/ an /abstract member/ with the same
       name.

     + is *mandatory* if a member /override/ an /concrete member/ with the same
       name.

   - The rule of how to use ~override~ provides useful information for the
     compiler that helps
     + avoid some hard-to-catch errors
       For instnace, if you misspell some names of *overrided* /methods/ or
       /fields/), you will see an error message like:
       #+BEGIN_SRC text
         .../LineElement.scala:50:
         error: method hight overrides nothing
           override def hight = 1
       #+END_SRC

     + makes system evolution safer

       =From Jian= Re-Write this entry of note in the future, and pay more
       attention to the wording -- make it clearer.

       For instance,
       * System Settings:
         1. A /base class/ ~A~.

         2. ~B~ is a /subclass/ of ~A~, and it has a /method/
            ~def hidden: Boolean~ (or ~def hidden(): Unit~).

       * Now, let's check what will happen to the system consisted by ~A~ and
         ~B~, after the API evolution of ~A~ -- a public /method/
         ~def hidden: Boolean~ is added to ~A~. For ~B~ the ~hidden~ in ~A~ is a
         exist-in-future /method/.

         =From Jian= Here I'll use anti-evidence to show why the rule of using
         ~override~ is useful, especially when ~override~ is *mandatory*:

         1. When the two ~hidden~'s in ~A~ and ~B~, by coincidence, have the same
            meaning and /type signature/, *mandatory* ~override~ is not very
            useful. How ever, we shouldn't weight this case too much -- is the
            rare case, *mandatory* ~override~ isi useless, but *mandatory*
            ~override~ also harmless.

         2. When the ~hidden~ in ~B~ has the _SAME_ /type signature/ as the one
            in ~A~, but they have different meaning (this is the most common
            case), _the lack of *mandatory* ~override~ is *fatal* --_ the
            implementors forget the different meanings between these two
            ~hidden~, and the users have no chance to detect this error until
            they get some wierd results.

            - These *accidental overrides* are the most common manifestation of
              what is called the *fragile base class* problem.
                The problem is that if you add new members to base classes (which
              we usually call superclasses) in a class hierarchy, you risk
              breaking client code.

              Scala cannot solve this problem completely, but its _MANDATORY_
              ~override~ (Java doesn't have this) can help the programmers to
              solve this problem -- the exist-in-future /methods/ won't have
              ~override~ modifier! When you change the /base class/, you may need
              to add ~override~ in the /subclasses/, at this time you have a
              chance to check if the meaning of ~hidden~ in ~B~ is the same as the
              meaning of the ~hidden~ in ~A~.

         3. if the ~hidden~ in ~B~ has the _DIFFERENT_ /type signature/ as the
            one in ~A~, the lack of *mandatory* ~override~ is NOT a big problem,
            the compiler will tell you the ~hidden~ in ~B~ has wrong signature,
            which is a hint that you need to check what does the ~hidden~ in ~B~
            do!

       * Summary:
         Without *mandatory* ~override~, 1 and 3 work well. However, they also
         work well with *mandatory* ~override~.

         Without *mandatory* ~override~, the problem of 2 can be *fatal*, the
         *mandatory* ~override~ can solve this problem.

         As a summary, the *mandatory* ~override~ is useful!

   - Java introduces ~@Override~ annotation from 1.5 on.
     However, this is *NOT* MANDATORY, and use it is just a good habit.

** DONE 10.9 Polymorphism and dynamic binding - 231
   CLOSED: [2017-10-10 Tue 06:41]
   - The /ploymorphism/ discussed in this section is /subtyping polymorphism/.

     =From Jian= I still remember the discussion between me and Hao Hou that
     /subtyping polymorphism/ is error prone, and the programmer need pay much
     attention on it.
     ------------------ Review, Reflection, and Summary in the future =TODO=!!!

     =From Jian= Another problem of /subtyping polymorphism/ in Java is that a
     lot of /casts/ must be insterted. I think Scala does a good job to
     eliminate manually /casts/ -- /implicts/ and ~this.type~
     ------------------ Review, Reflection, and Summary in the future =TODO=!!!

     =TODO= footnote 7: Chapter 19 discusses /universal polymorphism/.

   - dynamically bound :: the ACTUAL /method implementation/ *invoked* is
        _determined at run time_ _based on the /class/ of the object_, NOT the
        type of the variable or expression.

        #+BEGIN_SRC scala
          abstract class Element {
            def demo() = {
              println("Element's implementation invoked")
            }
          }
          class ArrayElement extends Element {
            override def demo() = {
              println("ArrayElement's implementation invoked")
            }
          }
          class LineElement extends ArrayElement {
            override def demo() = {
              println("LineElement's implementation invoked")
            }
          }
            // UniformElement inherits Element's demo
          class UniformElement extends Element

          // Type this method in the interpreter
          def invokeDemo(e: Element) = {
            e.demo()
          }


          // Invoke and inspect the OUTPUTs:

          // #1
          invokeDemo(new ArrayElement)
          // ArrayElement's implementation invoked

          // #2
          invokeDemo(new LineElement)
          // LineElement's implementation invoked

          // #3
          invokeDemo(new UniformElement)
          // Element's implementation invoked
        #+END_SRC

** DONE 10.10 Declaring ~final~ members - 233
   CLOSED: [2017-10-10 Tue 06:50]
   Use ~final~ to ensure that a member _cannot be overridden_ by /subclasses/.
   This usage of ~final~ is the same as in Java.
   - *Forbid* /subclass method overriding/
     ~final override def demo() = { ...~

   - *Forbid* /creating subclass/:
     ~final class ArrayElement extends Element { ...~

** DONE 10.11 Using composition and inheritance - 235
   CLOSED: [2017-10-10 Tue 07:04]
   - /Composition/ and /inheritance/ are two ways to
     _define a new class in terms of another existing class._

   - If what you're after is primarily _code reuse_, you should in general prefer
     /composition/ to /inheritance/.
     + Only /inheritance/ suffers from the /fragile base class problem/, in which
       you can INADVERTENTLY *break* /subclasses/ _by changing a /superclass/._

     + If you want to use /inheritance/, you need to consider two questions:
       1. whether it models an *is-a* relationship.
          For instance, ~ArrayElement~ *is a* ~Element~.

          footnote 8: Meyers, Effective C++ [Mey91] =TODO=

       2. whether clients will want to use the subclass type as a superclass type.
          For instance, use ~ArrayElement~ as an ~Element~

          footnote 9: Eckel, Thinking in Java [Eck98] =TODO=

   - Example:
     In the former section, we define ~LineElement~ as a /subclass/ of
     ~ArrayElement~ *to re-use* ~ArrayElement~'s definition of ~contents~.

     It is *better* to define ~LineElement~ as a /direct subclass/ of ~Element~:
     #+BEGIN_SRC scala
       class LineElement(s: String) extends Element {
         val contents = Array(s)
         override def width = s.length
         override def height = 1
       }
     #+END_SRC
     + If ~LineElement~ extends ~ArrayElement~, this is a /inheritance relation/
       between these two classes.

     + If ~LineElement~ extends ~Element~ directly, it is more important to
       forcus on the /composition relation/ between ~LineElement~ and ~Array~.

** DONE 10.12 Implementing ~above~, ~beside~, and ~toString~ - 236
   CLOSED: [2017-10-10 Tue 07:11]
   Simplified Implementation (See complete version in section 10.14):
   #+BEGIN_SRC scala
     // Save width
     def above(that: Element): Element =
       new ArrayElement(this.contents ++ that.contents)

     // Save height
     def beside(that: Element): Element = {
       val newContents =
         (this.contents zip that.contents) map {
           case (l1, l2) => l1 + l2
         }

       new ArrayElement(newContents)
     }

     override def toString = contents mkString "\n"
   #+END_SRC

   - Both ~above~ and ~beside~ above are simplified versions.
     + Currently, ~above~ only works for ~Element~'s of same ~width~.
     + Currently, ~beside~ only works for ~Element~'s of same ~height~.

** DONE 10.13 Defining a factory object - 238
   CLOSED: [2018-03-06 Tue 14:21]
   - A /factory object/ contains /methods/ that _construct other objects_.

   - An advantage of this approach:
     + /object creation/ can be *centralized*
     + the details of how objects are represented with /classes/ can be *hidden*.

       * This hiding will both make your library
         + *simpler for clients to understand*, because less detail is exposed,

         + provide you with _more opportunities to change your library's
           implementation later_ *WITHOUT breaking client code*.

   - Example of a factory class:
     #+BEGIN_SRC scala
       abstract class Element {
         def contents: Array[String]

         def width: Int =
           if (height == 0) 0 else contents(0).length

         def height: Int = contents.length

         def above(that: Element): Element =
           new ArrayElement(this.contents ++ that.contents)

         def beside(that: Element): Element =
           new ArrayElement(
             for (
               (line1, line2) <- this.contents zip that.contents
             ) yield line1 + line2
           )

         override def toString = contents mkString "\n"
       }
     #+END_SRC

   - Use /companion object/ as a factory:
     #+BEGIN_SRC scala
       object Element {
         def elem(contents: Array[String]): Element =
           new ArrayElement(contents)

         def elem(chr: Char, width: Int, height: Int): Element =
           new UniformElement(chr, width, height)

         def elem(line: String): Element =
           new LineElement(line)
       }
     #+END_SRC
     Later we can use ~import Element.elem~ in the top level of client code.

   - After defining /factory methods/, there is not need to make ~ArrayElement~,
     ~LineElement~, and ~UniformElement~ public. The usual choice is to put them
     inside the /companion object/.

** DONE 10.14 Heighten and widen - 240
   CLOSED: [2018-04-05 Thu 01:42]
   One last enhancement:
   The version of ~Element~ shown in Listing 10.11 is NOT quite sufficient
   because it does _NOT allow clients to align different size ~Element~'s_.

   Here _"NOT allow"_ means the ~above~ and ~beside~ before this section can't
   work properly.

   *We should adjust different elements, and make them the same size first.*

   *Pad spaces* to ~widen~ and ~heighten~ an element.

   #+BEGIN_SRC scala
     object Element {
       private class ArrayElement(
         val contents: Array[String]
       ) extends Element

       private class LineElement(s: String) extends Element {
         val contents = Array(s)
         override def width = s.length
         override def height = 1
       }

       private class UniformElement(
         ch: Char,
         override val width: Int,
         override val height: Int
       ) extends Element {
         private val line = ch.toString * width
         def contents = Array.fill(height)(line)
       }

       def elem(contents: Array[String]): Element =
         new ArrayElement(contents)

       def elem(chr: Char, width: Int, height: Int): Element =
         new UniformElement(chr, width, height)

       def elem(line: String): Element =
         new LineElement(line)
     }


     import Element.elem

     abstract class Element {
       def contents: Array[String]
       def width: Int = contents(0).length
       def height: Int = contents.length

       def above(that: Element): Element = {
         val this1 = this widen that.width
         val that1 = that widen this.width
         elem(this1.contents ++ that1.contents)
       }

       def beside(that: Element): Element = {
         val this1 = this heighten that.height
         val that1 = that heighten this.height
         elem(
           for ((line1, line2) <- this1.contents zip that1.contents)
           yield line1 + line2
         )
       }

       def widen(w: Int): Element =
         if (w <= width) this
         else {
           val left = elem(' ', (w - width) / 2, height)
           val right = elem(' ', w - width - left.width, height)
           left beside this beside right
         }

       def heighten(h: Int): Element =
         if (h <= height) this
         else {
           val top = elem(' ', width, (h - height) / 2)
           val bot = elem(' ', width, h - height - top.height)
           top above this above bot
         }

       override def toString = contents mkString "\n"
     }
   #+END_SRC

** DONE 10.15 Putting it all together - 244 =Re-Read=
   CLOSED: [2018-04-05 Thu 02:47]
   #+BEGIN_SRC scala
     import Element.elem

     object Spiral {
       val space = elem(" ")
       val corner = elem("+")

       def spiral(nEdges: Int, direction: Int): Element = {
         if (nEdges == 1)
           elem("+")
         else {
           val sp = spiral(nEdges - 1, (direction + 3) % 4)
           def verticalBar = elem('|', 1, sp.height)
           def horizontalBar = elem('-', sp.width, 1)

           if      (direction == 0) (corner beside horizontalBar) above (sp beside space)
           else if (direction == 1) (sp above space) beside (corner above verticalBar)
           else if (direction == 2) (space beside sp) above (horizontalBar beside corner)
           else                     (verticalBar above corner) beside (space above sp)
         }
       }

       def main(args: Array[String]) = {
         val nSides = args(0).toInt
         println(spiral(nSides, 0))
       }

     }
   #+END_SRC
   - =TODO=
     =From Jian= =???=
     Make ~direction~'s /case class/ rather than integer.

   - =TODO= Try to understand= !!!

     =From Jian= Now I follow the code and manually construct spirals.
     I understand how does it construct, but I don't understand how can the
     programmer get an idea to write code like this /combinator style/???

** DONE 10.16 Conclusion - 245
   CLOSED: [2017-10-11 Wed 18:03]

* DONE 11 Scala's Hierarchy - 246
  CLOSED: [2017-10-12 Thu 00:16]
  In Scala, every class inherits from a common superclass named ~Any~.

  Scala also defines some interesting classes at the _bottom_ of the hierarchy,
  ~Null~ and ~Nothing~, which essentially act as common subclasses.

  ~Nothing~ is a subclass of ~Null~.

** DONE 11.1 Scala's class hierarchy - 246
   CLOSED: [2017-10-11 Wed 18:39]
   - The ~hashCode~ method has an alias ~##~

   - The ~==~ method is essentially the same as ~equals~ and ~!=~ is _ALWAYS_ the
     negation of ~equals~.

     footnote 1:
     The only case where ~==~ does not directly call ~equals~ is for Java's boxed
     numeric classes, such as ~Integer~ or ~Long~. In Java, a ~new Integer(1)~
     does NOT equal a ~new Long(1)~ even though for /primitive values/ ~1 == 1L~.
       Since Scala is a more regular language than Java, it was necessary to
     correct this discrepancy by special-casing the ~==~ method for these classes.
     Likewise, the ~##~ method provides a Scala version of hashing that is the
     same as Java’s ~hashCode~, except for boxed numeric types, where it works
     consistently with ~==~. For instance ~new Integer(1)~ and ~new Long(1)~
     hash the same with ~##~ even though their Java ~hashCodes~ are different.

     =From Jian= this is NOT always the case if in Java due to its /boxed type/
     and /reference equality/.

   - ~Any~ has two direct subclasses:
     + ~AnyVal~ :: the parent class of /value classes/.

       There are _NINE_ /value classes/ built into Scala, they are subtypes of
       ~scala.AnyVal~, but they do NOT subclass each other:
       * ~Byte~
       * ~Short~
       * ~Char~
       * ~Int~
       * ~Long~
       * ~Float~
       * ~Double~
       * ~Boolean~
       * ~Unit~

       The instances of /these classes/ are all written as /literals/ in Scala.
       You cannot create instances of these classes using ~new~. This is enforced
       by the "trick" that value classes are all defined to be both ~abstract~
       and ~final~.

     + ~AnyRef~ :: the base class of all /reference classes/ in Scala.

       This is just an alias for class ~java.lang.Object~. So classes written in
       Java, as well as classes written in Scala, all inherit from ~AnyRef~.

       One way to think of ~java.lang.Object~, therefore, is as the way ~AnyRef~
       is implemented on the Java platform. Thus, although you can use ~Object~
       and ~AnyRef~ interchangeably in Scala programs on the Java platform,
       _the recommended style is to use ~AnyRef~ everywhere_.

** DONE 11.2 How primitives are implemented - 250
   CLOSED: [2017-10-11 Wed 19:01]
   - Scala stores integers in the same way as Java -- as 32-bit words.
     This is important for efficiency on the JVM and also for interoperability
     with Java libraries.

     Integers of type ~Int~ are converted transparently to "boxed integers" of
     type ~java.lang.Integer~ whenever necessary. This is like /auto-boxing/ in
     Java 5+ and it is indeed quite similar.
       There's _ONE crucial difference_ though: /Boxing/ in Scala is much less
       visible than /boxing/ in Java -- you cannot distinguish them in Scala.

   - _Java is NOT a pure object-oriented language_.
     There is a difference between /primitive types/ and /reference types/ that
     can be clearly observed.
     #+BEGIN_SRC java
       boolean isEqual(int x, int y) {
           return x == y;
       }

       isEqual(42, 42);  // true

       boolean isEqualObj(Integer x, Integer y) {
           return x == y;
       }

       isEqualObj(42, 42);  // false
     #+END_SRC

   - For /reference types/ other than Java's boxed numeric types, ~==~ is treated
     as an alias of the ~equals~ method inherited from ~Object~.

     One example that the result is
     ~true~ in Scala,
     but ~false~ in Java (~equals~ returns ~true~):
     #+BEGIN_SRC scala
       val x = "abcd".substring(2)
       val y = "abcd".substring(2)

       x == y  // true
     #+END_SRC

   - =TODO= /hash cons/

   - Class ~AnyRef~ defines an additional ~eq~ method, which _CANNOT be
     overridden_ and is implemented as /reference equality/ (behaves like ~==~ in
     Java for /reference types/). It has a negation ~ne~.
     #+BEGIN_SRC scala
       val x = new String("abc")
       val y = new String("abc")

       x == y  // true
       x eq y  // false
       x ne y  // true
     #+END_SRC

   - =TODO=
     Equality in Scala is discussed further in Chapter 30.

** DONE 11.3 Bottom types - 252
   CLOSED: [2017-10-12 Thu 00:03]
   - Class ~Null~ is the type of the ~null~ reference; it is a subclass of every
     reference class (i.e., every class that itself inherits from ~AnyRef~).

     ~Null~ is NOT compatible with /value types/.

   - ~Nothing~ is at the very bottom of Scala's class hierarchy; it is a subtype
     of every other type. However, there exist NO values of this type whatsoever.

     Q: Why does it make sense to have a type without values?
     A: (partial) As discussed in Section 7.4, one use of ~Nothing~ is that is
        singnals abnormal termination.
        For instance, the ~error~ method in the ~Predef~ object:
        #+BEGIN_SRC scala
          def error(message: String): Nothing =
            throw new RuntimeException(message)
        #+END_SRC

** DONE 11.4 Defining your own value classes - 253
   CLOSED: [2017-10-12 Thu 00:15]
   - For a class to be a /value class/,
     + it must have exactly ONE parameter
     + it must have NOTHING inside it except ~def~'s.
     + NO other class can extend a /value class/
     + cannot redefine ~equals~ or ~hashCode~.

   - Example:
     #+BEGIN_SRC scala
       class Dollars(val amount: Int) extends AnyVal {
         override def toString() = "$" + amount
       }
     #+END_SRC

*** DONE Avoiding a types monoculture
    CLOSED: [2017-10-12 Thu 00:15]
    To get the most benefit from the Scala class hierarchy,
    _try to define a new class for each domain concept_,
    even when it would be possible to reuse the same class for different
    purposes. Even if such a class is a so-called /tiny type/ with no methods or
    fields,
    _defining the additional class is a way to help the compiler be helpful to
    you._

** DONE 11.5 Conclusion - 256
   CLOSED: [2017-10-12 Thu 00:15]

* DONE 12 Traits - 257
  CLOSED: [2018-03-21 Wed 23:51]
  - /Traits/ are a fundamental unit of code reuse in Scala.

  - A /trait/ encapsulates /method/ and /field/ definitions,
    which can then be reused by mixing them into classes.

  - This chapter shows you
    + how traits work
    + TWO of the most common ways they are useful:
      * widening thin interfaces to rich ones
      * defining stackable modifications
      *
  - It also shows
    + how to use the ~Ordered~ trait
    + compares traits to the multiple inheritance of other languages.

** DONE 12.1 How traits work - 257
   CLOSED: [2017-10-12 Thu 00:37]
   - A trait does NOT declare a superclass, so like a class, it has the default
     superclass of ~AnyRef~.

   - /traits/ can do anything calls can do, with only _TWO exceptions_:
     + a trait cannot have any /class parameter/ (i.e. parameters passed to the
       primary constructor of a class).

     + Whereas in classes, the ~super~ calls are _statically_ bound; in traits,
       they are dynamically bound.

       ~super~ is undefined when you define the ~trait~ that includes it.
       Rather, the implementation to invoke will be determined anew each time
       the trait is mixed into a concrete class.

       =TODO=
       This curious behavior of super is key to allowing traits to work as
       /stackable modifications/, which will be described in Section 12.5.

       =TODO=
       The rules for resolving super calls will be given in Section 12.6.

   - stackable modifications :: =TODO=

** DONE 12.2 Thin versus rich interfaces - 260
   CLOSED: [2017-10-12 Thu 03:17]
   =From Jian= Except the phase /Java interface/, *interface* by itself in this
   section is used to represent its general meaning, NOT something for a
   specific language.

   - One major use of /traits/ is to automatically add (concrete) /methods/ to a
     /class/ that extends it.

   - Thin vs Rich:
     Consider the trade-off between the _implementers_ and the _clients_ of an
     interface.

     + A *rich* interface
       has _MANY_ /methods/, which make it convenient for the _callers (clients)_
       -- they have more chance to find /methods/ that can fit their requirement
       exactly.

     + A *thin* interface,
       on the other hand, has _FEWER_ /methods/, and thus
       * it is easier for the _implementers_ whoes load is light.

       * more work are left for the _clients (clients)_, who call into a *thin*
         interface, however, have to write more code -- comparing the the *rich*
         interface, they have less chance to find /methods/ that can fit their
         requirement exactly -- they can choose to implement the thin interface
         required methods, or write a more fittable one -- either of them require
         their own coding.

   - Unlike in Java, adding a /concrete method/ to a /Scala trait/ is a *one-time
     effort* -- you only need to implement the /method/ once, in the /trait/
     itself, instead of needing to reimplement it for every /class/ that mixes in
     the /trait/.

     Thus, *rich* interfaces are _less_ work to provide in Scala than in a
     language without /traits/.

   - =From Jian=
     The discussion above about "Thin vs Rich" is a discussion in general.
     For Scala, even the /rich interface (trait)/ doesn't add load to the
     _implementer_, a reasonable ~trait~

     + has a *STILL* _small number_ of /abstract methods/ --
       the part the implementer need to finish -- the coding load is still light.

       This is _the (still) thin part_ of the trait's interface

       and

     - defines a potentially _large number_ of /concrete methods/,
       *ALL _implemented in terms of_ the /abstract methods/.*

     - then you can mix the enrichment /trait/ into a /class/, *implement the thin
       portion of the interface*, and end up with a /class/ that has all of the
       rich interface available.

** DONE 12.3 Example: Rectangular objects - 261
   CLOSED: [2017-10-12 Thu 01:21]
** DONE 12.4 The ~Ordered~ trait - 264
   CLOSED: [2017-10-12 Thu 01:38]
   Do comparison manually:

   footnote 1: This example is based on the ~Rational~ class shown in Listing 6.5
   on page 151, with ~equals~, ~hashCode~, and modifications to ensure a
   _positive_ ~denom~ added.
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) {
       def < (that: Rational) =
         this.numer * that.denom < that.numer * this.denom

       def > (that: Rational) = that < this

       def <= (that: Rational) = (this < that) || (this == that)

       def >= (that: Rational) = (this > that) || (this == that)
     }
   #+END_SRC

   Use the ~Ordered~ trait
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) extends Ordered[Rational] {
       //...
       def compare(that: Rational) =
         (this.numer * that.denom) - (that.numer * this.denom)
     }
   #+END_SRC

** DONE 12.5 Traits as stackable modifications - 266 =Re-Read=
   CLOSED: [2017-10-12 Thu 03:04]
   - One major use of traits:
     turning a thin interface into a rich one.

   - Now turn to a second major use of traits:
     providing stackable modifications to classes.

   - Traits let you modify the methods of a class, and they do so in a way that
     allows you to stack those modifications with each other (order matters).

   - As an example,
     _consider stacking modifications to a queue of integers_.

     + Two basic operations to the queue (FIFO):
       * ~put~
       * ~get~

     + Code:
       #+BEGIN_SRC scala
         abstract class IntQueue {
           def get(): Int
           def put(x: Int)
         }

         import scala.collection.mutable.ArrayBuffer

         class BasicIntQueue extends IntQueue {
           private val buf = new ArrayBuffer[Int]
           def get() = buf.remove(0)
           def put(x: Int) = { buf += x }
         }
       #+END_SRC

     + Given a class that implements such a queue, you could define traits to
       perform modifications such as these:
       * ~Doubling~: double all integers that are put in the queue
       * ~Incrementing~: increment all integers that are put in the queue
       * ~Filtering~: filter out negative integers from a queue

       These THREE traits represent /modifications/, because they modify the
       behavior of an underlying queue class rather than defining a full queue
       class themselves.

       The three are also /stackable/ -- you can select any of the three you
       like, mix them into a class, and obtain a new class that has all of the
       modifications you chose.

     + The implementations of three traits.
       #+BEGIN_SRC scala
         trait Doubling extends IntQueue {
           abstract override def put(x: Int) = { super.put(2 * x) }
         }

         trait Incrementing extends IntQueue {
           abstract override def put(x: Int) = { super.put(x + 1) }
         }

         trait Filtering extends IntQueue {
           abstract override def put(x: Int) = {
             if (x >= 0) super.put(x)
           }
         }
       #+END_SRC

       * If a /trait/ extends a class A, _ONLY_ classes that extends A can mix in
         this /trait/. For instance, you can mix ~Doubling~ into ~BasicIntQueue~,
         but NOT into ~Rational~.

       * If a /trait/ can have ~super~ call on a method declared ~abstract~.
         =TODO= =???=
         - Such calls are illegal for normal /classes/ because they will
           certainly fail at run time.
           =From Jian= since the current method ~m~ is ~abstract~, the ~m~
           method of the superclass is also ~abstract~.

         - For a trait, however, since ~super~ calls is dynamically bound, such a
           call can actually succeed.

         In this example the ~super~ call in ~trait Doubling~ will work so long
         as _the trait is mixed in after another trait or class that gives a
         concrete definition to the method_.

         This arrangement is frequently needed with traits that implement stackable
         modifications. To tell the compiler you are doing this on purpose, you
         must mark such methods as ~abstract override~. _This combination of
         modifiers is only allowed for members of traits, not classes_, and it
         means that the trait must be mixed into some class that has a concrete
         definition of the method in question.

     + Run and check the result:
       * Non-stacked
         #+BEGIN_SRC scala
           class MyQueue extends BasicIntQueue with Doubling

           val queue = new MyQueue
           // OR //
           // Use anonymous class `val queue = new BasicIntQueue with Doubling`

           queue.put(10)
           queue.get()
           // 20
         #+END_SRC

       * Stacked
         #+BEGIN_SRC scala
           val queue = (new BasicIntQueue
                            with Incrementing with Filtering)
           queue.put(-1)
           queue.put(0)
           queue.put(1)

           queue.get()
           // Int = 1
           queue.get()
           // Int = 2
         #+END_SRC

       * Stacked (different order)
         #+BEGIN_SRC scala
           val queue = (new BasicIntQueue
                            with Filtering with Incrementing)
           queue.put(-1)
           queue.put(0)
           queue.put(1)

           queue.get()
           // Int = 0
           queue.get()
           // Int = 1
           queue.get()
           // Int = 2
         #+END_SRC

     + Rules (roughly): =TODO= see the next section for details
       + traits further to the right take effect first.
         When you call a method on a class with mixins, the method in the trait
         furthest to the right is called first.

       + If that method calls ~super~, it invokes the method in the next trait to
         its left, and so on.

   - Since _the order of traits is significant_,
     you must keep eyes open for opportunities to arrange code as stackable
     modifications.

   - mixin :: a /trait/ that is _mixed into_ a /class/ (from footnote 2).

** DONE 12.6 Why not multiple inheritance? - 270
   CLOSED: [2018-03-21 Wed 23:13]
   /Traits/ are a way to inherit from multiple class-like constructs, but they
   *differ* in important ways from the /multiple inheritance/ present in many
   languages.

   - One _DIFFERENCE_ is especially important:
     the *interpretation* of ~super~.

   - The precise order of the /linearization/ is described in the *language
     specification*.

   - Example:
     #+BEGIN_SRC scala
       class Animal
       trait Furry extends Animal
       trait HasLegs extends Animal
       trait FourLegged extends HasLegs
       class Cat extends Animal with Furry with FourLegged
     #+END_SRC

     Left to Right:
     1. ~Animal~: ~Animal~ --> ~AnyRef~ --> ~Any~

     2. ~Furry~: ~Furry~ ===> ~Animal~ --> ~AnyRef~ --> ~Any~

     3. ~FourLegged~: ~FourLegged~ --> ~HasLegs~ ===> ~Furry~ ===> ~Animal~ --> ~AnyRef~ --> ~Any~

** DONE 12.7 To trait or not to trait? - 274 =IMPORTANT=
   CLOSED: [2018-03-21 Wed 23:50]
   There is *NO* firm rules about the choice of using /trait/ or /abstract class/
   for a specific use case. ONLY guidelines:

   - If the behavior will _NOT be reused_, then make it a /concrete class/. It
     is not reusable behavior after all.

   - If it might be reused in _multiple, *unrelated* classes_, make it a /trait/.
     Only traits can be mixed into different parts of the class hierarchy.

   - If you want to _inherit from it in Java code_, use an /abstract class/.
     Since traits with code do not have a close Java analog, it tends to be
     *AWKWARD* to _inherit from a trait in a Java class_.

     =TODO= Learn the conversion rules from Scala /trait/ to Java code!!! =TODO=

     Inheriting from a Scala class, meanwhile, is exactly like inheriting from a
     Java class.

     *As one EXCEPTION*,
     _a /Scala trait/ with only abstract members translates directly to a /Java
     interface/_, so you should feel free to define such /traits/ even if you
     expect Java code to inherit from it.
     =TODO= =IMPORTANT=
     See Chapter 31 for more information on working with Java and Scala together.

   - If you plan to _distribute it in compiled form_, and you expect outside groups
     to write classes inheriting from it, you might lean towards using an
     /abstract class/.

     The issue is that when a trait gains or loses a member, any classes that
     inherit from it must be recompiled, even if they have not changed.

     If outside clients will only call into the behavior, instead of inheriting
     from it, then using a trait is fine.

   - *Default Choice* if NOT used in Java code:
     If you _still do not know, after considering the above_,
     then START BY making it as a /trait/.

     You can always change it later, and in general using a /trait/ _keeps more
     options open_.

** DONE 12.8 Conclusion - 275
   CLOSED: [2017-10-12 Thu 03:39]
   _Mix in multiple traits_ are similar to /multiple inheritance/.
   But because /traits/ interpret ~super~ using /linearization/, they both
   + _AVOID_ some of the difficulties of traditional multiple inheritance
     and
   + _ALLOW_ you to stack behaviors.

* DONE 13 Packages and Imports - 276
  CLOSED: [2017-10-21 Sat 17:53]
  Write in a /modular style/ to *minimize coupling*.
  - modular style :: Divide the program into a number of SMALLER /modules/, each of
                     which has an _inside_ and an _outside_.
    + When working on the _inside_ of a /module/ - its _implementation_ - you need
      ONLY coordinate with other programmers working on that very SAME /module/.

    + Only when you must change the _outside_ of a module - its /interface/ - is
      it necessary to coordinate with developers working on OTHER /modules/.

  - =from Jian=
    The ~module~ in Java 9 is a language built-in support for /modular style/.
    However, even without the built-in ~module~ support, write in /modular
    style/ is also possible -- though it may not be concise, clean, and strong.

  - This chapter shows several constructs that help you program in a /modular
    style/:
    + HOW TO place things in /packages/
    + _make names visible_ through /imports/
    + _control the visibility_ of definitions through /access modifiers/

** DONE 13.1 Putting code in packages - 277
   CLOSED: [2019-07-24 Wed 16:26]
   - unnamed package ::
     The example code you've seen so far in this book has been in the
     /unnamed package/.

   - _TWO_ ways to place code into named packages:
     + *ENTIRE FILE* as a /package/:
       The most concise way is to use the ~package~ clause at the top of the
       file.
       #+BEGIN_SRC scala
         package com.bobsrockets.navigation

         class Navigator
       #+END_SRC
       From the outside you can reference ~Navigator~ through
       ~com.bobsrockets.navigation.Navigator~
       =from Jian=
       Another syntax mentioned below is also oKay but not concise for _entire
       file file single package_.

     + NOT ENTIRE FILE packages, more like /C# namespaces/ --
       the /packaging syntax/:
       #+BEGIN_SRC scala
         package com.bobsrockets.navigation {
           class Navigator
         }
       #+END_SRC

   - *Note*
     Follow Java's reverse-domain-name

   - For simple cases, usually choose the /entire file package syntax/.
     However, the /packaging syntax/ is more flexible.

** DONE 13.2 Concise access to related code - 281
   CLOSED: [2019-07-24 Wed 16:26]
   - When code is divided into a package hierarchy, it
     + does NOT ONLY help _PEOPLE_ browse through the code
     + BUT ALSO tells the _COMPILER_ that code in the SAME /package/ is related
       in some way to each other.
         Scala takes advantage of this relatedness by _allowing short,
       unqualified names_ when accessing code that is in the *SAME* /package/.

   - Q :: How to use the /including package/ members with a SHORTER UNQUALIFIED names?

   - A :: Use the nested structure *explicitly*:
     + use nested package syntax ==> Compilable
       #+BEGIN_SRC scala
         package bobsrockets {
           class Ship

           package fleets {
             class Fleet {
               // Compilable! Ship is in scope.
               def addShip = new Ship
             }
           }
         }
       #+END_SRC

     + NOT use nested package syntax ==> NOT compilable --
       same as Java if we put them in separate files (what Java must do):
       #+BEGIN_SRC scala
         package bobsrockets {
           class Ship
         }

         package bobsrockets.fleets {
           class Fleet {
             // Doesn't compile! Ship is not in scope.
             def addShip = new Ship
           }
         }
       #+END_SRC

   - ~_root_~
     =from Jian= Not often used, but should know!!!!! =IMPORTANT=
     #+BEGIN_SRC scala
       // In file launch.scala
       package launch {
         class Booster3
       }

       // In file bobsrockets.scala
       package bobsrockets {
         package navigation {
           package launch {
             class Booster1
           }

           class MissionControl {
             val booster1 = new launch.Booster1
             val booster2 = new bobsrockets.launch.Booster2
             val booster3 = new _root_.launch.Booster3
           }
         }

         package launch {
           class Booster2
         }
       }
     #+END_SRC
     + Q :: Access ~Booster1~ and ~Booster2~ are not tricky, but how about the
            third one ~Booster3~?

     + A :: To help in this situation, Scala provides a /package/ named ~_root_~.
       * ~_root_~ :: a /package/ *outside any package a user can write*.

       * Put another way, *every /top-level package/ you can write is treated as a
         member of /package/ ~_root_~.* For example, both ~launch~ and ~bobsrockets~
         of Listing 13.6 are members of package ~_root_~.
           As a result, ~_root_.launch~ gives you the _top-level_ ~launch~
         /package/, and ~_root_.launch.Booster3~ designates the _outermost_
         ~booster~ /class/.

   - Use /chained packages clauses/ to *avoid the right shift of code of the
     /packaging syntax/.*
     #+BEGIN_SRC scala
       package bobsrockets

       class Ship {}

       package fleets

       class Fleet {
         // No need to say bobsrockets.Ship
         def addShip = new Ship
       }
     #+END_SRC

** DONE 13.3 Imports - 285
   CLOSED: [2019-07-25 Thu 00:39]
   - Simple Example:
     #+BEGIN_SRC scala
       package bobsdelights

       abstract class Fruit(
         val name: String,
         val color: String
       )

       object Fruits {
         object Apple extends Fruit("apple", "red")
         object Orange extends Fruit("orange", "orange")
         object Pear extends Fruit("pear", "yellowish")
         val menu = List(Apple, Orange, Pear)
       }
     #+END_SRC
     + ~import bobsdelights.Fruit~
       corresponds to _Java's single type import_.

     + ~import bobsdelights._~
       corresponds to _Java's on-demand import_.
       The only difference is Scala use ~_~ instead of Java's ~_~.
       (After all, * is a valid identifier in Scala!)

     + ~import bobsdelights.Fruits._~
       This corresponds to _Java's import of /static class/ /fields/._

   - *Scala's flexible imports*
     Scala's import clauses are quite a bit more flexible than Java's.
     There are _3_ principal differences. In Scala, imports:
     + may appear ANYWHERE
     + may refer to ARBITRARY /objects (singleton or regular)/ in addition to
       /packages/. For example,
       #+BEGIN_SRC scala
         def showFruit(fruit: Fruit) = {
           import fruit._
           println(name + "s are" + color)
         }
       #+END_SRC
       The ~name~ and ~color~ above are ~fruit.name~ and ~fruit.color~.
       TODO TODO
       This syntax is particularly useful when you use objects as modules =Chapter 29=
       * =from Jian=
         I didn't notice this before!
         ~import~ can be applied to any /object/, not only the /companion object/!!!
         The code above is a good example!

     + let you _rename_ and _hide_ some of the imported members

   - Import /package/ themselves, not just their _non-package members_:
     #+begin_src scala
       import java.util.regex

       class AStarB {
         // Access java.util.regex.Pattern
         val pat = regex.Pattern.compile("a*b")
       }
     #+end_src
     + This is only natural
       _if you think of /nested packages/ being contained in their /surrounding
       package/._

   - /import selector clause/ -- the part enclosed in braces.
     + ~import Fruits.{Apple, Orange}~

     + ~import Fruits.{Apple => McIntosh, Orange}~
       ~import Fruits.Apple => McIntosh=>~ is a /renaming clause/.

     + ~import Fruits.{Apple}~ is the same as ~import Fruits.Apple~
       The latter can be seen as a special abbreviations of /import clauses/
       with a /selector clause/.

     + ~import Fruits._~.
       Here is a catch-all ~_~

     + ~import Fruits.{Pear => _, _}~
       *Hide* ~Pear~ and import all the other things

** DONE 13.4 Implicit imports - 285
   CLOSED: [2019-07-25 Thu 00:47]
   Scala adds some imports implicitly to every program.
   This is equivalent to add
   #+BEGIN_SRC scala
     import java.lang._ // everything in the java.lang package
     import scala._     // everything in the scala package
     import Predef._    // everything in the Predef object
   #+END_SRC
   on the top of every source file with extension =.scala=

   The order above is important, it implies that *the latter can overshadow the
   former*. For example, ~scala.StringBuilder~ overshadows ~java.lang.StringBuilder~.
   =from Jian= The example itself is important, you'll notice this when you use
   unqualified name ~StringBuilder~ in Scala.

** DONE 13.5 Access modifiers - 286
   CLOSED: [2017-10-21 Sat 17:40]
   _Members_ of /packages/, /classes/, or /objects/ can be labeled with the
   /access modifiers/ ~private~ and ~protected~.

*** DONE Private members
    CLOSED: [2019-07-25 Thu 00:51]
    *MORE _restrictive_ and _consistent_ THAN in Java!*

    A member labeled ~private~ is visible ONLY inside the /class/ or /object/
    that _DIRECTLY contains_ the member definition.
    #+BEGIN_SRC scala
      class Outer {
        class Inner {
          private def f(): Unit = println("f")

          class InnerMost {
            f() // OK
          }
        }
        (new Inner).f() // error: f is not accessible
      }
    #+END_SRC

    - By contrast, in Java, both of the two accesses to the ~f~ /method/ above
      are legal.

*** DONE Protected members
    CLOSED: [2019-07-25 Thu 00:52]
    *More _restrictive_ than in Java!*

    =from Jian= More like all the other languages that have the ~protected~
    modifier.

    #+BEGIN_SRC scala
      package p {
        class Super {
          protected def f() = { println("f") }
        }

        class Sub extends Super {
          f()
        }

        class Other {
          (new Super).f()  // error: f is NOT accessible
        }
      }
    #+END_SRC
    - In Scala, a ~protected~ member is ONLY accessible from /subclasses/ of the
      class in which the member is defined.

    - In Java such accesses are also possible from other classes _in the SAME
      /package/._ Both of the accesses above can succeed in Java.

*** DONE Public members
    CLOSED: [2019-07-25 Thu 00:54]
    Any member with no ~private~ and ~protected~ /modifier/ are /public/.
    There is no ~public~ keyword in Scala.

    - /Public members/ can be accessed from anywhere.
      =from Jian= We still need a /module system/ like Java 9+.

*** DONE Scope of protection
    CLOSED: [2019-07-25 Thu 01:03]
    =from Jian= This title misleading!
                _Scope of qualified modifiers_ is more reasonable!!!

    - Q :: How to get a very fine-grained CONTROL over /visibility/?

    - A :: Use /qualified access modifiers/.

    - /Access modifiers/ in Scala can be *AUGMENTED* with /qualifiers/.
      There is only one _excpetion_ -- ~private[this]~ *shrink the scope*!!!

    - SYNTAX of /modifier qualifiers/: ~private[X]~ and ~protected[X]~
      + The *X* here means *up to X*,
        where *X* designates some *enclosing* /package/, /class/ or /singleton
        object/.

    - /Access modifiers/ *ONLY* can't express some accessibility
      in Java. For example, =IN JAVA=
      + _package private_: ~protected~
      + _package protected_: default
      + _private up to outermost class_: ~private~

    - Use /qualified access modifiers/ *WITH* /qualifiers/
      =IN SCALA=
      + _package private_: ~private[packageName]~
      + _package protected_: ~protected[packageName]~
      + _private up to outermost class_: ~private[OutermostClass]~

    - /Qualified access modifiers/ can express *more* accessibility than
      in Java.

    - The same technique is *NOT possible* in Java.

      _There, once a definition escapes its IMMEDIATE /package/ BOUNDARY,
      it is visible to the world at large._
      + =from Jian= This is why Java 9 introduces a built-in /module system/.

      + =from Jian= However, comparing to the formal Java 9+ the built-in /module
                    systems/, when will Scala support the /module system/??

      + =from Jian= I remember Scala 3 has ~export~?? TODO TODO TODO

    - Example:
      #+BEGIN_SRC scala
        package bobsrockets

        package navigation {
          private[bobsrockets] class Navigator {
            protected[navigation] def useStarChart() = {}

            class LegOfJourney {
              private[Navigator] val distance = 100
            }

            private[this] var speed = 200
          }
        }

        package launch {
          import navigation._
          object Vehicle {
            private[launch] val guide = new Navigator
          }
        }
      #+END_SRC
      Table 13.1 - Effects of ~private~ qualifiers on ~LegOfJourney.distance~
      + no access modifier:      public access
      + ~private[bobsrockets]~:  access within outer package
      + ~private[navigation]~:   same as package visibility in Java
      + ~private[Navigator]~:    same as ~private~ in Java
      + ~private[LegOfJourney]~: same as ~private~ in Scala
      + ~private[this]~:         access only from same object

    - ALL /qualifiers/ can also be applied to ~protected~, with the same meaning
      as ~private~.
      + ~protected[X]~ in a /class/ _C_ allows
        * access to the labeled definition in ALL /subclasses/ of _C_
          and
        * also within the *enclosing* /package/, /class/, or /object/ _X_.

        =from Jian= Yes! The augmentation of the scope (the 2nd point above) is
        not along the inheritance chain only.
          Actually, the /qualifier/ is only about the enclosing structures,
        only the the /modifier/ can represent other meanings -- like ~protected~
        itself is related to inheritance only, but ~protected[X]~ is related to
        inheritance, but not "ONLY".

          For instance, the ~useStarChart~ /method/ in Listing 13.12 is accessible
        in ALL /subclasses/ of ~Navigator~ and also in ALL code contained in the
        *enclosing* /package/ ~navigation~ -- it thus corresponds exactly to the
        _meaning of ~protected~ in Java_.

    - ~private[this]~ is called /object-private/.

*** DONE Visibility and companion objects
    CLOSED: [2019-05-27 Mon 02:01]
    - In Java, /static members/ and /instance members/ belong to the SAME /class/,
      so /access modifiers/ apply *uniformly* to them.

      In Scala there are no /static members/; instead you can have a /companion
      object/ that contains members that exist only once.
      #+begin_src scala
        class Rocket {
          import Rocket.fuel
          private def canGoHomeAgain = fuel > 20
        }

        object Rocket {
          private def fuel = 10

          def chooseStrategy(rocket: Rocket): Unit = {
            if (rocket.canGoHomeAgain)
              goHome()
            else
              pickAStar()
          }

          def goHome(): Unit = {}

          def pickAStar(): Unit = {}
        }
      #+end_src

    - Scala's access rules *privilege* /companion objects and classes/ when it
      comes to ~private~ or ~protected~ accesses.
        A /class/ *shares* ALL its ACCESS RIGHTS with its /companion object/ and
      _vice versa_.
        In particular, an /object/ can access *ALL* ~private~ members of its
      /companion class/, just as a /class/ can access *ALL* ~private~ members of
      its /companion object/.

    - One *exception* where the similarity between Scala and Java _breaks down_
      concerns ~protected static~ members.
      + In Java A ~protected static~ member of a /class/ C can be accessed in ALL
        /subclasses/ of C.

      + In Scala, a /protected member/ in a /companion object/ _makes no sense_,
        as /singleton objects/ do *NOT have any* /subclasses/.

      + =from Jian= TODO TODO TODO =READ!!!=
        * https://stackoverflow.com/questions/4445617/calling-a-protected-static-java-method-from-scala
        * https://github.com/scala/bug/issues/1806

** DONE 13.6 Package objects - 291
   CLOSED: [2019-07-25 Thu 01:28]
   - *ANY* kind of definition that you can put inside a /class/ can also be at
     the top level of a /package/.

     + Q: How to do it?

     + A: put the definitions in a /package object/.

   - Each /package/ is allowed to have one /package object/.
     Any definitions placed in a /package object/ are considered members of the
     /package/ itself.

   - Example:
     + In file =bobsdelights/package.scala=
       #+BEGIN_SRC scala
         package object bobsdelights {
           def showFruit(fruit: Fruit) = {
             import fruit._
             println(name + "s are " + color)
           }
         }
       #+END_SRC

     + In file =PrintMenu.scala=
       #+BEGIN_SRC scala
         package printmenu
         import bobsdelights.Fruits
         import bobsdelights.showFruit
         object PrintMenu {
           def main(args: Array[String]) = {
             for (fruit <Fruits.
                  menu) {
               showFruit(fruit)
             }
           }
         }
       #+END_SRC

   - /Package objects/ are frequently used to hold
     + package-wide /type aliases/ (Chapter 20)
     + /implicit conversions/ (Chapter 21).

   - =from Jian=
     I tried to add new types into /package objects/, and the IDE suggested me
     NOT do that!

   - =from Jian=
     TODO Read the other people's /package objects/ to learn

   - The top-level ~scala~ package has a /package object/, and its definitions
     are available to all Scala code.

   - /Package objects/ are compiled to /class files/ named ~package.class~ that are
     located in the directory of the /package/ that they augment.

     It's useful to _keep the same convention_ for source files.
     So you would typically put the source file of the /package object/
     ~bobsdelights~ of Listing 13.14 into a file named =package.scala= that
     resides in the ~bobsdelights~ directory.

     + =from Jian= This convention is NOT followed by Scala standard library (I
       read some of them in details) -- it use the pattern of =<package>.scala=,
       rather than =package.scala=.

** DONE 13.7 Conclusion - 293
   CLOSED: [2019-07-25 Thu 01:30]
   Scala's system is _the same in spirit as Java's_ packages, but there are some
   differences where Scala chooses to be _more consistent or more general_.

* DONE 14 Assertions and Tests - 294 - _No details in this book!!!_
  CLOSED: [2018-04-10 Tue 22:20]
  /Assertions/ and /tests/ are *two* important ways you can check that the software
  you write behaves as you expect.

** DONE 14.1 Assertions - 294
   CLOSED: [2017-10-23 Mon 12:52]
   - ~assert(condition)~ throws an ~AssertionError~
     if condition does *NOT* hold.

   - Footnote 1: ~assert~ is defined in the ~Predef~ /singleton object/.

   - There's also a two-argument version of ~assert~:
     ~assert(condition, explanation)~,
     where ~explanation~ is of type ~Any~.

     If the ~condition~ does *NOT* hold, throws an ~AssertionError~ that contains
     the given the string form of the ~explanation~ -- before putting it into the
     ~AssertionError~, automatically call ~toString~ on it first.

   - Example:
     #+BEGIN_SRC scala
       def above(that: Element): Element = {
         val this1 = this widen that.width
         val that1 = that widen this.width
         assert(this1.width == that2.width)
         elem(this1.contents ++ that1.contents)
       }
     #+END_SRC

   - ~ensuring~
     Example:
     #+BEGIN_SRC scala
       private def widen(w: Int): Element =
         if (w <= width)
           this
         else {
           val left = elem(' ', (w - width) / 2, height)
           val right = elem(' ', w - width - left.width, height)
           left beside this beside right
         } ensuring (w <= _.width)
     #+END_SRC
     The ~ensuring~ /method/ is called on a /implicitly conversion/ of the
     ~Element~ value, rather than the ~Element~ value itself.

     If the passed in predicate return ~true~, *return* the result;
     otherwise, ensuring will *throw* an ~AssertionError~.

   - Enable and disable /assertions/ in JVM:
     use the =-ea= and =-da= flags respectively.

   - In the remainder of this chapter, we'll focus on the writing of /external
     tests/, which provide their own test data and run independently from the
     application.

** DONE 14.2 Testing in Scala - 296
   CLOSED: [2017-10-23 Mon 15:23]
   - A quick tour of these tools:
     + in Java:
       * JUnit
       * TestNG

     + in Scala:
       * ScalaTest
       * specs2
       * ScalaCheck

   - suite :: a collection of tests.

   - /suite/ is the /central concept/ in /ScalaTest/.

   - /Trait/ ~Suite~ is the _central unit_ of *composition* in ~ScalaTest~.

     ~Suite~ declares "lifecycle" /methods/ defining _a default way to run tests_,
     which can be *overridden* to customize how tests are written and run.

   - test :: anything with a name that can start and either
     + succeed
     + fail
     + be pending
     + be cancled.

   - You usually don't use ~Suite~ directly.
       ~ScalaTest~ offers /style traits/ that *extend* ~Suite~ and *override*
     /lifecycle methods/ _to support different testing styles_.

   - ~ScalaTest~ also provides /mixin traits/ that *override* /lifecycle methods/
     to address particular testing needs.

   - In ScalaTest, there are my styles you can use to write you tests.
     You can choose a style with its specific /style trait/.
     The names of the /style traits/ are in the pattern of ~<StyleName>Suit~.

   - Start with /ScalaTest/, which is the most flexible -- teams can use whatever
     testing style fits their needs best.
     + for teams familar with /JUnit/, they can use ~FunSuite~ style.
       #+BEGIN_SRC scala
         import org.scalatest.FunSuite
         import Element.elem

         class ElementSuite extends FunSuite {
           test("elem result should have passed width") {
             val ele = elem('x', 2, 3)
             assert(ele.with == 2)
           }
         }
       #+END_SRC

   - =IMPORTANT=
     Define /test classes/ by *composing* /style traits/ and /mixin traits/.
     Define /test suites/ by *composing* ~Suite~ instances.

   - ~FunSuite~ is a /style trait/, and the "Fun" stands for "function".

   - ~test~ is a /method/ defined in ~FunSuite~, which is invoked by the /primary
     constructor/ of ~ElementSuite~.

   - The _test code_ is a /function/ passed as a by-name parameter to ~test~, which
     registers it for later execution.
     =From Jian=
     #+BEGIN_SRC scala
       protected def test(testName: String, testTags: Tag*)
                         (testFun: => Any /* Assertion*/)
                         (implicit pos: source.Position): Unit
     #+END_SRC

   - =TODO= DETAILS????
     ~ScalaTest~ is integrated into common build tools (such as /sbt/ and
     /Maven/) and IDEs (such as /IntelliJ IDEA/ and /Eclipse/).

   - You can run a ~Suite~ directly via ~ScalaTest~'s ~Runner~ application
     =TODO=

     or

     from the Scala interpreter simply by invoking ~execute~ on it.
     For example,
     #+BEGIN_SRC scala
       scala> (new ElementSuite).execute()
       // ElementSuite:
       // - elem result should have passed width
     #+END_SRC

   - The style you choose dictates _ONLY_
     how the declarations of your tests will _look_.

     _Everything else_ in ~ScalaTest~ works consistently the *same* way no matter
     what style you choose.

** DONE 14.3 Informative failure reports - 297
   CLOSED: [2017-10-23 Mon 22:36]
   - ~assert~ error message example:
     #+BEGIN_SRC scala
       val width = 3
       // width: Int = 3

       assert(width == 2)
       // org.scalatest.exceptions.TestFailedException:
       //     3 did not equal 2
     #+END_SRC

   - Use ~DiagrammedAssertions~, whose error messages display a diagram of the
     expression passed to ~assert~.
     =From Jian= I'm not sure, but _I think_ there is an /implicit conversion/.
     #+BEGIN_SRC scala
       import DiagrammedAssertions._

       assert(List(1, 2, 3).contains(4))
       // org.scalatest.exceptions.TestFailedException:
       //     assert(List(1, 2, 3).contains(4))
       //            | | | | | |
       //            | 1 2 3 false 4
       //            List(1, 2, 3)
     #+END_SRC

   - ScalaTest's ~assert~ methods do NOT differentiate between the _actual_ and
     _expected_ result in error messages. It only shows what is the left hand
     side, and what is the right hand side.

   - Use ~assertResult~ Clarify what is the _expected_ and what is the real _result_.
     #+BEGIN_SRC scala
       assertResult(2) {
         ele.width
       }
     #+END_SRC
     If ~ele.width~ is 3, you'll see an error message like
     ="Expected 2, but got 3"=

   - Check /exceptions/ type:
     #+BEGIN_SRC scala
       assertThrows[IllegalArgumentException] {
         elem('x', -2, 3)
       }
     #+END_SRC
     The error message is like:
     #+BEGIN_SRC text
       Expected IllegalArgumentException to be thrown,
         but NegativeArraySizeException was thrown.
     #+END_SRC

   - Intercept /exception/ to use:
     #+BEGIN_SRC scala
       val caught =
         intercept[ArithmeticException] {
           1 / 0
         }

       assert(caught.getMessage == "/ by zero")
     #+END_SRC
     The ~intercept~ /method/ works the *same* as ~assertThrows~,
     *except* if the _expected exception_ is thrown,

   - =From Jian=
     Here ~assert~, ~assertResult~, ~assertThrows~, and ~intercept~ comes from
     the /trait/ ~Assertions~ -- the /supertrait/ of ~Suite~.

** DONE 14.4 Tests as specifications - 299
   CLOSED: [2018-04-10 Tue 02:36]
   - In the /behavior-driven development (BDD)/ _testing style_, the emphasis is
     on
     1. writing human-readable specifications of the expected behavior of code;

     2. accompanying tests that verify the code has the specified behavior.

   - /ScalaTest/ includes several /traits/ that facilitate BDD style of testing.

     An example using one such /trait/, ~FlatSpec~, is shown in Listing 14.4.

     =TODO= =TODO= =TODO= =TODO= =TODO= =TODO=

     #+BEGIN_SRC scala
       import org.scalatest.FlatSpec
       import org.scalatest.Matchers
       import Element.elem


       class ElementSpec extends FlatSpec with Matchers {

         "A UniformElement" should
         "have a width equal to the passed value" in {
           val ele = elem('x', 2, 3)
           ele.width should be (2)
         }

         it should "have a height equal to the passed value" in {
           val ele = elem('x', 2, 3)
           ele.height should be (3)
         }

         it should "throw an IAE if passed a negative width" in {
           an [IllegalArgumentException] should be thrownBy {
             elem('x', -2, 3)
           }
         }
       }
     #+END_SRC
     + This illustrates ScalaTest's /matchers/ domain-specific language (DSL).

     + By mixing in /trait/ ~Matchers~,
       you can write assertions that read _more like natural language_.

     + If you prefer ~must~ than ~should~, you can mix in ~MustMatchers~ instead.
       Then, you can write code like:
       ~result must be >= 0~ and ~map must contain key 'c'~

       If the last assertion failed, you'd see an error message similar to:
       ~Map('a' -> 1, 'b' -> 2) did not contain key 'c'~

   - The /spec2/ testing framework also support the BDD style but with a
     different syntax.
     #+BEGIN_SRC scala
       import org.specs2._
       import Element.elem

       object ElementSpecification extends Specification {
         "A UniformElement" should {
           "have a width equal to the passed value" in {
             val ele = elem('x', 2, 3)
             ele.width must be_==(2)
           }
           "have a height equal to the passed value" in {
             val ele = elem('x', 2, 3)
             ele.height must be_==(3)
           }
           "throw an IAE if passed a negative width" in {
             elem('x', -2, 3) must
             throwA[IllegalArgumentException]
           }
         }
       }
     #+END_SRC
     + Here is the /specs2/ matchers DSL.

     + /specs2/ can be used alone, but it is also integrated with /ScalaTest/ and
       /JUnit/, so _you can run /specs2/ tests with those tools as well_.

   - Although any of /ScalaTest/'s or /specs2/'s sytels can be used in the BDD
     maner, /ScalaTest/'s ~FeatureSpec~ in particular is designed for it.
     #+BEGIN_SRC scala
       import org.scalatest._

       class TVSetSpec extends FeatureSpec with GivenWhenThen {

         feature("TV power button") {
           scenario("User presses power button when TV is off") {
             Given("a TV set that is switched off")
             When("the power button is pressed")
             Then("the TV should switch on")
             pending
           }
         }

       }
     #+END_SRC
     + ~FeatureSpec~ is designed to guide conversations about software
       requirements: You must
       1. identify specific features

       2. then specify those features in terms of ~scenario~'s.

       3. The ~Given~, ~When~, and ~Then~ /methods/ (provided by trait
          ~GivenWhenThen~) can help focus the conversation on the specifics of
          individual ~scenario~'s.

       4. The ~pending~ call at the end indicates that _neither the test nor the
          actual behavior has been implemented_ -- just the specification.
            Once all the tests and specified behavior have been implemented, the
          tests will pass and the requirements can be deemed to have been met.
          =TODO= =???= =I don't understand= =!!!=

** DONE 14.5 Property-based testing - 302
   CLOSED: [2018-04-10 Tue 03:10]
   /ScalaCheck/ enables you to _specify_ /properties/ that the code under test
   _must obey_.
     For each /property/, /ScalaCheck/ will *generate* data and execute
   assertions that the check wheter the property holds.

   - Example:
     =TODO= I can't see /ScalaCheck/ below, though the book says this example
     uses it. =TODO= Find out which part??? Does this mean /ScalaTest/ depends
     on /ScalaCheck/.

     #+BEGIN_SRC scala
       import org.scalatest.WordSpec
       import org.scalatest.prop.PropertyChecks
       import org.scalatest.MustMatchers._
       import Element.elem


       class ElementSpec extends WordSpec with PropertyChecks {
         "elem result" must {
           "have passed width" in {
             forAll { (w: Int) =>
               whenever (w > 0) {
                 elem('x', w, 3).width must equal (w)
               }
             }
           }
         }
       }
     #+END_SRC
     + ~WordSpec~ is a /ScalaTest/ /style class/.

     + The ~PropertyChecks~ /triat/ provides several ~forAll~ /methods/ that
       _allow you to mix property-based test with traditional assertion-based or
       matcher-based tests._

     + /ScalaCheck/ /properties/ are expressed as /function values/ that take
       _as parameters_ the data needed by the property's assertions. This *data*
       will be _generated by_ /ScalaCheck/.
       * data:  an integer named ~w~ that represents a _width_.

       * Inside the body of the function, you see this code:
         #+BEGIN_SRC scala
           whenever (w > 0) {
             elem('x', w, 3).width must equal (w)
           }
         #+END_SRC

   - With small amount of code like in the example above, /ScalaCheck/ will
     generate hundreds of ~w~ values and test each one.

   - If /property tests/ fail, you'll see an /exception/ ~TestFailedException~
     that contains information including the value that caused the failure.

** DONE 14.6 Organizing and running tests - 304
   CLOSED: [2018-04-10 Tue 22:20]
   Each framework mentioned in this chapter provides _some mechanism for
   *organizing* and *running* tests._

   - In this section, we'll give a quick overview of /ScalaTest/'s approach.
     _More details in their documents_

   - In /ScalaTest/, you organize large test suites by _nesting *Suite*'s inside
     *Suite*'s._

     + When a ~Suite~ is executed,
       it will execute its nested ~Suite~'s as well as its tests. The nested
       ~Suite~'s will in turn execute their nested ~Suite~'s, and so on.

     + A large test /suite/, therefore, is represented as a tree of ~Suite~
       objects. When you execute the root ~Suite~ in the tree, all ~Suite~'s in
       the tree will be executed.

   - You can *nest* /suites/ _manually_ or _automatically_.

     + Nest manually:
       you either override the ~nestedSuites~ /method/ on your ~Suite~'s or pass
       the ~Suite~'s you want to nest to the constructor of class ~Suite~'s, which
       /ScalaTest/ provides for this purpose.
       =TODO= =Details???=

     + To nest automatically:
       you provide package names to ScalaTest's ~Runner~, which will discover
       ~Suite~'s automatically, nest them under a root ~Suite~, and execute the
       root ~Suite~.
       =TODO= =Details???=

   - You can invoke /ScalaTest/'s ~Runner~ application

     + _from the command line_:
       The simplest way to invoke ~Runner~ on the command line is via the
       ~org.scalatest.run~ application. This application expects a fully
       qualified test class name. For example, to run the test class shown in
       Listing 14.6, you must compile it with:
       1. Compile: ~scalac -cp scalatest.jar TVSetSpec.scala~

       2. Run it with: ~scala -cp scalatest.jar org.scalatest.run TVSetSpec~

          * With ~-cp~ you place /ScalaTest/'s JAR file on the /class path/.

          * The next token, ~org.scalatest.run~, is the fully qualified
            application name. Scala will run this application and pass the
            remaining tokens as command line arguments.

            The ~TVSetSpec~ argument specifies the /suite/ to execute.

     + _via a build tool_, such as /sbt/, /maven/, or /ant/.
       =TODO= Not mentioned in this book!

** DONE 14.7 Conclusion - 305
   CLOSED: [2018-04-10 Tue 03:17]
   - In this chapter you saw examples of
     + mixing assertions directly in production code;

     + writing them externally in tests.

* TODO 15 Case Classes and Pattern Matching - 306
** DONE 15.1 A simple example - 306
   CLOSED: [2017-10-21 Sat 20:08]
*** DONE Case classes
    CLOSED: [2017-10-21 Sat 20:04]
    - footnote 1: Modeling the root of a class hierarchy as an ~abstract class~
      may be slightly more efficient.
      =TODO= =???=

    - Example:
      #+BEGIN_SRC scala
        abstract class Expr
        case class Var(name: String) extends Expr
        case class Number(num: Double) extends Expr
        case class UnOp(operator: String, arg: Expr) extends Expr
        case class BinOp(operator: String,
                         left: Expr, right: Expr) extends Expr
      #+END_SRC

    - Conveniences:
      + a ~apply~ method is automatically implemented -- create a new instance
        with ~new~.

      + all arguments in the parameter list of a /case class/ implicitly get a
        ~val~ prefix, so they are maintained as fields.

      + a ~copy~ method is automatically implemented -- you can use it to create
        a similar object:
        #+BEGIN_SRC scala
          val op = BinOp("+", Number(1.0), Var(x))

          op.copy(operator = "-")
          // BinOp("-", Number(1.0), Var(x))
        #+END_SRC

*** DONE Pattern matching
    CLOSED: [2017-10-21 Sat 20:08]
    If there is NO /pattern matching/, try to imagine match
    ~UnOp("-", UnOp("-", e))~. The method you can use now is:
    + write this match in /visitor design pattern/.
    + use embeded ~if ... else~'s.

*** DONE ~match~ compared to ~switch~
    CLOSED: [2017-10-21 Sat 19:53]
    - There are three differences to keep in mind:
      + ~match~ is an /expression/ in Scala (i.e., it always results in a value).
      + Scala's alternative expressions _NEVER_ /fall through/ into the next case.
        =From Jian= How about if I want /fall through/ in some low-level cases???
        =TODO=

      + if none of the patterns match, an exception named ~MatchError~ is thrown.
        This means you always have to make sure that all cases are covered, even
        if it means adding a default case where there's nothing to do.

    - Example (the value can be generated if the second pattern matchs ~()~):
      #+BEGIN_SRC scala
        expr match {
          case BinOp(op, left, right) =>
            println(expr + " is a binary operation")
          case _ =>
        }
      #+END_SRC

    - Apply ~@swtich~ to switch-like ~match~ (only /constant patterns/), and this
      ~match~ expression will be optimized.

** DONE 15.2 Kinds of patterns - 311
   CLOSED: [2017-10-21 Sat 19:34]
*** DONE Wildcard patterns
    CLOSED: [2017-10-21 Sat 19:09]
    ~_~

*** DONE Constant patterns
    CLOSED: [2017-10-21 Sat 19:09]
    _A /constant pattern/ matches only itself._
    It includes:
    + any literal
    + any ~val~
    + any singleton object

*** DONE Variable patterns
    CLOSED: [2017-10-21 Sat 19:19]
    - A /variable pattern/ matches any object, just like a /wildcard/, but with
      bind it.

    - pattern variable :: A simple name _starting with a lowercase letter_.

    - How to use a starting-with-a-lowercase-letter name as /constant pattern/:
      + with qualifiers -- ~this.pi~ is a /constant pattern/, and ~pi~ is NOT.
      + use back-tick to quote it -- ~`pi`~ is a /constant pattern/.

    - Recall the usage of back-ticks. All its usages are for some special cases:
      + Section 6.10, use a word as identifier rahter than a keyword.
        ~Thread.`yield`()~

      + use a starting-with-a-lowercase-letter name as /constant pattern/

*** DONE Constructor patterns
    CLOSED: [2017-10-21 Sat 19:20]
*** DONE Sequence patterns
    CLOSED: [2017-10-21 Sat 19:21]

    =IMPORTANT=
    If you want to match against a sequence without specifying how long it can
    be, you can specify ~_*~ as the last element of the pattern.
    #+BEGIN_SRC scala
      expr match {
        case List(0, _*) => println("found it")
        case _ => //...
      }
    #+END_SRC

*** DONE Tuple patterns
    CLOSED: [2017-10-21 Sat 19:22]
*** DONE Typed patterns
    CLOSED: [2017-10-21 Sat 19:22]
    #+BEGIN_SRC scala
      def generalSize(x: Any) = x match {
        case s: String => s.length
        case m: Map[_, _] => m.size
        case _ => 1
      }
    #+END_SRC

    - As you will have noted by now, writing type tests and casts is rather
      verbose in Scala. That's intentional because it is not encouraged practice.
      #+BEGIN_SRC scala
        // Test
        expr.isInstanceOf[String]

        // Cast
        expr.asInstanceOf[String]
      #+END_SRC

    - Due to /type erasure/, you CANNOT do /typed patterns/ match with the type
      information of generics like ~Map[Int, Int]~.
      =From Jian= Hope this can be changed in the future Java 10.

      If you do this,
      + when compile, there will be a warning.
      + when run, there can be wrong results (~Map("abc"->"abc")~ can match a
        pattern typed ~Map[Int, Int]~).

    - _One Exception_:
      You can use /typed patterns/ with exact info about arrays like ~Array[Int]~

*** DONE Variable binding
    CLOSED: [2017-10-21 Sat 19:34]
    Use ~@~ to bind a entire pattern and its inner structures.
    For example,
    #+BEGIN_SRC scala
      expr match {
        case UnOp("abc", e @ UnOp("abs", _)) => e
        case _ => //...
      }
    #+END_SRC

** DONE 15.3 Pattern guards - 320
   CLOSED: [2017-10-21 Sat 19:36]
   #+BEGIN_SRC scala
     def simplifyAdd(e: Expr) = e match {
       case BinOp("+", x, x) => BinOp("*", x, Number(2))
       case _ => e
     }

     // <console>:14: error: x is already defined as value x
     //          case BinOp("+", x, x) => BinOp("*", x, Number(2))
   #+END_SRC

   This fails because Scala restricts patterns to be linear:
   _a pattern variable may only appear once in a pattern_.

   Use /guard/ to solve this problem.

** DONE 15.4 Pattern overlaps - 321
   CLOSED: [2017-10-21 Sat 19:44]
   - Patterns are tried in the order in which they are written.

   - Catch-all patterns should be after more specific patterns.

   - Unreachable patterns will trigger warnings.

   =From Jian=
   1. The latter patterns include the former patterns can be resonable and clear,
      though they should be arranged in right order.

   2. "Not including, only intersection" is NOT reasonable. I can't imagine when
      can I apply this kind of patterns.

** DONE 15.5 Sealed classes - 323
   CLOSED: [2017-10-21 Sat 20:12]
** DONE 15.6 The ~Option~ type - 325
   CLOSED: [2017-10-21 Sat 20:16]
   Suppose ~Option[T]~ has two values:
   - ~Some(x)~ where ~x~ is of type ~T~
   - ~None~

   Why the ~None~ of ~Option[T]~ type is better than ~null~:
   + ~Option[T]~ is explicit: ~Some("aString")~ and ~None~ is much clearer than
     ~"aString"~ and ~null~. Though syntactically ~null~'s type is a subtype of
     ~String~, semantically ~null~ is nothing (NOT a string).

   + ~None~ won't propagate like ~null~.
     /Flunet style/ can be used to process a ~Option[T]~ type value. The methods
     can be used to process a ~Option[T]~ value always include a mechanism to
     process ~None~ properly.

   + The type system can help you managing values of ~Option[T]~ types, but not
     ~null~, which is always a legal value for all reference types.

** DONE 15.7 Patterns everywhere - 327
   CLOSED: [2017-10-23 Mon 23:25]
*** DONE Patterns in variable definitions
    CLOSED: [2017-10-23 Mon 22:39]
    #+BEGIN_SRC scala
      val myTuple = (123, "abc")
      val (number, string) = myTuple

      val exp = new BinOp("*", Number(5), Number(1))
      val BinOp(op, left, right) = exp
    #+END_SRC

*** DONE Case sequences as partial functions
    CLOSED: [2017-10-23 Mon 23:22]
    A /sequence of cases/ (i.e., alternatives) in curly braces can be used
    ANYWHERE a /function literal/ can be used. Essentially, a case sequence is a
    /function literal/, only more general (multiple entrances).

    - Only indicate the type doesn't tell the compiler a /partial function/
      exists. Use ~PartialFunction~. For example,
      #+BEGIN_SRC scala
        val second: PartialFunction[List[Int], Int] = {
          case x :: y :: _ => y
        }
      #+END_SRC

    - Stackoverflow (=From Jian=):
      why scala doesn't have a built-in ~PartialFunctionN~?

    - Use the ~isDefineAt~ method (of a type ~PartialFunction~ value) and a input
      pattern to check if a pattern is supported by a /partial function/.
      #+BEGIN_SRC scala
        second.isDefineAt(List(5, 6, 7))
        // true

        second.isDefineAt(List())
        // false
      #+END_SRC

    - What does scala do to a /partial function/ definition?
      ~second~ is translated to
      #+BEGIN_SRC scala
        new PartialFunction[List[Int], Int] {
          def apply(xs: List[Int]) = xs match {
            case x :: y :: _ => y
          }

          def isDefinedAt(xs: List[Int]) = xs match {
            case x :: y :: _ => true
            case _ => false
          }
        }
      #+END_SRC

      This translation takes effect _whenever_ the declared type of a function
      literal is ~PartialFunction~.

      If the declared type is just ~Function1~, or is missing, the /function
      literal/ is instead translated to a /complete function/.

    - Of course, you should work with /complete functions/ whenever possible,
      because /partial functions/ allow for runtime errors that the compiler
      cannot help you with.

      However,
      + there are context that you know some patterns will never show up, and
        then you /partial functions/.

      + Alternatively, you might be using a framework that expects /partial
        functions/ and so will always check ~isDefinedAt~ before calling the
        function.

*** DONE Patterns in ~for~ expressions
    CLOSED: [2017-10-23 Mon 23:25]
    A good feature: patterns which are NOT matched will be discard directly.
    #+BEGIN_SRC scala
      val results = List(Some("apple"), None, Some("orange"))

      for (Some(fruit) <- results) println(fruit)
    #+END_SRC

** TODO 15.8 A larger example - 331
** DONE 15.9 Conclusion - 339
   CLOSED: [2017-10-23 Mon 23:28]
   - If you want to use /pattern matching/ on one of your classes, but you do NOT
     want to open access to your classes the way /case classes/ do, you can use
     the /extractors/ described in Chapter 26.
     =TODO=

* DONE 16 Working with Lists - 340
  CLOSED: [2018-11-25 Sun 16:22]
** DONE 16.1 ~List~ literals - 340
   CLOSED: [2017-10-24 Tue 01:16]
** DONE 16.2 The ~List~ type - 341
   CLOSED: [2017-10-24 Tue 01:24]
   - Lists are /homogeneous/.

   - The list type in Scala is /covariant/.

     /convariant/ for /list types/ means:
     Two types ~S~ and ~T~. If ~S~ is a subtype of ~T~, then ~List[S]~ is a
     subtype of ~List[T]~.

   - Since the /convariant/ property, ~List()~ is of type ~List[Nothing]~.

   - Because lists are /covariant/, it follows that ~List[Nothing]~ is a subtype
     of ~List[T]~ for ANY type ~T~.

     This is why /empty list/ ~List()~ is of type ~List[Nothing]~,
     though it is permissible to write code like:
     ~val xs: List[String] = List()~

** DONE 16.3 Constructing lists - 341
   CLOSED: [2017-10-24 Tue 01:44]
   Empty list ~Nil~ and an infix operator ~::~
** DONE 16.4 Basic operations on lists - 342
   CLOSED: [2017-10-24 Tue 01:45]
   - ~head~

   - ~tail~

   - ~isEmpty~

** DONE 16.5 ~List~ patterns - 343
   CLOSED: [2017-10-24 Tue 01:46]
** DONE 16.6 First-order methods on class ~List~ - 345
   CLOSED: [2018-03-28 Wed 23:12]
   - first-order method :: a method that does not take any functions as arguments

*** DONE Concatenating two lists
    CLOSED: [2017-10-24 Tue 01:48]
    ~:::~

*** DONE The Divide and Conquer principle
    CLOSED: [2017-10-24 Tue 01:49]
*** DONE Taking the length of a list: ~length~
    CLOSED: [2017-10-24 Tue 01:49]
*** DONE Accessing the end of a list: ~init~ and ~last~
    CLOSED: [2017-10-24 Tue 01:49]
*** DONE Reversing lists: ~reverse~
    CLOSED: [2017-10-24 Tue 01:52]
    =TODO= PAGE 363

*** DONE Prefixes and suffixes: ~drop~, ~take~, and ~splitAt~
    CLOSED: [2017-10-24 Tue 01:54]
    ~xs splitAt n~ equals ~(xs take n, xs drop n)~
    However, ~splitAt~'s implementation AVOIDS traversing the list xs twice.

*** DONE Element selection: ~apply~ and ~indices~
    CLOSED: [2017-10-24 Tue 01:57]
    - ~abcde apply 2~ results in ~'c'~.
      ~apply~ is rarely used explicitly.
      ~abcde(2)~ is the often used form.

      ~xs apply n~ equals ~(xs drop n).head~

    - ~abcde.indices~ is ~scala.collection.immutable.Range(0, 1, 2, 3, 4)~

*** DONE Flattening a list of lists: ~flatten~
    CLOSED: [2017-10-24 Tue 01:58]
    ~List(List(1, 2), List(3), List(), List(4, 5)).flatten~ is
    ~List(1, 2, 3, 4, 5)~

*** DONE Zipping lists: ~zip~ and ~unzip~
    CLOSED: [2017-10-24 Tue 02:05]
    - ~zip~:
      ~abcde.indices zip abcde~ is of type
      ~scala.collection.immutable.IndexedSeq[(Int, Char)]~.

      Its value is ~Vector((0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e'))~

    - ~zipWithIndex~:
      ~abcde.zipWithIndex~ is of type
      ~List[(Char, Int)]~

      Its value is ~List(('a', 0), ('b', 1), ('c', 2), ('d', 3), ('e', 4))~

    - ~unzip~:
      ~zipped.unzip~ is of type
      ~(List[Char], List[Int])~

      Its value is ~(List('a', 'b', 'c'), List(1, 2, 3))~

*** DONE Displaying lists: ~toString~ and ~mkString~
    CLOSED: [2017-10-24 Tue 02:11]
    - ~xs mkString sep~ equals ~xs mkString ("", sep, "")~
      ~xs.mkString~ equals ~xs mkString ""~

    - ~scala.StringBuilder~ is NOT ~java.lang.StringBuilder~
      #+BEGIN_SRC scala
        val buf = new StringBuilder
        // buf: StringBuilder =

        abcde addString (buf, "(", ";" ,")")
        // StringBuilder = (a;b;c;d;e)
      #+END_SRC

    - The ~mkString~ and ~addString~ methods are inherited from ~List~'s
      /super trait/ ~Traversable~, so they are applicable to all other
      collections as well.

*** DONE Converting lists: ~iterator~, ~toArray~, ~copyToArray~
    CLOSED: [2017-10-24 Tue 02:17]
    #+BEGIN_SRC scala
      val arr = abcde.toArray
      // arr: Array[Char] = Array(a, b, c, d, e)

      arr.toList
      // res26: List[Char] = List(a, b, c, d, e)

      val arr2 = new Array[Int](10)
      // arr2: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

      List(1, 2, 3) copyToArray (arr2, 3)
      arr2
      // res28: Array[Int] = Array(0, 0, 0, 1, 2, 3, 0, 0, 0, 0)


      val it = abcde.iterator
      // it: Iterator[Char] = non-empty iterator

      it.next
      // res29: Char = a

      it.next
      // res30: Char = b
    #+END_SRC

*** DONE Example: Merge sort - 355
    CLOSED: [2018-03-28 Wed 23:11]
    #+BEGIN_SRC scala
      def msort[T](less: (T, T) => Boolean)(xs: List[T]): List[T] = {
        def merge(xs: List[T], ys: List[T]): List[T] =
          (xs, ys) match {
            case (Nil, _) => ys
            case (_, Nil) => xs
            case (x :: xs1, y :: ys1) =>
              if (less(x, y)) x :: merge(xs1, ys)
              else            y :: merge(xs, ys1)
          }

        val n = xs.length / 2
        if (n == 0) xs
        else {
          val (ys, zs) = xs splitAt n
          merge(msort(less)(ys), msort(less)(zs))
        }
      }
    #+END_SRC
    - =From Jian=
      Can use /implicit parameter/ or /context bound/ to simplify this.

    - The cost does *NOT* depend on the initial distribution of elements in the
      list,
      so _the worst case cost is the *SAME* as the average case cost._ This
      property makes /merge sort/ an attractive algorithm for sorting lists.

** DONE 16.7 Higher-order methods on class ~List~ - 357
   CLOSED: [2017-10-24 Tue 17:39]
*** DONE Mapping over lists: ~map~, ~flatMap~ and ~foreach~
    CLOSED: [2017-10-24 Tue 12:55]
*** DONE Filtering lists: ~filter~, ~partition~, ~find~, ~takeWhile~, ~dropWhile~, and ~span~
    CLOSED: [2017-10-24 Tue 13:09]
    - ~xs partition p~ equals ~(xs filter p, xs filter (!p(_)))~

    - ~find~ return ONLY the first element fullfill the requirement.
      The type of its return value is ~Option[T]~.

    - ~xs span p~ equals ~(xs takeWhile p, xs dropWhile p)~
      Like ~splitAt~, ~span~ avoids traversing the list ~xs~ twice.

*** DONE Predicates over lists: ~forall~ and ~exists~
    CLOSED: [2017-10-24 Tue 13:10]
*** DONE Folding lists: ~/:~ and ~:\~
    CLOSED: [2017-10-24 Tue 17:39]
    - ~(z /: List(a, b, c)) (op)~ equals ~op(op(op(z, a), b), c)~
      The ~/:~ operator is pronounced /fold right/.

               op
              /  \
             op   c
            /  \
           op   b
          /  \
         z    a

    - ~(List(a, b, c) :\ z) (op)~ equals ~op(a, op(b, op(c, z)))~
      The ~:\~ operator is pronounced /fold right/.

               op
              /  \
             a    op
                 /  \
                b    op
                    /  \
                   c    z

    - ~flattenRight~ is more efficient than ~flattenLeft~

      ~flattenLeft~ copy the first element of ~xss~ n - 1 times, while
      ~flattenRight~ do it only once.

*** DONE Example: List reversal using fold
    CLOSED: [2017-10-24 Tue 17:30]
    #+BEGIN_SRC scala
      def reverseLeft[T](xs: List[T]) = (List() /: xs) {(ys, y) => y :: ys}
    #+END_SRC

*** DONE Sorting lists: ~sortWith~
    CLOSED: [2017-10-24 Tue 17:33]
    #+BEGIN_SRC scala
      List(1, -3, 4, 2, 6) sortWith (_ < _)

      words sortWith (_.length > _.length)
    #+END_SRC

** DONE 16.8 Methods of the ~List~ object - 365
   CLOSED: [2017-10-24 Tue 02:42]
*** DONE Creating lists from their elements: ~List.apply~
    CLOSED: [2017-10-24 Tue 02:41]
    ~List(1, 2, 3)~ is simply the application of the object ~List~ to the
    elements ~1~, ~2~, ~3~ -- ~List.apply(1, 2, 3)~

*** DONE Creating a range of numbers: ~List.range~
    CLOSED: [2017-10-24 Tue 02:41]
    ~List.range(from, until)~
    ~List.range(from, until, step)~
    #+BEGIN_SRC scala
      List.range(1, 5)
      // res54: List[Int] = List(1, 2, 3, 4)

      List.range(1, 9, 2)
      // res55: List[Int] = List(1, 3, 5, 7)

      List.range(9, 1, -3)
      // res56: List[Int] = List(9, 6, 3)
    #+END_SRC
*** DONE Creating uniform lists: ~List.fill~
    CLOSED: [2017-10-24 Tue 02:33]
    #+BEGIN_SRC scala
      List.fill(5)('a')
      // res57: List[Char] = List(a, a, a, a, a)

      List.fill(3)("hello")
      // res58: List[String] = List(hello, hello, hello, hello, hello)

      List.fill(2, 3)('b')
      // res59: List[List[Char]] = List(List(b, b, b), List(b, b, b))

      // From Jian
      // This is NOT the design intent of `List.fill`, use `List.tabulate`
      var i = 0
      def inc: Int = {
        i += 1
        i
      }

      List.fill(3)(inc)
      // res60: List[Int] = List(1, 2, 3)
    #+END_SRC

*** DONE Tabulating a function: ~List.tabulate~
    CLOSED: [2017-10-24 Tue 02:37]
    #+BEGIN_SRC scala
      val squares = List.tabulate(5)(n => n * n)
      // squares: List[Int] = List(0, 1, 4, 9, 16)

      val multiplication = List.tabulate(5, 5)(_ * _)
      // multiplication: List[List[Int]] = List(List(0, 0, 0, 0, 0),
      //     List(0, 1, 2, 3, 4), List(0, 2, 4, 6, 8),
      //     List(0, 3, 6, 9, 12), List(0, 4, 8, 12, 16))
    #+END_SRC

*** DONE Concatenating multiple lists: ~List.concat~
    CLOSED: [2017-10-24 Tue 02:38]
    #+BEGIN_SRC scala
      List.concat(List(), List('b'), List('c'))
      //res61: List[Char] = List(b, c)
    #+END_SRC

** DONE 16.9 Processing multiple lists together - 367
   CLOSED: [2017-10-24 Tue 13:43]
   ~(List(10, 20), List(3, 4, 5)).zipped.map(_ * _)~

** DONE 16.10 Understanding Scala's type inference algorithm - 368
   CLOSED: [2018-11-25 Sun 16:22]
   /Type inference/ in Scala is *flow based*.


   - You may notice there is one difference between the application of ~msort~
     and the application of ~sortWith~:
     #+BEGIN_SRC scala
       // abcde = ['a', 'b', 'c', 'd', 'e']

       // #1
       msort((x: Char, y: Char) => x > y)(abcde)

       // #2
       abcde sortWith (_ > _)
     #+END_SRC
     + The first parameter of ~msort~ must be explicitly typed.
       ~msort(_ > _)(abcde)~ will lead to a compile error:
       #+BEGIN_SRC text
         // <console>:12: error: missing parameter type for expanded
         // function ((x$1, x$2) => x$1.$greater(x$2))
         //        msort(_ > _)(abcde)
         //              ˆ
       #+END_SRC

     + The ~msort~ method needs to be instantiated with a /type parameter/
       BEFORE it can be applied to its arguments.

   - Usually, you have three ways to work around:
     + Pass the /type parameter/ RATHER THAN EXPLICITLY annotate the /function
       literal/ like ~msort[Char](_ > _)(abcde)~

     + Two more general solutions, that you need to modify your design:

       The guide rule comes from the fact:
       Generally, when tasked to infer the /type parameters/ of a /polymorphic
       method/, the type inferencer consults the types of all value arguments
       *in the first parameter (ONLY) list BUT NO arguments BEYOND that.*

       * Use ONE parameter list, rather than curring.
         Now you all the type information are saved in the first parameter list.

       * Keep curring, but swap the parameter lists:
         #+BEGIN_SRC scala
           def msortSwapped[T](xs : List[T])
                           (less: (T, T) => Boolean): List[T] = {
             // ...
           }
         #+END_SRC
         This is the way we usually take, discussed below!

   - This inference scheme suggests the following *library design principle*:
     When designing a /polymorphic method/ that takes
     1. some /non-function arguments/
        and
     2. a /function argument/,
        place the /function argument/ *last* in a /curried parameter list/ on
        its own.

     That way, the method's correct instance type can be inferred from the
     non-function arguments, and that type can in turn be used to type check the
     function argument.
       The net effect is that users of the method will be able to give less type
     information and write function literals in more compact ways.

   - The way Scala do the type inference does NOT use the Hindley-Milner algorithm.

     =TODO= =Learn More= =Read Paper=
     The Hindley-Milner algorithm does NOT have the issue we met in this section.
     However, the Scala way is more gracefully with object-oriented subtyping than
     the Hindley-Milner style does.
     =TODO= =Learn More= =Read Paper=

** DONE 16.11 Conclusion - 372
   CLOSED: [2017-10-24 Tue 13:45]

* DONE 17 Working with Other Collections - 373
  CLOSED: [2017-11-03 Fri 23:39]
** DONE 17.1 Sequences - 373
   CLOSED: [2017-11-01 Wed 03:57]
   - Sequence ::  a group of data lined up in order.

*** DONE Lists
    CLOSED: [2017-11-01 Wed 03:23]
*** DONE Arrays
    CLOSED: [2017-11-01 Wed 03:26]
    - footnote 1: The _difference_ in variance of _Scala's_ and _Java's arrays_
      -- i.e., whether ~Array[String]~ is a subtype of ~Array[AnyRef]~ -- will be
      discussed in Section 19.3. =TODO=

*** DONE List buffers
    CLOSED: [2017-11-01 Wed 03:41]
    - ~List~ has its limitation -- if you want to append element to the end of a
      /list/, you can append to the head, and ~reverse~ at the end.

    - Another alternative, which avoid ~reverse~, is to use a ~ListBuffer~.
      ~ListBuffer~ is a mutable object (contained in package
      ~scala.collection.mutable~), which can help you build lists more
      efficiently when you need to _append_ -- constant time _append_ and
      _prepend_ operations:

      + append operator: ~+=~
      + prepend operator: ~+=:~

    - Example:
      #+BEGIN_SRC scala
        import scala.collection.mutable.ListBuffer

        val buf = new ListBuffer[Int]
        buf += 1
        buf += 2
        buf
        //  buf.type = ListBuffer(1, 2)

        3 +=: buf
        buf
          //  buf.type = ListBuffer(3, 1, 2)

        buf.toList
        // List[Int] = List(3, 1, 2)
      #+END_SRC

    - Another reason to use ListBuffer instead of List is to _prevent_ the
      _potential for stack overflow_.

      If you can build a /list/ in the desired order by _prepending_, but the
      recursive algorithm that would be required is _NOT tail recursive_, you can
      use a ~for~ expression or ~while~ loop and a ~ListBuffer~ instead. You'll
      see ~ListBuffer~ being used in this way in Section 22.2.

      =TODO=

*** DONE Array buffers
    CLOSED: [2017-11-01 Wed 03:53]
    - ~ArrayBuffer~ is like ~Array~, EXCEPT the additional _add_ and _remove_
      elements from the beginning and end of the sequence.

      + ALL
        ~Array~ operations are available, though they are a little slower due to
        a layer of wrapping in the implementation.

      + The new addition and removal operations are constant time on average, but
        occasionally require linear time due to the implementation needing to
        allocate a new array to hold the buffer's contents.

    - Similar to ~ListBuffer~, ~ArrayBuffer~ has the ~+=~, ~+=:~, ~toArray~
      operations.

*** DONE Strings (via ~StringOps~)
    CLOSED: [2017-11-01 Wed 03:57]
    - ~StringOps~ implements many sequence methods.

      ~Predef~ has an implicit conversion from ~String~ to ~StringOps~.

    - Example (Methods in ~StringOps~, NOT Java ~String~):
      #+BEGIN_SRC scala
        def hasUpperCase(s: String) = s.exists(_.isUpper)

        hasUpperCase("Robert Frost")  // true
        hasUpperCase("e e cummings")  // false
      #+END_SRC

** DONE 17.2 Sets and maps - 377
   CLOSED: [2017-11-03 Fri 22:16]
   - By default when you write “Set” or “Map” you get an _immutable_ object.

     You DO need ~import~ to work with their _mutable_ variants.

     #+BEGIN_SRC scala
       object Predef {
         type Map[A, +B] = collection.immutable.Map[A, B]
         type Set[A] = collection.immutable.Set[A]
         val Map = collection.immutable.Map
         val Set = collection.immutable.Set
         //...
       }
     #+END_SRC
     + Here ~type~ define aliases.

     + =TODO= More in 378

*** DONE Using sets
    CLOSED: [2017-11-01 Wed 04:14]
   - ~val words = mutable.Set.empty[String]~

   - ~+=~, ~-=~

   - ~--=~ like ~-=~, but one operand is a collection, NOT single value.
     ~words --= List("do", "re", "mi")~

   - ~++=~ like ~+=~, but one operand is a collection, NOT single value.
     ~words ++= List("do", "do", "re")~

   - The ~clear~ method.

*** DONE Using maps
    CLOSED: [2017-11-01 Wed 20:11]
    - ~val map = mutable.Map.empty[String, Int]~

    - Table 17.2 Common operations for maps
      + Add one entry: ~+~

      + Remove one entry: ~-~
        For example: ~nums - keyValue~

      + Concatenate: ~++~
        For example: ~nums ++ List("iii" -> 3, "v" -> 5)~

      + Remove multple entries: ~--~
        For example: ~nums -- List("iii", "v")~

      + ~contains~ method

      + ~keys~ method returns an ~Iterable~

      + ~keySet~ method returns keys as /set/

      + ~values~ method

      + ~isEmpty~ method

      + ~+=~ for /mutable maps/

      + ~-=~ for /mutable maps/

      + ~++=~ for /mutable maps/

      + ~--=~ for /mutable maps/

*** DONE Default sets and maps
    CLOSED: [2017-11-03 Fri 22:00]
    Both immutable ~Set~ and ~Map~ have

    The class returned by the ~scala.collection.immutable.Set()~ factory method
    depends on how many elements you pass to it. It tries to maximize performance.
    There are
    + ~scala.collection.immutable.EmptySet~
    + ~scala.collections.immutable.Set1~
    + ~scala.collections.immutable.Set2~
    + ~scala.collections.immutable.Set3~
    + ~scala.collections.immutable.Set4~
    + ~scala.collections.immutable.HashSet~

    It is similar to ~scala.collection.immutable.Map()~.

*** DONE Sorted sets and maps
    CLOSED: [2017-11-03 Fri 22:15]
    - For the purpose of use a map or a set in a particular order, the Scala
      ~collections~ library provides /traits/ ~SortedSet~ and ~SortedMap~.
      These /traits/ are implemented by classes ~TreeSet~ and ~TreeMap~, which
      use a /red-black tree/ to keep /elements/ (in the case of ~TreeSet~) or
      /keys/ (in the case of ~TreeMap~) in order.

    - The order is determined by the ~Ordered~ trait, which the element type of
      the set, or key type of the map, must either mix in or be implicitly
      convertible to.

    - These classes ONLY come in _immutable_ variants.

    - Example:
      #+BEGIN_SRC scala
        import scala.collection.immutable.TreeSet
        val ts = TreeSet(9, 3, 1, 8, 0, 2, 7, 4, 6, 5)
        // ts: scala.collection.immutable.TreeSet[Int] =
        //     TreeSet(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

        import scala.collection.immutable.TreeMap
        val tm = TreeMap(3 -> 'x', 1 -> 'x', 4 -> 'x')
        // tm: scala.collection.immutable.TreeSet[Int, Char] =
        //     Map(1 -> x, 3 -> x, 4 -> x)

        tm += (2 -> 'x')
        tm
        // res30: scala.collection.immutable.TreeSet[Int, Char] =
        //     Map(1 -> x, 2 -> x, 3 -> x, 4 -> x)
      #+END_SRC

** DONE 17.3 Selecting mutable versus immutable collections - 385
   CLOSED: [2017-11-03 Fri 23:27]
   - When you don't know, choose /immutable collections/ first.

   - When you don't want copy, use /mutable collections/.

   - /immutable collections/ is more efficient in using space.
     For example,
     + an empty mutable map in its default representation of ~HashMap~ takes up
       about 80 bytes, and about 16 more are added for each entry that's added to
       it.

       An empty immutable ~Map~ is a single object that's share between all
       references, so referring to it essentially costs just a single pointer
       field.

     + The Scala CURRENTLY store /immutable collections/ with up to four entries
       in a single object, which typically takes up between 16 and 40 bytes,
       depending on the number of entires stored in the collection.

       Conclusion: So for _SMALL_ maps and sets, the /immutable/ versions are
       much _more compact than_ the /mutable/ ones.

   - Scala provides some syntactic sugar.
     Whenever you write ~a += b~, and ~a~ does NOT support ~a~ method named +=,
     Scala will try interpreting it as ~a = a + b~.

     =From Jian= DO NOT use this feature. It misleading to the reader.

   - Remember: you can save /immutable collections/ in ~var~!

** DONE 17.4 Initializing collections - 388
   CLOSED: [2017-11-03 Fri 23:39]
*** DONE Converting to array or list
    CLOSED: [2017-11-03 Fri 23:35]
    - ~aList.toArray~ and ~anArray.toList~

    - When you invoke ~toList~ or ~toArray~ on a collection, the order of the
      elements in the resulting list or array will be the same as the order of
      elements produced by an /iterator/ obtained by invoking ~elements~ on that
      collection.

    - Keep in mind, however, that conversion to lists or arrays usually requires
      _copying all_ of the elements of the collection, and thus may be _SLOW for
      LARGE collections_.

*** DONE Converting between mutable and immutable sets and maps
    CLOSED: [2017-11-03 Fri 23:39]
    - Convert a mutable set or map to an immutable one, or vice versa:
      ~emptyTargetCollectionTypeValue ++ existCollectionValue~

** DONE 17.5 Tuples - 392
   CLOSED: [2017-10-24 Tue 17:44]
   - Because /tuples/ can combine objects of _different types_, tuples do NOT
     inherit from ~Traversable~.

   - Use ~_n~ method to access the nth element of a tuple.

     The n here starts from 1, which is a convention even in other languages like
     Haskell.

** DONE 17.6 Conclusion - 394
   CLOSED: [2017-11-03 Fri 23:39]
* TODO 18 Mutable Objects - 395
   This chapter
   - Explains
     + what /mutable objects/ are
     + what Scala provides in terms of syntax to express them.

   - Introduces a larger case study on
     + /discrete event simulation/, which involves /mutable objects/,

     + as well as *building* an /internal DSL/ for defining _digital circuits_ to
       simulate.

** DONE 18.1 What makes an object mutable? - 395
   CLOSED: [2018-04-02 Mon 04:08]
   - _Mutable object_ does NOT fulfill the requirement of of /reference
     transparency/.

   - A good EXAMPLE of /mutable object/ is a _bank account_.
     #+BEGIN_SRC scala
       class BankAccount {
         private var bal: Int = 0

         def balance: Int = bal

         def deposit(amount: Int): Unit = {
           require(amount > 0)
           bal += amount
         }

         def withdraw(amount: Int): Boolean =
           if (amount > bal) false
           else {
             bal -= amount
             true
           }
       }
     #+END_SRC
     =From Jian=
     I think this is a good idea that the default ~bal~ must be ~0~ first -- NOT
     specified during constructing! This helps avoiding unintended errors like
     initalize an accout with a huge ~bal~ value for anyone. Of course, intended
     behaviors can't be stopped, no matter it is good or bad -- eliminate bad
     behaviors is NOT the duty of ~BankAccount~.

   - Remember! /mutability/ does NOT always mean ~var~,

     For instance, a /class/ might be /mutable/ _without defining or inheriting
     any ~var~'s_ because it *forwards* /method/ calls to other objects that
     have /mutable state/.

     (=From Jian= this is why oop is complicated!!!
     One simple example is a ~val~ references to /mutable object/, the
     /reference/ saved in the ~val~ cannot change, but the *forworded* operations
     change the content of the object it references.)

     The reverse is also possible: *A class might contain ~var~'s and still be
     purely functional.* For example, a /class/ that _caches the result of an
     expensive operation in a field for opimization purposes_ .
     #+BEGIN_SRC scala
       // NO cache, unoptimized
       class Keyed {
         def computeKey: Int = ...  // this will take some time

         // ...
       }


       // Optimized with cache
       class MemoKeyed extends Keyed {

         private var keyCache: Option[Int] = None

         override def computeKey: Int = {
           if (!keyCache.isDefined) keyCache = Some(super.computeKey)
           keyCache.get
         }

       }
     #+END_SRC
     The difference between ~Keyed~ and ~MemoKeyed~ is that ~MemoKeyed~ is more
     efficient -- no repeated computation, and then _no other difference if only
     inspect them from the outside_.
       *Therefore, if ~Keyed~ is puerly functional to the user, why not
     ~MemoKeyed~.*

** DONE 18.2 Reassignable variables and properties - 398
   CLOSED: [2018-04-02 Mon 20:49]
   - You can perform _two_ fundamental operations on a reassignable variable:
     + *get* its value
     + *set* it to a new value.

   - In Scala, every ~var~ that is a /non-private member/ of some object
     *implicitly defines a /getter/ and a /setter/ /method/ with it*.

     These /getters/ and /setters/ are _NAMED_ *differently from the Java
     convention*, however. Of a ~var x~,
     + Its /getter/ is also named ~x~
     + Its /setter/ is named ~x_=~.

   - Example:
     + Original Source code:
       #+BEGIN_SRC scala
         class Time {
           var hour = 12
           var minute = 0
         }
       #+END_SRC

     + Code after auto-transformation:
       #+BEGIN_SRC scala
         class Time {
           private[this] var h = 12
           private[this] var m = 0
           def hour: Int = h
           def hour_=(x: Int) = { h = x }
           def minute: Int = m
           def minute_=(x: Int) = { m = x }
         }
       #+END_SRC
       In the transformed code, correspond to one ~var~, for example, ~hour~:
       * there is always a ~private[this] var~ with _different name_ (~h~).

       * there are always a /getter/ and a /setter/ with the same visibility.
         The orginal ~val hour~ is /public/, thus the generated ~def hour~ and
         ~def hour_=~ are /public/.

     + You can manually define /getters/ and /setters/. Here is an example, and
       we add some constraints to the /getters/ and /setters/, and make a new
       ~Time~ which, besides some explicit reasonable constraints, works the same
       as the "Original Souce Code" version:
       #+BEGIN_SRC scala
         class Time {
           private[this] var h = 12
           private[this] var m = 0
           def hour: Int = h

           def hour_=(x: Int) = {
             require(0 <= x && x < 24)
             h = x
           }

           def minute: Int = m

           def minute_=(x: Int) = {
             require(0 <= x && x < 60)
             m = x
           }
         }
       #+END_SRC

   - It's also possbile, and sometimes useful, to define a /getter/ and a
     /setter/ without an associated field. For example,
     #+BEGIN_SRC scala
       class Thermometer {
         var celsius: Float = _

         def fahrenheit = celsius * 9 / 5 + 32

         def fahrenheit_= (f: Float) = {
           celsius = (f 32)
             ,* 5 / 9
         }

         override def toString = fahrenheit + "F/" + celsius + "C"
       }
     #+END_SRC
     In this example, ~Thermometer~ doesn't have a field called ~fahrenheit~, but
     it has the information of /fahrenheit temparature/, which is saved inside
     ~var celcisus~.
       The definition of /getter/ ~fahrenheit~ body is the function to translate
     the information.
       The definition of /setter/ ~fahrenheit_=~ body translates the input
     /fahrenheit temparature/ information to /celcisus temparature/ and save it.

** DONE 18.3 Case study: Discrete event simulation - 401
   CLOSED: [2018-04-02 Mon 21:35]
   - This task is broken down into several subproblems, each of which is
     interesting individually:

     1. You'll see a little language for digital circuits -- /embedding DSL/ in a
        host language like Scala.

     2. Present a simple but general _framework for discrete event simulation_.

          Its main task will be to keep track of actions that are performed in
        simulated time.

     3. We'll show how *discrete simulation programs* can be _structured_ and
        _built_.

        The idea of such simulations is to
        + model physical objects by simulated objects

        + use the simulation framework to model physical time.

     4. xxx

   - This /digital circuits simulation/ example is taken from SICP.

   - The various aspects of the example are structured into *four* software
     layers:
     1. simulation framework;

     2. the basic circuit simulation package;

     3. a library of user-defined circuits;

     4. each simulated circuit itself.

     Each layer is expressed as a /class/, some of them have inheritance
     hierarchy.

** TODO 18.4 A language for digital circuits - 402
** TODO 18.5 The ~Simulation~ API - 405
** TODO 18.6 Circuit Simulation - 409
*** TODO The ~Wire~ class
*** TODO The ~inverter~ method
*** TODO The ~andGate~ and ~orGate~ methods
*** TODO Simulation output
*** TODO Running the simulator

** TODO 18.7 Conclusion - 417
* DONE 19 Type Parameterization - 418 - =RE-DO=
  CLOSED: [2018-04-10 Tue 22:58]
  - The chapter contains _THREE_ parts:
    1. Develop a data structure for /purely functional queues/.

    2. Develop techniques to *hide* internal representation details of this structure.

    3. Explain /variance/ of /type parameters/
       and
       how it interacts with information hiding.

** DONE 19.1 Functional queues - 418
   CLOSED: [2017-11-04 Sat 17:22]
   - A functional queue is a data structure with three operations:
     + head :: returns the first element of the queue

     + tail :: returns a queue without its first element

     + enqueue ::  returns a _new_ queue with a given element appended at the end

   - Example (~enqueue~ has O(n) complexity):
     #+BEGIN_SRC scala
       class SlowAppendQueue1[T](elems: List[T]) { // Not efficient
         def head = elems.head
         def tail = new SlowAppendQueue(elems.tail)
         def enqueue(x: T) = new SlowAppendQueue(elems ::: List(x))
       }
     #+END_SRC

   - Example (~enqueue~ has O(1) complexity, but ~head~ and ~tail~ have O(n)
     compleixty):
     #+BEGIN_SRC scala
       // The list is saved reversely (the "smele" is the reverse of "elems")
       class SlowHeadQueue2[T](smele: List[T]) { // Not efficient
                                                 // smele is elems reversed
         def head = smele.last
         def tail = new SlowHeadQueue(smele.init)
         def enqueue(x: T) = new SlowHeadQueue(x :: smele)
       }
     #+END_SRC

   - Example (amortized complexity is constant)
     #+BEGIN_SRC scala
       class Queue[T](
         private val leading: List[T],
         private val trailing: List[T]
       ) {
         private def mirror =
           if (leading.isEmpty)
             new Queue(trailing.reverse, Nil)
           else
             this

         def head = mirror.leading.head

         def tail = {
           val q = mirror
           new Queue(q.leading.tail, q.trailing)
         }

         def enqueue(x: T) =
           new Queue(leading, x :: trailing)
       }
     #+END_SRC

   - *Caveats*:
     =TODO= =TODO= =TODO=

** DONE 19.2 Information hiding - 422
   CLOSED: [2017-11-04 Sat 16:27]
*** DONE Private constructors and factory methods - 422
    CLOSED: [2017-11-04 Sat 16:19]
    - A /primary constructor/ is the base of a class, but some /primary
      constructors/ do NOT work in a natural way from the client's point of view,
      and they need to be hidden and called the other /constructors/.

    - The /primary constructor/ in Scala does NOT have an explicit definition,
      and we can use Java-like syntax to make it private:
      #+BEGIN_SRC scala
        class Queue[T] private (
          private val leading: List[T],
          private val trailing: List[T]
        )
      #+END_SRC

    - After _hiding_ the /primary constructor/, you need a client to construct a
      ~Queue[T]~. Mostly in two ways:

      + a /constructor/ can be used in the more natural way:
        #+BEGIN_SRC scala
          class Queue[T] private (
            private val leading: List[T],
            private val trailing: List[T]
          ) {

            def this(elem: T*) = this(elems.toList, Nil)

            // ...
          }
        #+END_SRC

      + A /factory method/:
        #+BEGIN_SRC scala
          object Queue {
            def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
          }
        #+END_SRC
        With this /factory method/, you can create a queue in the way of
        ~Queue(1, 2, 3)~ (which is automatically converted to
        ~Queue.apply(1, 2, 3)~ in the background).

*** DONE An alternative: private classes - 423
    CLOSED: [2017-11-04 Sat 16:27]
    - Ways to _hide_ the initialization and representation of a class.
      + Use /private constructors/ and /private members/.
        This is discussed in the last section!

      + *Another more radical way*
        * type abstraction :: _HIDE the /class/ itself_ and *ONLY export a trait*
             that reveals the public interface of the /class/.

    - Example:
      #+BEGIN_SRC scala
        trait Queue[T] {
          def head: T
          def tail: Queue[T]
          def enqueue(x: T): Queue[T]
        }

        object Queue {
          def apply[T](xs: T*): Queue[T] =
            new QueueImpl[T](xs.toList, Nil)

          private class QueueImpl[T](
            private val leading: List[T],
            private val trailing: List[T]
          ) extends Queue[T] {

            def mirror =
              if (leading.isEmpty)
                new QueueImpl(trailing.reverse, Nil)
              else
                this

            def head: T = mirror.leading.head

            def tail: QueueImpl[T] = {
              val q = mirror
              new QueueImpl(q.leading.tail, q.trailing)
            }

            def enqueue(x: T) =
              new QueueImpl(leading, x :: trailing)
          }
        }
      #+END_SRC

** DONE 19.3 Variance annotations - 425
   CLOSED: [2017-11-05 Sun 03:42]
   - ~Queue~ is a trait, NOT a type.

     When you fill in a /type parameter/, it becomes a /type/.
     For example, ~Queue[Int]~, ~Queue[String]~, ...

   - ~Queue~ is also called a /type constructor/ -- it generates a family of
     /types/.

     It is also called a /generic trait/.

   - ~Queue[T]~ is a /generic/ trait, and ~Queue[String]~ is a /parameterized/
     trait.

   - /variance/:
     + /covariant/, ~+~ type prefix

     + /nonvariant/, this is the default in Scala. It is also called "rigid".

     + /contravariant/, ~-~ type prefix

   - variance annotations ::
        The ~+~ and ~-~ symbols that can prefix a /type parameter/.

   - In a purely functional world, many types are _naturally_ /covariant/
     (flexible).

     However, the situation changes once you introduce mutable data.
     For example,
     #+BEGIN_SRC scala
       class Cell[+T](init: T) {   // This doesn't compile
         private[this] var current = init
         def get = current
         def set(x: T) = { current = x }
       }

       // If the code above can compile, the code below are right in syntax but
       // will fail.
       val c1 = new Cell[String]("abc")
       val c2: Cell[Any] = c1
       c2.set(1)
       val s: String = c1.get
     #+END_SRC

*** Variance and arrays
    Scala treats arrays as /nonvariant/ (rigid);
    Java treats arrays as /covariant/.

    - The reasons why Java does like this:
      + Prior Java 5, Java didn't have /generics/.
        The designers want to be able to write a method like sort all elements of
        an array, using a signature like the following that takes an array of
        ~Object~: ~void sort(Object[] a, Comparator cmp)~

        To have a simple means to treat arrays generically, Java language decides
        to treat its ~Array~ as /covariant/, though some operations lead to runtime
        errors. For example:
        #+BEGIN_SRC java
          String[] a1 = { "abc" };
          Object[] a2 = a1;
          a2[0] = new Integer(17);
          String s = a1[0];

          /* Runtime Error */

          // Exception in thread "main" java.lang.ArrayStoreException:
          // java.lang.Integer
          //         at JavaArrays.main(JavaArrays.java:8)
        #+END_SRC

      + Since Java 5, write a method to process /generics/ is no longer a
        problem, and the /covariant/ property of Java ~Array~ still exist just
        for compatibility.

    - =IMPORTANT=
      Since the different variance between Scala ~Array~ (/nonvariant/) and Java
      ~Array~ (/covariant/), and sometimes it is necessary to interact with
      legacy methods in Java that use an ~Object~ array as a means to emulate a
      generic array.
        For instance, you might want to call a ~sort~ method like the one
      described previously with an array of ~String~'s as argument. To make this
      possible, Scala lets you cast an array of ~T~'s to an array of any
      supertype of ~T~:
      #+BEGIN_SRC scala
        val a2: Array[Object] =
          a1.asInstanceOf[Array[Object]]

        // a2: Array[Object] = Array(abc)
      #+END_SRC
      + The /cast/ is always legal at compile-time =TODO=
        and
      + it will always succeed at runtime because the JVM’s underlying run-time
        model treats arrays as /covariant/, just as Java the language does.

        *But you might get ~ArrayStore~ exceptions afterwards, again just as you
        would in Java.*

** DONE 19.4 Checking variance annotations - 429 - =Re-Read= =Re-Read=
   CLOSED: [2017-11-05 Sun 05:43]
   -
   -
** DONE 19.5 Lower bounds - 432
   CLOSED: [2017-11-07 Tue 00:14]
   #+BEGIN_SRC scala
     class Queue[+T] (private val leading: List[T],
                      private val trailing: List[T]) {
       def enqueue[U >: T](x: U) =
         new Queue[U](leading, x :: trailing) //...
     }
   #+END_SRC

** DONE 19.6 Contravariance - 434
   CLOSED: [2017-11-07 Tue 00:34]
   - Liskov Substitution Principle ::
        It is safe to assume that a type ~T~ is a /subtype/ of a type ~U~ if you
        can substitute a value of type ~T~ wherever a value of type ~U~ is
        required.

   - The principle holds if ~T~ supports the same operations as ~U~, and all of
     ~T~'s operations _require less and provide more_ than the corresponding
     operations in ~U~.

     For example,
     #+BEGIN_SRC scala
       trait OutputChannel[-T] {
         def write(x: T)
       }
     #+END_SRC
     ~OutputChannel[AnyRef]~ is a subtype of ~OutputChannel[String]~.

   - Example:
     #+BEGIN_SRC scala
       trait Function1[-S, +T] {
         def apply(x: S): T
       }
     #+END_SRC

     ~Function1~ is
     + /contravariant/ in the function argument type ~S~
     + /convariant/ in the reulst type ~T~.

   - =TODO= Listing 19.9

** DONE 19.7 Object private data - 437
   CLOSED: [2018-04-10 Tue 22:58]
   - Problem:
     For the ~Queue~ /class/ implementations seen so far
     the ~mirror~ operation will *repeatedly* copy the ~trailing~ into the
     ~leading~ list if ~head~ is called several times in a row on a list where
     ~leading~ is empty.

   - Solution:
     Add some judicious side effects!

     Here is the new implementation of ~Queue~, which performs _at most_ *ONE*
     ~trailing~ to ~leading~ adjustment for _any SEQUENCE of ~head~ operations_.
     #+BEGIN_SRC scala
       class Queue[+T] private (
         private[this] var leading: List[T],
         private[this] var trailing: List[T]
       ) {
         private def mirror() =
           if (leading.isEmpty) {
             while (!trailing.isEmpty) {
               leading = trailing.head :: leading
               trailing = trailing.tail
             }
           }

         def head: T = {
           mirror()
           leading.head
         }

         def tail: Queue[T] = {
           mirror()
           new Queue(leading.tail, trailing)
         }

         def enqueue[U >: T](x: U) =
           new Queue[U](leading, x :: trailing)
       }
     #+END_SRC

   - Q: There is /mutable fields/ in our new ~Queue~.
        Can it pass the Scala type checker?

     A: If we only use the rules described before, rather than add new special
        rule(s), the new ~Queue~ cannot pass the type checker.
          However, accesses to variables _from the same object_ in which they are
        defined do *NOT* cause problems with /variance/. Here ~private[this]~
        guarantees this!

        Scala's variance checking rules contain a special case for object
        private definitions. Therefore, our new ~Queue~ definition can pass
        the /variance check/.

   - The intuitive explanation:
     _in order to construct a case where /variance/ would lead to type errors_,
     you need to have a reference to a containing object that has a statically
     *weaker type* than the /type/ the object was defined with. For accesses to
     /object private values/, however, this is impossible.

** DONE 19.8 Upper bounds - 439
   CLOSED: [2018-03-19 Mon 00:32]
   - ~<:~

   - Example:
     #+BEGIN_SRC scala
       class Person(val firstName: String, val lastName: String)
           extends Ordered[Person] {
         def compare(that: Person) = {
           val lastNameComparison =
             lastName.compareToIgnoreCase(that.lastName)
           if (lastNameComparison != 0)
             lastNameComparison
           else
             firstName.compareToIgnoreCase(that.firstName)
         }
         override def toString = firstName + " " + lastName
       }


       object Sort {

         def orderedMergeSort[T <: Ordered[T]](xs: List[T]): List[T] = {
           def merge(xs: List[T], ys: List[T]): List[T] =
             (xs, ys) match {
               case (Nil, _) => ys
               case (_, Nil) => xs
               case (x :: xs1, y :: ys1) =>
                 if (x < y) x :: merge(xs1, ys)
                 else       y :: merge(xs, ys1)
             }

           val n = xs.length / 2

           if (n == 0) xs
           else {
             val (ys, zs) = xs splitAt n
             merge(orderedMergeSort(ys), orderedMergeSort(zs))
           }
         }

         def test(): Unit = {
           val people = List(
             new Person("Larry", "Wall"),
             new Person("Anders", "Hejlsberg"),
             new Person("Guido", "van Rossum"),
             new Person("Alan", "Kay"),
             new Person("Yukihiro", "Matsumoto")
           )

           println(orderedMergeSort(people))
           // List(Anders Hejlsberg, Alan Kay, Yukihiro Matsumoto, Guido van Rossum, Larry Wall)
         }

       }
     #+END_SRC

   - The ~orderedMergeSort~ is NOT the most general way in Scala to design a sort
     function that takes advantage of the ~Ordered~ trait -- for example, it
     CANNOT sort a list of integers.

     See Section 21.6 to learn how to use implicit parameters and context bounds
     to achieve a more general solution.

** DONE 19.9 Conclusion - 442
   CLOSED: [2018-04-10 Tue 22:58]
   In this chapter you saw several techniques for information hiding:
   - /private constructors/, /factory methods/ (~apply~), /type abstraction/, and
     /object private members/.

   - You also learned how to SPECIFY /data type variance/
     and
     what it IMPLIES for /class/ implementation.

   - Finally, you saw *TWO* techniques which help in /obtaining flexible variance
     annotations/:
     + /lower bounds/ for /method type parameters/
       and
     + ~private[this]~ annotations for /local fields and methods/.

* DONE 20 Abstract Members - 443
  CLOSED: [2017-11-12 Sun 01:26]
  - abstract member :: A member of a /class/ or /trait/ is abstract if the member
       does _not have a complete definition_.

  - In Scala you can declare /abstract fields/ and even /abstract types/ as
    members of /classes/ and /traits/. This goes beyond Java, which only lets you
    declare /abstract methods/.

  - In this chapter
    we'll describe all _FOUR_ kinds of /abstract member/:
    + vals
    + vars
    + methods
    + types

  - Along the way of describing all four kinds of /abstract member/,
    we'll discuss
    + pre-initialized fields
    + lazy vals
    + path-dependent types =TODO= =???=
    + enumerations

** DONE 20.1 A quick tour of abstract members - 443
   CLOSED: [2017-11-09 Thu 20:54]
   - A /trait/ includes four kinds of /abstract members/:
     #+BEGIN_SRC scala
       trait Abstract {
         type T
         def transform(x: T): T
         val initial: T
         var current: T
       }
     #+END_SRC

     A concrete implementation of the ~Abstract~ /trait/.
     #+BEGIN_SRC scala
       class Concrete extends Abstract {
         type T = String
         def transform(x: String) = x + x
         val initial = "hi"
         var current = initial
       }
     #+END_SRC

** DONE 20.2 Type members - 444
   CLOSED: [2017-11-09 Thu 20:58]
   A type /alias/ that uses the ~type~ keyword to declare.

** DONE 20.3 Abstract ~val~'s - 445
   CLOSED: [2017-11-09 Thu 21:04]
   An abstract ~val~ can't be /overrided/ by a subtype with ~def~.

** DONE 20.4 Abstract ~var~'s - 446
   CLOSED: [2017-11-09 Thu 21:09]
   When you declare an abstract ~var~, you implicitly declare an abstract
   /getter/ and /setter/. For instance, there are two exactly equivalent
   definitions:
   #+BEGIN_SRC scala
     trait AbstractTime {
       var hour: Int
       var minute: Int
     }
   #+END_SRC

   #+BEGIN_SRC scala
     trait AbstractTime {
       def hour: Int      // getter for `hour`
       def hour_=: Int    // setter for `hour`
       def minute: Int    // getter for `minute`
       def minute_=: Int  // setter for `minute`
     }
   #+END_SRC

** DONE 20.5 Initializing abstract ~val~'s - 447
   CLOSED: [2017-11-11 Sat 21:03]
   - Create a /instance/ of an /anonymous class/ that /mixes in/ the /trait/ and
     is defined by the body.
     #+BEGIN_SRC scala
       trait RationalTrait {
         val numerArg: Int
         val denomArg: Int
       }

       val r = new RationalTrait {
         val numerArg = 1
         val denomArg = 2
       }
     #+END_SRC

   - This particular /anonymous class instantiation/ has an effect _analogous to_
     the instance creation ~new Rational(1, 2)~.

     However, this analogy is NOT perfect.
     + For classes, When you write: ~new Rational(expr1, expr2)~, the two
       expressions, ~expr1~ and ~expr2~, are evaluated before class ~Rational~
       is initialized, so the values of ~expr1~ and ~expr2~ are available for
       the initialization of class ~Rational~.

     + For traits, When you write:
       #+BEGIN_SRC scala
         new RationalTrait {
           val numerArg = expr1
           val denomArg = expr2
         }
       #+END_SRC
       * ~expr1~ and ~expr2~, are evaluated as part of the initialization of the
         /anonymous class/,

       * but the /anonymous class/ is _initialized AFTER_ the ~RationalTrait~.

       So the /values/ of ~numerArg~ and ~denomArg~ are _NOT available_ during
       the initialization of ~RationalTrait~ (more precisely, a selection of
       either value would yield the /default value/ for type ~Int~, ~0~).
         This is NOT a problem for the example above.
         A problematic example is showed below.

   - Example:
     #+BEGIN_SRC scala
       trait RationalTrait {
         val numerArg: Int
         val denomArg: Int

         require(denomArg != 0)

         private val g = gcd(numerArg, denomArg)
         val numer = numerArg / g
         val denom = denomArg / g

         private def gcd(a: Int, b: Int): Int =
           if (b == 0) a else gcd(b, a % b)

         override def toString = numer + "/" + denom
       }

       val x = 2

       new RationalTrait {
         val numerArg = 1 * x
         val denomArg = 2 * x
       }

       // java.lang.IllegalArgumentException: requirement failed
       //   at scala.Predef$.require(Predef.scala:207)
       //   at RationalTrait$class.$init$(<console>:10)
       //   ... 28 elided
     #+END_SRC

     The pre-requisite is not fullfilled due to the reason mentioned above.

   - Scala offers _TWO_ alternative solutions to this problem:
     + /pre-initialized fields/
     + /lazy vals/

     =TODO= They are presented in the remainder of this section.

*** Pre-initialized fields
    - pre-initialized fields :: A syntax that lets you initialize a field of a
         /subclass/ _BEFORE_ the /superclass/ is called.

    - Example:
      #+BEGIN_SRC scala
        //// initialize an anonymous class
        new {
          val numerArg = 1 * x
          val denomArg = 2 * x
        } with RationalTrait


        //// define object
        object twoThirds extends {
          val numerArg = 2
          val denomArg = 3
        } with RationalTrait


        //// define class
        class RationalClass(n: Int, d: Int) extends {
          val numerArg = n
          val denomArg = d
        } with RationalTrait {
          def + (that: RationalClass) = new RationalClass(
            numer * that.denom + that.numer * denom,
            denom * that.denom
          )
        }
      #+END_SRC

    - Because /pre-initialized fields/ are initialized _BEFORE_ the /superclass
      constructor/ is called, their initializers CANNOT refer to the object
      that's being constructed.

      Consequently, if such an initializer refers to ~this~, the reference goes
      to
      + the object CONTAINING the class
        (=From Jian= if this is successful, the result is usually not the wanted)

      + object that's _being constructed_,
        (=From Jian= this can always be an error???)

      NOT the _constructed object_ itself.

    - Example (in REPL):
      #+BEGIN_SRC scala
        // scala>
        new {
          val numerArg = 1
          val denomArg = this.numerArg * 2
        } with RationalTrait

        // <console>:11: error: value numerArg is not a member of object
        //  $iw
        //                 val denomArg = this.numerArg * 2
      #+END_SRC
      =Re-READ=
      The example did _NOT compile_ because the reference ~this.numerArg~ was
      looking for a ~numerArg~ field in _the object containing this ~new~
      expression_ (which in this case was the synthetic object named ~$iw~, into
      which the interpreter puts user input lines). Once more, pre-initialized
      fields behave in this respect like class constructor arguments.

*** Lazy ~val~'s
    - Comparison:
      + Strict
        #+BEGIN_SRC scala
          // scala>
          object Demo {
            val x = { println("initializing x"); "done" }
          }

          // scala>
          Demo
          // initializing x
          // res3: Demo.type = Demo$@2129a843

          // scala>
          Demo.x
          // res4: String = done
        #+END_SRC

      + Lazy
        #+BEGIN_SRC scala
          // scala>
          object Demo {
            lazy val x = { println("initializing x"); "done" }
          }
          // define object Demo

          // scala>
          Demo
          // res5: Demo.type = Demo$@5b1769c

          // scala>
          Demo.x
          // initializing x
          // res6: String = done

        #+END_SRC

    - Unlike a ~def~, a /lazy/ ~val~ is NEVER evaluated more than once.
      The evaluted value is cached for later use.

    - Reformulate ~RationalTrait~ to ~LazyRationalTrait~:
      #+BEGIN_SRC scala
        trait LazyRationalTrait {
          val numerArg: Int
          val denomArg: Int
          lazy val numer = numerArg / g
          lazy val denom = denomArg / g
          override def toString = numer + "/" + denom
          private lazy val g = {
            require(denomArg ! = 0)
            gcd(numerArg, denomArg)
          }
          private def gcd(a: Int, b: Int): Int =
            if (b == 0) a else gcd(b, a % b)
        }
      #+END_SRC
      + If we put the ~require~ statement in the original position as in
        ~RationalTrait~, ~denomArg~ will be forced to evaluate too early.
        Thus, we put the ~require~ statement just before the call to ~gcd~, where
        the condition ~denomArg != 0~ is important.

      + One important property of lazy ~val~'s:
        The textual order of their definitions does NOT matter because values get
        initialized on demand.
          However, this advantage holds only as long as the initialization of
        lazy ~val~'s neither produces side effects nor depends on them.
          So _lazy ~val~'s are an ideal complement to functional objects_, where
        the order of initializations does NOT matter, as long as everything gets
        initialized eventually.

** DONE 20.6 Abstract types - 455
   CLOSED: [2017-11-11 Sat 21:46]
   - Example (why do we need /abstract types/):
     + Wrong way
       #+BEGIN_SRC scala
         class Food

         abstract class Animal {
           def eat(food: Food)
         }


         class Grass extends Food

         class Cow extends Animal {
           override def eat(food: Grass) = {}  // This won't compile
         }
       #+END_SRC

     + Wrong way but compilable
       #+BEGIN_SRC scala
         class Food

         abstract class Animal {
           def eat(food: Food)
         }

         class Cow extends Animal {
           override def eat(food: Food) = {}
         }

         class Fish extends Food
         val bessy: Animal = new Cow
         bessy eat (new Fish)  // Everything is OK, but the meaning in the real world.
       #+END_SRC

     + Right way
       #+BEGIN_SRC scala
         class Food

         abstract class Animal {
           type SuitableFood <: Food
           def eat(food: SuitableFood)
         }


         class Grass extends Food

         class Cow extends Animal {
           type SuitableFood = Grass
           override def eat(food: Grass) = {}
         }
       #+END_SRC

** DONE 20.7 Path-dependent types - 457
   CLOSED: [2017-11-11 Sat 22:39]
   - path-dependent type :: A type like ~bessy.SuitableFood~

   - A /path-dependent type/ resembles the syntax for an /innter class type/
     _in Java_, _but there is a CRUCIAL difference_:
     + a /path-dependent type/ names an /outer object/
     + an /inner class/ type names an /outer class/.

   - Scala can also create /inner class/ types.
     The sytax of definition is similar to Java, while the syntax of usage is
     different, use ~Outer#Inner~ -- Scala keep ~.~ for objects ONLY.

     For example,
     #+BEGIN_SRC scala
       class Outer {
         class Inner
       }

       val o1 = new Outer
       val o2 = new Outer
     #+END_SRC
     Here ~o1.Inner~ and ~o2.Inner~ are two /path-dependent types/ (and they are
     _DIFFERENT_ types). Both of these types conform to (are subtypes of) the more
     general type ~Outer#Inner~, which represents the ~Inner~ class with an
     arbitrary outer object of type Outer.

     By contrast, type ~o1.Inner~ refers to the ~Inner~ class with a specific
     outer object (the one referenced from ~o1~). Likewise, type ~o2.Inner~
     refers to the ~Inner~ class with a different, specific outer object (the one
     referenced from ~o2~).

   - In Scala, as in Java, /inner class instances/ _hold a reference to an
     enclosing_ /outer class instance/. This allows an /inner class/, for
     example, to access members of its /outer class/.

     Thus you _CANNOT_ instantiate an /inner class/ without in some way
     specifying an /outer class instance/.

   - You can ~new o1.Inner~ -- it knows its outer object is ~o1~.
     You cannot ~new Outer#Inner~ -- NO outer object specified.

** DONE 20.8 Refinement types - 460
   CLOSED: [2017-11-11 Sat 22:48]
   - nominal subtype ::

   - structural subtyping ::

   - Use the /nominal subtype/ way, if you want to define a class ~Pasture~ that
     can contain animals that eat grass, you need to first define a trait
     ~AnimalThatEatsGrass~ and mix it into every class where it applies. This is
     _VERBOSE_.

   - Use the /structural subtyping/ way (use /refinement type/):
     #+BEGIN_SRC scala
       class Pasture {
         var animals: List[Animal { type SuitableFood = Grass }] = Nil
         //...
       }
     #+END_SRC

** DONE 20.9 Enumerations - 461
   CLOSED: [2017-11-11 Sat 23:46]
   Extend the ~scala.Enumeration~ class to create /enumerations/.

   - Syntax:
     #+BEGIN_SRC scala
       object Color extends Enumeration {
         val Red = Value
         val Green = Value
         val Blue = Value
       }
     #+END_SRC

   - syntactic sugared version:
     #+BEGIN_SRC scala
       object Color extends Enumeration {
         val Red, Green, Blue = Value
       }
     #+END_SRC

   - /Enumeration/ defines an /inner class/ named ~Value~, and the same-named
     parameterless ~Value~ method returns a fresh instance of that class.
       It means in the above example, ~Color.Red~, ~Color.Green~, ~Color.Blue~ is
     of type ~Color.Value~.

   - Associate names to the variants of a /enumeration/.
     #+BEGIN_SRC scala
       object Direction extends Enumeration {
         val North = Value("North")
         val East = Value("East")
         val South = Value("South")
         val West = Value("West")
       }

       for (d <- Direction.values) print(d + " ")
       // North East South West
     #+END_SRC

   - Values of an enumeration are numbered from 0, and use the ~id~ method to
     find out them: ~Direction.East.id~

   - Get a variant of /enumeration/ from a integer. For example the result of
     ~Direction(1)~ is ~Direction.East~

** DONE 20.10 Case study: Currencies - 463 - =RE-READ=
   CLOSED: [2017-11-12 Sun 01:26]
** DONE 20.11 Conclusion - 473
   CLOSED: [2017-11-12 Sun 01:26]

* DONE 21 Implicit Conversions and Parameters - 474
  CLOSED: [2017-11-18 Sat 00:02]
  - Summary to the features of the other languages which can (partially) do the
    things Scala can do with _implicit conversions and parameters_
    + Powerful but also dangerous, in that you can modify the behavior of a class
      for an entire application, some parts of which you might not know.
      * Ruby: =TODO=
        modules

      * Smalltalk: =TODO=
        packages that add to each other's classes

    + More local but also more restrictive.
      * C# 3.0: =TODO=
        /static extension methods/

        In that you can only add /methods/, *NOT* /fields/, to a /class/,
        and you *CAN'T* make a /class/ _implement new interfaces_.

** DONE 21.1 Implicit conversions - 474
   CLOSED: [2017-11-16 Thu 03:34]
   - /Implicit conversions/ are often helpful for working with two bodies of
     software that were developed WITHOUT each other in mind:
       they help _by *reducing* the number of explicit conversions_ that are
     needed from one type to another.

   - Example:
     #+BEGIN_SRC scala
       // Use Swing
       val button = new JButton

       // If no implicit convertion
       button.addActionListener(
         new ActionListener {
           def actionPerformed(event: ActionEvent) = {
             println("pressed!")
           }
         }
       )


       // Eliminate information-free boilerplate code.
       // (Scala 2.12, which includes support to Java 8 feature, can compile the code
       // below)
       button.addActionListener(
         // Type mismatch if no implicit conversion or Scala that < 2.12!
         (_: ActionEvent) => println("pressed!")
       )


       // With implicit convertion
       implicit def function2ActionListener(f: ActionEvent => Unit) =
         new ActionListener {
           def actionPerformed(event: ActionEvent) = f(event)
         }

       button.addActionListener(
         (_: ActionEvent) => println("pressed!")
       )
       // This is actually
       // button.addActionListener(
       //   function2ActionListener(
       //     (_: ActionEvent) => println("pressed!")
       //   )
       // )
     #+END_SRC

   - In this section, we
     + illustrated some of the power of implicit conversions

       and

     + how they let you dress up existing libraries.

   - In the next sections, you'll learn =TODO=
     + the rules that determine when /implicit conversions/ are tried

       and

     + how they are found.

** DONE 21.2 Rules for implicits - 477
   CLOSED: [2017-11-17 Fri 23:58]
   - /implict operations/ are for clarification,
     + It is NOT a show off of magic.
     + It is NOT used to confuse people.

   - /Implicit conversions/ are *governed* by the following general rules:

     + Marking rule :: Only definitions marked ~implicit~ are available.
       * You can use ~implicit~ to mark any
         (footnote: /Variables/ and /singleton objects/ marked ~implicit~ can be
          used as /implicit parameters/. This use case will be described later
          in this chapter. =TODO=)

         - /variable/ definition =???=
         - /function/ definition
         - /object/ definition =???=

     + Scope rule :: An inserted /implicit conversion/ must
       * be in scope as a /single identifier/
         For example, ~someVariable.convert~ won't be considered (not a /single
         indentifier/), you must import and use ~convert~ directly

         or

       * be associated with the source or target type of the
         conversion.

         The companion object will be considered without explicitly import.
         #+BEGIN_SRC scala
           object Dollar {
             implicit def dollarToEuro(x: Dollar): Euro = ...
           }

           class Dollar { ... }
         #+END_SRC
         The /implicit conversion/ function can also be in the ~Euro~ companion
         object. Both works.

   - It is common for libraries to include a ~Preamble~ object including a number
     of useful implicit conversions. Code that uses the library can then do a
     single ~import Preamble._~ to access the library's /implicit conversions/.

   - One-at-a-time rule :: Only _one_ implicit is inserted.
        The compiler will *NEVER* rewrite ~x + y~ to ~convert1(convert2(x)) + y~.

   - Explicits-first rule :: Whenever code type checks as it is written, no
        implicits are attempted.

*** DONE Naming an implicit conversion
    CLOSED: [2017-11-16 Thu 04:31]
    - The name of an /implicit conversion/ matters only in _TWO_ situations:
      + If you want to write it explicitly in a method application
      + for determining which implicit conversions are available at any place in
        the program -- you can import (by name) only the ones you need.

*** DONE Where implicits are tried
    CLOSED: [2017-11-17 Fri 23:59]
    - There are _THREE_ places /implicits/ are used in the language:
      + conversions to an expected type:
        /Implicit conversions/ to an expected type let you use one type in a
        context where a different type is expected.
        For example, ~String~ to ~IndexedSeq[Char]~

      + conversions of the /receiver/ of a selection:
        Conversions of the receiver let you adapt the receiver of a method call
        (i.e., the object on which a method is invoked), if the method is not
        applicable on the original type.

        For example, ~"abc".exists~ to ~stringWrapper("abc").exists~
        (~exist~ is available on ~IndexedSeq~'s rather than ~String~'s)


      + /implicit parameters/: like the /type class/ in Haskell - add /implicit
        parameters/ to a generic function to provide more information to the
        generic type(s).

** DONE 21.3 Implicit conversion to an expected type - 480
   CLOSED: [2017-11-16 Thu 04:31]
   Example:
   #+BEGIN_SRC scala
     // This is in `Predef`
     implicit def int2double(x: Int): Double = x.toDouble
   #+END_SRC
   That's why in Scala ~Int~ values can be stored in variables of type ~Double~.
     There's _NO_ special rule in the type system for this; it's just an
   /implicit conversion/ that gets applied.

   - footnote:
     The Scala compiler backend will treat the conversion specially, however,
     translating it to a special ~i2d~ bytecode. So the compiled image is the
     same as in Java.

** DONE 21.4 Converting the receiver - 482
   CLOSED: [2017-11-16 Thu 06:19]
   - /Implicit conversions/ also apply to the /receiver/ of a /method call/, the
     object on which the /method/ is invoked.
       This kind of implicit conversion has _TWO main uses_:
     1. /receiver conversions/ allow smoother integration of a NEW class into an
        existing class hierarchy.

     2. they support writing DSL's within the language.

*** DONE Interoperating with new types - 482
    CLOSED: [2017-11-16 Thu 05:48]
    #+BEGIN_SRC scala
      class Rational(n: Int, d: Int) {
        // ...
        def + (that: Rational): Rational = ...
        def + (that: Int): Rational = ...
      }

      val oneHalf = new Rational(1, 2)
      oneHalf + oneHalf  // res0: Rational = 1/1
      oneHalf + 1        // res1: Rational = 3/2

      // BUT this doesn't compile (if without an implicit conversion)
      1 + oneHalf

      // Then
      implicit def intToRational(x: Int) = new Rational(x, 1)

      1 + oneHalf
      // res2: Rational = 3/2
      //// In the background: `intToRational(1) + oneHalf`
    #+END_SRC

*** DONE Simulating new syntax - 483
    CLOSED: [2017-11-16 Thu 06:03]
    - Consider the ~->~ in a ~Map~ like ~Map(1 -> "one", 2 -> "two",
      3 -> "three")~
      + It is *NOT* syntax!!!

      + It is a method of the class ~ArrowAssoc~, a class defined inside the
        standard Scala preamble (~scala.Predef)~.

        The preamble also defines an /implicit conversion/ from ~Any~ to
        ~ArrowAssoc~ (then the ~->~ method can be used).

      #+BEGIN_SRC scala
        package scala

        object Predef {
          class ArrowAssoc[A](x: A) {
            def -> [B](y: B): Tuple2[A, B] = Tuple2(x, y)
          }

          implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =
            new ArrowAssoc(x)

          //...
        }
      #+END_SRC

    - There are a lot of ~Rich<Something>~ classes (e.g., ~RichInt~ or
      ~RichBoolean~). That class is likely adding _syntax-like methods_ to type
      ~<Something>~.

    - An internal DSL can be defined as a library with the help of /implicit
      conversion/.

*** DONE Implicit classes - 485
    CLOSED: [2017-11-16 Thu 06:19]
    - /Implicit classes/ were added in Scala *2.10* to make it easier to write
      /rich wrapper classes/.

      For any such class, the compiler generates an /implicit conversion/

      *from* the class's constructor parameter *to* the class itself.

      Such a conversion is just what you need if you plan to use the class for
      the /rich wrappers pattern/.

    - Example:
      #+BEGIN_SRC scala
        case class Rectangle(width: Int, height: Int)

        implicit class RectangleMaker(width: Int) {
          def x(height: Int) = Rectangle(width, height)
        }

        // Then we can do
        val myRectangle = 3 x 4
        // myRectangle: Rectangle = Rectangle(3, 4)
      #+END_SRC

    - NOT any class can have ~implicit~ put in front of it.

      An /implicit class/
      + CANNOT be a /case class/
      + its constructor MUST have exactly _ONE_ parameter.
      + an /implicit class/ cannot be in top level, and it MUST be located within
        some other /object/, /class/, or /trait/.

      In practice, so long as you use /implicit classes/ as /rich wrappers/ to
      add a few methods onto an _existing class_, these restrictions should NOT
      matter.

** DONE 21.5 Implicit parameters - 485
   CLOSED: [2017-11-16 Thu 18:38]
   - Example (default parameters):
     #+BEGIN_SRC scala
       class PreferredPrompt(val preference: String)
       class PreferredDrink(val preference: String)

       object Greeter {
         def greet(name: String)(implicit prompt: PreferredPrompt,
                                 drink: PreferredDrink) = {
           println("Welcome, " + name + ". The system is ready.")
           print("But while you work, ")
           println("why not enjoy a cup of " + drink.preference + "?")
           println(prompt.preference)
         }
       }

       object JoesPrefs {
         implicit val prompt = new PreferredPrompt("Yes, master> ")
         implicit val drink = new PreferredDrink("tea")
       }

       Greeter.greet("Joe")(prompt, drink)
       // OR
       Greeter.greet("Joe")

       // Welcome, Joe. The system is ready.
       // But while you work, why not enjoy a cup of tea?
       // Yes, master>
     #+END_SRC

     + ~implicit~ above is used to mark the _ENTIRE last parameter list_, NOT
       only the ~prompt~!

     + Because the compiler selects /implicit parameters/ _by matching types of
       parameters against types of values in scope_, /implicit parameters/
       usually have *"RARE"* or *"special"* enough types that accidental matches
       are unlikely.

       =From Jian= You mustn't be crazy to use types like ~Int~, ~String~, etc,
       in a scope of large.

   - They are perhaps most often used to provide information about a type
     mentioned explicitly in an _earlier_ parameter list, similar to the /type
     classes/ of Haskell. =IMPORTANT=

     + Example (type-classes-like):
       #+BEGIN_SRC scala
         //// _Replace_
         // def maxListOrdering[T](elements: List[T])
         //                    (ordering: Ordering[T]): T =
         //// _With_
         def maxListOrdering[T](elements: List[T])
                            (implicit ordering: Ordering[T]): T =
           elements match {
             case List() =>
               throw new IllegalArgumentException("empty list!")
             case List(x) => x
             case x :: rest =>
               val maxRest = maxListOrdering(rest)(ordering)
               if (ordering.gt(x, maxRest)) x
               else maxRest
           }
       #+END_SRC

       This pattern is so common that _the standard Scala library provides
       implicit "ordering" methods for many common types_. That's way we can
       mostly use ~maxListImpParm~ *without* providing the implicit ~ordering~
       argument.

*** DONE A style rule for implicit parameters
    CLOSED: [2017-11-16 Thu 18:38]
    It is best to use a custom named type in the types of /implicit parameters/.
    As a counter-example,
    #+BEGIN_SRC scala
      def maxListPoorStyle[T](elements: List[T])
                          (implicit orderer: (T, T) => Boolean): T
    #+END_SRC
    - The ~(T, T) => Boolean~ is a farily generic type that, however, without
      indicating anything at all about what the type is for -- it could be
      + a equality test
      + a less than test
      + a greater-than test
      + a something else

    - It is easy for the compiler to "mistakenly" (actually, the compiler is
      "right", and human make mistakes) pick a wrong implicit value with this
      fairly generic type ~(T, T) => Boolean~.

      *Simply speaking, it is error prone!!!*

    - The good style one is of type ~Ordering[T]~, which is informative.

    - Thus *the style rule*:
      Use at least one role-determining name within the type of an /implicit
      parameter/.

** DONE 21.6 Context bounds - 491
   CLOSED: [2017-11-17 Fri 15:07]
   #+BEGIN_SRC scala
     def maxList[T](elements: List[T])
                (implicit ordering: Ordering[T]): T =
       elements match {
         case List() =>
           throw new IllegalArgumentException("empty list!")
         case List(x) => x
         case x :: rest =>
           val maxRest = maxList(rest)
           if (implicitly[Ordering[T]].gt(x, maxRest)) x
           else maxRest
     }
   #+END_SRC
   We can get rid of the ~ordering~ inside the body of ~maxList~ by
   - Use the already in-scope implicit argument(s):
     ~maxList(rest)(ordering)~ is simplified to ~maxList(rest)~

   - Use the ~implicitly[T]~ function, which is defined in the standard library
     as ~def implicitly[T](implicit t: T) = t~:
     ~ordering.gt(x, maxRest)~ is simplified (globally, rather than locally --
     the length is longer) to ~implicitly[Ordering[T]].gt(x, maxRest)~

     After applying the two steps above, there is no ~ordering~ inside the body
     of ~maxList~, which is good that when changing the name of the /implicit
     parameter/, there is no need to change the body of this function.

   - This pattern if common, Scala lets you leave out the name of this parameter
     and shorten the method header by using a /context bound/.
     #+BEGIN_SRC scala
       def maxList[T : Ordering](elements: List[T]): T = ...
     #+END_SRC
     With /context bound/ we don't have the name of the implicit parameter, the
     use of ~implicitly[T]~ is then not just "another way", but the only way.

   - Comparison (subtype vs context bound)
     + ~[T <: Ordered[T]]~: ~T~ is an ~Ordered[T]~.

     + ~[T : Ordering]~: some form of ordering associated with ~T~.
       This is more flexible than the ~[T <: Ordered[T]]~.

** DONE 21.7 When multiple conversions apply - 494
   CLOSED: [2017-11-17 Fri 15:36]
   If MULTIPLE implicit conversions exist,
   - Up through Scala 2.7, this triggers compiler error!

     This is like method overloading, but more strict.

   - Scala 2.8+ lossened this rule -- the more specific one is chosen.

     This is like method overloading, and same strictness.

     What does the "specific" here means?
     + The argument type of the former is a subtype of the latter's.

     + Both conversions are methods, and the enclosing class of the former
       extends the enclosing class of the latter.

         For example, ~Predef~ extends ~LowPriorityImplicits~, and the
       _implicit's_ in ~Predef~ that not come from ~LowPriorityImplicits~ has
       high priority.

   - In Scala 2.7, for example, since Java ~String~ doesn't have the ~reverse~
     method,
     1. In ~val cba = "abc".reverse~, ~cba~ is a collection.

        ~"abc"~ was first converted to a /Scala collection/, and the reversing a
        /Scala collection/ yields a /Scala collection/.

     2. There's also an /implicit conversion/ back to a string, but that didn't
        patch up every problem.
          For example, ~"abc" == "abc".reverse.reverse~ was ~false~ !!!!!!

   - With Scala 2.8, the type of ~cba~ is ~String~.

     The old implicit conversion to a Scala collection (~WrappedString~) is
     retained.

     HOWEVER, there is a more specific conversion supplied from ~String~ to a
     new type called ~StringOps~.

       The conversion to ~StringOps~ is defined directly in ~Predef~, whereas the
     definition of the retained conversion to a Scala collection is moved to a
     new class, ~LowPriorityImplicits~, which is extended by ~Predef~. Apply the
     second rule, we know the /implicit conversion/ in ~Predef~ is preferred.

** DONE 21.8 Debugging implicits - 496
   CLOSED: [2017-11-17 Fri 23:22]
   - Some debug tips:
     1. When you see some error you don't quite get it, try to *convert the
        /implicit conversion/ explicitly*. Then the error message may become
        clear.
        #+BEGIN_SRC scala
          // scala>
          val chars: List[Char] = "xyz"
          // <console>:24: error: type mismatch;
          //  found : String("xyz")
          //  required: List[Char]
          //        val chars: List[Char] = "xyz"
          //                                ^

          scala> val chars: List[Char] = wrapString("xyz")
          // <console>:24: error: type mismatch;
          //  found : scala.collection.immutable.WrappedString
          //  required: List[Char]
          //        val chars: List[Char] = wrapString("xyz")
          //                                          ^
        #+END_SRC

     2. After applying 1, if there is not any error, you need to consider the
        other reasons (such as _the Scope Rule_) that prevent the /implicit
        conversion/ from being applied.

     3. Try the ~-Xprint:typer~ option of ~scalac~, and the compiler will show
        you what your code looks like after all implicit conversions have been
        added by the type checker. *Details are given in the next secion*!

** DONE 21.9 Conclusion - 497
   CLOSED: [2017-11-17 Fri 23:54]
   - /Implicit/ are a powerful, _code-condensing_ feature of Scala.

   - Warning:
     /implicits/ can make code confusing if they are used too frequently.

   - Before adding a new implicit conversion, first try other means, such as
     + inheritance
     + mixin composition
     + method overloading

   - Check the code after /type checking/ and /insertion of implicits/:
     #+BEGIN_SRC scala
       // Mocha.scala
       object Mocha extends App {
         class PreferredDrink(val preference: String)
         implicit val pref = new PreferredDrink("mocha")
         def enjoy(name: String)(implicit drink: PreferredDrink) = {
           print("Welcome, " + name)
           print(". Enjoy a ")
           print(drink.preference)
           println("!")
         }
         enjoy("reader")
       }
     #+END_SRC

     + Run ~scalac -Xprint: typer mocha.scala~
       #+BEGIN_SRC scala
         // [[syntax trees at end of                     typer]] // Mocha.scala
         package <empty> {
           object Mocha extends AnyRef with App {
             def <init>(): Mocha.type = {
               Mocha.super.<init>();
               ()
             };
             class PreferredDrink extends scala.AnyRef {
               <paramaccessor> private[this] val preference: String = _;
               <stable> <accessor> <paramaccessor> def preference: String = PreferredDrink.this.preference;
               def <init>(preference: String): Mocha.PreferredDrink = {
                 PreferredDrink.super.<init>();
                 ()
               }
             };
             private[this] val pref: Mocha.PreferredDrink = new Mocha.this.PreferredDrink("mocha");
             implicit <stable> <accessor> def pref: Mocha.PreferredDrink = Mocha.this.pref;
             def enjoy(name: String)(implicit drink: Mocha.PreferredDrink): Unit = {
               scala.Predef.print("Welcome, ".+(name));
               scala.Predef.print(". Enjoy a ");
               scala.Predef.print(drink.preference);
               scala.Predef.println("!")
             };
             Mocha.this.enjoy("reader")(Mocha.this.pref)
           }
         }
       #+END_SRC

* DONE 22 Implementing Lists - 499
  CLOSED: [2018-03-20 Tue 03:47]
  - Chapter 16 showed you how to use lists.
    This chapter “opens up the covers” and explains a bit about how lists are
    implemented in Scala.

  - Knowing the internal workings of the ~List~ /class/ is useful for several
    reasons:

    + Gain a better idea of _the relative efficiency of list operations_,
      which will help you in writing fast and compact code using lists.

    + From the implementation of Scala ~List~ to _learn how to design_ your own
      libraries.

    + Finally, the ~List~ /class/ is a sophisticated application of Scala's type
      system in general and its genericity concepts in particular.
        So studying class List will deepen your knowledge in these areas.

** DONE 22.1 The ~List~ class in principle - 499
   CLOSED: [2018-03-20 Tue 02:19]
   - Scala ~List~'s is NOT built-in.
     They are defined by an /abstract class/ ~List~ in the ~scala~ package, which
     comes with two /subclasses/ for ~::~ and ~Nil~.
     #+BEGIN_SRC scala
       package scala

       abstract class List[+T] {
         // ...
       }
     #+END_SRC

     + Since it is /abstract/, you cannot ~new~ a ~List~.
       You can only use the /factory method/!

   - This section presents a somewhat *simplified* account of the class,
     compared to its _real implementation_ in the Scala standard library, which
     is covered in Section 22.3.

   - This chapter will present a somewhat simplified account of ~List~.

   - ~List[T]~ has two subtypes:
     + the /case object/ ~scala.Nil~

     + the ~final~ /case class/ ~scala.::[T]~

   - All list operations can be defined in terms of three basic methods:
     + ~def isEmpty: Boolean~

     + ~def head: T~

     + ~def tail: List[T]~

     They are all /abstract/ in ~List~

*** DONE The ~Nil~ object - 500
    CLOSED: [2018-03-20 Tue 02:10]
    #+BEGIN_SRC scala
      // Simplified
      case object Nil extends List[Nothing] {
        override def isEmpty = true

        override def head: Nothing =
          throw new NoSuchElementException("head of empty list")

        override def tail: List[Nothing] =
          throw new NoSuchElementException("tail of empty list")
      }
    #+END_SRC

    Here ~Nothing~ is NOT only reasonable but also guarantee the /convariance/.

*** DONE The ~::~ class - 501
    CLOSED: [2018-03-20 Tue 02:10]
    #+BEGIN_SRC scala
      final case class ::[B](head: B, private[scala] var tail: List[B]) extends List[B] {
        override def isEmpty: Boolean = false
      }


      /* The implementation in the standard library */

      // final case class ::[B](override val head: B, private[scala] var tl: List[B]) extends List[B] {
      //   override def tail: List[B] = tl
      //   override def isEmpty: Boolean = false
      // }
    #+END_SRC

*** DONE Some more methods - 502
    CLOSED: [2018-03-20 Tue 02:13]
    All other List methods can be written using the basic three. For instance:
    #+BEGIN_SRC scala

      def length: Int =
        if (isEmpty) 0 else 1 + tail.length

      // or:
      def drop(n: Int): List[T] =
        if (isEmpty) Nil  else
        if (n <= 0)  this else
                     tail.drop(n 1)

      // or:
      def map[U](f: T => U): List[U] =
        if (isEmpty) Nil
        else         f(head) :: tail.map(f)
    #+END_SRC

*** DONE List construction - 503
    CLOSED: [2018-03-20 Tue 02:19]
    The list construction methods ~\colon{}\colon{}~ and ~:::~ are SPECIAL.
    Because they end in a colon, they are _bound to their right operand_.
    #+BEGIN_SRC scala
      def ::[U >: T](x: U): List[U] = new scala.::(x, this)

      def :::[U >: T](prefix: List[U]): List[U] =
        if (prefix.isEmpty) this
        else                prefix.head :: prefix.tail ::: this
    #+END_SRC

** DONE 22.2 The ~ListBuffer~ class - 505
   CLOSED: [2018-03-20 Tue 02:27]
   - ~List~ is inefficient on adding elements to the end of its tail.
     Try to use ~ListBuffer~.

   - ~ListBuffer~ is a class in package ~scala.collection.mutable~.

   - Use ~ListBuffer~ to build a list-like structure, and use ~toList~ /method/
     to convert itself to a ~List~ at the end of a sequence of operations.
       For example,
     #+BEGIN_SRC scala
       import scala.collection.mutable.ListBuffer


       val buf = new ListBuffer[Int]
       for (x <xs)
         buf += x + 1
       buf.toList
     #+END_SRC

   - This is a *very efficient* way to build lists.

     In fact, the list buffer implementation is organized so that both the
     append operation (~+=~) and the ~toList~ operation take (very short)
     constant time.

** DONE 22.3 The ~List~ class in practice - 507
   CLOSED: [2018-03-20 Tue 03:47]
   - The implementations of list methods given in Section 22.1 are concise and
     clear, but _suffer from the same stack overflow problem_ as the /non-tail
     recursive implementation/ of ~incAll~.

   - Therefore, most methods in the *REAL implementation* of /class/ ~List~
     *avoid* /recursion/ and *use* /loops/ with /list buffers/ instead.

     For example,
     #+BEGIN_SRC scala
       final override def map[U](f: T => U): List[U] = {
         val b = new ListBuffer[U]

         var these = this

         while (!these.isEmpty) {
           b += f(these.head)
           these = these.tail
         }
         b.toList
       }
     #+END_SRC
     + This is very efficient.

     + A /tail recursive/ implementation would be similarly efficient,
       but _a general recursive implementation, in Scala, would be slower and
       less scalable_.

     + The last /method/ invoke ~toList~ takes only a small number of cycles,
       which is *independent of the length of the list*.

       * To understand why, take a second look at /class/ ~::~, which
         constructs non-empty lists -- the real one, NOT the one in Section 22.1!
         #+BEGIN_SRC scala
           final case class ::[U](hd: U,
               private[scala] var tl: List[U]) extends List[U] {
             def head = hd
             def tail = tl
             override def isEmpty: Boolean = false
           }
         #+END_SRC
         - One peculiarity here is the ~tl~ argument is a ~var~ -- it can be
           modified, but only by the members in package ~scala~.

           ~ListBuffer~ is inside package ~scala.collection.mutalbe~, and it can
           access the ~tl~ field of a cons cell.

         - In fact the elements of a /list buffer/ are represented as a /list/
           and appending new elements involves a modification of the ~tl~ field
           of the last ~::~ cell in that /list/. Here's the start of class
           ~ListBuffer~:
           #+BEGIN_SRC scala
             package scala.collection.immutable

             final class ListBuffer[T] extends Buffer[T] {
               private var start: List[T] = Nil  // points to the list of all elements stored in the buffer
               private var last0: ::[T] = _      // points to the last :: cell in that list

               // indicates whether the buffer has been turned into a list using
               // a toList operation
               private var exported: Boolean = false
               // ...
             }
           #+END_SRC

         - The ~toList~ operation is very simple:
           #+BEGIN_SRC scala
             override def toList: List[T] = {
               exported = !start.isEmpty
               start
             }
           #+END_SRC
           This is very efficient because it _does NOT copy_ the list which is
           stored in a ~ListBuffer~.

         - But what happens if the list is further extended after the ~toList~
           operation?
           _Of course, once a list is returned from ~toList~, it MUST be
           *immutable*._
           And appending to the ~last0~ element will modify the list which is
           referred to by ~start~. To avoid this and maintain the correctness of
           the /list buffer/ operations, a fresh list is required! This is
           achieved by the first line in the implementation of the ~+=~
           operation:
           #+BEGIN_SRC scala
             override def += (x: T) = {
               if (exported) copy()

               if (start.isEmpty) {
                 last0 = new scala.::(x, Nil)
                 start = last0
               } else {
                 val last1 = last0
                 last0 = new scala.::(x, Nil)
                 last1.tl = last0
               }
             }
           #+END_SRC
           You see that ~+=~ _copies_ the list pointed to by ~start~ if
           ~exported~ is _true_. So, in the end, there is *no free lunch*.

           If you want to go from lists which can be extended at the end to
           immutable lists, there needs to be some copying.

           However, the implementation of ~ListBuffer~ is such that copying is
           necessary *only* for /list buffers/ that are _FURTHER extended *after*
           they have been turned into /lists/._ *This case is quite rare in
           practice.* Most use cases of /list buffers/ add elements incrementally
           and then do one ~toList~ operation at the end. In such cases, no
           copying is necessary.

** DONE 22.4 Functional on the outside - 509
   CLOSED: [2018-03-20 Tue 03:16]
   - You saw that ~List~'s are
     + purely functional on the "outside"
       but
     + have an imperative implementation using ~ListBuffer~'s on the "inside."

     This is a typical strategy in Scala programming -- trying to combine purity
     with efficiency by carefully *delimiting* the effects of impure operations.

   - Q: Why *NOT* just make ~tl~ accessible and mutable?

     A: For example, if we do so, the code below will introduce side effects that
        are hard to track.
        #+BEGIN_SRC scala
          // `ys` and `zs` share the tail `xs`
          val ys = 1 :: xs
          val zs = 2 :: xs

          // ILLEGAL
          // code in Scala, but this is reasonable if `tail` (actually `tl`) is mutable
          ys.drop(2).tail = Nil

          // This can affect the tail of `ys` and `zs`
        #+END_SRC

   - The ~ListBuffer~ /class/ still allows you to build up lists imperatively and
     incrementally, if you wish. But since /list buffers/ are *not* /lists/, the
     types _keep /mutable buffers/ and /immutable lists/ *separate*._

   - The design of Scala's ~List~ and ~ListBuffer~ is quite similar to what's
     done in Java's pair of classes ~String~ and ~StringBuffer~ (or since Java
     5, the mostly used ~StringBuilder~) . This is *NOT* coincidence.

** DONE 22.5 Conclusion - 510
   CLOSED: [2018-03-20 Tue 03:24]
   This chapter talks about the implementation of the ~List~ in Scala.

   - Instead of recursing through this structure,
     however, _many core list /methods/_ are implemented using a ~ListBuffer~.

   - ~ListBuffer~, in turn, is carefully implemented so that it can
     _efficiently build_ lists *without* allocating extraneous memory.

   - Functional on the outside for the clarity.
     Somehow, imperative inside to speed up the common case where a buffer is
     discarded after ~toList~ has been called.

* DONE 23 For Expressions Revisited - 512
  CLOSED: [2018-03-28 Wed 23:43]
  - More generally,
    + ALL ~for~ expressions that ~yield~ a result are _translated_ by the
      compiler into combinations of invocations of the higher-order methods
      ~map~, ~flatMap~, and ~withFilter~.

    + ALL ~for~ loops WITHOUT ~yield~ are translated into a smaller set of
      higher-order functions: just ~withFilter~ and ~foreach~.

  - In this chapter, you'll find out
    1. the precise rules of writing for expressions
    2. how they can make combinatorial problems easier to solve.
    3. how ~for~ expressions are translated, and how as a result, ~for~
       expressions can help you "grow" the Scala language into new application
       domains.

** DONE 23.1 ~for~ expressions - 513
   CLOSED: [2017-10-21 Sat 21:52]
   Syntax: ~for ( seq ) yield expr~

   - Here, ~seq~ is a sequence of /generators/, /definitions/, and /filters/,
     with semicolons between successive elements.

   - Enclose the ~seq~ in /braces/ instead of /parentheses/. Then the semicolons
     become _optional_:
     #+BEGIN_SRC scala
       for (p <- persons; n = p.name; if (n startsWith "To"))
       yield n

       // OR

       for {
         p <- persons             // a generator
         n = p.name               // a definition
         if (n startsWith "To")   // a filter
       } yield n
     #+END_SRC

     + A /generator/ is of the form: ~pat <- expr~
       The ~pat~ gets matched one-by-one against all elements. If the match fails
       the element is simply discarded from the iteration (=From Jian= this will
       be proved a good feature)

       * the most common case: a variable. Then simply iterates over all elements

     + If there are multiple generators, later ones are for inner iterations.

       =From Jian= I don't think write a embeded structure in a flat form is a
       good idea.

   -

** DONE 23.2 The n-queens problem - 515
   CLOSED: [2018-03-28 Wed 23:43]
   - Start numbering cells at one:
     + upper-left cell of N \times{} N board has coordinate (1, 1)
     + lower-right cell of N \times{} N board has coordinate (N, N)

   - Give up and re-do the search if you *cannot* find a location to a queen
     anymore!

   - The imperative solution:
     it would place queens one by one, moving them around on the board.

       But it looks _difficult to_ come up with a scheme that really _tries all
     possibilities_.

   - A more functional approach *represents a solution directly, as a value*.
     A solution consists of a list of coordinates, one for each queen placed on
     the board (you still need to build the solution gradually!).

   - 0-queuen problem has one solution, and the solution list is ~List(List())~.

   - 2-queuen problem has no solution, and the solution list is ~List()~.

   - Code (get all solutions -- this can be very slow for large N):
     #+BEGIN_SRC scala
       def queens(n: Int): List[List[(Int, Int)]] = {
         def placeQueens(k: Int): List[List[(Int, Int)]] =
           if (k == 0)
             List(List())
           else
             for {
               queens <- placeQueens(k - 1)
               column <- 1 to n
               queen = (k, column)
               if isSafe(queen, queens)
             } yield queen :: queens
         placeQueens(n)
       }

       def isSafe(queen: (Int, Int), queens: List[(Int, Int)]) =
         queens forall (q => !inCheck(queen, q))

       def inCheck(q1: (Int, Int), q2: (Int, Int)) =
         // q1._1 == q2._1 || // same row -- we have already pick queens by row to guarantee this
         q1._2 == q2._2 || // same column
          (q1._1 - q2._1).abs == (q1._2 - q2._2).abs // on diagonal
     #+END_SRC

** DONE 23.3 Querying with ~for~ expressions - 518
   CLOSED: [2017-10-21 Sat 22:00]
** DONE 23.4 Translation of ~for~ expressions - 520 =Re-READ=
   CLOSED: [2017-10-21 Sat 22:25]
*** DONE Translating ~for~ expressions with one generator
    CLOSED: [2017-10-21 Sat 22:10]
    ~for (x <- expr1) yield expr2~    ------->    ~expr1.map(x => expr2)~

*** DONE Translating ~for~ expressions starting with a generator and a filter
    CLOSED: [2017-10-21 Sat 22:10]
    ~for (x <- expr1 if expr2) yield expr3~
    ------->    ~for (x <- expr1 withFilter (x => expr2)) yield expr3~
    ------->    ~expr1 withFilter (x => expr2) map (x => expr3)~


    ~for (x <- expr1 if expr2; seq) yield expr3~
    ------->    ~for (x <- expr1 withFilter (x => expr2); seq) yield expr3~
    Then translation continues with the second expression, which is again shorter
    by one element than the original one.

*** DONE Translating ~for~ expressions starting with two generators
    CLOSED: [2017-10-21 Sat 22:10]
    ~for (x <- expr1; y <expr2; seq) yield expr3~
    ------->    ~expr1.flatMap (x => for (y <- expr2; seq) yield expr3)~

    - Example:
      In Section 23.3 we have
      #+BEGIN_SRC scala
        for (b1 <- books; b2 <- books if b1 != b2;
             a1 <- b1.authors; a2 <- b2.authors if a1 == a2)
        yield a1

        // Translation
        books flatMap (b1 =>
          books withFilter (b2 => b1 != b2) flatMap (b2 =>
            b1.authors flatMap (a1 =>
              b2.authors withFilter (a2 => a1 == a2) map (a2 =>
                a1))))
      #+END_SRC

*** DONE Translating patterns in generators
    CLOSED: [2017-10-21 Sat 22:15]
    ~for ((x1, ..., xn) <- expr1) yield expr2~
    ------->    ~expr1.map { case (x1, ..., xn) => expr2 }~

    More general patterns,
    ~for (pat <- expr1) yield expr2~
    ------->
    #+BEGIN_SRC scala
      expr1 withFilter {
        case pat => true
        case _ => false
      } map {
        case pat => expr2
      }
    #+END_SRC

    More than one patterns cases don't add much new insight, just omit them here.
    (More info about this in *Scala Language Specification*)

*** DONE Translating definitions
    CLOSED: [2017-10-21 Sat 22:21]
    ~for (x <- expr1; y = expr2; seq) yield expr3~
    Assume again that ~seq~ is a (possibly empty) sequence of /generators/,
    /definitions/, and /filters/. This expression is translated to this one:

    ------->
    #+BEGIN_SRC scala
      // From Jian: expr2 is often a function of x.
      //            If not, no reason to re-evaluate expr2 every iteration
      for ((x, y) <- for (x <- expr1) yield (x, expr2); seq)
      yield expr3
    #+END_SRC

*** DONE Translating ~for~ loops
    CLOSED: [2017-10-21 Sat 22:24]
    In principle, wherever the previous translation scheme used a ~map~ or a
    ~flatMap~ in the translation, the translation scheme for /for loops/ uses
    just a ~foreach~.

    ~for (x <- expr1) body~
    -------> ~expr1 foreach (x => body)~

    ~for (x <- expr1; if expr2; y <- expr3) body~
    -------> ~expr1 withFilter (x => expr2) foreach (x =>
                expr3 foreach (y => body))~

** DONE 23.5 Going the other way - 524
   CLOSED: [2017-10-21 Sat 22:29]
   Every application of a ~map~, ~flatMap~, or ~filter~ can be represented as a
   /for expression/.

   #+BEGIN_SRC scala
     object Demo {
       def map[A, B](xs: List[A], f: A => B): List[B] =
         for (x <- xs) yield f(x)

       def flatMap[A, B](xs: List[A], f: A => List[B]): List[B] =
         for (x <- xs; y <- f(x)) yield y

       def filter[A](xs: List[A], p: A => Boolean): List[A] =
         for (x <- xs if p(x)) yield x
     }
   #+END_SRC

   Not surprisingly, the body of the above definitions (for expression) will be
   translated to higher order functions by Scala in the background.

** DONE 23.6 Generalizing ~for~ - 525 =Re-Read the last some paragraph=
   CLOSED: [2018-03-28 Wed 22:46]
   - Because the translation of ~for~ expressions only relies on the presence of
     methods ~map~, ~flatMap~, and ~withFilter~, it is possible to apply the
     ~for~ notation to a large class of data types.

   - We have see /for expressions/ over /lists/ and /arrays/.
     There are supported because they have ~map~, ~flatMap~, and ~withFilter~.

   - We have see /for loop/ over /lists/ and /arrays/.
     There are supported because they have ~foreach~.

   - Examples that support /for expressions/ and /for loops/:
     + /ranges/
     + /iterators/
     + /streams/
     + all implementations of /sets/.

   - You can have your own defined /class/ that support /for expressions/ and
     /for loops/.

     It is also possible to define a _subset_ of these /methods/, and thereby
     support a _subset_ of all possible /for expressions/ and /for loops/.

   - Here are the precise rules:
     + If your type defines just ~map~, it allows /for expressions/ consisting of a
       *SINGLE generator*.

     + If it defines ~flatMap~ as well as ~map~, it allows /for expressions/
       consisting of *SEVERAL generators*.

     + If it defines ~foreach~, it allows /for loops/ (both with *single and
       multiple generators*).

     + If it defines ~withFilter~, it allows /for filter expressions/ starting
       with an ~if~ in the
       for expression. =From Jian= I think this should work for both /for loops/
       and /for expressions/.

   - The translation of /for expressions/ happens *before* /type checking/.
     This allows for maximum _flexibility_ because the _only requirement_ is
     that the result of expanding a /for expression/ /type checks/.

     Scala defines *NO* /typing rules/ for the /for expressions/ themselves, and
     does *NOT* require that /methods/ ~map~, ~flatMap~, ~withFilter~, or
     ~foreach~ have any particular type signatures.

     Nevertheless, there is a *typical setup* that captures the most common
     intention of the /higher order methods/ to which /for expressions/
     translate.
     #+BEGIN_SRC scala
       abstract class C[A] {
         def map[B](f: A => B): C[B]
         def flatMap[B](f: A => C[B]): C[B]
         def withFilter(p: A => Boolean): C[A]  // Not perfect, same as `filter`
         def foreach(b: A => Unit): Unit
       }
     #+END_SRC
     + For example, ~List~ has
       ~def withFilter(p: (A) ⇒ Boolean): FilterMonadic[A, List[A]]~

   - =TODO= =???=
     Concentrating on just the first three functions of /class/ ~C~, the following
     facts are noteworthy:
     In functional programming, there’s a general concept called a /monad/,
     which can explain a large number of types with computations, ranging from
     collections, to computations with state and I/O, backtracking computations,
     and transactions, to name a few.

     =TODO=
       *You can formulate functions ~map~, ~flatMap~, and ~withFilter~ on a
     /monad/, and, if you do, they end up having exactly the types given here.*

   - =TODO= /monad/ related =TODO= =Learn More= =!!!=

** DONE 23.7 Conclusion
   CLOSED: [2017-10-21 Sat 22:29]

* DONE 24 Collections in Depth - 528
  CLOSED: [2018-04-04 Wed 01:06]
  - Several NICE properties of Scala collections:
    + *Easy to use*
      * A small vocabulary of _twenty to fifty_ /methods/ is ENOUGH to solve most
        collection problems in a couple of operations.
        No need to explicitly wirte out complicated loopings or recursions.

      * /Persistent/ collections and /side-effect-free/ operations mean that
        you need not worry about accidentally corrupting existing collections
        with new data.
        =TODO= I need deeper understanding

        Interference between iterators and collection updates is eliminated.
        =TODO=

    + *Concise*
      No need to explicitly wirte out complicated loopings or recursions.

    + *Safe*
      =TODO=

    + *Fast*
      * _Collection operations_ are tuned and *OPTIMIZED* in the libraries.

      * /Parallel collections/ support the _SAME operations_ as /sequential
        collections/, so *NO* new operations need to be learned and no code
        needs to be rewritten. Just remember to call the ~par~ /method/ to turn
        a /sequantial collection/ into a /parallel collection/.

    + *Universal*
      /Collections/ provide *the SAME operations on ANY type* _where it makes sense
      to do so_.

  - What we've learned about Scala /collections/ library
    + We've already seen a quick tour of the collections library, in Chapter 17.

    What we will learn about Scala /collections/ library
    + This chapter *from a user perspective*
      describes in depth the APIs of the Scala collection classes

    + Looking ahead, =TODO=
      Chapter 25 *for people implementing* new collection types
      will concentrate on the *architecture* and *extensibility* aspects of the
      library,

** DONE 24.1 Mutable and immutable collections - 529
   CLOSED: [2017-11-21 Tue 05:51]
   - All /collection/ classes are found in the package ~scala.collection~ or one
     of its subpackages: ~mutable~, ~immutable~, and ~generic~.

   - Most /collection/ classes needed by client code exist in _THREE_ variants,
     each of which has DIFFERENT characteristics with respect to /mutability/.
       The three variants are located in packages
     + ~scala.collection~
     + ~scala.collection.immutable~
     + ~scala.collection.mutable~

   - A /collection/ in package ~scala.collection~ can be _either /mutable/ or
     /immutable/_.
       For instance, ~scala.collection.IndexedSeq[T]~ is a /supertrait/ of both
     ~scala.collection.immutable.IndexedSeq[T]~ and its mutable sibling
     ~scala.collection.mutable.IndexedSeq[T]~.

   - Generally, the *root* /collections/ in package ~scala.collection~ define the
     _SAME interface as the /immutable/ collections_. And typically, the /mutable
     collections/ in package ~scala.collection.mutable~ add some side-effecting
     modification operations to this immutable interface.

   - =TODO= =???= 530
     The _DIFFERENCE_ between *root* /collections/ and /immutable collections/
     + clients of an /immutable collection/ have a guarantee that nobody can
       mutate the collection,

     + whereas clients of a /root collection/ only know that they can't change
       the collection themselves. =???=

   - /Immutable collections/ is always the default.
     To use the /mutable collections/, you need to write explicitly the package
     names.

   - =TODO= ~collection.generic~ =TOOD=
     This package contains _building blocks_ for _IMPLEMENTING_ collections.
     Typically, collection classes defer the implementations of some of their
     operations to classes in ~generic~.

** DONE 24.2 Collections consistency - 531
   CLOSED: [2017-11-21 Tue 05:55]
   - All collections support the API provided by ~Traversable~.

   - Figure 24.1  Colleciton hierarchy
     #+BEGIN_SRC text
       Traversable
       |
       |-- Iterable
       |   |
       |   |-- Seq
       |   |   |
       |   |   |-- IndexedSeq
       |   |   |   |
       |   |   |   |-- Vector
       |   |   |   |-- ResizableArray
       |   |   |   |-- GenericArray
       |   |   |
       |   |   |-- LinearSeq
       |   |   |   |
       |   |   |   |-- MutableList
       |   |   |   |-- List
       |   |   |   |-- Stream
       |   |   |
       |   |   |-- Buffer
       |   |       |
       |   |       |-- ListBuffer
       |   |       |-- ArrayBuffer
       |   |
       |   |-- Set
       |   |   |
       |   |   |-- SortedSet
       |   |   |   |
       |   |   |   |-- TreeSet
       |   |   |
       |   |   |-- HashSet (mutable)
       |   |   |-- LinkedHashSet
       |   |   |-- HashSet (immutable)
       |   |   |-- BitSet
       |   |   |-- EmptySet, Set1, Set2, Set3, Set4
       |   |
       |   |-- Map
       |       |
       |       |-- SortedMap
       |       |   |
       |       |   |-- TreeMap
       |       |
       |       |-- HashMap (mutable)
       |       |-- LinkedHashMap (mutable)
       |       |-- HashMap (immutable)
       |       |-- EmptyMap, Map1, Map2, Map3, Map4
     #+END_SRC

   - Most of the classes above exist in _THREE_ variants:
     + root
     + mutable
     + immutable

     *The ONLY EXCEPTION* is the ~Buffer~ trait, which ONLY exists as a /mutable
     collection/.

** DONE 24.3 Trait ~Traversable~ - 533
   CLOSED: [2017-12-03 Sun 00:22]
   - Its ONLY abstract operation is ~foreach~:
     ~def foreach[U](f: Elem => U)~

   - ~Traversable~ also defines many concrete methods, which are all listed in
     _Table 24.1 on page 535_. These methods fall into the following categories:
     + Addtion ~++~
       * append two /traversables/ together
       * append all elements of an /iterator/ to a /traversable/.

     + Map operations ~map~, ~flatMap~, and ~collect~

     + Conversions ~toIndexedSeq~, ~toIterable~, ~toStream~, ~toArray~, ~toList~,
       ~toSeq~, ~toSet~, and ~toMap~.

         general traversables --> specific traversables

         If the receiver of these method is already the target type, nothing will
       be transformed -- just return the receiver value.

     + Copying operations ~copyToBuffer~ and ~copyToArray~

     + Size operations ~isEmpty~, ~nonEmpty~, ~size~, and ~hasDefiniteSize~

       /Collections/ that are traversable can be /finite/ or /infinite/.

       DO NOT use ~traversable.size == 0~ to check if a /traversable/ is empty or
       not! Two reasons:
       * Complexity:
         ~size~ is ~O(n)~
         ~isEmpty~, ~nonEmpty~, and ~hasDefiniteSize~ are ~O(1)~'s

       * Get a size of an /infinite traversable/ is a disaster.

       ~hashDefiniteSize~
       * returns true, the collection is certainly _finite_.
       * returns false, the collection might be _infinite_, in which case ~size~
         will emit an error or not return.

     + Element retrieval operations ~head~, ~last~, ~headOption~, ~lastOption~,
       and ~find~.
         A _pitfall_: NOT all /traversables/ have definite order. DO NOT apply
       these methods to NO order /traversables/.

     + Subcollection retrieval operations ~takeWhile~, ~tail~, ~init~, ~slice~,
       ~take~, ~drop~, ~filter~, ~dropWhile~, ~filterNot~, and ~withFilter~.

       They return some subcollection identified by
       * an index range
         or
       * a predicate

     + Subdivision operations ~splitAt~, ~span~, ~partition~, and ~groupBy~
       =TODO=

     + Element tests ~exists~, ~forall~ and ~count~
       Test collection elements with a given predicate.

     + Folds ~foldLeft~, ~foldRight~, ~/:~, ~:\~, ~reduceLeft~, ~reduceRight~
       They apply a binary operation to successive elements.
       =TODO=

     + Specific folds ~sum~, ~product~, ~min~, and ~max~
       They works to specific types (numeric or comparable).

     + String operations ~mkString~, ~addString~, and ~stringPrefix~
       They provide alternative ways of converting a collection to a string.

       #+BEGIN_SRC scala
         List(1, 2, 3).
           addString(new StringBuilder, "List(", ", ", ")").
           toString

         // "List(1, 2, 3)"

         List(1, 2, 3).stringPrefix
         // "List"
       #+END_SRC

     + View operations consisting of two overloaded variants of the ~view~ method
       A view is a collection that's evaluated lazily.
       =TODO= more about view in Section 24.14

   - Table 24.1  Operations in trait ~Traversable~

** DONE 24.4 Trait ~Iterable~ - 538
   CLOSED: [2018-03-22 Thu 02:22]
   The *core* /abstract method/ of ~Iterable~ is ~iterator~.

   - The abstract ~foreach~ method inherited from ~Traversable~ is implemented in
     ~Iterable~ in terms of ~iterator~.
     #+BEGIN_SRC scala
       def foreach[U](f: Elem => U): Unit = {
         val it = iterator
         while (it.hasNext) f(it.next())
       }
     #+END_SRC

   - Quite a *few* /subclasses/ of ~Iterable~ override this standard
     implementation of ~foreach~ in ~Iterable~, because they can provide a _more
     efficient_ implementation.

       Remember that ~foreach~ is the basis of the implementation of _all_
     operations in ~Traversable~, so _its performance matters_.

   - _TWO_ more methods exist in ~Iterable~ that return /iterators/:
     + ~grouped~
       For example,
       ~List(1, 2, 3, 4, 5) grouped 3~ generates an /interator/ includes
       ~List(1, 2, 3)~ and ~List(4, 5)~ in order.

     + ~sliding~
       For example,
       ~List(1, 2, 3, 4, 5) sliding 3~ generates an /interator/ includes
       ~List(1, 2, 3)~, ~List(2, 3, 4)~, and ~List(3, 4, 5)~ in order.

   - Trait ~Iterable~ also adds some other methods to ~Traversable~ that can be
     implemented efficiently ONLY if an ~iterator~ is available.
       They are summarized in Table 24.2, page 540

*** DONE Why have both ~Traversable~ and ~Iterable~? - 540  =RE-READ=
    CLOSED: [2018-03-22 Thu 01:49]
    =From Jian= ~Traversable~ will be removed from the re-designed Scala
    collection library since Scala 2.13

    One reason for having ~Traversable~ is that sometimes it is _easier or more
    efficient_ to provide an implementation of ~foreach~ than to provide an
    implementation of ~iterator~.

    For example: =TODO= =TODO= =TODO=
    + Make a binary tree traversable,
      With ~Traversable~, the cost of visiting all leaves takes O(N) time --
      N + N - 1 steps.
      #+BEGIN_SRC scala
        sealed abstract class Tree extends Traversable[Int] {
          def foreach[U](f: Int => U) = this match {
            case Node(elem) => f(elem)
            case Branch(l, r) => l foreach f; r foreach f
          }
        }

        case class Branch(left: Tree, right: Tree) extends Tree
        case class Node(elem: Int) extends Tree
      #+END_SRC

    + Make a binary tree iterable,
      With ~Iterable~, the cost of visiting all leaves takes O(N*logN) --
      logN for indirection.
      =TODO=
      #+BEGIN_SRC scala
        sealed abstract class Tree extends Iterable[Int] {
          def iterator: Iterator[Int] = this match {
            case Node(elem) => Iterator.single(elem)
            case Branch(l, r) => l.iterator ++ r.iterator
          }
        }

        case class Branch(left: Tree, right: Tree) extends Tree
        case class Node(elem: Int) extends Tree
      #+END_SRC

*** DONE Subcategories of ~Iterable~ - 542
    CLOSED: [2017-12-03 Sun 02:07]
    In the inheritance hierarchy below ~Iterable~ you find _THREE_ traits:
    ~Seq~, ~Set~, ~Map~

    =From Jian= From the online *errata* I know this section makes some mistakes!!!!!!!!!
                See below -- I correct it.

    - ~Seq~ and ~Map~ implement the ~PartialFunction~ /trait/, therefore they
      have the ~apply~ and ~isDefinedAt~ /methods/).

      + ~Seq~ extends ~PartialFunction~;
      + ~Map~ extends ~MapLike~, and ~MapLike~ extends ~PartialFunctions~.

    - ~Set~ also has an ~apply~ /method/, but it comes from the ~GetSetLike~
      /trait/ (~Set~ -> ~GenSet~ -> ~GenSetLike~).

      =From Errata=
      ~Set~ does *NOT* implement ~PartialFunction~ (this book makes mistake here).
      It also does *NOT* have the ~isDefineAt~ /method/.

    - The ~apply~ /methods/ are defined in _DIFFERENT_ way:

      + The ~apply~ of ~Seq~ news and returns a ~Seq~

      + The ~apply~ of ~Set~ check if the element is in this set.
        It calls the ~contains~ /method/.

      + The ~apply~ of ~Map~ is a selection.

** DONE 24.5 The sequence traits ~Seq~, ~IndexedSeq~, and ~LinearSeq~ - 542
   CLOSED: [2017-12-07 Thu 12:44]
   - A sequence (~Seq~) is
     + a kind of iterable that has a ~length~
     + its elements have fixed index positions, starting from 0.

   - Methods
     + *Indexing and length operations* ~apply~, ~isDefinedAt~, ~length~,
       ~indices~, and ~lengthCompare~
       * ~apply~ (for ~Seq~) means /indexing/ -- hence ~Seq[T]~ extends
         ~PartialFunction[Int, T]~.

       * ~length~ is an alias of ~size~ in more general collections.

       * ~lengthCompare~ time complexity is _O(min(seq1.length, seq2.length))_,
         rather than _O(seq1.length + seq2.length)_ when you try to get the exact
         values of two sequences to compare, which is a _BAD idea_.

     + *Index search operations* ~indexOf~, ~lastIndexOf~, ~indexOfSlice~,
       ~lastIndexOfSlice~, ~indexWhere~, ~lastIndexWhere~, ~segmentLength~, and
       ~prefixLength~
       They return a index.

     + *Addition operations* ~+:~, ~:+~, and ~padTo~

     + *Update operations* ~updated~ and ~patch~
       =TODO= Read API ~patch~

     + *Sorting operations* ~sorted~, ~sortWith~, and ~sortBy~

     + *Reversal operations* ~reverse~, ~reverseIterator~, and ~reverseMap~
       =IMPORTANT= Never use a pattern like ~seq.map(...).reverse~

     + *Comparison operations* ~startsWith~, ~endsWith~, ~contains~,
       ~corresponds~, and ~containsSlice~
       =TODO= Read API

     + *Multiset operations* ~intersect~, ~diff~, ~union~, and ~distinct~

     + mutable sequences have a side-effecting update method ~update~.
       =From Jian= Why NOT use name ~updateInPlace~, which is much clearer.

   - Table 24.3 · Operations in trait ~Seq~
     =IMPORTANT=

   - Two subtraits of ~Seq~ (NO additional operations, but different performance
     characteristics):
     + ~LinearSeq~: for example ~List~
       It is good at ~head~ and ~tail~

     + ~IndexedSeq~: for example ~Array~, ~ArrayBuffer~ (actually this is a
       ~Buffer~, not a ~IndexedSeq~)

       It is good at ~apply~, ~length~, and (if mutable) ~update~ operations.

     + ~Vector~ is a ~IndexedSeq~, but it has balanced performance -- CONSTANT
       time for both linear access and indexing.
         Because of this, vectors are a good foundation for mixed access
       patterns.

*** Buffers
    - ~Buffer~ is a MUTABLE sequence subtrait.

    - ~Buffer~'s allow
      + NOT only _updates_ of existing elements
      + BUT ALSO element _insertions_, element _removals_, and _efficient
        additions_ of new elements _at the end_ of the buffer.

    - Table 24.4 · Operations in trait ~Buffer~
      =From Jian= I modified some description of this Table to clarify something.

** DONE 24.6 Sets - 547
   CLOSED: [2018-03-30 Fri 02:03]
   - ~Set~ :: ~Iterable~ that contain *NO duplicate* elements.

   - /Methods/ fall into the following categories:
     + *Tests*
       ~contains~, /instance method/ ~apply~, and ~subsetOf~.
       For ~Set~, /instance method/ ~apply~ is the same as ~contains~.

       =From Jian= *CAUTION*
       ~Set~ also has /factory method/ ~apply~ (also called /static method/, or
       /object method/). DO NOT BE CONFUSED!!!

     + *Additions*
       * ~+~ and ~++~ for both /immutable sets/ and /mutable sets/. They all yield new
         /sets/.

       * ~+=~ and ~++=~ for /immutable sets/ -- in place modification the
         reference to ~var~'s.

       * ~+=~ and ~++=~ for /mutable sets/ -- in place modification the /set
         objects/ saved as ~val~'s.

     + *Removals*
       * ~-~ and ~--~ for both /mutable/ and /immutable/. They all yield new
         /sets/.

       * ~-=~ and ~--=~ for /immutable sets/ -- in place modification the
         reference to ~var~'s.

       * ~-=~ and ~--=~ for /mutable sets/ -- in place modification the /set
         objects/ saved as ~val~'s.

     + *Set operations*
       For /union/, /intersection/, and /difference/.

       These operations have two forms:
       * alphabetic: ~intersect~, ~union~, and ~diff~
       * symbolic: ~&~, ~|~, ~&~~

     + The ~++~ that ~Set~ inherits from ~Traversable~ can be seen as yet
       _another alias_ of ~union~ or ~|~, _EXCEPT_ that
       * ~++~ takes a ~Traversable~ argument
       * whereas ~union~ and ~|~ take /sets/.

   - Table 24.5 Operations in trait ~immutable.Set~

   - Table 24.6 Operations in trait ~mutable.Set~
     =From Jian= =IMPORTANT=
     Pay attention the operation of ~mutable.Set~

   - Functional additions and removals are *rarely used* by /mutable sets/ --
     copy are involved, which will not happen for these operations on /immutable
     sets/.

   - *Implementation* =IMPORTANT=
     + The current _default_ implementation of a /mutable set/ uses a /hash table/
       to store the set’s elements.

     + The _default_ implementation of an /immutable set/ uses a representation
       that adapts to the number of elements of the set.

       * An *EMPTY* set is represented by just a /singleton object/.

       * /Sets/ of sizes up to *FOUR* are represented by a /single object/ that
         stores all elements as fields.

       * Beyond that size, /immutable sets/ are implemented as /hash tries/.

    - Due to the implementation mentioned above, therefore, for small
      (size <= 4), /immutable sets/, compare to /mutable sets/, are
      + more compact
      + more effcient

** DONE 24.7 Maps - 552
   CLOSED: [2017-12-17 Sun 03:11]
   - ~Map~'s :: ~Iterable~'s of pairs of keys and values.

   - /Maps/ are also named /mappings/ or /associations/.

   - In Scala, /maps/ can be written in two forms:
     + ~Map("x" -> 24, "y" -> 25, "z" -> 26)~

     + ~Map(("x", 24), ("y", 25), ("z", 26))~

     The first one will be implicitly converted (by a function imported from
     ~Predef~) to the second one.

   - A TYPO in this page (I've already submitted this type to the official
     errata):
     ~Predef~ class _should be_ ~Predef~ object.

   - Methods (Table 24.7):
     + *Lookups* ~apply~, ~get~, ~getOrElse~, ~contains~, and ~isDefinedAt~
       * ~apply~ and ~isiDefineAt~ come from the ~PartialFunction~ /trait/.

       * One ~apply(key: K): V~ from ~PartialFunction~ and
         one ~apply[A, B](elems: (A, B)*): Map[A, B]~ from the ~Map~ /object/.

       * ~get~ returns a ~Option[V]~ type value, while
         the ~apply~ from ~PartialFunction~ returns a ~V~ type value (if the
         given key doesn't exist, throw an exception).

     + *Additions and updates* ~+~, ~++~, and ~updated~

     + *Removals* ~-~ and ~--~

     + *Subcollection producers* ~keys~, ~keySet~, ~keysIterator~,
       ~valuesIterator~, and ~values~,

     + *Transformations* ~filterKeys~ and ~mapValues~

   - Table 24.7 · Operations in trait ~Map~

   - Table 24.8 · Operations in trait ~mutable.Map~

   - Like all other /immutable/ and /mutable/ collections, /mutable maps/ support
     no side-effect (or called not destructive) operations like ~+~, ~-~, but
     they are rarely used -- if frequently use them, why not just use the
     /immutable maps/.

   - The ~getOrElseUpdate~ is useful for accessing maps that act as /caches/.
     #+BEGIN_SRC scala
       def f(x: String) = {
         println("taking my time.");
         Thread.sleep(100)
         x.reverse
       }

       val cache = collection.mutable.Map.empty[String, String]
       def cacheF(s: String) = cache.getOrElseUpdate(s, f(s))

       cacheF("abc")
       // take my time.
       // res16: String = cba

       cacheF("abc")
       // res17: String = cba
     #+END_SRC
     It is obvious that the second parameter of ~getOrElseUpdate~ is defined lazy.

     This is much simpler than the equivalent code with out ~getOrElseUpdate~:

     #+BEGIN_SRC scala
       def cacheF(arg: String) = cache get arg match {
         case Some(result) => result
         case None =>
           val result = f(arg)
           cache(arg) = result
           result
       }
     #+END_SRC

** DONE 24.8 Concrete immutable collection classes - 556
   CLOSED: [2018-03-27 Tue 07:27]
   Scala provides many /immutable collections/, and they differ in
   - the /trait/ thye implement (/maps/, /sets/, /sequences/)

   - whether they can be infinite

   - the speed of various operations

*** DONE Lists - 556
    CLOSED: [2018-03-27 Tue 03:29]
    See more discussion in Chapter 16 and 22

*** DONE Streams - 557
    CLOSED: [2018-03-27 Tue 06:38]
    - /streams/ are like *lazy* /list/.

    - /streams/ can be infinitely long.

    - Only those elements requested will be computed.
      Otherwise, /streams/ have the _same performance_ characteristics as /lists/.

    - Like the ~::~ of /lists/, /streams/ use ~#::~.
      #+BEGIN_SRC scala
        val intStream = 1 #:: 2 #:: 3 #:: Stream.empty
        // intStream: scala.collection.immutable.Stream[Int] = Stream(1, ?)
      #+END_SRC

    - The ~toString~ of /streams/ won't force any extra evaluation.

    - Use a /stream/ to represent Fibonacci sequence:
      #+BEGIN_SRC scala
        def fibFrom(a: Int, b: Int): Stream[Int] =
          a #:: fibFrom(b, a + b)

        val fibs = fibFrom(1, 1)

        val fibsFirst7 = fibs.take(7)
        // fibs: scala.collection.immutable.Stream[Int] = Stream(1, ?)

        fibs.toList
        // res23: List[Int] = List(1, 1, 2, 3, 5, 8, 13)
      #+END_SRC

*** DONE Vectors - 558 =Re-READ=
    CLOSED: [2018-03-27 Tue 07:17]
    - Access to any elements of a vector take only *effectively constant time*.

    - =From Jian=
      I think, in Scala, ~Vector~ is the immutable correspondance of ~Array~,
      which is mutable.

    - Example,
      #+BEGIN_SRC scala
        val vec = scala.collection.immutable.Vector.empty

        val vec2 = vec :+ 1 :+ 2
        // vec2: scala.collection.immutable.Vector[Int] = Vector(1, 2)

        val vec3 = 100 +: vec2
        // vec3: scala.collection.immutable.Vector[Int] = Vector(100, 1, 2)

        vec3(0)
        // res24: Int = 100
      #+END_SRC

    - /Vectors/ are represented as *broad, shallow trees*.

    - =TODO= Some details about implementation. =RE-READ=

    - Functional update:
      #+BEGIN_SRC scala
        val vec = Vector(1, 2, 3)
        // vec: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)

        vec updated (2, 4)
        // res25: scala.collection.immutable.Vector[Int] = Vector(1, 2, 4)

        vec
        // res26: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)
      #+END_SRC

    - =TODO= RE-READ

    - Because /vectors/ *strike a good balance* between _fast random selections_
      and _fast random functional updates_, they are currently the _default
      implementation_ ~scala.collection.immutable.IndexedSeq~.

*** DONE Immutable stacks - 559
    CLOSED: [2018-03-27 Tue 03:19]
    - ~scala.collection.immutable.Stack~

    - LIFO

    - Basic operations (constant time):
      #+BEGIN_SRC scala
        val stack = scala.collection.immutable.Stack.empty
        // stack: scala.collection.immutable.Stack[Nothing] = Stack()

        val hasOne = stack.push(1)
        // hasOne: scala.collection.immutable.Stack[Int] = Stack(1)

        stack
        // res28: scala.collection.immutable.Stack[Nothing] = Stack()

        hasOne.top
        // res29: Int = 1

        hasOne.pop
        // res30: scala.collection.immutable.Stack[Int] = Stack()
      #+END_SRC

      + ~pop~ dosen't return the poped element.
        =From Jian= Why NOT return a pair with the poped element???

      + ~top~ doesn't remove the top element.

    - /Immutable stacks/ are *used rarely* in Scala programs because their
      functionality is subsumed by /lists/:
      + /stack/ ~push~ is the same as /list/ ~::~

      + /stack/ ~pop~ is the same as /list/ ~tail~

*** DONE Immutable queues - 560
    CLOSED: [2018-03-27 Tue 03:28]
    - ~scala.collection.immutable.Queue~
      Its simplified implementation is discussed in Chapter 19

    - FIFO

    - ~enqueue~ append element(s) to /queues/:
      #+BEGIN_SRC scala
        val empty = scala.collection.immutable.Queue.empty

        val has1 = empty.enqueue(1)
        // has1: scala.collection.immutable.Queue[Int] = Queue(1)

        val has123 = has1.enqueue(List(2, 3))
        // has123: scala.collection.immutable.Queue[Int] = Queue(1, 2, 3)
      #+END_SRC

    - ~dequeue~ removes an element from the head of the /queue/:
      #+BEGIN_SRC scala
        val (element, has23) = has123.dequeue
        // element: Int = 1
        // has23: scala.collection.immutable.Queue[Int] = Queue(2, 3)
      #+END_SRC

*** DONE Ranges - 561
    CLOSED: [2018-03-27 Tue 06:41]
    Use ~to~ and ~until~, which can be combined with ~by~ if you want to specify
    the step.

*** DONE Hash tries - 561 =TOOD= =NOTE=
    CLOSED: [2018-03-27 Tue 07:27]
*** DONE Red-black trees - 562
    CLOSED: [2018-03-27 Tue 07:24]
    - Operations on /red-black trees/ reliably complete in _time logarithmic to
      the size of the tree_.

    - Scala provides implementations of /sets/ and /maps/ that use *a /red-black
      tree/ INTERNALLY*.
        You access them under the names ~TreeSet~ and ~TreeMap~:
      #+BEGIN_SRC scala
        val set = collection.immutable.TreeSet.empty[Int]

        set + 1 + 3 + 3
        // res34: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 3)
      #+END_SRC

    - /Red-black trees/ are also the _standard implementation of ~SortedSet~ in
      Scala_,
      because they provide an *efficient* /iterator/ that returns
      _ALL elements of the set in SORTED ORDER._

*** DONE Immutable bit sets - 562 =TODO= =???=
    CLOSED: [2018-03-27 Tue 06:58]
    - bit set :: represent a collection of _small integers_ as the bits of _a
                 large integer_.

    - *Internally*, /bit sets/ use an array of 64-bit ~Long~'s.
      The first ~Long~ in the array is for integers 0 through 63,
      the second is for 64 through 127, and so on.

    - Operations on bit sets are very fast.
      + _Testing for inclusion_ takes *constant time*.

      + _Adding an item_ to the set takes _time proportional to the number of
        ~Long~'s in the bit set’s array_, which is typically a small number.

    - Here are some simple examples of the use of a /bit set/:
      #+BEGIN_SRC scala
        val bits = scala.collection.immutable.BitSet.empty
        // bits: scala.collection.immutable.BitSet = BitSet()

        val moreBits = bits + 3 + 4 + 4
        // moreBits: scala.collection.immutable.BitSet = BitSet(3, 4)

        moreBits(3)
        // res35: Boolean = true

        moreBits(0)
        // res36: Boolean = false
      #+END_SRC

*** DONE List maps - 563
    CLOSED: [2018-03-27 Tue 06:45]
    - list map :: represent a /map/ as _a /linked list/ of key-value pairs_.

    - /List maps/ are rarely used -- their operations take linear time.

    - Use /list maps/ only when you know the first some elements are accessed
      more often than the other elements.

** DONE 24.9 Concrete mutable collection classes - 563
   CLOSED: [2018-03-28 Wed 21:52]
*** DONE Array buffers - 563
    CLOSED: [2018-03-27 Tue 13:55]
    /Array buffers/ are useful for efficiently building up a large collection,
    which is planed finally to be converted to an /array/,
    whenever the new items are always added to the end.

    - Have already seen /array buffer/ in Section 17.1.

    - An /array buffer/ holds an /array/ and a /size/.

    - Most operations on an /array buffer/ have the *same speed* as an /array/.

    - /Array buffers/ can have data efficiently added to the end.
      Add one item to the end takes with *amortized constant time*.

    - Examples:
      #+BEGIN_SRC scala
        val buf = collection.mutable.ArrayBuffer.empty[Int]
        // buf: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()

        buf += 1
        // res38: buf.type = ArrayBuffer(1)

        buf += 10
        // res39: buf.type = ArrayBuffer(1, 10)

        buf.toArray
        // res40: Array[Int] = Array(1, 10)
      #+END_SRC

    - ~ArrayBuffer~ is currently the *standard implementation* of
      ~scala.collection.immutable.IndexedSeq~

*** DONE List buffers - 564
    CLOSED: [2018-03-27 Tue 14:03]
    /List buffers/ are useful for efficiently building up a large collection,
    which is planed finally to be converted to an /list/, whenever the new items
    are always added to the end.

    - /List buffers/ are similar to /array buffers/
      except that it uses a linked list internally.

    - Have already seen /array buffer/ in Section 17.1.

    - Example:
      #+BEGIN_SRC scala
        val buf = collection.mutable.ListBuffer.empty[Int]
        // buf: scala.collection.mutable.ListBuffer[Int] = ListBuffer()

        buf += 1
        // res41: buf.type = ListBuffer(1)

        buf += 10
        // res42: buf.type = ListBuffer(1, 10)

        buf.toList
        // res43: List[Int] = List(1, 10)
      #+END_SRC

    - footnote: =TODO= =Re-read=
      ~buf.type~.

      More details in Section 29.6.

      =From Jian=
      This show up in the sections /Array buffers/, /List buffers/, /String
      builders/

    - =From Jian=
      ~ListBuffer~ is currently the *standard implementation* of
      ~scala.collection.immutable.LinearSeq~ in Scala.

      !!! immutable

*** DONE String builders - 564
    CLOSED: [2018-03-27 Tue 14:15]
    Just like /array buffers/ and /list buffers/ usage,
    /string builders/ is used to build strings, and it will always be converted
    to a /string/.

    - =From Jian= Why not /string buffer/???
      There are /string buffers/ in Java, but its design is not considered good,
      and people redesign and introduce the /string builder/.

    - =From Jian= *TRAP*
      There are confliction between Java's ~StringBuilder~ and Scala's
      ~StringBuilder~ if consider their _construction_.

      Be careful! Scala's ~StringBuilder~ has some /constructor/ that is
      different from Java's.

    - Example:
      #+BEGIN_SRC scala
        val buf = new StringBuilder
        // buf: StringBuilder =

        buf += 'a'
        // res44: buf.type = a

        buf ++= "bcdef"
        // res45: buf.type = abcdef

        buf.toString
        // res46: String = abcdef
      #+END_SRC

*** DONE Linked lists - 565
    CLOSED: [2018-03-27 Tue 14:19]
    - In most languages ~null~ would be picked as the empty /linked list/.
      This is not the case of Scala.

      /Empty linked lists/ still need to support all the operations of /non-empty
      linked list/.

    - /Empty linked lists/ are encoded instead in a special way:
      Their ~next~ field points back to the node itself.

    - =From Jian=
      ~LinkedList~ is also the base of ~MutableList~

*** DONE Double linked lists - 565
    CLOSED: [2018-03-27 Tue 15:09]
    - Besides ~next~, it has another /mutable field/ ~prev~

    - The main benefit of that additional link is that it _makes element removal
      very fast_.

*** DONE Mutable lists - 565
    CLOSED: [2018-03-27 Tue 15:21]
    - A ~MutableList~ consists of
      + a /single linked list/ together with
      + a /pointer/ that refers to the /terminal empty node/ of that list.

    - This makes list *append* a _constant time_ operation
      because it avoids having to traverse the list in search for its terminal
      node.

    - ~MutableList~ is currently the *standard implementation* of
      ~scala.collection.mutable.LinearSeq~ in Scala.

*** DONE Queues - 566
    CLOSED: [2018-03-27 Tue 15:40]
    Like the ~immutable.Queue~,
    but
    + instead of ~enqueue~, you use the ~+=~ and ~++=~ operators to append.

    + ~dequeue~ removes and returns the head element, NOT like the ~dequeue~ of
      ~immutable.Queue~, which returns a pair.

*** DONE Array sequences - 566 =RE-READ=
    CLOSED: [2018-03-27 Tue 15:44]
    - /Array sequences (~ArraySeq~)/ are *mutable* sequences of *fixed size* that
      store their elements internally in an ~Array[AnyRef]~.

    - You would typically use an ~ArraySeq~ if
      + you want an array for its performance characteristics,
      + but you also want to create generic instances of the sequence where you
        * _do not know the type_ of the elements
          and
        * _do not have_ a ~ClassTag~ to provide it at run-time.

      =TODO=
      You will find out about these issues with arrays shortly, in Section 24.10.

*** DONE Stacks - 566
    CLOSED: [2018-03-27 Tue 15:48]
    #+BEGIN_SRC scala
      val stack = new scala.collection.mutable.Stack[Int]
      // stack: scala.collection.mutable.Stack[Int] = Stack()

      stack.push(1)
      // res52: stack.type = Stack(1)

      stack
      // res53: scala.collection.mutable.Stack[Int] = Stack(1)

      stack.push(2)
      // res54: stack.type = Stack(2, 1)

      stack
      // res55: scala.collection.mutable.Stack[Int] = Stack(2, 1)

      stack.top
      // res56: Int = 2

      stack
      // res57: scala.collection.mutable.Stack[Int] = Stack(2, 1)

      stack.pop
      // res58: Int = 2

      stack
      // res59: scala.collection.mutable.Stack[Int] = Stack(1)
    #+END_SRC

    - The ~pop~ methods of /mutable stack/ and /immutable stack/ return different
      type of values.

*** DONE Array stacks - 567
    CLOSED: [2018-03-27 Tue 15:45]
    - ~ArrayStack~ :: an *alternative implementation* of a /mutable stack/,
                      which is backed by an ~Array~ that gets resized as needed.

    - It provides fast indexing

      it is generally _slightly more efficient_ for most operations than a normal
      /mutable stack/.

*** DONE Hash tables - 567
    CLOSED: [2018-03-28 Wed 21:41]
    - A /hash table/ stores its elements in an *UNDERLYING* /array/, placing each
      item at a position in the /array/ _determined by the hash code of that
      item_.

    - Add an element to a /hash table/ takes only _constant time_, so long as
      there isn't already another element in the array that has the same hash
      code. =NOT clear about if the same hash code element exists=

    - Hash tables are thus very *fast* _so long as the objects placed in them
      have a good distribution of hash codes_.

    - As a result, the DEFAULT /mutable map/ and /mutable set/ types in Scala are
      _based on_ /hash tables/.

    - =From Jian=
      Remember! Use mutable hash based collection is tricky in some situation!

    - /Iteration/ over a /hash table/ is *NOT* guaranteed to occur in any
      particular order.

    - To iterate a hash map or hash set in a guaranteed order, use /linked (hash)
      map/ or /linked (hash) set/.
        /Iteration/ over such a /collection/ is always in *the same order that
      the elements were initially added*.

    - A /linked hash map or set/ is just _like_ a /regular hash map or set/
      _except_ that it *also* _includes a /linked list/ of the elements in the
      order they were added_.

      =From Jian= Does this *also* mean they include an underlying /array/ and
      /linked list/???

*** DONE Weak hash maps - 568
    CLOSED: [2018-03-28 Wed 21:46]
    - =TODO= Learn more details!!!

    - /Weak hash maps/ in Scala are _implemented_ as a wrapper of an underlying
      Java implementation, ~java.util.WeakHashMap~.

    - A /weak hash map/ is a special kind of /hash map/ in which the _garbage
      collector does *NOT* follow links from the map to the keys stored in it_.

        This means that
      a key and its associated value will _disappear_ from the map _if there is
      no other reference to that key_.

    - *Weak hash maps are useful for tasks such as caching*

*** DONE Concurrent Maps - 569
    CLOSED: [2018-03-28 Wed 21:51]
    - A /concurrent map/ can be accessed by _several threads at once_.

    - In addition to the usual ~Map~ operations,
      it provides the following *ATOMIC operations*:

      Table 24.9  Operations in trait ~ConcurrentMap~
      | What it is                | What it does                                                                            |
      |---------------------------+-----------------------------------------------------------------------------------------|
      | ~m putIfAbsent(k, v)~     | Adds key/value binding ~k -> v~ unless k is already defined in ~m~                      |
      | ~m remove (k, v)~         | Removes entry for ~k~ if it is currently mapped to ~v~                                  |
      | ~m replace (k, old, new)~ | Replaces value associated with key ~k~ to ~new~, if it was previously bound to ~old~    |
      | ~m replace (k, v)~        | Replaces value associated with key ~k~ to ~v~, if it was previously bound to some value |

*** DONE Mutable bit sets - 569
    CLOSED: [2018-03-28 Wed 21:52]
    It likes the immutable version, and it's slightly more efficient at
    updating.

** DONE 24.10 Arrays - 570
   CLOSED: [2018-03-28 Wed 13:52]
   - /Arrays/ are a special kind of collection in Scala!
     + On one hand,
       you can build one-to-one correspondance to /Java Arrays/. For example,
       ~Array[Int]~ is represented as a Java ~int[]~; ~Array[String]~ is
       represented as a Java ~String[]~.

     + On the other hand, Scala /Arrays/
       * are /generic/

       * compatible with Scala sequences -- you can pass an ~Array[T]~ where a
         ~Seq[T]~ is required, though Scala ~Array~'s are not sequences, which
         is not a design choice to make it compatible with /Java arrays/.

       * support *ALL* sequence operations.
         *Two* /implicit conversions/ from and to ~ArrayOps~ and ~WrappedArray~.

   - Conversions from ~WrappedArray~ to ~Array~ use the ~toArray~ method defined
     in ~Traversable~.

     Wrapping then unwrapping with ~toArray~ gives you back the same array you
     start with:
     #+BEGIN_SRC scala
       val a1 = Array(1, 2, 3)

       val seq: Seq[Int] = a1
       // seq: Seq[Int] = WrappedArray(1, 2, 3)

       val a4: Array[Int] = seq.toArray
       // a4: Array[Int] = Array(1, 2, 3)

       a1 eq a4
       // res2: Boolean = true
     #+END_SRC

   - Typically, this ~ArrayOps~ object is short-lived; it will usually be inaccessible
     after the call to the sequence method and its storage can be recycled.

     Modern VMs often avoid creating this object entirely.

   - The difference between these two implicit conversions:
     #+BEGIN_SRC scala
       val seq: Seq[Int] = a1
       // seq: Seq[Int] = WrappedArray(1, 2, 3)

       seq.reverse
       // res2: Seq[Int] = WrappedArray(3, 2, 1)

       val ops: collection.mutable.ArrayOps[Int] = a1
       // ops: scala.collection.mutable.ArrayOps[Int] = [I(1, 2, 3)

       ops.reverse
       // res3: Array[Int] = Array(3, 2, 1)
     #+END_SRC

     As you can see, call many methods on a ~WrappedArray~, it will return a
     ~WrappedArray~. ~WrappedArray~ is ~Seq~, while ~ArrayOps~ returns ~Array~.
       This example also show you that ~ArrayOps~ is short-lived.

   - The example is quite artificial. It is designed to show you the difference
     between ~WrappedArray~ and ~ArrayOps~. Normally, you'd never specify the
     type of a value ~ArrayOps~, though you actually use it. For example,
     #+BEGIN_SRC scala
       a1.reverse
       // res4: Array[Int] = Array(3, 2, 1)
     #+END_SRC

   - /Implicits/ in /subclasses/ and /subobjects/ take precedence over
     /implicits/ in /base classes/.
       The implicit converesion of ~ArrayOps~ is inside ~Predef~, which is the
     /subobject/ of ~LowPriorityImplicits~, where you can find the implicit
     conversion of ~WrappedArray~.

   - At run-time, when an element of an array of type ~Array[T]~ is accessed or
     updated there is _a sequence of type tests_ that determine the actual array
     type, followed by the correct array operation on the Java array.
       These type tests slow down array operations somewhat.

   - You can expect accesses to generic arrays to be three to four times
     slower than accesses to primitive or object arrays.
       *This means that if you need maximal performance, you should prefer
     concrete over generic arrays.*

   - It's hard to create generic ~Array~, you need context bound with ~ClassTag~
     #+BEGIN_SRC scala
       import scala.reflect.ClassTag

       def evenElems[T: ClassTag](xs: Vector[T]): Array[T] = {
         val arr = new Array[T]((xs.length + 1) / 2)
         for (i <0
              until xs.length by 2)
           arr(i / 2) = xs(i)
         arr
       }
     #+END_SRC

     + Without the ~ClassTag~ context bound, you will see the error message:
       #+BEGIN_SRC text
         error: cannot find class tag for element type T
           val arr = new Array[T]((arr.length + 1) / 2)
       #+END_SRC

     + What's required here is that you help the compiler by providing a _runtime
       hint_ of what the actual type parameter of ~evenElems~ is.

         This _runtime hint_ takes the form of a /class tag/ of type
       ~scala.reflect.ClassTag~. A /class tag/ describes the /erased type/ of a
       given type, which is all the information needed to construct an array of
       that type.

   - In many cases the compiler can generate a /class tag/ on its own.
     This is case for concrete type or generic types like ~List[T]~.
     =TODO= this paragraph

     Then, you can do
     #+BEGIN_SRC scala
       evenElems(Vector(1, 2, 3, 4, 5))
       // res6: Array[Int] = Array(1, 3, 5)

       evenElems(Vector("this", "is", "a", "test", "run"))
       // res7: Array[java.lang.String] = Array(this, a, run)
     #+END_SRC

   - If the argument is itself another type parameter without its /class tag/,
     the code won't compile, and you need to provide /class tag/.
     #+BEGIN_SRC scala
       // scala>
       def wrap[U: ClassTag](xs: Vector[U]) = evenElems(xs)

       // wrap: [U](xs: Vector[U])(implicit evidence$1:
       //      scala.reflect.ClassTag[U])Array[U]
     #+END_SRC

** DONE 24.11 Strings - 575
   CLOSED: [2018-03-27 Tue 16:08]
  Like /arrays/,
  - Though /strings/ are not directly sequences, they support all /sequence
    operations/. Actually, two /implicit conversions/ are applied:

    + /low-priority conversion/ maps a ~String~ to a ~WrappedString~, which is a
      /subclass/ of ~immutable.IndexedSeq~.

      This conversion was applied in the situation like
      #+BEGIN_SRC scala
        val str = "hello"
        val s: Seq[Char] = str
        // s: Seq[Char] = WrappedString(h, e, l, l, o)
      #+END_SRC

    + /high-priority conversion/ maps a ~String~ to a ~StringOps~ object, which
      adds *ALL methods* on /immutable sequences/ to strings.

      This conversion was implicitly inserted in the method calls of ~reverse~,
      ~map~, ~drop~, and ~slice~.

  - They can be converted to them

** DONE 24.12 Performance characteristics - 575 =Recite=
   CLOSED: [2018-04-04 Wed 01:04]
** DONE 24.13 Equality - 578
   CLOSED: [2018-03-27 Tue 16:01]
   The ~collection~ libraries have a uniform approach to equality and hashing.

   - The Scala collections from ~colleciton~ can be divided into *THREE*
     categories: /sets/, /maps/, /sequences/.

     + The collections of different categories cannot be equal.

     + SAME category of collections can be equal,
       * *no matter* their _sub-categories_,
       * *no matter* if their are different in _mutability_.

       For example, both ~List(1, 2, 3) \eq{}\eq{} Vector(1, 2, 3)~, and
       ~HashSet(1, 2) == TreeSet(2, 1)~ are TRUE.

   - This means that a /mutable collection/ might be *equal to DIFFERENT
     collections at DIFFERENT times*, depending what elements are added or
     removed.

     =IMPORTANT=
     This is a *potential trap* when using a /mutable collection/ as a _key_ in
     a /hash map/.

** DONE 24.14 Views - 579 =Re-READ=
   CLOSED: [2018-03-28 Wed 14:59]
   - transform methods :: construct new collections from a collection / collections

   - Two types of /transform methods/:
     + strict
     + lazy

   - Scala /collections/ are by default *strict* in ALL their transformers, *EXCEPT*
     for ~Stream~, which implements ALL its /transformer methods/ lazily.

   - There is a systematic way to turn every /collection/ into a /lazy/ one and
     vice versa, _which is based on collection /views/._

   - If ~xs~ is some /collection/, then ~xs.view~ is the *same* /collection/, but
     with all transformers implemented *lazily*.

   - To get back from a /view/ to a /strict/ /collection/, you can use the
     ~force~ /method/.

   - =TODO=

   - =TODO=

   - Either you apply views in purely functional code where collection
     transformations do not have side effects. Or you apply them over mutable
     collections where all modifications are done explicitly. What’s best
     avoided is a mixture of views and operations that create new collections
     while also having side effects.

** DONE 24.15 Iterators - 584
   CLOSED: [2018-03-28 Wed 21:08]
   - An /iterator/ is *NOT* a /collection/, but rather a way to access the
     elements of a /collection/ one by one.

   - The two basic operations of ~Iterator~:
     + ~hasNext~
     + ~next()~

   - The most straightforward way to "step through" all the elements returned by
     an /iterator/ is to use a ~while~ loop:
     #+BEGIN_SRC scala
       while (it.hasNext)
         println(it.next())
     #+END_SRC

   - Inheritance relation:
     ~Iterator~ --> ~TraversableOnce~ --> ~GenericTraversableOnce~ --> ~Any~

   - ~Iterator~ provides analogues of most of the /methods/ that you find in
     ~Traversable~, ~Iterable~, and ~Seq~ /traits/,
     =From Jian= though from the "Inheritance relation" I list above, ~Iterator~
     doesn't implement those /traits/.

   - There is a difference between the ~foreach~ of ~Iterator~ and the ~foreach~
     of /collections/:
       When called on an /iterator/, ~foreach~ will leave the /iterator/ at its
     *end* when it is done -- call ~next~ again and you'll get a
     ~NoSuchElementException~.

   - Call ~map~ on an /iterator/ will get a *new* /iterator/. When you consume
     the *new* /iterator/, the being mapped /iterator/ will also be consumed.

     =From Jian= This is reasonable, but a little bit tricky!
     =From Jian= I don't think this design is good. Can we introduce concepts
                 like "ownership"???

     #+BEGIN_SRC scala
       val it = Iterator("a", "number", "of", "words")
       // it: Iterator[java.lang.String] = non-empty iterator

       it.map(_.length)
       // res1: Iterator[Int] = non-empty iterator

       it.next()
       // a

       res1.next()
       // number

       res1 foreach println
       // 2
       // 5

       it.next()
       // java.util.NoSuchElementException: next on empty iterator
     #+END_SRC

   - Call ~dropWhile~ on an /iterator/:
     #+BEGIN_SRC scala
       val it = Iterator("a", "number", "of", "words")
       // it: Iterator[String] = non-empty iterator

       it dropWhile (_.length < 2)
       // res4: Iterator[String] = non-empty iterator

       it.next()
       // res5: String = number
     #+END_SRC

     + Both ~it~ and ~res4~ reference to ~Iterator("a", "number", "of", "words")~

     + Call ~next()~ the first time you get ~"number"~.
       This does *NOT* mean the /iterator/ starts with ~"number"~, it only means
       a pointer points ~"number"~, rather than ~"a"~.

   - There is *only one* standard operation, ~duplicate~, which allows you to
     _re-use the SAME /iterator/:_ ~val (it1, it2) = it.duplicate~

     ~it1~ and ~it2~ work *independently*.

     =From Jian=
     However, though ~it1~ and ~it2~ are *independent* to each other, ~it1~ and
     ~it~ have interaction and ~it2~ and ~it~ have interaction.

     If you interleve the use (call ~next()~) of ~it~, ~it1~, and ~it2~, you may
     see something unexpected!!!
     =TODO= check if this also happens to Java?!

     *This is subtle!!!*
     Avoid using ~it~ if you has already ~duplicate~ it.
     I think the "ownership" concept should be introduced here to disable ~it~,
     and then ~it1~ and ~it2~ can be completely independent.

   - In summary,
     /iterators/ behave like /collections/ _if you NEVER access an /iterator/
     again after invoking a method on it_.

     The Scala /collection/ libraries make this explicit with an abstraction
     called ~TraversableOnce~, which is a common /supertrait/ of ~Traversable~
     and ~Iterator~.
       As the name implies, ~TraversableOnce~ objects can be traversed using
     ~foreach~, but _the state of that object after the traversal is *NOT*
     specified_.
     + If the ~TraversableOnce~ object is in fact an ~Iterator~, it will be at
       its end after the traversal,

     + If it is a ~Traversable~, it will still exist as before.

     A common use case of ~TraversableOnce~ is as an argument type for methods
     that can take either an /iterator/ or /traversable/ as argument. An example
     is the appending /method/ ~++~ in /trait/ ~Traversable~. It takes a
     ~TraversableOnce~ parameter, so you can append elements coming from either
     an /iterator/ or a /traversable collection/.
     =From Jian= Is there non-traversable collection???

   - =IMPORTANT=
     Table 24.12 · Operations in trait Iterator

*** DONE Buffered iterators - 591
    CLOSED: [2018-03-28 Wed 15:19]
    - You *cannot* peak the head element of an ~Iterator~ without advancing it.

    - An example that cannot be solved with ~Iterator~:
      "Skip leading empty strings from an iterator that returns a sequence of
      strings."

      + Wrong solution:
        #+BEGIN_SRC scala
          // This won't work
          def skipEmptyWordsNOT(it: Iterator[String]): Unit = {
            while (it.next().isEmpty) {}
          }
        #+END_SRC
        This even skip the first non-empty string!

    - You *can* peak the head element of an ~BufferedIterator~ without advancing
      it -- a ~head~ method is provided by ~BufferedIterator~.

      + Right solution:
        #+BEGIN_SRC scala
          def skipEmptyWords(it: BufferedIterator[String]): Unit =
            while (it.head.isEmpty) { it.next() }
        #+END_SRC

    - ~BufferedIterator~ is a subtrait of ~Iterator~.

    - Use the ~buffered~ /method/ of ~Iterator~ to get a ~BufferedIterator~.

** DONE 24.16 Creating collections from scratch - 592
   CLOSED: [2018-03-28 Wed 14:01]
   You can take any collection name and follow it by a list of elements in
   parentheses (for the standard library collections, the ~apply~ methods are
   always defined). The result will be a new collection with the given elements.

   - It does not matter whether the collection class represents a concrete
     implementation, like ~List~, ~Stream~, or ~Vector~, or whether it is an
     /trait/ such as ~Seq~, ~Set~, or ~Traversable~.
       In the latter case, calling apply will produce some _default
     implementation_ of the /trait/. For example,
     #+BEGIN_SRC scala
       List(1, 2, 3)
       // res17: List[Int] = List(1, 2, 3)

       Traversable(1, 2, 3)
       // res18: Traversable[Int] = List(1, 2, 3)

       mutable.Traversable(1, 2, 3)
       // res19: scala.collection.mutable.Traversable[Int] = ArrayBuffer(1, 2, 3)
     #+END_SRC

   - The ~Seq~ trait also provides some other /factory methods/:
     + ~concat~
     + ~fill~ and ~tabulate~
     + ~range~
     + ~iterate~
** DONE 24.17 Conversions between Java and Scala collections - 594 =Re-READ=
   CLOSED: [2018-03-22 Thu 02:59]
   ~import collection.JavaConverters._~

   =From Jian=
   The book originally use the *Deprecated*
   ~collection.JavaConversions._~

   - Bidirectional Conversion:
     #+BEGIN_SRC scala
       Iterator       <=> java.util.Iterator
       Iterator       <=> java.util.Enumeration
       Iterable       <=> java.lang.Iterable
       Iterable       <=> java.util.Collection
       mutable.Buffer <=> java.util.List
       mutable.Set    <=> java.util.Set
       mutable.Map    <=> java.util.Map
     #+END_SRC

   - No corresponding conversion: =TODO= =Re-Read= =More Details= =!!!=
     #+BEGIN_SRC scala
       Seq         => java.util.List
       mutable.Seq => java.util.List
       Set         => java.util.Set
       Map         => java.util.Map
     #+END_SRC

     + =NOT Clear= =Details= =TODO=
       Because Java does not distinguish between _mutable_ and _immutable_
       collections in their type, a conversion from, say,
       ~collection.immutable.List~ will yield a ~java.util.List~, on which all
       attempted _mutation operations_ will throw an
       ~UnsupportedOperationException~.

     + =From Jian= =More Details?=
       The ~mutable.Seq~ is converted to ~java.util.List~, and it also doesn't
       support ~add~ elements.

       Compare to the ~mutable.Buffer~, which has bidirectional conversion from
       and to ~java.util.List~, and it supports ~add~.

** DONE 24.18 Conclusion - 596
   CLOSED: [2018-04-04 Wed 01:05]
   - This chapter shows the use of Scala's collection in great detail.

   - This chapter has shown collections from the point of view of a programmer
     using the collection library.

* DONE 25 The Architecture of Scala Collections - 597
  CLOSED: [2018-04-02 Mon 02:43]
  This chapter describes the architecture of the Scala collections framework in
  detail.
  - Learn more details about the internal workings of the framework.

  - Learn *how* this architecture helps you _define your own collections_ in a
    few lines of code, while *reusing* the overwhelming part of collection
    functionality from the framework.

** DONE 25.1 Builders - 597
   CLOSED: [2018-03-30 Fri 05:04]
   - _Almost all_ /collection/ _operations_ are implemented in terms of
     *traversals* and *builders*.
     + *Traversals* are handled _by ~Traversable~'s ~foreach~ /method/;_

     + *Building* new collections is handled _by /instances/ of /class/
       ~Builder~._

       =From Jian= I review the source code and found that ~Builder~'s are only
       used for ~scala.collection.mutable~ (and ~scala.collection.cocuncurrent~).

       #+BEGIN_SRC scala
         package scala
         package collection
         package mutable

         import generic._


         class Builder[-Elem, +To] {
           def +=(elem: Elem): this.type

           def result(): To

           def clear()

           def mapResult[NewTo](f: To => NewTo): Builder[Elem, NewTo] =
             ...
         }
       #+END_SRC

     + Add _one_ element ~x~ to a /builder/ ~b~ with ~b += x~.

     + Add _more than one_ element at once: For instance, ~b += (x, y)~ and ~b
       ++= xs~ work as for /buffers/ (In fact, /buffers/ are an _enriched version_
       of /builders/).

     + The ~result()~ /method/ returns a collection from a /builder/.

       The state of the /builder/ is *undefined* _after taking its result_,
       but it can be _reset into a new empty state_ using ~clear()~.

     + /Builders/ are generic in both the element type, ~Elem~, and in the type,
       ~To~, of collections they return.

   - Use ~mapResult~ to set the ~result~ output of a /builder/:
     #+BEGIN_SRC scala
       val buf = new ArrayBuffer[Int]
       // buf: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()

       val bldr = buf mapResult (_.toArray)
       // bldr: scala.collection.mutable.Builder[Int,Array[Int]] = ArrayBuffer()

       bldr.result
       // res0: Array[Int] = Array()

       //// From Jian
       // val bldr = buf mapResult (_.toList)
       // bldr.result
       //// res0: List[Int] = List()
     #+END_SRC

** DONE 25.2 Factoring out common operations - 599
   CLOSED: [2018-03-30 Fri 21:28]
   - The main design objectives of the collection library redesign (=From Jian=
     Scala 2.8 ???) were to have, at the same time, natural types and maximal
     sharing of implementation code.

   - Scala's /collections/ follow the *"same-result-type"* principle:
     Wherever possible, a /transformation method/ on a /collection/ will yield a
     /collection/ of the *same type*. For instance, you filter a ~List~ instance
     and then should always get a new ~List~ instance.

   - *The fast track*
     =TODO=

   - The _Scala /collection/ library_ *avoids*
     + code duplication and
     + achieves the "same-result-type" principle

     by using /generic builders/ (=TODO= =???=) and /traversals/ over
     /collections/ in so-called /implementation traits/, and these /traits/ are
     _named with a ~Like~ suffix._
       For instance, ~IndexedSeqLike~ is the /implementation trait/ for
     ~IndexedSeq~, and similarly, ~TraversableLike~ is the /implementation
     trait/ for ~Traversable~. Collection classes such as ~Traversable~ or
     ~IndexedSeq~ inherit all their *concrete method implementations* _from these
     /traits/._

   - /Implementation traits/ have *two type parameters* instead of _one_ for
     normal /collections/.
     + One is the collection's /element type/, which can be considered as a
       common sense of the /generic collections/ design.

     + the other one is over the collection's /representation type/ -- the /type/
       of the /underlying collection/)

     For instance, here is the header of trait ~TraversableLike~:
     #+BEGIN_SRC scala
       package scala
       package collection

       trait TraversableLike[+Elem, +Repr] {
         def newBuilder: Builder[Elem, Repr]  // deferred
         def foreach[U](f: Elem => U):        // deferred

         // ...

         def filter(p: Elem => Boolean): Repr = {
           val b = newBuilder

           this foreach {
             elem => if (p(elem)) b+= elem
           }

           b.result
         }
       }
     #+END_SRC
     + No constraints on ~Repr~, this is *IMPORTANT*!
       This means ~Repr~ might be instantiated to a type that is itself NOT a
       /subtype/ of ~Traversable~.

         That way, classes outside the collections hierarchy, such as ~String~
       and ~Array~, can still make use of all operations defined in a collection
       /implementation trait/.

       =From Jian=
       More concrete example: ~StringOps~ extends ~StringLike[String]~, and the
       /type parameter/ ~String~ is NOT a /collection/!

   - Taking ~filter~ as an exmaple, this operation is _defined once for all
     collection classes_ in the trait ~TraversableLike~, and it depends on the
     ~newBuilder~ and ~foreach~ /methods/, which are concrete only to a specific
     /concrete collection/.

   - The ~map~ operation on collections is a bit more complicated.
     + The /element type/ of its result can be different from the input.

     + The change of /element type/ can affect the /collection type/ -- change
       the /element type/ can change the /collection type/.
       #+BEGIN_SRC scala
         import collection.immutable.BitSet

         val bits = BitSet(1, 2, 3)

         bits map (_ * 2)
         // res0: scala.collection.immutable.BitSet = BitSet(2, 4, 6)

         bits map (_.toFloat)
         // res1: scala.collection.immutable.Set = Set(1.0, 2.0, 3.0)

         Map("a" -> 1, "b" -> 2) map { case (x, y) => y }
         // res2: scala.collection.immutable.Iterable[Int] = List(1, 2)
       #+END_SRC
       * Q: Can we make a new design to make some limitation to prevent the
            change happend? For example, make the ~map~ of ~BitSet~ can only be
            ~Int => Int~?

         A: This would violate the /Liskov Substitution Principle/. For instance,
            for the last example above, ~Map~ *is* an ~Iterable~, and every
            operation that's legal on an ~Iterable~ must also be legal on a ~Map~.

   - Scala solves this problem *insteand with overloading*:
     + *Not* _the simple form of /overloading/ inherited by Java_ (that would not
       be flexible enough),

     + but _the more systematic form of /overloading/_ that's provided by
       /implicit parameters/.

     #+BEGIN_SRC scala
       // Inside `TraversableLike`
       def map[B, That](f: Elem => B)
              (implicit bf: CanBuildFrom[Repr, B, That]): That = {
         val b = bf(this)
         for (x <- this) b += f(x)
         b.result
       }
     #+END_SRC

   - ~map~ and ~filter~ looks similar.
     The principal difference is that
     + ~filter~ uses the ~newBuilder~ /abstract method/.

     + ~map~ uses a /builder factory/ that's passed as an additional implicit
       parameter of type ~CanBuildFrom~.

   - The definition of the /trait/ ~CanBuildFrom~
     #+BEGIN_SRC scala
       package scala.collection.generic

       trait CanBuildFrom[-From, -Elem, +To] {
         // Creates a new builder
         def apply(from: From): Builder[Elem, To]
       }
     #+END_SRC
     For example,
     The ~BitSet~ /companion object/ contains a /builder factory/ of type
     ~CanBuildFrom[BitSet, Int, BitSet]~.
       This means that when operating on a ~BitSet~ you can construct another
     ~BitSet~, _provided_ the type of the collection to build is ~Int~.

       If this is Not the case, you can always fall back to a different
     /implicit builder factory/, this time implemented in ~mutable.Set~'s
     /companion object/ of type ~CanBuildFrom[Set[_], A, Set[A]]~.

     *You can then rely on Scala's /rules for implicit resolution/ to pick the
     one that's appropriate and maximally specific.* -- subtypes have high
     priority.

   - So /implicit resolution/ provides the correct /static types/ for tricky
     collection operations, such as ~map~. But what about the /dynamic types/?

     See an example,
     #+BEGIN_SRC scala
       val xs: Iterable[Int] = List(1, 2, 3)
       // xs: Iterable[Int] = List(1, 2, 3)

       val ys: Iterable[Int] = xs map (x => x * x)
       // ys: Iterable[Int] = List(1, 4, 9)
     #+END_SRC

     + The /static type/ of ys above is ~Iterable~, as expected.
       But its /dynamic type/ is (and _should be_) still ~List~!

     + This behavior is achieved by one more indirection.

       The ~apply~ /method/ in ~CanBuildFrom~ is passed the source collection
       as argument. _Most_ /builder factories/ for /generic traversables/ (in
       fact all *except* /builder factories/ for /leaf classes/) *forward* the
       call to a /method/ ~genericBuilder~ of a /collection/. The ~genericBuilder~
       /method/ in turn _calls the /builder/ that belongs to the /collection/ in
       which it is defined_.

     + summary: =TODO= =Try to understand=
       So Scala uses /static implicit resolution/ to resolve constraints on the
       types of ~map~, and /virtual dispatch/ to pick the *best* /dynamic type/
       that corresponds to these constraints.


** DONE 25.3 Integrating new collections - 604
   CLOSED: [2018-04-02 Mon 02:43]
   In this section we'll show you _two examples_ that
   1. do integrate a new collection class
   2. so that it can profit from all predefined operations at the right types.

*** DONE Integrating sequences - 604
    CLOSED: [2018-04-01 Sun 07:10]
    Object: Create a new sequence type for RNA strands.
    #+BEGIN_SRC scala
      // building blocks and static methods

      abstract class Base
      case object A extends Base
      case object T extends Base
      case object G extends Base
      case object U extends Base

      object Base {
        // Both `Array` and `Map` implement the `Function1` trait
        val fromInt: Int => Base = Array(A, T, G, U)
        val toInt: Base => Int = Map(A -> 0, T -> 1, G -> 2, U -> 3)
      }
    #+END_SRC

    - *Representation* design:
      + Conceptually, a strand of RNA is simply a ~Seq[Base]~.

        However, RNA strands can get quite long,
        so it makes sense to invest some work in a _compact representation_.

      + There are _FOUR building blocks_, and we can use two bits as their
        representation. Therefore, a ~Int~ (32-bit integer) can be used to store
        *SIXTEEN* bases.

      + The idea, then, is to construct a _specialized_ /subclass/ of
        ~Seq[Base]~, which uses this *PACKED representation*.

    - Implementation:
      #+BEGIN_SRC scala
        import collection.IndexedSeqLike
        import collection.mutable.{Builder, ArrayBuffer}
        import collection.generic.CanBuildFrom


        final class RNA1 private (val groups: Array[Int],
                                  val length: Int) extends IndexedSeq[Base] {
          import RNA1._

          def apply(idx: Int): Base = {
            if (idx < 0 || length <= idx) throw new IndexOutOfBoundsException
            Base.fromInt(groups(idx / N) >> (idx % N * S) & M)
          }
        }

        object RNA1 {
          // Number of bits necessary to represent group
          private val S = 2
          // Number of groups that fit in an `Int`
          private val N = 32 / S
          // Bitmask to isolate a group
          private val M = (1 << S) - 1

          def fromSeq(buf: Seq[Base]): RNA1 = {
            @inline def requiredInt(nBase: Int) = (nBase + N - 1) / N
            val groups = new Array[Int](requiredInt(buf.length))

            for (i <- buf.indices)
              groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)

            new RNA1(groups, buf.length)
          }

          def apply(bases: Base*) = fromSeq(bases)
        }
      #+END_SRC
      + ONLY one /constructor/ exists, and it is /private/.
        This design achieves a GOOD *decoupling* of the /interface/ of RNA
        sequences and its /implementation/.

      + Two /factory methods/: ~fromSeq~ and ~apply~.

      + =From Jian=
        I extract a ~requiredInt~ function from the original ~val groups~ line,
        which promises the right and minimal capacity of the underlying
        ~Array[Int]~, and the last ~Int~ might be partially filled.

        The equivalence of the body of ~requiredInt~ is
        #+BEGIN_SRC scala
          implicit booleanToInt(b: Boolean): Int = if (b) 1 else 0

          (nBase / n) + (nBase % n != 0)

          // From Jian: I think I need Python's `divmod`
        #+END_SRC

**** DONE Adapting the _result type_ of ~RNA~ /methods/:
     CLOSED: [2018-04-01 Sun 07:10]
     - Read the example below and you know what kind of problem we need to deal with:
       #+BEGIN_SRC scala
         val rna1 = RNA1(A, U, G, G, T)

         rna1.length
         // res2: Int = 5

         rna1.last
         // res3: Base = T

         rna1.take(3)  // !!! the result type, both static and dynamic are not what we want!
         // res4: IndexedSeq[Base] = Vector(A, U, G)
       #+END_SRC

       =From Jian=
       There is always a category of /methods/ of a /collection class/ that they
       always return a subset of this /collction/, and we expect the results is
       of the receiver's type, ~RNA1~ for here. Current version (~RNA1~) doesn't
       fulfill this requirement. We need to solve this!!!

       + ~take~ is inherited from ~IndexedSeq~, and this is why the /static type/
         of the return value is ~IndexedSeq[Base]~.

         The current default implementation of ~IndexedSeq~ is ~Vector~, and this
         is why the /dynamic type/ is ~Vector[Base]~.

     - We have multiple ways to fix this problem:
       + The _most naive solution_:
         ~def take(count: Int): RNA1 = RNA1.fromSeq(super.take(count))~

         This works, but how about the other (*over fifty*) /methods/?
         "Re-implement them" is _NOT_ an attractive option!!!

       + A _sophisticated solution_:
         Let ~RNA2~ /class/ (the version 2 of the RNA /class/) extends _not
         only_ ~IndexedSeq[Base]~, _but also_ the /implementation trait/
         ~IndexedSeqLike[Base, RNA2]~ (not the one of ~IndexedSeq[Base]~'s
         /supertype/ -- ~IndexedSeqLike[Base, IndexedSeq[Base]]~).

         #+BEGIN_SRC scala
           // Code shown in Listing 25.7.
           final class RNA2 private (val groups: Array[Int], val length: Int)
               extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA2] {
             import RNA2._

             override def newBuilder: Builder[Base, RNA2] =
               new ArrayBuffer[Base] mapResult fromSeq

             def apply(idx: Int): Base = // as before
           }
         #+END_SRC

         * The definition of ~newBuilder~:
           ~ArrayBuffer[Base]~ itself is a ~Builder[Base, ArrayBuffer]~.
           To get the required /builder/ ~Builder[Base, RNA2]~, call the
           ~mapResult~ /method/ of the ~Builder[Base, ArrayBuffer]~, namely
           the ~ArrayBuffer[Base]~, with the parameter ~RNA2.fromSeq~.

           - Q :: WHY ~RNA2.fromSeq~?

           - A :: Because
             + its /input parameter type/ is ~Seq[Base]~, and
               ~ArrayBuffer[Base]~ is the /subtype/ of ~Seq[Base]~.

             + its /result type/ is ~RNA2~.

         * If you left out the ~newBuilder~ definition, you would have gotten
           an error message like the following:
           #+BEGIN_SRC text
             RNA2.scala:5: error: overriding method newBuilder in trait
             TraversableLike of type => scala.collection.mutable.Builder[Base,RNA2];
              method newBuilder in trait GenericTraversableTemplate of type
              => scala.collection.mutable.Builder[Base,IndexedSeq[Base]] has
              incompatible type
             class RNA2 private (val groups: Array[Int], val length: Int)
                   ˆ
             one error found
           #+END_SRC
           *This error message is complicated, which reflects the intricate way
           the collection libraries are put together.*

           Some info of the error message detracts more than it helps.

           What remains is that a /method/ ~newBuilder~ with /result type/
           ~Builder[Base, RNA2]~ needed to be defined, but a /method/ ~newBuilder~
           with result type ~Builder[Base, IndexedSeq[Base]]~ was found. The
           latter does _NOT override_ the former. =WHY= =TODO=

     - The _new implementation_ (~RNA2~) DIFFERS from the previous one (~RNA1~)
       in _only two aspects_:

       1. class ~RNA2~ now ALSO _extends_ from ~IndexedSeqLike[Base, RNA2]~.
          =From Jian=
          If not, its still a subtype of ~IndexedSeqLike~, but it is NOT a
          /subtype/ of ~IndexedSeqLike[Base, RNA2]~ -- it is a /subtype/ of
          ~IndexedSeqLike[Base, IndexedSeq[Base]]~, which is the /supertrait/ of
          ~IndexedSeq[Base]~.

       2. The ~IndexedSeqLike~ /trait/ implements ALL /concrete methods/ of
          ~IndexedSeq~ in an extensible way (=From Jian= by using
          ~newBuilder~, which is inherited eventually from
          ~TraversableLike~). =TODO= =???=

     - =From Jian=
       + Q :: Since ~IndexedSeq~ extends ~IndexedSeqLike~, WHY NOT only
              extends ~IndexedSeq~ rather than BOTH ~IndexedSeq~ and
              ~IndexedSeqLike~.

       + A :: Firstly, as =Jian= mentioned,
              ~A extends IndexedSeq[Base]~ also implies A is a /subtype/ of
              ~IndexedSeqLike[Base, IndexedSeq[Base]]~, but we actually want
              ~IndexedSeqLike[Base, RNA2]~ -- the /subtype/ (more specific) of
              ~IndexedSeqLike[Base, IndexedSeq[Base]]~.

              Secondly, even though, we still have multiple choices, among which
              ~extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA2]~ is
              the only one which can take into account _both_ CORRECTNESS and
              SAFTY (with the help of type checking from compiler):

         1. Only ~extends IndexedSeqLike[Base, RNA2]~.

            I think you won't do this -- this can be right, if you can
            complete the code as re-do the work ~IndexedSeq[Base]~ already do --
            which means you need to write more code but won't get more reward,
            and if you made mistake more punishment will come.

         2. Only ~extends IndexedSeq[Base]~.

            This can also be right _IF YOU REMEMBER_ to *override* the
            ~newBuilder~ -- we have ~newBuilder: Builder[Base, IndexedSeq[Base]]~,
            but we want ~newBuilder: Builder[Base, RNA2]~).

            If you _forget overriding it_, the compiler won't warn you --
            actually you did nothing wrong from the perspective of the
            compiler. Then when you call /methods/ like ~take~, you get a
            ~Vector[Base]~ back, this is our starting point. We need a strong
            constraint to help us stopping forgetting *override*.

         3. ~extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA2]~

            This time if you forget to override ~newBuilder~, _the compiler
            will trigger a *error report* (see back and you can find it) for
            /type incompatibility/:_
              The ~newBuilder: Builder[Base, RNA2]~ of ~IndexedSeqLike[Base]~
            (which is eventually comes from ~TraversableLike[Base, RNA2]~) is
            imcompatible with the ~newBuilder: Builder[Base, IndexedSeq[Base]]~
            that comes from the ~GenericTraversableTemplate[Base, IndexedSeq]~.
            * *COMMENT*:
              #+BEGIN_SRC scala
                IndexedSeq[+A] extends Seq[A]
                              with scala.collection.IndexedSeq[A]
                              with GenericTraversableTemplate[A, IndexedSeq]
                              with IndexedSeqLike[A, IndexedSeq[A]]
              #+END_SRC

            =From Jian=
            ( My guess ): =TODO= =???= =AM I right?=
            /linearization rule/ can *resolve* the right ~super~, but, even
            though, /conflict method types/ of different /supertypes/ is still a
            compile error -- even if the /conflict method types/ have inheritance
            relation -- like ~IndexedSeq[Base]~ and ~RNA2~ in our case.
              To solve this, just /override/ the /method/, can manually choose
            _the most specific type_ (for this case, it should be ~RNA2~, which
            is the /subtype/ of ~IndexedSeq[Base]~) to fufill the /compitable/
            requirement.

       + =From Jian=
         According to this new implementation, we know
         * ~RNA2~ extends
           1. ~IndexedSeq[Base]~;
           2. and then ~IndexedSeqLike[Base, RNA2]~.

         * ~IndexedSeq[Base]~ extends
           - ~IndexedSeqLike[Base, IndexedSeq[Base]]~
           - ~GenericTraversableTemplate[Base, IndexedSeq]~.

         _My GUESS_:
         because of the /linearization rule/, ~IndexedSeqLike[Base, RNA2]~ and
         ~GenericTraversableTemplate[Base, IndexedSeq]~ show up in the
         inheritance hierarchy, but ~IndexedSeqLike[Base, IndexedSeq[Base]]~
         doesn't.
           Then incompatibility happens because of the different second type
         parameters!

         Now we override the ~newBuilder~ with the type ~Builder[Base, RNA2]~,
         then the compiler use this, rather than being confused by the
         incompatible ~newBuilder~'s from different supertypes.

         =Question=
         Since I'm still now good at identifying the /variance/, whats the
         relation between ~newBuilder: Builder[Base, RNA2]~ and ~newBuilder:
         Builder[Base, IndexedSeq[Base]~ from the /variance/ point of view???

         (Background Info: the second type parameter of ~Builder~ is defined
         as /covariance/)

**** DONE Dealing with ~map~ and friends
     CLOSED: [2018-04-01 Sun 07:10]
     =From Jian=
     - We have solved the "make /subset methods/ return type right" problem.

       Now we need to solve a new problem: Some /methods/ potentially have the
       capacity of changing the /element type of a collection/, and then what
       should be the /result types/.

       + The ideal case, for example:
         #+BEGIN_SRC scala
           val rna = RNA(A, U, G, G, T)
           // rna: RNA = RNA(A, U, G, G, T)

           /** Element type does NOT change -- return the same type */
           rna map { case A => T case b => b }
           // res7: RNA = RNA(T, U, G, G, T)

           rna ++ rna
           // res8: RNA = RNA(A, U, G, G, T, A, U, G, G, T)

           /** --------------------------------------------------- */


           /** Element type does change -- return the a proper supertype */
           rna map Base.toInt
           // res2: IndexedSeq[Int] = Vector(0, 3, 2, 2, 1)

           rna ++ List("missing", "data")
           // res3: IndexedSeq[java.lang.Object] = Vector(A, U, G, G, T, missing, data)
         #+END_SRC

       + Our ~RNA2~:
         Always return ~IndexedSeq[Base]~ and ~Vector[Base]~ as /static type/ and
         /dynamic type/, respectively. No ~RNA2~ returned.

     - *Solution*:
       1. Take a close look at the signature of the ~map~ /method/ (or other
          =From Jian= /transformation methods/ -- *transformation* here means
          /aggregation/, /removal/, /change element type/ -- ~++~ is another
          example).
          #+BEGIN_SRC scala
            def map[B, That](f: Elem => B)
               (implicit cbf: CanBuildFrom[Repr, B, That]): That
          #+END_SRC
          + ~Elem~ is the /type of elements/ of the /collection/

          + ~Repr~ is the /type of the collection/ ITSELF,
            that is, the _second_ /type parameter/ that gets passed to
            /implementation traits/ such as ~TraversableLike~ and
            ~IndexedSeqLike~.

          + The ~map~ /method/ takes _TWO more_ /type parameters/, ~B~ and ~That~.
            * ~B~ stands for the /result type/ of the /mapping function/ ~f~.
              It is also the /element type/ of the *new* /collection/.

            * ~That~ appears as the /result type/ of ~map~, so it represents the
              /type of the new collection/ that gets created.

       2. How does ~That~ determined?

          It is linked to the other types by an /implicit parameter/ ~cbf~ of
          type ~CanBuildFrom[Repr, B, That]~. ~cbf~ is defined by the INDIVIDUAL
          /collection class/ (usually in its /companion object/).

          In essence, an /implicit value/ of type ~CanBuildFrom[From, Elem, To]~
          says:
          _"Here is a way, given a collection of type From, to build with
          elements of type Elem a collection of type To."_

       3. Now we know why in our example ~map~ and ~++~ cannot return the ideal
          type -- no ~CanBuildFrom~ instance that creates ~RNA2~, and the next
          best available ~CanBuildFrom~ was found in the companion object of the
          inherited ~IndexedSeq~ (=From Jian= remember the /linearization
          rule/!!!). That /implicit/ creates ~IndexedSeq~'s.

       4. The final version of RNA /class/ -- now we can drop the version number
          in the examples before:
          #+BEGIN_SRC scala
            final class RNA private (val groups: Array[Int], val length: Int)
                extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA] {
              import RNA._

              // Mandatory re-implementation of 'newBuilder' in ''IndexedSeq'
              override protected[this] def newBuilder: Builder[Base, RNA] =
                RNA.newBuilder

              // Mandatory implementation of 'apply' in 'IndexedSeq'
              def apply(idx: Int): Base = {
                if (idx < 0 || length <= idx)
                  throw new IndexOutOfBoundsException
                Base.fromInt(groups(idx / N) >> (idx % N * S) & M)
              }

              // Optional re-implementation of` foreach`,
              // to make it more efficient.
              override def foreach[U](f: Base => U): Unit = {
                var i = 0
                var b = 0
                while (i < length) {
                  b = if (i % N == 0) groups(i / N) else b >>> S
                  f(Base.fromInt(b & M))
                  i += 1
                }
              }
            }

            object RNA {
              private val S = 2             // number of bits in group
              private val M = (1 << S) - 1  // bitmask to isolate a group
              private val N = 32 / S        // number of groups in an Int

              def fromSeq(buf: Seq[Base]): RNA = {
                val groups = new Array[Int]((buf.length + N - 1) / N)

                for (i <- buf.indices)
                  groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)

                new RNA(groups, buf.length)
              }

              def apply(bases: Base*) = fromSeq(bases)

              def newBuilder: Builder[Base, RNA] =
                new ArrayBuffer mapResult fromSeq

              implicit def canBuildFrom: CanBuildFrom[RNA, Base, RNA] =
                new CanBuildFrom[RNA, Base, RNA] {
                  def apply(): Builder[Base, RNA] = newBuilder
                  def apply(from: RNA): Builder[Base, RNA] = newBuilder
                }
            }
          #+END_SRC

       5. Compared to /class/ ~RNA2~ there are _TWO important differences_:
          + the ~newBuilder~ implementation has moved from the ~RNA~ class to its
            /companion object/. =Why do we need to move it???= =TODO=

            The ~newBuilder~ /method/ in /class/ ~RNA~ simply forwards to this
            definition.

          + Add an implicit ~CanBuildFrom~ value in ~object RNA~.
            To create such an /object/ you need to define *two* ~apply~
            /methods/ in the ~CanBuildFrom~ /trait/. Both create a NEW /builder/
            for an ~RNA~ /collection/, but they _differ in their argument list_.
            * The ~apply()~ /method/ simply creates a NEW /builder/ of the RIGHT
              /type/.

            * The ~apply(from)~ /method/ takes the /original collection/ as
              argument.

              =TODO= =???=
              This can be useful to adapt the /dynamic type/ of /builder's return
              type/ to be the *SAME as* the /dynamic type/ of the /receiver/.

                In the case of ~RNA~ this does not come into play because RNA is a
              /final class/, so any /receiver/ of /static type/ ~RNA~ also has
              ~RNA~ as its /dynamic type/. That's why ~apply(from)~ also simply
              calls ~newBuilder~, ignoring its argument.

              =From Jian= I need a more complete example!!!!! =TODO= =TODO= =TODO=

     - This how we can implement a complete version of RNA.

       *It requires a little bit of protocol.*:
       In essence, you need to know where to put the ~newBuilder~ /factories/ and
       the ~canBuildFrom~ /implicits/.

       On the plus side, with relatively little code you get a large number of
       methods automatically defined.

     - If you do *NOT* intend to do bulk operations like ~take~, ~drop~, ~map~,
       or ~++~ on your /collection/, you can choose to use the first version,
       ~RNA1~.

*** DONE Integrating new sets and maps - 614
    CLOSED: [2018-04-02 Mon 02:43]
    - Patricia trie :: =TODO=

    - We will implement a /map/ as a /Patricia trie/, and we call it ~PrefixMap~,
      which means that it provides a /method/ ~withPrefix~ that _selects_ a
      _submap_ of all keys starting with a given prefix.
      #+BEGIN_SRC scala
        val m = PrefixMap("abc" --> 0, "abd" -> 1, "al" -> 2, "all" -> 3, "xy" -> 4)
        // m: PrefixMap[Int] = Map((abc,0), (abd,1), (al,2), (all,3), (xy,4))

        m withPrefix "a"
        // res14: PrefixMap[Int] = Map((bc,0), (bd,1), (l,2), (ll,3))
      #+END_SRC

    - Implementation (class):
      #+BEGIN_SRC scala
        import collection._


        class PrefixMap[T] extends mutable.Map[String, T]
                              with mutable.MapLike[String, T, PrefixMap[T]] {

          var suffixes: immutable.Map[Char, PrefixMap[T]] = Map.empty
          var value: Option[T] = None

          def get(s: String): Option[T] =
            if (s.isEmpty) value
            else           suffixes get (s(0)) flatMap (_.get(s substring 1))

          def withPrefix(s: String): PrefixMap[T] =
            if (s.isEmpty) this
            else {
              val leading = s(0)
              suffixes get leading match {
                case None =>
                  suffixes = suffixes + (leading -> empty)
                case _ =>
              }
              suffixes(leading) withPrefix (s substring 1)
            }

          override def update(s: String, elem: T) =
            withPrefix(s).value = Some(elem)

          override def remove(s: String): Option[T] =
            if (s.isEmpty) { val prev = value; value = None; prev }
            else           suffixes get (s(0)) flatMap (_.remove(s substring 1))

          def iterator: Iterator[(String, T)] =
            (for (v <- value.iterator) yield ("", v)) ++
              (for ((chr, m) <- suffixes.iterator;
                    (s, v) <- m.iterator) yield (chr +: s, v))

          def += (kv: (String, T)): this.type = { update(kv._1, kv._2); this }

          def -= (s: String): this.type = { remove(s); this }

          override def empty = new PrefixMap[T]
        }
      #+END_SRC
      + You have seen the inheritance pattern (extends a /trait/ and /its
        implementation trait/) in the RNA strand example.

      + The /prefix map/ node has *two* /mutable fields/:
        * ~suffixes~: A map from characters to ~PrefixMap~ value.
                      It is initialized to an /empty map/.

        * ~value~: An optional value associated with the node.
                   Its initial value is ~None~.

      + Question about the /type/ of ~suffixes~:
        Why did we pick an /immutable map/ rather than /mutable map/, which is
        more standard since ~PrefixMap~ as a whole is also /mutable/?

        Answer:
        /immutable maps/ that *contain only a few element* are _very efficient_
        in both /space/ and /execution time/.

          /Immutable maps/ that fewer than 5 elements are represented as a single
        object. By contrast, as described in Section 17.2, the standard /mutable
        map/ implementation ~HashMap~, even if it is empty, it occupies around
        80 bytes.

          If *small* /map/ are common, it is better to pick /immutable/ over
        /mutable/. In the case of /Patricia tries/, we'd expect that _most
        nodes, except the ones at the very top of the tree_, would contain only
        a few successors.

      + No ~newBuilder~ /method/, and with the help of ~empty~ /method/, the right
        /type/ can be built.

    - Implementation (companion object):
      #+BEGIN_SRC scala
        import scala.collection.mutable.{Builder, MapBuilder}
        import scala.collection.generic.CanBuildFrom


        object PrefixMap {
          def empty[T] = new PrefixMap[T]

          def apply[T](kvs: (String, T)*): PrefixMap[T] = {
            val m: PrefixMap[T] = empty
            for (kv <kvs)
              m += kv
            m
          }

          def newBuilder[T]: Builder[(String, T), PrefixMap[T]] =
            new MapBuilder[String, T, PrefixMap[T]](empty)

          implicit def canBuildFrom[T]
              : CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] =
            new CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] {
              def apply(from: PrefixMap[_]) = newBuilder[T]
              def apply() = newBuilder[T]
            }
        }
      #+END_SRC

      ~class PrefixMap[T]~ can work well without the companion object.
      We create this /companion object/ to provide some /factory methods/ for
      convenience.

      + We said we don't need ~newBuilder~ to generate new ~PrefixMap~ instance,
        and then why do we define it here in this /companion object/?

        Answer:
        Review the code of this /companion object/, and you'll find that the
        new /implicit method/ ~canBuildFrom~ need it -- what we said before is
        NOT wrong, if you don't need ~canBuildFrom~ to help you get the most
        fittable type when calling /transformation methods/ -- yes! this is not
        very important in some simple cases. ~canBuildFrom~ does NOT make things
        right, it only make things better.

*** DONE Summary - 620
    CLOSED: [2018-04-01 Sun 07:15]
    If you want to *FULLY integrate a NEW /collection class/ into the framework*,
    you need to _pay attention to the following points_:

    1. *Decide* whether the /collection/ should be /mutable/ or /immutable/.

    2. *Pick the right* /base traits/ for the /collection/.

    3. *Inherit from the right* /implementation trait/ to _implement_ most
       /collection/ operations.

    4. If you want ~map~ and similar operations to _return instances of your
       /collection type/,_ provide an _implicit_ ~CanBuildFrom~ in your
       /class/'s /companion object/.

** DONE 25.4 Conclusion - 620
   CLOSED: [2018-03-30 Fri 22:13]
   You have now seen
   - How Scala's /collections/ are built;

   - How you can _build new kinds_ of /collections/.

   - Because of Scala's rich support for abstraction,
     each _new_ /collection/ type can have a large number of /methods/ *without*
     having to reimplement them all over again.
* DONE 26 Extractors - 621
  CLOSED: [2017-12-02 Sat 23:56]
  This chapter explains what /extractors/ are and how you can use them to define
  patterns that are decoupled from an object's representation.

** DONE 26.1 An example: extracting email addresses - 621
   CLOSED: [2017-12-02 Sat 01:34]
   - =FROM JIAN= =TODO=
     All the examples before are oversimplified, modify them to runnable real
     world code later!!!

   - Compare
     + Access function:
       #+BEGIN_SRC scala
         def isEMail(s: String): Boolean = ???
         def domain(s: String): String = ???
         def user(s: String): String = ???

         if (isEMail(s)) println(user(s) + " AT " + domain(s))
         else            println("not an email address")
       #+END_SRC

     + Pattern matching:
       #+BEGIN_SRC scala
         toEmail(s) match {
           case EMail(user, domain) => println(user + " AT " + domain)
           case _                   => println("not an email address")
         }
       #+END_SRC

   - More complicated example - find two successive email addresses with the same
     user part:
     + Access function:
       #+BEGIN_SRC scala
         def isEMail(s: String): Boolean = ???
         def domain(s: String): String = ???
         def user(s: String): String = ???

         val sep: String = ???

         val result: Option[List[EMail]] = ss.
           split(sep).
           sliding(2).
           find { case List(e1, e2) =>
             isEMail(e1) && isEMail(e2) && user(e1) == user(e2)
           }

         if (result.isEmpty)
           println("not successive email addresses with the same user part")
         else
           println(f"Two successive email addresses with the same user part ${user(reslt.get.head)}")
       #+END_SRC

     + Pattern matching:
       #+BEGIN_SRC scala
         @annotation.tailrec
         def findSuccessiveSameUser(ss: List[EMail]): Unit = {
           ss match {
             case Nil =>
               println("not successive email addresses with the same user part")
             case EMail(u1, d1) :: EMail(u2, d2) :: _ if u1 == u2 =>
               println(f"Two successive email addresses with the same user part ${u1}")
             case _ :: tl =>
               findSuccessiveSameUser(tl)
           }
         }

         findSuccessiveSameUser(ss.split(sep).sliding(2).map(toEmail))
       #+END_SRC

   - Scala's /extractors/  let you define new /patterns/ for _preexisting_ types,
     where the /pattern/ need NOT follow the internal representation of the type.

** DONE 26.2 Extractors - 622
   CLOSED: [2017-12-02 Sat 05:57]
   - extractor :: an object that has a method called ~unapply~ as one of its
                  members.

   - xxx
     #+BEGIN_SRC scala
       object EMail {
         // The injection method (optional)
         def apply(user: String, domain: String) = user + "@" + domain

         def unapply(str: String): Option[(String, String)] =
           (str split "@") match {
             case List(u, d) => Some(u, d)
             case _          => None
           }
       }
     #+END_SRC

   - ~selectorString match { case EMail(user, domain) => ... }~
     would lead to the call:
     ~EMail.unapply(selectorString)~. This call will lead to two kinds of return
     value:
     + ~Some(user, domain)~
       If this is the case, then bind and run the expression after ~=>~

     + ~None~
       If this is the case, then try next pattern or fail (when NO pattern left)
       with a ~MatchError~ exception.

   - If the being matched value's annotated doesn't conform the parameter type
     that ~unapply~ require, check if this value can be the required type:
     + If it is, just cast and proceed.
     + If not, the pattern fails immediately.

   - injection :: ~apply~

   - extraction :: ~unapply~

   - Design principle:
     Dual methods ~apply~ and ~unapply~, it they both exist in a class, should
     satisfy the requirements:
     #+BEGIN_SRC scala
       // #1 - a direction
       Email.unapply(EMail.apply(user, domain))
       // SHOULD return `Some(user, domain)`


       // #2 - another redirection
       EMail.unapply(obj) match {
         case Some(u,d) => EMail.apply(u, d)
       }
       // The generated `EMail` SHOULD be equal to the input `obj`
     #+END_SRC

** DONE 26.3 Patterns with zero or one variables - 625
   CLOSED: [2017-12-02 Sat 21:44]
   - To return just one pattern element:
     Since there is NO one-tuple in Scala, the ~unapply~ method simply wraps the
     element itself directly into a ~Some~.
       This time ~Some(v)~ is NOT ~Some(Tuple1(v))~, which is a special case for
     ~unapply~, though write it in this way is so much natural.

     Example:
     #+BEGIN_SRC scala
       object Twice {
         def apply(s: String): String = s + s

         def unapply(s: String): Option[String] = {
           val length = s.length / 2
           val half = s.substring(0, length)
           if (half == s.substring(length)) Some(half) else None
         }
       }
     #+END_SRC

   - It's also possible that an extractor pattern does _NOT bind any_ variables.
     In this case the corresponding ~unapply~ method returns a boolean.

     Example:
     #+BEGIN_SRC scala
       object UpperCase {
         def unapply(s: String): Boolean = s.toUpperCase == s
       }
     #+END_SRC
     In this case, only ~unapply~, NO ~apply~:
     it would make NO sense to define an ~apply~, as there's _nothing to
     construct_.

   - Apply all the previously defined extractors together in its pattern matching
     code:
     #+BEGIN_SRC scala
       def userTwiceUpper(s: String) = s match {
         case EMail(Twice(x @ UpperCase()), domain) =>
           "match: " + x + " in domain " + domain
         case _ =>
           "no match"
       }
     #+END_SRC

     The pattern here is a little complicated:
     1. You MUSTN'T omit the empty parameter list in ~UpperCase()~, otherwise the
        match would test for equality with object UpperCase!

     2. You can consider the code like this:
     #+BEGIN_SRC scala
       val unapplyEMail = Email.unapply(s)

       if (unapplyEMail.nonEmpty) {
         Some(user, domain) = unapplyEMail
         val unapplyTwice = Twice.unapply(user)

         if (unapplyTwice.nonEmpty && Uppercase.unapply(unapplyTwice.get)) {
             "match: " + x + " in domain " + domain
         } else  // the catch all pattern `_`
             "no match"
       } else  // the catch all pattern `_`
           "no match"
     #+END_SRC

** DONE 26.4 Variable argument extractors - 627
   CLOSED: [2017-12-02 Sat 22:20]
   - Use ~unapplySeq~ can do something like
     #+BEGIN_SRC scala
       dom match {
         case Domain("org", "acm") => println("acm.org")
         case Domain("com", "sun", "java") => println("java.sun.com")
         case Domain("net", _*) => println("a .net domain")
       }
     #+END_SRC

   - Implementation of ~Domain~:
     #+BEGIN_SRC scala
       object Domain {
         // The injection method (optional)
         def apply(parts: String*): String =
           parts.reverse.mkString(".")

         // The extraction method (mandatory)
         def unapplySeq(whole: String): Option[Seq[String]] =
           Some(whole.split("\\.").reverse)
       }
     #+END_SRC

   - Example:
     #+BEGIN_SRC scala
       def isTomInDotCom(s: String): Boolean = s match {
         case EMail("tom", Domain("com", _*)) => true
         case _ => false
       }

       isTomInDotCom("tom@sun.com")    // true
       isTomInDotCom("peter@sun.com")  // false
       isTomInDotCom("tom@acm.org")    // false
     #+END_SRC

   - It's also possible to _return some fixed elements_ from an ~unapplySeq~
     _together with the variable part_.

     This is expressed by returning _all elements in a tuple_, where the variable
     part comes last, as usual.

     Example:
     #+BEGIN_SRC scala
       object ExpandedEMail {
         def unapplySeq(email: String)
             : Option[(String, Seq[String])] = {
           val parts = email split "@"

           if (parts.length == 2)
             Some(parts(0), parts(1).split("\\.").reverse)
           else
             None
         }
       }

       val s = "tom@support.epfl.ch"

       val ExpandedEMail(name, topdom, subdoms @ _*) = s
       // name: String = tom
       // topdom: String = ch
       // subdoms: Seq[String] = WrappedArray(epfl, support)
     #+END_SRC

** DONE 26.5 Extractors and sequence patterns - 630
   CLOSED: [2017-12-02 Sat 22:24]
   In the standard library
   #+BEGIN_SRC scala
     package scala

     object List {
       def apply[T](elems: T*) = elems.toList

       def unapplySeq[T](x: List[T]): Option[Seq[T]] = Some(x)
     }
   #+END_SRC
   Similar to ~Array~

** DONE 26.6 Extractors versus case classes - 631
   CLOSED: [2017-12-02 Sat 23:56]
   - Even though they are very useful, /case classes/ have one _SHORTCOMING_:
     they _expose the concrete representation of data_.

       This means that the name of the class in a constructor pattern
     corresponds to the concrete representation type of the selector object.

   - /Extractors/ _BREAK_
     this link between /data representations/ and /patterns/.

   - /representation independence/ allows you to change an implementation type
     used in a set of components without affecting clients of these components.

   - Since /case classes/ have no /representation independence/, if your
     component had _defined and exported_ a set of /case classes/, you'd be stuck
     with them BECAUSE
     client code could already contain pattern matches against these case classes.

   - /Representation independence/ is an important advantage of /extractors/
     over /case classes/.

   - /Case classes/ have some advantages:
     + More concise

     + Usually more efficient pattern matches than extractors.
         The Scala compiler can optimize patterns over /case classes/ much better
       than patterns over /extractors/ -- the mechanisms of /case classes/ are
       fixed, whereas an ~unapply~ or ~unapplySeq~ method in an /extractor/
       could do almost anything.

     + /Exhaustiveness check/ for /case classes/ inherit from /sealed classes/.

   - Summary: It depends
     + closed application: you usually prefer /case classes/

     + Expose a type to unknown clients: /extractors/ can help you maintain
       /representation independence/.

   - If it is NOT clear when you start a new project, you can always start from
     /case classes/, and then, when you think you need /representation
     independence/, change to /extractors/.

     You can do this because the syntax for /pattern matching/ is always the
     same, NO MATTER there are /extractors/ or /case classes/.

** DONE 26.7 Regular expressions - 632
   CLOSED: [2019-07-22 Mon 15:58]
   - One particularly useful application area of /extractors/ are /regular
     expressions/.

     Like Java, Scala provides /regular expressions/ through a library, but
     /extractors/ make it much nicer to interact with them.

*** DONE Forming regular expressions
    CLOSED: [2017-12-02 Sat 23:13]
    - Review some basic pattern of Java regex (~java.util.regex.Pattern~)
      page 632 - 633
      =TODO= =TODO= =TODO=

    - Scala regex inherits its _regex syntax_ comes from Java, and Java inherits
      most of the regex features of Perl.

    - ~scala.util.matching.Regex~

    - Create a new regex value from Regex constructor:
      #+begin_src scala
        val Decimal = new Regex("(-)?(\\d+)(\\.\\d*)?")
      #+end_src
      + A short syntax
        #+begin_src scala
          val Decimal = """(-)?(\d+)(\.\d*)?"""
        #+end_src
        Here /method/ ~r~ comes from ~StringOps~

    - The definition of ~r~ is like
      #+BEGIN_SRC scala
        package scala.runtime

        import scala.util.matching.Regex

        class StringOps(self: String) ... {
          // ...
          def r = new Regex(self)
        }
      #+END_SRC

*** DONE Searching for regular expressions
    CLOSED: [2017-12-02 Sat 23:13]
    - ~regex findFirstIn str~
      Return an ~Option~ value

    - ~regex findAllIn str~
      Return an ~Iterator~ value

    - ~regex findPrefixOf str~
      Return an ~Option~ value

    - Example:
      #+BEGIN_SRC scala
        val input = "for -1.0 to 99 by 3"

        for (s <- Decimal findAllIn input)
          println(s)
        // -1.0
        // 99
        // 3

        Decimal findFirstIn input
        // Some("-1.0")

        Decimal findPrefixOf input
        // None
      #+END_SRC

*** DONE Extracting with regular expressions
    CLOSED: [2017-12-02 Sat 23:26]
    Every Regex in Scala defines an /extractor/.
    #+BEGIN_SRC scala
      val Decimal(sign, integerPart, decimalPart) = "-1.23"
      // sign: String = -
      // integerPart: String = 1
      // decimalPart: String = .23


      val Decimal(sign, integerPart, decimalPart) = "1.0"
      // sign: String = null
      // integerPart: String = 1
      // decimalPart: String = .0


      for (Decimal(s, i, d) <- Decimal findAllIn input)
        println("sign: " + s + ", integer: " +
            i + ", decimal: " + d)
      // sign: -, integer: 1, decimal: .0
      // sign: null, integer: 99, decimal: null
      // sign: null, integer: 3, decimal: null
    #+END_SRC

    + *CAUTION*: =From Jian=
      An optional group that is not matched will bind ~null~ to the target variable.

** DONE 26.8 Conclusion - 636
   CLOSED: [2017-12-02 Sat 23:27]
   In this chapter you saw how to *generalize* /pattern matching/ with /extractors/.

   - /Extractors/ let you define your own kinds of patterns, which *need _NOT_
     correspond to the type of the expressions you select on*.
     + This gives you more flexibility in the kinds of patterns you can use for
       matching.

     + In effect it’s like *having different possible views on the same data*.

     + It also gives you a layer between a /type’s representation/ and _the way
       clients view it_.
         *This lets you do pattern matching while maintaining representation
       independence, a property which is very useful in large software systems.*

   - Extractors are one more element in your tool box that let you define
     flexible library abstractions.

* DONE 27 Annotations - 637 *Learn MORE*
  CLOSED: [2017-10-21 Sat 19:01]
  - annotations :: structured information added to program source code.

    + Like /comments/,
      they can be sprinkled throughout a program and attached to any variable,
      method, expression, or other program element.

    + Unlike /comments/,
      _they have structure, thus making them easier to machine process._

  - This chapter
    + shows how to use annotations in Scala,
    + shows their general syntax and how to use several standard annotations.

  - This chapter does NOT show how to write new annotation processing tools,
    because it is _beyond the scope of this book_.

      Chapter 31 shows one technique, but not the only one.

    _This chapter focuses on how to use annotations._

** DONE 27.1 Why have annotations? - 637
   CLOSED: [2017-10-21 Sat 18:59]
   - There are many things you can do with a program _other than_ compiling and
     running it. Some examples are:
     1. Automatic generation of documentation as with *Scaladoc*.
        =TODO=

     2. Pretty printing code so that it matches your preferred style.
        =TODO=

     3. Checking code for common errors such as opening a file but, on some
        control paths, never closing it.
        =TODO=

     4. Experimental type checking, for example to manage side effects or ensure
        ownership properties.
        =TODO=

   - Such tools are called /meta-programming/ tools, because they are programs
     that take other programs as input.

   - /Annotations/ can improve the previously listed tools as follows:
     1. A documentation generator could be instructed to document certain methods
        as _deprecated_.

     2. A pretty printer could be instructed to skip over parts of the program
        that have been carefully hand formatted.

     3. A checker for non-closed files could be instructed to ignore a particular
        file that has been manually verified to be closed.

     4. A side-effects checker could be instructed to verify that a specified
        method has no side effects.
        =TODO= =???=

** DONE 27.2 Syntax of annotations - 638
   CLOSED: [2017-10-21 Sat 18:59]
   - Annotations can also be applied to an expression, as with the ~@unchecked~
     annotation for pattern matching (see Chapter 15). To do so, place a colon
     (~:~) after the expression and then write the annotation. Syntactically, it
     looks like the annotation is being used as a type:
     #+BEGIN_SRC scala
       (e: @unchecked) match {
         // nonexhaustive
         cases...
       }
     #+END_SRC

   - /Annotations/ have a richer general form: @annot(exp1, exp2, ...)
     Though much simpler form annotations are often seen.

   - Internally,
     Scala represents an annotation as just a constructor call of an annotation
     class -- replace the ~@~ by ~new~ and you have a valid instance creation
     expression.

   - One slightly tricky bit concerns annotations that conceptually take other
     annotations as arguments, which are required by some frameworks.

     You _CANNOT_ write an annotation directly as an argument to an annotation,
     because _annotations are NOT valid expressions_. In such cases you must use
     ~new~ instead of ~@~, as illustrated here:
     #+BEGIN_SRC scala
       scala> import annotation._
       // import annotation._

       scala> class strategy(arg: Annotation) extends Annotation
       // defined class strategy

       scala> class delayed extends Annotation
       // defined class delayed

       scala> @strategy(@delayed) def f() = {}
       // <console>:1: error: illegal start of simple expression
       //        @strategy(@delayed) def f() = {}
       //                  ˆ

       scala> @strategy(new delayed) def f() = {}
       // f: ()Unit
     #+END_SRC

** DONE 27.3 Standard annotations - 640
   CLOSED: [2017-10-21 Sat 18:45]
*** DONE Deprecation
    CLOSED: [2017-10-21 Sat 18:34]
    ~@deprecated~

    - ~@deprecated def bigMistake() = // ...~

    - With message (use this in most cases):
      #+BEGIN_SRC scala
        @deprecated("use newShinyMethod() instead")
        def bigMistake() = //...
      #+END_SRC

*** DONE Volatile fields
    CLOSED: [2017-10-21 Sat 18:39]
    ~@volatile~

    Scala's concurrency support is /message passing/ and a _minimum_ of /shared
    mutable state/. =TODO= See Chapter 32

    Nonetheless, sometimes programmers want to use /mutable state/ in their
    concurrent programs. The ~@volatile~ annotation helps in such cases.

    - The ~@volatile~ keyword gives different guarantees on different platforms.

      On the Java platform, however, you get the same behavior as if you wrote
      the field in Java code and marked it with the Java volatile modifier.

*** TODO Binary serialization
*** DONE Automatic ~get~ and ~set~ methods *RE-READ*
    CLOSED: [2017-10-21 Sat 18:45]
    Scala doesn't need ~get~ and ~set~ methods.
    Some platform-specific frameworks do expect ~get~ and ~set~ methods, however.

    Scala provides the ~@scala.reflect.BeanProperty~ annotation. It informs the
    compiler to generate ~get~ and ~set~ methods for you automatically. For
    example, ~getCrazy~ and ~setCrazy~ for a field named ~crazy~.

    =IMPORTANT= =RE-READ=
    The generated ~get~ and ~set~ methods are ONLY available _AFTER_ a compilation
    pass completes.

*** DONE Tailrec
    CLOSED: [2017-10-21 Sat 18:04]
    Use ~@tailrec~, and if the _optimization CANNOT be performed_, you will then
    get a warning together with an explanation of the reasons.

*** DONE Unchecked
    CLOSED: [2017-10-21 Sat 18:06]
    ~@unchecked~

    Tell the compiler don't worry if the ~match~ expression seems to leave out some cases.
    =TODO= See Section 15.5 for details.

*** TODO Native methods
    ~@native~

    =TODO= =???=

** TODO 27.4 Conclusion - 644
   =TODO=
   Chapter 31 gives additional, Java-specific information on annotations. It
   covers annotations only available when targeting Java, additional meanings of
   standard annotations when targeting Java, how to interoperate with Java-based
   annotations, and how to use Java-based mechanisms to define and process
   annotations in Scala.

* DONE 28 Working with XML - 645
  CLOSED: [2018-04-07 Sat 01:54]
  =From Jian= the ~scala.xml~ is published officially but shipped separately.
              In the =build.sbt=, I include this library by adding
              ~"org.scala-lang.modules" %% "scala-xml" % "1.1.0"~ to
              ~libraryDependencies~.

  =From Jian= You may notice the version number ~"1.1.0"~, which is different
              from the _scala version number_.
                This is different from the case of ~scala.reflect~ library, which
              always keeps the same version number as Scala version.
                I think this means ~scala.xml~ is separated from the core
              standard library of Scala on purpose -- it is considered should
              not be a part of standard library, and it won't be merged back in
              the future. Conversely, ~scala.reflect~ is new or no-mature, and
              it is considered that ~scala.reflect~ should be a part the
              standard library in the future.

  - This chapter introduces Scala's support for XML.

  - After discussing semistructured data in general, it shows the essential
    functionality in Scala for manipulating XML:
    + how to *make* /nodes/ with /XML literals/

    + how to *save* and *load* XML _to files_

    + how to *take apart* XML /nodes/ using /query methods/ and /pattern matching/.

  - This chapter is just a brief introduction to what is possible with XML, but
    it shows enough to get you started.

** DONE 28.1 Semi-structured data - 645
   CLOSED: [2018-04-06 Fri 01:54]
   - semi-structured data :: =TODO= check the Glossary

     + XML is *more* structured than plain text.

     + _Plain XML_ is *less* structured than the objects of a programming language:
       * it admits /free-form text/ between tags

       * it lacks a type system.
         If consider the only _Plain XML_, this is right.

         footnote 1: There are /type systems/ for XML, such as XML Schemas, but
         they are beyond the scope of this book.

   - /Semi-structured data/ is very helpful any time you need to *serialize
     program data for saving in a file* or *shipping across a network*.
       Instead of _converting structured data all the way down to bytes_, you
     convert it to and from /semi-structured data/ -- usually use pre-existing
     library routines.

   - Among others, XML is the most widely used /semi-structured data/ on the
     Internet.

** DONE 28.2 XML overview - 646
   CLOSED: [2018-04-06 Fri 02:04]
   - XML is built out of *two* basic elements:
     + text

     + tags:
       /Start and end tags/ *must* match each other, just like parentheses.

     =TODO=
     footnote 2: The full story is more complicated, but this is enough to be
     effective with XML.

   - empty element :: one element that represents /start and end tags/ together.
                      For exmaple, ~<pod>Three <peas/> in the </pod>~

   - /tags/ can have /attributes/ attached to them.
     ~<pod peas="3" strings="true"/>~

   - attribute :: a name-value pair written with an equals sign in the middle.
     + The /attribute/ _name_ itself is /plain, or unstructured text/.

     + Either ~""~ or ~''~ work.

** DONE 28.3 XML literals - 647
   CLOSED: [2018-04-06 Fri 18:07]
   - Scala lets you type in XML as a /literal/ *anywhere that an /expression/ is
     valid*. For example,
     #+BEGIN_SRC scala
       <a>
         This is some XML.
         Here is a tag: <atag/>
       </a>

       //  res0: scala.xml.Elem =
       //  <a>
       //    This is some XML.
       //    Here is a tag: <atag/>
       //  </a>
     #+END_SRC

     + The ~Elem~ type.

   - Some other important XML classes are:
     + Class ~Node~ is the /abstract superclass/ of _all XML node /classes/._

     + Class ~Text~ is a /node/ _holding just text_. For example, the “stuff”
       part of ~<a>stuff</a>~ is of /class/ ~Text~.

     + Class ~NodeSeq~ holds _a sequence of nodes_.
       Many methods in the XML library process ~NodeSeqs~ in places you might
       expect them to process individual Nodes. You can still use such methods
       with individual nodes, however, since ~Node~ extends from ~NodeSeq~.

         _This may *sound weird*, but it *works out well* for XML_. You can
       think of an individual ~Node~ as a /one-element ~NodeSeq~./

   - Embed Scala code in XML:
     #+BEGIN_SRC scala
       <a> {"hello" + ", world"} </a>
       // scala.xml.Elem = <a> hello, world </a>
     #+END_SRC

   - Switch back and forth between XML and ordinary Scala:
     #+BEGIN_SRC scala
       <a> { if (yearMade < 2000) <old>{yearMade}</old>
             else xml.NodeSeq.Empty }
       </a>
     #+END_SRC

   - An expression inside a brace escape does *not have to* evaluate to an XML
     node. It can evaluate to any Scala value.
     #+BEGIN_SRC scala
       <a> {3 + 4} </a>
       // res3: scala.xml.Elem = <a> 7 </a>
     #+END_SRC

   - Any =<=, =>=, and =&= characters in the text will *be escaped* if you print
     the node back out:
     #+BEGIN_SRC scala
       <a> {"</a>potential security hole<a>"} </a>
       // res4: scala.xml.Elem = <a> &lt;/a&gt;potential security hole&lt;a&gt; </a>
     #+END_SRC

     This is good.
       If you cancatenate strings, and try to use the result as XML, you may run
     into traps -- legal result which is not what you want, or illegal XML form:
     #+BEGIN_SRC scala
       "<a>" + "</a>potential security hole<a>" + "</a>"
       // res5: String = <a></a>potential security hole<a></a>
     #+END_SRC

** DONE 28.4 Serialization - 649
   CLOSED: [2018-04-06 Fri 18:15]
   - Example:
     #+BEGIN_SRC scala
       abstract class CCTherm {
         val description: String
         val yearMade: Int
         val dateObtained: String
         val bookPrice: Int // in US cents
         val purchasePrice: Int // in US cents
         val condition: Int // 1 to 10
         override def toString = description

         def toXML =
           <cctherm>
             <description>{description}</description>
             <yearMade>{yearMade}</yearMade>
             <dateObtained>{dateObtained}</dateObtained>
             <bookPrice>{bookPrice}</bookPrice>
             <purchasePrice>{purchasePrice}</purchasePrice>
             <condition>{condition}</condition>
           </cctherm>
       }

       val therm = new CCTherm {
         val description = "hot dog #5"
         val yearMade = 1952
         val dateObtained = "March 14, 2006"
         val bookPrice = 2199
         val purchasePrice = 500
         val condition = 9
       }

       therm.toXML
       // res6: scala.xml.Elem =
       //   <cctherm>
       //     <description>hot dog #5</description>
       //     <yearMade>1952</yearMade>
       //     <dateObtained>March 14, 2006</dateObtained>
       //     <bookPrice>2199</bookPrice>
       //     <purchasePrice>500</purchasePrice>
       //     <condition>9</condition>
       //     </cctherm>
     #+END_SRC

   - Escape brace: use double braces (one is used to escape another) to represent
     one brace literal
     #+BEGIN_SRC scala
       <a> {{{{brace yourself!}}}} </a>
       // res7: scala.xml.Elem = <a> {{brace yourself!}} </a>
     #+END_SRC

** DONE 28.5 Taking XML apart - 651
   CLOSED: [2018-04-06 Fri 21:43]
  Among the many /methods/ available for the /XML classes/, there are *THREE* in
  particular that you should be aware of:

  - Extracting text.
    Use the ~text~ /method/:
    #+BEGIN_SRC scala
      /* XML with encoded characters */
      val xml = <a>Sounds <tag/> good</a>
      xml.text
      // res8: String = Sounds good

      /* XML with encoded characters */
      <a> input ---&gt; output </a>.text
      // res9: String = " input ---> output "
    #+END_SRC

  - Extracting sub-elements.
    #+BEGIN_SRC scala
      <a><b><c>hello</c></b></a> \ "b"
      // res10: scala.xml.NodeSeq = NodeSeq(<b><c>hello</c></b>)

      <a><b><c>hello</c></b></a> \ "c"
      // res11: scala.xml.NodeSeq = NodeSeq()

      <a><b><c>hello</c></b></a> \\ "c"
      // res12: scala.xml.NodeSeq = NodeSeq(<c>hello</c>)

      <a><b><c>hello</c></b></a> \ "a"
      // res13: scala.xml.NodeSeq = NodeSeq()

      <a><b><c>hello</c></b></a> \\ "a"
      // res14: scala.xml.NodeSeq = NodeSeq(<a><b><c>hello</c></b></a>)
    #+END_SRC
    + ~\~ search the sub-element by _tag name_.

    + ~\\~ search do "deep search", such as the sub-sub-element, or the the
      element itself.

    + Q: Why NOT use the ~/~ and ~//~ used in XPath?

      A: ~//~ starts a comment in Scala, and we can't use ~//~ as code.

         Since we CANNOT use ~//~, and we also don't want to use some ~\\~ and
         ~/~ together, though we want to use operators like the ones in XPath.
           Thus we use ~\\~ and ~\~, like the ones in XPath, and more consistent
         than ~\\~ and ~/~.

  - Extracting attributes.
    Use ~\\~ and ~\~, however, in this time the argument after ~\\~ and ~\~
    should be prefixed with ~@~.
    #+BEGIN_SRC scala
      val joe = <employee name="Joe"
                          rank="code monkey"
                          serial="123" />

      joe \ "@name"
      // res15: scala.xml.NodeSeq = Joe

      joe \ "@serial"
      // res16: scala.xml.NodeSeq = 123
    #+END_SRC

** DONE 28.6 Deserialization - 652
   CLOSED: [2018-04-06 Fri 21:49]
   With the help of the /methods/ described in the last section, you can
   *DESERIALIZAE* XML backinto your internal data structures.

   - For example,
     #+BEGIN_SRC scala
       def fromXML(node: scala.xml.Node): CCTherm =
         new CCTherm {
           val description = (node \ "description").text
           val yearMade = (node \ "yearMade").text.toInt
           val dateObtained = (node \ "dateObtained").text
           val bookPrice = (node \ "bookPrice").text.toInt
           val purchasePrice = (node \ "purchasePrice").text.toInt
           val condition = (node \ "condition").text.toInt
         }

       val node = therm.toXML
       // node: scala.xml.Elem =
       //   <cctherm>
       //     <description>hot dog #5</description>
       //     <yearMade>1952</yearMade>
       //     <dateObtained>March 14, 2006</dateObtained>
       //     <bookPrice>2199</bookPrice>
       //     <purchasePrice>500</purchasePrice>
       //     <condition>9</condition>
       //   </cctherm>

       fromXML(node)
       // res17: CCTherm = hot dog #5
       /* Remember:
        this is the result of `toString`, and it is also the value of the `description`
        field*/
     #+END_SRC

** DONE 28.7 Loading and saving - 653
   CLOSED: [2018-04-06 Fri 22:00]
   There is _one last part_ needed to write a /data serializer/:
   *conversion between XML and streams of bytes.*

   - There are library routines that will do it all for you!
     You simply have to call the right routine on the right data.

   - The XML /class/ has a good ~toString~, and this is why you can play with XML
     in the REPL.

   - However, it is better to use a library routine and convert all the way to
     bytes. In this way you can *include* _encoding info_.

   - *SAVE* XML (the ~node~ below) to a file of bytes:
     ~scala.xml.XML.save("therm1.xml", node)~

     After saving, the content of =therm1.xml=:
     #+BEGIN_SRC xml
       <?xml version='1.0' encoding='UTF8'?>
       <cctherm>
         <description>hot dog #5</description>
         <yearMade>1952</yearMade>
         <dateObtained>March 14, 2006</dateObtained>
         <bookPrice>2199</bookPrice>
         <purchasePrice>500</purchasePrice>
         <condition>9</condition>
       </cctherm>
     #+END_SRC

   - *LOAD* XML from a file:
     #+BEGIN_SRC scala
       val loadnode = xml.XML.loadFile("therm1.xml")
       // loadnode: scala.xml.Elem =
       // <cctherm>
       //     <description>hot dog #5</description>
       //     <yearMade>1952</yearMade>
       //     <dateObtained>March 14, 2006</dateObtained>
       //     <bookPrice>2199</bookPrice>
       //     <purchasePrice>500</purchasePrice>
       //     <condition>9</condition>
       //   </cctherm>

       fromXML(loadnode)
       // res14: CCTherm = hot dog #5
     #+END_SRC

   - Those are the *basic* /methods/ you need.
     =TODO= Learn when I need to use XML.
     There are many variations on these loading and saving /methods/, including
     /methods/ for
     + *reading* and *writing* to _various kinds_ of /readers/, /writers/,
       /input and output streams/.

** DONE 28.8 Pattern matching on XML - 655
   CLOSED: [2018-04-07 Sat 01:54]
   - For example:
     #+BEGIN_SRC scala
       def proc(code: scala.xml.Node): String =
         node match {
           case <a>{contents}</a> => "It's an a: " + contents
           case <b>{contents}</b> => "it's a b: " + contents
           case _                 => "It's something else."
         }

       proc(<a>apple</a>)
       // res18: String = It's an a: apple

       proc(<b>banana</b>)
       // res19: String = It's a b: banana

       proc(<c>cherry</c>)
       // res20: String = It's something else.
     #+END_SRC

     + An XML pattern looks just like an XML literal.

       The _main difference_ is that if you insert a ~{}~ escape, then the code
       inside is *NOT* an /expression/ but a /pattern/.
         This kind of patterns can use the full Scala pattern language!

   - Use ~_*~ to represent a pattern that mach "any sequence" of /XML nodes/.
       It is like the wildcard pattern ~_~ followed by a regex-style Kleene star
     (~*~).

     Here is the updated function matches a sequence of sub-elements instead of a
     single sub-element:
     #+BEGIN_SRC scala
       def proc(node: scala.xml.Node): String =
         node match {
           case <a>{contents @ _*}</a> => "It's an a: " + contents
           case <b>{contents @ _*}</b> => "It's a b: " + contents
           case _ => "It's something else."
       }

       proc(<a>a <em>red</em> apple</a>)
       // res23: String = It's an a: ArrayBuffer(a , <em>red</em>, apple)

       proc(<a/>)
       // res24: String = It's an a: WrappedArray()
     #+END_SRC

   - As a final tip, be aware that XML patterns work very nicely with ~for~
     expressions as a way to iterate through some parts of an XML tree while
     ignoring other parts.
       For example, suppose you wish to _skip over the white space between
     records_ in the following XML structure:
     #+BEGIN_SRC scala
       val catalog =
         <catalog>
           <cctherm>
             <description>hot dog #5</description>
             <yearMade>1952</yearMade>
             <dateObtained>March 14, 2006</dateObtained>
             <bookPrice>2199</bookPrice>
             <purchasePrice>500</purchasePrice>
             <condition>9</condition>
           </cctherm>
           <cctherm>
             <description>Sprite Boy</description>
             <yearMade>1964</yearMade>
             <dateObtained>April 28, 2003</dateObtained>
             <bookPrice>1695</bookPrice>
             <purchasePrice>595</purchasePrice>
             <condition>5</condition>
           </cctherm>
         </catalog>
     #+END_SRC
     + Visually, it lokks like there are _TWO_ /nodes/ inside the ~<catalog>~
       element.
         Actually, there are *FIVE*!!! *Three* white space /node/.
       #+BEGIN_SRC scala
         catalog match {
           case <catalog>{therms @ _*}</catalog> =>
             for (therm <- therms)
               println("processing: " + (therm \ "description").text)
         }

         // processing:
         // processing: hot dog #5
         // processing:
         // processing: Sprite Boy
         // processing:
       #+END_SRC

     + Ignore the white space /nodes/!
       Solution: ~for~ with /pattern matching/ -- only match the specified
       pattern and implicitly ignore other patterns (here it is the white space
       node pattern):
       #+BEGIN_SRC scala
         catalog match {
           case <catalog>{therms @ _*}</catalog> =>
             for (therm @ <cctherm>{_*}</cctherm> <- therms)
               println("processing: " + (therm \ "description").text)
         }

         // processing: hot dog #5
         // processing: Sprite Boy
       #+END_SRC

** DONE 28.9 Conclusion - 658
   CLOSED: [2018-04-06 Fri 22:30]
   - This chapter has *only scratched the surface* of what you can do with XML.

   - There are many other extensions, libraries, and tools you could learn about,
     some customized for Scala, some made for Java but usable in Scala, and some
     language-neutral.

   - What you should walk away from this chapter with is
     + how to use /semi-structured data/ for *interchange*

     + how to *access* /semi-structured data/ via Scala's XML support

* DONE 29 Modular Programming Using Objects - 659 - =Re-READ=
  CLOSED: [2018-03-19 Mon 19:04]
  -
  - In this chapter, we’ll discuss how you can use Scala's object-oriented
    features to *make a program more modular*:
    1. Show HOW *a simple /singleton object/ can be used as a module*.

    2. Explain how you can use /traits/ and /classes/ as abstractions over
       /modules/.

       These abstractions can be reconfigured into multiple modules, even
       multiple times within the same program.

    3. Show a pragmatic technique for using /traits/ _to *divide* a /module/
       across MULTIPLE files_.

** DONE 29.1 The problem - 660 =Re-Read= =Review=
   CLOSED: [2018-03-19 Mon 02:19]
   - As a program grows in size, it becomes increasingly important to organize it
     in a modular way.
     1. being able to compile different modules that make up the system separate-
        ly helps different teams work independently.

     2. being able to unplug one implementation of a module and plug in another
        is useful,
        because it allows different configurations of a system to be used in
        different contexts, such as unit testing on a developer’s desktop,
        integration testing, staging, and deployment.

   - Any technique that aims to facilitate this kind of modularity needs to
     provide a few essentials.
     1. there should be a module construct that provides a good separation of
        interface and implementation.

     2. there should be a way to replace one module with another that has the
        same interface without changing or recompiling the modules that depend
        on the replaced one. Lastly, there should be a way to wire modules
        together.

        This wiring task can by thought of as configuring the system.

   - One solution is /depedency injection/. =TODO=
     It is a technique supported on the Java platform by frameworks such as
     Spring and Guice.

     We can use this method in Scala.

   - In the remainder of this chapter,
     we'll show HOW to _use objects as modules_ to achieve the desired "in the
     large" modularity *without using an external framework*.

** TODO 29.2 A recipe application - 661
** TODO 29.3 Abstraction - 664
   - Use /abstract classes/

** TODO 29.4 Splitting modules into traits - 667
   - Split /every large abstract class/ to multiple /traits/.

** TODO 29.5 Runtime linking - 670
** TODO 29.6 Tracking module instances - 671
** TODO 29.7 Conclusion - 673
* DONE 30 Object Equality - 674
  CLOSED: [2018-07-19 Thu 18:27]
  Define *object equality* is more tricky than it looks at first glance.

  =From Jian=
  This complexity comes from /subtyping/.
  This is NOT a problem of OOP, but a problem of OOP with /inheritance/.

** DONE 30.1 Equality in Scala - 674
   CLOSED: [2017-11-25 Sat 00:39]
   - As mentioned in Section 11.2, the definition of equality is _DIFFERENT_ in
     Scala and Java. Both of them has *TWO* equality comparison operators, but
     with _DIFFERENT design choice_.

     + Java
       * ~==~ operator ::
         - /natural equality check/ for /value types/
           AND
         - /object identity/ for /reference types/

       * ~equals~ method :: (user-defined) canonical equality for /reference types/.

     + Scala
       * ~==~ operator :: Be reserved for the "natural" equality of each type.
         - For /value types/, ~==~ is value comparison, just like in Java.

         - For /reference types/, ~==~ is the same as ~equals~ in Scala, and you
           can redefine the behavior of ~==~ for new types by overriding the
           ~equals~ /method/.

       * ~eq~ method :: /object identity/, which is NOT used much.

   - Q: Why does Java's design is BAD!?

     A: The more natural symbol, ~==~, *does NOT* always correspond to the natural
        notion of equality.

   - In Scala ~==~ is value comparison, just like in Java.

     For reference types, ~==~ is the same as ~equals~ in Scala.
     You can redefine the behavior of ~==~ of new types by overriding the
     ~equals~ method, which is _always inherited from_ class ~Any~.

     This inherited ~equals~, which takes effect _unless_ overridden, is /object
     identity/, as in the case in Java. So ~equals~ (and with it, ~==~) is by
     default the same as ~eq~, but you can change its behavior by overriding the
     ~equals~ method in the classes you define.

   - It is not possible to override ~==~ directly, as it is defined as a /final
     method/ in class ~Any~.
     #+BEGIN_SRC scala
       // In the class `Any`
       final def == (that: Any): Boolean =
         if (null eq this) {null eq that} else {this equals that}
     #+END_SRC

** DONE 30.2 Writing an equality method - 675
   CLOSED: [2018-07-19 Thu 01:19]
   - footnote:
     All but the _third_ pitfall are described in the context of Java in the
     book, Effective Java Second Edition, by Joshua Bloch.

   - Here are four common pitfalls2 that can cause inconsistent behavior when
     overriding equals:
     1. Defining equals with the wrong signature.

     2. Changing equals without also changing hashCode.

     3. Defining equals in terms of mutable fields.

     4. Failing to define equals as an equivalence relation.

*** DONE Pitfall #1: Defining ~equals~ with the wrong signature - 676
    CLOSED: [2017-11-25 Sat 00:54]
    Consider adding an /equality method/ to the following class of simple points:
    ~class Point(val x: Int, val y: Int)~

    - At the first glance, you may want to /override/ the ~equals~ /method/ with
      the /signature/ ~equals(other: Point): Boolean~.

      *This is utterly WRONG!*

    - The *right* /signature/ is ~equals(other: Any): Boolean~, which is the
      signature of the one defined in the ROOT /class/ ~Any~.

    - If you use the wrong one, ~equals(other: Point): Boolean~, you just write
      an /overloaded/ alternative, *which should NOT exists, and it can make
      people confused*.

      Let's say some examples:

      + If we use the *wrong* /signature/ ~equals(other: Point): Boolean~:
        #+BEGIN_SRC scala
          // An utterly WRONG definition of equals
          def equals(other: Point): Boolean =
            this.x = other.x && this.y == other.y

          val p1, p2 = new Point(1, 2)
          // p1: Point = Point@37d7d90f
          // p2: Point = Point@3beb846d

          val coll = mutable.HashSet(p1)
          // coll: scala.collection.mutable.HashSet[Point] =
          // Set(Point@37d7d90f)

          // Use the `equals` defined above, NOT the one from `Any`, which is
          // WRONG. This is also the reason why this result is not consistent
          // with the `contains` expression below -- the implementation of the
          // `contains` uses `equals` from `Any`.
          p1 equals p2
          // res1: Boolean = true

          coll contains p2
          // res2: Boolean = false
        #+END_SRC
        The result of the last expression is *NOT* what we expect!!!

        The reason is that the ~mutable.HashSet~ is a generics, and it use the
        ~equals~ inherited from ~Any~ to test ~equality~, and ~contains~ exploits
        this ~equals~!

        We can prove that with the ~equals~ from ~Any~, with _not exact_ /static
        type/, the answer is ~false~ -- the same as the ~contains~ reported above!

        #+BEGIN_SRC scala
          val p2a: Any = p2
          // p2a: Any = Point@3beb846d

          // This result of this expression is consistent with the `contains`
          // expression above!
          p1 equals p2a
          // res3: Boolean = false
        #+END_SRC

    - A BETTER definition, but still *NOT perfect*:
      #+BEGIN_SRC scala
        override def equals(other: Any) = other match {
          case that: Point => this.x == that.x && this.y == that.y
          case _ => false
        }
      #+END_SRC

    - A related *pitfall* is to define ~==~ with a *wrong* /signature/.

      As we mentioned the ~==~ in ~Any~ is a /final method/, and you _CANNOT_
      redefine ~def ==(other: Any): Boolean~.

      HOWEVER, if you use a *wrong* /signature/, you just /overload/ ~==~,
      _rather than_ /override/ it, which is allowed.

*** DONE Pitfall #2: Changing ~equals~ without also changing ~hashCode~ - 678
    CLOSED: [2017-11-25 Sat 01:25]
    #+BEGIN_SRC scala
      val p1, p2 = new Point(1, 2)
      // p1: Point = Point@122c1533
      // p2: Point = Point@c23d097

      collection.mutable.HashSet(p1) contains p2
      //// The output is NOT certain: can be `true` or `false`
    #+END_SRC
    - The ~contains~ method of a ~HashSet~ instance will search ~p2~ in the same
      "hash bucket" of ~p1~. The result is ~true~ when ~p1~ and ~p2~ can be put in
      the same "hash bucket".
        However, since ~hashCode~ is *NOT* /overridden/ for ~Point~, ~p1~ and
      ~p2~ have different hash code, and they can be in the _same or different_
      "hash bucket". Then the result can be ~true~ or ~false~.

    - The problem is that the last implementation of ~Point~ _violated the
      contract_ on ~hashCode~ as defined for class ~Any~:
      #+BEGIN_QUOTE
      If two objects are equal according to the equals method, then calling the
      ~hashCode~ method on each of the two objects must produce the same integer
      result.
      #+END_QUOTE

    - footnote:
      The text of ~Any~'s ~hashCode~ contract is inspired by the Javadoc
      documentation of class ~java.lang.Object~.

    - The new implementation (Better but *not* all right):
      #+BEGIN_SRC scala
        class Point(val x: Int, val y: Int) {
          override def hashCode = (x, y).##
          override def equals(other: Any) = other match {
            case that: Point => this.x == that.x && this.y == that.y
            case _ => false
          }
        }
      #+END_SRC
      + This is just ONE of many possible implementations of ~hashCode~.

      + ~##~ method :: a shorthand for computing hash codes that works for
        * primitive values
        * reference types
        * ~null~

        When invoked on a collection or a tuple, it computes a mixed hash that
        is _sensitive to the hash codes of all the elements_ in the collection.

*** DONE Pitfall #3: Defining ~equals~ in terms of mutable fields - 680
    CLOSED: [2017-11-25 Sat 01:35]
    You put an object into a ~HashSet~, this object is then put in a specific
    "hash bucket" according to its hash code. After modifing its mutable fields,
    its hash code is changed. Only a similar to the original hash code object
    will be equality checked in this "hash bucket", a similar to the new hash
    code object will mostly be equality checked in other "hash bucket".

    - Example (bad definition):
      #+BEGIN_SRC scala
        class Point(var x: Int, var y: Int) {  // Problematic
          override def hashCode = (x, y).##

          override def equals(other: Any) = other match {
            case that: Point => this.x == that.x && this.y == that.y
            case _           => false
          }
        }
      #+END_SRC

    - Solution:
      1. /Hash codes/ *shouldn't depend* on /mutable fields/.

      2. _IF_ /hash codes/ depend on /mutable fields/, *try NOT modify them*.

      3. If all the above can be satisfied, try to define your own method to
         check equality *without* /hash code/, for example, use a name like
         ~equalContents~.

*** DONE Pitfall #4: Failing to define ~equals~ as an equivalence relation
    CLOSED: [2018-07-19 Thu 01:19]
    - The /contract/ of the ~equals~ /method/ in ~scala.Any~ specifies that
      ~equals~ *must implement* _an equivalence relation on non-null objects_:
      + It is /reflexive/:
        For _ANY non-null value_ ~x~, the expression ~x.equals(x)~ should return
        ~true~.

      + It is /symmetric/:
        For _ANY non-null values_ ~x~ and ~y~, ~x.equals(y)~ should return ~true~
        iff ~y.equals(x)~ returns ~true~.

      + It is /transitive/:
        For _ANY non-null values_ ~x~, ~y~, and ~z~, if ~x.equals(y)~ returns ~true~
        and ~y.equals(z)~ returns ~true~, then ~x.equals(z)~ should return ~true~.

      + It is /consistent/:
        For _ANY non-null values_ ~x~ and ~y~, multiple invocations of ~x.equals(y)~
        should _consistently_ return ~true~ or _consistently_ return ~false~,
        provided no information used in ~equals~ comparisons on the objects is
        modified.

      + For _ANY non-null value_ ~x~, ~x.equals(null)~ should return ~false~.

    - The definition of ~equals~ developed for /class/ ~Point~ _up to now_ satisfies
      the contract for ~equals~.

      However, *things become more complicated once /subclasses/ are considered.*

    - Say there is a /subclass/ ~ColoredPoint~ of ~Point~ that adds a field ~color~
      of type ~Color~. Assume ~Color~ is defined as an /enumeration/:
      #+BEGIN_SRC scala
        object Color extends Enumeration {
          val Red, Orange, Yellow, Green, Blue, Indigo, Violet = Value
        }

        class ColoredPoint(x: Int, y: Int, val color: Color.Value)
            extends Point(x, y) { // Problem: equals not symmetric
          override def equals(other: Any) = other match {
            case that: ColoredPoint =>
              this.color == that.color && super.equals(that)
            case _ => false
          }
        }
      #+END_SRC
      + The above ~equals~ /method/ is *WRONG*.

        If you use ~equals~ to compare ~Point~ and ~ColoredPoint~, the /symmetric/
        contract will be violated!
        #+BEGIN_SRC scala
          val p = new Point(1, 2)
          // p: Point = Point@5428bd62

          val cp = new ColoredPoint(1, 2, Color.Red)
          // cp: ColoredPoint = ColoredPoint@5428bd62

          p equals cp
          // res9: Boolean = true

          cp equals p
          // res10: Boolean = false
        #+END_SRC

      + Now you need to make a decision:
        Modify the ~equals~ /method/ to make it *more general* OR *stricter*.

        - Try the *more general* way --
          if the corresponding parts are equal, not matter what exact class they
          are, they are equal.

          This way _violate_ the /transitive/ contract. It's a dead end!!!

        - Try the *stricter* way --
          Different /run time classes/ values should always be inequal!!!

          *This way _satisfies_ all the rules.*

    - For our current version of ~equals~, ~new Point(1, 2)~ does NOT equal
      to ~new Point(1, 1) { override val y = 2 }~. This is NOT reasonable!

      We know the reason, the second one is an /anonymous type/ which is a
      /subclass/ of the ~Point~ type.

      *There should be an _EXCEPTION_ that, in this case, two value of different
      classes should be equal* -- the /anonymous type/, which is a subtype of a
      /class/.

      + We introduce the ~def canEqual(other: Any): Boolean~ /method/.

        If in a subtype /override/ this /method/, it and its supertypes cannot
        be equal (you can /override/ it in a way violate this, but in the real
        world, I can guess a reason that we should do this!).

        Now the ~equals~'s of ~Point~ and ~ColoredPoint~:
        #+BEGIN_SRC scala
          class Point(val x: Int, val y: Int) {
            override def hashCode = (x, y).##
            override def equals(other: Any) = other match {
              case that: Point =>
                (that canEqual this) &&
                  (this.x == that.x) && (this.y == that.y)
              case _ =>
                false
            }
            def canEqual(other: Any) = other.isInstanceOf[Point]
          }


          class ColoredPoint(x: Int, y: Int, val color: Color.Value)
              extends Point(x, y) {
            override def hashCode = (super.hashCode, color).##
            override def equals(other: Any) = other match {
              case that: ColoredPoint =>
                (that canEqual this) &&
                  super.equals(that) && this.color == that.color
              case _ =>
                false
            }
            override def canEqual(other: Any) =
              other.isInstanceOf[ColoredPoint]
          }
        #+END_SRC

        In this way, since the ~new Point(1, 1) { override val y = 2 }~ does NOT
        /override/ the ~canEqual~ /method/, it is equal to ~Point(1, 2)~.

    - People may think this ~canEqual~ /method/ _violate_ the /Liskov Substitution
      Principle/, but this _wrong_. *There is NO violation*.
      - /Liskov Substitution Principle/ requires that a /subclass value/ can be used
        to replace a /superclass value/, but it doesn't require they have the
        same behavior!
      - =TODO= =DETAILS=

** DONE 30.3 Defining equality for parameterized types - 688
   CLOSED: [2017-11-25 Sat 01:50]
   When /classes/ are parameterized, this scheme needs to be adapted a little
   bit. *This is special due to /type erasure/.*

   - Example code with parameterized types:
     #+BEGIN_SRC scala


            trait Tree[+T] {
         def elem: T
         def left: Tree[T]
         def right: Tree[T]
       }

       object EmptyTree extends Tree[Nothing] {
         def elem =
           throw new NoSuchElementException("EmptyTree.elem")
         def left =
           throw new NoSuchElementException("EmptyTree.left")
         def right =
           throw new NoSuchElementException("EmptyTree.right")
       }

       class Branch[+T](
         val elem: T,
         val left: Tree[T],
         val right: Tree[T]
       ) extends Tree[T]
     #+END_SRC

   - No need to implement ~equals~ for ~Tree~ -- we assume ~equals~'s will be
     implemented separately for _EACH implementation_ of the /abstract class/.

     + For ~EmptyTree~:
       No overridden ~equals~, ~hashCode~, and ~canEqual~ is required.

       The default ~equals~ and ~hashCode~ inherited from ~AnyRef~ work just fine.
         After all, an ~EmptyTree~ is ONLY equal to itself, so equality should be
       /reference equality/, which is what's inherited from ~AnyRef~.

   - Define ~equals~
     #+BEGIN_SRC scala
       class Branch[T](
         val elem: T,
         val left: Tree[T],
         val right: Tree[T]
       ) extends Tree[T] {
         override def equals(other: Any) = other match {
           case that: Branch[T] => this.elem == that.elem &&
               this.left == that.left &&
               this.right == that.right
           case _ => false
         }
       }
     #+END_SRC

     This code will issue an *unchecked warnings*.
     Use ~fsc -unchecked Tree.scala~ to check, and you'll get a warning message:
     #+BEGIN_QUOTE
     Tree.scala
     Tree.scala:14: warning: non variable typeargument T in type
     pattern is unchecked since it is eliminated by erasure
         case that: Branch[T] => this.elem == that.elem &&
     #+END_QUOTE

     This is due to /type erasure/.

   - How to deal with this *unchecked warning*?
     + Fix it

         ~case that: Branch[T]~ to
       * ~case that: Branch[t]~ =TODO= details
         OR
       * ~case that: Branch[_]~

     + Rationale:
       You need NOT necessarily check that two ~Branch~'es have the same element
       types when comparing them -- it's quite possible that two ~Branch~'es with
       _different element types_ are equal, as long as their fields are the same.
       #+BEGIN_SRC scala
         val b1 = new Branch[List[String]](Nil, EmptyTree, EmptyTree)
         // b1: Branch[List[String]] = Branch@9d5fa4f

         val b2 = new Branch[List[Int]](Nil, EmptyTree, EmptyTree)
         // b2: Branch[List[Int]] = Branch@56cdfc29

         b1 == b2
         // res19: Boolean = true
       #+END_SRC

       * *CONTROVERSY*: Should ~b1 == b2~ _true_ or _false_?
         - In the /type erasure model/ (JVM - Scala):
           /type parameters/ are present ONLY at compile-time, and it's natural to
           consider the two ~Branch~ values ~b1~ and ~b2~ to be equal at run
           time if all fields are equal.

         - If in a model that the /type parameters/ are considered form part of
           an object's value, it's equally natural to consider them different.

   - Override ~hashCode~ for ~Branch~ as usual
     ~override def hashCode: Int = (elem, left, right).##~

   - Override ~canEqual~ for ~Branch~:
     #+BEGIN_SRC scala
       def canEqual(other: Any) = other match {
         case that: Branch[_] => true
         case _               => false
       }

       // OR

       def canEqual(other: Any) = otherisInstanceOf[Branch[_]]
     #+END_SRC
     How is it possible to leave some parts of it (the ~_~ in the second form
     above) undefined? =TODO= =TODO= =TODO= The /type parameter/, rather than
     /type pattern/, ~_~ is explained in the next chapter.

   - The final version:
     #+BEGIN_SRC scala
       class Branch[T](
         val elem: T,
         val left: Tree[T],
         val right: Tree[T]
       ) extends Tree[T] {
         override def equals(other: Any) = other match {
           case that: Branch[_] => (that canEqual this) &&
                                 this.elem == that.elem &&
                                 this.left == that.left &&
                                 this.right == that.right
           case _ => false
         }

         def canEqual(other: Any) = other.isInstanceOf[Branch[_]]

         override def hashCode: Int = (elem, left, right).##
       }
     #+END_SRC

** DONE 30.4 Recipes for ~equals~ and ~hashCode~ - 692
   CLOSED: [2018-07-19 Thu 18:27]
   In this section, we'll provide *step-by-step recipes for creating ~equals~ and
   ~hashCode~ /methods/ that should suffice for _most situations_.*

   As an illustration, we'll use the /methods/ of /class/ ~Rational~, shown in
   Listing 30.5. This is a *modified version* of Listing 6.5 on page 151:
   - Remove mathematical operators methods that are not related to this _equality
     check_ topic.

   - Enhance the ~toString~ /method/.

   - Code:
     #+BEGIN_SRC scala
       class Rational(n: Int, d: Int) {
         require(d != 0)

         private val g = gcd(n.abs, d.abs)
         val numer = (if (d < 0) -n else n) / g
         val denom = d.abs / g

         private def gcd(a: Int, b: Int): Int =
           if (b == 0) a else gcd(b, a % b)

         override def equals(other: Any): Boolean =
           other match {
             case that: Rational =>
               (that canEqual this) &&
                 numer == that.numer &&
                 denom == that.denom
             case _ => false
           }

         def canEqual(other: Any): Boolean =
           other.isInstanceOf[Rational]

         override def hashCode: Int = (numer, denom).##

         override def toString =
           if (denom == 1) numer.toString else numer + "/" + denom
       }
     #+END_SRC

*** DONE Recipe for ~equals~ - 693
    CLOSED: [2018-07-19 Thu 13:50]
    1. To override equals in a non-final class, create a canEqual method.

       + If the inherited definition of equals is from ~AnyRef~ (that is, ~equals~
         was not redefined higher up in the class hierarchy), the definition of
         ~canEqual~ should be *new*;

       + otherwise, it will /override/ a previous definition of a method with the
         same name.

       + ONLY Exception:
         for /final classes/ that redefine the ~equals~ method inherited from
         ~AnyRef~.

         For them the /subclass/ anomalies described in Section 30.2 _cannot arise_;
         consequently they _need not_ define ~canEqual~.

         The type of object passed to ~canEqual~ should be ~Any~:
         ~def canEqual(other: Any): Boolean =~

    2. The ~canEqual~ method should yield ~true~ if the argument object is an instance
       of the *CURRENT class* (i.e., the /class/ in which ~canEqual~ is defined), and
       ~false~ otherwise:
       ~other.isInstanceOf[Rational]~

    3. In the ~equals~ method, make sure you declare the type of the object
       passed as an ~Any~:
       ~override def equals(other: Any): Boolean =~

    4. Write the body of the ~equals~ method _as a single ~match~ expression_.
       The selector of the ~match~ should be _the object passed to ~equals~:_
       #+BEGIN_SRC scala
         other match {
           // ...
         }
       #+END_SRC

    5. The ~match~ expression should have *two* ~case~'s.

       The first ~case~ should declare a typed pattern for the type of the
       /class/ on which you're defining the ~equals~ method:
       ~case that: Rational =>~

    6. In the body of this ~case~, write *an expression that logical-ands* together
       the *individual expressions that must be ~true~ for the objects to be equal*.

       + If the ~equals~ /method/ you are /overriding/ is *NOT* that of ~AnyRef~,
         you will most likely want to include an invocation of the /superclass/'s
         ~equals~ /method/: ~super.equals(that) &&~

       + If you are defining ~equals~ for a /class/ that first introduced ~canEqual~,
         you should invoke ~canEqual~ on the argument to the _equality method_,
         passing ~this~ as the argument: ~(that canEqual this) &&~

       + Overriding redefinitions of ~equals~ *should also include* the ~canEqual~
         invocation, *unless they contain a call to ~super.equals~.* In the latter
         case, the ~canEqual~ test will already be done by the _superclass call_.

       + Lastly, _for *EACH* /field/ relevant to equality_, verify that the field
         in this object is equal to the corresponding field in the passed object:
         #+BEGIN_SRC scala
           numer == that.numer &&
           denom == that.denom
         #+END_SRC

    7. For the *second* ~case~, use a /wildcard pattern/ that yields ~false~:
       ~case _ => false~

*** DONE Recipe for ~hashCode~ - 695
    CLOSED: [2018-07-19 Thu 18:27]
    - If the ~equals~ method does _NOT_ invokes ~super.equals(that)~ as part of
      its calculation, you should create a tuple that include all the fields of
      this class, and then use the ~##~ /method/ to get the hash code.

    - If the ~equals~ method invokes ~super.equals(that)~ as part of its calcula-
      tion, you should start your ~hashCode~ calculation with an invocation of
      ~super.hashCode~. For example,
      #+BEGIN_SRC scala
        override def hashCode: Int = (super.hashCode, numer, denom).##
      #+END_SRC

    - Keep in mind as you write ~hashCode~ /methods/ using this approach is that
      your hash code will only be as good as the hash codes you build out of it
      (call the ~hashCode~ on the relevant fields)

    - Sometime you may need to do something extra besides just calling ~hashCode~
      on the field to get a useful hash code for that field.

      For example, if one of your fields is a collection,
      + you probably want a hash code for that field that is based on all the
        elements contained in the collection.

      + If the fields is a ~Vector~, ~List~, ~Set~, ~Map~, or /tuple/, you can
        simply include it in the list of items you are hashing over, because
        ~equals~ and ~hashCode~ are /overridden/ in those /classes/ to take into
        account the contained elements.

      + ~Array~'s are special, which do not take elements into account when
        calculating a /hash code/.
          Thus for an array, you should treat each element of the array like an
        individual field of your object, calling ~##~ on each element explicitly
        or passing the array to one of the ~hashCode~ /methods/ in singleton
        object ~java.util.Arrays~.

    - If you find that a particular /hash code/ calculation is harming the performance
      of your program, you can consider *caching* the /hash code/.
        This is especially useful for /immutable/ objects, their /hash code/ can
      be calculated once when the object is created, and save it.

      In this way, you will /override/ ~hashCode~ with a ~val~ instead of a ~def~.

** DONE 30.5 Conclusion - 697
   CLOSED: [2018-07-19 Thu 00:54]
   - In retrospect, defining a correct implementation of ~equals~ has been
     *surprisingly subtle*.
     + You must be careful about the /type signature/;

     + you must /override/ ~hashCode~;

     + you should *avoid dependencies* on /mutable state/;

     + you should implement and use a ~canEqual~ /method/
       _if your /class/ is non-~final~._

   - Given how difficult it is to implement a correct equality method,
     you might prefer to define your classes of comparable objects as /case
     classes/.

     That way, the Scala compiler will add ~equals~ and ~hashCode~ /methods/
     with the right properties *automatically*.

* DONE 31 Combining Scala and Java - 698
  CLOSED: [2018-11-25 Sun 15:01]
  This chapter describes two aspects of combining Java and Scala:

  + it discusses *how Scala is translated to Java*, which is especially important
    if you _call Scala code from Java_.

  + it discusses *the use of Java annotations in Scala*, an important feature if
    you want to use Scala with an existing Java framework.

** DONE 31.1 Using Scala from Java - 698
   CLOSED: [2018-11-25 Sun 15:00]
   1. _Most of the time_ you can think of Scala _at the source code level_.

   2. However,
      you will have _a richer understanding_ of how the system works if you know
      something about its *translation*.

   3. Further,
      if you call Scala code from Java,
      you will _need to know_ *what Scala code looks like from a Java point of
      view*.

*** DONE General rules - 698
    CLOSED: [2018-02-06 Tue 22:46]
    - Scala is implemented as a translation to standard Java bytecodes.
      *As much as possible*, Scala features map directly onto the equivalent
      Java features.

    - For example,
      + Scala classes
      + Scala methods
      + Scala strings
      + Scala exceptions
      are *all compiled to the _SAME_ in Java bytecode as their Java
      counterparts*.

    - To make this happen required an occasional hard choice in the design of
      Scala.

      For example,  =TODO= =???= =WHY=
      1. For Scala *resolve overloaded methods at run time, using run-time types,
         rather than at compile time* is a good design choice. =TODO= =???= =WHY=

      2. However,
         such a design would *break* with Java's, making it much trickier to mesh
         Java and Scala.

      3. In this case, *Scala stays with Java’s overloading resolution*, and thus
         Scala methods and method calls can map directly to Java methods and
         method calls.

    - Scala has its own design for other features.

      For example,
      + /traits/ have _NO equivalent in Java_.

      + Similarly, while both Scala and Java have /generic types/, the details of
        the two systems clash. =HOW=

      For language features like these, Scala code cannot be mapped directly to
      a Java construct, so it must be encoded using some combination of the
      structures Java does have.

      For these features that are mapped indirectly, the encoding is not fixed.

      There is an ongoing effort to make the translations as simple as possible
      so, by the time you read this, some details may be different than at the
      time of writing. You can find out what translation your current Scala
      compiler uses by examining the “.class” files with tools like *javap*. Those
      are the general rules. Consider now some special cases.

*** DONE Value types - 699
    CLOSED: [2018-02-06 Tue 22:46]
    =From Jian= Review this concept (in Appendix A)
    Use ~Int~ as example,

    - _Whenever possible_,
      the compiler translates a Scala ~Int~ to a Java ~int~
      _to get better performance._

    - Translate to ~java.lang.Integer~
      when the compiler is not sure if ~int~ is applicable.
        For example, even if a particular ~List[Any]~ hold only ~Int~'s, the
      compiler has to use ~java.lang.Integer~ when doing translation.

    - =TODO= =RE-READ=
      footnote:
      The implementation of /value types/ was discussed in details in Section 11.2

*** DONE Singleton objects - 699 - =Outdated Info= =Re-Read=
    CLOSED: [2018-11-25 Sun 15:00]
    =From Jian=
    Some information of this section is outdated!!!
    Update required!

    *Java has NO EXACT EQUIVALENT to a singleton object.*

    - The Scala translation of /singleton objects/ uses a combination of
      + /static methods/
      + /instance methods/

    - There are two types of /singleton object/:
      + "standalone" /singleton object/;
      + "companion" /singleton object/;

      _NO matter which case, *TWO* files will be generated!_

      Suppose the name of this /singleton object/ in the source code is ~ABC~,
      and the generated =.class= files are: =ABC.class= and =ABC$.class=.

    - "standalone" /singleton object/;
      #+BEGIN_SRC scala
        object App {
          def main(args: Array[String]): Unit = {
            println("Hello, world!")
          }
        }
      #+END_SRC

      is translated to

      #+BEGIN_SRC java
        // Use `javap -c -p` command

        // Compiled from "App.scala"
        public final class App {
            public static void main(java.lang.String[]);
            // Code:
            // 0: getstatic     #17                 // Field App$.MODULE$:LApp$;
            // 3: aload_0
            // 4: invokevirtual #19                 // Method App$.main:([Ljava/lang/String;)V
            // 7: return
        }

        // Compiled from "App.scala"
        public final class App$ {
            public static App$ MODULE$;

            public static {};
            // Code:
            // 0: new           #2                  // class App$
            // 3: invokespecial #12                 // Method "<init>":()V
            // 6: return

            public void main(java.lang.String[]);
            // Code:
            // 0: getstatic     #20                 // Field scala/Predef$.MODULE$:Lscala/Predef$;
            // 3: ldc           #22                 // String Hello, world!
            // 5: invokevirtual #26                 // Method scala/Predef$.println:(Ljava/lang/Object;)V
            // 8: return

            private App$();
            // Code:
            // 0: aload_0
            // 1: invokespecial #29                 // Method java/lang/Object."<init>":()V
            // 4: aload_0
            // 5: putstatic     #31                 // Field MODULE$:LApp$;
            // 8: return
        }
      #+END_SRC

    - "companion" /singleton object/;
      #+BEGIN_SRC scala
        class App {
          val x: Int = 3

          def addX(y: Int): Int =
            x + y
        }

        object App {
          def main(args: Array[String]): Unit = {
            println("Hello, world!")
          }
        }
      #+END_SRC

      is translated to

      #+BEGIN_SRC java
        // Compiled from "App.scala"
        public class App {
            private final int x;

            public static void main(java.lang.String[]);
            // Code:
            // 0: getstatic     #19                 // Field App$.MODULE$:LApp$;
            // 3: aload_0
            // 4: invokevirtual #21                 // Method App$.main:([Ljava/lang/String;)V
            // 7: return

            public int x();
            // Code:
            // 0: aload_0
            // 1: getfield      #24                 // Field x:I
            // 4: ireturn

            public int addX(int);
            // Code:
            // 0: aload_0
            // 1: invokevirtual #31                 // Method x:()I
            // 4: iload_1
            // 5: iadd
            // 6: ireturn

            public App();
            // Code:
            // 0: aload_0
            // 1: invokespecial #35                 // Method java/lang/Object."<init>":()V
            // 4: aload_0
            // 5: iconst_3
            // 6: putfield      #24                 // Field x:I
            // 9: return
        }


        // Compiled from "App.scala"
        public final class App$ {
            public static App$ MODULE$;

            public static {};
            // Code:
            // 0: new           #2                  // class App$
            // 3: invokespecial #12                 // Method "<init>":()V
            // 6: return

            public void main(java.lang.String[]);
            // Code:
            // 0: getstatic     #20                 // Field scala/Predef$.MODULE$:Lscala/Predef$;
            // 3: ldc           #22                 // String Hello, world!
            // 5: invokevirtual #26                 // Method scala/Predef$.println:(Ljava/lang/Object;)V
            // 8: return

            private App$();
            // Code:
            // 0: aload_0
            // 1: invokespecial #29                 // Method java/lang/Object."<init>":()V
            // 4: aload_0
            // 5: putstatic     #31                 // Field MODULE$:LApp$;
            // 8: return
        }
      #+END_SRC

    - Compare the code above, you'll notice if you did have a /class/ named ~App~,
      Scalac would create a corresponding /Java ~App~ class/ to hold the
      /members/ of the ~App~ /class/ you defined.
        In that case it would NOT add any /forwarding methods/ for the same-named
      singleton object, and Java code would have to access the singleton *via*
      the ~MODULE$~ field.

    - =Comment from Jian=
      The book use an outdated version of Scala in this section!!!
      From the result of ~javap~, we know it's Scala 2.9-.

      - From Scala 2.10 on, ~ScalaObject~ was eradicated, and th so does its member
        ~public int $tag()~

      - ~MODULE$~ was ~final~, but not ~final~ anymore.
        =from Jian= WHY??? I think ~final~ is more reasonable!!!

*** DONE Traits as interfaces - 701 =Learn MORE!=
    CLOSED: [2018-02-06 Tue 22:46]
    - Compiling any trait creates a Java interface of the same name. This
      interface is usable as a Java type, and it lets you call methods on Scala
      objects through variables of that type.

    - Implementing a trait in Java is another story.
      In the general case it is not practical; however, _one special case is
      important_:
        When all the methods in a /trait/ are /abstract/, this /trait/ can be
      translated directly to a /Java interface/ with no other code to worry
      about. You actually _create a /Java interface/ in Scala syntax_.

** DONE 31.2 Annotations - 701
   CLOSED: [2018-02-06 Tue 22:45]
   - Scala's general /annotations/ system is discussed in Chapter 27.

   - _This section discusses Java-specific aspects of /annotations/._

*** DONE Additional effects from standard annotations
    CLOSED: [2018-02-06 Tue 21:38]
    - Several annotations cause the compiler to emit extra information when
      targeting the Java platform. When the compiler sees such an /annotation/,
      1. it processes this /annotation/ according to the general Scala rules
      2. then it does something extra for Java

    - Deprecation :: =TODO=

    - Volatile fields :: =TODO=

    - Serialization :: =TODO=

*** DONE Exceptions thrown - 702
    CLOSED: [2018-02-06 Tue 21:38]
    - Scala has NO EQUIVALENT to Java's ~throws~ declarations on /methods/:
      Scala does NOT check that /thrown exceptions/ are caught.
      *footnote* The Java compiler checks the /thrown exceptions/,
                 but *not* the Java bytecode verifier -- /thrown exceptions/ is
                 *not* supported in the Java bytecode level.

    - *Rationale* (why Scala omits this feature)
      =TODO=

    - Sometimes when interfacing to Java,
      however, you may need to write Scala code that has _Java-friendly_
      /annotations/ describing the /thrown exceptions/ if from the Java point of
      view.

      Sometimes, this is mandatory. For example, each /method/ in an RMI remote
      interface is required to mention ~java.io.RemoteException~ in its ~throws~
      clause.

      Use Scala's ~@thorws~ /annotation/ to satisfy this kind of requirement.
      For example,
      #+BEGIN_SRC scala
        import java.io._

        class Reader(fname: String) {
          private val in = new BufferedReader(new FileReader(fname))

          @throws(classOf[IOException])
          def read() = in.read()
        }
      #+END_SRC

      You can use ~javap~ to check its =.class= file:
      #+BEGIN_SRC java
        // Compiled from "Reader.scala"
        public class Reader {
                public Reader(java.lang.String);
                public int read() throws java.io.IOException;
        }
      #+END_SRC

*** DONE Java annotations - 703
    CLOSED: [2018-02-06 Tue 21:38]
    - Existing annotations from Java frameworks can be used directly in Scala
      code.

      Any Java framework will see the annotations you write just as if you were
      writing in Java.

    - For example,
      JUnit use the ~@Test~ to mark which part of the code is a /test/.

      An example of using JUnit in Scala:
      #+BEGIN_SRC scala
        import org.junit.Test
        import org.junit.Assert.assertEquals

        class SetTest {

          @Test
          def testMultiAdd = {
            val set = Set.empty[Int] + 1 + 2 + 3 + 1 + 2 + 3
            assertEquals(3, set.size)
          }
        }
      #+END_SRC

       Run this test:
       #+BEGIN_SRC bash
         $ scala -cp junit4.3.1.jar:. org.junit.runner.JUnitCore SetTest
         ## JUnit version 4.3.1
         ## .
         ## Time: 0.023
         ##
         ## OK (1 test)
       #+END_SRC

*** DONE Writing your own annotations - 704
    CLOSED: [2018-02-06 Tue 22:45]
    - To make an /annotation/ that _is VISIBLE to /Java reflection/,_ you MUST
      + use Java notation
        and
      + compile it with ~javac~.

      For this use case, _writing the /annotation/ *in Scala* does *NOT* seem
      helpful_,

      *CONCLUSION*: so the standard compiler does _NOT support_ it.

    - Two reason for no support:
      + Inevitably non-fully support

      + Scala will probably one day have its own reflection,
        then you want to access /Scala annotations/ with /Scala reflection/.

    - Now we know current limitation.
      We will show an example of _call Java reflection from Scala_ to _get info
      from Scala code_ that use /Java annotaion/.
      + /Java annotation/
        #+BEGIN_SRC java
          // Compile this code with `javac`
          // Define annotation
          import java.lang.annotation.*; // This is Java
          @Retention(RetentionPolicy.RUNTIME)
          @Target(ElementType.METHOD)
          public @interface Ignore { }
        #+END_SRC
        =TODO=
        I don't quite understand how to define /Java annotaion/.
        Try to understand this part in the future.

      + Tests code in =Tests.scala=
        #+BEGIN_SRC scala
          object Tests {
            @Ignore
            def testData = List(0, 1, -1, 5, -5)

            def test1 = {
              assert(testDate == (testData.head :: testData.tail))
            }

            def test2 = {
              assert(testDate.contains(testData.head))
            }
          }
        #+END_SRC

      + The call-Java-reflection Scala code.
        #+BEGIN_SRC scala
          object Main extends App {
            for {
              method <- Tests.getClass.getMethods
              if method.getName.startsWith("test")
              if method.getAnnotation(classOf[Ignore]) == null
            } {
              println("found a test method: " + method)
            }
          }
        #+END_SRC

      Summary:
      #+BEGIN_SRC bash
        # $
        javac Ignore.java

        #$
        scalac Tests.scala

        #$
        scalac FindTests.scala

        #$
        scala FindTests
        # found a test method: public void Tests$.test2()
        # found a test method: public void Tests$.test1()
      #+END_SRC
      (you can see the /methods/ is defined in ~Tests~ /object/ source code, and
       when they are visited by /Java reflection/, the display name is ~Tests$~,
       which is explained in a former sectoin of this chapter)

    - Take care:
      When you use /Java annotatoins/ you have to work within their limitations.
      For example, you can *only use constants*, NOT expressions, in the
      /arguments to annotations/. This means ~@serial(1234)~ is legal, but
      ~@serial(x * 2)~ is _NOT legal_.

** DONE 31.3 Wildcard types - 706
   CLOSED: [2018-02-07 Wed 00:31]
   *ALL* /Java types/ have a Scala equivalent.
   This is necessary so that Scala code can access any legal Java class.

   - Most of the time the translation is straightforward.

   - For some cases, though,
     the /Scala types/ you have seen so far are not enough.

     For /Java wildcard types/ like ~Iterator<?>~ or ~Iterator<? extends
     Component>~ and /Java raw types/ like ~Iterator~,
     Scala uses an extra kind of type also called a /wildcard type/.

   - /Scala wildcard types/ are *written* using /placeholder syntax/.
     + ~Iterator[_]~ represents ~Iterator~ where the element type is NOT known.
     + ~Iterator[_ <: Component]~ represents ~Iterator<? extends Component>~.

   - How to *use*:
     + What you see when you use?
       Here is an example:
       #+BEGIN_SRC java
         // This is a Java class with wildcards
         public class Wild {
           public Collection<?> contents() {
             Collection<String> stuff = new Vector<String>();
             stuff.add("a");
             stuff.add("b");
             stuff.add("see");
             return stuff;
           }
         }
       #+END_SRC

       #+BEGIN_SRC scala
         // scala>
         val contents = (new Wild).contents
         // contents : java.util.Collection[_] = [a, b, see]
       #+END_SRC

     + For simple usage, not type parameter required.
       #+BEGIN_SRC scala
         // scala>
         contents.size
         res0: Int = 3
       #+END_SRC

     + More complicated cases:
       #+BEGIN_SRC scala
         import scala.collection.mutable
         val iter = (new Wild).contents.iterator
         val set = mutable.Set.empty[?]  // Illegal code. What type goes here?
         while (iter.hasMore) {
           set += iter.next()
         }
       #+END_SRC
       What should be in the ~?~ place?
       * There is *no way to name the type of elements* in the Java collection,
         so you *cannot* write down a satisfactory type for set.

       * Two tricks to work around:
         1. When *passing a wildcard type* into a /method/,
            give a /parameter/ to the /method/ for the placeholder.
            You now have a name for the type that you can use as many times as
            you like.

         2. About *returning*:
            INSTEAD OF returning wildcard type from a method,
            *return an object that has /abstract members/ for each of the
            placeholder types*.

            =TODO= =REVIEW=
            (See Chapter 20 for information on /abstract members/.)

       * The corrected code:
         #+BEGIN_SRC scala
           import scala.collection.mutable
           import java.util.Collection

           abstract class SetAndType {
             type Elem  // abstract members
             val set: mutable.Set[Elem]
           }

           // give the wildcard type a placeholder name
           def javaSet2ScalaSet[T](jset: Collection[T]): SetAndType = {
             val sset = mutable.Set.empty[T]  // now T can be named!

             val iter = jset.iterator
             while (iter.hasNext)
               sset += iter.next()
             return new SetAndType {
               type Elem = T
               val set = sset
             }
           }
         #+END_SRC

   - From the _more complicated example above_, we see why Scala code *normally
     does NOT use /wildcard types/*:
     To do anything sophisticated with them, you TEND TO *convert them to use
     /abstract members/.* So you may as well use /abstract members/ to begin
     with.

** DONE 31.4 Compiling Scala and Java together - 709
   CLOSED: [2018-02-06 Tue 23:32]
   - For the most simplest cases (=From Jian= what I usually meet):
     Scala code depends on Java code or vise versa.
     *Compile the dependencies first!*

   - For more complicated cases:
     Scala code and Java code mutually refer each other.

     To support such builds, Scala allows compiling against /Java source code/
     as well as /Java class files/. The Scala compiler won't compile those Java
     (source) files, but it will scan them to see that they contain.

     =Comment from Jian= Scala is created later than Java, and its design ideas
     include using Java code. The Java design idea dose NOT have any plan about
     using Scala. Using compiled Scala code in Java is an fact, not a rule it
     must follow. Therefore, it must be Scala that support this feature, NOT Java

     The steps:
     1. _Compile the Scala code_ using /Java source files/;
     2. _Compile the Java code_ using /Scala class files/.

   - Example:
     #+BEGIN_SRC bash
       #$
       scalac -d bin InventoryAnalysis.scala InventoryItem.java Inventory.java

       #$
       javac -cp bin -d bin Inventory.java InventoryItem.java InventoryManagement.java

       #$
       scala -cp bin InventoryManagement
       # Most expensive item = sprocket($4.99)
     #+END_SRC

** DONE 31.5 Java 8 integration in Scala 2.12 - 709
   CLOSED: [2018-02-07 Wed 02:10]
   - Java 8 added a few IMPROVEMENTS to
     + _the Java language_
       and
     + bytecodes

     Scala takes advantage of in its 2.12 release, this version *requires* Java 8

   - By exploiting new features of Java 8,
     the Scala 2.12 compiler can
     + generate *smaller* /class and jar files/
       and
     + improve the *binary compatibility* of /traits/.

*** DONE Lambda expressions and "SAM" types - 710
    CLOSED: [2018-02-07 Wed 01:14]
    - Before Scala 2.12 (before Java 8's support to /lambda expressions/), in the
      /SAM types/ position,
      + you CANNOT directly pass a /Scala function literal/
      + if you want to write it concisely, you need to write an /implicit
        conversion (Java code to Scala code)/ first!
        =TODO= =REVIEW= Section 21.1 =IMPORTANT=

      You no longer need to do this after !

    - Example (no /implict conversion/ -- after Scala 2.12):
      + Define in Java
        #+BEGIN_SRC java
          JButton button = new JButton();  // This is Java 8
          button.addActionListener(event -> System.out.println("pressed!"))
        #+END_SRC

      + Use in Scala
        #+BEGIN_SRC scala
          val button = new JButton
          button.addActionListener(_ => println("pressed!"))
        #+END_SRC

    - This will work with any SAM in Scala 2.12. Even if the SAM type is defined
      in Scala. For example,
      #+BEGIN_SRC scala
        trait Increaser {
          def increase(i: Int): Int
        }

        def increaseOne(increaser: Increaser): Int =
          increaser.increase(1)
      #+END_SRC

      + If NO (Scala code to Scala code) /implict conversion/, this code can work
        old versions of Scala
        #+BEGIN_SRC scala
          increaseOne(
            new Increaser {
              def increase(i: Int): Int = i + 7
            }
          )

          // res0: Int = 8
        #+END_SRC

      + Scala 2.12+, we can write it in a more concise way:
        #+BEGIN_SRC scala
          increaseOne(_ + 7)
          // res1: Int = 8
        #+END_SRC

*** DONE Using Java 8 Streams from Scala 2.12 - 712
    CLOSED: [2018-02-07 Wed 02:09]
    - _NOTE_
      *ONLY* /function literals/ will be adapted to /SAM types/,
      *NOT* arbitrary expressions that have a /function type/.

    - For example,
      + Right
        1. Use anonymous instance
           #+BEGIN_SRC scala
             // scala>
             import java.util.function.IntUnaryOperator

             // scala>
             import java.util.Arrays

             // scala>
             val stream = Arrays.stream(Array(1, 2, 3))

             // scala>
             stream.map(
               new IntUnaryOperator {
                 def applyAsInt(i: Int): Int = i + 1
               }
             ).toArray
             // res3: Array[Int] = Array(2, 3, 4)
           #+END_SRC

        2. Use a /funtion literal/
           #+BEGIN_SRC scala
             // scala>
             val stream = Arrays.stream(Array(1, 2, 3))
             // stream can only be used once, you must create a new one to use

             // scala>
             stream.map(_ + 1).toArray
             // res4: Array[Int] = Array(2, 3, 4)
           #+END_SRC

      + Wrong
        #+BEGIN_SRC scala
          // scala>
          val f = (i: Int) => i + 1
          // f: Int => Int = ...

          // scala>
          val stream = Arrays.stream(Array(1, 2, 3))

          // scala>
          stream.map(f).toArray
          // <console>:16: error: type mismatch;
          //  found   : Int => Int
          //  required: java.util.function.IntUnaryOperator
          //        stream.map(f).toArray
          //                   ^
        #+END_SRC

      + Correction 1

        =From Jian= More applicable -- no need to change the definition, though
                    not that concise)

        #+BEGIN_SRC scala
          // scala>
          val stream = Arrays.stream(Array(1, 2, 3))

          // scala>
          stream.map(i => f(i)).toArray
          // res5: Array[Int] = Array(2, 3, 4)
        #+END_SRC

      + Correction 2

        =From Jian= rarely used -- you must import ~IntUnaryOperator~ first, and
                    you must have permission to define ~f~ with
                    ~IntUnaryOperator~ type. However, if you can, why NOT just
                    use a /function literal/? The only two reasons I can imagine
        * ~f~ is not short, and you need to use it multiple times!
        * ~f~ is too long, you want to make you code clear!

        #+BEGIN_SRC scala
          // scala>
          val f: IntUnaryOperator = i => i + 1
          // f: java.util.function.IntUnaryOperator = ...

          // scala>
          val stream = Arrays.stream(Array(1, 2, 3))

          // scala>
          stream.map(f).toArray
          // res6: Array[Int] = Array(2, 3, 4)
        #+END_SRC

    - =TODO= =RE-READ= =RE-THINK=
      With Scala 2.12 and Java 8, you can also invoke methods compiled with Scala
      from Java, passing Scala function types using Java lambda expressions.

      Although Scala /function types/ are defined as /traits/ that include
      /concrete methods/, *Scala 2.12 compiles traits to Java interfaces with
      /default methods/,* a new feature of Java 8.
      As a result, /Scala function types/ appear to Java as /SAMs/.

** DONE 31.6 Conclusion - 713
   CLOSED: [2018-02-07 Wed 02:10]

* DONE 32 Futures and Concurrency - 714
  CLOSED: [2018-04-11 Wed 15:10]
  - Java provides concurrency support built around /shared memory/ and /locking/.
      Although this support is sufficient, this approach turns out to be _quite
    DIFFICULT to get right in practice_.

  - Scala's standard library offers an ALTERNATIVE that avoids these
    difficulties by focusing on /asynchronous transformations of immutable state/:
    the ~Future~.

  - Java also offers a ~Future~, but it is _very different from Scala's_.
    =TODO= =???=

  - ??????? =TODO= =???=

    This allows you to describe /asynchronous computations/ as _a series of
    transformations of immutable values_, *with no need to reason about shared
    memory and locks*.

** DONE 32.1 Trouble in paradise - 714 =Re-Do=
   CLOSED: [2018-03-06 Tue 14:37]
   - The Java way:
     + Model:
       each object is associated with a logical /monitor/, which can be used to
       control multi-threaded access to data.

     + Use this model:
       Mark the data that will be shared by multiple threads as *synchronized*.

       The Java runtime employs a locking mechanism to *ensure* that *only one*
       thread at a time enters synchronized sections guarded by the same /lock/.

   - For compatibility's sake,
     Scala provides access to Java's concurrency primitives.
     The ~wait~, ~notify~, and ~notifyAll~ /methods/ can be called in Scala, and
     _they have the same meaning as in Java_.

   - Scala
     + does *NOT* have the ~synchronized~ /keyword/

     + has a *predefined* ~synchronized~ /method/ that can be called
       as follows:
       #+BEGIN_SRC scala
         var counter = 0

         synchronized {
           // One thread in here at a time
           counter = counter + 1
         }
       #+END_SRC

   - Why is this model hard to be used?
     + You must reason about
       * what data you are modifying or accessing that might be modified or
         accessed by other trheads

       * what locks are being held.

     + At each method call,
       you must reason about
       * what locks it will try to hold and convince yourself that it will not
         /deadlock/ while trying to obtain them.

     + Compounding the problem, the locks you reason about are *not fixed at
       compile time*, _because the program is free to create new locks at run
       time as it progresses._

     + Making things worse, testing is not reliable with multi-threaded code, which
       has *non-deterministic* nature.

     + Over-synchronizing also does NOT work!
       New lock operations may _remove_ POSSIBILITIES for /race condition/, they
       simutaneously _add_ POSSIBILITIES for /deadlocks/.

   - Higher level abstractions: ~java.util.concurrent~
     It's far less error prone than the low-level synchronization primitives.

     Nevertheless, it is also based on /the shared data and locks models/, and
     it does NOT solve the fundamental difficulties of using that model!

** DONE 32.2 Asynchronous execution and ~Try~'s - 716
   CLOSED: [2018-04-11 Wed 01:19]
   - Many operations on ~Future~ require an implicit /execution context/ that
     provides a strategy for executing functions asychronously.

   - Example (lack of /execution context/):
     #+BEGIN_SRC scala
       import scala.concurrent.Future

       val fut = Future { Thread.sleep(10000); 21 + 21 }
       // <console>:11: error: Cannot find an implicit ExecutionContext.
       //     You might pass an (implicit ec: ExecutionContext)
       //     parameter to your method or import
       //     scala.concurrent.ExecutionContext.Implicits.global.
       //        val fut = Future { Thread.sleep(10000); 21 + 21 }
     #+END_SRC

   - Example (with /execution context/):
     #+BEGIN_SRC scala
       import scala.concurrent.Future
       import scala.concurrent.ExecutionContext.Implicits.global

       val fut = Future { Thread.sleep(10000); 21 + 21 }
     #+END_SRC

   - Use the ~isCompleted~ and ~value~ /methods/:
     #+BEGIN_SRC scala
       /* BEFORE finish */
       fut.isCompleted
       // res0: Boolena = false

       fut.value
       // res1: Option[scala.util.Try[Int]] = None



       /* AFTER finish */
       fut.isCompleted
       // res2: Boolena = true

       fut.value
       // res3: Option[scala.util.Try[Int]] = Some(Success(42))
     #+END_SRC

   - ~Try~ has two /subclasses/, and an instance of a ~Failure~ always contains
     an /exception/.

   - Why should we have ~Try~?
     + For *synchronous* computations, you can use ~try/catch~ to ensure that a
       thread that invokes a /method/ catches and handles /exceptions/ thrown by
       the /method/.

     + For *asynchronous* computations, the thread that initiates the computation
       often moves on to other tasks.
         Later if that asynchronous computation fails with an exception, _the
       *original* thread_ is _no longer_ able to handle the exception in a
       ~catch~ clause. Thus, we use ~Try~ to handle the /exceptions/.

   - Example:
     #+BEGIN_SRC scala
       import scala.concurrent.Future
       import scala.concurrent.ExecutionContext.Implicits.global

       val fut = Future { Thread.sleep(10000); 21 / 0 }
       // fut: scala.concurrent.Future[Int] = ...

       /* When the computation complete */
       fut.value
       // res4: Option[scala.util.Try[Int]] = None
       //     Some(Failure(java.lang.ArithmeticException: / by zero))

     #+END_SRC

** DONE 32.3 Working with ~Future~'s - 718
   CLOSED: [2018-04-11 Wed 15:06]
   Scala's ~Future~ allows you to specify /transformations/ on ~Future~ results
   and obtain a new /future/ that represents the composition of the _two_ /asynchronous
   computations/: the original and the transformation.

*** DONE Transforming ~Futures~ with ~map~ - 719
    CLOSED: [2018-04-11 Wed 02:19]
    #+BEGIN_SRC scala
      import scala.concurrent.Future
      import scala.concurrent.ExecutionContext.Implicits.global

      val fut = Future { Thread.sleep(10000); 21 + 21 }
      val result = fut.map(x => x + 1)
      /* When computation complete */
      result.value
      // res6: Option[scala.util.Try[Int]] = Some(Success(43))
    #+END_SRC

*** DONE Transforming ~Futures~ with ~for~ expressions - 719 =RE-READ=
    CLOSED: [2018-04-11 Wed 02:30]
    Because Scala's ~Future~ also declares a ~flatMap~ /method/, you can
    transform /futures/ using a ~for~ expression.
    #+BEGIN_SRC scala
      val fut1 = Future { Thread.sleep(10000); 21 + 21 }
      val fut2 = Future { Thread.sleep(10000); 23 + 23 }

      for {
        x <- fut1
        y <- fut2
      } yield x + y
      // res7: scala.concurrent.Future[Int] = ...

      /* When computation complete */
      res7.value
      // res8: Option[scala.util.Try[Int]] = Some(Success(88))

    #+END_SRC

    - Because ~for~ expressions serialize their /transformations/,
      *if you don't create the /futures/ before the ~for~ expression, they won't
      run in parallel.* =TODO=

        A similar look example, which will _run at least 20 seconds, rather then
      10 seconds_ as in the code above. =TODO=
      #+BEGIN_SRC scala
        // fut1.flatMap(x => fut2.map(y => x + y))
        for {
          x <- Future { Thread.sleep(10000); 21 + 21 }
          y <- Future { Thread.sleep(10000); 23 + 23 }
        } yield x + y
        // res7: scala.concurrent.Future[Int] = ...

        /* When computation complete */
        res7.value
      #+END_SRC

    - =FROM JIAN= Consider the code above, and find out the difference.
      Guess: check their forms of using ~flatMap~

*** DONE Creating the ~Future~: ~Future.failed~, ~Future.successful~, ~Future.fromTry~, and ~Promises~ - 721
    CLOSED: [2018-04-11 Wed 03:05]
    - The ~Future~ /companion object/ includes three /factory methods/ for
      creating already-completed /futures/:
      + ~Future.successful~
        #+BEGIN_SRC scala
          Future.successful { 21 + 21 }
          // res2: scala.concurrent.Future[Int] = ...
        #+END_SRC

      + ~Future.failed~
        #+BEGIN_SRC scala
          Future.failed(new Exception("bummer!"))
          // res3: scala.concurrent.Future[Nothing] = ...
        #+END_SRC

      + ~Future.fromTry~
        #+BEGIN_SRC scala
          import scala.util.{Success,Failure}

          Future.fromTry(Success { 21 + 21 })
          // res4: scala.concurrent.Future[Int] = ...

          Future.fromTry(Failure(new Exception("bummer!")))
          // res5: scala.concurrent.Future[Nothing] = ...
        #+END_SRC

      These /factory methods/ do NOT require an ~ExecutionContext~

    - The most general way to create a /future/ is to use a ~Promise~.
      + Given a /promise/ you can obtain a /future/ that is *controlled by* the
        /promise/.

      + The /future/ will *complete* _when_ you complete the /promise/.

    - Example:
      #+BEGIN_SRC scala
        val pro = Promise[Int]
        // pro: scala.concurrent.Promise[Int] = ...

        val fut = pro.future
        // fut: scala.concurrent.Future[Int] = ...

        fut.value
        // res8: Option[scala.util.Try[Int]] = None
      #+END_SRC

    - You can *complete* the /promise/ with /methods/
      + ~success~
        Example:
        #+BEGIN_SRC scala
          pro.success(42)
          // res9: pro.type = ...

          fut.value
          // res10: Option[scala.util.Try[Int]] = Some(Success(42))
        #+END_SRC

      + ~failure~
        Accept an /exception/ that will cause the /future/ to fail with that
        /exception/.

      + ~complete~
        Take a ~Try~.

      + ~completeWith~
        =TODO= =???= =Example?=
        =TODO= =???= =Example?=
        Take a /future/.
        The /promise/'s /future/ will thereafter mirror the completion status of
        the /future/ you passed to ~completeWith~.

*** DONE Filtering: ~filter~ and ~collect~ - 721
    CLOSED: [2018-04-11 Wed 03:19]
    - The ~filter~ and ~collect~ /methods/ allow you to *ensure a property holds
      true* about a /future value/.

    - Example:
      #+BEGIN_SRC scala
        val fut = Future { 42 }

        /* If valid */
        val valid = fut.filter(res => res > 0)
        valid.val
        // res0: Option[scala.util.Try[Int]] = Some(Success(42))


        /* If invalid */
        val invalid = fut.filter(res => res < 0)
        invalid.val
        // res1: Option[scala.util.Try[Int]] =
        //   Some(Failure(java.util.NoSuchElementException:
        //   Future.filter predicate is not satisfied))
      #+END_SRC

    - ~Future~ offers a ~withFilter~ /method/, and you can perform the same
      operation with ~for~ expression filters:
      #+BEGIN_SRC scala
        val valid = for (res <- fut if res > 0) yield res
        valid.value
        // res2: Option[scala.util.Try[Int]] = Some(Success(42))

        val invalid = for (res <- fut if res < 0) yield res
        // res3: Option[scala.util.Try[Int]] =
        //   Some(Failure(java.util.NoSuchElementException:
        //   Future.filter predicate is not satisfied))
      #+END_SRC

    - The ~collect~ /method/ allows you to
      1. validate the /future value/ (=From Jian= like a filter)
      2. transform it in one operation (=From Jian= like a map)

    - If the /partial function/ passed to ~collect~ is defined at the /future
      result/, the /future/ returned by ~collect~ will succeed with that value
      transformed by the function:
      #+BEGIN_SRC scala
        val valid = fut collect { case res if res > 0 => res + 46 }
        // valid: scala.concurrent.Future[Int] = ...

        valid.value
        // res17: Option[scala.util.Try[Int]] = Some(Success(88))
      #+END_SRC

      Otherwise, the /future/ will fail with ~NoSuchElementException~:
      #+BEGIN_SRC scala
        val invalid =
          fut collect { case res if res < 0 => res + 46 }
        // invalid: scala.concurrent.Future[Int] = ...

        invalid.value
        // res18: Option[scala.util.Try[Int]] =
        //   Some(Failure(java.util.NoSuchElementException:
        //   Future.collect partial function is not defined at: 42))
      #+END_SRC

*** DONE Dealing with failure: ~failed~, ~fallBackTo~, ~recover~, and ~recoverWith~ - 724
    CLOSED: [2018-04-11 Wed 05:15]
    - Scala's /future/ provides ways to work with /futures/ that *fail*, including:
      + ~failed~
        Transform a failed /future/ of any type into a successful
        ~Future[Throwable]~ that holds onto the /exception/ that caused the failure.
        * If it is a fail
          #+BEGIN_SRC scala
            val failure = Future { 42 / 0 }
            // failure: scala.concurrent.Future[Int] = ...

            failure.value
            // res23: Option[scala.util.Try[Int]] =
            //   Some(Failure(java.lang.ArithmeticException: / by zero))

            val expectedFailure = failure.failed
            // expectedFailure: scala.concurrent.Future[Throwable] = ...

            expectedFailure.value
            // res25: Option[scala.util.Try[Throwable]] =
            //   Some(Success(java.lang.ArithmeticException: / by zero))
          #+END_SRC

        * If it is NOT a fail, the saved /exception/ is the ~NoSuchElementException~:
          #+BEGIN_SRC scala
            val success = Future { 42 / 1 }
            // success: scala.concurrent.Future[Int] = ...

            success.value
            // res21: Option[scala.util.Try[Int]] = Some(Success(42))

            val unexpectedSuccess = success.failed
            // unexpectedSuccess: scala.concurrent.Future[Throwable] = ...

            unexpectedSuccess.value
            // res26: Option[scala.util.Try[Throwable]] =
            //   Some(Failure(java.util.NoSuchElementException:
            //   Future.failed not completed with a throwable.))
          #+END_SRC

      + ~fallBackTo~
        Provide a _fall back_ /future/ in case the future on which you invoke
        ~fallbackTo~ fails.
        + When success, return the result /future/
        #+BEGIN_SRC scala
          val fallback = failure.fallbackTo(success)
          // fallback: scala.concurrent.Future[Int] = ...

          fallback.value
          // res27: Option[scala.util.Try[Int]] = Some(Success(42))
        #+END_SRC

        + When fail, return the result _fall back_ /future/
          #+BEGIN_SRC scala
            val fallback = failure.fallbackTo(
              Future { val res = 42; require(res < 0); res }
            )

            failedFallback.value
            // res28: Option[scala.util.Try[Int]] =
            //   Some(Failure(java.lang.ArithmeticException: / by zero))
          #+END_SRC

      + ~recover~
        * transform a _failed_ /future/ into a _successful_ one
          #+BEGIN_SRC scala
            val recovered = failedFallback recover {
              case ex: ArithmeticException => -1
            }

            recovered.value
            // res32: Option[scala.util.Try[Int]] = Some(Success(-1))
          #+END_SRC

        * allowing a the result of a _successful_ /future/ to _pass through
          unchanged_.
          #+BEGIN_SRC scala
            /* No exception - Success */
            val unrecovered = fallback recover {
              case ex: ArithmeticException => 1
            }

            unrecovered.value
            // res33: Option[scala.util.Try[Int]] = Some(Success(42))



            /* With exception - Fail - unmatch exception */
            val alsoUnrecovered = failedFallback recover {
              case ex: IllegalArgumentException => -2
            }

            alsoUnrecovered.value
            // res34: Option[scala.util.Try[Int]] =
            //   Some(Failure(java.lang.ArithmeticException: / by zero))
          #+END_SRC

      + ~recoverWith~
        It's like ~recover~, except instead of recovering to a value like
        ~recover~, it allows you to _recover to a ~Future~._
        #+BEGIN_SRC scala
          val alsoRecovered = failedFallback recoverWith {
            case ex: ArithmeticException => Future { 42 + 46 }
          }

          alsoRecovered.value
          // res35: Option[scala.util.Try[Int]] = Some(Success(88))
        #+END_SRC
        * As with ~recover~,
          if
          - either _the original /future/ doesn't fail_,
          - or _the partial function passed to ~recoverWith~ isn't defined at the
            exception the original future ultimately fails with_,

          the original success (or failure) will pass through to the /future/
          returned by ~recoverWith~.

*** DONE Mapping both possibilities: ~transform~ - 726
    CLOSED: [2018-04-11 Wed 11:27]
    - ~Future~'s ~transform~ /method/ accepts *two* functions with which to
      *transform* a /future/:
      + one to use in case of _success_

      + the other in case of _failure_

    - Example:
      #+BEGIN_SRC scala
        val first = success.transform(
          res => res * 1,
          ex => new Exception("see cause", ex)
        )
        // first: scala.concurrent.Future[Int] = ...
      #+END_SRC

      + If the /future/ _succeeds_, the first function is used:
        #+BEGIN_SRC scala
          first.value
          // res42: Option[scala.util.Try[Int]] = Some(Success(-42))
        #+END_SRC

      + If the future fails, the second function is used:
        #+BEGIN_SRC scala
          val second = failure.transform(
            res => res * 1,
            ex => new Exception("see cause", ex)
          )
          // second: scala.concurrent.Future[Int] = ...


          second.value
          // res43: Option[scala.util.Try[Int]] =
          //   Some(Failure(java.lang.Exception: see cause))
        #+END_SRC

      + Note that with the ~transform~ /method/ shown in the previous examples,
        * you *CANNOT* change a /successful future/ into a /failed one/

        * you also *CANNOT* change a /failed future/ into a/ successful one/

    - To make transformations between /successful futures/ and /failed futures/
      easier, Scala 2.12 introduced an alternate overloaded form of ~transform~
      that takes a function from ~Try~ to ~Try~. Here are some examples:
      #+BEGIN_SRC scala
        val firstCase = success.transform { // Scala 2.12
          case Success(res) => Success(res * -1)
          case Failure(ex)  => Failure(new Exception("see cause", ex))
        }
        // first: scala.concurrent.Future[Int] = ...


        firstCase.value
        // res6: Option[scala.util.Try[Int]] = Some(Success(-42))


        val secondCase = failure.transform {
          case Success(res) => Success(res * -1)
          case Failure(ex)  => Failure(new Exception("see cause", ex))
        }
        // secondCase: scala.concurrent.Future[Int] = ...


        secondCase.value
        // res8: Option[scala.util.Try[Int]] =
        //    Some(Failure(java.lang.Exception: see cause))
      #+END_SRC

      + Usage:
        #+BEGIN_SRC scala
          val nonNegative = failure.transform { // Scala 2.12
            case Success(res) => Success(res.abs + 1)
            case Failure(_) => Success(0)
          }
          // nonNegative: scala.concurrent.Future[Int] = ...

          scala> nonNegative.value
          // res11: Option[scala.util.Try[Int]] = Some(Success(0))
        #+END_SRC

*** DONE Combining futures: ~zip~, ~Future.fold~, ~Future.reduce~, ~Future.sequence~, and ~Future.traverse~ - 728 =Re-Do=
    CLOSED: [2018-04-11 Wed 12:34]
    =From Jian= Try to understand this part with the idea of common algebra
    structures like /functor/, /monoid/, and /monad/

    - ~zip~
      + Success
        #+BEGIN_SRC scala
          scala> val zippedSuccess = success zip recovered
          // zippedSuccess: scala.concurrent.Future[(Int, Int)] = ...

          zippedSuccess.value
          // res46: Option[scala.util.Try[(Int, Int)]] =
          //      Some(Success((42,1)))
        #+END_SRC

      + Fail
        * If _either of the /futures/ *FAIL*,_ however, the /future/ returned by
          ~zip~ will also *FAIL* with the *same* /exception/:
          #+BEGIN_SRC scala
            val zippedFailure = success zip failure
            // zippedFailure: scala.concurrent.Future[(Int, Int)] = ...

            zippedFailure.value
            // res48: Option[scala.util.Try[(Int, Int)]] =
            //   Some(Failure(java.lang.ArithmeticException: / by zero))
          #+END_SRC

        * If both /futures/ *FAIL*, the failed /future/ that results will contain
          the /exception/ stored in the /initial future/, the one on which zip was
          invoked (the /receiver/).

    - ~Future.fold~
      Accumulate a result accross a ~TraversableOnce~ collection of /future/'s,
      yielding a /future/ result.
      #+BEGIN_SRC scala
        val fortyTwo = Future { 21 + 21 }
        // fortyTwo: scala.concurrent.Future[Int] = ...

        val fortySix = Future { 23 + 23 }
        // fortySix: scala.concurrent.Future[Int] = ...

        val futureNums = List(fortyTwo, fortySix)
        // futureNums: List[scala.concurrent.Future[Int]] = ...

        val folded = Future.fold(futureNums)(0) {
          (acc, num) => acc + num
        }
        // folded: scala.concurrent.Future[Int] = ...

        folded.value
        // res53: Option[scala.util.Try[Int]] = Some(Success(88))
      #+END_SRC

      + If *any* /future/ in the collection _fails_, the resulting /future/ will
        _fail_. If *MULTIPLE* /futures/ _fail_, the result will _fail_ with the
        same /exception/ with which the *first* /future/ (earliest in the
        ~TraversableOnce~ collection) *fails*.

    - ~Future.reduce~
      It performs a /fold/ *without* an /initial value/ as the _second parameter_,
      using the *initial /future/ result* instead.
      #+BEGIN_SRC scala
        val reduced =
          Future.reduce(futureNums) { (acc, num) =>
            acc + num
          }
        // reduced: scala.concurrent.Future[Int] = ...

        reduced.value
        // res54: Option[scala.util.Try[Int]] = Some(Success(88))
      #+END_SRC
      + Pass an empty collection as the first parameter of ~reduce~, and a
        ~NoSuchElementException~ will be thrown.

    - ~Future.sequence~
      It transforms a ~TraversableOnce~ collection of /futures/ into a /future/
      ~TraversableOnce~ of values.
        For instance, in the following example, ~sequence~ is used to
      /transform/ a ~List[Future[Int]]~ to a ~Future[List[Int]]~:
      #+BEGIN_SRC scala
        val futureList = Future.sequence(futureNums)
        // futureList: scala.concurrent.Future[List[Int]] = ...

        futureList.value
        // res55: Option[scala.util.Try[List[Int]]] =
        //   Some(Success(List(42, 46)))
      #+END_SRC

    - ~Future.traverse~
      It changes a ~TraversableOnce~ of any element type into a
      ~TraversableOnce~ of /futures/ and /sequence/ that into a /future/
      ~TraversableOnce~ of values.
        For example, here a ~List[Int]~ is transformed into a
      ~Future[List[Int]]~ by ~Future.traverse~:
      #+BEGIN_SRC scala
        val traversed =
          Future.traverse(List(1, 2, 3)) { i => Future(i) }
        // traversed: scala.concurrent.Future[List[Int]] = ...

        traversed.value
        // res58: Option[scala.util.Try[List[Int]]] =
        //   Some(Success(List(1, 2, 3)))
      #+END_SRC

*** DONE Performing side-effects: ~foreach~, ~onComplete~, and ~andThen~ - 730
    CLOSED: [2018-04-11 Wed 13:47]
    - ~foreach~
      Perform a side effect if a future completes successfully.
      For example,
      #+BEGIN_SRC scala
        failure.foreach(ex => println(ex))

        success.foreach(res => println(res))
        // 42
      #+END_SRC

    - Since ~for~ _without yield_ will rewrite to an invocation of ~foreach~, you
      can also accomplish the same effect using for expressions:
      #+BEGIN_SRC scala
        for (res <- failure) println(res)

        for (res <- success) println(res)
        // 42
      #+END_SRC

    - ~Future~ also offers *two* /methods/ for registering /callback functions/.
      + The ~onComplete~ /method/ will be executed whether the /future/ ultimately
        succeeds or fails.
          The function will be passed a Try—a Success holding the
        result if the future succeeded, else a Failure holding the exception that
        caused the future to fail. Here’s an example:
        #+BEGIN_SRC scala
          import scala.util.{Success, Failure}

          success onComplete {
            case Success(res) => println(res)
            case Failure(ex) => println(ex)
          }
          // 42

          failure onComplete {
            case Success(res) => println(res)
            case Failure(ex) => println(ex)
          }
          // java.lang.ArithmeticException: / by zero
        #+END_SRC

        * ~Future~ does *NOT* guarantee any order of execution for /callback
          functions/ registered with ~onComplete~.

      + If you want to *enforce an order* for /callback functions/, you must use
        ~andThen~ instead.
          The ~andThen~ /method/ returns a _new_ /future/ that mirrors (succeeds
        or fails in the same way as) the /original future/ on which you invoke
        ~andThen~, but it does NOT complete until the /callback function/ has been
        fully executed:
        #+BEGIN_SRC scala
          val newFuture = success andThen {
            case Success(res) => println(res)
            case Failure(ex) => println(ex)
          }
          // 42
          // newFuture: scala.concurrent.Future[Int] = ...

          newFuture.value
          // res76: Option[scala.util.Try[Int]] = Some(Success(42))
        #+END_SRC

    - Note that if a /callback function/ passed to ~andThen~ throws an
      /exception/ when executed,
        _That /exception/ will /not/ be propagated to subsequent callbacks or
      reported via the resulting future._
      =TODO= =???= =Details=

*** DONE Other methods added in *2.12*: ~flatten~, ~zipWith~, and ~transformWith~ - 732
    CLOSED: [2018-04-11 Wed 15:06]
    - ~flatten~
      #+BEGIN_SRC scala
        val nestedFuture = Future { Future { 42 } }
        val flattened = nestedFuture.flatten  // Scala 2.12
        // flattened: scala.concurrent.Future[Int] = Future(Success(42))
      #+END_SRC

    - ~zipWith~
      zip and then map
      #+BEGIN_SRC scala
        val futNum = Future { 21 + 21 }
        val futStr = Future { "ans" + "wer" }

        val zipWithed = futNum.zipWith(futStr) {
          case (num, str) => s"$num is the $str"
        }

        zipWithed.value
        // Option[scala.util.Try[String]] = Some(Success(42 is the answer))
      #+END_SRC

    - ~transformWith~ =TODO= =RE-READ=
      tranform with a function from ~Try~ to ~Future~
      #+BEGIN_SRC scala
        val flipped = success.transformWith { // Scala 2.12
          case Success(res) => Future { throw new Exception(res.toString) }
          case Failure(ex)  => Future { 21 + 21 }
        }
        // flipped: scala.concurrent.Future[Int] = ...

        flipped.value
        // res5: Option[scala.util.Try[Int]] =
        //     Some(Failure(java.lang.Exception: 42))
      #+END_SRC
      + The ~transformWith~ /method/ is similar to *the new, overloaded*
        ~transform~ /method/ added in Scala 2.12, _except_ instead of yielding a
        ~Try~ in your passed function as in ~transform~, ~transformWith~ allows
        you to yield a /future/.

** DONE 32.4 Testing with ~Future~'s - 733
   CLOSED: [2018-04-11 Wed 13:34]
   - Scala does allow you to *block* on a /future/ result when you need to.
     Scala's ~Await~ /object/ facilitates blocking to wait for future results.
     Here’s an example:
     #+BEGIN_SRC scala
       import scala.concurrent.Await
       import scala.concurrent.duration._


       val fut = Future { Thread.sleep(10000); 21 + 21 }
       // fut: scala.concurrent.Future[Int] = ...

       val x = Await.result(fut, 15.seconds) // blocks
       // x: Int = 42
     #+END_SRC
     + ~Await.result~ takes a ~Future~ and a ~Duration~.

     + If there is NOT enough time, a ~TimeoutException~ will be thrown.

   - One place where *blocking* has been generally accepted is
     _in tests of asynchronous code_.

     + Use ~Await.result~.
       #+BEGIN_SRC scala
         import org.scalatest.Matchers._
         x should be (42)
         // res0: org.scalatest.Assertion = Succeeded
       #+END_SRC

     + Extends ~ScalaFutures~ /trait/ as *alternatives*,
       For example, the ~futureValue~ /method/, implicitly added to ~Future~ by
       ~ScalaFutures~, *will block until the /future/ completes*.
       #+BEGIN_SRC scala
         import org.scalatest.concurrent.ScalaFutures._


         val fut = Future { Thread.sleep(10000); 21 + 21 }
         // fut: scala.concurrent.Future[Int] = ...

         fut.futureValue should be (42)    // futureValue blocks
         // res1: org.scalatest.Assertion = Succeeded
       #+END_SRC

       * ~TestFailedException~ on fails

   - While *blocking in tests* is often fine,
     /ScalaTest 3.0/ adds "async" testing styles that allow you to test
     /futures/ *without blocking*.
     #+BEGIN_SRC scala
       import org.scalatest.AsyncFunSpec
       import scala.concurrent.Future

       class AddSpec extends AsyncFunSpec {
         def addSoon(addends: Int*): Future[Int] =
           Future { addends.sum }

         describe("addSoon") {
           it("will eventually compute a sum of passed Ints") {
             val futureSum: Future[Int] = addSoon(1, 2)
             // You can map assertions onto a Future, then return
             // the resulting Future[Assertion] to ScalaTest:
             futureSum map { sum => assert(sum == 3) }
           }
         }
       }
     #+END_SRC

   - The /async testing/ use case illustrates a *general principle* for working
     with /futures/: *Once in "future space," try to _stay_ in /future/ space.*

   - =TODO= =???=
     To *get results out of* /future/ space, register /side effects/ to be
     _performed asynchronously_ once /futures/ complete. This approach will help
     you *make _maximum use_ of your /threads/.*

** DONE 32.5 Conclusion - 735
   CLOSED: [2018-04-11 Wed 15:10]
   - Concurrent programming gives you great power.
     It lets you *simplify* your code and take advantage of multiple processors.

   - It's *unfortunate* that the most widely used concurrency primitives,
     /threads/, /locks/, and /monitors/, are such a minefield of /deadlocks/ and
     /race conditions/.

     ~Futures~ provide a way out of that minefield, letting you write concurrent
     programs *without* as great a risk of /deadlocks/ and /race conditions/.

   - This chapter has introduced several fundamental constructs for working with
     /futures/ in Scala, including
     + how to create /futures/, how to *transform* them,

     + how to *test* them, among other nuts and bolts.

     It then showed you how to use these constructs as part of a general
     /futures/ style.

* DONE 33 Combinator Parsing - 736
  CLOSED: [2018-03-06 Tue 14:03]
  - These building blocks of /parser combinators/ will map one to one to the
    constructions of a /context-free grammar/, to make them easy to understand.

  - The only non-Scala specific prerequisite for understanding this chapter:
    you know about /regular and context-free grammars/.

** DONE 33.1 Example: Arithmetic expressions - 737
   CLOSED: [2018-03-05 Mon 15:53]
   - (Context-free) Grammar for arithmetic expressions:
     #+BEGIN_SRC text
         expr ::= term {"+" term | "-" term}.
         term ::= factor {"*" factor | "/" factor}.
       factor ::= floatingPointNumber | "(" expr ")".
     #+END_SRC

     + ~|~ denotes alternative productions
     + ~{...}~ denotes repetition (zero or more times)
     + No use in this example, ~[...]~ denotes an _optional occurrence_.

     + This grammar already encodes the /relative precedence/ of operators.

   - Translate the grammar above to Scala code (with /cominator parser library/):
     #+BEGIN_SRC scala
       import scala.util.parsing.combinator._

       class Arith extends JavaTokenParsers {
         def expr: Parser[Any] = term~rep("+"~term | "-"~term)
         def term: Parser[Any] = factor~rep("*"~factor | "/"~factor)
         def factor: Parser[Any] = floatingPointNumber | "("~expr~")"
       }
     #+END_SRC

     + The ~floatingPointNumber~ comes from the /trait/ ~JavaTokenParsers~.

     + This /trait/ provides the basic machinery for writing a parser
       and also provides some _primitive parsers_ that recognize some word classes:
       * identifiers
       * string literals
       * numbers

   - How to convert a /context-free grammar/ to Scala parser combinator code:
     1. Every production becomes a /method/ -- add ~def~.

     2. Replace ~::=~ with ~: Parser[Any] =~.

        =TODO= Learn what does this type mean and how to make it more precise in
        this chater later sections.

     3. The grammar has implict sequential composition, and use ~~~ to make it
        explicit in the code.

     4. Replace ~{...}~ with ~rep(...)~;
        Replace ~[...]~ with ~opt(...)~;

     5. The period (.) at the end of each production is ommitted in the code.

** DONE 33.2 Running your parser - 739
   CLOSED: [2018-03-05 Mon 16:35]
   - Run the parser:
     #+BEGIN_SRC scala
       object ParseExpr extends Arith {
         def main(args: Array[String]) = {
           println("input : " + args(0))
           println(parseAll(expr, args(0)))
         }
       }
     #+END_SRC

     + Run
       #+BEGIN_SRC bash
         scala ParseExpr "2 * (3 + 7)"
         # input: 2 * (3 + 7)
         # [1.12] parsed: ((2~List((*~(((~((3~List())~List((+
         # ~(7~List())))))~)))))~List())
       #+END_SRC

     + Besides ~parseAll~, there's also a method ~parse~, which allows you to
       * parse an input prefix
       * leaving some remainder unread.

   - Error messages:
     #+BEGIN_SRC bash
       scala ParseExpr "2 * (3 + 7))"
       # input: 2 * (3 + 7))
       # [1.12] failure: `-' # expected but `)' found
       #
       # 2 * (3 + 7))
       #            ˆ
     #+END_SRC

** DONE 33.3 Basic regular expression parsers - 740
   CLOSED: [2018-03-05 Mon 19:35]
   - ~JavaTokenParsers~ provides some basic parsers for patterns in Java format.

   - Q :: How to parse patterns not like Java? For example, parse /floating
          numbers/ not in Java format (CANNOT use ~floatingPointNumber~).

   - A :: Use /regular expression parser/.

   - The idea is that you can use any regular expression as a parser.
     The regular expression parses all strings that it can match.
     Its result is the parsed string.

   - For instance, parse a (subset of) Java identifiers:
     #+BEGIN_SRC scala
       object MyParsers extends RegexParsers {
         val ident: Parser[String] = """[azAZ_]\
       w*""".r
       }
     #+END_SRC

** DONE 33.4 Another example: JSON - 741
   CLOSED: [2018-03-05 Mon 19:35]
   ~JSON~ parser

** DONE 33.5 Parser output - 743
   CLOSED: [2018-03-05 Mon 20:29]
   - ~stringLiteral~ from ~JavaTokenParsers~

   - To produce this _representation_, you need to make use of one more
     combination form for parsers: ~ˆˆ~: ~P^^f~ returns ~f(P)~
       For example, ~floatingPointNumber ^^ (_.toDouble)~

*** DONE Symbolic versus alphanumeric names
    CLOSED: [2018-03-05 Mon 20:29]
    Symbolic names:
    - cons: abstract and learn and remember before use

    - pros: do not distract the reader

** DONE 33.6 Implementing combinator parsers - 749
   CLOSED: [2018-03-06 Tue 10:48]
   In the rest of this chapter you’ll take a look “under the hood” of the
   combinator parser library.

   - The core of Scala's combinator parsing framework is contained in the /trait/
     ~scala.util.parsing.combinator.Parsers~.

     This trait defines the ~Parser~ type as well as _all fundamental
     combinators_. If not being stated explicitly,

     (Except where stated explicitly otherwise, the definitions explained in the
      following two subsections all reside in this trait.)

   - As a first _approximation_, the type could be written as follows:
     ~type Parser[T] = Input => ParseResult[T]~

     =From Jian=
     Actually, ~abstract class Parser[T] extends (Input => ParseResult[T])~

*** DONE Parser input - 751
    CLOSED: [2017-11-23 Thu 01:21]
    - Sometimes, a parser reads _a stream of tokens_ instead of _a raw sequence
      of characters_.
        A separate /lexical analyzer/ =???= is then used to convert _a stream of
      raw characters_ into _a stream of tokens_.

      The type of parser inputs is defined as follows:
      ~type Input = Reader[Elem]~
      The class ~Reader~ comes from the package ~scala.util.parsing.input~

      A ~Reader~ is similar to a ~Stream~, but also keeps track of the positions
      of all the elements it reads.

      + ~Elem~ is abstract, which is written in the ~Parsers~ trait as
        ~type Elem~.
          For instance, the subtraits of ~Parser~, ~RegexParsers~ and
        ~JavaTokenParsers~ fix ~Elem~ to be equal to ~Char~.

        It would also be possible to set ~Elem~ to some other type, such as the
        type of /tokens/ returned from a separate /lexer/.

*** DONE Parser results - 751
    CLOSED: [2017-11-23 Thu 01:32]
    A parser might either _succeed_ or _fail_ on some given input.
    Consequently class ~ParseResult~ has two subclasses for representing them:
    #+BEGIN_SRC scala
      sealed abstract class ParseResult[+T]
      case class Success[T](result: T, in: Input)
        extends ParseResult[T]
      case class Failure(msg: String, in: Input)
        extends ParseResult[Nothing]
    #+END_SRC
    - The type parameter ~T~ is arbitrary.
      It represents the kinds of results returned by a given parser.
      =IMPORTANT=

    - ~Success~: the field ~in~ is needed for chaining parsers.

    - ~Failure~: the field ~in~ is, of course, not used for chaining, but to
      position the error message at the correct place in the input stream.

    - That ~ParseResult~'s are defined to be /covariant/ in the type parameter
      ~T~.

*** DONE The ~Parser~ class - 752
    CLOSED: [2017-11-23 Thu 03:04]
    - The previous characterization of parsers as functions from inputs to parse
      results was a bit oversimplified.
        Parsers are acutally /subclass/ of ~Input => ParseResult[T]~, and this is
      also why they have /methods/ like ~~~, ~|~, etc.
      #+BEGIN_SRC scala
        abstract class Parser[+T] extends (Input => ParseResult[T])
        { p =>
          // An unspecified method that defines
          // the behavior of this parser.
          def apply(in: Input): ParseResult[T]
          def ~ ...
          def | ...
          ...
        }
      #+END_SRC

    - ~Input => ParseResult[T]~ is equivalent to
      ~scala.Function1[Input, ParseResult[T]]~, which means is should have an
      ~apply~ /method/.

      The ~Parsers~ /class/ has an abstract ~apply~, and users need to implement
      this /method/ when they implement a subclass or instance object of the
      ~Parsers~.

*** DONE Aliasing ~this~ - 753
    CLOSED: [2017-11-23 Thu 03:18]
    - The definition given in the last subsection
      ~abstract class Parser[+T] extends ... { p =>~

      A clause such as ~id =>~ immediately after the opening brace of a /class/
      template defines the identifier ~id~ as an alias for ~this~ in the class.

      From the alias point of view, it's like ~val id = this~. However, this is
      not what exactly it is -- ~id~ will be considered as a normal identifier by
      the compiler, and it cannot use the /private members/ of ~this~.

    - Aliasing can also be a good abbreviation when you need to access the ~this~
      of an /outer class/. Here's an example:
      #+BEGIN_SRC scala
        class Outer { outer =>
          class Inner {
            println(Outer.this eq outer)  // prints: true
          }
        }
      #+END_SRC
      + The ~Outer.this~ is the Java way.
      + The ~outer~ is the Scala way.

*** DONE Single-token parsers - 754
    CLOSED: [2018-03-06 Tue 10:02]
    Trait ~Parsers~ defines a generic parser ~elem~ that can be used to parse any
    single token:
    #+BEGIN_SRC scala
      def elem(kind: String, p: Elem => Boolean) =
        new Parser[Elem] {
          def apply(in: Input) =
            if (p(in.first)) Success(in.first, in.rest)
            else             Failure(kind + " expected", in)
        }
    #+END_SRC
    + ~kind~ describing what kind of token should be parsed.

*** DONE Sequential composition - 754
    CLOSED: [2018-03-06 Tue 10:26]
    - About ~
      #+BEGIN_SRC scala
        abstract class Parser[+T] extends (Input => ParserResult[T]) { p =>
          // ...

          def ~ [U](q: => Parser[U]) = new Parser[T~U] {
            def apply(in: Input) = p(in) match {
              case Success(x, in1) =>
                q(in1) match {
                  case Success(y, in2) => Success(new ~(x, y), in2)
                  case failure => failure
                }
              case failure => failure
            }
        }
      #+END_SRC
      + ~[T~U]~ is the same as ~~[T, U]~

    - Similarly, about <~ and ~>:
      #+BEGIN_SRC scala
        def <~ [U](q: => Parser[U]): Parser[T] =
          (p~q) ˆˆ { case x~y => x }

        def ~> [U](q: => Parser[U]): Parser[U] =
          (p~q) ˆˆ { case x~y => y }
      #+END_SRC

*** DONE Alternative composition - 755
    CLOSED: [2018-03-06 Tue 10:28]
    #+BEGIN_SRC scala
      def | (q: => Parser[T]) = new Parser[T] {
        def apply(in: Input) = p(in) match {
          case s1 @ Success(_, _) => s1
          case failure => q(in)
        }
      }
    #+END_SRC

    - _CAUTION_:
      Note that if ~P~ and ~Q~ _BOTH_ fail, then the failure message is
      *determined by ~Q~.*
      =TODO= This subtle choice is discussed later, in Section 33.9.

*** DONE Dealing with recursion - 756
    CLOSED: [2018-03-06 Tue 10:31]
    Note that the ~q~ parameter in methods ~ and | is *by-name*.

    This makes it possible to write recursive parsers.

    If it's *by-value*, call them will lead to a stack overflow immediately.

*** DONE Result conversion - 756
    CLOSED: [2018-03-06 Tue 10:34]
    - The parser ~P ^^ f~ succeeds exactly when ~P~ succeeds.

    - Definition of ~^^~:
      #+BEGIN_SRC scala
        def ˆˆ [U](f: T => U): Parser[U] = new Parser[U] {
          def apply(in: Input) = p(in) match {
            case Success(x, in1) => Success(f(x), in1)
            case failure => failure
          }
        }
      #+END_SRC

*** DONE Parsers that don't read any input - 757
    CLOSED: [2018-03-06 Tue 10:44]
    Two useful parsers that do *NOT* consume any input:
    #+BEGIN_SRC scala
      def success[T](v: T) = new Parser[T] {
        def apply(in: Input) = Success(v, in)
      }

      def failure(msg: String) = new Parser[Nothing] {
        def apply(in: Input) = Failure(msg, in)
      }
    #+END_SRC

*** DONE Option and repetition - 757
    CLOSED: [2018-03-06 Tue 10:47]
    #+BEGIN_SRC scala
      def opt[T](p: => Parser[T]): Parser[Option[T]] = (
        p ˆˆ Some(_)
          | success(None)
      )

      def rep[T](p: => Parser[T]): Parser[List[T]] = (
        p~rep(p) ˆˆ { case x~xs => x :: xs }
          | success(List.empty[T])
      )

      def repsep[T](p: => Parser[T],
                    q: => Parser[Any]): Parser[List[T]] = (
        p~rep(q~> p) ˆˆ { case r~rs => r :: rs }
          | success(List.empty[T])
      )
    #+END_SRC

** DONE 33.7 String literals and regular expressions - 758
   CLOSED: [2018-03-06 Tue 12:02]
   - The parsers of ~literal~ and ~regex~ come from the trait ~RegexParsers~, a
     subtrait of ~Parsers~.

   - In ~RegexParsers~, ~type Elem = Char~.

   - Definition headers:
     #+BEGIN_SRC scala
       implicit def literal(s: String): Parser[String] = ...
       implicit def regex(s: Regex): Parser[String] = ...
     #+END_SRC
     Due to the ~implicit~'s, you can write ~String~ or ~Regex~ in your parser,
     and they are converted to object of ~Parser[String]~ implicitly.
       This means, for example,
       #+BEGIN_SRC scala
         "("~expr~")"

         // will be automatically expanded to

         literal("(") ~ expr ~ literal(")")
       #+END_SRC

   - The ~RegexParsers~ trait also takes care of handling white space between
     symbols. To do this, it calls a method named ~handleWhiteSpace~ before
     running a ~literal~ or ~regex~ parser.

     The ~handleWhiteSpace~ /method/ skips the longest input sequence that
     conforms to the ~whiteSpace~ regular expression, which is defined by default
     as follows: ~protected val whiteSpace = """\s+""".r~

   - If you want to change the treatment of white space, you can override the
     ~whiteSpace~ ~val~. For instance, if you want white space not to be skipped
     at all, ~override val whiteSpace = "".r~

** DONE 33.8 Lexing and parsing - 759
   CLOSED: [2018-03-06 Tue 12:30]
   - The task of syntax analysis is often split into two phases:
     1. The /lexer phase/ ::
          it recognizes *individual* words in the input and *classifies* them
          into some token classes. This phase is also called /lexical analysis/.

     2. The /syntactical analysis phase/ ::
          it analyzes *sequences* of tokens.
          Syntactical analysis is also sometimes just called parsing, even though
          this is slightly *imprecise*, as /lexical analysis/ can also be
          regarded as a parsing problem.

   - The ~Parsers~ trait as described in the previous section _can be used for
     either phase_, *because its input elements are of the _abstract_ type
     ~Elem~.*
     + For lexical analysis, ~Elem~ would be instantiated to ~Char~, meaning the
       individual characters that make up a word are being parsed.

     + The syntactical analyzer would in turn instantiate ~Elem~ to the type of
       token returned by the lexer.

   - Scala's parsing combinators provide _several utility classes_ for /lexical
     and syntactic analysis/.

     These are contained in two sub-packages, one for each kind of analysis:
     ~scala.util.parsing.combinator.lexical~
     ~scala.util.parsing.combinator.syntactical~

   - =TODO=
     If you want to _split your parser into a separate lexer and syntactical
     analyzer_, you should consult the Scaladoc documentation for these packages.

     But for simple parsers, the regular expression based approach shown
     previously in this chapter is usually sufficient.

** DONE 33.9 Error reporting - 759
   CLOSED: [2018-03-06 Tue 12:47]
   - Scala's parsing library implements a simple heuristic:
     among all failures, the one that occurred at the *latest position* in the
     input is chosen.

     In other words,
     the parser
     1. _picks the longest prefix that is still valid_

     2. issues an error message that describes why parsing the prefix could not
        be continued further.

   - If there are several failure points at that *latest position*,
     the one that was *visited last is chosen*.

   - The error reporting is useful for experts, but may be quite misleading for
     non-experts.

       A better error message can be engineered by adding a "catch-all" failure
     point as last alternative of a value production:
     #+BEGIN_SRC scala
       def value: Parser[Any] =
         obj | arr | stringLit | floatingPointNumber | "null" |
           "true" | "false" | failure("illegal start of value")
     #+END_SRC

   - The implementation of the “latest possible” scheme of error reporting uses a
     field named ~lastFailure~ in trait ~Parsers~ to mark the failure that
     occurred at the latest position in the input:
     ~var lastFailure: Option[Failure] = None~

     + This ~lastFailure~ is a ~var~, and it is initialized to ~None~.

     + It is updated in the constructor of the ~Failure~ class:
       #+BEGIN_SRC scala
         case class Failure(msg: String, in: Input)
             extends ParseResult[Nothing] {
           if (lastFailure.isDefined &&
                 lastFailure.get.in.pos <= in.pos)
             lastFailure = Some(this)
         }
       #+END_SRC

     + The field is read by the phrase method, which emits the final error
       message if the parser failed. =TODO= =???=
       #+BEGIN_SRC scala
         def phrase[T](p: Parser[T]) = new Parser[T] {
           lastFailure = None
           def apply(in: Input) = p(in) match {
             case s @ Success(out, in1) =>
               if (in1.atEnd) s
               else           Failure("end of input expected", in1)
             case f : Failure =>
               lastFailure
           }
         }
       #+END_SRC

     + The treatment of ~lastFailure~ is *non-functional*;
       it is updated as a /side effect/ by the constructor of ~Failure~ and
       by the ~phrase~ method itself.

       =TODO= =???=
       A functional version of the same scheme would be possible, but it would
       require threading the ~lastFailure~ value through every parser result, no
       matter whether this result is a ~Success~ or a ~Failure~.

** DONE 33.10 Backtracking versus LL(1) - 761
   CLOSED: [2018-03-06 Tue 13:31]
   - The /parser combinators/ employ /backtracking/ to choose between different
     parsers in an alternative.

   - /Backtracking/ imposes only a few *restrictions* on how to formulate a
     grammar so that it can be parsed.
       Essentially, you just need to *avoid /leftrecursive productions/.* =IMPORTANT=
     For example, ~expr ::= expr "+" term | term.~ will always fail because
     ~expr~ immediately calls itself and thus never progresses any further.

     + footnote:
       There are ways to _avoid stack overflows_ even in the presence of
       /left-recursion/, but this requires a more refined parsing combinator
       framework, which to date has not been implemented.

   - On the other hand, /backtracking/ is *potentially costly* because _the same
     input can be parsed SEVERAL times_. Consider for instance the production:
     ~expr ::= term "+" expr | term.~

   - It is often possible to modify the grammar so that /backtracking/ can be
     avoided. For instance, re-write the above grammar:
     + ~expr ::= term ["+" expr].~
     + ~expr ::= term {"+" term}.~

   - Many languages admit so-called /"LL(1)" grammars/.
       When a /combinator parser/ is formed from such a grammar, *it will never
     /backtrack/,*
       For instance, the grammars for _arithmetic expressions_ and _JSON_ terms
     earlier in this chapter are _BOTH_ LL(1), so the /backtracking/ capabilities
     of the parser combinator framework are never exercised for inputs from these
     languages.

     (=From Jian= However, the defintion in our code before should be modified a
     little bit like the definitions below??? OR this can be done by the
     compiler???)

   - The combinator parsing framework allows you to express the expectation that
     a grammar is LL(1) explicitly, using a new operator ~~!~.

     #+BEGIN_SRC text
       def expr : Parser[Any] =
         term ~! rep("+" ~! term | "-" ~! term)

       def term : Parser[Any] =
         factor ~! rep("*" ~! factor | "/" ~! factor)

       def factor: Parser[Any] =
         "(" ~! expr ~! ")" | floatingPointNumber
     #+END_SRC

     You see the definition of ~factor~ changes the order of alternatives!!!

   - One advantage of an LL(1) parser is that it can use a simpler input
     technique - no need to remember the position before the first alternatives.

     Another advantage is it's more efficient!

** DONE 33.11 Conclusion - 763 =Re-Read=
   CLOSED: [2018-03-06 Tue 14:01]
   - One downside of combinator parsers is that they are _not very efficient_, at
     least not when compared with parsers generated from special purpose tools
     such as Yacc or Bison.

     Two reasons:
     + /backtracking/
       * Solution: use ~~！~ to make the grammar LL(1).

     + combinator parsers is that they *mix* _parser construction_ and _input
       analysis_ in the same set of operations.

       In effect, a parser is generated anew for each input that's parsed.

       * Solution: _Different implementation_ of the parser combinator framework
         -- a parser should be no longer a function from inputs to parse results.
         Instead, *it would be represented as a tree, where every construction
         step was represented as a case class*. For example, /case class/ ~Seq~
         for sequential composition, ~Alt~ for alternative, and so on.
           =TODO= The “outermost” parser method, ~phrase~, could then take this
         symbolic representation of a parser and convert it to highly efficient
         /parsing tables/, using standard parser generator algorithms. =TODO= =???=

       * What's nice of this solution is, from the user point of view, they can
         still write parsers in terms of the old way -- use objects like ~ident~,
         ~floatingPointNumber~, ~~~, ~|~, and so on.

       * The advantage of this scheme with respect to performance is _two-fold_:
         - You can now *factor out* parser construction from input analysis.
           If you were to write: ~val jsonParser = phrase(value)~ and then apply
           ~jsonParser~ to several different inputs, the ~jsonParser~ would be
           *constructed only once, not every time an input is read (like the
           current framework)*.

         - The parser generation can _use efficient parsing algorithms such
           as LALR(1)_. These algorithms usually lead to much faster parsers than
           parsers that operate with /backtracking/.

   - _HOWEVER_, there are reasons for keeping the current parser combinator
     framework around:
     + It is much easier to understand and to adapt than a parser generator

     + the difference in speed would often not matter in practice, unless you
       want to parse very large inputs.

* DONE 34 GUI Programming - 765
  CLOSED: [2018-04-17 Tue 22:00]
  - The applications we'll develop are based on a Scala library that provides
    access to Java's /Swing/ framework of GUI classes.

  - Conceptually, the Scala library
    + *resembles* the underlying /Swing/ /classes/,
    + BUT *hides much of their complexity*.

    This make the GUI applications development with Java' /Swing/ much easier.

  - Even with Scala's *simplifications*, a framework like /Swing/ is quite rich.

  - Suggestion:
    Use IDE autocompletion to help you learn how to use the library!

  - =From Jian=
    Doesn't mention /JavaFX/.
    + I don't know if the ScalaFX is in a good condition of developing?!?

** DONE 34.1 A first Swing application - 765
   CLOSED: [2018-04-17 Tue 13:54]
   #+BEGIN_SRC scala
     // in build.sbt
     // libraryDependencies += "org.scala-lang.modules" %% "scala-swing" % "2.0.3"

     import scala.swing._

     object FirstSwingApp extends SimpleSwingApplication {
       def top = new MainFrame {
         title = "First Swing App"
         contents = new Button {
           text = "Click me"
         }
       }
     }
   #+END_SRC

   - See Appearance:
     Figure 34.1  A simple Swing application: initial (left) and resized (right).

   - =From Jian=
     My way to compile and run it:
     #+BEGIN_SRC bash
       scalac -classpath ./scala-swing_2.12-2.0.3.jar -d app.jar ./FirstSwingApp.scala
       scala ./app.jar
     #+END_SRC

   - Our ~FirstSwingApp~ inherits from a /class/, which already defines a ~main~
     /method/ that contains some setup code for Java's /Swing/ framework.
       The ~main~ /method/ then proceeds to call the ~top~ /method/, which you
     supply: ~def top = new MainFrame {~. It defines /the top-level GUI
     component/.

   - The ~top~ is usually some kind of ~Frame~ -- a window that can contain
     arbitrary data.

   - We choose a ~MainFrame~ as /the top-level component/.
     A ~MainFrame~ is like a normal /Swing/ ~Frame~ except that closing it will
     also close the whole GUI application.

   - /Frames/ have a number of attributes.
     *Two* of the most important are
     + its ~title~, which will be written in the title bar;
     + its ~contents~, which will be displayed in the window itself.

   - In Scala's /Swing/ API, such attributes like ~title~ and ~contents~ of
     /frames/ are modeled as /properties/.

     You know from Section 18.2 that /properties/ are encoded in Scala as pairs
     of /getter and setter methods/.

   - The above code uses the /setter/.
     If you leave the ~title~ assignment out, the window will have an EMPTY
     title.

   - The ~top~ /frame/ is the *root component* of the /Swing/ application.
       It is a ~Container~, which means the further components can be defined in
     it.

   - ~contents = new Button {~
     + Every /Swing container/ has a ~contents~ /property/, which allows you to
       *get* and *set* the _components_ it _contains_.

     + The /getter/ ~contents~ of this /property/ has type ~Seq[Component]~,
       indicating that a _component_ can in general have *SEVERAL* objects as
       its /contents/.

       * /Frames/, however, always have just a *single* _component_ as their
         ~contents~.

     + The /setter/ ~contents_=~ can be used to set and change this _component_.

       For example, in Listing 34.1 a single ~Button~ _constitutes_ the
       ~contents~ of the /top frame/.

     + ~text = "Click me"~ =TODO=
       The /button/ also gets a /title/, saved in ~text~, in this case
       ="Click me."=

** DONE 34.2 Panels and layouts - 768
   CLOSED: [2018-04-17 Tue 14:27]
   - Figure 34.2
     A *reactive* Swing application (with /panels/ and layout): initial (left) after clicks
     (right).
     =From Jian= This Figure 34.2 does NOT correspond to Listing 34.2

   - Code:
     #+BEGIN_SRC scala
       // Listing 34.2 Component assembly on a panel

       import scala.swing._

       object SecondSwingApp extends SimpleSwingApplication {
         def top = new MainFrame {
           title = "Second Swing App"

           val button = new Button {
             text = "Click me"
           }

           val label = new Label {
             text = "No button clicks registered"
           }

           contents = new BoxPanel(Orientation.Vertical) {
             contents += button
             contents += label
             border = Swing.EmptyBorder(30, 30, 10, 30)
           }
         }

       }
     #+END_SRC
     * We'll *add some text* as a _second_ /content element/ to the ~top~ /frame/
       of the application.

     * You saw in the last section that a /frame/ contains *EXACTLY one* child
       /component/.

       This is why we need a ~Panel~ containter/ object, which is the one saved
       in the ~contents~ of the ~MainFrame~.

       Put a /botton/ and a /label/ in this ~Panel~ /container/.

     * ~Panel~ :: a /container/ that *displays* ALL the /components/ it contains
                  _according to some *FIXED* layout rules_.

       - There are a number of different possible layouts that are implemented by
         various /subclasses/ of /class/ ~Panel~.

           In fact, one of the hardest parts of a complex GUI application can be
         getting the layouts right -- it's NOT EASY to come up with something
         that displays reasonably well on all sorts of devices and for all
         window sizes.

     * The /button/ is defined as before.

     * The /label/ is a displayed ~text~ field that *CANNOT* be edited:
       #+BEGIN_SRC scala
         val label = new Label {
           text = "No button clicks registered"
         }
       #+END_SRC

** DONE 34.3 Handling events - 770
   CLOSED: [2018-04-17 Tue 15:46]
   #+BEGIN_SRC scala
     import scala.swing._
     import scala.swing.event._

     object ReactiveSwingApp extends SimpleSwingApplication {

       def top = new MainFrame {

         title = "Reactive Swing App"

         val button = new Button {
           text = "Click me"
         }

         val label = new Label {
           text = "No button clicks registered"
         }

         contents = new BoxPanel(Orientation.Vertical) {
           contents += button
           contents += label
           border = Swing.EmptyBorder(30, 30, 10, 30)
         }

         listenTo(button)

         var nClicks = 0

         reactions += {
           case ButtonClicked(b) =>
             nClicks += 1
             label.text = "Number of button clicks: " + nClicks
         }

       }

     }
   #+END_SRC
   - To achieve the behavior of clicking button and change the count displayed,
     you need to *connect* a /user-input event/ (the button was clicked) with an
     action (the displayed /label/ is *updated*).

     + Java and Scala have fundamentally the *same* *"publish/subscribe"*
       approach to event handling:
       * /Components/ may be /publishers/ and/or /subscribers/.

       * A /publisher/ *publishes* /events/.
         /Publishers/ are also called "event sources,"

       * A /subscriber/ *subscribes* with a /publisher/ to be _notified_ of any
         /published events/.
         /Subscribers/ are also called "event listeners."

     + For instance,
       * a ~Button~ is an /event source/

       * an /event source/ *publishes* an /event/, ~ButtonClicked~ in this case.

       * the /event/ ~ButtonClicked~ indicates that the /button/ was clicked.

   - For Scala,
     + subscribing to an event source ~source~:
       ~listenTo(source)~

     + unsubscribe:
       ~deafTo(source)~

   - *subscribe* is ONLY half of the story.
     Another half is *handling* /events/.

   - *Handling* /events/ _in Java_ involves a fair amount of indirection and
     boilerplate code, which makes /event-handling/ applications _hard to write
     and read_.

   - *Handling* /events/ _in Scala_ is pretty concise and clear in coding:
     add (~+=~) a /partial function/ to ~reactions~.

     + If you want, use ~-=~ to remove an /event/.

   - The ~reactions~ /property/ implements a /collection/, just *like* the
     ~contents~ /property/ does.

   - Some /components/ come with /predefined reactions/.
     For instance,
     a ~Frame~ has a /predefined reaction/ that it will *close* if the user
     presses the _close button_ on the upper right.

   - Conceptually, the handlers installed in ~reactions~ form a /stack/.

     The /handler/ we add is in the top position of this /stack/, and when do
     pattern maching, match from /stack top/ to /stack bottom/.

** DONE 34.4 Example: Celsius/Fahrenheit converter - 773
   CLOSED: [2018-04-17 Tue 16:04]
   #+BEGIN_SRC scala
     import swing._  // import scala.swing._
     import event._  // import scala.swing.event._

     object TempConverter extends SimpleSwingApplication {

       def top = new MainFrame {
         title = "Celsius/Fahrenheit Converter"

         object celsius extends TextField { columns = 5 }

         object fahrenheit extends TextField { columns = 5 }

         contents = new FlowPanel {
           contents += celsius
           contents += new Label(" Celsius = ")
           contents += fahrenheit
           contents += new Label(" Fahrenheit")
           border = Swing.EmptyBorder(15, 10, 10, 10)
         }

         listenTo(celsius, fahrenheit)

         reactions += {
           case EditDone(`fahrenheit`) =>
             val f = fahrenheit.text.toInt
             val c = (f - 32) * 5 / 9
             celsius.text = c.toString

           case EditDone(`celsius`) =>
             val c = celsius.text.toInt
             val f = c * 9 / 5 + 32
             fahrenheit.text = f.toString
         }

       }

     }
   #+END_SRC

   - This is a bi-directional temperature convert.
     =From Jian= Not very precise: Here use ~Int~ rather than ~Double~!

   - ~TextField~ :: a /Swing component/ that lets you edit a single line of text.

   - ~TextField~ object has a _DEFAULT width_, which is given in the ~columns~
     /property/ measured in characters (here set to ~5~ for both fields).

   - The ~contents~ of the ~TempConverter~ object are assembled into a /panel/,
     which includes the
     + *two* ~TextField~ objects: ~celsius~ and ~fahrenheit~

     + *two* ~Label~ objects that explain what the fields are.

     The /panel/ is of class ~FlowPanel~

   - ~FlowPanel~ :: it displays all its elements *one after another*,
                    in one or more rows, depending on the width of the frame.

   - The ~reactions~ of the ~TempConverter~ object are defined by a /handler/
     that contains *two* cases. Each case matches an ~EditDone~ /event/ for one
     of the two text fields.

   - =From Jian=
     When you see the back ticks in /pattern matching/ (e.g. ~case
     EditDone(`celsius`)~), try to recall why do we need it!

** DONE 34.5 Conclusion - 775
   CLOSED: [2018-04-17 Tue 22:00]
   - This chapter has given you a first taste of GUI programming,
     using *Scala's wrappers for the Swing framework*.

   - The Scala wrappers resemble the underlying /Swing/ /classes/, but try to
     *simplify* concepts where possible and make them more uniform.

   - The *simplification* makes extensive use of the properties of the Scala
     language. For instance,
     + Scala's emulation of properties and its operator overloading allow
       convenient property definitions using assignments and ~+=~ operations.

     + Its "everything is an object" philosophy makes it possible to *inherit*
       the ~main~ /method/ from the /superclass/ of /Swing/ GUI application.

       Then the /method/ can thus be *hidden from*
       /USER applications/, including the boilerplate code for setting things up
       that comes with it.

     + Finally, and most importantly, Scala's /first-class functions/ and /pattern
       matching/ make it possible to formulate /event handling/ as the ~reactions~
       component /property/, which greatly simplifies life for the application
       developer.

       =TODO= Learn more about how the Java 8 with Lambda simplify this.

* TODO 35 The SCells Spreadsheet - 777
  - =From Jian=
    This is a whole book comprehensive project -- a spreadsheet application
    ~SCells~.

  - There are several reasons why this task is interesting.
    1. everybody knows spreadsheets, so it is easy to understand what the
       application should do.

    2. spreadsheets are programs that exercise a large range of different
       computing tasks. Many aspects:
       + The visual aspect:
         A spreadsheet is seen as a rich GUI application.

       + The symbolic aspect:
         having to do with formulas and how to parse and interpret them.

       + The calculational aspect:
         Deal with how to update possibly large tables incrementally.

       + The reactive aspect:
         where spreadsheets are seen as programs that react in intricate ways to
         events.

       + The component aspect:
         where the application is constructed as a set of reusable components.

       All these aspects will be treated in depth in this chapter.

** DONE 35.1 The visual framework - 777
   CLOSED: [2018-04-18 Wed 11:59]
   We'll start by writing the _basic visual framework of the application_.

   - You can see that a /spreadsheet/ is a _SCROLLABLE table_.
     + Rows from 0 to 99
     + Columns from A to Z

     You express this in /Swing/ by defining a /spreadsheet/ as a ~ScrollPane~
     containing a ~Table~.

   - Create a project with package ~org.stairwaybook.scells~, which contains
     all the things needed for this application.

   - Listing 35.1 - Code for spreadsheet in Figure 35.1
     #+BEGIN_SRC scala
       package org.stairwaybook.scells

       import swing._

       class Spreadsheet(val height: Int, val width: Int)
           extends ScrollPane {

         val table = new Table(height, width) {
           rowHeight = 25
           autoResizeMode = Table.AutoResizeMode.Off
           showGrid = true
           gridColor = new java.awt.Color(150, 150, 150)
         }

         val rowHeader =
           new ListView((0 until height) map (_.toString)) {
             fixedCellWidth = 30  // points
             fixedCellHeight = table.rowHeight
           }

         viewportView = table
         rowHeaderView = rowHeader

       }
     #+END_SRC
     + ~Spreadsheet~ extends ~ScrollPane~, which gives it
       * scroll-bars at the bottom and right.
       * two sub-components named ~table~ and ~rowHeader~

     + The ~table~ /component/ is an instance of an /anonymous subclass/ of
       /class/ ~scala.swing.Table~.
       * ~rowHeight~: height of a table row _in points_.
       * ~autoResizeMode~: turn auto-sizing the table _off_.
       * ~showGrid~: _display_ a grid of lines between cells.
       * ~gridColor~: set the color of the grid to a _dark gray_.

     + The ~rowHeader~ /component/ contains the row-number headers at the left of
       the spreadsheet (See Figure 35.1). It is a ~ListView~ that displays in
       its elements the strings 0 through 99.

     + The whole spreadsheet is *assembled* _by setting *two* fields_ in
       ~ScrollPane~.
       * The field ~viewportView~ is set to the ~table~,
       * The field ~rowHeaderView~ is set to the ~rowHeader~ list.

     + The difference between the two /views/ ~viewportView~ and ~rowHeaderView~:
       * a /view port/ of a /scroll pane/ is the area that scrolls with the two
         bars,

       * WHEREAS the /row header/ on the left stays fixed when you move the
         horizontal scroll bar.

         - By some quirk, /Swing/ already supplies by default a *column header*
           at the top of the table, so _there's no need to define one
           explicitly_.
           =From Jian= it is also fixed when you move the vertical scroll bar.

   - To try out the rudimentary ~Spreadsheet~ /class/ we just create,
     we need the main program.

   - Listing 35.2 - The main program for the spreadsheet application
     #+BEGIN_SRC scala
       package org.stairwaybook.scells

       import swing._

       object Main extends SimpleSwingApplication {

         def top = new MainFrame {
           title = "ScalaSheet"
           contents = new Spreadsheet(100, 26)
         }

       }
     #+END_SRC

** DONE 35.2 Disconnecting data entry and display - 780
   CLOSED: [2018-04-18 Wed 15:17]
   - Our current spreadsheet show what we type in directly.
     This is good for the basic usage,
     but we also need some facilities like enter formula and display its value.

     To do this we need to override the ~rendererComponent~ /method/ of a
     ~Table~ instance.

     In this section, we won't try to find out the ultimate solution, but only
     the first step: disconnect data entry and display.
       This is the preparation step, later we'll display the processed data.

   - Listing 35.3 - A spreadsheet with a ~rendererComponent~ /method/.
     #+BEGIN_SRC scala
       package org.stairwaybook.scells

       import swing._

       class Spreadsheet(val height: Int, val width: Int)
           extends ScrollPane {

         val cellModel = new Model(height, width)

         import cellModel._

         val table = new Table(height, width) {
           // settings as before...
           override def rendererComponent(isSelected: Boolean,
                                          hasFocus: Boolean,
                                          row: Int,
                                          column: Int): Component =
             if (hasFocus)
               new TextField(userData(row, column))
             else
               new Label(cells(row)(column).toString) {
                 xAlignment = Alignment.Right
               }

           def userData(row: Int, column: Int): String =
             this(row, column) match {
               case null => ""
               case v    => v.toString
             }

         }

         /** rest as before... */
         // val rowHeader = ...
         // viewportView = table
         // rowHeaderView = rowHeader
       }
     #+END_SRC

     + The ~rendererComponent~ /method/ *overrides* a /default method/ in /class/
       ~Table~. It takes *four* parameters:
       1. ~isSelected~ indicate whether the cell has been selected.

       2. ~hasFocus~ indicate if the keyboard events should go into the cell.

       3. ~row~ and ~column~ give the cell's *coordinates*.

     + footnote1: =TODO= =???=
       Although ~this(row, column)~ may look similar to a constructor
       invocation, it is in this case an invocation of the ~apply~ /method/ on
       the current ~Table~ instance.

   - So far so good.
     *BUT* what should be displayed if the cell _does not have focus_?

     In a real spreadsheet this would be the value of a cell.
     *Thus, there are really two tables at work.*
     1. The first _table_, named table contains what the user entered.

     2. The second _"shadow" table_ contains the internal representation of cells
        and what should be displayed.

     Then the ~rendererComponent~:
     + If a given cell _does *NOT* have editing focus_, the /method/ will display
       the element ~cells(row)(column)~.
         _The element *cannot* be edited_, so it should be displayed in a ~Label~
       instead of in an editable ~TextField~.

   - Listing 35.4 - First version of the ~Model~ /class/ -- the _shadow table_
     #+BEGIN_SRC scala
       package org.stairwaybook.scells

       class Model(val height: Int, val width: Int) {

         case class Cell(row: Int, column: Int)

         val cells: Array[Array[Cell]] =
           Array.ofDim[Cell](height, width)

         for { i <- 0 until height
               j <- 0 until width }
         cells(i)(j) = Cell(i, j)
       }
     #+END_SRC

   - It remains to define the internal array of cells. You could do this directly
     in the Spreadsheet class, but it’s generally preferable to separate the view
     of a GUI component from its internal model.

     That’s why in the example above the cells array is defined in a separate
     class named ~Model~.

     The model is integrated into the ~Spreadsheet~ by defining a value ~cellModel~
     of type ~Model~.

     The import clause that follows this val definition makes the members of
     ~cellModel~ available inside ~Spreadsheet~ without having to prefix them.

     Listing 35.4 shows a first simplified version of a ~Model~ /class/.

     The /class/ defines an /inner class/, ~Cell~, and a two-dimensional array,
     cells, of ~Cell~ elements.

     Each element is initialized to be a fresh ~Cell~.

     That’s it. If you compile the modified ~Spreadsheet~ /class/ with the
     ~Model~ /class/ and run the ~Main~ application you should see a window as
     in Figure 35.2.

   - The objective of this section was to arrive at a design where the displayed
     value of a cell is different from the string that was entered into it.

     This objective has clearly been met, albeit in a very crude way.

     In the new spreadsheet you can enter anything you want into a cell, but it
     will always display just its coordinates once it loses focus.

     Clearly, we are not done yet.

** DONE 35.3 Formulas - 783
   CLOSED: [2018-04-18 Wed 15:17]
   - =From Jian=
     We ONLY define /formulas/ in this section.

     Combine the defined /formulas/ with our ~Spreadsheet~ will be done in later
     sections.

   - In reality, a spreadsheet cell holds *two* things:
     + An actual /value/
     + A /formula/ to compute this value.

   - There are three types of /formulas/ in a spreadsheet:
     1. /Numeric values/ such as 1.22, 3, or 0.

     2. /Textual labels/ such as _Annual sales_, _Deprecation_, or _total_.

     3. /Formulas/ that compute a NEW /value/ from the contents of /cells/, such
        as ~=add(A1,B2)~, or ~=sum(mul(2, A2), C1:D16)~
        + A /formula/ that computes a /value/ *always*
          1. starts with an _equals sign_;
          2. the _equals sign_ is followed by an _arithmetic expression_.

   - Listing 35.3 - Classes representing /formulas/
     #+BEGIN_SRC scala
       package org.stairwaybook.scells

       trait Formula

       // For cell coordinates such as `A3`
       case class Coord(row: Int, column: Int) extends Formula {
         override def toString = ('A' + column).toChar.toString + row
       }

       // For cell ranges such as `A3:B17`
       case class Range(c1: Coord, c2: Coord) extends Formula {
         override def toString = c1.toString + ":" + c2.toString
       }

       // For floating-point such as `3.1415`
       case class Number(value: Double) extends Formula {
         override def toString = value.toString
       }

       // For textual labels such as `Deprecation`
       case class Textual(value: String) extends Formula {
         override def toString = value
       }

       // For function application such as `sum(A1, A2)`
       case class Application(function: String,
                              arguments: List[Formula]) extends Formula {
         override def toString =
           function + arguments.mkString("(", ",", ")")
       }

       object Empty extends Textual("")
     #+END_SRC

** DONE 35.4 Parsing formulas - 785
   CLOSED: [2018-04-18 Wed 17:23]
   - ~FormulaParsers~: From user input to the ~Formula~'s we defined.
     #+BEGIN_SRC scala
       package org.stairwaybook.scells

       import scala.util.parsing.combinator.RegexParsers

       object FormulaParsers extends RegexParsers {
         def ident: Parser[String] = """[a-zA-Z_]\w*""".r

         def decimal: Parser[String] = """-?\d+(\.\d*)?""".r

         def cell: Parser[Coord] =
           """[A-Za-z]\d+""".r ^^ { s =>
             val column = s.charAt(0).toUpper - 'A'
             val row = s.substring(1).toInt
             Coord(row, column)
           }

         def range: Parser[Range] =
           cell ~ ":" ~ cell ^^ {
             case c1 ~ ":" ~ c2 => Range(c1, c2)
           }

         def number: Parser[Number] =
           decimal ^^ (d => Number(d.toDouble))

         def application: Parser[Application] =
           ident ~ "(" ~ repsep(expr, ",") ~ ")" ^^ {
             case f ~ "(" ~ ps ~ ")" => Application(f, ps)
           }

         def expr: Parser[Formula] =
           range | cell | number | application

         def textual: Parser[Textual] =
           """[^=].*""".r ^^ Textual

         def formula: Parser[Formula] =
           number | textual | "=" ~> expr

         def parse(input: String): Formula =
           parseAll(formula, input) match {
             case Success(e, _) => e
             case f: NoSuccess  => Textual("[" + f.msg + "]")
           }
       }
     #+END_SRC
     + Restrictions:
       1. The ~cell~ parser allows *only* column coordinates consisting of a
          *single* letter.
          _You can try to generalize it as an exercise_ =TODO= =TODO=

       2. The ~expr~ doesn't differentiate the _toplevel_ expression and the
          _inner_ expression.
          =From Jian= =Need Test=
          #+BEGIN_SRC scala
            def exprToplevel: Parser[Formula] =
              "=" ~> expr

            def expr: Parser[Formula] =
              range | cell | number | application

            def formula: Parser[Formula] =
              number | textual | exprToplevel
          #+END_SRC

   - That's everything there is to parsing formulas.
     The only thing that remains is to *integrate* the parser into the
     spreadsheet:
     + *ENRICH* the ~Cell~ /class/ by a ~formula~ field.
       #+BEGIN_SRC scala
         case class Cell(row: Int, column: Int) {
           var formula: Formula = Empty
           override def toString = formula.toString
         }
       #+END_SRC

     + Add the "formula parsing" as a *reaction* to the user's input into a
       /cell/.

       A completed /cell input/ is *modeled* in the /Swing/ library by a
       ~TableUpdated~ /event/.

       The ~TableUpdated~ /class/ is contained in package ~scala.swing.event~.
       The /event/ is of the form:
       #+BEGIN_SRC scala
         case class TableUpdated(override val source: Table, range: Range, column: Int)
             extends TableChange(source)
       #+END_SRC
       * the ~range~ here, for this project, we always use ~Range[Int]~ to
         represent a sequence of /rows/.

       #+BEGIN_SRC scala
         package org.stairwaybook.scells

         import swing._
         import event._

         class Spreadsheet(val height: Int, val width: Int)
             extends ScrollPane {

           val table = new Table(height, width) {
             // ...
             reactions += {
               case TableUpdated(table, rows, column) =>
                 for (row <- rows)
                   cells(row)(column).formula =
                     FormulaParsers.parse(userData(row, column))
             }
           }

         }
       #+END_SRC

** DONE 35.5 Evaluation - 790
   CLOSED: [2018-04-18 Wed 18:20]
   Evaluate the /formulas/

   - We create a /trait/ ~Evaluator~

   - ~Evaluator~ and ~Cell~ have mutual dependencies.
     + When the ~evaluate~ /method/ of ~Evaluator~ sees a ~Coord(row, column)~
       ~Formula~, it will try to get the value of the /cell/ at (row, column).

     + The ~Cell~'s ~value~ /method/ is defined as ~evaluate(this.formula)~.
       A reminder: ~formula~ is a field of ~Cell~.

   - =TODO= =REVIEW= =???= =???=
     A good way to express such /mutual dependencies/ between /classes/ was
     shown in Chapter 29:
     you use inheritance in one direction and /self types/ in the other.
     =???= =???= =???=    *IMPORTANT*

     + /Class/ ~Model~ *inherits* from ~Evaluator~ and thus _gains_ access to its
       ~evaluation~ /method/.

     + ~trait Evaluator { this: Model => ...~
       In this way, the ~this~ value _inside_ /class/ ~Evaluator~ is assumed to
       be ~Model~ and the ~cells~ array is accessible by writing either ~cells~
       or ~this.cells~.

   - The core /method/ ~evaluate~:
     #+BEGIN_SRC scala
       def evaluate(e: Formula): Double = try {
         e match {
           case Coord(row, column) => cells(row)(column).value
           case Number(v)          => v
           case _: Textual         => 0

           case Application(function, arguments) =>
             val argvals = arguments flatMap evalList
             operations(function)(argvals)
         }
       } catch {
         case _: Exception => Double.NaN
       }
     #+END_SRC
     + The current ~Cell~ /class/:
       #+BEGIN_SRC scala
         // class Model(val height: Int, val width: Int) extends Evaluator {
         case class Cell(row: Int, column: Int) {
           var formula: Formula = Empty
           override def toString: String = formula.toString
           def value: Double = evaluate(formula)
         }
         // }
       #+END_SRC

     + Use ~try ... catch~ to deal with the error happend in evaluation.
       The ~catch~ part is oversimplified -- you can try to refine it if you want.

     + The ~Application~ *case*
       * uses the ~operations~ map to get functions by their names.
         #+BEGIN_SRC scala
           // two members of `Evaluator`
           type Op = List[Double] => Double
           val operations = new collection.mutable.HashMap[String, Op]
         #+END_SRC

       * Q: Why do we use ~flatMap~?

         A: In a spreadsheet, ~sum(A1:A3, 1.0, C7)~ is the same as
            ~sum(A1, A2, A3, 1.0, C7)~ and ~A1:A3~ is actually a list.

            We allow both syntax, but for real calculation, we use the form of
            latter one. Therefore, when we see the form of the parameters like the
            formmer, we need to flat it first.

            We use ~evalList~ to get back ~List[Double]~ value from a /formula/,
            and then flat it.

     + From a ~Range~ element to a list of ~Double~, we need to something.
       This work is done by the ~reference~ /method/, which is recursion for its
       ~Application~ *case* in the  pattern matching/.

     + The ~references~ /method/ is actually *more general than needed right now*
       in that it computes the list of /cells/ referenced by _ANY_ sort of
       /formula/, *not just* a ~Range~ /formula/.

       =TODO= =IMPORTANT=
         It will turn out later that the added functionality is needed to
       compute the sets of /cells/ that need updating.

   - The complete ~Evaluator~ definition:
     #+BEGIN_SRC scala
       trait Evaluator { this: Model =>

         def evaluate(e: Formula): Double = try {
           e match {
             case Coord(row, column) =>
               cells(row)(column).value

             case Number(v) =>
               v

             case _: Textual =>
               0

             case Application(function, arguments) =>
               val argvals = arguments flatMap evalList
               operations(function)(argvals)
           }
         } catch {
           case _: Exception => Double.NaN
         }

         type Op = List[Double] => Double

         val operations = new collection.mutable.HashMap[String, Op]

         private def evalList(e: Formula): List[Double] = e match {
           case Range(_, _) => references(e) map (_.value)
           case _           => List(evaluate(e))
         }

         def references(e: Formula): List[Cell] = e match {
           case Coord(row, column) =>
             List(cells(row)(column))

           case Range(Coord(r1, c1), Coord(r2, c2)) =>
             for (row <- (r1 to r2).toList; column <- c1 to c2)
               yield cells(row)(column)

           case Application(_, arguments) =>
             arguments flatMap references

           case _ =>
             Nil
         }
     #+END_SRC

** TODO 35.6 Operation libraries - 793
   - Listing 35.8 - A library for arithmetic operations
     #+BEGIN_SRC scala
       package org.stairwaybook.scells

       trait Arithmetic { this: Evaluator =>
         operations += (
           "add"  -> { case List(x, y) => x + y },
           "sub"  -> { case List(x, y) => x - y },
           "div"  -> { case List(x, y) => x / y },
           "mul"  -> { case List(x, y) => x * y },
           "mod"  -> { case List(x, y) => x % y },
           "sum"  -> { xs => (0.0 /: xs)(_ + _) },
           "prod" -> { xs => (1.0 /: xs)(_ * _) }
         )
       }
     #+END_SRC

** TODO 35.7 Change propagation - 796
   - Listing 35.9 - the finished spreadsheet component
     #+BEGIN_SRC scala
       package org.stairwaybook.scells

       import swing._
       import event._

       class Spreadsheet(val height: Int, val width: Int)
           extends ScrollPane {

         val cellModel = new Model(height, width)

         import cellModel._

         val table = new Table(height, width) {
           ... // settings as in Listing 35.1

           override def rendererComponent(
             isSelected: Boolean, hasFocus: Boolean,
             row: Int, column: Int) =
             ... // as in Listing 35.3

           def userData(row: Int, column: Int): String =
             ... // as in Listing 35.3

           reactions += {
             case TableUpdated(table, rows, column) =>
               for (row <- rows)
                 cells(row)(column).formula =
                   FormulaParsers.parse(userData(row, column))

             case ValueChanged(cell) =>
               updateCell(cell.row, cell.column)
           }

           for (row <- cells; cell <- row) listenTo(cell)
         }

         val rowHeader = new ListView(0 until height) {
           fixedCellWidth = 30
           fixedCellHeight = table.rowHeight
         }

         viewportView = table
         rowHeaderView = rowHeader
       }
     #+END_SRC
** TODO 35.8 Conclusion - 800

* DONE Appendix A. Scala Scripts on Unix and Windows - 802
  CLOSED: [2017-10-03 Tue 21:25]
  - In a Unix flavor system:
    #+BEGIN_SRC bash
      #!/bin/sh
      exec scala "$0" "$@"
      !#
      // Say hello to the first argument
      println("Hello, " + args(0) + "!")
    #+END_SRC
    1. ~$ chmod +x helloarg~
    2. ~$ ./helloarg globe~

    The output is =Hello, globe!=

    =From Jian=
    Start the JVM takes sometime.
    If you want to run this script for multiple times, read
    https://alvinalexander.com/scala/how-make-scala-shell-scripts-run-faster-with-savecompiled-argument
    However, this is NOT a real solution, just a kind of not-so-good walkaround.

  - =Question from Jian= =TODO= =???=
    Why can't I use ~#!/usr/bin/env bash~ as the first line?????

  - In Windows:
    1. Create a =helloarg.bat= file

    2. Add the code below to the top of this file, and then the scala code
       #+BEGIN_SRC bat
         ::#!
         @echo off
         call scala %0 %*
         goto :eof
         ::!#
       #+END_SRC

       =TODO=
       =From Jian= I never tried this. Try it later.

* Glossary - 803
* Bibliography - 819
* About the Authors - 822
* Index - 823
* Tips (Added by Jian)
  + You can leave off one pair of parentheses when passing a tuple to a function
    that takes a single argument. ---- footnote 1 - page 624

    For example, ~Some(a, b)~ means the same as ~Some((a, b))~

* TodoList (Added by Jian)
