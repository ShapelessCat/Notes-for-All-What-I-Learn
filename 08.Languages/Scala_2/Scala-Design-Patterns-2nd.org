#+TITLE: Scala Design Patterns
#+VERSION: 2018, 2nd
#+AUTHOR: Ivan Nikolov
#+STARTUP: entitiespretty
#+STARTUP: indent
#+STARTUP: overview

* TODO Preface - 1
** Who this book is for
** What this book covers
** To get the most out of this book
*** Download the example code files
*** Conventions used

** Get in touch
*** Reviews

* DONE 1. The Design Patterns Out There and Setting Up Your Environment - 7
  CLOSED: [2018-08-14 Tue 01:27]
** DONE Design patterns
   CLOSED: [2018-05-29 Tue 11:54]
   - Design Patterns (The formal definition) ::
        A design pattern is a reusable solution to a recurring problem in
        software design. It is not a finished piece of code but a template that
        helps to solve a particular problem or family of problems.

   - Feature-rich languages might not even need a /design pattern/, while others
     still do.

   - The lack or existence of a certain functionality within aprogramming language
     also makes it able to implement additional /design patterns/ that others
     cannot. The opposite is also valid -- it might not be able to implement
     things that others can.

*** DONE Scala and design patterns
    CLOSED: [2018-05-29 Tue 11:54]
    - The hybrid nature of the Scala makes some of the /traditional object-oriented
      design patterns/ _obsolete_, or possible, using _other cleaner techniques_.

*** DONE The need for design patterns and their benefits
    CLOSED: [2018-05-29 Tue 11:54]

** DONE Design pattern categories - =RE-READ= =IMPORTANT=
   CLOSED: [2018-05-29 Tue 12:45]
   - Even if there are many different /design patterns/, they can all be grouped
     in the following:
     + Creational

     + Structural

     + Behavioral

     + Functional

     + Scala-specific design patterns
       * Some of these /design patterns/ can be assigned to the previous groups.
         - They can either be _additions_ or _replacements_ of the already
           existing ones.

         - They are typical to Scala and take advantage of some advanced language
           features or simply features not available in other languages.)

   - The _first three groups_ contain the famous /Gang of Four design patterns/.

     The rest, even if they can be assigned to one of the first three groups, will
     be specific to Scala and functional programming languages.

     =TODO=
     In the next few subsections, we will explain the main characteristics of
     the listed groups and briefly present the actual design patterns that fall
     under them.

*** TODO Creational design patterns
    - The /creational design patterns/ deal with /object creation mechanisms/.

      + *PURPOSE*: create objects in a way that is suitable to the current situation,
        which could lead to unnecessary complexity and the need for extra
        knowledge if they were not there.

      + The main ideas behind the /creational design patterns/ are as follows:
        * *Knowledge encapsulation* about the concrete classes

        * *Hiding details* about the actual creation and how objects are combined

**** TODO The abstract factory design pattern
**** TODO The factory method design pattern
**** TODO The lazy initialization design pattern
**** TODO The singleton design pattern
**** TODO The object pool design pattern
**** TODO The builder design pattern
**** TODO The prototype design pattern

*** TODO Structural design patterns
    - /Structural design patterns/ exist in order to help establish the
      relationships between different entities in order to _form larger
      structures_.

        They define how each component should be structured so that it has very
      flexible interconnecting modules that can work together in a larger
      system.

    - The main features of /structural design patterns/ include the following:
      + The use of composition to combine the implementations of multiple objects

      + Help build a large system made of various components by maintaining a high
        level of flexibility

**** TODO The adapter design pattern
**** TODO The decorator design pattern
**** TODO The bridge design pattern
**** TODO The composite design pattern
**** TODO The facade design pattern
**** TODO The flyweight design pattern
**** TODO The proxy design pattern

*** TODO Behavioral design patterns
    - /Behavioral design patterns/ increase *communication flexibility* between
      objects based on the specific ways they interact with each other.

      Here,
      + /creational patterns/ mostly describe a moment in time during creation,
      + /structural patterns/ describe a more or less static structure,
      + /behavioral patterns/ describe a process or flow.

      They simplify this flow and make it more understandable.

    - The main features of /behavioral design patterns/ are as follows:
      + What is being described is a process or flow

      + The flows are simplified and made understandable

      + They accomplish tasks that would be difficult or impossible to achieve
        with objects

**** The value object design pattern
**** The null object design pattern
**** The strategy design pattern
**** The command design pattern
**** The chain of responsibility design pattern
**** The interpreter design pattern
**** The iterator design pattern
**** The mediator design pattern
**** The memento design pattern
**** The observer design pattern
**** The state design pattern
**** The template method design pattern
**** The visitor design pattern

*** DONE Functional design patterns
    CLOSED: [2018-05-29 Tue 12:37]
**** DONE Monoids
     CLOSED: [2018-05-29 Tue 12:29]
     - Concept

     - What is important about /monoids/ is that
       + they give us the possibility to work with many different types of values
         in a common way.

       + They allow us to convert pairwise operations to *work with sequences*;
       + the /associativity/ gives us the possibility for *parallelization*
       + the /identity element/ allows us to know what to do with empty lists.

       /Monoids/ are *GREAT to EASILY* _describe and implement *aggregations*._

**** DONE Monads
     CLOSED: [2018-05-29 Tue 12:37]
     - /Monads/ are algebraic structures that REPRESENT _computations as sequences
       of steps_.

     - /Monads/ are useful for
       + building pipelines

       + adding operations with side effects cleanly to a language where everything
         is immutable

       + implementing compositions.
         =From Jian= Especially for data structures with embedded sub-structures

**** DONE Functors
     CLOSED: [2018-05-29 Tue 12:34]
     - This concept comes from /category theory/.

     - For now, you could remember that /functors/ are things that can allow us
       to *lift* a function of the /type/ ~A => B~ to a function of the /type/
       ~F[A] => F[B]~.

*** DONE Scala-specific design patterns
    CLOSED: [2018-05-29 Tue 12:45]
**** The lens design pattern
**** The cake design pattern
**** Pimp my library
**** Stackable traits
**** The type class design pattern
**** Lazy evaluation
**** Partial functions
**** Implicit injection
**** Duck typing
**** Memoization

** DONE Choosing a design pattern - =Re-REAd= =IMPORTANT=
   CLOSED: [2018-08-14 Tue 01:19]
   - About how to *use* /a design pattern/ or *combine* /design patterns/, you
     should consider (this is BY NO MEANS an exhaustive list of questions):
     + Is this piece of code
       going to be _fairly static_ OR will it _change in the future_?

     + Do we have to _dynamically decide_ what /algorithms/ to use?

     + Is our code going to be _used by others_?

     + Do we have an agreed /interface/?

     + _What libraries_ are we planning to use, if any?

     + Are there any _special performance requirements or limitations_?

   - In the rest of the chapters, we will try to give specific recommendations
     about _when a /design pattern/ should and should NOT be used._ =TODO=

     =IMPORTANT=
     They should help you ask the right questions and take the right decision
     before going on and writing code.

** DONE Setting up the development environment
   CLOSED: [2018-08-14 Tue 01:26]
*** DONE Installing Scala
    CLOSED: [2018-05-29 Tue 13:12]
**** DONE Tips for installing Scala manually
     CLOSED: [2018-05-29 Tue 13:12]
**** DONE Tips for installing Scala using SBT
     CLOSED: [2018-05-29 Tue 13:12]

*** DONE Scala IDEs
    CLOSED: [2018-05-29 Tue 13:13]
*** DONE Dependency management
    CLOSED: [2018-08-14 Tue 01:22]
**** SBT
**** Maven
**** SBT versus Maven

** DONE Summary
   CLOSED: [2018-08-14 Tue 01:26]
   - In MANY CASES, we could _use Scala's features_
     in order to
     _make a pattern OBSOLETE, SIMPLER, or DIFFERENT to implement compared to
     the classical case like in old Java (Before Java 8)_.

* TODO 2. Traits and Mixin Compositions - 34
  - Clarify some Scala concepts
    * which can be used to implement some /design patterns/,
    * because of their existence (=from Jian= their expressiveness), Scala doesn't
      need some /design patterns/.

  - /Traits/ and /mixin compositions/ provide the developer with a possibility to
    * share already implemented functionality
      OR
    * define interfaces for classes

  - We will go through the following main topics in this chapter:
    * /Traits/
    * /Mixin compositions/
    * /Multiple inheritance/
    * /Linearization/
    * Testing /traits/
    * /Traits/ vs. /classes/

** DONE Traits
   CLOSED: [2022-10-11 Tue 11:31]
   - Different perspectives of /traits/ in Scala:
     * /interfaces/ in other languages
     * abstract classes with ONLY /parameter-less constructors/
       + This _ONLY /parameter-less constructors/_ restriction is removed in Scala 3.

   - In the following few sections,
     =TODO=
     we will see the /traits/
     * from different points of view
       AND
     * try to give you some ideas about how they can be used.

*** DONE Traits as interfaces
    CLOSED: [2022-10-11 Tue 11:31]
    - mixin :: a /trait/ that contains some concrete implementation(s)

    - =from Jian=
      It seems we can category /traits/, *in my words*, as :
      * interface traits
      * mixin traits (similar to /abstract class/ in other languages, espectially
        in Scala 3)

    - Example _these /traits/ are used in the next section -- Mixin compositions_:
      #+BEGIN_SRC scala
        trait Alarm {  // from Jian: interface trait
          def trigger(): String
        }

        trait Notifier {  // from Jian: mixin trait
          val notificationMessage: String

          def printNotification(): Unit = {
            System.out.println(notificationMessage)
          }

          def clear()
        }
      #+END_SRC

    - Moreover, the /traits/ can _require_ a /class/ that mix it in to _have a specific
      variable inside it_ (i.e. the ~notificationMessage~ in ~Notifier~).
      This is somewhat *similar to /abstract classes/ in other languages*.

**** DONE Mixing in traits with variables
     CLOSED: [2022-10-11 Tue 11:31]
     When a /trait/ requires the /class/ that mix it in to _hava a specific
     variable_, pass the variable (=from Jian= of course, must be a /property/,
     ~var~ or ~val~, corresponding to the one in the given /trait/) to the
     /constructor/ of this /class/ would satisfy this requirement.
     #+BEGIN_SRC scala
       class NotifierImpl(val notificationMessage: String) extends Notifier {
         override def clear(): Unit = System.out.println("cleared")
       }
     #+END_SRC

     - Here you apply ~val~ on ~notificationMessage~, then it is a part of the
       /class/ as a /field/, and a /getter/ will be generated for it.
       * *required*:
         1. ~val~
         2. same name ~notificationMessage~

     - If there is NO ~val~, we need to have an ~override val notificationMessage~
       assignment in the class body.
       * for implementing /trait field/, ~override~ is *optional*
         =from Jian= I think keep using ~override~ is a good practice -- a hint
                     to its future maintainer for its origin.

     - If we explicitly use ~val~ (or ~var~), the compiler will create a /field/
       with a /getter/ with the *same scope* as the parameter.

       If we just have the parameter (without ~val~ or ~var~), a private /field/
       will be created _only if_ the parameter is used _outside_ the /constructor
       scope/, for example, in a /method/.
       * =from Jian=: The original text uses *a field and internal getter*
                      I can't see the /getter/ when using ~java -p~ to check the
                      class file.

       * For completeness,
         /case classes/ automatically have the ~val~ keyword prepended to
         parameters.

*** DONE Traits as classes
    CLOSED: [2022-10-11 Tue 11:31]
    - /Traits/ can also be seen _from the perspective of_ /classes/
      (=from Jian= *abstract* /classes/).
      In this case, they
      * have to *implement ALL their methods*
      * have ONLY ONE /constructor/ that _does *NOT* accept *ANY* parameters_.
        =from Jian= This will be removed in Scala 3.

    - Example:
      #+BEGIN_SRC scala
        trait Beeper {
          def beep(times: Int): Unit =
            (1 to times).
              map(i => s"Beep number: $i").
              foreach(println)
        }

        object BeeperRunner {
          val TIMES = 10

          def main(args: Array[String]): Unit = {
            // Because you can't instantiate a `trait`,
            // you CANNOT write `new Beeper` without the following `{}`
            val beeper = new Beeper {}
            beeper beep TIMES
          }
        }
      #+END_SRC

*** DONE Extending classes
    CLOSED: [2022-10-11 Tue 11:31]
    /Traits/ *can* extend /classes/.

    - Example:
      #+BEGIN_SRC scala
        abstract class Connector {
          def connect()
          def close()
        }

        trait ConnectorWithHelper extends Connector {
          def findDriver(): Unit = {
            println("Find driver called.")
          }
        }

        class PgSqlConnector extends ConnectorWithHelper {
          override def connect(): Unit = {
            println("Connected...")
          }
          override def close(): Unit = {
            println("Closed...")
          }
        }
      #+END_SRC

      However, Scala will put a *limit* to some cases:
      It is forbided that extends multiple /traits/ that some of the /traits/
      extend *unrelated* (NOT in the SAME /inheritance chain/) /classes/.

*** DONE Extending traits
    CLOSED: [2022-10-11 Tue 11:31]
    /Traits/ can *extend* /traits/.

    - Example:
      #+BEGIN_SRC scala
        trait Ping {
          def ping(): Unit = {
            System.out.println("ping")
          }
        }

        trait Pong {
          def pong(): Unit = {
            System.out.println("pong")
          }
        }

        trait PingPong extends Ping with Pong {
          def pingPong(): Unit = {
            ping()
            pong()
          }
        }

        object Runner extends PingPong {
          def main(args: Array[String]): Unit = {
            pingPong()
          }
        }
      #+END_SRC
      * This is just an illstration example.
        IN PRACTICE, we should let ~Runner~ extend ~Ping~ and ~Pong~ DIRECTLY.
        + The usefulness of /extend traits/ is not significant in this example.

        + =IMPORTANT=
          /Extend traits/ is useful in a /design pattern/ called /Stackable Traits/.
          =TODO= =LATER=

    - =from Jian=
      This book didn't metion the *forbided* /circular extension/!!!

** TODO Mixin compositions
   Topics
   - Extends a /class/ with *multiple* /traits/.

   - Sub-topics:
     How *multiple* /traits/ can be
     * mixed in a SPECIFIC /class/
     * used to create anonymous classes with some specific functionality

*** DONE Mixing traits in
    CLOSED: [2019-06-06 Thu 10:59]
    - ~with~ is NOT commutative, the order matters!

    - =from Jian=
      Scala 3 (Dotty) will support /intersection type/, which have commutative
      property.
      * Reference: https://contributors.scala-lang.org/t/proposal-to-add-intersection-types-to-the-language/2351/3

*** DONE Composing
    CLOSED: [2018-10-06 Sat 01:27]
    Composing at _creation time_ gives us an opportunity to CREATE /anonymous
    classes/ *without* the need to explicitly define them with a name.

**** DONE Composing simple traits
     CLOSED: [2019-06-06 Thu 11:50]
     Compose simple /traits/, which do NOT extend other /traits/ or /classes/:
     #+BEGIN_SRC scala
       class Watch(val brand: String, initialTime: Long) {
         def getTime(): Long = System.currentTimeMillis() - initialTime
       }

       object WatchUser {
         def main(args: Array[String]): Unit = {
           val expensiveWatch = new Watch("expensive brand", 1000L) with Alarm with Notifier {
             override def trigger: String = "The alarm was triggered."

             override def clear(): Unit = {
               System.out.println("Alarm cleared.")
             }

             override val notificationMessage: String = "Alarm is running!"
           }

           val cheapWatch = new Watch("cheap brand", 1000L) with Alarm {
             override def trigger: String = "The alarm was triggered."
           }

           // show some watch usage.
           System.out.println(expensiveWatch.trigger)
           expensiveWatch.printNotification()
           System.out.println(s"The time is ${expensiveWatch.getTime()}.")
           expensiveWatch.clear()
           System.out.println(cheapWatch.trigger)
           System.out.println(s"${cheapWatch.brand} watches cannot manually stop the alarm...")
         }
       }
     #+END_SRC
     =from Jian= The original code does neither use ~brand~, nor create a /field/
     for it. This is not reasonable -- I modified the code and convert ~brand~ to
     a ~val~ field.

**** DONE Composing complex traits
     CLOSED: [2018-10-06 Sat 01:02]
     - If a trait and no other trait up the inheritance chain extends a specific
       class explicitly, then things will be pretty simple and nothing change
       much.

     We defined ~ConnectorWithHelper~ /trait/ before, and it extends the
     /abstract class/ ~Connector~. Now let's use ~ConnectorWithHelper~:
     #+BEGIN_SRC scala
       object ReallyExpensiveWatchUser {
         def main(args: Array[String]): Unit = {
           val reallyExpensiveWatch =
             new Watch("really expensive brand", 1000L)
                 with ConnectorWithHelper {
               override def connect(): Unit = {
                 System.out.println("Connected with another connector.")
               }

               override def close(): Unit = {
                 System.out.println("Closed with another connector.")
               }
             }

           System.out.println("Using the really expensive watch.")
           reallyExpensiveWatch.findDriver()
           reallyExpensiveWatch.connect()
           reallyExpensiveWatch.close()
         }
       }
     #+END_SRC

     You compile the code above and will see a /compilation error/ like:
     #+BEGIN_SRC text
       Error:(36, 80) illegal inheritance; superclass Watch
        is not a subclass of the superclass Connector
        of the mixin trait ConnectorWithHelper
           val reallyExpensiveWatch = new Watch("really expensive brand", 1000L)
       with ConnectorWithHelper {
       ^
     #+END_SRC

     ~Watch~ is a /class/ and it is NOT the /subclass/ of ~Connector~, thus it
     *CANNOT* extends a /trait/ that extends ~Connector~ -- for here,
     ~ConnectorWithHelper~ is the one.

     This is a case that how Scala *limit* multiple inheritance in order to prevent
     dangerous errors from happening. (=from Jian= "limit" not "forbid" --
     /trait/ based /mutiple inheritance/ is still a /mutiple inheritance/).

**** DONE Composing with self-types
     CLOSED: [2018-10-06 Sat 01:27]
     We can *enforce* a /trait/ to be /mixed into/ a /class/ that also has another
     /trait/ or /multiple traits/ mixed into it.

     - Example:
       #+BEGIN_SRC scala
         trait AlarmNotifier {
           this: Notifier =>

           def trigger(): String
         }
       #+END_SRC
       + Of course, ~this~ here must be ~AlarmNotifier~ itself, but it is also a
         ~Notifier~.

       + In the preceding code, we've shown a /self-type/.
         * The highlighted piece of code brings all the /methods/ of ~Notifier~
           to the scope of our new ~trait~
           and
         * it also requires that ANY /class/ that /mixes in/ ~AlarmNotifier~ should
           *also* /mix in/ ~Notifier~. Otherwise, a compilation error will occur.

       + Instead of this, we can use ~self~ and then refer to the ~Notifier~ /methods/
         inside ~AlarmNotifier~ by typing, for example, ~self.printNotification()~.

         =Urgent= =TODO= =IMPORTANT= =???= =Experiment=
         =from Jian= Does this mean if we write ~self: Notifier =>~, we can, in
         the body of this /trait/, use ~self~ to refer ~Notifier~ and use ~this~
         to refer ~AlarmNotifier~???

     - Code use the ~AlarmNotifier~ in the right way:
       #+BEGIN_SRC scala
         object SelfTypeWatchUser {
           def main(args: Array[String]): Unit = {
             //// uncomment to see the self-type error.
             // val watch = new Watch("alarm with notification", 1000L) with AlarmNotifier
             val watch = new Watch("alarm with notification", 1000L) with
                 AlarmNotifier with Notifier {
               override def trigger(): String = "Alarm triggered."
               override def clear(): Unit = System.out.println("Alarm cleared.")
               override val notificationMessage: String = "The notification."
             }
             System.out.println(watch.trigger())
             watch.printNotification()
             System.out.println(s"The time is ${watch.getTime()}.")
             watch.clear()
           }
         }
       #+END_SRC

     - Multiple /traits/ /self-types/ are also allowed, just use ~with~.

     - /Self-types/ are a key part of the /cake design pattern/, which is used for
       /dependency injection/.
       =TODO= More interesting cases later in this book!

*** DONE Clashing traits - =TODO= NOTES
    CLOSED: [2018-10-06 Sat 01:36]
    Resolve the question of _mix in_ /traits/ that have /methods/ with
    *IDENTICAL* /signatures/.

**** TODO Same signatures and return types
**** TODO Same signatures and different return types traits
**** TODO Same signatures and return types mixins
**** TODO Same signatures and different return types mixins

** DONE Multiple inheritance
   CLOSED: [2018-10-07 Sun 15:57]
*** DONE The diamond problem
    CLOSED: [2018-10-07 Sun 15:57]
    In Scala, the ambiguity of /the diamond problem/ is resolved -- use
    /linearization/. Even though, it is still prone to errors (even the *order*
    of /traits/ matters). For example,
    #+BEGIN_SRC scala
      trait A {
        def hello(): String = "Hello from A"
      }

      trait B extends A {
        override def hello(): String = "Hello from B"
      }

      trait C extends A {
        override def hello(): String = "Hello from C"
      }

      trait D extends B with C {
        override def hello(): String = "Hello from C"
      }

      object Diamond extends D {
        def main(args: Array[Strng]): Unit {
          System.our.println(hello())
        }
      }
    #+END_SRC
    - this print ="Hello from C"=
    - if we change the order by which ~D~ was implemented to ~trait D extends C with B~

*** DONE The limitations
    CLOSED: [2018-10-07 Sun 15:26]
    Scala *multiple inheritance limitations*:
    /Multiple inheritance/ in Scala is _achieved using_ /traits/
    and
    it follows the rules of /linearization/.

    - In the inheritance hierarchy, if there is a /trait/ that EXPLICITLY =???=
      extends a /class/, the /class/ that /mixes in/ this /trait/ *must also be
      a /subclass/ of the /trait/ parent.* This means that when /mixing in/
      /traits/ that extend /classes/, they must all have the same parent.

    - It is *not possible* to mix /traits/ in, which define or declare /methods/ with
      _the SAME /signatures/, but DIFFERENT /return types/._

** TODO Linearization
   - As we already saw, /traits/ offer a form of /multiple inheritance/.
     In such cases, the hierarchy is NOT NECESSARILY /linear/, but forms an
     /acyclic graph/ that needs to be flattened upon compilation.

     What /linearization/ does is this -- it specifies a single linear order for
     all of the ancestors of a /class/, including both the regular /superclass
     chain/ and the /parent chains of all of the traits/.

   - We will not have to deal with /linearization/ in _traits that contain no code_
     (=from Jian= in my word: /interface trait/).
     However, if we use /mixins/, we will have to consider it. The following will
     be affected by /linearization/:
     + Method definitions
     + Variables (both /mutable/ and /immutable/)

   - We already saw a simple example of linearization previously. Things, however,
     can get much more complicated and unexpected if the rules of /linearization/
     are not clear.
     =TODO= =TODO= =TODO=

*** DONE Rules of inheritance hierarchies
    CLOSED: [2018-10-07 Sun 17:20]
    Before looking into /linearization rules/, we need to be clear on some
    _inheritance rules in Scala_:

    - In Java, even if a class does not explicitly extend another one, its
      /superclass/ will be ~java.lang.Object~.

      The same stands for Scala, and the equivalent base is ~AnyRef~ .

      =From Comment= There was a ~ScalaObject~ in old Scala, which was
      implicitly added to ALL /traits/ and /classes/.

    - There is a SIMILARITY between =TODO= =???=
      + DIRECTLY *extending* a /trait/
        AND
      + *extending* the /trait superclass/
        and
        *mixing* the /trait/ in using the ~with~ keyword.

*** DONE Linearization rules - =TODO= =NOTE=
    CLOSED: [2018-10-07 Sun 17:20]
    - The linearization of ANY /class/ *must* include the unmodified linearization of any class (but not trait) that it extends.

*** DONE How linearization works - =TODO= =NOTE=
    CLOSED: [2018-10-07 Sun 17:20]
*** TODO Initialization
    Now that we know what happens during linearization,
    we will understand how instances are being created.

    The rule is that the /constructor/ code is *executed in a /reverse order/
    compared to the /linearization order/.*

*** TODO Method overriding

** TODO Testing traits
*** TODO Using a class
*** TODO Mixing the trait in
**** Mixing into the test class
**** Mixing into the test cases

*** TODO Running the tests

** TODO Traits versus classes
*** TODO Summary

* TODO 3. Unification - 62
** TODO Functions and classes
*** DONE Functions as classes
    CLOSED: [2018-08-14 Tue 01:38]
**** Function literals
**** Functions without syntactic sugar

*** Increased expressivity
    From the example, you see:
    - *Unifying classes and functions* leads to _increased expressivity_
      and
      + we can easily achieve various things such as /callbacks/, /lazy parameter
        evaluation/, /centralized exception handling/, and others,
        AND
        without writing extra code and logic.

    - Moreover, /functions/ as /classes/ mean that we can extend them to _provide
      EXTRA functionality_.

** Algebraic data types and class hierarchies
   - Scala's ADT -- Use /case classes/.

*** TODO ADTs
    - =TODO=
      The following few subsections will give
      + a bit more insight on what ADTs are
        and
      + what types are out there.

**** DONE Sum ADTs
     CLOSED: [2018-08-14 Tue 01:51]
     - /Sum ADTs/ is good for enumerable variants cases.

     - Example:
       #+BEGIN_SRC scala
         sealed abstract trait Month
         case object January extends Month
         case object February extends Month
         case object March extends Month
         case object April extends Month
         case object May extends Month
         case object June extends Month
         case object July extends Month
         case object August extends Month
         case object September extends Month
         case object October extends Month
         case object November extends Month
         case object December extends Month
       #+END_SRC

**** DONE Product ADTs
     CLOSED: [2018-08-14 Tue 01:51]
     - /Product ADTs/ for NOT-be-enumerable variants cases.

     - Example:
       ~sealed case class RGB(red: Int, greet: Int, blue: Int}~

**** Hybrid ADTs
**** The unification

*** Pattern matching
**** Pattern matching with values
**** Pattern matching for product ADTs

** Modules and objects
**** Using modules

** Summary

* TODO 4. Abstract and Self Types - 74
  - Designing and writing high-quality code in software engineering is important
    in order to have applications that are easy to extend and maintain.

    This activity requires the
    + domain to be well-known, correctly understood by a developer
    + the requirements for the application to be well-defined.

    If any of these are absent, then writing good programs becomes quite
    challenging.

  - We will look into the following topics in this chapter:
    + Abstract types
    + Polymorphism
    + Self types

  - This chapter can by itself help you writing good code.

  - This chapter is useful when we start looking into some of the concrete
    design patterns.

** TODO Abstract types
   We can _parameterize classes by using values_ -- instantiate a class with
   different values to get different instances -- just the construction
   parameters.

   For example, pass different names (string values) to ~case class Person(name:
   String)~.

*** DONE Generics
    CLOSED: [2018-09-21 Fri 17:04]
    - /Generics/ are another way of _parameterizing classes_.

    - The most signatures example of using /generics/ to _parameterizing
      classes_ is the collection types.

    - Example:
      #+BEGIN_SRC scala
        trait Adder {
          def sum[T](a: T, b: T)(implicit numeric: Numeric[T]): T =
            numeric.plus(a, b)
        }
      #+END_SRC

    - *ad hoc polymorphism*
      =TODO=
      =???=

*** TODO Abstract types
    - Another way to _parameterize classes is by using /abstract types/._

      /Generics/ have their counterparts in other languages such as Java.
      _UNLIKE them_, however, /abstract types/ do *not* exist in Java.

    - xxx

*** TODO Generics versus abstract types
**** Usage advice

** TODO Polymorphism
*** TODO Subtype polymorphism
*** TODO Parametric polymorphism
*** TODO Ad hoc polymorphism
**** TODO Adding functions for multiple types

** TODO Self types
*** TODO Using self types
**** TODO Requiring multiple components
**** TODO Conflicting components
**** TODO Self types and the cake design pattern

*** TODO Self types versus inheritance
**** TODO Inheritance leaking functionality

** TODO Summary

* 5. Aspect-Oriented Programming and Components
** Aspect-oriented programming
*** Understanding application efficiency
**** Timing our application without AOP
**** Timing our application with AOP

** Components in Scala
*** Using Scala's expressive power to build components
**** Implementing components
**** Self types for components

** Summary

* 6. Creational Design Patterns
  - _Based on the aspects of a program on which a piece of code is written to
    solve a problem_, we can split /design patterns/ into the following main
    groups:
    + *Creational*

    + *Structural*

    + *Behavioral*

  - This chapter will focus on the /creational design patterns/, and of course,
    we will look at them from the point of view of the Scala programming
    language. We will go through the following topics:

    + *What* are /creational design patterns/

    + The /factory method/

    + The /abstract factory/

    + Other /factory design patterns/

    + /Lazy initialization/

    + The /singleton/

    + The /builder/

    + The /prototype/

** What are creational design patterns?
   - Creational Design Patterns :: the design patterns deal with /object creation/.

   - Creating objects could involve some extra complexities,
     and
     /creational design patterns/ *hide these complexities* IN ORDER TO *make the
     use of software components easier.*

   - The object creation complexity could be _caused by_ any of the following:
     + The *number* of initialization parameters

     + Required *validation*

     + The complexity of *acquiring* the required parameters

     This list can be expanded, and these factors are present NOT just
     individually, but in combinations.

** The factory method design pattern
*** An example class diagram
*** A code example
**** Scala alternatives

*** What it is good for?
*** What it is not so good for?

** The abstract factory
*** An example class diagram
*** A code example
**** Scala alternatives

*** What it is good for?
*** What it is not so good for?

** Other factory design patterns
*** The static factory
*** The simple factory
*** Factory combinations

** Lazy initialization
*** An example class diagram
*** A code example
*** What it is good for?
*** What it is not so good for?

** The singleton design pattern
*** An example class diagram
*** A code example
*** What it is good for?
*** What it is not so good for?

** The builder design pattern
*** An example class diagram
*** A code example
**** A Java-like implementation
**** Implementation with a case class
**** Using generalized type constraints
***** Changing the Person class
***** Adding generalized type constraints to the required methods
***** Using the type-safe builder

*** What it is good for?
*** What it is not so good for?

** The prototype design pattern
*** An example class diagram
*** A code example
*** What it is good for?
*** What it is not so good for?

** Summary

* 7. Structural Design Patterns
** Defining structural design patterns
** The adapter design pattern
*** Example class diagram
*** Code example
**** The adapter design pattern with final classes
**** The adapter design pattern the Scala way

*** What it is good for
*** What it is not so good for

** The decorator design pattern
*** Example class diagram
*** Code example
**** The decorator design pattern the Scala way

*** What it is good for
*** What it is not so good for

** The bridge design pattern
*** Example class diagram
*** Code example
**** The bridge design pattern the Scala way

*** What it is good for
*** What it is not so good for

** The composite design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The facade design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The flyweight design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The proxy design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** Summary

* TODO 8. Behavioral Design Patterns - Part One
  - There are more members in this group than the others we've already been through,
    so we will split it into two separate parts.

  - We'll focus on the following /behavioral design patterns/:
    + Value object
    + Null object
    + Strategy object
    + Command
    + Chain of responsibility
    + Interpreter

  - This and next chapters will give some clarity about
    + What behavioral design patterns are?
    + Where they are useful?
    + How to implement them in Scala?

** DONE Defining behavioral design patterns
   CLOSED: [2019-08-19 Mon 10:58]
   - CONTRARY TO /creational and structural design patterns/,
     the /behavioral design patterns/ describe a *flow* or a *process*.

   - This means that a developer should be really familiar with the actual process
     they are trying to implement.

   - As with every other type of design pattern,
     /behavioral design patterns/ exist in order to _increase_ the
     + testability,
     + maintainability, and
     + flexibility
     of the produced code.

** DONE The value object design pattern
   CLOSED: [2019-08-19 Mon 11:52]
   - Value object :: Small and simple immutable objects whoes equality is based
                     not on identity, but on value equality.
     + =from Jian= The "value" in "value equality" is a summary of the value(s)
       contained in an object

   - Scenarios that use /value objects/:
     + _multithreaded_ applications due to _value objects' immutability_.

     + Data tranfer objects in enterprise applications.
       =from Jian= This description is not very clear!!! TODO

*** DONE An example class diagram
    CLOSED: [2019-08-19 Mon 11:29]
    - Java (till Java 12) has NO built-in support for /value objects/.
      + The Java way used to simulate /value objects/:
        * Declare the /fields/ as ~final~;
        * Implement the ~hashCode~ and ~equals~ /methods/.

    - Scala can use /case classes/ (no ~var~ definitions) and /tuples/ to represent
      /value objects/.

*** DONE A code example
    CLOSED: [2019-08-19 Mon 11:30]
*** DONE Alternative implementation
    CLOSED: [2019-08-19 Mon 11:52]
    - /Tuples'/ *availability* for /value object pattern/:
      /Tuples/ can be an alternative if the number of fields are less than 22 --
      the limitation of built-in tuple classes (=from Jian= will be changed in
      Scala 3).

    - Shorthands:
      + Two n-tuples can be considered equal, even if semantically they are different
        types of objects.
        * =from Jian=
          A shorthand is NOT always a shorthand in all scenarios!!!
          _Shapeless_ is exploiting this "shorthand" and push /generic programming/
          to a new level.

      + /Case classes/ has a better readability than /tuples/!
        Everyone will prefer ~date.year~ rather han ~date._1~.
        * =from Jian=
          Use /2-tuple/ or /3-tuple/ in localized code snippets is OK.
          _But_ localized ONLY! _Because_ this way of using it doesn't resolve the
          first shorthand mentioned above.

        * =from Jian=
          Sometimes this shorthand can be walkarounded by ~import date.year~.
            However, this is not always the way you want to use it, and /case
          class objects/ can also do this.

*** DONE What it is good for
    CLOSED: [2019-08-19 Mon 11:52]
    The /value object design pattern/ is good for
    - multithreading
    - creating /data transfer objects (DTOs)/.

*** DONE What it is not so good for
    CLOSED: [2019-08-19 Mon 11:52]
    There is no other major drawbacks to using this pattern
    other than using /n-tuples/, which has a big n and is used nonlocal to
    represent /value objects/.

** TODO The null object design pattern
   - The purpose of the /null object design pattern/ is to
     define an *actual object* that represents the /null value/ and *has neutral
     behavior*.
     + This right /null object design pattern/ should also remove the _EXPLICIT
       null checks_, but _AUTOMATICALLY ENFORCE an implicit null check_, which can
       improve the readability!

*** An example class diagram
    Example: Poll a queue for messages. The queue might NOT always have anything to offer.

    - Solution:
      #+begin_src scala
        sealed trait Text {
          def print(): Unit = println(this.toString)
        }

        final case class Message(number: Int) extends Text
        case object NullMessage               extends Text
      #+end_src
*** A code example
*** What it is good for
*** What it is not so good for

** The strategy design pattern
*** An example class diagram
*** A code example
**** The strategy design pattern the Scala way

*** What it is good for
*** What it is not so good for

** The command design pattern
*** An example class diagram
*** A code example
**** The command design pattern the Scala way

*** What it is good for
*** What it is not so good for

** The chain of responsibility design pattern
*** An example class diagram
*** A code example
**** The chain of responsibility design pattern the
**** Scala way
*** What it is good for
*** What it is not so good for

** The interpreter design pattern
*** An example class diagram
*** A code example
*** What it is good for
*** What it is not so good for

** Summary

* 9. Behavioral Design Patterns - Part Two
** The iterator design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The mediator design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The memento design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The observer design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The state design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The template method design pattern
*** Example class diagram
*** Code exampleWhat it is good for
*** What it is not so good for

** The visitor design pattern
*** Example class diagram
*** Code example
**** The visitor design pattern the Scala way

*** What it is good for
*** What it is not so good for

** Summary

* 10. Functional Design Patterns - the Deep Theory
** Abstraction and vocabulary
** Monoids
*** What are monoids?
*** Monoids in real life
*** Using monoids
**** Monoids and foldable collections
**** Monoids and parallel computations
**** Monoids and composition

*** When to use monoids

** Functors
*** Functors in real life
**** Using our functors

** Monads
*** What is a monad?
**** The flatMap method
**** The unit method
**** The connection between map, flatMap, and unit
***** The names of the methods
**** The monad laws

*** Monads in real life
*** Using monads
**** The Option monad
**** A more advanced monad example

*** Monad intuition

** Summary

* 11. Applying What We Have Learned
** The lens design pattern
*** Lens example
**** Without the lens design pattern
***** Immutable and verbose
***** Using mutable properties

**** With the lens design pattern

*** Minimizing the boilerplate

** The cake design pattern
*** Dependency injection
**** Dependency injection libraries and Scala

*** Dependency injection in Scala
**** Writing our code
**** Wiring it all up
**** Unit testing our application

*** Other dependency injection alternatives
**** Implicits for dependency injection
**** Reader monad for dependency injection

** The pimp my library design pattern
*** Using pimp my library
*** Pimp my library in real life

** The stackable traits design pattern
*** Using stackable traits

** The type class design pattern
*** Type class example
*** Type class design pattern alternatives

** Lazy evaluation
*** Evaluating by-name parameters only once
*** Alternative lazy evaluation

** Partial functions
*** Partial functions are not partially applied functions
*** Partially defined functions

** Implicit injection
*** Implicit conversions
*** Dependency injection using implicits
**** Testing with implicit dependency injection

** Duck typing
*** Duck typing example
*** Duck typing alternatives
*** When to use duck typing

** Memoization
*** Memoization example
*** Memoization alternatives

** Summary

* 12. Real-Life Applications
** Reasons to use libraries
** The Scalaz library
*** Monoids in Scalaz
**** Using monoids
**** Testing monoids

*** Monads in Scalaz
**** Using monads
**** Testing monads

*** The possibilities of Scalaz

** Writing a complete application
*** Application specifications
*** Implementation
**** The libraries to use
***** Reading the application configuration
***** Reading the scheduler configuration
***** Scheduling tasks
***** Accessing a database
***** Executing console commands

*** Writing some code
*** Wiring it all up
*** The end result

** Testing our application
*** Unit testing
*** Application testing

** The future of our application
** Summary
