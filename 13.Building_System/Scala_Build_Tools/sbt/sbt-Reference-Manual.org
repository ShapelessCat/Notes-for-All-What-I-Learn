#+TITLE: sbt Reference Manual
#+VERSION: 1.x (1.5.5 -> 1.9.8)
#+STARTUP: overview
#+STARTUP: entitiespretty

=from Jian= sbt can support Scala 3 WITHOUT the sbt-dotty plugin since 1.5.0

** Features of sbt
  - Little or no configuration required for simple projects
  - Scala-based build definition that can use the full flexibility of Scala code
  - Accurate incremental recompilation using information extracted from the compiler
  - Library management support using _Coursier_
  - Continuous compilation and testing with triggered execution
  - Supports mixed Scala/Java projects
  - Supports testing with _ScalaCheck_, _specs_, and _ScalaTest_. _JUnit_ is supported by a plugin.
  - Starts the Scala REPL with project classes and dependencies on the classpath
  - Modularization supported with sub-projects
  - External project support (list a git repository as a dependency!)
  - Parallel task execution, including parallel test execution =TODO= =HOW=

** Also
   - This documentation applies to sbt 1.5.5.
   - See also the [[https://www.scala-sbt.org/1.x/api/sbt/index.html][API Documentation]], and the _index of names and types_ (Check the below part 6).

* TODO 1. Getting Started with sbt
  sbt uses a small number of concepts.
  However, you will stumble on if you haven't read the documentation.

  - This _Getting Started with sbt_ gudie covers the concepts:
    =FIXME= name mismatch: _Getting Started Guide_ and _Getting Started with sbt_
    * create
    * maintain
    an sbt build definition.

  - If you are in a huge hurry,
    the most important conceptual background can be found in (inside this part):
    * /build definition/
    * /scopes/
    * /task graph/

** DONE a. Installing sbt
   CLOSED: [2021-10-18 Mon 02:32]
   - To create an sbt project, you’ll need to take these steps:
     * Install JDK (JDK 8 or JDK 11).
     * Install sbt.
     * Setup a simple hello world project
     * Move on to running to learn how to run sbt.
     * Then move on to .sbt build definition to learn more about build definitions.


   - =from Jian=
     * My recompilation:
       Use _Coursier_ to install all things about Scala development (check the
       ~cs setup~ command), including
       + JDK
       + sbt
       + Scala
       + Ammonite
       + etc.

     * If you are using Microsoft Windows,
       this way may not convenient:
       1. Check the Installation -> Native launcher -> Windows section of Coursier
          documentation. Run the installation command from ~bitsadmin~ must be
          from cmd.exe, not Powershell.

       2. You may see some =null= folder issue that has not been resolved
          when I'm using Coursier recently.

*** i. Installing sbt on macOS
*** ii. Installing sbt on Windows
*** iii. Installing sbt on Linux

** DONE b. sbt by example - =TODO= =RE-READ=
   CLOSED: [2019-08-09 Fri 15:17]
   This page assumes you've installed sbt 1.x, NOT 0.13.x or lower version.

   Explain sbt usages by examples.

   =START=
*** DONE Create a minimum sbt build
    CLOSED: [2019-08-07 Wed 16:31]
    Assume you are in Bash, type the command below:
    1. ~mkdir foo-build~
    2. ~cd foo-build~
    3. ~touch build.sbt~

*** DONE Start sbt shell
    CLOSED: [2019-08-07 Wed 16:32]
    Run ~sbt~ and you'll see
    #+begin_src text
      [info] Updated file /tmp/foo-build/project/build.properties: set sbt.version to 1.1.4
      [info] Loading project definition from /tmp/foo-build/project
      [info] Loading settings from build.sbt ...
      [info] Set current project to foo-build (in build file:/tmp/foo-build/)
      [info] sbt server started at local:///Users/eed3si9n/.sbt/1.0/server/abc4fb6c89985a00fd95/sock
      sbt:foo-build>
    #+end_src

*** DONE Exit sbt shell
    CLOSED: [2019-08-07 Wed 17:32]
    Sbt command ~exit~

*** DONE Compile a project
    CLOSED: [2019-08-07 Wed 17:32]
    Sbt command ~compile~

*** DONE Recompile on code change
    CLOSED: [2019-08-07 Wed 17:33]
    Sbt shell command ~~compile~

*** DONE Create a source file
    CLOSED: [2019-08-07 Wed 17:34]

*** DONE Run a previous command
    CLOSED: [2019-08-07 Wed 17:34]
    Use the <Up> arrow key or CTRL+p.

*** DONE Getting help
    CLOSED: [2019-08-07 Wed 17:34]
    Sbt command ~help~

    - Example: ~help run~

*** DONE Run your app
    CLOSED: [2019-08-07 Wed 17:35]
    Sbt command ~run~

*** DONE Set ~ThisBuild / scalaVersion~ from sbt shell
    CLOSED: [2019-08-07 Wed 17:35]
    Sbt shell command ~set ThisBuild / scalaVersion := "2.13.6"~

*** DONE Save the session to =build.sbt= - =IMPORTANT=
    CLOSED: [2019-08-07 Wed 17:36]
    Sbt shell command ~session save~

*** DONE Name your project
    CLOSED: [2019-08-07 Wed 17:37]
    Edit =build.sbt=
    #+begin_src scala
      ThisBuishorter namesld / scalaVersion := "2.13.6"
      ThisBuild / organization := "com.example"

      lazy val hello = (project in file("."))
        .settings(
          name := "Hello"
        )
    #+end_src

*** DONE Reload the build
    CLOSED: [2019-08-07 Wed 17:39]
    Sbt shell command ~reload~
    Then you can see the prompt changes.

*** DONE Add ScalaTest to ~libraryDependencies~
    CLOSED: [2019-08-07 Wed 17:41]
    Edit =build.sbt=
    #+begin_src scala
      ThisBuild / scalaVersion := "2.13.6"
      ThisBuild / organization := "com.example"

      lazy val hello = (project in file("."))
        .settings(
          name := "Hello",
          libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.5" % Test,
        )
    #+end_src

    and then ~reload~

*** DONE Run tests
    CLOSED: [2019-08-07 Wed 17:41]
    Sbt command ~test~

*** DONE Run incremental tests continuously
    CLOSED: [2019-08-07 Wed 17:41]
    Sbt shell command ~~testQuick~

*** DONE Write a test
    CLOSED: [2019-08-07 Wed 17:43]
    #+begin_src scala
      // src/test/scala/HelloSpec.scala

      import org.scalatest._

      class HelloSpec extends FunSuite with DiagrammedAssertions {
        test("Hello should start with H") {
          assert("hello".startsWith("H"))
        }
      }
    #+end_src

*** DONE Make the test pass
    CLOSED: [2019-08-07 Wed 17:43]
    Correct the tests written in the last section to make it pass.

*** DONE Add a library dependency
    CLOSED: [2019-08-07 Wed 17:46]
    Edit =build.sbt=
    #+begin_src scala
      ThisBuild / scalaVersion := "2.13.6"
      ThisBuild / organization := "com.example"

      lazy val hello = (project in file("."))
        .settings(
          name := "Hello",
          libraryDependencies += "com.typesafe.play" %% "play-json" % "2.9.2",
          libraryDependencies += "com.eed3si9n" %% "gigahorse-okhttp" % "0.5.0",
          libraryDependencies += "org.scalatest" %% "scalatest" % "3.2.y" % Test,
        )
    #+end_src

    and then ~reload~

*** DONE Use Scala REPL
    CLOSED: [2019-08-07 Wed 17:48]
    Sbt command ~console~
    =FIXME= Scala version in console.

*** DONE Make a subproject
    CLOSED: [2019-08-07 Wed 17:49]
    Edit =build.sbt=
    #+begin_src scala
      ThisBuild / scalaVersion := "2.13.6"
      ThisBuild / organization := "com.example"
      
      lazy val hello = (project in file("."))
        .settings(
          name := "Hello",
          libraryDependencies += "com.eed3si9n" %% "gigahorse-okhttp" % "0.3.1",
          libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.5" % Test,
        )
      
      lazy val helloCore = (project in file("core"))
        .settings(
          name := "Hello Core",
          )
    #+end_src
    Then ~reload~

*** DONE List all subprojects - =IMPORTANT=
    CLOSED: [2019-08-07 Wed 17:50]
    Sbt command ~projects~

*** DONE Compile the subproject - =IMPORTANT=
    CLOSED: [2019-08-08 Thu 14:52]
    For example: ~helloCore/compile~

*** DONE Add ScalaTest to the subproject
    CLOSED: [2019-08-08 Thu 14:53]
    #+begin_src scala
      ThisBuild / scalaVersion := "2.13.6"
      ThisBuild / organization := "com.example"

      val scalaTest = "org.scalatest" %% "scalatest" % "3.2.7"

      lazy val hello = (project in file("."))
        .settings(
          name := "Hello",
          libraryDependencies += "com.eed3si9n" %% "gigahorse-okhttp" % "0.5.0",
          libraryDependencies += scalaTest % Test,
          )

      lazy val helloCore = (project in file("core"))
        .settings(
          name := "Hello Core",
          libraryDependencies += scalaTest % Test,
          )
    #+end_src

*** DONE Broadcast commands
    CLOSED: [2019-08-08 Thu 14:59]
    *Set ~aggregate~ so that the command sent to ~hello~ is _broadcast to_ ~helloCore~ too:*
    #+begin_src scala
      ThisBuild / scalaVersion := "2.12.7"
      ThisBuild / organization := "com.example"

      val scalaTest = "org.scalatest" %% "scalatest" % "3.0.5"

      lazy val hello = (project in file(".")).
        aggregate(helloCore).
        settings(
          name := "Hello",
          libraryDependencies ++= Seq(
            "com.eed3si9n" %% "gigahorse-okhttp" % "0.3.1",
            scalaTest % Test,
          )
        )

      lazy val helloCore = (project in file("core")).
        settings(
          name := "Hello Core",
          libraryDependencies += scalaTest % Test,
        )
    #+end_src
    After ~reload~, ~testQuick~ now runs on both subprojects.

*** DONE Make hello depend on helloCore
    CLOSED: [2019-08-09 Fri 13:24]
    Add ~dependesOn(...)~ to a project (also move Gigahorse dependency to ~helloCore~):
    #+begin_src scala
      ThisBuild / scalaVersion := "2.13.6"
      ThisBuild / organization := "com.example"

      val scalaTest = "org.scalatest" %% "scalatest" % "3.5.7"

      lazy val hello = (project in file("."))
        .aggregate(helloCore)
        .dependsOn(helloCore)
        .settings(
          name := "Hello",
          libraryDependencies += scalaTest % Test,
          )

      lazy val helloCore = (project in file("core"))
        .settings(
          name := "Hello Core",
          libraryDependencies += "com.eed3si9n" %% "gigahorse-okhttp" % "0.5.0",
          libraryDependencies += scalaTest % Test,
          )
    #+end_src

*** DONE Parse JSON using Play JSON - =TODO= READ EXAMPLE CODE
    CLOSED: [2019-08-09 Fri 13:25]
    Add ~"com.typesafe.play" %% "play-json" % "2.9.2"~
    #+begin_src scala
      ThisBuild / scalaVersion := "2.13.6"
      ThisBuild / organization := "com.example"
      
      val scalaTest = "org.scalatest" %% "scalatest" % "3.2.7"
      val gigahorse = "com.eed3si9n" %% "gigahorse-okhttp" % "0.5.0"
      val playJson  = "com.typesafe.play" %% "play-json" % "2.9.2"
      
      lazy val hello = (project in file("."))
        .aggregate(helloCore)
        .dependsOn(helloCore)
        .settings(
          name := "Hello",
          libraryDependencies += scalaTest % Test,
        )
      
      lazy val helloCore = (project in file("core"))
        .settings(
          name := "Hello Core",
          libraryDependencies ++= Seq(gigahorse, playJson),
          libraryDependencies += scalaTest % Test,
        )
    #+end_src
    After ~reload~,

    1. add ~core/src/main/scala/example/core/Weather.scala~:
       #+begin_src scala
         package example.core

         import gigahorse._, support.okhttp.Gigahorse
         import scala.concurrent._, duration._
         import play.api.libs.json._

         object Weather {
           lazy val http = Gigahorse.http(Gigahorse.config)

           def weather: Future[String] = {
             val baseUrl = "https://www.metaweather.com/api/location"
             val locUrl = baseUrl + "/search/"
             val weatherUrl = baseUrl + "/%s/"
             val rLoc = Gigahorse.url(locUrl).
               get.
               addQueryString("query" -> "New York")

             import ExecutionContext.Implicits.global

             // TODO: from Jian -- I don't like the `get`'s below
             for {
               loc <- http.run(rLoc, parse)
               woeid = (loc \ 0  \ "woeid").get
               rWeather = Gigahorse.url(weatherUrl format woeid).get
               weather <- http.run(rWeather, parse)
             } yield (weather \\ "weather_state_name")(0).as[String].toLowerCase
           }

           private def parse = Gigahorse.asString andThen Json.parse
         }
       #+end_src

    2. change ~src/main/scala/example/Hello.scala~ as follows:
       #+begin_src scala
         package example

         import scala.concurrent._, duration._
         import core.Weather

         object Hello extends App {
           val w = Await.result(Weather.weather, 10.seconds)
           println(s"Hello! The weather in New York is $w.")
           Weather.http.close()
         }
       #+end_src

    3. Finally, run it with ~run~.

*** DONE Add sbt-native-packger plugin
    CLOSED: [2019-08-09 Fri 14:28]
    1. Create =project/plugins.sbt=:
       #+begin_src scala
         addSbtPlugin("com.typesafe.sbt" % "sbt-native-packager" % "1.3.4")
       #+end_src

    2. Edit =build.sbt= as follows to add ~JavaAppPackaging~:
       #+begin_src scala
         ThisBuild / scalaVersion := "2.12.7"
         ThisBuild / organization := "com.example"

         val scalaTest = "org.scalatest" %% "scalatest" % "3.0.5"
         val gigahorse = "com.eed3si9n" %% "gigahorse-okhttp" % "0.3.1"
         val playJson  = "com.typesafe.play" %% "play-json" % "2.6.9"

         lazy val hello = (project in file("."))
           .aggregate(helloCore)
           .dependsOn(helloCore)
           .enablePlugins(JavaAppPackaging)
           .settings(
             name := "Hello",
             libraryDependencies += scalaTest % Test,
             )

         lazy val helloCore = (project in file("core"))
           .settings(
             name := "Hello Core",
             libraryDependencies ++= Seq(gigahorse, playJson),
             libraryDependencies += scalaTest % Test,
             )
       #+end_src

*** DONE Reload and create a =.zip= distribution
    CLOSED: [2019-08-09 Fri 14:33]
    ~reload~ and then ~dist~
    Here is how you can run:
    #+begin_src bash
      cd /tmp/someother
      unzip -o -d /tmp/someother /tmp/foo-build/target/universal/hello-0.1.0-SNAPSHOT.zip
      ./hello-0.1.0-SNAPSHOT/bin/hello
    #+end_src

*** DONE Dockerize your app =???=
    CLOSED: [2019-08-09 Fri 14:34]
    1. Sbt command ~Docker/publishLocal~
       #+begin_src text
         [info] Successfully built b6ce1b6ab2c0
         [info] Successfully tagged hello:0.1.0-SNAPSHOT
         [info] Built image hello:0.1.0-SNAPSHOT
       #+end_src

    2. Run it ~docker run hello:0.1.0-SNAPSHOT~
       
*** DONE Set the version
    CLOSED: [2019-08-09 Fri 14:38]
    Add ~ThisBuild / version := "0.1.0"~

*** DONE Switch scalaVersion temporarily
    CLOSED: [2019-08-09 Fri 15:01]
    Sbt shell command like ~++2.12.14!~ can force the version.
    Run ~scalaVersion~ to check current version, and you'll see:.
    #+begin_src scala
      scalaVersion
      // [info] helloCore / scalaVersion
      // [info]  2.11.12
      // [info] scalaVersion
      // [info]  2.11.12 scalaVersion
      // [info] 2.12.7
    #+end_src

    The temporary ~scalaVersion~ will go away after ~reload~.
    
*** DONE Inspect the dist task =???=
    CLOSED: [2019-08-09 Fri 15:13]
    To find out more about ~dist~, try ~help~ and ~inspect~:
    #+begin_src scala
      help dist
      // Creates the distribution packages.

      inspect dist
      // TODO: ???

      inspect tree dist  // Call `inspect` recursively on the dependency tasks
      // [info] dist = Task[java.io.File]
      // [info]   +-Universal / dist = Task[java.io.File]
      // ....
    #+end_src

*** DONE Batch mode
    CLOSED: [2019-08-09 Fri 15:14]
    #+begin_src bash
      sbt clean "testOnly HelloSpec"
    #+end_src

*** DONE sbt new command
    CLOSED: [2019-08-09 Fri 15:17]
    Quickly setup a simple "Hello world" build.
    ~sbt new sbt/scala-seed.g8~
    #+begin_src text
      A minimal Scala project.
      
      name [My Something Project]: hello
      
      Template applied in ./hello
    #+end_src

*** DONE Credits - =TODO=
    CLOSED: [2019-08-09 Fri 15:15]
    This page is based on the [[https://www.scalawilliam.com/essential-sbt/][Essential sbt]] tutorial written by William "Scala William" Narmontas.
    
** DONE c. Directory structure
   CLOSED: [2019-08-09 Fri 15:36]
   - Base directory :: the directory containing the project.

   - Source code :: /sbt/ uses the same directory structure as /Maven/ for source
                    files by default.
     * All paths below are relative to the base directory:
       + Source code directory structure
         #+BEGIN_SRC text
           src/
             main/
               resources/
                  <files to include in main jar here>
               scala/
                  <main Scala sources>
               java/
                  <main Java sources>

             test/
               resources
                  <files to include in test jar here>
               scala/
                  <test Scala sources>
               java/
                  <test Java sources>
         #+END_SRC

         - Other directories in ~src/~ will be ignored.
           Additionally, all hidden directories will be ignored.

         - You can also put =.scala= files in the base directory.
           This is usually for small projects.

           =From Jian= I will NEVER do this with project source file. However, see below!!!
           * Put =.scala= files in base directory is NOT ONLY an odd trick.
             It becomes relevant later.
             =TODO= =IMPORTANT=

   - *sbt build definition files*
     =build.sbt= (actually _ANY_ files named with =.sbt= extension) in the /project's
     base directory/.

   - *Build support files*
     In addition to =build.sbt=,
     =project= directory can contain =.scala= files that defines
     * helper objects and
     * one-off plugins.
     =TODO= See /organizing the build/ for more.

   - *Build products*
     Generated files
     * compiled classes,
     * packaged jars,
     * managed files,
     * caches, and
     * documentation
     will be written to the =target= directory _by default_.

   - *Configuring version control*
     Add ~target/~ to =.gitignore=
     * _Note:_ =IMPORTANT=-
       + it deliberately *has* a TRAILING ~/~ (to match only directories)
       + it deliberately *has NO* LEADING ~/~ (to match =project/target/= in addition
         to plain =target/=).

** DONE d. Running
   CLOSED: [2019-08-12 Mon 15:33]
   This page describes how to use /sbt/ _ONCE_ you have set up your project.
   It assumes you've _installed sbt_ and went through _sbt by example_.

   - *sbt shell*
     * Use ~sbt~ command to get into /sbt shell/.

       Inside /sbt shell/, you can type in sbt commands like ~compile~, ~run~,
       etc.

   - *Batch mode*
     In you system shell, type ~sbt~, and then specify a _space-separated list_ of
     /sbt commands/ as arguments.
     * If a /sbt command/ needs arguments, enclose this command and its argument
       in quotes as one string, and pass this string as one argument of the
       ~sbt~ command:
       For example, ~sbt clean compile "testOnly TestA testB"~. Here we have
       + _THREE commands_
       + the last command ~testOnly~ has _TWO arguments_.

     * NOTE:
       Running in /batch mode/ requires JVM spinup and JIT each time, so your build
       will run _much slower_.

       + For day-to-day coding, we *RECOMMEND*
         - using the /sbt shell/
           OR
         - /Continuous build and test feature/ described below.

       + Beginning in sbt 0.13.16, using /batch mode/ in sbt will issue an
         informational startup message,
         #+begin_src text
           [info] Executing in batch mode. For better performance use sbt's shell
           ...
         #+end_src
         =IMPORTANT=
         Use ~supressSbtShellNotification := true~ to supress this!

   - *Continuous build and test*
     * Prefix a sbt command with =~=, press <Enter>, and then the command after
       =~= will run automatically WHEN one or more source files change.

     * =IMPORTANT=
       Press <Enter> again to stop watching for changes.

     * =IMPORTANT= =IMPORTANT= =IMPORTANT=
       This feature can be used with *either /sbt shell/ or /batch mode/.*

     * =TODO= See /Triggered Execution/ for more details.

   - *Common commands*
     For a more complete list, see /Command Line Reference/.
     |-------------------+----------------------------------------------------------|
     | Command           | Description                                              |
     |-------------------+----------------------------------------------------------|
     | ~clean~           | Deletes all generated files (in the target directory).   |
     |-------------------+----------------------------------------------------------|
     | ~compile~         | Compiles the main sources                                |
     |                   | (in src/main/scala and src/main/java directories).       |
     |-------------------+----------------------------------------------------------|
     | ~test~            | Compiles and runs all tests.                             |
     |-------------------+----------------------------------------------------------|
     | ~console~         | Starts the Scala interpreter with a classpath            |
     |                   | including the compiled sources and all dependencies.     |
     |                   | To return to sbt, type ~:quit~, _Ctrl+D_ (Unix), or      |
     |                   | _Ctrl+Z_ (Windows).                                      |
     |-------------------+----------------------------------------------------------|
     | ~run <argument>*~ | Runs the _main class_ for the project in the same        |
     |                   | virtual machine as sbt.                                  |
     |-------------------+----------------------------------------------------------|
     | ~package~         | Creates a jar file containing the files in               |
     |                   | _src/main/resources_ and the classes compiled from       |
     |                   | _src/main/scala_ and _src/main/java_.                    |
     |-------------------+----------------------------------------------------------|
     | ~help <command>~  | Displays detailed help for the specified command.        |
     |                   |                                                          |
     |                   | If no command is provided, displays brief                |
     |                   | descriptions of all commands.                            |
     |-------------------+----------------------------------------------------------|
     | ~reload~          | Reloads the build definition                             |
     |                   | (=build.sbt=, =project/*.scala=, =project/*.sbt= files). |
     |                   | Needed if you change the build definition.               |
     |-------------------+----------------------------------------------------------|

   - *Tab completion*
     * Press <Tab> _once_ to show only a subset of most likely completions.
     * Press <Tab> _more times_ to show more verbose choices.

   - *sbt shell history* =IMPORTANT= =TODO=
     The sbt shell remembers history, even if you exit sbt and restart it.

     You can:
     1. Press the up arrow key to cycle through previously entered commands.

     2. Ctrl-R incrementally searches the history backwards.

     3. Through _JLine's integration_ with the terminal environment,
        you can *customize* /sbt shell/ by changing ~$HOME/.inputrc~.
        =TODO= =???= =TODO= =IMPORTANT=-
        * The following settings will allow up- and down- arrow to perform
          prefix-based search of the history:
          #+begin_src text
            "\e[A": history-search-backward
            "\e[B": history-search-forward
            "\e[C": forward-char
            "\e[D": backward-char
          #+end_src

     4. sbt shell also supports the following commands: =TODO= =Recite=
        |------------+-------------------------------------------------------------------|
        | Command    | Description                                                       |
        |------------+-------------------------------------------------------------------|
        | ~!~        | Show history command help.                                        |
        | ~!!~       | Execute the previous command again.                               |
        | ~!:~       | Show all previous commands.                                       |
        | ~!:n~      | Show the last ~n~ commands.                                       |
        | ~!n~       | Execute the command with index ~n~, as shown by the ~!:~ command. |
        | ~!-n~      | Execute the _nth_ command before this one.                        |
        | ~!string~  | Execute the most recent command starting with ~string~.           |
        | ~!?string~ | Execute the most recent command containing ~string~.              |
        |------------+-------------------------------------------------------------------|

** TODO e. IDE Integration
*** Using sbt as Metals build server
**** Interactive debugging on VS Code
**** Logging into sbt session

*** Importing to IntelliJ IDEA
**** Interactive debugging with IntelliJ IDEA

*** Using sbt as IntelliJ IDEA build server (advanced)
**** Logging into sbt session

*** Using Neovim as Metals frontend (advanced)
**** Go to definition
**** Hover
**** Listing diagnostics
**** Interactive debugging with Neovim
**** Logging into sbt session

** DONE f. Build definition
   CLOSED: [2022-09-05 Mon 10:46]
   - This page describes /sbt build definitions/, including
     * some "theory"
     * the syntax of =build.sbt=.

*** DONE Specifying the sbt version
    CLOSED: [2022-09-04 Sun 16:38]
    Create a file =project/build.properties=, and
    specify the sbt version in it: =sbt.version=1.7.1=

    - If the required version is not available locally, the =sbt= launcher will
      download it for you.

    - *DISCOURAGED*:
      If =project/build.properties= is not present,
      the _sbt launcher_ will choose an *ARBITRARY version*, and this makes your
      build *non-portable*.

*** DONE What is a build definition?
    CLOSED: [2022-09-04 Sun 17:20]
    - The /build definition/ is defined in =build.sbt=.
      * build definition :: A set of /projects/ (of type ~Project~).
        + Because the term /project/ can be ambiguous,
          *we often call /project/ /subproject/ in this guide.*

    - Example:
      #+BEGIN_SRC scala
        lazy val root = (project in file("."))
          .settings(
            name := "Hello",
            scalaVersion := "2.13.3"
          )
      #+END_SRC

    - Each /subproject/ is configured by _key-value pairs_, which are listed under
      the ~.settings(...)~.
      * In the example above, they are ~name~ and ~scalaVersion~ key-value pairs.


    - =TODO= =FIXME= =DOC=
      Two adjacent sbt configuration snippets that have the same contents.
      Rewords these paragraphs and remove one of the duplicated code block.

*** DONE How =build.sbt= defines settings
    CLOSED: [2022-09-04 Sun 17:19]
    Each /subproject/ holds a sequence of key-value pairs called /setting expressions/
    using =build.sbt= *DSL*.

    - /Setting expressions/ (some among them are also called /task expressions/).
      The name /setting expression/ has wider meaning than /task expression/.
      =TODO= *We will see more on the difference later in this page.*

    - Example:
      #+begin_src scala
        ThisBuild / organization := "com.example"
        ThisBuild / scalaVersion := "2.13.3"
        ThisBuild / version      := "0.1.0-SNAPSHOT"

        lazy val root = (project in file(".")).
          settings(
            name         := "Hello",
          )
      #+end_src

    - The =build.sbt= DSL:
      organization     :=       { "com.example" }
      ------------  ---------   -----------------
           key      operator   (setting/task) body

      * A /setting expression/ consists of three parts:
        1. Left-hand side is a /key/.
        2. /Operator/, which in this case is ~:=~
        3. Right-hand side is called the /body/, or the /setting body/.

      * A /key/ is an instance of ~SettingKey[T]~, ~TaskKey[T]~, or ~InputKey[T]~,
        where ~T~ is the type of the expected value.
        + For example,
          the key ~name~ above is typed to ~SettingKey[String]~.

    - All ~val~'s, ~lazy val~'s, and ~def~'s can be used in =build.sbt=.

    - _Top-level /objects/ and /classes/ are *NOT allowed* in =build.sbt=._
      Those should go in the =project/= directory as _Scala source files_.
      =IMPORTANT=

*** DONE Keys
    CLOSED: [2022-09-05 Mon 10:46]
**** DONE Types
     CLOSED: [2022-09-05 Mon 10:45]
      There are _THREE_ flavors of key:
      * ~SettingKey[T]~:
        a key for a value *computed ONCE* (the value is computed _when loading_
        the /subproject/, and kept around).

      * ~TaskKey[T]~:
        a key for a value, called a /task/, that has to be *recomputed EACH
        time*, potentially _with side effects_.

      * ~InputKey[T]~:
        a key for a /task/ that _HAS command line arguments AS INPUT_.
        =TODO= Check out /Input Tasks/ for more details.

**** DONE Built-in Keys
     CLOSED: [2022-09-05 Mon 10:45]
      The built-in keys are just fields in an /object/ called ~Keys~.

      - A =build.sbt= *implicitly* has an import =sbt.Keys._=

**** DONE Custom Keys
     CLOSED: [2022-09-05 Mon 10:45]
     - /Custom keys/ may be defined with their respective _creation methods_:
       * ~settingKey~
       * ~taskKey~
       * ~inputKey~
       Each /method/ expects the /type/ of the value associated with the key as
       well as a /description/. See the definition below.

     - The name of the key is taken from the ~val~ the key is assigned to.
       For example, to define a key for a new task called ~hello~,
        #+begin_src scala
          lazy val hello = taskKey[Unit]("An example task")
        #+end_src

     - The =.sbt= files can contain ~val~'s and ~def~'s in addition to settings.
       1. Run ~val~'s and ~def~'s _BEFORE_ /settings/ regardless of where they
          are defined in the file.

       2. *Typically, ~lazy val~'s are used instead of ~val~'s to avoid
          initialization order problems.*

**** DONE Task vs Setting keys
     CLOSED: [2022-09-05 Mon 10:45]
      - Define a task with ~TaskKey[T]~.

      - /Tasks/: operations such as ~compile~ or ~package~.

      - /Tasks/
        * may return ~Unit~, OR
        * may return a value related to the /task/.
          + Example:
            ~package~ is a ~TaskKey[File]~ and its value is the jar file it
            creates.

      - Each time you /start a task execution/, for example by typing ~compile~
        at the /interactive sbt prompt/, *sbt will re-run any tasks involved
        _EXACTLY ONCE_.*

      - =from Jian= From the differences between the duty of /tasks/ and /settings/, we know:
        * sbt's key-value pairs describing the /subproject/
          + can keep around a *fixed string value* for a /setting/ =TODO= =???= always string? =???=
            such as _name_,

          + _BUT_ it has to keep around some *executable code* for a /task/
            such as ~compile~ -- even if that executable code eventually returns a
            string, it has to be re-run every time.
            - =from Jian=
              /Tasks/ are designed for
              side-effect OR some environment related values.
              =TODO= =More???=

        * A given key *ALWAYS* refers to EITHER a /task/ OR a plain /setting/.
          =IMPORTANT=
          =IMPORTANT=
          =IMPORTANT=
          That is, “taskiness” (whether to re-run each time) is a property of
          the key, *NOT* the value.

**** DONE Listing all available setting keys and task keys
     CLOSED: [2022-09-05 Mon 10:46]
     - List ALL /settings/: ~settings~ or ~settings -v~

     - List ALL /tasks/: ~tasks~ or ~tasks -v~

     - A key will be printed in the resulting list if:
       (=from Jian= This is a explanation to the *ALL* in the first two entries)
       * it's /built-in/ sbt (like ~name~ or ~scalaVersion~ in the examples above)
       * you created it as a /custom key/
       * you *imported* a plugin that brought it into the /build definition/.

     - ~help <key>~

     - =TODO= Check [[https://www.scala-sbt.org/1.x/docs/Command-Line-Reference.html][Command Line Reference]].

*** DONE Defining tasks and settings
     CLOSED: [2022-09-05 Mon 10:46]
     Example

     - Define a /task/ ~hello~:
       #+begin_src scala
         lazy val hello = taskKey[Unit]("An example task")

         lazy val root = (project in file("."))
           .settings(
             hello := println("Hello!")
           )
       #+end_src

     - Use a /setting/ ~name~:
       =FIXME= =No "define"= This is not consistent with the title of this section.
       #+begin_src scala
         lazy val root = (project in file("."))
           .settings(
             name := "hello"
           )

       #+end_src

**** Types for tasks and settings
      From a type-system perspective:

      - the ~Setting~ created from a /task/ key is *SLIGHTLY different* from the
        one created from a /setting/ key.
        * Example:
          + ~certainTaskKey := 42~ results in a ~Setting[Task[T]]~
          + ~certainSettingKey := 42~ results in a ~Setting[T]~.

        * For MOST purposes this makes NO difference;
          the /task/ key still creates a value of type ~T~,
          (=from Jian= though in a box ~Task~), when the /task/ executes.

      - The ~T~ vs. ~Task[T]~ type difference has this *implication*:
        a /setting/ *CAN'T* depend on a /task/, because a /setting/ is evaluated
        only once on project load and is not re-run.
        =TODO= =TODO= =TODO= More on this in _task graph_.

*** DONE Keys in sbt shell
     CLOSED: [2022-09-05 Mon 10:46]
     In sbt shell:

     - Type the name of any /task/ to *execute* it.
       * Use ~show <task name>~ to *display* its value

     - Type the name of any /setting/ to *display* its value.

     - The CONVENTION for keys names is to use *camelCase*
       so that the command line name and the Scala identifiers are the SAME.

     - To learn more about any key, type ~inspect <keyname>~ at the sbt interactive
       prompt.

       * Some of the information inspect displays won’t make sense yet, =TODO= =Learn more=
         but at the top it shows you the setting’s value type and a brief
         description of the setting.

*** DONE Imports in =build.sbt=
     CLOSED: [2022-09-05 Mon 10:46]
     - /Import statements/ *at the top* of =build.sbt=;

       =TODO= =Q: WHY DO WE NEED THIS? Old SBT limitation???=
       they need not be separated by blank lines.

     - Implied default imports:
       #+begin_src scala
         import sbt._
         import Keys._
       #+end_src
       * If you have /auto plugins/, the names marked under ~autoImport~ will be imported.
         =TODO= UNDERSTAND THIS.

*** DONE Bare =.sbt= build definition
     CLOSED: [2022-09-05 Mon 10:46]
     - Bare style :: write the _settings_ directly into the =build.sbt= file instead
                     of putting them inside a ~.settings(...)~ call.
       * This syntax is *recommended* for =TODO= =DOC= =SHOW WE ADD "only" before "recommended"=
         + ~ThisBuild~ scoped settings
         + adding plugins.
         =TODO= See later section about the /scoping/ and the /plugins/.

     - Example:
       #+begin_src scala
         ThisBuild / version := "1.0"
         ThisBuild / scalaVersion := "2.12.8"
       #+end_src

*** DONE Adding library dependencies
     CLOSED: [2022-09-05 Mon 10:46]
     Two options:
     1. /unmanaged depdendencies/: Drop jars in =lib/=
        =IMPORTANT=
        =ESPECIALLY when a repository is not available and you have a jar for that dependency=

     2. Add in =build.sbt= through ~libraryDependencies~ as /managed depdendencies/.
        Example:
        #+begin_src scala
          val derby = "org.apache.derby" % "derby" % "10.4.1.3"

          ThisBuild / organization := "com.example"
          ThisBuild / scalaVersion := "2.12.16"
          ThisBuild / version      := "0.1.0-SNAPSHOT"

          lazy val root = (project in file("."))
            .settings(
              name := "Hello",
              libraryDependencies += derby
            )
        #+end_src
        - The ~libraryDependencies~ key involves two complexities:
          * ~+=~ rather than ~:=~:
            Append to the key's old value rather than replacing it.
            =TODO= It is explained in /Task Graph/.

          * the ~%~ /method/:
            It construct an /ivy module ID/ from strings.
            =TODO= It is explained in /Library dependencies/.

        - Details will be covered later on -- there's a whole page (_Library dependencies_) covering it.

** DONE g. Multi-project builds - =START=
   CLOSED: [2019-08-13 Tue 15:35]
   This page introduces _multiple subprojects_ in a single build.

*** DONE Multiple subprojects
    CLOSED: [2019-08-13 Tue 14:21]
     Sometimes users may want to _keep multiple related /subprojects/ in a single
     build_, especially _if they depend on one another and you tend to modify them
     together_.

     - Each /subproject/ in a build
       * has its own source directory.
       * generates its own jar file when run ~package~.

     - For example,
       #+BEGIN_SRC scala
         lazy val util = (project in file("util"))
         lazy val core = (project in file("core"))
       #+END_SRC

       If the name of a base directory is the same as the name of the ~val~, it
       can be omitted.
       #+BEGIN_SRC scala
         lazy val util = project
         lazy val core = project
       #+END_SRC
       * The capacility of the expressiveness is limited by the allowed identifier
         in Scala -- we often want the subproject directory name in the pattern
         of hyphen connected words, but _hyphen_ is not a legal Scala identifier
         character.

**** DONE Build-wide settings
     CLOSED: [2019-08-13 Tue 14:17]
     - Q :: How to factor out common setting across multiple projects?

     - A :: Define the settings scoped to ~ThisBuild~. There are some limitations:
       + the RHS needs to be
         * a pure value
           OR
         * /settings/ scoped to ~Global~ or ~ThisBuild~ TODO What is ~Global~
           =from Jian= my understanding: you can't make forward refererces to
           get values not defined in this or an outer scope.

       + There are no default settings to subprojects. TODO See *Scopes*

     - Example:
       Set the common settings once, and make it affect build-wide settings,
       including all subprojects.
       #+begin_src scala
         ThisBuild / organization := "com.example"
         ThisBuild / version      := "0.1.0-SNAPSHOT"
         ThisBuild / scalaVersion := "2.12.8"

         lazy val core = (project in file("core")).
           settings(
             // other settings
           )


         lazy val util = (project in file("util")).
           settings(
             // other settings
           )
       #+end_src

**** DONE Common settings
     CLOSED: [2019-08-13 Tue 14:21]
     - Another way to factor out _common settings_ across multiple projects is to
       + create a sequence named ~commonSeettings~
         AND
       + call ~settings~ method _on EACH project_.

     - Example:
       #+begin_src scala
         lazy val commonSettings = Seq(
           organization := "com.example",
           version := "0.1.0-SNAPSHOT",
           scalaVersion := "2.12.4"
         )

         lazy val core = (project in file("core")).
           settings(
             commonSettings,
             // other settings
           )

         lazy val util = (project in file("util")).
           settings(
             commonSettings,
             // other settings
           )
       #+end_src

*** DONE Dependencies
    CLOSED: [2019-08-13 Tue 15:20]
    /Subprojects/ _in one build_ can be
    - completely independent of one another.
      OR
    - related to one another by _TWO_ kinds of dependencies:
      * ~aggregate~
      * /classpath/

**** Aggregation
     - Aggregation :: running a task on the _aggregate project_ will also run it
                      on the _aggregated projects_.

     - For example,
       #+BEGIN_SRC scala
         lazy val root = (project in file("."))
           .aggregate(util, core)

         lazy val util = (project in file("util"))
         lazy val core = (project in file("core"))
       #+END_SRC
       + When you run ~compile~ in the sbt shell (by default, you are in the
         ~root~ subproject),
         _all three projects will be compiled_.

       + If you want to compile one /subproject/ that being aggregated, rather
         than the ~root~, you need to
         1. use ~project <project name>~ to switch to that /subproject/
         2. ~compile~

     - /aggregation/ will run the aggregated tasks *in parallel and with no
       defined ordering between them*.

     - Control aggregation per-task
       For example, avoid aggregating the ~update~ task:
       #+BEGIN_SRC scala
         lazy val root = (project in file("."))
           .aggregate(util, core)
           .settings(
             update / aggregate := false
           )

         lazy val util = (project in file("util"))
         lazy val core = (project in file("core"))
       #+END_SRC
       + ~update / aggregate~ is the aggregate key scoped to the ~update~ task.
         TODO See *scopes*.

**** Classpath dependencies
     #+begin_src scala
     lazy val core = project.dependsOn(util)
     #+end_src
     ~dependsOn~ can have multiple arguments.

***** Per-configuration classpath dependencies*
      - ~foo.dependsOn(bar)~ means that _the /compile configuration/ in ~foo~
        depends on the /compile configuration/ in ~bar~._

        This can be written explicitly as:
        ~foo.dependsOn(bar % "compile -> compile")~, where the ~-> compile~
        part can be ignored, which is the default, no matter what before the
        ~->~.

      - A useful declaration is ~test->test~.
        This allows you to put utility code for testing in ~bar/src/test/scala~
        and then use that code in ~foo/src/test/scala~, for example.

      - There can be multiple configurations for a dependency, separated by
        semicolons. For example,
        ~dependsOn(bar % "test->test; compile->compile")~.

      - =TODO= =From Jian=
        Can I put spaces around ~->~???

*** TODO Inter-project dependencies =TODO= =NOT-often-used!!!=
*** TODO Default root project
    If a project is NOT defined for the root directory in the build,
    sbt creates a default one that aggregates all other projects in the build.

*** DONE Navigating projects interactively
    CLOSED: [2019-08-13 Tue 15:34]
    - Use ~projects~ to list all /subprojects/, including the /root project/.
      =From Jian= Remember? In this document, /project/ and /subproject/ are
      exchangeable.

    - When you start a /sbt shell/, *the /root project/ is selected by default.*

    - Run a command on a specific subproject:
      * Use ~project <projectName>~ to select that a specific subproject.
        And then, run command like ~compile~.

      * When you are in /subproject/ ~A~, you can run the command in another
        /subproject/ with the syntax ~subProjectID/command~

*** DONE Common code
    CLOSED: [2019-08-13 Tue 15:32]
   *The definitions in =.sbt= files are not visible in other =.sbt= files.*

   In order to share code between =.sbt= files,
   define one or more =.scala= files in the =project/= directory of the /build
   root/.

   - =TODO= See *organizing the build* for details.

*** TODO Appendix: Subproject build definition files

** DONE h. Task graph - =TODO= =FIXME???= =head level issue=
   CLOSED: [2022-11-18 Fri 15:52]
   Continuing from /build definition/, this page explains =build.sbt= definition
   in more detail.

   - RATHER THAN thinking of settings as _key-value pairs_,
     a *better analogy* would be to think of it as a /DAG/ of /tasks/
     where the _edges denote /happens-before/._
     * *Let's call this the /task graph/.*

*** DONE Terminology
    CLOSED: [2019-08-13 Tue 15:59]
     Review before dive in:
     - Setting/Task expression :: entry inside ~.settings(...)~.

     - Key :: LHS of ~:=~ in a /setting\slash{}task expression/.
              It could be a ~SettingKey[A]~, a ~TaskKey[A]~, or an ~InputKey[A]~.

     - Setting :: Defined by a /setting expression/ with ~SettingKey[A]~.
                  The value is calculated _ONCE during load_.

     - Task :: Defined by a /task expression/ with ~TaskKey[A]~.
               The value is calculated _EACH TIME it is invoked_.

*** DONE Declaring dependency to other tasks
    CLOSED: [2022-11-17 Thu 15:06]
    =IMPORTANT= *This is very tricky!!!!!*

    - _In =build.sbt= DSL_, we use ~.value~ /method/ to _express the dependency
      to another /task/ or /setting/._

    - =IMPORTANT=
      The ~value~ /method/ is *SPECIAL* (explained later) and *may ONLY* be called
      in the argument to ~:=~ (or, ~+=~ or ~++=~, which we'll see later).

    - Example
      *Note*: The values calculated below are nonsensical for ~scalaOptions~,
              and it's just for demonstration purpose only:
      #+begin_src scala
        // build.sbt
        val scalacOptions = taskKey[Seq[String]]("Options for the Scala compiler.")
        val update = taskKey[UpdateReport]("Resolves and optionally retrieves dependencies, producing a report.")
        val clean = taskKey[Unit]("Deletes files produced by the build, such as generated sources, compiled classes, and task caches.")

        scalacOptions := {
          val ur = update.value  // `update` task happens-before `scalacOptions`
          val x = clean.value    // `clean` task happens-before `scalacOptions`
          // ---- `scalacOptions` begins here ----
          ur.allConfigurations.take(3)
        }
      #+end_src
      * ~update.value~ and ~clean.value~ declare /task dependencies/, whereas
        ~ur.allConfigurations.take(3)~ is the body of the /task/.

      * =IMPORTANT=
        =IMPORTANT=
        =IMPORTANT=
        ~.value~ is *NOT a normal Scala method call*.
        =build.sbt= DSL _uses a /macro/ to *lift* these *outside* of the /task body/._
        Both ~update~ and ~clean~ /tasks/ are completed by the time task engine
        evaluates the opening ~{~ of ~scalacOptions~ _regardless of which line
        it appears in the body_.

        For example,
        + #1
          #+BEGIN_SRC scala
            ThisBuild / organization := "com.example",
            ThisBuild / scalaVersion := "2.12.16",
            ThisBuild / version := "0.1.0-SNAPSHOT",

            lazy val root = (project in file(".")).
              settings(
                name := "Hello",
                scalacOptions := {
                  val out = clean.value  // `clean` task happens-before `scalacOptions`
                  val log = out.log
                  log.info("123")
                  val ur = update.value  // `update` task happens-before `scalacOptions`
                  log.info("456")
                  ur.allConfigurations.take(3)
                }
              )

            // > scalacOptions
            // [info] Updating {file:/xxx/}root...
            // [info] Resolving jline#jline;2.14.1 ...
            // [info] Done updating.
            // [info] 123
            // [info] 456
            // [success] Total time: 0 s, completed Jan 2, 2017 10:38:24 PM
          #+END_SRC
          From the out, it clear:
          run ~clean~ and ~update~ before the ~{~ of ~scalacOptions~

        + #2
          #+BEGIN_SRC scala
            ThisBuild / organization := "com.example",
            ThisBuild / scalaVersion := "2.12.16",
            ThisBuild / version := "0.1.0-SNAPSHOT",

            lazy val root = (project in file("."))
              .settings(
                name := "Hello",
                scalacOptions := {
                  val ur = update.value  // update task happens-before scalacOptions
                  if (false) {
                    val x = clean.value  // clean task happens-before scalacOptions
                  }
                  ur.allConfigurations.take(3)
                }
              )

            // > run
            // [info] Updating {file:/xxx/}root...
            // [info] Resolving jline#jline;2.14.1 ...
            // [info] Done updating.
            // [info] Compiling 1 Scala source to /Users/eugene/work/quick-test/task-graph/target/scala-2.12/classes...
            // [info] Running example.Hello
            // hello
            // [success] Total time: 0 s, completed Jan 2, 2017 10:45:19 PM

            // > scalacOptions
            // [info] Updating {file:/xxx/}root...
            // [info] Resolving jline#jline;2.14.1 ...
            // [info] Done updating.
            // [success] Total time: 0 s, completed Jan 2, 2017 10:45:23 PM
          #+END_SRC
          Now if you check for =target/scala-2.12/classes/=, it won't exist
          because ~clean~ task has run EVEN THOUGH it is inside the ~if (false)~.

      * =IMPORTANT=
        *NO guarantee* about _the ORDERING of ~update~ and ~clean~ /tasks/._
        Can be
        + ~update~ before ~clean~
        + ~clean~ before ~update~
        + in parallel

**** Inlining ~.value~ calls =FIXME= =Should level down??? Or level up the following 3 sections???=
     - Because of the specialty of ~.value~,
       =IMPORTANT=
       =IMPORTANT=
       =IMPORTANT=
       _UNTIL you're familiar with =build.sbt=,_
       we RECOMMEND you *put all ~.value~ calls at the _TOP_ of the /task body/.*

     - Inlining ~.value~ to simplify code:
       #+BEGIN_SRC scala
         scalaOptions := {
           val x = clean.value
           update.value.allConfigurations.take(3)  // Inline the `update.value`
         }
       #+END_SRC
       You can use this to simplify the code of your build, and then you don't
       need to give a name to ~update.value~ in this example.

     - *CAUTION*: =From Jian= =IMPORTANT=
       I don't think this is a good feature.
       I'll try to avoid using inlining in projects.

**** Inspecting the task
     From the output of ~inspect <task name>~, you can find the information
     about this task, including dependencies info.

     - Detailed inspection with a tree structure:
       ~inspect tree <task name>~

     - =IMPORTANT=
       If you use a _key_'s ~value~ in another computation,
       then the computation *depends on* that _key_.

**** Defining a task that depends on other settings
     - SUMMARY (for this section and the following section):
       * legal:
         + A /setting key/ depends on another /setting key/
         + A /task key/ depends on a /setting key/

       * *ILLEGAL*:
         + A /setting key/ depends on a /task key/
           - =from Jian=
             This is clear if you consider in sbt how keys of different types
             _evaluate in DIFFERENT ways_.

     - A /setting key/ depends on another /setting key/,
       * Example:
         #+begin_src scala
           lazy val root = (project in file("."))
             .settings(
               name := "Hello",
               organization := "com.example",
               scalaVersion := "2.12.4",
               version := "0.1.0-SNAPSHOT",
               scalacOptions := List("-encoding", "utf8", "-Xfatal-warnings", "-deprecation", "-unchecked"),
               scalacOptions := {
                 val old = scalacOptions.value
                 scalaBinaryVersion.value match {
                   case "2.12" => old
                   case _      => old filterNot (Set("-Xfatal-warnings", "-deprecation").apply)
                 }
               }
             )

           // > show scalacOptions
           // [info] * -encoding
           // [info] * utf8
           // [info] * -Xfatal-warnings
           // [info] * -deprecation
           // [info] * -unchecked
           // [success] Total time: 0 s, completed Jan 2, 2017 11:44:44 PM
           //
           // > ++2.11.8!
           // [info] Forcing Scala version to 2.11.8 on all projects.
           // [info] Reapplying settings...
           // [info] Set current project to Hello (in build file:/xxx/)
           //
           // > show scalacOptions
           // [info] * -encoding
           // [info] * utf8
           // [info] * -unchecked
           // [success] Total time: 0 s, completed Jan 2, 2017 11:44:51 PM
         #+end_src

       * The ~++2.11.8!~ command can force the Scala version choice on all projects,
         and then we can see the content of ~scalacOptions~ is different when the
         ~scalaBinaryVersion~ is different, as expected.

     - A /task key/ can depend on /a setting key/, if two keys have the same
       value type.
       #+BEGIN_SRC scala
         val scalacOptions = taskKey[Seq[String]]("Options for the Scala compiler.")
         val checksums = settingKey[Seq[String]]("The list of checksums to generate and to verify for dependencies.")

         scalacOptions := checksums.value

         // Illegal
         checksums := scalacOptions.value
       #+END_SRC
       * The code above is meaningless for a real build, and it is just a illustration.

       * _There is *NO way* to go the other direction_:
         a /task key/ *CANNOT* depend on a /setting key/.

**** Defining a setting that depends on other settings
     In terms of the execution timing,
     we can think of the /settings/ as a _special tasks_ that evaluate DURING
     loading time.

     - =IMPORTANT=
       =IMPORTANT=
       =IMPORTANT=
       Here's a realistic example (=from Jian= Real world project use this FREQUENTLY):
       #+BEGIN_SRC scala
         Compile / scalaSource := {
           val old = (Compile / scalaSource).value
           scalaBinaryVersion.value match {
             case "2.11" => baseDirectory.value / "src-2.11" / "main" / "scala"
             case _      => old
           }
         }
       #+END_SRC
       This rewires ~scalaSource~ in ~Compile~ key to a different directory only
       when ~scalaBinaryVersion~ is "2.11".

*** TODO Inlining ~.value~ calls
**** Inspecting the task
**** Defining a task that depends on other settings
**** Defining a setting that depends on other settings

*** DONE What's the point of the =build.sbt= DSL?
    CLOSED: [2022-11-18 Fri 15:51]
    We use /the =build.sbt= domain-specific language (DSL)/ to construct a /DAG/
    of /settings/ and /tasks/.

    - The /setting expressions/ encode
      * /settings/,
      * /tasks/ and
      * the /dependencies among them/.

    - This structure is _COMMON_ to
      * Make (1976),
      * Ant (2000), and
      * Rake (2003).

**** Intro to Make
     We can think of this as /dependency-oriented programming/, or /flow-based
     programming/.

     - *Make* is actually considered a _hybrid system_
       because
         while the DSL describes the task dependencies, the actions are
       *delegated to* system commands.

**** Rake
**** Benefits of hybrid flow-based programming
     There are several _MOTIVATION_ to organizing the build this way:

     1. De-duplication, not the code, but the execution.
          With flow-based programming, a /task/ is executed *ONLY ONCE* even
        when it is depended by MULTIPLE /tasks/.
        * For example,
          even when MULTIPLE /tasks/ along the /task graph/ depend on ~Compile /
          compile~, the compilation will be executed *exactly once*.

     2. Parallel
        The task engine can schedule *mutually non-dependent* /tasks/ in PARALLEL.

     3. The separation of concern and the flexibility.
        * Use the /task graph/ to wire the /tasks/ together, while

        * /sbt/ and /plugins/ can provide various features such as
          _compilation_ and _library dependency management_ as functions that
          can be reused.

*** DONE Summary
    CLOSED: [2022-11-18 Fri 15:51]
    - The _CORE data structure_ of the /build definition/ is a /DAG of tasks,/
      where the _edges_ denote *happens-before* relationships.

    - =build.sbt= is a DSL designed to express /dependency-oriented
      programming/, or /flow-based programming/, similar to _Makefile_ and
      _Rakefile_.

    - The *key MOTIVATION* for the /flow-based programming/ is
      * de-duplication,
      * parallel processing, and
      * customizability.

** TODO i. Scopes
*** The whole story about keys
*** Scope axes
**** Scoping by the subproject axis
**** Scoping by the configuration axis
**** Scoping by Task axis
**** Zero scope component

*** Referring to scopes in a build definition
*** Referring to scoped keys from the sbt shell
*** Examples of scoped key notation in the sbt shell
*** Inspecting scopes
*** When to specify a scope
*** Build-level settings
*** Scope delegation

** DONE j. Appending values
   CLOSED: [2022-11-18 Fri 16:18]
   - *Appending to previous values:* ~+=~ and ~++=~
     * When the value type, i.e. the ~T~ in ~SettingKey[T]~, is a sequence, we
       have _TWO_ more operations (besides ~:=~):
       + ~+=~ will append a single element to the sequence.

       + ~++=~ will concatenate another sequence.

     * For example,
       #+BEGIN_SRC scala
         // Use `+=`
         sourceDirectories in Compile += new File("source")
         // // Or
         sourceDirectories in Compile += file("source")


         // Use `++=`
         sourceDirectories in Compile ++= Seq(file("sources1"), file("sources2"))
       #+END_SRC

*** TODO Appending to previous values: ~+=~ and ~++=~
**** DONE When settings are undefined
     CLOSED: [2022-11-18 Fri 16:14]
     Whenever a /setting/ uses ~:=~, ~+=~, or ~++=~ to _create a dependency_ on
     itself or another key's value

     - _Depends on *MUST* exist._
       OR ELSE,
       sbt will complain "Reference to undefined setting".
       * When this happens,
         + Be sure you're using the key in the /scope/ that defines it.

       * It's possible to *CREATE cycles*, which is an error;
         _sbt will TELL you if you do this._

**** TODO Tasks based on other keys' values - =TODO= =???=
     - ~Def.task~
       =TODO= =???=  =TODO= =???=

*** DONE Appending with dependencies: ~+=~ and ~++=~
    CLOSED: [2022-11-18 Fri 16:18]
    For example,
    say you have a _coverage report_ named after the project, and
    you want to add it to the files removed by ~clean~:
    #+begin_src scala
      cleanFiles += file("coverage-report-" + name.value + ".txt")
    #+end_src

** DONE k. Scope delegation (~.value~ lookup)
   CLOSED: [2022-11-18 Fri 19:15]
   - Summary so far:
     * A /scope/ is a /tuple/ of components in *three* axes:
       + the _subproject_ axis
       + the _configuration_ axis
       + the _task_ axis

     * A SPECIAL /scope/ component ~Zero~ for ANY of the /scope axes/.

     * ~ThisBuild~ is a special scope component for the /subprojects axis/.

     * ~Test~ extends ~Runtime~
       ~Runtime~ extends ~Compile~

     * The *default* /scope/ for keys in =built.sbt= is
       ~${current subproject} / Zero / Zero~.

     * A key can be scoped using ~/~ operator.

   - Example:
     #+begin_src scala
       lazy val foo = settingKey[Int]("")
       lazy val bar = settingKey[Int]("")

       lazy val projX = (project in file("x")) .settings(
         foo := {
           (Test / bar).value + 1
         },
         Compile / bar := 1
       )
     #+end_src
     Check Rule 3 for detailed explanation.

   - Scope Delegation :: a well-defined _fallback search path_ for sbt.
     * This feature allows you to set a value once in a *more general* /scope/,
       allowing multiple *more specific* /scopes/ to *inherit* the value.

*** Scope delegation rules
    Here are the rules for /scope delegation/:
    - Rule 1:
      /Scope axes/ have the following *precedence*:
      * the /subproject axis/ (Highest),
      * the /configuration axis/ (Middle),
      * and then the /task axis/ (Lowest).

    - Rule 2 (for the /task axis/):
      Given a /scope/, /delegate scopes/ are searched by
      _SUBSTITUTING_ the /task axis/ in the following order:
      1. the given /task scoping/,
      2. and then ~Zero~, which is non-task scoped version of the /scope/.

    - Rule 3 (for the /configuration axis/):
      Given a /scope/, /delegate scopes/ are searched by
      _SUBSTITUTING_ the /configuration axis/ in the following order:
      1. the given configuration,
      2. its parents,
      3. their parents and so on,
      4. and then ~Zero~ (same as /unscoped configuration axis/).

    - Rule 4 (for the /subproject axis/):
      Given a /scope/, /delegate scopes/ are searched by
      _SUBSTITUTING_ the /subproject axis/ in the following order:
      1. the given /subproject/,
      2. ~ThisBuild~,
      3. and then ~Zero~.

    - Rule 5: =IMPORTANT=
      A /delegated scoped key/ and its _dependent settings/tasks_ are
      _evaluated *without* carrying the original context._

*** DONE Rule 1: Scope axis precedence
    CLOSED: [2022-09-09 Fri 21:36]
    =from Jian=
    This means when comparing two scopes, the order of them can be decided
    like comparing two triples by default (metaphor: the relation between
    ~Ordering[A]~, ~Ordering[B]~, ~Ordering[C]~, and ~Ordering[(A, B, C)]~),
    from left to right.

*** DONE Rule 2: The task axis delegation
    CLOSED: [2022-09-09 Fri 21:53]
    Example A: Given the following /build definition/:
    #+begin_src scala
      lazy val projA = (project in file("a"))
        .settings(
          name :=  {
            "foo-" + (packageBin / scalaVersion).value
          },
          scalaVersion := "2.11.11"
        )
    #+end_src
    The value of ~projA / name~ is ~"foo-2.11.11"~.

    - The key in the ~settings(...)~ of ~projA~ is automatically scoped to
      ~projA / Zero / Zero~ if no other scope info given. Therefore,
      1. The complete form of ~packageBin / scalaVersion~ is
         ~projA  / Zero / packageBin / scalaVersion~.

      2. Since this particular scoped key ~projA  / Zero / packageBin / scalaVersion~
         is undefined, by using Rule 2, sbt will substitute the /task axis/ to
         ~Zero~ as ~projA / Zero / Zero~, and the key ~projA / Zero / Zero /
         scalaVersion~, whoes value is ~"2.11.11"~, is selected.

*** DONE Rule 3: The configuration axis search path
    CLOSED: [2022-09-09 Fri 22:08]
    #+begin_src scala
      lazy val foo = settingKey[Int]("")
      lazy val bar = settingKey[Int]("")

      lazy val projX = (project in file("x")).settings(
        foo := {
          (Test / bar).value + 1
        },
        Compile / bar := 1
      )
    #+end_src
    - The full scope of ~bar~ in ~settings~ is ~projX / Test / Zero~.

    - Since ~Test~ extends ~Runtime~, and ~Runtime~ extends ~Compile~,
      due to Rule 3 sbt will look for ~bar~ scoped (in order) in
      1. ~projX / Test / Zero~
      2. ~projX / Runtime / Zero~
      3. ~projX / Compile / Zero~
      Here only the last one is defined, and it is found.

*** DONE Rule 4: The subproject axis search path
    CLOSED: [2022-11-18 Fri 18:47]
    #+begin_src scala
      ThisBuild / organization := "com.example"

      lazy val projB = (project in file("b")) .settings(
        name := "abc-" + organization.value,
        organization := "org.tempuri"
      )

    #+end_src
    The value of ~projB / name~ is ~"abc-org.tempuri"~

    - So based on Rule 4,
      the first search path is ~organization~ scoped to ~projB / Zero / Zero~, which
      is defined in ~projB~ as ~"org.tempuri"~.
        This has *HIGHER precedence* than the _build-level setting ~ThisBuild /
      organization~._

**** DONE Scope axis precedennce, again
     CLOSED: [2022-11-18 Fri 18:53]
     =from Jian=
     Useful excises, I get right answers =2022-11-18=
     =RE-DO= it later.

     - Exercise C: Given the following build definition:
     - Exercise D: Given the following build definition:

*** DONE Inspect command lists the delegates
    CLOSED: [2022-11-18 Fri 18:59]
    =IMPORTANT=
    =IMPORTANT=
    =IMPORTANT=
    The ~inspect~ can show the /delegates/

    #+begin_src scala
      sbt:projd> inspect projD / Compile / console / scalacOptions
        [info] Task: scala.collection.Seq[java.lang.String]
        [info] Description:
        [info]  Options for the Scala compiler.
        [info] Provided by:
        [info]  ProjectRef(uri("file:/tmp/projd/"), "projD") / Compile / scalacOptions
        [info] Defined at:
        [info]  /tmp/projd/build.sbt:9
        [info] Reverse dependencies:
        [info]  projD / test
        [info]  projD / Compile / console
        [info] Delegates:
        [info]  projD / Compile / console / scalacOptions
        [info]  projD / Compile / scalacOptions
        [info]  projD / console / scalacOptions
        [info]  projD / scalacOptions
        [info]  ThisBuild / Compile / console / scalacOptions
        [info]  ThisBuild / Compile / scalacOptions
        [info]  ThisBuild / console / scalacOptions
        [info]  ThisBuild / scalacOptions
        [info]  Zero / Compile / console / scalacOptions
        [info]  Zero / Compile / scalacOptions
        [info]  Zero / console / scalacOptions
        [info]  Global / scalacOptions
    #+end_src

*** DONE ~.value~ lookup vs dynamic dispatch - =RE-READ= =RE-DO=
    CLOSED: [2022-11-18 Fri 19:15]
    =from Jian=
    Useful excises, I get right answer for E =2022-11-18=
    =RE-DO= it later.
    =RE-DO= Solve F by myself without any help or hint

    - Exercise E: Given the following build definition:
    - Exercise F: Given the following build definition:

** DONE l. Library dependencies
   CLOSED: [2017-12-20 Wed 14:44]
   - Library dependencies can be added in _TWO_ ways:
     * unmanaged dependencies :: jars dropped into the =lib= directory.

     * managed dependencies :: packages configured in the build definition and
          downloaded automatically from repositories.

*** DONE Unmanaged dependencies
    * If you want the simplest use of /unmanaged dependencies/, there's NOTHING
      to add to =build.sbt=, just put jar's in the =lib= directory in your
      project.

    * /Dependencies/ in =lib= go on all the /classpaths/ (for ~compile~, ~test~,
      ~run~, and ~console~).

      If you wanted to change the /classpath/ for just one of those, you would
      adjust ~dependencyClasspath in Compile~ or
      ~dependencyClasspath in Runtime~ for example.

    * If you want, you can change ~unmanagedBase~ key to use a different
      directory rather than =lib=. For example, use =custom_lib= instead:
      ~unmanagedBase := baseDirectory.value / "custom_lib"~
      Here ~baseDirectory~ is the project root directory.

    * ~unmanagedJars~ task: lists the jars from the ~unmanagedBase~ directory.

    * If you need to use multiple directories for /unmanaged packages/, you
      might need to replace the whole ~unmanagedJars~ task with the one that can
      do something to help you. e.g. empty the list for ~Compile~ configuration
      regardless of the files in =lib= directory:
      ~unmanagedJars in Compile := Seq.empty[sbt.Attributed[java.io.File]]~

*** DONE Managed Dependencies - =TODO= =CONTENT=
    * *The ~libraryDependencies~ key*
      + ~libraryDependencies~ is declared in ~sbt.Keys~ as
        ~val libraryDependencies = settingKey[Seq[ModuleID]]("Declares managed dependencies.")~

      + Add a dependency:
        - ~libraryDependencies += groupID % artifactID % revision~

        - ~libraryDependencies += groupID % artifactID % revision % configuration~
          The ~configuration~ above can be
          * a string
            OR
          * a ~Configuration~ val

      + ~%~ can help to convert a string to ~ModuleID~ to satisfy the
        declaration of ~libraryDependencies~

    * For example, type
      ~libraryDependencies += "org.apache.derby" % "derby" % "10.4.1.3"~ into
      =build.sbt= and then ~update~, sbt should download Debry to
      ~/.ivy2/cache/org.apache.derby/~

      Note: you actually rarely type ~update~ command for _TWO_ reasons
      + ~compile~ depends on ~update~, when you call ~compile~ related tasks,
        ~update~ will be run automatically.

      + IDEs like Intellij idea can be configured to run ~update~ when they
        detect the change of =build.sbt=

    * You can also use ~++=~, and you rarely use ~:=~

    * *Getting the right Scala version with* ~%%~
      ~%%~ is a shortcut. If ~scalaVersion~ for your build is set to 2.11.1, the
      two lines below are equivalent:
      + ~libraryDependencies += "org.scala-tools" % "scala-stm_2.11.1" % "0.3"~
      + ~libraryDependencies += "org.scala-tools" %% "scala-stm" % "0.3"~

      many dependencies are compiled for multiple Scala versions, and you’d like
      to get the one that matches your project to ensure binary compatibility.

      + =TODO= See /Cross Building/ for more details.

    * *Ivy revisions*
      =TODO= See the /Ivy revisions/ documentation for details. =TODO=

      The revision does NOT have to be a single fixed version.
      You can specify ~"latest.integration"~, ~"2.9.+"~, or ~"[1.0,)"~.

    * *Resolvers*
      + /sbt/ uses the standard Maven2 repository by default.

      + If this CANNOT cover all your cases, you'll have to add a /resolver/ to
        help Ivy find it. The pattern is ~resolvers += <name> at <location>~.
        For example,
        ~resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"~

      + This key is defined in ~sbt.Keys~:
        ~val resolvers = settingKey[Seq[Resolver]]("The user-defined additional resolvers for automatically managed dependencies.")~

      + If you want to search your local Maven repository
        ~resolvers += "Local Maven Repository" at "file://" + Path.userHome.absolutePath + "/.m2/repository"~
        or, for convenience:
        ~resolvers += Resolver.mavenLocal~

      + See /Resolvers/ for details on defining other types of repositories.

    * *Overriding default resolvers*
      + ~resolvers~ does NOT contain the /default resolvers/;
        only additional ones added by your build definition.

      + sbt combines ~resolvers~ with some /default repositories/ to form
        ~externalResolvers~.

      + To _change_ or _remove_ the /default resolvers/, you would need to
        _OVERRIDE_ ~externalResolvers~ instead of ~resolvervs~.

    * *Per-configuration dependencies*
      Often some dependencies (like ~ScalaCheck~, ~Specs2~, and ~ScalaTest~) are
      used by your test code (by default in =src/test/scala=, which is compiled
      by the ~Test~ configuration) but NOT your main code.

      + If you want a dependency to show up in the /classpath/ ONLY for the
        ~Test~ configuration and NOT the ~Compile~ configuration, add ~% "test"~
        like this:
        ~libraryDependencies += "org.apache.derby" % "derby" % "10.4.1.3" % "test"~

      + You may also use the _type-safe version_ of ~Test~ configuration as
        follows:
        ~libraryDependencies += "org.apache.derby" % "derby" % "10.4.1.3" % Test~

      + After doing this,
        this library is NOT listed in ~compile:dependencyClasspath~,
        but it is listed ~test:dependencyClasspath~

** DONE m. Using plugins =TODO= =A lot of questions=
*** DONE What is a plugin?
    A plugin extends the build definition, most commonly by adding _NEW_
    /settings/. The new settings could be _NEW_ /tasks/.

    For example, a plugin could add a ~codeCoverage~ task which would
    generate a test coverage report.

*** DONE Declaring a plugin
    - If your project is in directory =hello=, and you’re adding /sbt-site
      plugin/ to the build definition, create =hello/project/site.sbt= and
      declare the plugin dependency by passing the plugin's /Ivy module ID/ to
      ~addSbtPlugin~:
      ~addSbtPlugin("com.typesafe.sbt" % "sbt-site" % "0.7.0")~

    - If add /sbt-assembly/ (=TODO= ???), create =hello/project/assembly.sbt=
      with the following:
      ~addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "0.11.2")~

    - If not located on one of the default repositories =TODO= =???=
      ~resolvers += Resolver.sonatypeRepo("public")~

    - =TODO= See next section.

*** DONE Enabling and disabling auto plugins
    - =TODO=
      As of _sbt 0.13.5_, there is a new /auto plugins/ feature that enables
      plugins to automatically, and safely, ensure their settings and
      dependencies are on a project.

      Many /auto plugins/ should have their default settings automatically,
      however _some may require explicit enablement_. For example,
      #+BEGIN_SRC scala
        lazy val util = (project in file("util"))
          .enablePlugins(FooPlugin, BarPlugin)
          .settings(
            name := "hello-util"
          )
      #+END_SRC

      * ~enablePlugins~ method :: it allows projects to explicitly define the
           /auto plugins/ they wish to consume.
           =TODO= =???=

    - ~disablePlugins~ method :: exclude plugins in some project.
      * For example, remove ~IvyPlugin~ /settings/ from ~util~
        #+BEGIN_SRC scala
          lazy val util = (project in file("util"))
            .enablePlugins(FooPlugin, BarPlugin)
            .disablePlugins(plugins.IvyPlugin)
            .settings(
              name := "hello-util"
            )
        #+END_SRC

    - /Auto plugins/ _should document whether they need to be explicitly enabled_.
      =TODO= =IMPORTANT=

    - Run the ~plugins~ command to list the enabled auto plugins.
      For example,
      #+BEGIN_SRC text
        > plugins
        In file:/home/jsuereth/projects/sbt/test-ivy-issues/
                sbt.plugins.IvyPlugin: enabled in scala-sbt-org
                sbt.plugins.JvmPlugin: enabled in scala-sbt-org
                sbt.plugins.CorePlugin: enabled in scala-sbt-org
                sbt.plugins.JUnitXmlReportPlugin: enabled in scala-sbt-org
      #+END_SRC

      This output is showing that the /sbt default plugins/ are all _enabled_.

      * sbt’s default settings are provided via three plugins: =TODO= =???=
        + ~CorePlugin~:
          Provides the core parallelism controls for tasks.

        + ~IvyPlugin~:
          Provides the mechanisms to publish/resolve modules.

        + ~JvmPlugin~:
          Provides the mechanisms to compile/test/run/package Java/Scala projects.

      In addition, ~JUnitXmlReportPlugin~ provides an experimental support for
      generating /junit-xml/.

    - Older non-auto plugins often require settings to be added explicitly. The
      plugin documentation will indicate how to configure it, but typically for
      older plugins this involves adding the base settings for the plugin and
      customizing as necessary.

      For example, for the sbt-site plugin, create =site.sbt= with the following
      content ~site.settings~ to enable it for that project.

      If there is multiple projects, add it to a specific one:
      #+BEGIN_SRC scala
        // don't use the site plugin for the `util` project
        lazy val util = (project in file("util"))

        // enable the site plugin for the `core` project
        lazy val core = (project in file("core"))
          .settings(site.settings)
      #+END_SRC

*** DONE Global plugins
    Plugins can be installed for _ALL_ your projects at once by declaring them
    in =~/.sbt/1.0/plugins/= (=From Jian= I think this =1.0= is the main
    version number of sbt. Am I right???).

    Roughly speaking, any =.sbt= or =.scala= in this directory behaves as if they
    were in the =project/= directory for _ALL_ projects.

    - One thing you can, but you should use sparingly:
      create =build.sbt= in this global directory, and put ~addSbtPlugin~
      expressions in it to add plugins to all your projects at once.

      Use this feature you increase the dependency on the machine environment,
      which is _NOT good_.

*** DONE Available Plugins -  =TODO= =Links=
    =TODO= A link in this document to a list of available plugins.

    - Some especially popular plugins are:
      * those for IDEs (to import an sbt project into your IDE)
      * those supporting web frameworks, such as /xsbt-web-plugin/.

    - See the *Plugins* section for More details

    - See the *Plugins-Best-Practices* section for More details.

** DONE n. Custom settings and tasks
   CLOSED: [2017-12-21 Thu 17:50]
   This page gets you started _creating_ your own /settings/ and /tasks/.

*** DONE Defining a key
    - /Keys/ have one of _THREE types_:
      * ~SettingKey~ (read /.sbt build definition/)
      * ~TaskKey~ (read /.sbt build definition/)
      * ~InputKey~ (read /Input Tasks/ page)

    - =TODO= =Something Wrong???=
      This document says
      #+BEGIN_QUOTE
      The key constructors have two string parameters:
      the name of the key (like "scalaVersion") and
      a documentation string (like "The version of scala used for building.").
      #+END_QUOTE

      However, the definition is in this form
      ~val scalaVersion = settingKey[String]("The version of scala used for building.")~

    - Keys may be defined in an =.sbt= file, a =.scala= file, or in an /auto
      plugin/. Any ~val~'s found under ~autoImport~ object of an enabled /auto
      plugin/ will be imported automatically into your =.sbt= files.

*** DONE Implementing a task
    - Use ~:=~ to associate some code with the task key.
      For example,
      #+BEGIN_SRC scala
        val sampleStringTask = taskKey[String]("A sample string task.")
        val sampleIntTask = taskKey[Int]("A sample int task.")

        lazy val commonSettings = Seq(
          organization := "com.example",
          version := "0.1.0-SNAPSHOT"
        )

        lazy val library = (project in file("library"))
          .settings(
            commonSettings,
            sampleStringTask := System.getProperty("user.home"),
            sampleIntTask := {
              val sum = 1 + 2
              println("sum: " + sum)
              sum
            }
          )
      #+END_SRC

    - The hardest part about implementing /tasks/ is often NOT sbt-specific;
      /tasks/ are just Scala code.

*** DONE Execution semantics of tasks
    By /execution semantics/, we mean exactly _WHEN_ these /tasks/ are evaluated

    Assume ~startServer~ and ~stopServer~ are two /tasks/, you
    Put the callings of their ~value~ methods in order WON'T make them run _in
    order_. This is the property of /tasks/.

**** TODO Deduplication of task dependencies
**** DONE Cleanup task
     The last operation should become the task that depends on other
     intermediate tasks. For instance ~stopServer~ should depend on
     ~sampleStringTask~, _at which point ~stopServer~ should be the
     ~sampleStringTask~._

     =From Jian= WHY NOT name the last ~sampleStringTask~ as ~stopServer~, and
     set its dependencies as ~sampleStringTask~?

     #+BEGIN_SRC scala
       val startServer = taskKey[Unit]("start server")
       val stopServer = taskKey[Unit]("stop server")
       val sampleIntTask = taskKey[Int]("A sample int task.")
       val sampleStringTask = taskKey[String]("A sample string task.")

       lazy val commonSettings = Seq(
         organization := "com.example",
         version := "0.1.0-SNAPSHOT"
       )

       lazy val library = (project in file("library"))
         .settings(
           commonSettings,
           startServer := {
             println("starting...")
             Thread.sleep(500)
           },
           sampleIntTask := {
             startServer.value
             val sum = 1 + 2
             println("sum: " + sum)
             sum
           },
           sampleStringTask := {
             startServer.value
             val s = sampleIntTask.value.toString
             println("s: " + s)
             s
           },
           sampleStringTask := {
             val old = sampleStringTask.value
             println("stopping...")
             Thread.sleep(500)
             old
           }
         )
     #+END_SRC

**** DONE Use plain Scala
     You can also use plain scala to force the order.
     Scala program plain method calls follow /sequential semantics/.

     However, plain scala code won't implement deduplication, so you have to be
     careful about that.

*** DONE Turn them into plugins
    =TODO=
    It's very easy to create a plugin, as /teased earlier/ and /discussed at
    more length here/.

** DONE o. Organizing the build
   CLOSED: [2022-09-07 Wed 01:59]
*** sbt is recursive
    - The build files conceals how sbt really works.
      The content of build files are Scala code, which, itself, has to be built.
      * Q :: How to build them?
      * A :: We need a another build (/meta-build/) for the project build.

    - proper build :: your build for your project

    - meta-build :: the build in =project= that is for building your project build

    - The =project= directory is the /meta-build/.

    - The =project='s inside the /meta-build/ can do anything any other =project= can do.

    - Your /build definition/ is an /sbt project/.

    - If you like, you can tweak the /build definition/ of the /build definition/ project,
      by creating a =project/project/= directory.
      * Of course, most of the time you are not going to need this.

    - A illustration:
      =from Jian= Check the original document
      =from Jian= The comment in it is weird!!! Any improvement???

    - Any time files ending in =.scala= or =.sbt= are used, naming them
      =build.sbt= and =Dependencies.scala= are _conventions ONLY_.
      * This also means that _multiple files_ are *allowed*.

*** Tracking dependencies in one place
    One way of using the fact that =.scala= files under =project= becomes part
    of the /build definition/ is to
    create =project/Dependencies.scala= to track /dependencies/ in one place.

    - Example:
      #+NAME: project/Dependencies.scala
      #+begin_src scala
        import sbt._

        object Dependencies {
          // Versions
          lazy val akkaVersion = "2.6.19"

          // Libraries
          val akkaActor = "com.typesafe.akka" %% "akka-actor" % akkaVersion
          val akkaCluster = "com.typesafe.akka" %% "akka-cluster" % akkaVersion
          val specs2core = "org.specs2" %% "specs2-core" % "4.16.0"

          // Projects
          val backendDeps =
            Seq(akkaActor, specs2core % Test)
        }
      #+end_src

      * Then use it in =build.sbt=
        #+NAME: build.sbt
        #+begin_src scala
          import Dependencies._

          ThisBuild / organization := "com.example"
          ThisBuild / version      := "0.1.0-SNAPSHOT"
          ThisBuild / scalaVersion := "2.12.16"

          lazy val backend = (project in file("backend"))
            .settings(
              name := "backend",
              libraryDependencies ++= backendDeps
            )
        #+end_src

    - This technique is useful when you have a multi-project build that's getting
      large, and you want to ensure that _subprojects have *consistent* dependencies_.

*** When to use =.scala= files
    - No limitation. The =.scala= files for build can contain any legal Scala code.

    - The recommended approach:
      * Define _MOST settings_ in a multi-project =build.sbt= file

      * Use =project/*.scala= files for
        + _/task/ implementations_
        + share values, such as /keys/.

      * The use of =.scala= files also
        *depends on*
        how comfortable you or your team are with Scala.

*** Defining auto plugins - =TODO=
    For more advanced users,
    another way of organizing your build is to define one-off /auto plugins/ in
    =project/*.scala=.

    - =TODO= =Learn More=
      By defining /triggered plugins/, /auto plugins/ can be used as a convenient
      way to inject custom tasks and commands across all /subprojects/.

** TODO p. Getting Started summary =Important=
*** sbt: The Core Concepts - =RE-READ=
*** Advanced Notes

* TODO 2. Frequently Asked Questions
** Project Information
*** What does the name "sbt" stand for, and why shouldn't it be written "SBT"?
*** How do I get help?
*** How do I report a bug?
*** How can I help?

** Usage
*** My last command didn't work but I can't see an explanation. Why?
*** How do I disable ansi codes in the output?
*** How can I start a Scala interpreter (REPL) with sbt project configuration (dependencies, etc.)?

** Build definitions
*** What are the ~:=~, ~+=~, and ~++=~ methods?
*** What is the ~%~ method?
*** What does ~ThisBuild / scalaVersion~ mean?
*** What is ~ModuleID~, ~Project~, ...?
*** How do I add files to a jar package?
*** How can I generate source code or resources?
*** How can a task avoid redoing work if the input files are unchanged?

** Extending sbt
*** How can I add a new dependency configuration?
*** How do I add a test configuration?
*** How can I create a custom run task, in addition to ~run~?
*** How should I express a dependency on an outside tool such as proguard?
*** How would I change sbt's classpath dynamically?
*** Example of dynamic classpath augmentation
*** How can I take action when the project is loaded or unloaded?
*** Example of project load/unload hooks

** Errors
*** On project load, "Reference to uninitialized setting"

** Dependency Management
*** How do I resolve a checksum error?
*** I've added a plugin, and now my cross-compilations fail!

** Miscellaneous
*** TODO Where can I find plugins for 1.9.8?

* TODO 3. General Information
  This part of the documentation has project "meta-information” such as where to
  * where to get help
  * where to find source code
  * how to contribute.

** a. Credits
** b. Community Plugins
*** sbt Organization
*** Community Ivy Repository
*** Cross building plugins from sbt 0.13
*** Plugins available for sbt 1.0 (including RC-x)
**** Code formatter plugins
**** Documentation plugins
**** One jar plugins
**** Release plugins
**** Deployment integration plugins
**** Utility and system plugins
**** IDE integration plugins
**** Test plugins
**** Library dependency plugins
**** Web and frontend development plugins
**** Database plugins
**** Framework-specific plugins
**** Code generator plugins
**** Static code analysis plugins
**** Code coverage plugins
**** Create new project plugins
**** In-house plugins
**** Verification plugins
**** Language support plugins

** c. Community Repository Policy
** d. Bintray For Plugins
   *We no longer use Bintray to host plugins*

   Some history

** e. Using Sonatype
*** Sonatype setup
*** sbt setup
**** step 1: PGP Signatures
**** step 2: sbt-pgp
**** step 3: Credentials
**** step 4: Configure =build.sbt=
**** step 5: Publishing

*** Optional steps
**** sbt-sonatype
**** Publishing tips
**** Integrate with the release process

** f. Contributing to sbt
*** Documentation

** g. Changes - =IMPORTANT=
*** TODO i. Migrating from sbt 0.13.x
**** Migrating case class .copy(...)
**** SbtPlugin
**** sbt version specific source directory
**** Migrating to slash syntax
**** Migrating from sbt 0.12 style
***** Migrating sbt 0.12 style operators
***** Migrating from the tuple enrichments
***** Migrating when using .dependsOn , .triggeredBy or .runBefore
***** Migrating when you need to set Task s
***** Migrating with InputKey

**** Migrating from the Build trait
**** Migrating from Resolver.withDefaultResolvers 

*** TODO ii. sbt 1.4.x releases
**** sbt 1.4.1
**** sbt 1.4.0
**** Build server protocol (BSP) support
***** How to import to IntelliJ using BSP
***** How to import to VS Code + Metals

**** Native thin client
**** ThisBuild / versionScheme
**** VirtualFile + RemoteCache
**** Build linting
**** Conditional task
**** Incremental build pipelining
**** sbt-dependency-graph is in-sourced
**** Fixes with compatibility implications
**** Other updates
**** Participation

*** TODO iii. sbt 1.3.x releases
**** sbt 1.3.0
***** Changes with compatibility implication
***** Library management with Coursier
***** Turbo mode with ClassLoader layering
***** IO improvements
***** Glob
***** Watch improvements
***** Build definition source watch
***** Custom incremental tasks
***** Super shell
***** Tracing
***** SemanticDB support
***** print command
***** Appending Function1
***** JDK 11 support
***** Other bug fixes and improvements
***** Participation

*** TODO iv. sbt 1.2.x releases
**** sbt 1.2.1
***** Forward bincompat breakage
***** The project Foo references an unknown configuration bar
***** Other bug fixes
***** Contributors

**** sbt 1.2.0
***** SbtPlugin for plugin development
***** Cross JDK forking
***** scalaVersion-filtered aggregation
***** Composite project
***** Project matrix
***** Semantic Version selector API
***** addPluginSbtFile command
***** Extensible sbt server
***** Thin client(s)
***** Changes with compatibility implication
***** Other bug fixes and improvements
***** Internal
***** Contributors

*** TODO v. sbt 1.1.x releases -  =FIXME=
**** sbt 1.1.6
***** Bug fixes
***** Contributors

**** sbt 1.1.5
***** Bug fixes
***** Improvements
***** Watcher improvements
***** VS Code extension update
***** sbt by example
***** Contributors

**** sbt 1.1.4
***** Bug fixes
***** Improvements
***** Triggered execution on macOS
***** Running sbt with standby
***** Loading performance improvement

**** Contributors =FIXME= =WRONG LEVEL=
**** sbt 1.1.2
***** Bug fixes
***** Improvements
***** Internal
***** Contributors

**** sbt 1.1.1
***** Bug fixes
***** Improvements
***** autoStartServer setting
***** Contributors

**** sbt 1.1.0
***** Features, fixes, changes with compatibility implications
***** Features
***** Fixes
***** Improvements
***** Unified slash syntax for sbt shell and build.sbt
***** sbt server
***** VS Code extension
***** Filtering scripted tests using project/build.properties
***** Contributors

*** TODO vi. sbt 1.0.x releases
**** sbt 1.0.4
***** Bug fixes
***** Enhancement
***** Internal
***** Contributors

**** sbt 1.0.3
***** Bug fixes
***** Improvements
***** Alternative watch mode
***** Contributors

**** sbt 1.0.2
***** Bug fixes
***** Internal
***** Contributors

**** sbt 1.0.1
***** Bug fixes
***** WatchSource

**** sbt 1.0.0
***** Features, fixes, changes with compatibility implications
***** Features
***** Fixes
***** Improvements
***** Internals
***** Details of major changes
***** Zinc 1: Class-based name hashing
****** Zinc API changes
****** sbt server: JSON API for tooling integration
****** Static validation of build.sbt
****** Eviction warning presentation
****** sbt-cross-building
****** CopyOptions
****** Library management API and parallel artifact download
****** Binary format for Zinc s internal storage
****** Dependency locking

***** Contributors

* TODO 4. Detailed Topics
  - _Prerequisite_: Finish the "Getting Started Guide".

** TODO a. Using sbt
***    i. Command Line Reference
    - This page is a *relatively COMPLETE* list of
      * command line options,
      * commands, and
      * tasks
      you can use from the _sbt interactive prompt or in batch mode_.

      See Running in the _Getting Started Guide_ for an intro to the basics,
      while this page has a lot more detail.

**** Notes on the command line
**** Project-level tasks
     - ~clean~:
       Deletes all generated files (the =target= directory).

     - ~publishLocal~:
       Publish artifacts (such as jars) to the local Ivy repository as described
       in *Publishing*.
       =TODO= *Publishing*

     - ~publish~:
       Publish artifacts (such as jars) to the repository defined by /the ~publishTo~
       setting/, described in *Publishing*.
       =TODO= *Publishing*

     - ~update~:
       Resolves and retrieves external dependencies as described in *library dependencies*.
       =TODO= in-file citation

**** Configuration-level tasks
**** General commands
**** Commands for managing the build definition
**** Sbt runner arguments
***** sbt JVM options and system properties
***** sbt JVM heap, permgen, and stack sizes
***** Boot directory
***** Terminal encoding
***** HTTP/HTTPS/FTP Proxy
***** Other system properties

***   ii. Console Project
**** Description
**** Accessing settings
***** Examples

**** Evaluating tasks
***** Examples

**** State
***** Examples

*** TODO iii. Cross-building - =TODO=
**** Introduction
     Different versions of Scala can be *binary incompatible*, despite maintaining source compatibility.

     - This page describes how to use _sbt_ to
       * _build and pubish_ your project against multiple versions of Scala
       * _use_ libraries that have done the same

     - For *cross building sbt plugins* see also [[https://www.scala-sbt.org/1.x/docs/Cross-Build-Plugins.html][Cross building plugins]].

**** Publishing conventions
     - The _UNDERLYING mechanism_ used to
       _INDICATE which version of Scala a library was compiled against_ is
       to *append* ~_<scala-binary-version>~ to the _library's name_.
       * =from Jian=
         Here this document describes a _rather EXPLICIT way_ to let the sbt
         know which library version should be used. This is natural, because the
         artifacts for Scala libraries are usually published in this name
         pattern.
         + Q :: Then WHY does this document call it _UNDERLYING mechanism_?
         + A :: Because we rarely use this way explicitly. See below.

       * =from Jian=
         For example, the artifact name _dispatch-core_2.12_ is used when
         compiled against any Scala 2.12.x version.
           _This fairly simple approach allows interoperability with users of
         *Maven*, *Ant* and *other build tools*._

     - =IMPORTANT=
       For /pre-prelease versions/ of Scala such as 2.13.0-RC1 and for versions
       prior o 2.10.x, *full version is used as the suffix.*

     - The rest of this page describes how sbt handles this for you as part of
       cross-building.

**** Using cross-built libraries
     Use ~%%~ instead of ~%~, and then _sbt_ knows it should append the current
     version of Scala being used to build the library to the dependency's namee.

     - Example:
       If in the current build, ~scalaVersion~ is one of the 2.12.x versions.

       #+begin_src scala
         libraryDependencies += "net.databinder.dispatch" %% "dispatch-core" % "0.13.3"
       #+end_src

       can be interpreted as

       #+begin_src scala
         libraryDependencies += "net.databinder.dispatch" % "dispatch-core_2.12" % "0.13.3"
       #+end_src

       * "A nearly equivalent, manual alternative for a fixed version of Scala is"
         =from Jian=
         This is from the original document, I don't quite understand why it
         uses the phrase "nearly equivalent".
         =TODO=
         =TODO=
         =TODO=

**** TODO Cross building a project using sbt-projectmatrix
**** Cross building a project statefully
     Define the versions of Scala to build against in the ~crossScalaVersions~ setting.
     *Versions of Scala 2.10.2 or later are allowed.*

     - For example, in a =.sbt= /build definition/:
       #+begin_src scala
         lazy val scala212 = "2.12.16"
         lazy val scala211 = "2.11.12"
         lazy val supportedScalaVersions = List(scala212, scala211)

         ThisBuild / organization := "com.example"
         ThisBuild / version      := "0.1.0-SNAPSHOT"
         ThisBuild / scalaVersion := scala212

         lazy val root = (project in file("."))
           .aggregate(util, core)
           .settings(
             // crossScalaVersions must be set to Nil on the aggregating project
             crossScalaVersions := Nil,
             publish / skip := true
           )

         lazy val core = (project in file("core"))
           .settings(
             crossScalaVersions := supportedScalaVersions,
             // other settings
           )

         lazy val util = (project in file("util"))
           .settings(
             crossScalaVersions := supportedScalaVersions,
             // other settings
           )
       #+end_src
       * Note: =IMPORTANT=
         ~crossScalaVersions~ *MUST BE set to ~Nil~ on the /root project/* to
         *avoid* /double publishing/.

     - To build against *ALL versions* listed in ~crossScalaVersions~,
       *prefix* the action to run with ~+~.

**** Change settings depending on the Scala version
     We can change some settings depending on the Scala version.

     - ~CrossVersion.partialVersion(scalaVersion.value)~ returns
       ~Option[(Int, Int)]~ containing the first two segments of the Scala
       version.

     - This can be useful
       for instance
       IF
       * you include a /dependency/ that requires the /macro paradise compiler plugin/
         for _Scala 2.12_ and
       * the ~-Ymacro-annotations~ /compiler option/ for _Scala 2.13_.

       #+begin_src scala
         lazy val core = (project in file("core"))
           .settings(
             crossScalaVersions := supportedScalaVersions,
             libraryDependencies ++= {
               CrossVersion.partialVersion(scalaVersion.value) match {
                 case Some((2, n)) if n <= 12 =>
                   List(compilerPlugin("org.scalamacros" % "paradise" % "2.1.1" cross CrossVersion.full))
                 case _                       => Nil
               }
             },
             Compile / scalacOptions ++= {
               CrossVersion.partialVersion(scalaVersion.value) match {
                 case Some((2, n)) if n <= 12 => Nil
                 case _                       => List("-Ymacro-annotations")
               }
             },
           )
       #+end_src
       =from Jian=
       It seems we can define a function for ~libraryDependencies~ and ~Compile
       / scalacOptions~ to eliminate the above duplicate code.

***** Scala-version specific source directory
      =from Jian= BY DEFAULT, (=from Jian= I think this document should add this phrase)
      In addition to =src/main/scala/= directory,
      =src/main/scala-<scala binary version>/= directory is included as a /source
      directory/.

      - For =FIXME= (,) example,
        if the current /subproject/'s ~scalaVersion~ is _2.12.10_,
        then =src/main/scala-2.12= is included as a /Scala-version specific source/.

      - *DISABLE* THIS:
        By setting ~crossPaths~ to ~false~,
        you can _opt out_ of BOTH
        * /Scala-version source directory/ and
        * /the =_<scala-binary-version>= publishing convention/.
        =IMPORTANT=
        =IMPORTANT=
        =IMPORTANT=
        This might be useful for *NON-Scala projects*.

      - Similarly, the /build products/ such as =*.class= files are written into
        =crossTarget= directory, which by default is =target/scala-<scala binary version>=.

***** TODO Cross building with a Java project
***** Switching Scala version
      - Use ~++ <version> [command]~ to temporarily switch the Scala version
        currently being used to build the /subprojects/
        _GIVEN that ~<version>~ is listed in their ~crossScalaVersions~._
        * The ~<version>~ here can also be a path to a Scala home directory.

        * When a ~[command]~ is passed in to ~++~, it will execute the command on
          the /subprojects/ that *supports* the given ~<version>~.
          + For example, if we use this ~++~ command in the previous section example
            (has a Java module) and use a ~<version>~ other than the one in that
            Java module, nothing will happen to that module:
            #+begin_src
              > ++ 2.11.12 -v test
              [info] Setting Scala version to 2.11.12 on 1 projects.
              [info] Switching Scala version on:
              [info]     core (2.12.16, 2.11.12)
              [info] Excluding projects:
              [info]   * root ()
              [info]     network (2.12.16)
              [info] Reapplying settings...
              [info] Set current project to core (in build file:/Users/xxx/hello/)
            #+end_src

      - Sometimes you might want to _FORCE_ the Scala version switch *REGARDLESS*
        of the ~crossScalaVersions~ values.
        You can use ~++ <version>!~ with *exclamation mark* for that.

***** TODO Cross publishing
***** Overriding the publishing convention
***** Scala 3 specific cross-versions
***** More about using cross-built libraries
***** Note about sbt-release =TODO= =???=

***   iv. Interacting with the Configuration System
**** Selecting commands, tasks, and settings
***** Selecting the configuration
***** Task-specific Settings

**** Discovering Settings and Tasks
***** Value and Provided By
***** Related Settings
***** Dependencies
****** Requested Dependencies
****** Actual Dependencies

***** Delegates

***    v. Triggered Execution
**** Compile
**** Testing
**** Running Multiple Commands
**** Build sources
**** Clearing the screen
**** Configuration

***   vi. Scripts mode
**** sbt Script runner
***** Example

***  vii. sbt Server
**** Language Server Protocol 3.0
**** Server modes
**** Server discovery and authentication
**** Initialize request
**** textDocument/publishDiagnostics event
**** textDocument/didSave event
**** sbt/exec request
**** sbt/setting request
**** sbt/completion request
**** sbt/cancelRequest

*** viii. Understanding Incremental Recompilation
**** sbt heuristics
**** How to take advantage of sbt heuristics

** b. Configuration
***    i. Classpaths, sources, and resources
***   ii. Compiler Plugin Support
***  iii. Configuring Scala
***   iv. Forking
***    v. Global Settings
***   vi. Java Sources
***  vii. Mapping Files
*** viii. Local Scala
***   ix. Macro Projects
***    x. Paths
***   xi. Parallel Execution
***  xii. External Processes
*** xiii. Running Project Code
***  xiv. Testing
***   xv. In process class loading
***  xvi. Globs
*** xvii. Remote Caching

** c. Dependency Management
***    i. Artifacts
***   ii. Dependency Management Flow
***  iii. Library Management
***   iv. Proxy Repositories
***    v. Publishing
***   vi. Resolvers
***  vii. Update Report
*** viii. Cached Resolution

** d. Tasks and Commands
***   i. Tasks
***  ii. Caching
*** iii. Input Tasks
***  iv. Commands
***   v. Parsing and tab completion
***  vi. State and actions
*** vii. Tasks/Settings: Motivation

** e. Plugins and Best Practices
***    i. General Best Practices
***   ii. Plugins
***  iii. Plugins Best Practices
***   iv. Setting up GitHub Actions with sbt
***    v. Setting up Travis CI with sbt
***   vi. Testing sbt plugins
***  vii. sbt new and Templates
*** viii. Cross building plugins

* TODO 5. How to...
** a. Classpaths
** b. Customizing paths
** c. Generating files
** d. Inspect the build
** e. Interactive mode
** f. Configure and use logging
** g. Project metadata
** h. Configure packaging
** i. Running commands
** j. Configure and use Scala
** k. Generate API documentation
** l. Define Custom Tasks
** m. How to take an action on startup
** n. Track file inputs and outputs
** o. Troubleshoot memory issues
** p. Sequencing
***   i. Defining a sequential task with ~Def.sequential~
***  ii. Defining a dynamic task with ~Def.taskDyn~
*** iii. Doing something after an input task
***  iv. Defining a dynamic input task with ~Def.inputTaskDyn~
***   v. How to sequence using commands

** q. How to define a custom dependency configuration
** r. Examples
***   i. =.sbt= build examples
***  ii. =.sbt= build with =.scala= files example
*** iii. Advanced configurations example
***  iv. Advanced command example

* TODO 6. Index
** Values and Types
*** Dependency Management
*** Settings and Tasks
*** Build Structure

** Methods
*** Settings and Tasks
*** File and IO
*** Dependency Management
*** Parsing

* 7. Developer's Guide (Work in progress)
** a. Modularization
*** i. Module summary
**** IO API (~sbt/io~)
**** Serialization API (~sbt/serialization~)
**** Util API (~sbt/util~)
**** LibraryManagement API (~sbt/librarymanagement~)
**** IncrementalCompiler API (~sbt/zinc~)
**** Build API (tbd)
**** sbt Launcher (~sbt/launcher~)
**** Client/Server (tbd)
**** Website (~sbt/website~)

** b. sbt Coding Guideline
*** General goal
**** Clean up old deprecation
**** Aim for zero warnings (except deprecation)

*** Documentation
*** Modular design
**** Aim small
**** Public APIs should be coded against "interfaces"
**** Hide implementation details
**** Less interdependence
**** Hinde external classes
**** Hide internal modules
**** Compiler flags
**** Package name and organization name

*** Binary resiliency
**** MiMa
**** Public traits should contain ~def~ declarations only
**** Abstract classes are also useful
**** Seal traits and abstract classes
**** Finalize the leaf classes
**** Typeclass and subclass inheritance
**** Avoid case classes, use sbt-datatype
**** Prefer method overloading over default parameter values

*** Other public API matters
**** Avoid Stringly-typed programming
**** Avoid overuse of ~def apply~
**** Use specific datatypes (~Vector~, ~List~, or ~Array~), rather than ~Seq~
**** Avoid calling ~toSeq~ or anything with side-effects on ~Set~
**** Avoid calling ~toSeq~ on ~Map~
**** Avoid functions and tuples in the signature, if Java iteroperability is needed

*** Style matters
**** Use scalafmt
**** Avoid procedure syntax
**** Define instances of typeclasses in their companion objects, when possible
**** Implicit conversions for syntax (enrich-my-library pattern) should be imported

** c. sbt-datatype
*** Using the plugin
*** Dtatype schema
**** Records
**** Interfaces
**** Enums

*** Using datatype to retain binary compatibility
*** JSON codec generation
*** Existing parameters for protocols, records, etc.
*** Settings
*** Syntax summary

** d. Compiler Interface
*** i. Fetching the most specific sources

** TODO e. sbt Launcher
***   i. Getting Started with the sbt launcher
**** Overview
***** Applications
***** Servers
***** Resolving Applications/Servers
***** Creating a Launched Application
***** Running an Application
***** Execution

***  ii. Sbt Launcher Architecture
**** Module Resolution
**** Classloader Caching and Isolation
**** Caching
**** Locking
**** Service Discovery and Isolation

*** iii. sbt Launcher Configuration
**** Example
***** 1. Scala Configuration
***** 2. Applicaiton Identification
***** 3. Repositories Section
***** 4. The Boot section
***** 5. The Ivy section
***** 6. The Server Section

**** Variable Substitution
**** Syntax

** f. Notes
***   i. Core Principles
**** Introduction to build state
**** Settings Architecture
**** Task Architecture

***  ii. Settings Core
**** Example
***** Setting up
***** Example Settings System
***** Example Usage

**** sbt Settings Discussion
***** Scopes
***** Constructing settings
***** Settings definitions

*** iii. Setting Initialization
***  iv. Creating Command Line Applications Using sbt
**** Hello World Example
***** Build Definition: =build.sbt=
***** Application: =Main.scala=
***** Launcher configuration file: =hello.build.properties=

* 8. Archived pages
** a. Hello, World
*** sbt new command
*** Running your app
*** Exiting sbt shell
*** Build definition

