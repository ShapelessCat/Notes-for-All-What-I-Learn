#+TITLE: Programming Language Pragmatics
#+VERSION: 4th
#+AUTHOR: Michael L. Scott
#+STARTUP: overview
#+STARTUP: entitiespretty

* Foreward - xxiii
* Preface - xxv
* I. Foundations - 3
** TODO 1. Introduction - 5
*** 1.1 The Art of Language Design - 7
*** 1.2 The Programming Language Spectrum - 11
*** 1.3 Why Study Programming Languages? - 14
*** 1.4 Compilation and Interpretation - 17
*** 1.5 Programming Environments - 24
*** 1.6 An Overview of Compilation - 26
**** 1.6.1 Lexical and Syntax Analysis - 28
**** 1.6.2 Semantic Analysis and Intermediate Code Generation - 32
**** 1.6.3 Target Code Generation - 34
**** 1.6.4 Code Improvement - 36
    
*** 1.7 Summary and Concluding Remarks - 37
*** 1.8 Exercises - 38
*** 1.9 Explorations - 39
*** 1.10 Bibliographic Notes - 40
   
** TODO 2. Programming Language Syntax - 43
*** 2.1 Specifying Syntax: Regular Expressions and Context-Free Grammars - 44
**** 2.1.1 Tokens and Regular Expressions - 45
**** 2.1.2 Context-Free Grammars - 48
**** 2.1.3 Derivations and Parse Trees - 50
   
*** 2.2 Scanning - 54
**** 2.2.1 Generating a Finite Automaton - 56
**** 2.2.2 Scanner Code - 61
**** 2.2.3 Table-Driven Scanning - 65
**** 2.2.4 Lexical Errors - 65
**** 2.2.5 Pragmas - 67
     
*** 2.3 Parsing - 69
**** 2.3.1 Recursive Descent - 73
**** 2.3.2 Writing an LL(I) Grammar - 79
**** 2.3.3 Table-Driven Top-Down Parsing - 82
**** 2.3.4 Bottom-Up Parsing - 89
**** 2.3.5 Syntax Errors - C-I * 102
    
*** 2.4 Theoretical Foundations - C-13 * 103
**** 2.4.1 Finite Automata - C-13
**** 2.4.1 Push-Down Automata - C-18
**** 2.4.1 Grammar and Language Classes - C-19
    
*** 2.5 Summary and Concluding Remarks - 104
*** 2.6 Exercises - 105
*** 2.7 Explorations - 112
*** 2.8 Bibliographic Notes - 112
    
** 3. Names, Scopes, and Bindings - 115
*** 3.1 The Notion of binding Time - 116
*** 3.2 Object Lifetime and Storage Management - 118
*** 3.3 Scope Rules - 125
*** 3.4 Implementing Scope - C-26 * 144
*** 3.5 The Meaning of Names within a Scope - 145
*** 3.6 The Binding of Referencing Environments - 152
*** 3.7 Macro Expansion - 162
*** 3.8 Separate Compilation - C-36 * 165
*** 3.9 Summary and Concluding Remarks - 165
*** 3.10 Exercises - 167
*** 3.11 Explorations - 175
*** 3.12 Bibliographic Notes - 177   
    
** 4. Semantic Analysis - 179
** 5. Target Machine Architecture - 217
   
* II. Core Issues in Language Design - 221
** 6. Control Flow
** 7. Type Systems
** 8. Composite Types
** 9. Subroutines and Control Abstraction
** 10. Data Abstraction and Object Orientation
  
* III. Alternative Programming Models - 533
** 11. Functional Languages
** 12. Logic Languages
** 13. Concurrency
** 14. Scripting Languages
   
* IV. A Closer Look At Implementation - 773
** 15. Building a Runnable Program
** 16. Run-Time Program Management
** 17. Code Improvement

* A. Programming Languages Mentioned - 859
* B. Languages Design and Language Implementation - 871
* C. Numbered Examples - 877
* Bibliography - 891
* Index - 911
