#+TITLE: Scala-2-Reflection (Removed in Scala 3)
#+AUTHORS: Heather Miller, Eugene Burmako, Philipp Haller
#+STARTUP: overview
#+STARTUP: entitiespretty

* DONE Overview
  CLOSED: [2020-07-03 Fri 05:00]
  - Authors:
    * Heather Miller
    * Eugene Burmako
    * Philipp Haller

  - Contributors:
    * komainu8
    * srishti-jain
    * marconilanna
    * karlroberts
    * heathermiller

  - Reflection :: the ability of a program to *inspect*, and possibly even *modify*
    itself.

  - /Reflection/ has a long history across object-oriented, functional, and logic
    programming paradigms.
    + While some languages are built around /reflection/ as a guiding principle
      (=from Jian= languages of lisp-family),
      many languages progressively evolve their reflection abilities over time.

  - /Reflection/ involves the ability to /reify/ (ie. _make explicit_)
    otherwise-implicit elements of a program.
    + These elements can be
      * either /static program elements/ like /classes/, /methods/, or /expressions/,

      * or /dynamic elements/ like the current continuation or execution events
        such as /method invocations/ and /field accesses/.

    + One usually *distinguishes between* /compile-time and runtime reflection/
      depending on when the reflection process is performed.
      =from Jian= Dotty emphasize /compile-time reflection/, and in the discussion
      I see people say /compile-time reflection/ can resolve satisfy of requirement.

      * /Compile-time reflection/ is a powerful way to develop _program TRANSFORMERS
        and GENERATORS_,

      * while /runtime reflection/ is typically used to _adapt the language semantics_
        or to _support very late binding between software components_.

  - _Until 2.10_, Scala *don't have any* reflection capability of its own.
    It can use Java's relfection API.
    + Limitation of using Java's reflection API:
      * Many Scala-specific elements are *unrecoverable* under standalone Java
        reflection, which ONLY exposes
        - Java elements (*NO* /functions/, no /traits/)
        - Java types (*NO* /existential/, /higher-kinded/, /path-dependent/ and
          /abstract types/).

      * *Unable to recover* /runtime type/ info of /Java types that are generic/
        at /compile-time/; a restriction that carried through to /runtime
        reflection/ on /generic types/ in Scala.

  - _In Scala 2.10_, a new reflection library was introduced not only to address the
    shortcomings of Java's runtime reflection on Scala-specific and generic types,
    but to also add a more powerful toolkit of general reflective capabilities to
    Scala.
    + Along with _FULL-featured_ /runtime reflection/ for Scala /types/ and /generics/,
      Scala 2.10 ALSO ships with /compile-time reflection/ capabilities, in the form
      of /macros/, as well as _the ability to *reify* /Scala expressions/ *into*
      /abstract syntax trees/._

** DONE Runtime Reflection
   CLOSED: [2020-07-03 Fri 03:18]
   - Q :: What is /runtime reflection/?
   - A :: Given a /type/ or /instance of some object/ at /runtime/, /reflection/
     is the ability to:
     + *INSPECT the /type/* of that /object/, _including_ /generic types/.
     + to *INSTANTIATE new /objects/*
     + or to *ACCESS or INVOKE members* of that /object/.

*** DONE Examples
    CLOSED: [2020-07-01 Wed 04:33]
**** DONE Inspecting a Runtime Type (Including Generic Types at Runtime)
     CLOSED: [2020-07-01 Wed 03:52]
     - As with other _JVM languages_, /Scala's types/ are *erased* at /compile
       time/ --- at /runtime type/, you might not have access to all type
       information that the Scala compiler has available at /compile time/.

     - ~TypeTag~'s can be thought of as objects which _CARRY along *ALL* TYPE
       INFORMATION available at /compile time/, TO /runtime/._ Though, it's
       important to note *that ~TypeTag~'s are ALWAYS _generated by the compiler_.*
       + This generation is triggered whenever by an /implicit parameter/ requiring
         a ~TypeTag~ is used. Of course, this /implicit parameter/ can be
         expressed as a /context bound/.

     - For example,
       1. Obtain a /runtime generic type/:
          #+begin_src scala
            import reflect.runtime.{universe => ru}

            val l = List(1, 2, 3)

            def getTypeTag[T: ru.TypeTag](obj: T) = ru.typeTag[T]
            // getTypeTag: [T](object: T)(implicit evidence$1: ru.TypeTag[T])ru.TypeTag[T]

            val theType = getTypeTag(l).tpe
            // theType: ru.Type = List[Int]
          #+end_src
          + ~import scala.reflect.runtime.universe~ in order to use ~TypeTag~'s

          + =from Jian= Need to check the scala spec!!! =TODO=
            If I eliminate the not-in-use ~obj~ parameter and only keep the /type
            parameter/, the result will be like this:
            #+begin_src scala
              def getTypeTag[T: ru.TypeTag] = ru.typeTag[T]

              val theType = getTypeTag[l.type].tpe
              // val theType: reflect.runtime.universe.Type = l.type

              theType =:= getTypeTag[List[Int]].tpe
              // val res7: Boolean = false

              theType <:< getTypeTag[List[Int]].tpe
              // val res8: Boolean = true
            #+end_src
            =TODO= =???= =TODO= =READ-SPEC???=

       2. Inpsect the gained ~Type~:
          #+begin_src scala
            val decls = theType.decls.take(10)
            // decls: Iterable[ru.Symbol] = List(constructor List,
            //                                   method companion,
            //                                   method isEmpty,
            //                                   method head,
            //                                   method tail,
            //                                   method ::,
            //                                   method :::,
            //                                   method reverse_:::,
            //                                   method mapConserve,
            //                                   method ++)
          #+end_src

**** DONE Instantiating a Type at Runtime
     CLOSED: [2020-07-01 Wed 04:08]
     /Types/ obtained through /reflection/ can be *instantiated* by invoking
     their constructor using _an appropriate "invoker" /mirror/ (/mirrors/ are
     expanded upon below)._

     - Let's walk through an example using the REPL:
       1. Obtain a /mirror/ ~m~ which makes *ALL* /classes/ and /types/
          available that are loaded by the *CURRENT* /classloader/, including
          /class/ ~Person~.
          #+begin_src scala
            final case class Person(name: String)

            val m = ru.runtimeMirror(getClass.getClassLoader)
            // m: scala.reflect.runtime.universe.Mirror = JavaMirror with ...
          #+end_src

       2. Prepare data: a ~ClassMirror~ and a ~MethodSymbol~
          + Obtain a ~ClassMirror~ for class ~Person~ using the ~reflectClass~ /method/.
            The ~ClassMirror~ *provides access* to the /constructor/ of /class/ ~Person~.
            #+begin_src scala
              val classPerson = ru.typeOf[Person].typeSymbol.asClass
              // classPerson: scala.reflect.runtime.universe.ClassSymbol = class Person

              val cm = m.reflectClass(classPerson)
              // cm: scala.reflect.runtime.universe.ClassMirror = class mirror for Person (bound to null)
            #+end_src

          + Obtain the /constructor/ ~MethodSymbol~:
            #+begin_src scala
              val ctor = ru.typeOf[Person].decl(ru.termNames.CONSTRUCTOR).asMethod
              // ctor: scala.reflect.runtime.universe.MethodSymbol = constructor Person
            #+end_src

       3. Call the /constructor/ through ~MethodMirror~:
          #+begin_src scala
            val ctorm = cm.reflectConstructor(ctor)
            // ctorm: scala.reflect.runtime.universe.MethodMirror =
            //   constructor mirror for Person.<init>(name: String): Person (bound to null)

            val p = ctorm("Mike")
            // p: Any = Person(Mike)
          #+end_src

**** DONE Accessing and Invoking Members of Runtime Types
     CLOSED: [2020-07-01 Wed 04:33]
     In general, members of runtime types are accessed using an appropriate
     “invoker” mirror (mirrors are expanded upon below).

     - Let's walk through an example using the REPL:
       #+begin_src scala
         final case class Purchase(name: String, orderNumber: Int, var shipped: Boolean)

         val p = Purchase("Jeff Lebowski", 23819, false)
         // p: Purchase = Purchase(Jeff Lebowski,23819,false)
       #+end_src
       In this example, we will attempt to *get* and *set* the ~shipped~ /field/
       of ~Purchase p~, *REFLECTIVELY*.
       1. Begin by obtaining a /mirror/ ~m~, as in previous example:
          #+begin_src scala
            import scala.reflect.runtime.{universe => ru}

            val m = ru.runtimeMirror(p.getClass.getClassLoader)
            // m: scala.reflect.runtime.universe.Mirror = JavaMirror with ...
          #+end_src

       2. Get the ~FieldMirror~ of the ~shipped~ /field/:
          + Look up the /declaration/ of the ~shipped~ /field/, which gives us a
            ~TermSymbol~ (a /type/ of ~Symbol~):
            #+begin_src scala
              val shippingTermSymb = ru.typeOf[Purchase].decl(ru.TermName("shipped")).asTerm
              // shippingTermSymb: scala.reflect.runtime.universe.TermSymbol = method shipped
            #+end_src

          + IN ORDER TO *access* a SPECIFIC /instance/'s ~shipped~ /member/, we
            need a /mirror/ for our SPECIFIC /instance/, ~p~'s /instance mirror/
            (~InstanceMirror~), ~im~:
            #+begin_src scala
              val im = m.reflect(p)
              // im: scala.reflect.runtime.universe.InstanceMirror =
              //   instance mirror for Purchase(Jeff Lebowski,23819,false)
            #+end_src

          + Given our /instance mirror/, we can obtain a ~FieldMirror~ for any
            ~TermSymbol~ representing a /field/ of ~p~'s /type/:
            #+begin_src scala
              val shippingFieldMirror = im.reflectField(shippingTermSymb)
              // shippingFieldMirror: scala.reflect.runtime.universe.FieldMirror =
              //   field mirror for Purchase.shipped (bound to Purchase(Jeff Lebowski,23819,false))
            #+end_src

       3. Use the ~get~ and ~set~ methods of ~FieldMirror~ to *get/set* our SPECIFIC
          /instance/'s ~shipped~ /member/:
          #+begin_src scala
            shippingFieldMirror.get
            // res7: Any = false

            shippingFieldMirror.set(true)

            // Let's change the status of `shipped` to `true`.
            shippingFieldMirror.get
            // res9: Any = true
          #+end_src

*** DONE Runtime Classes in Java vs. Runtime Types in Scala
    CLOSED: [2020-07-03 Fri 03:18]
    /Java reflection/ obtains /Java Class instances/ at /runtime/,
    while /Scala reflection/ obtains /runtime types/.

    - The REPL-run below shows a very simple scenario where
      using /Java reflection/ on /Scala classes/ MIGHT return *surprising or
      incorrect results*.
      + Setting:
        #+begin_src scala
          class E {
            type T
            val x: Option[T] = None
          }
          class C extends E
          class D extends C
        #+end_src

      + Use /Java reflection/:
        #+begin_src scala
          object javaReflectionOnScalaLimitationShow {
            val c = new C { type T = String }
            // c: C{type T = String} = $anon$1@7113bc51
            val d = new D { type T = String }
            // d: D{type T = String} = $anon$1@46364879

            c.getClass isAssignableFrom d.getClass
            // res6: Boolean = false
          }
        #+end_src
        Since ~D extends C~, this result is a bit surprising.
        1. In performing this simple /runtime type check/, one would expect the
           result of the question "is the class of ~d~ a subclass of the class of
           ~c~?" to be *true*.

        2. However, as you might've noticed above, when ~c~ and ~d~ are instantiated,
           the Scala compiler actually *creates* /anonymous subclasses/ of ~C~ and ~D~,
           respectively.
           1. The Scala compiler must translate Scala-specific (i.e., non-Java)
              language features into some equivalent in Java bytecode in order
              to be able to run on the JVM.

           2. Thus, the Scala compiler often creates /synthetic classes (i.e.
              automatically-generated classes)/ that are used at /runtime/ in
              place of /user-defined classes/.

           3. This is quite commonplace in Scala and can be observed when using
              Java reflection with a number of Scala features, e.g. /closures/,
              /type members/, /type refinements/, /local classes/, etc.

      + Use /Scala reflection/:
        In situations like these, use Scala reflection can obtain *precise*
        /runtime types/ of these /Scala objects/. /Scala runtime types/ _carry_
        along *ALL type info* _from_ /compile-time/, *AVOIDING these _types
        mismatches_, we see in Java relfection result, between /compile-time/
        and /run-time/.*
        #+begin_src scala
          import scala.reflect.runtime.{universe => ru}

          object scalaReflectionShow {
            def m[T: ru.TypeTag, S: ru.TypeTag](x: T, y: S): Boolean = {
              val leftTag = ru.typeTag[T]
              val rightTag = ru.typeTag[S]
              leftTag.tpe <:< rightTag.tpe
            }

            m(d, c)
            // res9: Boolean = true
          }
        #+end_src

** DONE Compile-time Reflection
   CLOSED: [2020-07-03 Fri 03:24]
   /Scala reflection/ enables a form of metaprogramming which makes it possible
   for programs to modify themselves at /compile time/.

   - This /compile-time reflection/ is realized in the form of /macros/, which
     provide the ability to execute methods that manipulate /abstract syntax
     trees at compile-time/.

   - A particularly interesting aspect of /macros/ is that
     *they are based on the same API used also for Scala's runtime reflection,
     provided in package ~scala.reflect.api~.*
     + This enables the *sharing* of generic code
       between /macros/ and implementations that utilize /runtime reflection/.

   - Note that the _macros guide_ focuses on /macro specifics/,
     whereas _this guide_ focuses on the general aspects of the reflection API.
     Many concepts directly apply to /macros/, though, such as /abstract syntax
     trees/ which are discussed in greater detail in the section on _Symbols,
     Trees, and Types._

** DONE Environment
   CLOSED: [2020-07-01 Wed 04:49]
   - ALL /reflection/ tasks require a proper environment to be set up.
     + This environment *differs* _based on_ whether the reflective task is to be
       done AT /run time/ or AT /compile time/.
       * The DISTINCTION between an environment to be used at /run time/ or /compile
         time/ is *encapsulated in* a so-called /universe/.

     + Another important aspect of the /reflective environment/ is the set of
       entities that we have reflective access to.
       + mirror :: a specific set of entities -- DIFFERENT kind of /mirrors/ have
         DIFFERENT sets of entities!

   - /Mirrors/
     + NOT ONLY *determine* the set of entities that can be accessed reflectively.
       BUT ALSO *provide* _reflective operations_ to be performed on those entities.

     + For example,
       in /runtime reflection/ an /invoker mirror/ can be used to *invoke* a
       /method/ or /constructor/ of a /class/.

*** DONE ~Universe~'s
    CLOSED: [2020-07-01 Wed 04:42]
    /Universe/ is the *entry point* to _Scala reflection_.

    - A /universe/ provides an interface to *ALL* the _principal concepts_ used in
      /reflection/, such as ~Type~'s, ~Tree~'s, and ~Annotation~'s.
      + For more details, see
        * the section of this guide on ~Universes~,
          OR
        * the _Universes API docs_ in /package/ ~scala.reflect.api~.

    - To use most aspects of Scala reflection, including most code examples provided
      in this guide, you need to make sure you import a ~Universe~ or the members
      of a ~Universe~.
      + Typically, to use /runtime reflection/, one can do /wildcard import/ like
        ~import scala.reflect.runtime.universe._~

*** DONE ~Mirror~'s
    CLOSED: [2020-07-01 Wed 04:38]
    - ~Mirror~'s are a *CENTRAL part* of _Scala Reflection_ -- *ALL* information
      provided by /reflection/ is made accessible through these so-called /mirrors/.
      + Depending on
        _the TYPE OF INFORMATION to be obtained_, or _the REFLECTIVE ACTION to be taken_,
        different flavors of /mirrors/ must be used.

    - For more details, see
      + the section of this guide on ~Mirrors~,
        OR
      + the ~Mirrors~ API docs in /package/ ~scala.reflect.api~ (not shipped with
        the standard library).

* DONE Environment, Universes, and Mirrors
  CLOSED: [2020-09-13 Sun 22:39]
  - Contributors:
    * ashawley
    * marconilanna
    * heathermiller

** DONE Environment
   CLOSED: [2020-07-02 Thu 01:11]
   *Reflection Environment*

   - About when the task is done -- *at run time* OR *at compile time*:
     The /reflection environment/ _DIFFERS BASED ON_ whether the reflective task
     is to be done *at run time* OR *at compile time*.
       The DISTINCTION between an environment to be used _AT_ /run time/ or
     /compile time/ is *encapsulated* in a so-called /universe/.

   - About the *set of entities* we have /reflective access/:
     This set of entities is determined by a so-called /mirror/.
     + For example,
       the entities accessible through /nuntime reflection/ are made available
       by a ~ClassloaderMirror~.
       * This /mirror/ provides only access to entities (/packages/, /types/, and
         /members/) loaded by a SPECIFIC /classloader/.

     + /Mirrors/
       NOT ONLY _DETERMINE_ the set of entities that _can be accessed reflectively_,
       BUT ALSO _PROVIDE_ reflective operations _to be performed_ on those entities.
       * For example,
         in /runtime reflection/ an /invoker mirror/ can be used to *invoke*
         - a /method/
           OR
         - /constructor/ of a /class/.

** DONE Universes
   CLOSED: [2020-07-02 Thu 02:16]
   - There are two principal types of universes, and one must use the /universe/
     that corresponds to whatever the task is at hand. Either:
     + ~scala.reflect.runtime.universe~ for /runtime reflection/, or
     + ~scala.reflect.macros.Universe~ for /compile-time reflection/.

   - A /universe/ provides an interface to all the principal concepts used in
     reflection, such as ~Type~'s, ~Tree~'s, and ~Annotation~'s.

** DONE Mirrors
   CLOSED: [2020-09-13 Sun 22:39]
   - *ALL* information provided by /reflection/ is _made accessible_ *through*
     /mirrors/.
     + Depending on the type of information to be obtained, or the reflective action
       to be taken, different flavors of mirrors must be used.
     + ~Classloader~ mirrors can be used to obtain representations of types and
       members.
       From a classloader mirror, it’s possible to obtain more specialized invoker
       mirrors (the most commonly-used mirrors), which implement reflective invocations,
       such as method or constructor calls and field accesses.

   - Summary:
     + "Classloader" mirrors ::
       These /mirrors/ *TRANSLATE* /names/ *TO* /symbols/
       (via /methods/ ~staticClass~ / ~staticModule~ / ~staticPackage~).

     + "Invoker" mirrors ::
       These /mirrors/ *IMPLEMENT* /reflective invocations/
       (via methods ~MethodMirror.apply~, ~FieldMirror.get~, etc.).
       These /"invoker" mirrors/ are the types of /mirrors/ that are _MOST COMMONLY
       used_.

*** DONE Runtime Mirrors
    CLOSED: [2020-07-02 Thu 02:22]
    - The /entry point/ to /mirrors/ for use *at runtime* is VIA
      ~ru.runtimeMirror(<classloader>)~,
      where ~ru~ is ~scala.reflect.runtime.universe~.

    - The result of a ~scala.reflect.api.JavaMirrors#runtimeMirror~ call is a
      /classloader mirror/, of /type/ ~scala.reflect.api.Mirrors#ReflectiveMirror~,
      which _can *load* /symbols/ by NAME._

    - A /classloader mirror/ can create /invoker mirrors/, including
      + ~scala.reflect.api.Mirrors#InstanceMirror~
      + ~scala.reflect.api.Mirrors#MethodMirror~
      + ~scala.reflect.api.Mirrors#FieldMirror~
      + ~scala.reflect.api.Mirrors#ClassMirror~
      + ~scala.reflect.api.Mirrors#ModuleMirror~

    - Examples of _HOW these two types of /mirrors/ INTERACT_ are available below.

*** DONE Types of Mirrors, Their Use Cases & Examples
    CLOSED: [2020-09-13 Sun 22:35]
    INSERT ~import scala.reflect.runtime.{universe => ru}~ in ALL the code
    snippets below.

    1. ~ReflectiveMirror~
       + Be used for
         * *loading* symbols *by* name,
           *as* an /entry point/ into /invoker mirrors/.

       + Entry point:
         ~val m = ru.runtimeMirror(<classloader>)~.

       + Example:
         #+begin_src scala
           val m = ru.runtimeMirror(getClass.getClassLoader)
           // m: scala.reflect.runtime.universe.Mirror = JavaMirror ...
         #+end_src

    2. ~InstanceMirror~
       + Be used for
         *creating* /invoker mirrors/ for
         * /methods/
         * /fields/
         * /inner classes/ and /inner objects/ (modules).

       + Entry point:
         ~val im = m.reflect(<value>)~.

       + Example:
       #+begin_src scala
           class C { def x = 2 }

           val im = m.reflect(new C)
           // im: scala.reflect.runtime.universe.InstanceMirror = instance mirror for C@3442299e
         #+end_src

    3. ~MethodMirror~
       + Be used for =TODO= =RE-READ=
         *invoking* /instance methods/
         * Scala ONLY has /instance methods/ -- /methods/ of /objects/ are /instance
           methods/ of /object instances/, obtainable via ~ModuleMirror.instance~.

       + Entry point:
         ~val mm = im.reflectMethod(<method symbol>)~.

       + Example:
         #+begin_src scala
           object methodMirrorShow {
             val methodX = ru.typeOf[C].decl(ru.TermName("x")).asMethod
             // methodX: scala.reflect.runtime.universe.MethodSymbol = method x

             val mm = im.reflectMethod(methodX)
             // mm: scala.reflect.runtime.universe.MethodMirror =
             //   method mirror for C.x: scala.Int (bound to C@3442299e)

             mm()
             // res0: Any = 2
           }
         #+end_src

    4. ~FieldMirror~ =TODO= =TODO= =TODO=
       + Be used for *getting/setting* /instance fields/ (like /methods/, Scala ONLY
         has /instance fields/, see above).

       + Entry point:
         ~val fm = im.reflectField(<field or accessor symbol>)~.

       + Example:
         #+begin_src scala
           object fieldMirrorShow {
             final class C { val x = 2; var y = 3 }

             val m = ru.runtimeMirror(getClass.getClassLoader)
             // m: scala.reflect.runtime.universe.Mirror = JavaMirror ...

             val im = m.reflect(new C)
             // im: scala.reflect.runtime.universe.InstanceMirror = instance mirror for C@5f0c8ac1

             val fieldX = ru.typeOf[C].decl(ru.TermName("x")).asTerm.accessed.asTerm
             // fieldX: scala.reflect.runtime.universe.TermSymbol = value x

             val fmX = im.reflectField(fieldX)
             // fmX: scala.reflect.runtime.universe.FieldMirror = field mirror for C.x (bound to C@5f0c8ac1)

             fmX.get
             // res0: Any = 2

             fmX.set(3)

             val fieldY = ru.typeOf[C].decl(ru.TermName("y")).asTerm.accessed.asTerm
             // fieldY: scala.reflect.runtime.universe.TermSymbol = variable y

             val fmY = im.reflectField(fieldY)
             // fmY: scala.reflect.runtime.universe.FieldMirror = field mirror for C.y (bound to C@5f0c8ac1)

             fmY.get
             // res1: Any = 3

             fmY.set(4)

             fmY.get
             // res2: Any = 4
           }
         #+end_src
         * =from Jian=
           =TODO=
           Need more explanation about ~accessed~!!!
           In the current example code, even after removing ~accessed~, the code also works.

    5. ~ClassMirror~
       + Be used for
         *creating* /invoker mirrors/ for /constructors/.

       + Entry points:
         * for /static classes/ ~val cm1 = m.reflectClass(<class symbol>)~,
         * for /inner classes/ ~val mm2 = im.reflectClass(<class symbol>)~.

       + Example:
         #+begin_src scala
           object classMirrorShow {
             final case class C(x: Int)

             val m = ru.runtimeMirror(getClass.getClassLoader)
             // m: scala.reflect.runtime.universe.Mirror = JavaMirror ...

             val classC = ru.typeOf[C].typeSymbol.asClass
             // classC: scala.reflect.runtime.universe.Symbol = class C

             val cm = m.reflectClass(classC)
             // cm: scala.reflect.runtime.universe.ClassMirror = class mirror for C (bound to null)

             val ctorC = ru.typeOf[C].decl(ru.termNames.CONSTRUCTOR).asMethod
             // ctorC: scala.reflect.runtime.universe.MethodSymbol = constructor C

             val ctorm = cm.reflectConstructor(ctorC)
             // ctorm: scala.reflect.runtime.universe.MethodMirror =
             //   constructor mirror for C.<init>(x: scala.Int): C (bound to null)

             ctorm(2)
             // res0: Any = C(2)
           }
         #+end_src

    6. ~ModuleMirror~
       + Be used for
         *accessing* /instances/ of /singleton objects/.

       + Entry points:
         * for /static objects/ ~val mm1 = m.reflectModule(<module symbol>)~,
         * for /inner objects/ ~val mm2 = im.reflectModule(<module symbol>)~.

       + Example:
         #+begin_src scala
           object moduleMirrorShow {
             object C { def x = 2 }

             val m = ru.runtimeMirror(getClass.getClassLoader)
             // m: scala.reflect.runtime.universe.Mirror = JavaMirror ...

             val objectC = ru.typeOf[C.type].termSymbol.asModule
             // objectC: scala.reflect.runtime.universe.ModuleSymbol = object C

             val mm = m.reflectModule(objectC)
             // mm: scala.reflect.runtime.universe.ModuleMirror = module mirror for C (bound to null)

             val obj = mm.instance
             // obj: Any = C$@1005ec04
           }
         #+end_src

*** DONE Compile-Time Mirrors
    CLOSED: [2020-09-13 Sun 22:39]
    /Compile-time mirrors/ make use of *only* /classloader mirrors/ to
    *LOAD /symbols/ _by name_.*

    - The entry point to /classloader mirrors/ is _VIA_
      ~scala.reflect.macros.Context#mirror~.

    - _Typical methods_ which use /classloader mirrors/ include
      + ~scala.reflect.api.Mirror#staticClass~
      + ~scala.reflect.api.Mirror#staticModule~
      + ~scala.reflect.api.Mirror#staticPackage~
      For example:
      #+begin_src scala
        import scala.reflect.macros.Context

        final case class Location(filename: String, line: Int, column: Int)

        object Macros {
          def currentLocation: Location = macro impl

          def impl(c: Context): c.Expr[Location] = {
            import c.universe._
            val pos = c.macroApplication.pos
            val clsLocation = c.mirror.staticModule("Location")  // get symbol of "Location" object
            c.Expr(Apply(Ident(clsLocation),
                         List(Literal(Constant(pos.source.path)),
                              Literal(Constant(pos.line)),
                              Literal(Constant(pos.column)))))
          }
        }
      #+end_src
      + Of note:
        There are several high-level alternatives that one can use to avoid having
        to manually lookup symbols. For example, ~typeOf[Location.type].termSymbol~
        (or ~typeOf[Location].typeSymbol~ if we needed a ~ClassSymbol~), which are
        typesafe since we don't have to use strings to lookup the symbol.
        =TODO= =TODO= =TODO=

* DONE Symbols, Trees, and Types
  CLOSED: [2020-09-14 Mon 01:48]
  - Contributors:
    * nogurenn
    * Philippus
    * SethTisue
    * komainu8
    * ashawley
    * ashishkujoy
    * OlivierBlanvillain
    * marconilanna
    * heathermiller

** DONE Symbols
   CLOSED: [2020-09-14 Mon 00:38]
   - /Symbols/ are used to *establish bindings* BETWEEN a *name* AND the *entity*
     it refers to, such as a /class/ or a /method/.

   - ANYTHING you define and _can give a NAME to_ in Scala has an associated /symbol/.

   - /Symbols/ contain *ALL* available information about the declaration of
     + an _entity_ (~class~ / ~object~ / ~trait~ etc.)
       or
     + a _member_ (~val~'s / ~var~'s / ~def~'s etc.),

     and as such are an integral abstraction central to both /runtime reflection/
     and /compile-time reflection (macros)/.

   - A /symbol/ can provide a wealth of information
     ranging
     + _FROM_ the basic ~name~ method available on all /symbols/

     + _TO_ other, more involved, concepts such as getting the
       ~baseClasses~ from ~ClassSymbol~.

   - Other common use cases of /symbols/ include
     * *inspecting* /members' signatures/,
     * *getting* /type parameters/ of a /class/,
     * *getting* the /parameter type/ of a /method/
     * *finding out* the /type/ of a /field/.

*** DONE The ~Symbol~ Owner Hierarchy
    CLOSED: [2020-09-14 Mon 00:38]
    - /Symbols/ are organized in a hierarchy.
      + For example,
        * a /symbol/ that represents a parameter of a method is *owned* by the
          corresponding /method symbol/,

        * a /method symbol/ is owned by its enclosing /class/, /trait/, or /object/,

        * a /class/ is owned by a containing package and so on.

    - If a /symbol/ does _NOT have an owner,_ for example, because it refers to a
      _top-level entity_, such as a top-level package, then its owner is the
      special ~NoSymbol~ /singleton object/. Representing a _MISSING symbol_,
      + ~NoSymbol~ is commonly used in the API to denote an EMPTY or DEFAULT value.
        _Accessing the ~owner~ of ~NoSymbol~ throws an exception._

*** DONE ~TypeSymbol~'s
    CLOSED: [2020-09-13 Sun 23:42]
    - ~TypeSymbol~ :: it represents declarations of
      + ~type~
      + ~class~
      + ~trait~
      + /type parameters/

    - Interesting members that *do _NOT apply_ to the more specific ~ClassSymbol~'s,*
      include ~isAbstract~ (=from Jian= ~isAbstractType~ in this doc),
      ~isContravariant~, and ~isCovariant~.
      + =from Jian=
        Here _NOT apply_ means always return ~false~.

      + =from Jian=
        Current version uses ~isAbstractType~, which is _DEPRECATED_.
        Should use ~isAbstract~.

      + ~ClassSymbol~:
        Provides access to all information contained *in* a /class or trait
        declaration/, e.g., ~name~, modifiers (~isFinal~, ~isPrivate~, ~isProtected~,
        ~isAbstractClass~, etc.), ~baseClasses~, and ~typeParams~.

*** DONE ~TermSymbol~'s
    CLOSED: [2020-09-14 Mon 00:33]
    - The /type/ of ~TermSymbol~ representing declarations of
      + ~val~
      + ~var~
      + ~def~
      + ~object~
      + ~package~
      + _value parameters_

    - ~TermSymbol~ has TWO /subclasses/:
      + ~MethodSymbol~ :: Represent ~def~ _declarations_.
        * It supports queries like checking
          - whether a /method/ is a (primary) constructor,
          - whether a /method/ supports /variable-length argument lists/.

      + ~ModuleSymbol~ :: Represent ~object~ _declarations_.
        * It allows *looking up* the /class/ implicitly associated with the object
          definition via member ~moduleClass~. =TODO= =???= =TODO=

        * The opposite look up is also possible.
          One can go back from a /module class/ to the associated /module symbol/ by
          inspecting its ~selfType.termSymbol~. =TODO= =???= =TODO=

*** DONE ~Symbol~ Conversions
    CLOSED: [2020-09-14 Mon 00:35]
    - It's possible to _CONVERT_ the MORE GENERAL ~Symbol~ type obtained _TO_ the
      SPECIFIC, MORE SPECIALIZED /symbol type/ needed.

    - For example,
      #+begin_src scala
        import scala.reflect.runtime.universe._

        class C[T] {
          def test[U](x: T)(y: U): Int = ???
        }

        object showResult {
          val testMember = typeOf[C[Int]].member(TermName("test"))
          // testMember: scala.reflect.runtime.universe.Symbol = method test

          testMember.asMethod
          // res0: scala.reflect.runtime.universe.MethodSymbol = method test
        }
      #+end_src

*** DONE Free symbols - =TODO= =NEED-EXAMPLES=
    CLOSED: [2020-09-14 Mon 00:38]
    - The _TWO_ /symbol/ types ~FreeTermSymbol~ and ~FreeTypeSymbol~ have a special
      status, in the sense that they refer to symbols whose available information
      is not complete.

    - These symbols are generated in some cases during /reification/
      + =TODO=
        see the corresponding section about /reifying trees/ for more background.

    - Whenever /reification/ *CANNOT locate* a /symbol/ (meaning that the /symbol/
      is NOT available in the corresponding class file, for example, because the
      /symbol/ refers to a local class),
      =???= =TODO= =???=
        it reifies it as a so-called "free type", a /synthetic dummy symbol/ that
      remembers the original name and owner and has a surrogate type signature
      that closely follows the original.
      =TODO= NEED EXAMPLEs =TODO=
      + Check by ~sym.isFreeType~

      + Get a list of all free types referenced by a tree and it children by
        calling ~tree.freeTypes~.

      + Get warnings when ~tree.freeTypes~ /reification/ produces /free types/
        by using ~-Xlog-free-types~.

** DONE Types
   CLOSED: [2020-09-14 Mon 00:56]
   - ~Type~: a instance of ~Type~ represents information about a type of a
     corresponding /symbol/.

   - This includes its members (methods, fields, type aliases, abstract types,
     nested classes, traits, etc.) either declared directly or inherited, its
     base types, its erasure and so on.
     =from Jian=
     This sentence is hard to understand? Looks wierd!!!
     What does it mean???

   - Types also PROVIDE operations to *test* for _type conformance or equivalence_.

*** DONE Instantiating Types
    CLOSED: [2020-09-14 Mon 00:47]
    - In general, there are three ways to instantiate a Type.
      1. via method ~typeOf~ on ~scala.reflect.api.TypeTags~, which is mixed into
         ~Universe~ (_simplest and most common_).

      2. /Standard Types/, such as ~Int~, ~Boolean~, ~Any~, or ~Unit~ are accessible
         through the available /universe/.

      4. Manual instantiation using /factory methods/ such as ~typeRef~ or ~polyType~
         on ~scala.reflect.api.Types~ (_NOT recommended_).

**** DONE Instantiating Types With ~typeOf~
     CLOSED: [2020-09-14 Mon 00:47]
     - To *instantiate* a /type/, most of the time,
       the ~scala.reflect.api.TypeTags#typeOf~ /method/ can be used.
       + For example:
         #+begin_src scala
           import scala.reflect.runtime.universe._

           typeOf[List[Int]]
           // res0: scala.reflect.runtime.universe.Type = scala.List[Int]
         #+end_src
         It takes a /type argument/ and produces a ~Type~ /instance/ which
         represents that argument.
         + =from Jian=
           If ~val l = List(1, 2, 3)~, then ~typeOf[obj.type]~ will return a ~Type~
           /instance/ with representation ~l.type~. This representation is not very
           helpful, though it is a more exact /type/. Call ~widen~ method on it,
           and it can return the widened ~Type~ instance: ~scala.List[Int]~.

     - In this example, a ~scala.reflect.api.Types$TypeRef~ is returned, which
       corresponds to the /type constructor/ ~List~, applied to the /type argument/
       ~Int~.

     - ~typeOf~ approach requires one to _specify by hand_ the type we're trying
       to instantiate. We can define a function with the help of ~typeOf~ but
       takes one parameter:
       #+begin_src scala
         def getType[T: TypeTag](obj: T) = typeOf[T]

         getType(List(1,2,3))
         // res1: scala.reflect.runtime.universe.Type = List[Int]

         class Animal
         final class Cat extends Animal

         val a = new Animal
         // a: Animal = Animal@21c17f5a

         getType(a)
         // res2: scala.reflect.runtime.universe.Type = Animal

         val c = new Cat
         // c: Cat = Cat@2302d72d

         getType(c)
         // res3: scala.reflect.runtime.universe.Type = Cat
       #+end_src

     - Note:
       Method ~typeOf~ does *NOT* work for types with /type parameters/, such as
       ~typeOf[List[A]]~ where ~A~ is a /type parameter/ (=from Jian= means not
       concrete! /type argument/ is the concorete one).
         In this case, one can use ~scala.reflect.api.TypeTags#weakTypeOf~ instead.
       For more details, see the =TypeTags= section of this guide.

**** DONE Standard Types
     CLOSED: [2020-09-14 Mon 00:47]
     - /Standard types/, such as ~Int~, ~Boolean~, ~Any~, or ~Unit~, are accessible
       through a /universe/'s definitions member.

     - For example:
       #+begin_src scala
         import scala.reflect.runtime.universe

         val intTpe = universe.definitions.IntTpe
         // intTpe: scala.reflect.runtime.universe.Type = Int
       #+end_src

     - The _list_ of /standard types/ is specified in /trait/ ~StandardTypes~ in
       ~scala.reflect.api.StandardDefinitions~.

*** DONE Common Operations on Types
    CLOSED: [2020-09-14 Mon 00:56]
    - ~Type~'s are typically used for /type conformance tests/ or /are queried for
      members/.

    - The three main classes of operations performed on types are:
      1. *Checking* the /subtyping relationship/ between two types.
      2. *Checking* for /equality/ between two types.
      3. *Querying* a given type for certain members or inner types.

**** DONE Subtyping Relationships
     CLOSED: [2020-07-04 Sat 04:30]
     - Given two ~Type~ instances, one can easily test whether one is a /subtype/
       of the other using ~<:<~ (and in exceptional cases, ~weak_<:<~, *explained
       below*)
       #+begin_src scala
         import scala.reflect.runtime.universe._

         object subtypingShow {
           private class A
           final private class B extends A

           typeOf[A] <:< typeOf[B]
           // res0: Boolean = false

           typeOf[B] <:< typeOf[A]
           // res0: Boolean = true
         }
       #+end_src

     - Note that method ~weak_<:<~ exists to check for /weak conformance/ between
       two types. *This is typically important when dealing with /numeric types/.*
       + /Scala's numeric types/ abide by the following ordering (_section 3.5.3
         of the Scala language specification_):
         * *Weak Conformance Relations*
           - ~Byte <:w Short~
           - ~Short <:w Int~
           - ~Char <:w Int~
           - ~Int <:w Long~
           - ~Long <:w Float~
           - ~Float <:w Double~

       + For example, /weak conformance/ is used to determine the /type/ of the
         following if-expression:
         #+begin_src scala
           if (true) 1 else 1d
           // res2: Double = 1.0
         #+end_src
         * if-expression result type is defined to be the /weak least upper bound/
           of the two types (i.e., the /least upper bound/ with respect to /weak
           conformance/).

         * Thus, since ~Double~ is defined to be /the *least upper bound* with
           respect to weak conformance/ between ~Int~ and ~Double~ (according to
           the spec, shown above), ~Double~ is inferred as the type of the given
           if-expression.

       + Note that method ~weak_<:<~ checks for /weak conformance/ and thus returns
         the correct result when inspecting /conformance relations/ between /numeric
         types/ ~Int~ and ~Double~:
         #+begin_src scala
           typeOf[Int] weak_<:< typeOf[Double]
           // res3: Boolean = true

           typeOf[Double] weak_<:< typeOf[Int]
           // res4: Boolean = false
         #+end_src

       + Whereas using ~<:<~ would INCORRECTLY report that ~Int~ and ~Double~ do not
         conform to each other in any way:
         #+begin_src scala
           typeOf[Int] <:< typeOf[Double]
           // res5: Boolean = false

           typeOf[Double] <:< typeOf[Int]
           // res5: Boolean = false
         #+end_src

**** DONE Type Equality
     CLOSED: [2020-09-14 Mon 00:50]
     - Similar to /type conformance/, one can easily *check* the /equality of two
       types/.
         That is, given two arbitrary types, one can use method ~=:=~ to see if
       both denote the *exact same* /compile-time type/.
       #+begin_src scala
         import scala.reflect.runtime.universe._

         def getType[T: TypeTag](obj: T) = typeOf[T]

         class A

         val a1 = new A
         val a2 = new A

         getType(a1) =:= getType(a2)
         // res0: Boolean = true
       #+end_src

     - Also important to note is that ~=:=~ should always be used to compare types
       for equality.
       + *CAUTION*
         That is, _NEVER_ use ~==~, as *it can't check for /type equality/ in the
         presence of /type aliases/,* whereas ~=:=~ can:
       #+begin_src scala
         type Histogram = List[Int]
         // defined type alias Histogram

         typeOf[Histogram] =:= getType(List(4,5,6))
         // res3: Boolean = true

         typeOf[Histogram] == getType(List(4,5,6))
         // res4: Boolean = false
       #+end_src

**** DONE Querying Types for Members and Declarations
     CLOSED: [2020-09-14 Mon 00:56]
     - Given a ~Type~, one can also *query* it for specific _members_ or
       _declarations_.
       + A ~Type~'s _members_ include all /fields/, /methods/, /type aliases/,
         /abstract types/, _nested classes / objects / traits_, etc.

       + A ~Type~'s _declarations_ are only those members that were declared (*NOT
         inherited*) in the class/trait/object definition which the given ~Type~
         represents.

     - To obtain a ~Symbol~ for some specific /member/ or /declaration/,
       + one need only to use methods ~members~ or ~decls~ which provide the list
         of definitions associated with that type.

       + There also exists singular counterparts for each, methods ~member~ and
         ~decl~ as well. The signatures of all four are shown below:

     - Info of ~members~, ~decls~, ~member~, and ~decl~:
       #+begin_src scala
         /** The member with given name, either directly declared or inherited, an
           * `OverloadedSymbol` if several exist, `NoSymbol` if none exist. */
         def member(name: Universe.Name): Universe.Symbol

         /** The defined or declared members with given name in this type; an
           * `OverloadedSymbol` if several exist, `NoSymbol` if none exist. */
         def decl(name: Universe.Name): Universe.Symbol

         /** A `Scope` containing all members of this type
           * (directly declared or inherited). */
         def members: Universe.MemberScope // MemberScope is a type of
                                           // Traversable, use higher-order
                                           // functions such as map,
                                           // filter, foreach to query!

         /** A `Scope` containing the members declared directly on this type. */
         def decls: Universe.MemberScope // MemberScope is a type of
                                         // Traversable, use higher-order
                                         // functions such as map,
                                         // filter, foreach to query!
       #+end_src

     - For example, to look up the ~map~ method of ~List~, one can do:
       #+begin_src scala
         import scala.reflect.runtime.universe._

         typeOf[List[_]].member(TermName("map"))
         // res0: scala.reflect.runtime.universe.Symbol = method map
       #+end_src
       * Note that we pass method member a ~TermName~,
         since we're looking up a /method/.

       * If we were to look up a /type member/, such as ~List~'s /self type/,
         ~Self~, we would pass a ~TypeName~:
         #+begin_src scala
           typeOf[List[_]].member(TypeName("Self"))
           // res1: scala.reflect.runtime.universe.Symbol = type Self
         #+end_src

     - _QUERY_ *ALL* /members/ or /declarations/ on a /type/ in interesting ways.
       We can use /method/ ~members~ to obtain a ~Traversable~ (~MemberScopeApi~
       *extends* ~Traversable~) of ~Symbols~ representing all /inherited or
       declared members/ on a GIVEN /type/
       + For example,
         to print the /members/ of ~List~ which are ~private~, simply do:
         #+begin_src scala
           typeOf[List[Int]].members.filter(_.isPrivate).foreach(println)
           // method super$sameElements
           // method occCounts
           // class CombinationsItr
           // class PermutationsItr
           // method sequential
           // method iterateUntilEmpty
         #+end_src

** DONE Trees
   CLOSED: [2020-09-14 Mon 01:48]
   - ~Tree~, a structure in /Scala reflection/, is the concrete representation of
     Scala's abstract syntax. They are also called AST.

   - In /Scala reflection/, APIs that *produce* or *use* /trees/ are the following:
     1. Scala annotations, which use trees to represent their arguments, exposed
        in ~Annotation.scalaArgs~ (for more, see the *Annotations* section of this
        guide).

     2. ~reify~, a special /method/ that _takes_ an /expression/ and _returns_ an
        /AST/ that represents this expression.

     3. /Compile-time reflection/ with ~macros~ (outlined in the *Macros* guide)
        and /runtime compilation/ with /toolboxes/ both use /trees/ as their
        program representation medium.

   - It's important to note that /trees/ *are _immutable_ _except_ for THREE
     fields* -- ~pos~ (~Position~), ~symbol~ (~Symbol~), and ~tpe~ (~Type~),
     which are assigned when a /tree/ is typechecked.

*** DONE Kinds of ~Tree~'s
    CLOSED: [2020-07-04 Sat 19:11]
    - There are _THREE_ main categories of /trees/:
      1. /Subclasses/ of ~TermTree~ which represent *terms*,
         e.g.,
         + /method invocations/ are represented by ~Apply~ nodes,
         + /object instantiation/ is achieved using ~New~ nodes,
         + etc.

      2. /Subclasses/ of ~TypTree~ which represent *types* that are _EXPLICITLY
         SPECIFIED in program source code_,
         + e.g., ~List[Int]~ is parsed as ~AppliedTypeTree~.

         + Note:
           ~TypTree~ is *NOT* misspelled, *NOR* is it conceptually the same as
           ~TypeTree~ -- ~TypeTree~ is something different.
             That is, in situations where ~Type~'s are constructed by the
           compiler (e.g., during type inference), they can be wrapped in
           ~TypeTree~ trees and integrated into the AST of the program.

      3. /Subclasses/ of ~SymTree~ which *introduce or reference definitions*.
         + Examples of the *introduction* of new definitions include
           * ~ClassDef~'s represent /class and trait definitions/
           * ~ValDef~'s represent /field and parameter definitions/.

         + Examples of the *reference* of existing definitions include
           * ~Ident~'s refer to an existing definition _in the CURRENT scope_ such
             as a /local variable/ or a /method/.

    - Any other /type/ of /tree/ that one might encounter are TYPICALLY /syntactic
      or short-lived constructs/.
      + For example,
        ~CaseDef~, which wraps individual match cases; such nodes are NEITHER
        /terms/ NOR /types/, NOR do they carry a /symbol/.

*** DONE Inspecting Trees
    CLOSED: [2020-07-04 Sat 19:11]
    - Scala Reflection provides a handful of ways to *visualize* /trees/, all
      available through a /universe/.
      Given a /tree/, one can:
      + use /methods/ ~show~ or ~toString~ which *print* pseudo-Scala code
        represented by the tree.

      + use /methods/ ~showRaw~ to see the _raw internal_ tree that the typechecker
        operates upon.

    - For example, given the following tree:
      #+begin_src scala
        import scala.reflect.runtime.universe._

        // Add 2 to x.
        val tree = Apply(Select(Ident(TermName("x")), TermName("$plus")),
                         List(Literal(Constant(2))))
        // tree: scala.reflect.runtime.universe.Apply = x.$plus(2)

      #+end_src
      + We can use ~show(tree)~ (or ~toString~, which is _equivalent_) to see what
        that /tree/ represents -- in the case above, it is a string of ~"x.$plus(2)"~.

    - We can also _go in the *other direction*._
      Given some Scala expression, we can
      1. obtain a /tree/,
      2. then use method ~showRaw~ to see the _raw internal_ /tree/ that the compiler
         and typechecker operate on.

    - For example, given the expression:
      #+begin_src scala
        import scala.reflect.runtime.universe._

        val expr = reify { class Flower { def name = "Rose" } }
        // expr: scala.reflect.runtime.universe.Expr[Unit] = ...
      #+end_src
      + ~reify~ simply
        * takes the /Scala expression/
        * returns a Scala ~Expr~, which is simply _wraps_ a ~Tree~ and a ~TypeTag~
          (see the =Expr= section of this guide for more information about ~Exprs~).

    - We can obtain the tree that expr contains by:
      #+begin_src scala
        val tree = expr.tree
        // tree: scala.reflect.runtime.universe.Tree =
        // {
        //   class Flower extends AnyRef {
        //     def <init>() = {
        //       super.<init>();
        //       ()
        //     };
        //     def name = "Rose"
        //   };
        //   ()
        // }
      #+end_src

    - And we can inspect the raw tree by simply doing:
      #+begin_src scala
        showRaw(tree)
        // res1: String = Block(List(ClassDef(Modifiers(), TypeName("Flower"), List(), Template(List(Ident(TypeName("AnyRef"))), emptyValDef, List(DefDef(Modifiers(), termNames.CONSTRUCTOR, List(), List(List()), TypeTree(), Block(List(Apply(Select(Super(This(typeNames.EMPTY), typeNames.EMPTY), termNames.CONSTRUCTOR), List())), Literal(Constant(())))), DefDef(Modifiers(), TermName("name"), List(), List(), TypeTree(), Literal(Constant("Rose"))))))), Literal(Constant(())))
      #+end_src

*** DONE Traversing Trees
    CLOSED: [2020-09-14 Mon 01:48]
    After one understands the structure of a given /tree/, typically the next step
    is to extract info from it. This is accomplished by *traversing* the /tree/,
    and it can be done in one of _TWO_ ways:
    - *Traversal* via /pattern matching/.

    - Using a /subclass/ of ~Traverser~

**** DONE Traversal via Pattern Matching
     CLOSED: [2020-09-14 Mon 01:37]
     Traversal via /pattern matching/ is the SIMPLEST and MOST COMMON way to
     *traverse* a /tree/.

     - Typically, one _traverses_ a /tree/ via /pattern matching/ when they are
       interested in the state of a given /tree/ at a *single* /node/.

     - For example,
       say we simply want to obtain the function and the argument of
       the only ~Apply~ /node/ in the following /tree/:
       #+begin_src scala
         import scala.reflect.runtime.universe._

         val tree = Apply(Select(Ident(TermName("x")), TermName("$plus")),
                          List(Literal(Constant(2))))
         // tree: scala.reflect.runtime.universe.Apply = x.$plus(2)

         val Apply(fun, arg :: Nil) = tree
         // fun: scala.reflect.runtime.universe.Tree = x.$plus
         // arg: scala.reflect.runtime.universe.Tree = 2
       #+end_src

     - Note that ~Tree~'s can TYPICALLY be *quite complex*, with /nodes/ _nested
       arbitrarily deep_ within other /nodes/.
         A simple illustration would be if we were to add a second ~Apply~ node
       to the above tree which serves to add 3 to our sum:
       #+begin_src scala
         val tree = Apply(Select(Apply(Select(Ident(TermName("x")), TermName("$plus")),
                                       List(Literal(Constant(2)))),
                                 TermName("$plus")),
                          List(Literal(Constant(3))))
         // tree: scala.reflect.runtime.universe.Apply = x.$plus(2).$plus(3)
       #+end_src

     - If we apply the same patternn match as above, we obtain the outer ~Apply~
       node which contains as its function the entire /tree/ representing ~x.$plus(2)~
       that we saw above:
       #+begin_src scala
         val Apply(fun, arg :: Nil) = tree
         // fun: scala.reflect.runtime.universe.Tree = x.$plus(2).$plus
         // arg: scala.reflect.runtime.universe.Tree = 3

         showRaw(fun)
         // val res3: String = Select(Apply(Select(Ident(TermName("x")), TermName("$plus")),
         //                                 List(Literal(Constant(2)))),
         //                           TermName("$plus"))
       #+end_src

     - In cases where one must do some richer task, such as
       + *traversing* an ENTIRE /tree/ WITHOUT STOPPING at a SPECIFIC /node/,
         or
       + *collecting* and *inspecting* ALL /nodes/ of a SPECIFIC /type/, using
         ~Traverser~ for traversal might be more advantageous.

**** DONE Traversal via ~Traverser~
     CLOSED: [2020-09-14 Mon 01:48]
     In situations where it's necessary to *traverse an ENTIRE tree* from top to
     bottom, using traversal via /pattern matching/ would be *infeasible* -- to do
     it this way, one must individually handle every type of node that we might
     come across in the pattern match.
       *Thus, in these situations, typically class ~Traverser~ is used.*

     - ~Traverser~ makes sure to visit *every* /node/ in a given /tree/,
       in a _depth-first search_.

     - To use a ~Traverser~, simply subclass ~Traverser~ and _override_ /method/
       ~traverse~. In doing so, you can simply provide custom logic to *handle
       ONLY the cases you're interested in*.
       + For example, if, given our ~x.$plus(2).$plus(3)~ /tree/ from the previous
         section, we would like to collect all Apply nodes, we could do:
         #+begin_src scala
           import scala.reflect.runtime.universe._

           object traverser extends Traverser {
             val tree = Apply(Select(Apply(Select(Ident(TermName("x")), TermName("$plus")),
                                           List(Literal(Constant(2)))),
                                     TermName("$plus")), List(Literal(Constant(3))))
               // tree: scala.reflect.runtime.universe.Apply = x.$plus(2).$plus(3)

             var applies = List.empty[Apply]

             override def traverse(tree: Tree): Unit = tree match {
               case app @ Apply(fun, args) =>
                 applies = app :: applies
                 super.traverse(fun)
                 super.traverseTrees(args)

               case _ => super.traverse(tree)
             }
           }
         #+end_src

     - In the above, we intend to construct a list of ~Apply~ /nodes/ that we find in
       our given /tree/.

     - We achieve this by in effect ADDING _a SPECIAL case_ TO the already
       /depth-first traverse/ method defined in /superclass/ ~Traverser~, via
       /subclass/ ~traverser~'s _overridden_ ~traverse~ /method/.
         Our special case affects ONLY nodes that match the pattern ~Apply(fun, args)~,
       where ~fun~ is some /function/ (represented by a ~Tree~) and ~args~ is a list of
       /arguments/ (represented by a list of ~Tree~'s).

     - When a /tree/ matches the pattern (i.e., when we have an ~Apply~ /node/),
       we simply add it to our ~List[Apply]~, ~applies~, and continue our _traversal_.

     - Q :: WHY do we
       + call ~super.traverse~ on ~fun~?
       + call ~super.traverseTrees~ on ~args~? (=from Jian= more details in this doc)

     - A :: The ~Traverser~ /superclass/ calls ~this.traversve~, passing in every
            nested sub-tree, eventually our custom ~traverse~ method is guaranteed
            to be called for each sub-tree that matches our ~Apply~ pattern.

     - To trigger the /traverse/ and to see the resulting ~List~ of matching ~Apply~
       /nodes/, simply do:
       #+begin_src scala
         traverser.traverse(tree)

         traverser.applies
         // res0: List[scala.reflect.runtime.universe.Apply] = List(x.$plus(2), x.$plus(2).$plus(3))
       #+end_src

*** DONE Creating Trees
    CLOSED: [2020-09-14 Mon 01:32]
    - When working with /runtime reflection/, one *need NOT construct* /trees/
      manually.

    - However,
      *BOTH*

      /runtime/ compilation with /toolboxes/
      and
      /compile-time reflection/ with /macros/

      *use* /trees/ as their _program representation medium_.

    - In these cases, there are three recommended ways to create /trees/:
      + Via /method/ ~reify~ (should be *PREFERRED* wherever possible).
      + Via /method/ ~parse~ on ~ToolBox~'es.
      + Manual construction (*NOT recommended*).

**** DONE Tree Creation via ~reify~
     CLOSED: [2020-07-04 Sat 21:51]
     - ~Tree~ creation via /method/ ~reify~ is the recommended way of creating
       trees in Scala Reflection.

     - Example:
       #+begin_src scala
         import scala.reflect.runtime.universe._

         { val tree = reify(println(2)).tree; showRaw(tree) }
         // res0: String = Apply(Select(Select(This(TypeName("scala")), TermName("Predef")),
         //                                    TermName("println")),
         //                      List(Literal(Constant(2))))
       #+end_src
       + Note:
         the ~println~ /method/ was transformed to ~scala.Predef.println~.
         Such transformations ensure that regardless of where the result of
         ~reify~ is used, *it will _NOT_ unexpectedly change its meaning.*
         * For example,
           even if this ~println(2)~ snippet is later inserted into a block of
           code that defines its own ~println~, it wouldn't affect the behavior
           of the snippet.

       + *This way of creating trees is thus /hygenic/,*
         in the sense that it *PRESERVES* _bindings of identifiers._

***** DONE Splicing Trees
      CLOSED: [2020-07-04 Sat 22:00]
      Using ~reify~ also allows one to *compose* /trees/ from SMALLER /trees/.
      This is done using ~Expr.splice~.

      - Note:
        ~Expr~ is ~reify~'s /return type/.
        It can be _thought of as_ a simple wrapper which contains
        + a typed ~Tree~
        + a ~TypeTag~
        + a handful of _reification-relevant methods_, such as ~splice~

      - For example, let's try to construct a tree representing ~println(2)~ using
        ~splice~:
        #+begin_src scala
          val x = reify(2)
          // x: scala.reflect.runtime.universe.Expr[Int(2)] = Expr[Int(2)](2)

          reify(println(x.splice))
          // res1: scala.reflect.runtime.universe.Expr[Unit] =
          //   Expr[Unit](scala.this.Predef.println(2))
        #+end_src

      - Note, HOWEVER,
        that there is *A requirement* for the argument of ~reify~ to be _valid
        and typeable Scala code_.
          If instead of the argument to ~println~ we wanted to abstract over the
        ~println~ itself, it wouldn't be possible:
        #+begin_src scala
          val fn = reify(println)
          // fn: scala.reflect.runtime.universe.Expr[Unit] =
          //   Expr[Unit](scala.this.Predef.println())

          reify(fn.splice(2))
          // <console>:12: error: Unit does not take parameters
          //             reify(fn.splice(2))
          //                             ^
        #+end_src
        + As we can see,
          - *the compiler assumes* that we wanted to ~reify~ a call to ~println~
            with _NO_ arguments,

          - *while* what we _really wanted_ was to capture the name of the function
            to be called.

        + These types of use-cases are _currently_ *INEXPRESSIBLE* when using ~reify~.

**** DONE Tree Creation via ~parse~ on ~ToolBox~'es
     CLOSED: [2020-07-04 Sat 22:07]
     - ~Toolbox~'es can be used to
       + typecheck
       + compile
       + execute /abstract syntax trees/.

     - A /toolbox/ can also be used to *parse* a string *into* an /AST/.

     - Note:
       Using /toolboxes/ requires =scala-compiler.jar= to be on the /classpath/.

     - Let's see how ~parse~ deals with the ~println~ example from the previous
       section:
       #+begin_src scala
         import scala.reflect.runtime.universe._
         import scala.tools.reflect.ToolBox

         val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
         // tb: scala.tools.reflect.ToolBox[scala.reflect.runtime.universe.type] =
         //   scala.tools.reflect.ToolBoxFactory$ToolBoxImpl@7bc979dd

         showRaw(tb.parse("println(2)"))
         // res2: String = Apply(Ident(TermName("println")), List(Literal(Constant(2))))
       #+end_src

     - =IMPORTANT=
       It's important to note that, _UNLIKE_ ~reify~,
       /toolboxes/ are _NOT LIMITED_ by the typeability requirement–
       although this flexibility is achieved *by SACRIFICING robustness*.
       + That is, here we can see that ~parse~, unlike ~reify~, *doesn't reflect*
         the fact that ~println~ should be bound to the standard ~println~ /method/.

     - *CAUTION*
       when using /macros/, one *SHOULDN'T* use ~ToolBox.parse~.
       This is because there's _ALREADY_ a ~parse~ /method/ _built into_ the
       /macro context/.
       + For example:
         #+begin_src scala
           import scala.language.experimental.macros

           def impl(c: scala.reflect.macros.Context) = c.Expr[Unit](c.parse("println(2)"))

           def test: Unit = macro impl

           // In another file!!!
           test
           //// 2
         #+end_src

***** Typechecking with ~ToolBox~'es
      - As earlier alluded to,
        ~ToolBox~'es enable one to do _more than just_ constructing trees from strings.
        + They can also be used to
          * typecheck
          * compile
          * execute trees

      - _IN ADDITION TO_ outlining the structure of the program,
        /trees/ _ALSO_ hold important information about the /semantics/ of the
        program encoded in ~symbol~ (a /symbol/ assigned to /trees/ that introduce
        or reference definitions), and ~tpe~ (the /type/ of the /tree/).
          *By default these fields are empty, but typechecking fills them in.*

      - When using the runtime reflection framework, typechecking is implemented by
        ~ToolBox.typeCheck~.
        When using macros, at compile time one can use the ~Context.typeCheck~ method.
        #+begin_src scala
          import scala.reflect.runtime.universe._

          val tree = reify { "test".length }.tree
          // tree: scala.reflect.runtime.universe.Tree = "test".length()

          import scala.tools.reflect.ToolBox

          val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
          // tb: scala.tools.reflect.ToolBox[scala.reflect.runtime.universe.type] = ...

          val ttree = tb.typeCheck(tree)
          // ttree: tb.u.Tree = "test".length()

          ttree.tpe
          // res5: tb.u.Type = Int

          ttree.symbol
          // res6: tb.u.Symbol = method length
        #+end_src

      - Here, we simply create a tree that represents a call to ~"test".length~,
        and use ~ToolBox~ ~tb~'s ~typeCheck~ method to typecheck the tree. As we
        can see, ~ttree~ gets the correct type, ~Int~, and its ~Symbol~ is
        correctly set.

**** DONE Tree Creation via Manual Construction
     CLOSED: [2020-07-04 Sat 22:34]
     If all else fails, one can manually construct /trees/.

     - It is obvious that manual construction of a ~Tree~
       + is the MOST _low-level_ way to create /trees/,

       + should _ONLY_ be attempted if _no other approach_ works.

       + sometimes offers
         * *greater flexibility* when compared with ~parse~,
         * though this /flexibility/ is achieved _at a COST of_ *excessive verbosity
           and fragility*.

     - Our earlier example involving ~println(2)~ can be manually constructed as
       follows:
       #+begin_src scala
         Apply(Ident(TermName("println")), List(Literal(Constant(2))))
         // res0: scala.reflect.runtime.universe.Apply = println(2)
       #+end_src

     - The canonical use case for this technique is when the target /tree/ _needs
       to be assembled from dynamically created parts_, which do _NOT_ make sense
       in isolation from one another.
       + In that case,
         * ~reify~ will most likely be inapplicable, because it requires its argument
           to be typeable.

         * ~parse~ might not work either, since quite often, /trees/ are assembled
           on _sub-expression level_, with individual parts being *INEXPRESSIBLE
           as Scala sources*.

* TODO Annotations, Names, Scopes, and More
  - Contributors:
    * nogurenn
    * SethTisue
    * komainu8
    * ashawley
    * marconilanna
    * heathermiller

** Annotations
** Names
*** Standard Names

** Scopes
** Exprs
** Flags and flag sets
** Constants
** Printers
*** Printing Trees
*** Printing Types

** Positions

* TODO ~TypeTag~'s and ~Manifest~'s
  - Contributors:
    + ashawley
    + mukesh210
    + heathermiller

  - As with other JVM languages, Scala's types are erased at run time. This means
    that if you were to inspect the runtime type of some instance, you might not
    have access to all type information that the Scala compiler has available at
    compile time.

  - Like ~scala.reflect.Manifest~, ~TypeTag~'s can be thought of as objects which
    carry along all type information available at compile time, to runtime. For
    example, ~TypeTag[T]~ encapsulates the runtime type representation of some
    compile-time type ~T~. Note however, that ~TypeTag~'s should be considered
    to be a richer replacement of the pre-2.10 notion of a ~Manifest~, that are
    additionally fully integrated with Scala reflection.

  - There exist three different types of ~TypeTag~'s:
    1. scala.reflect.api.TypeTags#TypeTag. A full type descriptor of a Scala type.
       For example, a ~TypeTag[List[String]]~ contains all type information, in
       this case, of type ~scala.List[String]~.

    2. ~scala.reflect.ClassTag~.
       A partial type descriptor of a Scala type. For example, a
       ~ClassTag[List[String]]~ contains only the erased class type information,
       in this case, of type scala.collection.immutable.List. ClassTags provide
       access only to the runtime class of a type. Analogous to
       ~scala.reflect.ClassManifest~.

    3. ~scala.reflect.api.TypeTags#WeakTypeTag~.
       A type descriptor for abstract types (see corresponding subsection below).

** Obtaining a ~TypeTag~
   Like ~Manifest~'s, ~TypeTag~'s are always generated by the compiler, and can
   be obtained in *THREE* ways.

*** via the Methods ~typeTag~, ~classTag~, or ~weakTypeTag~
    - One can directly obtain a ~TypeTag~ for a specific type by simply using
      /method/ ~typeTag~, available through ~Universe~.

    - For example, to obtain a ~TypeTag~ which represents ~Int~, we can do:
      #+begin_src scala
        import scala.reflect.runtime.universe._

        val tt = typeTag[Int]
      #+end_src

    - Or likewise, to obtain a ~ClassTag~ which represents ~String~, we can do
      #+begin_src scala
        import scala.reflect._
        val ct = classTag[String]
      #+end_src

    - Each of these /methods/ constructs a ~TypeTag[T]~ or ~ClassTag[T]~ for the
      given type argument ~T~.

*** Using an Implicit Parameter of Type ~TypeTag[T]~, ~ClassTag[T]~, or ~WeakTypeTag[T]~
    - As with Manifests, one can in effect request that the compiler generate a
      ~TypeTag~. This is done by simply specifying an implicit evidence parameter
      of type ~TypeTag[T]~. If the compiler fails to find a matching implicit
      value during implicit search, it will automatically generate a ~TypeTag[T]~.

    - Note:
      this is typically achieved by using an implicit parameter on methods and
      classes only.

    - For example, we can write a method which takes some arbitrary object, and
      using a ~TypeTag~, prints information about that object's type arguments:
      #+begin_src scala
        import scala.reflect.runtime.universe._

        def paramInfo[T](x: T)(implicit tag: TypeTag[T]): Unit = {
          val targs = tag.tpe match { case TypeRef(_, _, args) => args }
          println(s"type of $x has type arguments $targs")
        }
      #+end_src

    - Here, we write a /generic method/ ~paramInfo~ parameterized on ~T~, and we
      supply an /implicit parameter/ (implicit tag: ~TypeTag[T]~). We can then
      directly access the type (of type ~Type~) that tag represents using /method/
      ~tpe~ of ~TypeTag~.

    - We can then use our /method/ ~paramInfo~ as follows:
      #+begin_src scala
        paramInfo(42)
        //// type of 42 has type arguments List()

        paramInfo(List(1, 2))
        //// type of List(1, 2) has type arguments List(Int)
      #+end_src

*** Using a Context bound of a Type Parameter
    - A less verbose way to achieve exactly the same as above is by using a /context
      bound/ on a type parameter. Instead of providing a separate implicit
      parameter, one can simply include the TypeTag in the type parameter list
      as follows: ~def myMethod[T: TypeTag] = ...~

    - Given context bound [T: TypeTag], the compiler will simply generate an implicit parameter of type TypeTag[T] and will rewrite the method to look like the example with the implicit parameter in the previous section.

    - The above example rewritten to use /context bounds/ is as follows:
      #+begin_src scala
        import scala.reflect.runtime.universe._

        object typeTagAsContextBound {

          def paramInfo[T: TypeTag](x: T): Unit = {
            val targs = typeOf[T] match { case TypeRef(_, _, args) => args }
            println(s"type of $x has type arguments $targs")
          }

          paramInfo(42)
          //// type of 42 has type arguments List()

          paramInfo(List(1, 2))
          //// type of List(1, 2) has type arguments List(Int)
        }
      #+end_src

** ~WeakTypeTag~'s
   - ~WeakTypeTag[T]~ generalizes ~TypeTag[T]~.
     Unlike a regular ~TypeTag~, components of its /type representation/ can be
     references to /type parameters/ or /abstract types/. However, ~WeakTypeTag[T]~
     tries to be as concrete as possible, i.e., if /type tags/ are available for
     the referenced /type arguments/ or /abstract types/, they are used to embed
     the concrete types into the ~WeakTypeTag[T]~.

   - Continuing the example above:
     #+begin_src scala
       object weakTypeTagsShow {

         def weakParamInfo[T](x: T)(implicit tag: WeakTypeTag[T]): Unit = {
           val targs = tag.tpe match { case TypeRef(_, _, args) => args }
           println(s"type of $x has type arguments $targs")
         }

         def foo[T] = weakParamInfo(List.empty[Int])

         foo[Int]
         // type of List() has type arguments List(T)

       }
     #+end_src

** ~TypeTag~'s and ~Manifest~'s
   - ~TypeTag~'s _correspond LOOSELY to_ the pre-2.10 notion of
     ~scala.reflect.Manifests~.
       While ~scala.reflect.ClassTag~ corresponds to ~scala.reflect.ClassManifest~
     and ~scala.reflect.api.TypeTags#TypeTag~ mostly corresponds to
     ~scala.reflect.Manifest~, other pre-2.10 ~Manifest~ types do not have a
     direct correspondence with a 2.10 _"Tag" type_.
     + ~scala.reflect.OptManifest~ is *NOT* supported.
         This is because Tags can reify arbitrary types, so they are always
       available.

     + *There is no equivalent for ~scala.reflect.AnyValManifest~.*
         Instead, one can compare their Tag with one of the base Tags (defined in
       the corresponding companion objects) in order to find out whether or not
       it represents a primitive value class. Additionally, it’s possible to simply
       use ~<tag>.tpe.typeSymbol.isPrimitiveValueClass~.

     + *There are no replacement for factory methods defined in the Manifest
       companion objects.*
         Instead, one could generate corresponding types using the reflection
       APIs provided by Java (for classes) and Scala (for types).

     + *Certain manifest operations(i.e., ~<:<~, ~>:>~ and ~typeArguments~) are NOT
       supported.*
         Instead, one could use the reflection APIs provided by Java (for classes)
       and Scala (for types).

   - In Scala 2.10, ~scala.reflect.ClassManifest~ are deprecated, and it is planned
     to deprecate ~scala.reflect.Manifest~ in favor of ~TypeTag~'s and ~ClassTag~'s
     in an upcomming point release.
     + CONCLUSION:
       Thus, it is ADVISABLE to _migrate_ any *Manifest-based APIs* _to_ use *Tags*.

* TODO Thread Safety
  - Author:
    Eugene Burmako

  - Contributors:
    + ashawley
    + heathermiller

  - Unfortunately, in its current state released in Scala 2.10.0, reflection is
    not thread safe. There’s a JIRA issue SI-6240, which can be used to track
    our progress and to look up technical details, and here’s a concise summary
    of the state of the art.

  - NEW Thread safety issues have been fixed in Scala 2.11.0-RC1, but we are going
    to keep this document available for now, since the problem still remains in
    the Scala 2.10.x series, and we currently don't have concrete plans on when
    the fix is going to be backported.

  - Currently we know about two kinds of races associated with reflection.
    1. reflection initialization (the code that is called when
       ~scala.reflect.runtime.universe~ is accessed for the first time) cannot
       be safely called from multiple threads.

    2. symbol initialization (the code that is called when symbol's flags or type
       signature are accessed for the first time) isn’t safe as well.

  - Here's a typical manifestation:
    #+begin_src text
      java.lang.NullPointerException:
      at s.r.i.Types$TypeRef.computeHashCode(Types.scala:2332)
      at s.r.i.Types$UniqueType.<init>(Types.scala:1274)
      at s.r.i.Types$TypeRef.<init>(Types.scala:2315)
      at s.r.i.Types$NoArgsTypeRef.<init>(Types.scala:2107)
      at s.r.i.Types$ModuleTypeRef.<init>(Types.scala:2078)
      at s.r.i.Types$PackageTypeRef.<init>(Types.scala:2095)
      at s.r.i.Types$TypeRef$.apply(Types.scala:2516)
      at s.r.i.Types$class.typeRef(Types.scala:3577)
      at s.r.i.SymbolTable.typeRef(SymbolTable.scala:13)
      at s.r.i.Symbols$TypeSymbol.newTypeRef(Symbols.scala:2754)
    #+end_src

  - Good news is that compile-time reflection (the one exposed to macros via
    ~scala.reflect.macros.Context~) is much less susceptible to threading
    problems than runtime reflection (the one exposed via
    scala.reflect.runtime.universe). The first reason is that by the time macros
    get chance to run, compile-time reflective universe are already initialized,
    which rules our the race condition #1. The second reason is that the
    compiler has never been thread-safe, so there are no tools, which expect is
    to run in parallel. Nevertheless, if your macro spawns multiple threads you
    should still be careful.

  - It’s much worse for runtime reflection though. Reflection init is called the
    first time when scala.reflect.runtime.universe is initialized, and this
    initialization can happen in an indirect fashion. The most prominent example
    here is that calling methods with TypeTag context bounds is potentially
    problematic, because to call such a method Scala typically needs to
    construct an autogenerated type tag, which needs to create a type, which
    needs to initialize the reflective universe. A corollary is that if you
    don’t take special measures, you can’t call reliably use TypeTag-based
    methods in tests, because a lot of tools, e.g. sbt, run tests in parallel.

  - Bottom line:
    + If you're writing a macro, which doesn't explicitly create threads, you're
      perfectly fine.

    + /Runtime reflection/ mixed with /threads/ or /actors/ *might be DANGEROUS*.

    + Multiple threads calling methods with ~TypeTag~ /context bounds/ might lead
      to non-deterministic results.

    + Check out SI-6240 to see our progress with this issue.

* TODO Changes in Scala 2.11
  - Contributors:
    + OlivierBlanvillain
    + ashawley
    + heathermiller

  - The page lives at https://docs.scala-lang.org/overviews/macros/changelog211.html
