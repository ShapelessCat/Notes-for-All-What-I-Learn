#+TITLE: Scala for The Impatient
#+VERSION: 1st
#+AUTHOR: Cay Horstmann
#+STARTUP: overview
#+STARTUP: entitiespretty

=TODO= Exercises of Chapter 7

* Preface
** Acknowledgements
* Contents
* DONE Chapter 1   The Basics
  CLOSED: [2017-03-02 Thu 16:39]
** 1.1 The Scala Interpreter ("The REPL")
  - ~toCharArray~, ~toLowerCase~, ~toString~, and ~toUpperCase~.

  - Technically speaking, the scala program is not an interpreter. Behind the
    scenes, your input is quickly compiled into bytecode, and the bytecode is
    executed by the Java virtual machine. For that reason, most Scala programmers
    prefer to call it "the REPL".

** 1.2 Declaring Values and Variables
   - ~val~
   - ~var~

** 1.3 Commonly Used Types
   - There is _NO_ distinction between primitive types and class types in Scala.

   - =TODO=: ~Range~ class (Chapter 13).

   - Object are implicitly converted to their corresponding augmented classes,
     for example: ~java.lang.String~ object is converted to ~StringOps~ object.
     The target object (of class ~StringOpas~) has more methods.

   - =TODO=: /Scaladoc/ (Section 1.7).

   - ~Int~ <-> ~RichInt~
     ~Double~ <-> ~RichDouble~
     ~Char~ <-> ~RichChar~

   - ~java.math.BigInteger~ <-> ~BigInt~
     ~java.math.BigDecimal~ <-> ~BigDecimal~
     =COMMENT=: ~BitInt~ and ~BigDecimal~ is more convenient than their cusins
                in Java: they can use the usual mathematical operators.

** 1.4 Arithmetic and Operator Overloading
   - Operators are actually methos. For example:
     ~a + b~ is a shorthand for ~a.+(b)~

** 1.5 Calling Functions and Methods
   - NOTE: To use a package that starts with ~scala.~, you can omit the
     =scala= prefix:
     + ~import scala.math._~ is the same as ~import math._~.
     + ~scala.math.sqrt(2)~ is the same as ~math.sqrt(2)~

   - After importing with ~import math._~, methods like ~sprt~, ~pow~, and ~min~
     can be used.

   - =TODO=: ~import~ Chapter 7.

   - =TODO=: /singleton object/ (Chapter 6) and /companion object/

   - =TODO=: NOTE: Here, ~Random~

   - =STYLE=: Scala methods without parameters OFTEN DON'T use parentheses.
              The rule of thumb is that a parameterless method that doesn't
              modify the object has no parentheses.
              =TODO= We discuss this further in Chapter 5.

** 1.6 The ~apply~ Method
   - In Scala, it is common to use a syntax that looks like a function call. For
     example, if s is a string, then ~s(i)~ is the ith character of the string.
     (~s[i]~ in C++ and ~s.charAt(i)~ in Java.

   - It's actually the ~apply~ method ~def apply(n: Int): Char~. For example:
     + ~"Hello"(4)~ is a shorthand of ~"Hello".apply(4)~.
     + ~BigInt("1234567890")~ is a shorthand of ~BigInt.apply("12234567890")~.

** TODO 1.7 Scaladoc
   - Scaladoc can be a bit overwhelming. Keep these tips in mind:

** TODO Exercises
   solution: https://gist.github.com/parambirs/9932268
   - 5
   - 6
   - 8 ~BigInt.probablePrime(100, util.Random).toString(36)~
   - 10. The given methods has
     + advantage :: If count from the head / tail, these methods are consice and
                    intuitive.
     + disadvantage :: If not count from the head / tial, at least two operations
                       are required, and then they are not more concise and
                       intuive than the ~substring~ method.

* DONE Chapter 2   Control Structures and Functions
  CLOSED: [2017-03-05 Sun 00:03]
  =14 ~ 29=
  - In Scala, almost all constructs have values. =TODO: WHY ALMOST ALL???=
** 2.1 Conditional Expressions
   - ~if/else~
     #+BEGIN_SRC scala
     val s = if (x > 0) 1 else -1  // prefered, can initialize a val
     
     var p
     if (x > 0) p = 1 else p = -1  // p must be var in this if/else
     #+END_SRC

   - The type of ~if/else~ is the common supertype of both branches. For example:
     #+BEGIN_SRC scala
     // This if/else has type `Any'
     if (x > 0) "positive" else -1
     #+END_SRC
     =TODO=: Section 8.11, "The Scala Inheritance Hierarchy" page 96

   - class ~Unit~ has one value, written as ~()~. An no ~else~ ~if~ expression is
     equivalent to a ~if~ expression with ~else ()~ as the second branch.

   - =TODO=: /pattern matching/ in Chapter 14.

   - _CAUTIOIN_: The REPL can only see one line. Use ~{}~ to write multiple lines
     ~if/else~.

   - TIP: If you want to paste a block of code into the REPL without worrying
     about its nearsightedness, _use paste mode_. Type
        ~:paste~
     Then paste in the code block and type =Ctrl+K=. The REPL will then analyze
     the block in its entirety.

** 2.2 Statement Termination
   - _Feature_ =??=:
     #+BEGIN_SRC scala
     // This works
     val s = s0 + (v - v0) * t +
           0.5 * (a - a0) * t * t
     
     // This doesn't work as being wished
     val p = s0 + (v - v0) * t
         + 0.5 * (a - a0) * t * t
     #+END_SRC
     + This is also the reason why Scala programmers favor the
       Kernighan & Ritchie brace style: The ~{~ tells the compiler that this is
       not the end.

   - 
** 2.3 Block Expressions and Assignments
   - In Scala, a ~{~ ~}~ block contains a sequence of expressions, and the result
     is also an expression. The value of the block is the value of the last
     expression.

   - Usage 1: the initialization of a val takes more than one step
     ~val distance = {val dx = x - x0; val dy = y - y0; sqrt(dx*dx, dy*dy)}~

   - In Scala, assigments have a value of type ~Unit~, the ~()~.

   - _Be aware_: A block that ends with an assignment statement, such as
     ~{ r = r * n; n -= 1 }~ has a ~()~ value. DO NOT chain assignment.

** 2.4 Input and Output
   - ~print~
   - ~println~
   - ~printf~: C-style print
   - ~readLine~: read a line of input from the console. It can take a prompt.
   - ~readInt~, ~readDouble~, ~readByte~, ~readShort~, ~readLong~, ~readFloat~,
     ~readBoolean~, and ~readChar~. They can't take a prompt.
** 2.5 Loops
   - ~while~ loop:
     #+BEGIN_SRC scala
     while (n > 0) {
       r = r * n
       n -= 1
     }
     #+END_SRC

   - ~for~ loop:
     #+BEGIN_SRC scala
     for (i <- 1 to n)
       r = r * i
     #+END_SRC

   - =NOTE=: xxx

   - range use ~until~: ~0 until n~ doesn't include the upper bound.

   - range use ~to~: ~0 to n~ includes the upper bound.

   - Loop a iterable =By Jian=:
     #+BEGIN_SRC scala
     var sum = 0
     for (ch <- "Hello") sum += ch
     #+END_SRC

   - _NOTE_ =TODO= Scala doesn't have ~break~ and ~continue~. If you need:
     1. 
     2. 
     3. 

     _page21_ =IMPORTANT=

** 2.6 Advanced ~for~ Loops and ~for~ Comprehensions
   - The generated collection is compatible with the first generator:
     #+BEGIN_SRC scala
     for (c <- "Hello"; i <- 0 to 1) yield (c +i).toChar
     // Yields "HIeflmlmop"

     for (i <- 0 to 1; c <- "Hello") yield (c +i).toChar
     // Yields Vector('H', 'e', 'l', 'l', 'o', 'I', 'f', 'm', 'm', 'p')
     #+END_SRC

   - _NOTE_: If you prefer, you can enclose the generators, guards, and
     definitions of a ~for~ loop inside braces, and you can use newlines instead
     of semicolons to separate them: =TODO Re-read=
     #+BEGIN_SRC scala
     for {i <- 1 to 3
          from = 4 - i
          j <- from to 3}
     #+END_SRC 
** 2.7 Functions
   - Scala, not like Java, has functions in addition to methods.
 
   - If the body of the function requires more than one expression, use a block.

   - Return type must written _explicitly_ for recursive function.

   - ~return~ keyword does exist in Scala, but it's rarely used.

   - In anonymous functions, ~return~ has it's duty:
     + it DOESN'T return a value to the caller.
     + It breaks out to the enclosing named function.
     Think of ~return~ as a kind of _break_ statement for functions, and
     _ONLY use it when you want that breakout functionality_.

   - =IMPORTANT=: Some programming languages (such as /ML/ and /Haskell/) can
     infer the type of a recursive function, using the Hindley-Milner algorithm.
     However, _this doesn't work well in an object-oriented language_.
     =TODO= Extending the Hindley-Milner algorithm so it can handle subtypes is
     still a research problem. 

** 2.8 Default and Named Arguments
   - Example:
     #+BEGIN_SRC scala
     def decorate(str: String, left: String = "[", right: String = "]") =
       left + str + right
     
     #+END_SRC

   - You can mix unnamed and named arguments, provided the unnamed ones come
     first.

** 2.9 Variable Arguments
   - Example:
     #+BEGIN_SRC scala
     def sum(args: Int*) = {
       var result = 0
       for (arg <- args) result += arg
         result
     }
     #+END_SRC
     The function receives a single parameter of type ~Seq~,
     =TODO=: which we will discuss in Chapter 13.
     * _CAUTION_: if you already have a sequence of values, you can't pass it directly to
       such a function like ~val s = sum(1 to 5) // Error~.
     * _REMEDY_: Use ~_*~ to tell the compiler that you : ~val s = sum(1 to 5: _*)

   - This call syntax is needed in a recursive definition:
     #+BEGIN_SRC scala
     def sum(args: Int*) : Int = {
       if (args.length == 0) 0
       else args.head + recursiveSum(args.tail : _*)
     }
     #+END_SRC

   - _CALL Java_: =IMPORTANT=
     _CAUTION_: When you call a Java method with variable arguments of type
     _Object_, such as ~PrintStream.printf~ or ~MessageFormat.format~, you need
     to convert any primitive types by hand.
     For example,
     #+BEGIN_SRC scala
     val str = MessageFormat.format("The answer to {0} is {1}",
       "everything", 42.asInstanceOf[AnyRef])
     #+END_SRC
     This is the case for any _Object_ parameter, but I mention it here because
     it is most common with varargs methods.

** 2.10 Procedures
   - /procedure/: Call it for side effect only. It's value is ~()~, and
     the pattern of procedures defintion can be different from that of
     funtions:
     #+BEGIN_SRC scala
     // 1 concise version
     def box(s : String) { // Look carefully: NO =
       val border = "-" * s.length + "--\n"
       println(border + "|" + s + "|\n" + border)
     }

     // 2 explicit return type version
     def box(s : String): Unit = {
       // ...
     }
     #+END_SRC

** 2.11 Lazy Values
   - When a ~val~ is declared as _lazy_, its initialization is deferred until it
     is accessed for the first time. For example:
     #+BEGIN_SRC scala
     lazy val words = scala.io.Source.fromFile("/usr/share/dict/words").mkString 
     #+END_SRC
     In this example, if words is never accessed, file will never be opened. For
     example: if the file name is misspelled, but =words= is not accessed, no
     error will be triggered.
     =TODO=: discuss file operation in Chapter 9

   - Lazy values are useful to delay costly initialization statements.

   - =TODO= Lazy values can also deal with other initialization issues, such as
     circular dependencies. Moreover, they are essential for developing lazy data
     structures.   See Section 13.13 "Steam" 173.

   - You can think of lazy values as halfway between ~val~ and ~def~. Compare:
     #+BEGIN_SRC scala
     val words = scala.io.Source.fromFile("/usr/share/dict/words").mkString
       // Evaluated as soon as words is defined
     lazy val words = scala.io.Source.fromFile("/usr/share/dict/words").mkString
       // Evaluated the first time words is used
     def words = scala.io.Source.fromFile("/usr/share/dict/words").mkString
       // Evaluated every time words is used
     #+END_SRC

   - _NOTE_: Laziness is _NOT cost-free_.
     Every time a lazy value is accessed, a method is called that checks,
     in a threadsafe manner =TODO ??=, whether the value has already been
     initialized.

** 2.12 Exceptions
   - Scala exceptions work the same way as in Java or C++:
     ~throw new IllegalArgumentException("x should not be negative")~

   - As in Java, the objects that you throw need to belong to
     _a subclass of_ ~java.lang.Throwable~.

   - Unlike Java, Scala has no "checked" exceptions: you never have to declare
     that a function or method might throw an exception.

   - NOTE: In Java, "checked" exceptions are checked at compile time. If your
     method might throw an IOException, you must declare it. This forces
     programmers to think where those exceptions should be handled, which is a
     laudable goal. Unfortunately, it can also give rise to monstrous method
     signatures such as
     ~void doSomething() throws IOException, InterruptedException, ClassNotFoundException~.
     Many Java programmers detest this feature and end up defeating it by either
     catching exceptions too early or using excessively general exception
     classes.
     The Scala designers decided against checked exceptions,
     recognizing that _thorough compile-time checking isn't always a good thing_.
     =TODO: WHY=

   - A ~throw~ expression has the special type ~Nothing~.
     That is useful in ~if/else~ expressions:
     If one branch has type Nothing, the type of the ~if/else~ expression is the
     type of the other branch.

   - The syntax for catching exceptions is modeled after the pattern-matching
     syntax (=TODO= Chapter 14).
     #+BEGIN_SRC scala
     try {
       process(new URL("http://horstmann.com/fred-tiny.gif"))
     } catch {
       case _: MalformedURLException => println("Bad URL: " + url)
       case ex: IOException => ex.printStackTrace()
     }
     #+END_SRC
     As in Java or C++, the more general exception types should come _AFTER_ the
     more specific ones.

   - The ~try/finally~ statement lets you dispose of a resource whether or not an
     exception has occurred. For example:
     #+BEGIN_SRC scala
     var in = new URL("http://horstmann.com/fred.gif").openStream()
     try {
       process(in)
     } finally {
       in.close()
     }
     #+END_SRC
     This code is a bit subtle, and it raises several issues:
     + _Q_: What if the URL constructor or the openStream method throws an
            exception?
       _A_: Then the trysblock is never entered, and neither is the ~finally~
       clause. That's just as well—in was never initialized, so it makes no
       sense to invoke ~close~ on it.
     + _Q_: Why isn't ~val in = new URL(...).openStream()~ inside the try block?
       _A_: Then the _scope_ of in would NOT extend to the ~finally~ clause.
     + _Q_: What if ~in.close()~ throws an exception?
       _A_: Then that exception is thrown out of the statement, superseding any
            earlier one. (This is just like in Java, and it isn't very nice.
            Ideally, the old exception would stay attached to the new one.)

   - Note that ~try/catch~ and ~try/finally~ have complementary goals:
     + The ~try/catch~ statement handles exceptions, and
     + the ~try/finally~ statement takes some action (usually cleanup) when an
       exception is not handled.

   - The combination of ~try/catch~ and ~try/finally~ exists, but it's rarely
     used:
     ~try { ... } catch { ... } finally { ... }~, which is the same as
     ~try { try { ... } catch { ... }} finally { ... }~

** Exercises

* DONE Chapter 3   Working with Arrays
  CLOSED: [2017-03-31 Fri 18:26]
  =30 ~ 41=
  - Key points of this chapter:
    + Use an ~Array~ if the length is _fixed_, and
          an ~ArrayBuffer~ if the _length can vary_.
    + DON'T use ~new~ when supplying initial values.
    + Use ~()~ to access elements. (=From Jian=: NOT ~[]~ !!!)
    + Use ~for (elem <- arr)~ to traverse the elements.
    + Use ~for (elem <- arr if . . . ) . . . yield . . .~ to transform into a new array.
    + Scala and Java arrays are _interoperable_;
      with ~ArrayBuffer~, use ~scala.collection.JavaConverters~.

** 3.1 Fixed-Length Arrays — page 31
   - Inside the JVM, a Scala Array is implemented as a Java array.

   - Examples:
     #+BEGIN_SRC scala
     val nums = new Array[Int](10)
       // An array of ten integers, all initialized with zero
     val a = new Array[String](10)
       // A string array with ten elements, all initialized with null
     val s = Array("Hello", "World")
       // An Array[String] of length 2—the type is inferred
       // Note: No new when you supply initial values
     s(0) = "Goodbye"
       // Array("Goodbye", "World")
       // Use () instead of [] to access elements 
     #+END_SRC

** 3.2 Variable-Length Arrays: Array Buffers — page 32
   - ~ArrayBuffer~ is like ~ArrayList~ in Java and ~vector~ in C++

   - Examples:
     #+BEGIN_SRC scala
     import scala.collection.mutable.ArrayBuffer
     val b = ArrayBuffer[Int]()
       // Or `new ArrayBuffer[Int]'
       // An empty array buffer, ready to hold integers
     b += 1
       // ArrayBuffer(1)
       // Add an element at the end with +=
     b += (1, 2, 3, 5)
       // ArrayBuffer(1, 1, 2, 3, 5)
       // Add multiple elements at the end by enclosing them in parentheses
     b ++= Array(8, 13, 21)
       // ArrayBuffer(1, 1, 2, 3, 5, 8, 13, 21)
       // You can append any collection with the ++= operator
     b.trimEnd(5)
       // ArrayBuffer(1, 1, 2)
       // Removes the last five elements 
     #+END_SRC

   - _Adding_ or _removing_ elements at the end of an array buffer is an
     _efficient_ ("amortized constant time") operation.

   - You can also _insert_ and _remove_ elements at an arbitrary location,
     but those operations are _not as efficient_ — all elements after that
     location must be shifted.
     #+BEGIN_SRC scala
     b.insert(2, 6)
       // ArrayBuffer(1, 1, 6, 2)
       // Insert before index 2
     b.insert(2, 7, 8, 9)
       // ArrayBuffer(1, 1, 7, 8, 9, 6, 2)
       // You can insert as many elements as you like
     b.remove(2)
       // ArrayBuffer(1, 1, 8, 9, 6, 2)
     b.remove(2, 3)
       // ArrayBuffer(1, 1, 2)
       // The second parameter tells how many elements to remove 
     #+END_SRC

   - ~b.toArray~: convert ~ArrayList~ to ~Array~

** 3.3 Traversing Arrays and Array Buffers — page 33
   - ~for (i <- 0 until a.length) println(i + ": " + a(i))~
     traverses from ~0~ to ~a.length - 1~, and the ~until~ method belongs to
     ~RichInt~ class.

   - ~0 until (a.length, 2)~: it returns ~Range(0, 2, 4, ...)~
     =From Jian=: I prefer ~0 until a.length by 2~

   - Visit from the end of the array:
     ~(0 unitl a.length).reverse~

** DONE 3.4 Transforming Arrays — page 34
   CLOSED: [2017-03-31 Fri 18:27]
   - The ~for (...) yield~ comprehension creates
     _a new collection of the same type as the original collection_.

   - With /guard/ for comprehension:
     ~for (elem <- a if a % 2 == 0) yield 2 * elem~.
     /guard/ is like a filter.

   - Alternatives to the with guard version:
     #+BEGIN_SRC scala
     a.filter(_ % 2 == 0).map(2 * _)
     a filter { _ % 2 == 0 } map { 2 * _ } 
     #+END_SRC

   - Example: Given an ~ArrayBuffer~ (a sequence of integers), we want to remove
     all but the first negative number.
     #+BEGIN_SRC scala
     // Traditional (extreme) imperative way
     var first = true
     var n = a.length
     var i = 0

     while (i < n) {
       if (a(i) >= 0) i += 1
       else {
         if (first) {first = false; i += 1}
         else {a.remove(i); n -= 1}
       }
     }
     
     // Scala way
     // Because the inefficiency of `remove' from the front, use `reverse'
     
     val indexes = for(i <- 0 until a.length if a(i) < 0) yield i
     for (j <- (1 until indexes.length).reverse) a.remove(indexes(j))

     // indexes.indices.drop(1).reverse this is not safe if indexes is empty
     

     // or

     var first = false
     val indexes = for (i <- 0 until a.length if first || a(i) >= 0) yield {
       if (a(i) < 0) first = false
       i
     }

     for (j <- 0 until indexes.length) a(j) = a(indexes(j))
     a.trimEnd(a.length - indexes.length)
     #+END_SRC
     
     See Problem 8 in the Exercise of this chapter. It's more concise then these
     three methods. =TODO: How about complexity=

** 3.5 Common Algorithms — page 35
   - Example:
     #+BEGIN_SRC scala
     val b = ArrayBuffer(1, 7, 2, 9)
     val bSorted = b.sorted(_ < _)
       // b is unchanged; bSorted is ArrayBuffer(1, 2, 7, 9) 
     #+END_SRC

   - =TODO= You pass the comparison function as parameter -- See Chapter 12

   - You can sort an array, _but not an array buffer_, in place:
     #+BEGIN_SRC scala
     val a = Array(1, 7, 2, 9)
     scala.util.Sorting.quickSort(a)
       // a is now Array(1, 2, 7, 9)
     #+END_SRC

   - For the ~min~, ~max~, and ~quickSort~ methods, the element type must have a
     comparison operation. This is the case for numbers, strings, and other types
     with the ~Ordered~ /trait/.

   - Display an array or an array buffer:
     #+BEGIN_SRC scala
     // `mkString' method
     a.mkString(" and ")  // separator
       // output: "1 and 2 and 7 and 9"
     a.mkString("<", ",", ">") // prefix and suffix
       // output: "<1, 2, 7, 9>"

     // `toString' method
     a.toString
       // output: "[I@b73e5"
       // This is the useless `toString' method from Java
     b.toString
       // output: "ArrayBuffer(1, 7, 2, 9)"
       // The `toString' method reports the type, which is useful for debugging
     #+END_SRC

** 3.6 Deciphering Scaladoc — page 37
   - _NOTE_: The methods for the ~Array~ class are listed under ~ArrayOps~.
     Technically, an array is converted to an ~ArrayOps~ object before any of the
     operations is applied.

   - The ~Seq~ trait requires element access by an integer index. Think "array,
     list, or string."

** 3.7 Multidimensional Arrays — page 38
   - Like in Java, multidimensional arrays are implemented as arrays of arrays.
     For example: a two-dimensional array of ~Double~ values has the type
     ~Array[Array[Double]]~.

   - _Construct_ such an array with ~ofDim~ method:
     ~val matrix = Array.ofDim[Double](3, 4)  // Three rows, four columns~

   - To _access_ an element:
     ~matrix(row)(column) = 42~

   - You can make _ragged arrays_, with _varying_ row lengths:
     #+BEGIN_SRC scala
     val triangle = new Array[Array[Int]](10)
     for (i <- 0 until triangle.length) {
       triangle(i) = new Array[Int](i + 1)
     }
     #+END_SRC
     =TODO TEST=

** 3.8 Interoperating with Java — page 39
   - Since Scala arrays are implemented as Java arrays, you can pass them back
     and forth between Java and Scala.

   - If you call a Java method that receives or returns a ~java.util.List~,
     you could, of course, use a Java ~ArrayList~ in your Scala code -- but that
     is unattractive.

   - Instead, import the conversion methods in ~scala.collection.JavaConverters~.
     Then you can use the ~asJava~ method to convert any sequence (such as a
     Scala buffer) into a Java ~List~.

   - For example, the ~java.lang.ProcessBuilder~ class has a constructor with a
     ~List<String>~ parameter. Here is how you can call it from Scala:
     #+BEGIN_SRC scala
     import scala.collection.JavaConverters._
     import scala.collection.mutable.ArrayBuffer
     val command = ArrayBuffer("ls", "-al", "/home/cay")
     val pb = new ProcessBuilder(command.asJava)  // Scala to Java
     #+END_SRC
     The Scala buffer is wrapped into an object of a Java class that implements
     the ~java.util.List interface~.

   - Conversely, when a Java method returns a ~java.util.List~, you can convert
     it into a Buffer: =IMPORTANT=
     #+BEGIN_SRC scala
     import scala.collection.JavaConverters._
     import scala.collection.mutable.Buffer
     val cmd : Buffer[String] = pb.command().asScala    // Java to Scala
       // You can't use ArrayBuffer -- the wrapped object is only guaranteed to
       // be a Buffer
     // TODO is the () after `command' method useful???
     #+END_SRC

   - If the Java method returns a wrapped Scala buffer, then the _implicit_
     conversion unwraps the original object. In our example, ~cmd == command~.

** TODO Exercises — page 39
   #6, #7, #8
* DONE Chapter 4   Maps and Tuples
  CLOSED: [2017-03-31 Fri 22:19]
  =42 ~ 49=
  - A classic programmer's saying is, "If you can only have one data structure,
    make it a hash table." Hash tables -- or, more generally, maps -- are among
    the most versatile data structures.

  - _Highlights of the chapter are_:
    + Scala has a pleasant syntax for creating, querying, and traversing _maps_.

    + You need to choose between _mutable_ and _immutable_ maps.

    + By default, you get a _hash map_, but you can also get a _tree map_.

    + You can easily _convert_ between Scala and Java maps.

    + Tuples are useful for aggregating values. 

** DONE 4.1 Constructing a Map — page 43
   CLOSED: [2017-03-06 Mon 02:06]
   - Construct an immutable ~Map~:
     ~val scores = Map("Alice" -> 10, "Bob" -> 3, "Cindy" -> 8)~

   - Construct a mutable ~Map~:
     ~val scores = scala.collection.mutable.Map("Alice" -> 10, "Bob" -> 3, "Cindy" -> 8)~

   - Construct a blank ~Map~ (most probabily mutable):
     ~val scores = new scala.collection.mutable.HashMap[String, Int]~

   - ~->~ makes a pair (two element Tuple). The value of ~"Alice" -> 10~ is
     ~("Alice", 10)~.
     Thus, ~val scores = Map(("Alice", 10), ("Bob", 3), ("Cindy", 8))~ is also
     right.

** DONE 4.2 Accessing Map Values — page 44
   CLOSED: [2017-03-06 Mon 02:06]
   - Use ~()~ to access ~Map~ values

   - If the map doesn't contain a value for the requested key, an exception is
     thrown.

   - To check whether there is a key with the given value, use ~contains~ method

   - With default value, and avoid exception:
     ~val bobsScore = scores.getOrElse("Bob", 0)~

   - Finally, the call ~aMap.get(key)~ returns an ~Option~ object that is either
     ~Some(value_for_key)~ or ~None~. =TODO Chapter 14=

** DONE 4.3 Updating Map Values — page 45
   CLOSED: [2017-03-06 Mon 02:19]
   =For mutable map ONLY=
   - To update or add one new key/value pair:
     #+BEGIN_SRC scala
     scores("Bob") = 10
     #+END_SRC

   - To add multiple key/value pairs, use ~+=~:
     #+BEGIN_SRC scala
     scores += ("Bob" -> 10, "Fred" -> 7)
     #+END_SRC

   - To remove a key and its associated value, use ~-=~:
     #+BEGIN_SRC scala
     scores -= "Alice"
     #+END_SRC

   - _immutable_ maps can't be changed, but you can generate a new one with
     updated or added key/value pair(s):
     #+BEGIN_SRC scala
     val newScores = immu_scores + ("Bob" -> 10, "Fred" -> 7)
     #+END_SRC

   - Or update a ~var~:
     #+BEGIN_SRC scala
     var scores = // Map ...
     scores = scores + ("Bob" -> 10, "Fred" -> 7)
     scores = scores - "Alice"
     #+END_SRC

** DONE 4.4 Iterating over Maps — page 45
   CLOSED: [2017-03-06 Mon 02:27]
   - ~for ((k, v) <- map) ... /* process k and v */~

   - ~scores.keySet~ returns a ~Set~

   - ~scores.values~ returns an ~Iterable~

   - To reverse a map: ~for ((k, v) <- map) yield (v, k)~

** DONE 4.5 Sorted Maps — page 46
   CLOSED: [2017-03-06 Mon 02:38]
   - When working with a map, you need to choose an implementation:
     1. a hash table or
     2. a balanced tree.

   - By _default_, Scala gives you a _hash table_.
     You might want a _tree map_
     1. if you don't have a good hash function for the keys, or =WHY=
     2. if you need to visit the keys in sorted order.

   - Get a tree map:
     #+BEGIN_SRC scala
     val scores = scala.collection.immutable.SortedMap("Alice" -> 10,
       "Fred" -> 7, "Bob" -> 3, "Cindy" -> 8)
     #+END_SRC

   - There is no mutable tree map in Scala 2.9 =TODO: How about now 2.12?=
     Your best bet is to adapt a Java ~TreeMap~, as described in Chapter 13.
     =TODO=

   - _TIP_: If you want to visit the keys in insertion order (=??=), use a
     ~LinkedHashMap~. For example:
     #+BEGIN_SRC scala
     val months = scala.collection.mutable.LinkedHashMap("January" -> 1,
       "February" -> 2, "March" -> 3, "April" -> 4, "May" -> 5, ...) 
     #+END_SRC
     =TODO: I don't quite understand here!!!=

** DONE 4.6 Interoperating with Java — page 46
   CLOSED: [2017-03-06 Mon 03:01]
   - Java to Scala: Import ~scala.collection.JavaConverters._~ and then use
     ~asScala~ method:
     + #1
       #+BEGIN_SRC scala
       val ids = java.time.ZoneId.SHORT_IDS.asScala
       // Yields a scala.collection.mutable.Map[String, String] 
       #+END_SRC

     + #2 =TODO ???= In addition, you can get a conversion from
       ~java.util.Properties~ to a ~Map[String, String]~:
       #+BEGIN_SRC scala
       import scala.collection.JavaConversions.propertiesAsScalaMap
       val props: scala.collection.Map[String, String] = System.getProperties() 
       #+END_SRC

   - Scala to Java:
     #+BEGIN_SRC scala
     import java.awt.font.TextAttribute._ // Import keys for map below
     val attrs = Map(FAMILY -> "Serif", SIZE -> 12)
       // A Scala map with the `Any' type values
     val font = new java.awt.Font(attrs.asJava) // Expects a Java map 
     #+END_SRC

** DONE 4.7 Tuples — page 47
   CLOSED: [2017-03-06 Mon 02:45]
   - ~(1, 3.14, "Fred")~ has type ~Tuple3[Int, Double, java.lang.String]~, which
     is also written as ~(Int, Double, java.lang.String)~

   - To access:
     #+BEGIN_SRC scala
     val t = (1, 3.14, "Fred")
     val second = t._2  // Sets second to 3.14
       // You can also write t _2, but not t_2
     #+END_SRC

   - =IMPORTANT=: _Unlike_ array or string positions,
     the component positions of a _tuple_ _start with 1_, not 0.

   - To get the components of a tuple with pattern matching:
     #+BEGIN_SRC scala
     val (first, second, third) = t
     
     val (fst, snd, _) = t
     #+END_SRC

   - 
** DONE 4.8 Zipping — page 48
   CLOSED: [2017-03-06 Mon 02:52]
   - The usage of ~zip~:
     #+BEGIN_SRC scala
     val symbols = Array("<", "-", ">")
     val counts = Array(2, 10, 2)
     val pairs = symbols.zip(counts)
       // yields an array of pairs
       // Array(("<", 2), ("-", 10), (">", 2))
       

     // Iterate `pairs'
     for ((s, n) <- pairs) Console.print(s * n) // Prints <<---------->>
     #+END_SRC

   - _TIP_: The ~toMap~ method turns a collection of pairs into a map.
     ~keys.zip(values).toMap~

** DONE Exercises — page 48
   CLOSED: [2017-03-31 Fri 22:19]
   =TODO= Or look at Chapter 9 for a Scalaesque way.
   
* DONE Chapter 5   Classes
  CLOSED: [2017-03-15 Wed 00:36]
  The key points of this chapter are:
  - Fields in classes automatically come with /getters/ and /setters/.

  - You can replace a field with a custom getter/setter without changing the
    client of a class -- that is the "uniform access principle." =TODO ???=

  - Use the ~@BeanProperty~ annotation to generate the JavaBeans getXxx/setXxx
    methods. =TODO: How about Intellij??=

  - Every class has a primary constructor that is "interwoven" with the class
    definition. Its parameters turn into the fields of the class.
    _The primary constructor executes all statements in the body of the class._

  - Auxiliary constructors are optional. They are called ~this~.

** DONE 5.1 Simple Classes and Parameterless Methods — page 51
   CLOSED: [2017-03-13 Mon 23:46]
   - In Scala, a class is not declared as ~public~ (Java requires ~public~).
     A Scala source file can contain multiple classes, and all of them have
     ~public~ visibility.

   - ~new~

   - =Recommended Style= It is considered good style
     1. to _use_ ~()~ for a _mutator method_ (a method that changes the object
        state), and
     2. to _drop_ the ~()~ for an _accessor method_ (a method that does not
        change the object state).

   - You can _enforce_ this style by declaring _accessor methods_ without ~()~,
     and then you _MUST_ call this method without ~()~.

** DONE 5.2 Properties with Getters and Setters — page 52
   CLOSED: [2017-03-11 Sat 16:55]
   - /property/: a getter/setter pair of a field A. We call it A property.
   - Getters and setters are better than ~public~ fields because they let you
     start with simple get/set semantics and evolve them as needed, such as
     provide a gurad to prevent something happen.
     #+BEGIN_SRC java
     public class Person { // This is Java
       private int age;

       public int getAge() {
         return age;
       }

       public void setAge(int newValue) {
         if (newValue > age) this.age = newValue;
       }
     }
     #+END_SRC

   - Scala provides getter and setter methods for _every_ field. We define a
     public field:
     #+BEGIN_SRC scala
     class Person {
       var age = 0
     }
     #+END_SRC
     Scala generates a class for the JVM with
     1. a ~private age~ field and
     2. getter and setter methods.
     3. These methods are _public_ because we did not declare ~age~ as _private_.
        (For a _private_ field, the getter and setter methods are _private_.)

   - For the code above, the getter and setter methods are called ~age~ and
     ~age_=~. For example:
     #+BEGIN_SRC scala
     println(fred.age)  // Calls the method fred.age()
     fred.age = 21  // Call fred.age_=(21)
     #+END_SRC

   - _NOTE_: To see these methods with your own eyes, compile the ~Person~ class
     and then look at the bytecode with =javap=:
     #+BEGIN_SRC bash
     #$
     scalac Person.scala

     #$
     scala -private Person
     # Compiled from "Person.scala"
     # public class Person extends java.lang.Object implements scala.ScalaObject{
     #   private int age;
     #   public int age();
     #   public void age_$eq(int);
     #   public Person();
     # }
     
     # (The = symbol is translated to $eq because the JVM does not allow an = in
     #  a method name.) 
     #+END_SRC

   - _NOTE_: In Scala, the getters and setters are not named getXxx and setXxx, but
      they fulfill the same purpose. Section 5.5, “Bean Properties,” on page 57
      shows how to generate Java-style getXxx and setXxx methods, so that your
      Scala classes can interoperate with Java tools.
      =TODO=

   - You can override getter (for example, ~age~ above) and setter (for example,
     ~age_=~ above) at any time.

   - "All services offered by a module should be available through a uniform
      notation, which does not betray whether they are implemented through
      storage or through computation."
        --- /Uniform Access Principle/ formulated by Bertrand Meyer,
            the inventor of the influential Eiffel language

   - _TIP_: It may sound scary that Scala generates getter and setter methods for
     every field. But you have some control over this process.
     + If the field is private, the getter and setter are private.
     + If the field is a val, only a getter is generated.
     + If you don't want any getter or setter, declare the field as
       ~private[this]~ (see Section 5.4, "Object-Private Fields," on page 56).
       =TODO=

** DONE 5.3 Properties with Only Getters — page 55
   CLOSED: [2017-03-06 Mon 03:51]
   - Use ~val~ for a read-only property (only getter).
     Then Scala makes a ~private final~ field (in JVM) and a /getter/ method,
     but no /setter/.

   - Sometimes you may want a property will change by calling a method, but there
     is no /setter/. Then, you can do this:
     #+BEGIN_SRC scala
     class Counter {
       private var value = 0
       def increment() { value += 1 }
       def current = value // No () in declaration
         // `def' means everytime you call this, it will re-run.
     }
     #+END_SRC

   - =IMPORTANT= To summarize, you have four choices for implementing properties:
     1. ~var foo~: Scala synthesizes a getter and a setter.
     2. ~val foo~: Scala synthesizes a getter.
     3. You define methods ~foo~ (/getter/) and ~foo_=~ (/setter/).
     4. You define a method ~foo~.

   - NOTE: In Scala, you can't have a write-only property (with /setter/ and no
     /getter/). =From Jian: This means Scala designers think this is useless, but
     is this really useless?!?!=

   - _TIP_: When you see a field in a Scala class, remember that
     it is _NOT_ the same as a field in Java or C++.
     1. It is a private field together with a /getter/ (for a ~val~ field) or
     2. a /getter/ and a /setter/ (for a ~var~ field).

** DONE 5.4 Object-Private Fields — page 56
   CLOSED: [2017-03-06 Mon 04:02]
   - In Scala (as well as in Java and C++), a method can access the _private_
     fields of all objects of its class. For example:
     #+BEGIN_SRC scala
     class Counter {
       private var value = 0
       def increment() { value += 1 }
       def isLess(other : Counter) = value < other.value
       // Can access private field of other object
     } 
     #+END_SRC
     
   - /object-private/: Use the ~private[this]~ qualifier, for example:
     ~private[this] var value = 0 // Accessing someObject.value is not allowed~
     This is common in some OO languages, such as SmallTalk.

   - For an /object-private field/, _NO_ /getters/ and /setters/ are generated
     _at all_.

   - With a /class-private field/, Scala generates private /getter/ and /setter/
     methods.

   - _NOTE_: Scala allows you to grant access rights to specific classes.
     The ~private[ClassName]~
     1. =From Jian: Can I add multiple class names???=
     2. =From Jian: Can this ClassName be this class name???=
     qualifier states that only methods of the given class can access the given
     field.
     Here, the =ClassName= must be the name of the class being defined or an
     enclosing class.
     =TODO=: (See Section 5.8, "Nested Classes," on page 62 for a discussion of
     inner classes.)

     In this case, the implementation will generate auxiliary getter and setter
     methods that allow the enclosing class to access the field.
     These methods will be ~public~ because the JVM does not have a fine-grained
     access control system, and they will have implementation-dependent names.
     =RE-READ= =TODO= =IMPORTANT=

** DONE 5.5 Bean Properties _L1_ — page 57
   CLOSED: [2017-03-12 Sun 03:08]
   - The names of these automatically generated getter/setter methods are not
     what Java tools expect.

   - The JavaBeans specification defines a Java property (for example, if you
     have a field named ~foo~) as a pair of ~getFoo/setFoo~ methods(or just
     ~getFoo~ method for a read-only property).
     Many Java tools rely on this naming convetion.

   - Annotation: ~@BeanProperty~
     #+BEGIN_SRC scala
     import scala.reflect.BeanProperty

     class Person {
       @BeanProperty var name: String = _
     }
     #+END_SRC
     With the help of this annotation, four methods are generated:
     1. ~name: String~
     2. ~name_=(newValue: String): Unit~
     3. ~getName(): String~
     4. ~getName(newValue: String): Unit~

   - _NOTE_: If you define a field as a primary constructor parameter (see
     Section 5.7, “The Primary Constructor,” on page 59), and you want JavaBeans
     getters and setters, annotate the constructor parameter like this:
     ~class Person(@BeanProperty var name: String)~

   - Table 5-1 Generated Methods for Fields =TODO: RE-READ=
     |-----------------------------------+----------------------------+------------------------------------------|
     | Scala Field                       | Generated Methods          | When to Use                              |
     |-----------------------------------+----------------------------+------------------------------------------|
     | ~val name~                        | ~public name~              | To implement a property that is publicly |
     |                                   |                            | accessible and backed by a field         |
     |-----------------------------------+----------------------------+------------------------------------------|
     | ~var name~                        | above getter and ~name_=~  | as above                                 |
     |-----------------------------------+----------------------------+------------------------------------------|
     | ~@BeanProperty val name~          | ~public name~, ~getName()~ | To interoperate with JavaBeans           |
     |-----------------------------------+----------------------------+------------------------------------------|
     | ~@BeanProperty var name~          | above getter and ~name_=~, | as above                                 |
     |                                   | ~setName(...)~             |                                          |
     |-----------------------------------+----------------------------+------------------------------------------|
     | ~private val name~                | ~private name~             | To confine the field to the methods of   |
     |                                   |                            | this class, just like in Java. Use       |
     |                                   |                            | ~private~ unless you really want a       |
     |                                   |                            | public property.                         |
     |-----------------------------------+----------------------------+------------------------------------------|
     | ~private var name~                | above getter and ~name_~   | as above                                 |
     |-----------------------------------+----------------------------+------------------------------------------|
     | ~private[this] val/var name~      | none                       | To confine the field to methods invoked  |
     |                                   |                            | on the same object. Not commonly used.   |
     |-----------------------------------+----------------------------+------------------------------------------|
     | ~private[ClassName] val/var name~ | implementation-dependent   | To grant access to an enclosing class.   |
     |                                   |                            | Not commonly used.                       |
     |-----------------------------------+----------------------------+------------------------------------------|

** DONE 5.6 Auxiliary Constructors — page 58
   CLOSED: [2017-03-06 Mon 04:12]
   - Scala has
     _ONE_ /primary constructor/ and
     _ANY NUMBER_ of /auxiliary constructors/.

   - Talk the auxiliary constructors first, because they are very _similar_ to
     constructors in Java or C++, with just _TWO differences_.
     1. The auxiliary constructors are called ~this~.
        (_Better_ than the one in Java or C++,
         whoes constructors have _the same name as the class_.
         This is not so convenient if you _rename_ the class.)
     2. Each auxiliary constructor _MUST start with_ a call to
        +. _a_ previously defined /auxiliary constructor/ or
        +. the /primary constructor/.

   - Here is a class with _TWO_ /auxiliary constructors/.
     #+BEGIN_SRC scala
     class Person {
       private var name = ""
       private var age = 0

       def this(name: String) { // An auxiliary constructor
         this() // Calls primary constructor
         this.name = name
       }

       def this(name: String, age: Int) { // Another auxiliary constructor
         this(name) // Calls previous auxiliary constructor
         this.age = age
       }
     }
     #+END_SRC

   - A class for which you DON'T define a primary constructor _HAS_ a
     primary constructor _with no arguments_.

   - You can construct objects of this ~Person~ class in three ways:
     #+BEGIN_SRC scala
     val p1 = new Person // Primary constructor
     val p2 = new Person("Fred") // First auxiliary constructor
     val p3 = new Person("Fred", 42) // Second auxiliary constructor
     #+END_SRC

** DONE 5.7 The Primary Constructor — page 59
   CLOSED: [2017-03-13 Mon 23:07]
   - In Scala, every class has a primary constructor. The primary constructor
     1. _is NOT_ defined with a ~this~ method.
     2. _is_ interwoven with the class definition.

   - The parameters of the primary constructor are placed immediately after the
     class name. For example:
     #+BEGIN_SRC scala
     class Person(val name: String, val age: Int) {
       // ...
     } 
     #+END_SRC

     The Java equivalence:
     #+BEGIN_SRC java
     public class Person { // This is Java
       private String name;
       private int age;
       public Person(String name, int age) {
         this.name = name;
         this.age = age;
       }
       public String name() { return this.name; }
       public int age() { return this.age; }
       // ...
     } 
     #+END_SRC

   - The primary constructor executes all statements in the class definition. For
     example, in the following class
     #+BEGIN_SRC scala
     class Person(val name: String, val age: Int) {
       println("Just constructed another person")
       def description = name + " is " + age + " years old"
     } 
     #+END_SRC

     This feature is useful when you need to configure a field during construc-
     tion.
     For example:
     #+BEGIN_SRC scala
     class MyProg {
       private val props = new Properties
       props.load(new FileReader("myprog.properties"))
         // The statement above is a part of the primary constructor
         //...
     } 
     #+END_SRC

   - _NOTE_: If there are _no parameters_ after the class name, then the class
     has a primary constructor with no parameters.
       That constructor simply executes all statements in the body of the class.

   - _TIP_: You can often _Eliminate_ /auxiliary constructors/ by using
     _default arguments_ in the primary constructor. For example:
     ~class Person(val name: String = "", val age: Int = 0)~

   - =IMPORTANT= Table 5–1 Generated Methods for Fields

   - Primary constructor parameters can have any of the forms in Table 5–1.

   - Construction parameters can also be regular method parameters, without ~val~
     or ~var~. How these parameters are processed depends on their usage inside
     the class.
     + If a parameter _WITHOUT_ ~val~ or ~var~ is _used inside_ at least one
       method, it becomes a field. For example,
       #+BEGIN_SRC scala
       class Person(name: String, age: Int) {
         def description = name + " is " + age + " years old"
       }
       #+END_SRC
       declares and initializes _immutable_ fields ~name~ and ~age~ that are
       _object-private_ (is the equivalent of a ~private[this] val~ field).

     + Otherwise, the parameter is not saved as a field. It's just a regular
       parameter that can be accessed in the code of the primary constructor.
       (Strictly speaking, this is an implementation-specific optimization.)
       =TODO ??????=

   - Table 5–2 Fields and Methods Generated for Primary Constructor Parameters =IMPORTANT=
     |--------------------------------------+--------------------------------------|
     | Primary Constructor Parameter        | Generated Field/Methods              |
     |--------------------------------------+--------------------------------------|
     | ~name: String~                       | object-private field, or no field    |
     |                                      | if no method uses ~name~             |
     |--------------------------------------+--------------------------------------|
     | ~private val/var name: String~       | private field, private getter/setter |
     |--------------------------------------+--------------------------------------|
     | ~val/var name: String~               | private field, public getter/setter  |
     |--------------------------------------+--------------------------------------|
     | ~@BeanProperty val/var name: String~ | private field, public Scala and      |
     |                                      | JavaBeans getters/setters            |
     |--------------------------------------+--------------------------------------|

   - If you find the primary constructor notation confusing, you don't need to
     use it. Just provide one or more auxiliary constructors in the usual way,
     but remember to call ~this()~ if you don't chain to another auxiliary
     constructor. 
     =From Jian: CONFUSING NOW=

   - Martin Odersky suggests to think about it this way: In Scala, classes take
     parameters, just like methods do.

   - _TIP_: When reading a Scala class, you need to disentangle the two. For
     example, when you see
     #+BEGIN_SRC scala
     class Person(val name: String) {
       var age = 0
       def description = name + " is " + age + " years old"
     }
     #+END_SRC
     take this definition apart into a class definition:
     #+BEGIN_SRC scala
     class Person(val name: String) {
       var age
       def description = name + " is " + age + " years old"
                         // not be evaluated
     }
     #+END_SRC
     and a constructor definition:
     #+BEGIN_SRC scala
           Person(    name: String) {
           age = 0
                                                           
     }
     #+END_SRC

   - Create a primary constructor, which can't be touched by the user (only used
     by auxiliary constructors.
     #+BEGIN_SRC scala
     class Person private(val id: Int) {
       // ...   
     }
     #+END_SRC

** DONE 5.8 Nested Classes _L1_ — page 62
   CLOSED: [2017-03-13 Mon 23:46]
   - Example:
     #+BEGIN_SRC scala
     import scala.collection.mutable.ArrayBuffer

     class Network {
       class Member(val name: String) {
         val contacts = new ArrayBuffer[Member]
       }

       private val members = new ArrayBuffer[Member]

       def join(name: String) = {
         val m = new Member(name)
         members += m
         m
       }
     }
     #+END_SRC

   - How to use the classes above: 
     #+BEGIN_SRC scala
     val chatter = new Network
     val myFace = new Network
     #+END_SRC
     Here each instance has its own class ~Member~, just like each instance has
     its own field ~members~.
       That is, ~chatter.Member~ and ~myFace.Member~ are different classes.

   - _NOTE_:
     1. This is different from Java, where _an inner class belongs to the outer
        class_.

     2. The Scala approach is _more regular_.
        For example, to make a new inner object,
        + In Scala: ~new chatter.Member~
        + In Java: ~chatter.new Member()~

   - If you don't want the way metioned above of using inner class, you can:
     1. You can move the ~Member~ type somewhere else.
        A good place would be the ~Network~ _companion object_.
        (=TODO=: Companion objects are described in Chapter 6.)
        #+BEGIN_SRC scala
        object Network {
          class Member(val name: String) {
            val contacts = new ArrayBuffer[Member]
          }
        }

        class Network {
          private val members = new ArrayBuffer[Network.Member]
          // ...
        } 
        #+END_SRC

     2. Alternatively, you can use a /type projection/ ~Network#Member~, which
        means "a Member of any Network." For example,
        #+BEGIN_SRC scala
        class Network {
          class Member(val name: String) {
            val contacts = new ArrayBuffer[Network#Member]
          }
          // ...
        }
        #+END_SRC
          The fine-grained "inner class per object" feature in some places of
        your program, but not everywhere.
        =TODO= See Chapter 18 for more information about type projections.

   - _NOTE_:
     1. In a nested class, you can access the this reference of the enclosing
        class as ~EnclosingClass.this~, _like in Java_.

     2. If you like, you can establish an _alias_ for that reference with the
        following syntax:
        #+BEGIN_SRC scala
        class Network(val name: String) { outer =>
          class Member(val name: String) {
            // ...
            def description = name + " inside " + outer.name
          }
        }
        #+END_SRC
        The class ~Network { outer =>~ syntax makes the variable =outer= refer to
        ~Network.this~. You can choose any name for this variable. The name self
        is common, but perhaps confusing when used with nested classes.

        =TODO=: This syntax is related to the “self type” syntax that you will
                see in Chapter 18.

** DONE Exercises — page 65
   CLOSED: [2017-03-15 Wed 00:36]
   - 9 =TODO=

* DONE Chapter 6   Objects
  CLOSED: [2017-04-01 Sat 05:19]
  - Use Objects
    + when you need a class with a single instance, or
    + when you want to find a home for miscellaneous values or functions.

  - The key points of this chapter are:
    + Use /objects/ for singletons and utility methods.
    + A /class/ can have a /companion object/ with the same name.
    + /Objects/ can extend /classes/ or /traits/.
    + The ~apply~ method of an object is usually used for constructing new
      instances of the companion class (without using ~new~).
    + To _avoid_ the ~main~ method, use an ~object~ that extends the ~App~ trait.
    + You can implement enumerations by extending the ~Enumeration~ object.

** DONE 6.1 /Singletons/ — page 67
   CLOSED: [2017-03-06 Mon 05:47]
   - Scala has _NO_ /static methods/ or /fields/.
     Instead, you use the object construct.

   - An object defines a _single instance of a class_ with the features that you
     want.

   - For example:
     #+BEGIN_SRC scala
     object Accounts {
       private var lastNumber = 0
       def newUniqueNumber() = { lastNumber += 1; lastNumber }
     } 
     #+END_SRC
     When you need a new unique account number in your application, call
     ~Accounts.newUniqueNumber()~.

   - The constructor of an /object/ is executed when the object is first used.
     =When to construct=

   - An /object/ can have essentially all the features of a class.
     There is just _one exception_: You CANNOT provide constructor parameters.

   - You use an object in Scala whenever you would have used a singleton object in
     Java or C++:
     + As a home for utility functions or constants
     + When a single immutable instance can be shared efficiently
     + When a single instance is required to coordinate some service (the
       singleton design pattern) =TODO ???=

   - _NOTE_: Many people view the singleton design pattern with disdain. =TODO WHY???=
     Scala gives you the tools for both good and bad design, and it is up to you
     to use them wisely. 

** DONE 6.2 /Companion Objects/ — page 68
   CLOSED: [2017-04-01 Sat 02:16]
   - The /class/ and /its companion object/ can access _each other's_ private
     features.
     _They must be located in the same source file_.

   - _Note_:
     The companion object of a class is _accessible_, but it is _NOT in scope_.
     What does this mean??? =TODO= =DESIGN RATIONAL???=
     A: Use companion object method in class through ~ClassName.method~, rather
        than ~method~ or ~this.method~.

   - /paste mode/ of the REPL: type =:paste=, input, and type <Ctrl+D> to quit
     this mode.

   - In the REPL, you _MUST_ define the /class/ and the /companion object/ toge-
     ther in /paste mode/.

** DONE 6.3 /Objects/ Extending a /Class/ or /Trait/ — page 69
   CLOSED: [2017-04-01 Sat 02:23]
   - An /object/ can extend a /class/ and/or one or more /traits/.
       The result is an /object/ of a /class/ that extends the given /class/
     and/or /traits/, and in addition has all of the features specified in the
     /object/ definition.

   - One useful application is to specify default objects that can be shared.
     For example,
     #+BEGIN_SRC scala
     abstract class UndoableAction(val description: String) {
       def undo(): Unit
       def redo(): Unit
     } 
     
     object DoNothingAction extends UndoableAction("Do nothing") {
       override def undo() {}
       override def redo() {}
     }
     
     // "open" and "save" are not yet implemented.
     // DoNothingAction here is a place holder with proper type.
     val actions = Map("open" -> DoNothingAction, "save" -> DoNothingAction, ...)
     #+END_SRC
** DONE 6.4 The ~apply~ Method — page 69
   CLOSED: [2017-04-01 Sat 02:38]
   - ~apply~ is usually used to provide a construction interface to simplify the
     creation of instances (usually without ~new~).
       Though, ~apply~ is not always used to do this.

   - _Caution_:
     Difference between ~Array(100)~ and ~new Array(100)~:
     + ~Array(100)~ create an ~Array[Int]~ with one ~Int~ type element =100=.
     + ~new Array(100)~ create an ~Array[Nothing]~ with 100 ~null~ elements.

** DONE 6.5 Application Objects — page 70
   CLOSED: [2017-04-01 Sat 02:46]
   - _Each_ Scala program _MUST_ start with an /object/'s ~main~ method of type
     ~Array[String] => Unit~.

   - _Instead of_ providing a ~main~ method for your application, you can ~extend~
     the ~App~ trait and place the program code into the constructor body:
     #+BEGIN_SRC scala
     object Hello extends App {
       println("Hello, World!")
     }
     #+END_SRC
     + Get the command line arguments from the ~args~ property:
       #+BEGIN_SRC scala
       object Hello extends App {
         if (args.length > 0) println("Hello, " + args(0))
         else println("Hello, World!")
       }
       #+END_SRC

   - If you invoke the application with the ~scala.time~ option set,
     then the elapsed time is displayed when the program exits.
     #+BEGIN_SRC bash
     # $
     scalac Hello.scala
     
     # $
     scala -Dscala.time Hello Fred
     # output and info displayed #
     #
     # Hello, Fred
     # [total 4ms]
     #+END_SRC

   - _NOTE_:
     + ~Application~ trait (deprecated): Older versions of Scala had it for the
       same purpose of ~App~.
       That trait carried out the program's action _in the static initializer_,
       which is _NOT optimized_ by the just-in-time compiler.

     + Use the ~App~ trait instead.

** DONE 6.6 Enumerations — page 71
   CLOSED: [2017-04-01 Sat 03:19]
   - Scala does _NOT_ have /enumerated types/.  =Design Rational???= =TODO=
     Scala standard library provides an ~Enumeration~ helper class to produce enumerations.

   - Example:
     #+BEGIN_SRC scala
     Object TrafficLightColor extends Enumeration {
       val Red, Yellow, Green = Value
     }
     #+END_SRC
     ~Value~ is a method to initialize each of them (left enumeration values).

     The above code is a shortcut for
     #+BEGIN_SRC scala
     Object TrafficLightColor extends Enumeration {
       val Red = Value
       val Yellow = Value
       val Green = Value
     }
     #+END_SRC
     Each call to the ~Value~ method returns a new instance of an inner class,
     also called ~Value~.

   - Alternatively, you can pass _IDs_, _names_, or _both_ to the ~Value~ method:
     ~val Red = Value(0, "Stop")~
     If _NOT_ specified,
     + the ID is one more than the previous assigned one, starting with zero.
     + the default name is the field name.

   - Usage:
     1. ~TrafficLightColor.Red~
     2. ~import TrafficLightColor._~

   - _The type of the enumeration is_ ~TrafficLightColor.Value~
     ~TrafficLightColor~ is the type of the object holding the values, _NOT_ the
     type of the enumeration values.

   - Some suggestion:
     #+BEGIN_SRC scala
     object TrafficLightColor extends Enumeration {
       type TrafficLightColor = Value
       val Red, Yellow, Green = Value
     } 
     #+END_SRC
     This is only an improvement if you use Usage 2 ~import TrafficLightColor._~
     method.
     =FROM JIAN= If not doing this, all imported different enumerated types have
     the same type ~Value~. This is confusing for people, I think compiler
     knows the whole project, and won't get confused.

   - ~id~: this method is used to get the ID.

   - ~toString~: this method is used to get the name. Thus, this method is
     especially useful for enumerated values, though this method exist in
     almost every other classes.

   - _Look up_ through ID or name.
     #+BEGIN_SRC scala
     TrafficLightColor(0)
     TrafficLightColor.withName("Red")
     #+END_SRC

** DONE Exercises — page 73
   CLOSED: [2017-04-01 Sat 05:19]

* TODO Chpater 7   Packages and Imports
  - The key points of this chapter are:
    + Packages nest just like /inner classes/.

    + Package paths are _NOT_ absolute.

    + A chain ~x.y.z~ in a package clause leaves the intermediate packages ~x~
      and ~x.y~ _INVISIBLE_.

    + Package statements without braces at the top of the file extend to the
      entire file.

    + A package object can hold
      * functions
      * variables

    + import statements can
      * import packages
      * classes
      * objects

    + Import statements can be _anywhere_.

    + Import statements can _rename_ and _hide_ members.

    + ~java.lang~, ~scala~, and ~Predef~ are always imported.

** DONE 7.1 Packages — page 76
   CLOSED: [2017-03-08 Wed 00:12]
   - Packages in Scala fulfill the SAME PURPOSE AS
     * _packages in Java_
       or
     * _namespaces in C++_:

     To manage names in a large program.

   - To add items to a package, you can include them in package statements, such
     as:
     #+BEGIN_SRC scala
     // Assume this is the content of a file "Employee.scala"
     package com {
       package horstmann {
         package impatient {
           class Employee
           // ...
         }
       }
     }
     #+END_SRC
     Then the class name ~Employee~ can be accessed anywhere as
     ~com.horstmann.impatient.Employee~.

   - _Unlike_ the definition of an /object/ or a /class/,
     a /package/ can be _defined in multiple files_.
     #+BEGIN_SRC scala
     // Assume this is the content of a file "Manager.scala"
     package com {
       package horstmann {
         package impatient {
           class Manager
           ...
         }
       }
     }
     #+END_SRC

       Now, both ~Employee~ and ~Manager~ are can be accessed anywhere as
     ~com.horstmann.impatient.<name>~ (here name is ~Employee~ or ~Manager~).
     
   - _NOTE_: There is _NO ENFORCED_ relationship between the directory of the
     source file and the package.You don't have to put =Employee.scala= and
     =Manager.scala= into a =com/horstmann/impatient directory=.

   - Conversely, you can contribute to _more than one_ /package/ in
     _a single file_. The file =Employee.scala= can contain
     #+BEGIN_SRC scala
     package com {
       package horstmann {
         package impatient {
           class Employee
           ...
         }
       }
     }

     package org {
       package bigjava {
         class Counter
         ...
       }
     } 
     #+END_SRC

** DONE 7.2 Scope Rules — page 77
   CLOSED: [2017-03-08 Wed 00:12]
   - For example,
     #+BEGIN_SRC scala
     package com {
       package horstmann {
         object Utils {                  // define `Utils'
           def percentOf(value: Double, rate: Double) = value * rate / 100
           // ...
         }

         package impatient {
           class Employee {
             // ...
             def giveRaise(rate: scala.Double) {
               // reference `Uitls.percentOf'
               salary += Utils.percentOf(salary, rate)
             }
           }
         }
       }
     } 
     #+END_SRC

   - ~_root_~:
     If you want to use the utilities in ~scala.collection~ package, but there
     is a ~collection~ package also in the current scope, Scala will try to use
     the later one.
       To avoid this,
     INSTEAD OF USING ~collection.mutable.ArrayBuffer ...~,
     USE ~_root_.scala.collection.mutable.ArrayBuffer ...~

   - Another approach is to use "chained" package clauses, as detailed in the
     next section.

   - _NOTE_: Most programmers use complete paths for package names, without
     the ~_root_~ prefix.
     This is _safe as long as_ everyone _avoids_ names =scala=, =java=, =com=,
     =org=, and so on, for nested packages.

** DONE 7.3 Chained Package Clauses — page 79
   CLOSED: [2017-03-08 Wed 00:12]
   - A package clause can contain a "chain," or path segment, for example:
     #+BEGIN_SRC scala
     package com.horstmann.impatient {
       // Members of com and com.horstmann are not visible here
       package people {
         class Person
         ...
       }
     }
     #+END_SRC
     Such a clause _LIMITS the visible members_.
     Now a ~com.horstmann.collection~ package would _no longer be accessible as_
     ~collection~. 

** DONE 7.4 Top-of-File Notation — page 79
   CLOSED: [2017-03-08 Wed 00:19]
   - Top-of-File Notation example:
     #+BEGIN_SRC scala
     package com.horstmann.impatient
     package people

     class Person
       // ... 
     #+END_SRC

     is equivalent to

     #+BEGIN_SRC scala
     package com.horstmann.impatient {
       package people {
         class Person
           // ...
           // Until the end of the file
       }
     } 
     #+END_SRC

   - /Top-of-File notation/ is the _preferred_ notation
     _if_
       ALL the code in the file belongs to the same package
       (= one file one package)
       (which is the usual case).

   - _Note_ that in the example above,
     1. everything in the file belongs to the package
        ~com.horstmann.impatient.people~,

     2. but the package ~com.horstmann.impatient~ has also been opened up so you
        can refer to its contents.

** DONE 7.5 Package Objects — page 80
   CLOSED: [2017-03-08 Wed 01:07]
   - A package
     1. _can contain_
        + classes
        + objects
        + traits

     2. _but not_ the definitions of functions or variables.

     =IMPORTANT=
     _That's an unfortunate limitation of the Java virtual machine._

   - /Package object/ address this limitation.
     1. Every package can have _ONE_ package object.

     2. You define it in the parent package, and it has the same name as the
        child package. For example,
        #+BEGIN_SRC scala
        package com.horstmann.impatient

        package object people {
          val defaultNmae = "John Q. Public"
        }
        
        package people {
          class Person {
            var name = defaultName // A constant from the package
          }
          ...
        }
        #+END_SRC
        Note:
        + the ~defaultName~ value did _NOT_ need to be _QUALIFIED_
          because it was in the same package.

        + Elsewhere, it is accessible as
          ~com.horstmann.impatient.people.defaultName~.

   - =TODO= =JAVA= Behind the scenes,
     the package object gets compiled into a JVM class with static methods and
     fields, called ~package.class~, inside the package.
       In our example, that would be a /class/
     ~com.horstmann.impatient.people.package~ with a ~static~ field
     ~defaultName~.
     (In the JVM, you can use =package= as a class name.)

   - _naming scheme_ of /package objects/:
     It is a good idea to use the same naming scheme for source files.
     Put the package object into a file
     ~com/horstmann/impatient/people/package.scala~.
     That way, anyone who wants to add functions or variables to a package can
     find the /package object/ easily.
     =TODO= =TRY=

** DONE 7.6 Package Visibility — page 80
   CLOSED: [2017-03-08 Wed 01:24]
   - In Java, a class member that isn't declared as ~public~, ~private~, or
     ~protected~ is visible in the package containing the class. In Scala, you
     can achieve the same effect _with qualifiers_.
     #+BEGIN_SRC scala
     package com.horstmann.impatient.people

     class Person {
       private[people] def description = "A person with name " + name
       ...
     }
     #+END_SRC
     You can extend the visibility to an enclosing package with the qualifier
     ~private[impatient]~

** DONE 7.7 Imports — page 81
   CLOSED: [2017-03-08 Wed 14:01]
   - You can import all members of a package as ~import java.awt._~

   - The ~_~ in ~import java.awt._~ is the same as the ~*~ in Java
       In Scala, ~*~ is a valid character for an identifier.
     Theoretically, you can define a package ~com.horstmann.*.people~,
     _but DON'T do this!_.

   - You can also import _all members of_ a /class/ or /object/:
     #+BEGIN_SRC scala
     import java.awt.Color._
     val c1 = RED // Color.RED
     val c2 = decode("#ff0000") // Color.decode
     #+END_SRC
     This is like ~import static~ in Java. =TODO= =JAVA=

** DONE 7.8 Imports Can Be Anywhere — page 82
   CLOSED: [2017-03-08 Wed 14:04]
   - In Scala, an ~import~ statement can be anywhere.
     The scope:
       extends until the end of the enclosing block.

   - By putting the imports where they are needed,
     you can greatly reduce the potential for conflicts.

** DONE 7.9 Renaming and Hiding Members — page 82                    :ReRead:
   CLOSED: [2017-03-08 Wed 14:11]
   - /selector/: a syntax to be used to import a few members from a package.
     #+BEGIN_SRC scala
     // import two members of a package
     import java.awt.{Color, Font}

     // import and "rename" to get rid of confliction
     import java.util.{HashMap => JavaHashMap}
     import scala.collection.mutable._ 
     #+END_SRC

   - The selector ~HashMap => _~ hides a member instead of renaming it. This is
     only useful if you import others:
     #+BEGIN_SRC scala
     import java.util.{HashMap => _, _}
       // import all the members of java.util, but hide the "HashMap" from
       // java.util. With this sentence, people know "HashMap" in this code
       // will never be the one from "java.util"
     import scala.collection.mutable._
     #+END_SRC
     Now ~HashMap~ unambiguously refers to ~scala.collection.mutable.HashMap~
     since ~java.util.HashMap~ is hidden.

** DONE 7.10 Implicit Imports — page 82
   CLOSED: [2017-03-08 Wed 14:19]
   - Every Scala program implicitly starts with
     #+BEGIN_SRC scala
     import java.lang._
     import scala._
     import Predef._
     #+END_SRC

     1. As with Java programs, ~java.lang~ is always imported.

     2. Next, the scala package is imported, _but in a special way_.
        _Unlike all other_ imports,
        this one _is allowed to OVERRIDE the preceding import_.
        For example, ~scala.StringBuilder~ overrides ~java.lang.StringBuilder~
        instead of conflicting with it.

        =TODO: If a confliction happends (in the other imports), what will happen=

     3. the ~Predef~ object is imported. It contains quite a few useful
        functions.
        =Rationale=: These could equally well have been placed into the
        ~scala~ /package object/, but ~Predef~ was introduced _BEFORE_ Scala had
        /package objects/.

     4. Since the ~scala~ package is imported, you never need to write package
        name start with =scala=.

** TODO Exercises — page 83
   1. Q:
      + ~package com.horstmann.impatient~ opens ~com.horstmann.impatient~
      + ~package com; package horstmann; package impatient;~ opens
        ~com~, ~com.horstmann~, and ~com.horstmann.impatient~
   2. 

   3. Q: (=TODO= The given formula is different from the one in html version)
      #+BEGIN_SRC scala 
      package object random {
        var seed : Int = 0

        def setSeed(seedVal : Int): Unit = seed = seedVal

        def nextInt(): Int = {
          // TODO: There might be overflow problem:
          //
          // seed is `Int', and `math.pow(2, 32).longValue' is `Long' (`.IntValue'
          // is not applicable due to overflow)
          seed = (seed * 1664525 + 1013904223) % math.pow(2, 32).longValue
          seed
        }

        def nextDouble(): Double = nextInt().toDouble / Int.MaxValue.toDouble
      }
      #+END_SRC

   4. Q: This is mentioned in this chapter. This design is due to the limitation
         of JVM. If this limitation doesn't exist, add functions and variables
         to package might be a better design.

   5. Q: ~private[com] def giveRaise(rate: Double)~ means only package ~com~ can
         see this function, and the enclosing package can't.
         =TODO=: Can the inner (~com~) package members see this definition?
         =TODO=: Do a test later.

   6. Q:
      #+BEGIN_SRC scala
      // TODO: Write a Generic Version
      import java.util.{HashMap => JavaHashMap}
      import collection.mutable.{HashMap => ScalaHashMap}

      val jmap = new JavaHashMap[Int, String]
      jmap.put(1, "one")
      jmap.put(2, "one")

      val smap = new ScalaHashMap[Int, String]

      def copyJavaMapToScalaMap(jmp: JavaHashMap[Int, String], smp: ScalaHashMap[Int, String]): Unit = {
        import collection.JavaConverters._
        for ((k, v) <- jmp.asScala) smp += (k -> v)
      }
      #+END_SRC

   7. Q:
   8. Q:
   9. Q:
   10. Q:
   
* TODO Chapter 8   Inheritance
  - The highlights are:
    + The ~extends~ and ~final~ keywords are _as in Java_.
    + You must use ~override~ when you _override a method_.
    + _ONLY_ the primary constructor can call the primary superclass constructor.
    + You can override fields.
** DONE 8.1 Extending a Class — page 87
   CLOSED: [2017-03-15 Wed 01:30]
   - ~extends~ example:
     #+BEGIN_SRC scala
     class Employee extends Person {
       var salary: Double = 0.0
     }
     #+END_SRC

   - About ~final~:
     1. _As in Java_, you can declare a _class_ ~final~ so that it cannot be
        extended.
     2. _Unlike Java_, you can also declare individual _methods or fields_
        ~final~ so that they cannot be overridden.
     3. =TODO=: (See Section 8.6, “Overriding Fields,” on page 91 for
                 overriding fields.)

** DONE 8.2 Overriding Methods — page 88
   CLOSED: [2017-03-15 Wed 01:30]
   - ~override~

   - /The fragile base class problem/: a _change in the superclass_ CANNOT be
     verified _without_ looking at _all the subclasses_.

   - The ~override~ modifier can give useful error messages in a number of common
     situations, such as:
     + When you _misspell_ the name of the method that you are overriding
     + When you accidentally provide a _wrong parameter type_ in the overriding
       method
     + When you introduce a _new method in a superclass_ that _clashes_ with a
       _subclass method_ =/The fragile base class problem/=

   - _NOTE_:
     1. In Scala, you can solve /the fragile base class problem/ with ~override~
        as mentioned in the last case above.

     2. In Java, the suggested method to "solve" /the fragile base class problem/
        is to always use ~final~ unless methods are explicitly designed to be
        overridden.
          This is sounds good in theory, but programmers hate this. That's why
        Java eventually introduced an optional ~@Overrides~ annotation.

   - ~super~: invoke a superclass method:
     #+BEGIN_SRC scala
     public class Employee extends Person {
       // ...
       override def toString = super.toString + "[salary=" + salary + "]"
     }
     #+END_SRC

** DONE 8.3 Type Checks and Casts — page 89
   CLOSED: [2017-03-15 Wed 03:07]
   - ~isInstanceOf~: test

   - ~asInstanceOf~: convert a reference to a subclass reference, if
                     ~isInstanceOf~ test succeeds.
   - Example:
     #+BEGIN_SRC scala
     if (p.isInstanceOf[Employee]) {
       val s = p.asInstanceOf[Employee] // s has type Employee
     }
     #+END_SRC
     + The ~p.isInstanceOf[Employee]~ test succeeds if ~p~ refers to an object
       of class ~Employee~ or _its subclass_ (such as ~Manager~).

     + If p is ~null~, then ~p.isInstanceOf[Employee]~ returns ~false~ and
       ~p.asInstanceOf[Employee]~ returns ~null~.

     + If ~p~ is not an Employee, then ~p.asInstanceOf[Employee]~ throws an
       exception.

   - ~classOf~ (defined in the ~scala.Predef~): If you want to test whether ~p~
     refers to a ~Employee~ object, but not a subclass, use
     #+BEGIN_SRC scala
     if (p.getClass == classOf[Employee])
     #+END_SRC

   - Table 8-1 Type Checks and Casts in Scala and Java
     | Scala                 | Java               |
     |-----------------------+--------------------|
     | ~obj.inInstanceOf[C]~ | ~obj instanceof C~ |
     | ~obj.asInstanceOf[C]~ | ~(C) obj~          |
     | ~classOf[C]~          | ~C.class~          |

   - _HOWEVER_, _pattern matching is usually better_. For example,
     #+BEGIN_SRC scala
     p match {
       case s: Employee => ... // Process s as a Employee
       case _ => ... // p wasn't a Employee
     #+END_SRC
     =TODO= See Chapter 14 for more information

** DONE 8.4 Protected Fields and Methods — page 90
   CLOSED: [2017-03-15 Wed 03:12]
   - ~protected~: as in Java and C++, the ~protected~ field can be accessed from
     any subclasses _ONLY_.

   - _UNLIKE in Java_, a ~protected~ member is _not_ visible throughout the
     package to which the class belongs.
     =TODO= See Chapter 7, use package modifier to get the visibility

   - ~protected[this]~ restricts access to the current object.

** DONE 8.5 Superclass Construction — page 90
   CLOSED: [2017-03-15 Wed 03:31]
   - An auxiliary constructor can _NEVER_ invoke a superclass constructor
     directly.
       _Only_ the primary constructor can call a superclass constructor.

   - Example:
     #+BEGIN_SRC scala
     class Employee(name: String, age: Int, val salary : Double) extends Person(name, age)
     #+END_SRC
     defines a subclass
     #+BEGIN_SRC scala
     class Employee(...) extends Person(...)

     // and a primary constrctor that calls the superclass constructor

     ... Employee(name: String, age: Int, val salary : Double) ... Person(name, age)
     #+END_SRC

   - Example of Java equivalent:
     #+BEGIN_SRC java
     public class Employee extends Person { // Java
       private double salary;
       public Employee(String name, int age, double salary) {
         super(name, age);
         this.salary = salary;
       }
     }
     #+END_SRC

   - _NOTE_: In a Scala constructor, you can _never call super(params)_, as you
     would in Java, to call the superclass constructor.

   - A Scala class can extend a Java class.
     Its primary constructor must invoke one of the constructors of the Java
     superclass. For example,
     #+BEGIN_SRC scala
     class Square(x: Int, y: Int, width: Int) extends
       java.awt.Rectangle(x, y, width, width)
     #+END_SRC
     =TODO= Jian knows nothing about Java.

** DONE 8.6 Overriding Fields — page 91
   CLOSED: [2017-03-15 Wed 03:54]
   - Note taken on [2017-03-15 Wed 03:54]
   - You can override a ~val~ (or a _parameterless_ ~def~) with
     another ~val~ field of the _same name_.

   - The subclass has
     + a _private field_ and
     + a _public getter_, which overrides the _superclass getter (or method)_.

   - For example,
     #+BEGIN_SRC scala
     class Person(val name: String) {
       override def toString = getClass.getName + "[name=" + name + "]"
     }

     class SecretAgent(codename: String) extends Person(codename) {
       override val name = "secret" // Don't want to reveal name ...
       override val toString = "secret"  // ...or class name
     }
     #+END_SRC

   - A more common example,
     #+BEGIN_SRC scala
     abstract class Person { // See Section 8.8 for abstract classes
       def id: Int // Each person has an ID that is computed in some way
       ...
     }
     
     class Student(override val id: Int) extends Person
       // A student ID is simply provided in the constructor
     #+END_SRC

   - Table 8-2 Overriding ~val~, ~def~, and ~var~ =TODO=
     |----------------+--------------------------+--------------+----------------------------|
     |                | with ~val~               | with ~def~   | with ~var~                 |
     |----------------+--------------------------+--------------+----------------------------|
     | Override ~val~ | + Subclass has a         | Error        | Error                      |
     |                | ~private~ field.         |              |                            |
     |                |                          |              |                            |
     |                |                          |              |                            |
     |                | + Getter overrides       |              |                            |
     |                | the superclass ~getter~. |              |                            |
     |----------------+--------------------------+--------------+----------------------------|
     | Override ~val~ | + Subclass has a         | Like in Java | A ~var~ can override a     |
     |                | ~private~ field.         |              | ~getter~ / ~setter~ pair.  |
     |                |                          |              | Overriding just a ~getter~ |
     |                | + Getter overrides the   |              | is an error.               |
     |                | superclass method.       |              |                            |
     |----------------+--------------------------+--------------+----------------------------|
     | Override ~var~ | Error                    | Error        | Only if the superclass     |
     |                |                          |              | ~var~ is _abstract_        |
     |                |                          |              |                            |
     |                |                          |              | _TODO_ 8.8 see Section     |
     |----------------+--------------------------+--------------+----------------------------|

   - _NOTE_
     + In Chapter 5, I said that it's OK to use a ~var~ because you can always
       change your mind and reimplement it as a ~getter/setter~ pair.

     + However, the programmers extending your class _do not have that choice_.
       They _cannot override_ a ~var~ with a ~getter/setter~ pair.
       In other words, if you provide a ~var~, all subclasses are stuck with it.

** TODO 8.7 Anonymous Subclasses — page 93
   - As in Java, you make an instance of an /anonymous subclass/
     if you include
     a block with
     + _definitions_ or
     + _overrides_,
     such as
     #+BEGIN_SRC scala
     val alien = new Person("Fred") {
       def greeting = "Greetings, Earthling! My name is Fred."
     }
     #+END_SRC

   - Technically, this creates _an object of a structural type_ --
     =TODO= see Chapter 18 for details.
       The type is denoted as ~Person{def greeting: String}~. You can use this
     type as a /parameter type/:
     #+BEGIN_SRC scala
     def meet(p: Person{def greeting: String}) {
       println(p.name + " says: " + p.greeting)
     }
     #+END_SRC

** DONE 8.8 Abstract Classes — page 93
   CLOSED: [2017-03-15 Wed 04:04]
   - ~abstract~ class as in Java. For example,
     #+BEGIN_SRC scala
     abstract class Person(val name: String) {
       def id: Int // No method body -- this is an abstract method
     }
     #+END_SRC

   - Unlike Java, you do not use the ~abstract~ method for an abstract method.
     You simply omit its body.

   - As in Java, a class with _at least one abstract method_ must be declared
     ~abstract~.

   - No ~override~ needed if the method is abstract.

** DONE 8.9 Abstract Fields — page 93
   CLOSED: [2017-03-15 Wed 04:29]
   - /abstract field/: a field without an initial value. For example,
     #+BEGIN_SRC scala
     abstract class Person {
       val id: Int
         // an abstract field with an abstract getter method
       var name: String
         // an abstract field with an abstract getter and setter methods.
     }
     #+END_SRC
     =TODO ??= The generated Java class has _no fields_

** TODO 8.10 Construction Order and Early Definitions _L3_ — page 94
   - When you
     1. ~overrride~ a ~val~ in a _subclass_ and
     2. _use_ the value in a _superclass_ constructor
     the resulting behavior is _unintuitive_.
   - =TODO=
** DONE 8.11 The Scala Inheritance Hierarchy — page 96
   CLOSED: [2017-03-15 Wed 04:50]
   - Figure 8-1 The Inheritance Hierarchy of Scala Classes

   - ~AnyVal~: The classes that correspond to the primitive types in Java,
     as well as the type Unit, _extend_ ~AnyVal~.

   - ~AnyRef~: All other classes are subclasses of the ~AnyRef~ class, which is a
     synonym for the ~Object~ class from the Java or .NET virtual machine.

   - ~Any~: Both ~AnyVal~ and ~AnyRef~ extend the ~Any~ class, the root of the
     hierarchy.

   - Methods ~isInstanceOf~, ~asInstanceOf~, and
     the methods for equality and hash codes (=TODO=: Section 8.12)
     come from ~Any~.

   - The ~AnyVal~ does _NOT_ add any methods. It is just a marker for value
     types.

   - The ~AnyRef~ class
     + adds the _monitor methods_ ~wait~ and ~notify/notifyAll~ from the ~Object~ class.
     + provides a ~synchronized~ method with a function parameter.
       This is the equivalent of a ~synchronized~ block in Java. For example,
       ~account.synchronized { account.balance += amount }~
       =TODO ???=

   - _NOTE_
     Just like in Java, I suggest you
     + _stay away from_ ~wait~, ~notify~, and ~synchronized~
     + _unless_ you have a good reason to use them instead of higher-level
       concurrency constructs.

   - _ALL_ Scala classes implement the _marker interface_ ~ScalaObject~, which
     has no methods.

   - At the other end of the hierarchy are the ~Nothing~ and ~Null~ types.

   - ~Null~ is the type whose _sole instance_ is the value ~null~.
       You can assign ~null~ to any reference, but NOT to one of the value types.
     For example, setting an ~Int~ to ~null~ is _NOT POSSIBLE_.
       _This is better than in Java_, where it would be possible to set an Integer
     wrapper to ~null~.

   - The ~Nothing~ type has no instances.
       It is occasionally useful for _generic constructs_. For example, the empty
     list ~Nil~ has type ~List[Nothing]~, which is a subtype of ~List[T]~ for any
     ~T~.

   - _CAUTION_:  =TODO re-read!!!=
     The ~Nothing~ type is _NOT AT ALL THE SAME AS_ ~void~ in Java or C++.
       In Scala, ~void~ is represented by the ~Unit~ type, the type with the
     _sole value_ ~()~.
       Note that ~Unit~ is _NOT A SUPERTYPE OF ANY OTHER TYPE_.
       However, the compiler still allows any value to be replaced by a ~()~.
     Consider
     #+BEGIN_SRC scala
     def printAny(x: Any) { println(x) }
     def printUnit(x: Unit) { println(x) }
     printAny("Hello") // Prints Hello
     printUnit("Hello")
       // Replaces "Hello" with () and calls printUnit(()), which prints ()
     #+END_SRC

** DONE 8.12 Object Equality _L1_ — page 97
   CLOSED: [2017-03-15 Wed 05:01]
   - In Scala,
     + the ~eq~ method of the ~AnyRef~ class checks whether two references refer
       to the same object.
     + The ~equals~ method in ~AnyRef~ _calls_ ~eq~.

       When you implement a class, you should consider overriding the ~equals~
     method to provide a natural notion of equality for your situation.

   - For example,
     #+BEGIN_SRC scala
     final override def equals(other: Any) = {
       val that = other.asInstanceOf[Item]
       if (that == null) false
       else description == that.description && price == that.price
     }
     #+END_SRC

   - _NOTE_:
     + We defined the method as ~final~ because it is generally very difficult to
       correctly extend equality in a subclass.
         The problem is _symmetry_.

     + You want ~a.equals(b)~ to have the same result as ~b.equals(a)~,
       _even when_ ~b~ belongs to ~a~ subclass.

   - _CAUTION_
     Be sure to define the ~equals~ method with parameter type ~Any~.
       The following would be _wrong_:
     #+BEGIN_SRC scala
     final def equals(other: Item) = { ... }
     #+END_SRC
     This is a different method that does _NOT override_ the ~equals~ method of
     ~AnyRef~.

   - When you define ~equals~, remember to define ~hashCode~ as well.
       _The hash code should be computed ONLY from the fields that you use in the
     equality check._
     In the Item example, combine the hash codes of the fields:
     #+BEGIN_SRC scala
     final override def hashCode = 13 * description.hashCode + 17 * price.hashCode
     #+END_SRC

   - _TIP_
     You are _NOT compelled_ to override ~equals~ and ~hashCode~.
     For many classes, it is appropriate to consider _distinct objects unequal_.
       For example, if you have two distinct input streams or radio buttons, you
     will _NEVER consider them equal_.

   - In an application program, you don't generally call ~eq~ or ~equals~.
     Simply use the ~==~ operator.
       For reference types, it calls ~equals~ after doing the appropriate check
     for ~null~ operands.

** TODO Exercises — page 98

* TODO Chapter 9   Files and Regular Expressions =TODO=
  _Chapter highlights_:
  + ~Source.fromFile(...).getLines.toArray~ yields _all lines of a file_.

  + ~Source.fromFile(...).mkString~ yields the file contents as _one string_.

  + To convert a string into a number, use the ~toInt~ or ~toDouble~ method.

  + Use the Java ~PrintWriter~ to write text files.

  + "regexPatternString".r is a /Regex/ object.

  + Use """...""" if your regular expression contains backslashes or quotes.

  + If a regex pattern has groups, you can extract their contents using the
    syntax ~for (regex(var1, ...,varn) <- string)~.

** DONE 9.1 Reading Lines — page 102
   CLOSED: [2017-03-24 Fri 22:01]
   - ~scala.io.Source.getLines~: read all lines from a file.
     Usage:
     #+BEGIN_SRC scala
     import scala.io.Source
     val source = Source.fromFile("myfile.txt", "UTF-8")
       // The encoding can be omited if the file uses the default platform encoding

     // #1
     val lineIterator = source.getLines

     // #2
     for (l <- lineIterator) process(l)

     // #3
     val linesArr = source.getLines.toArray
     val linesBuf = source.getLines.toBuffer
     
     // #4
     val contents = source.mkString
     #+END_SRC

   - Call ~close~ when you are done.

   - =TODO=: Python-like ~with~ is required, which does not exist in Scala today
     (2017-04-03).

** DONE 9.2 Reading Characters — page 102
   CLOSED: [2017-03-24 Fri 22:05]
   - The ~Source~ class extends ~Iterator[Char]~

   - If you want peek (~head~) at a character without consuming this iterator:
     + solution 1: call ~buffered~ method.
       #+BEGIN_SRC scala
       val source = Source.fromFile("myfile.txt", "UTF-8")
       val iter = source.buffered
       while (iter.hasNext) {
         if (iter.head satisfy some conditions)
           process iter.next
         else
           // ...
       }
       source.close()
       #+END_SRC

     + solution 2: ~val contents = source.mkString~

** DONE 9.3 Reading Tokens and Numbers — page 103
   CLOSED: [2017-03-24 Fri 22:14]
   - String objects have:
     + ~split~ method: ~val tokens = source.mkString.split("\\s+")~
     + ~toInt~ and ~toDouble~ method:
       #+BEGIN_SRC scala
       val numbers1 = for (w <- tokens) yield w.toDouble
       val numbers2 = tokens.map(_.toDouble)
       #+END_SRC

   - _TIP_: =TODO= I don't understand
     you can always use the ~java.util.Scanner~ class to process a file that
     continas a mixture of text and numbers.

   - ~readInt~, ~readDouble~, or ~readLong~: Read a number from the console
     #+BEGIN_SRC scala
     print("How old are you? ")
     val age = readInt()
       // Console is imported by default, no qualifier to ```print``` and
       // ```readInt``` requred
     #+END_SRC
     =CAUTION=:
     These methods _assume_ that the next input line contains
     _a single number, WITHOUT leading or trailing whitespace_.
     Otherwise, a ~NumberFormatException~ occurs.

** DONE 9.4 Reading from URLs and Other Sources — page 104
   CLOSED: [2017-03-24 Fri 22:17]
   - ~Source.fromURL~, ~Source.fromString~, and ~Source.stdin~
     exmaple:
     #+BEGIN_SRC scala
     val source1 = Source.fromURL("http://horstmann.com", "UTF-8")
     val source2 = Source.fromString("Hello, World!")
       // Reads from the given string -- useful for debugging
     val source3 = Source.stdin
       // Reads from standard input
     #+END_SRC

   - _CAUTION_: =TODO=
     When you read from a URL, you need to know the character set in advance,
     perhaps from an HTTP header.
     =TODO=
     See http://www.w3.org/International/O-charset for more information.
** DONE 9.5 Reading Binary Files — page 104 =Need JAVA Library=
   CLOSED: [2017-03-24 Fri 22:19]
   _Java library is required_ =TODO: RE-READ=

   #+BEGIN_SRC scala
   // Read a file into a byte array
   val file = new File(filename)
   val in = new FileInputStream(file)
   val bytes = new Array[Byte](file.length.toInt)
   in.read(bytes)
   in.close() 
   #+END_SRC

** DONE 9.6 Writing Text Files — page 104 =Need JAVA Library=
   CLOSED: [2017-03-24 Fri 22:27]
   _Scala has no built-in support for writing files._ Use ~java.io.PrintWriter~

   #+BEGIN_SRC scala
   val out = new PrintWriter("number.txt")
   for (i <- 1 to 100) out.println(i)
   out.close()
   #+END_SRC

   + Everything works as expected, except for the ~printf~ method:
     When you pass a number to ~printf~, the compiler will complain that you need
     to convert it to an ~AnyRef~.
     #+BEGIN_SRC scala
     out.printf("%6d %10.2f",
                quantity.asInstanceOf[AnyRef], price.asInstanceOf[AnyRef]) // Ugh
     // Instead, use the ```format``` method of the ```String``` class:
     out.print("%6d %10.2f".format(quantity, price))
     #+END_SRC

   + The ~printf~ method of the ~Console~ class DOES NOT suffer from this
     problem. ~printf(%6d %10.2f", quantity, price)~ for printing a message to
     the console.

** DONE 9.7 Visiting Directories — page 105 =RE-READ=
   CLOSED: [2017-04-03 Mon 18:49]
   - There are currently _NO "official" Scala classes_
     1. for visiting all files in a directory, or
     2. for recursively traversing directories.
     In this section, we discuss a couple of alternatives.

   - List all the subdirectories of a directory:
     + Recommended:
       #+BEGIN_SRC scala
       import java.io.File

       def subdirs(dir: File): Iterator[File] = {
         val children = dir.listFiles.filter(_.isDirectory)
         children.toIterator ++ children.toIterator.flatMap(subdirs _)
          // I think this _ can be ignored
       }

       for (d <- subdirs(dir)) process(d)
       #+END_SRC

     + Not recommended:
       If you use Java 7, you can adapt the ~walkFileTree~ method of the
       ~java.nio.file.Files~ class.
       #+BEGIN_SRC scala
       import java.nio.file._

       implicit def makeFileVisitor(f: (Path) => Unit) = new SimpleFileVisitor[Path] {
         override def visitFile(p: Path, attrs: attribute.BasicFileAttributes) = {
           f(p)
           FileVisitResult.CONTINUE
         }
       } 
       #+END_SRC
       That class makes use of a ~FileVisitor~ interface.
         In Scala, we generally prefer to use function objects, not interfaces,
       for specifying work (even though in this case the interface allows more
       fine-grained control—see the Javadoc for details).
         The above /implicit conversion/ adapts a function to the interface.

** DONE 9.8 Serialization — page 106
   CLOSED: [2017-04-03 Mon 19:01]
   - Here is how you declare a serializable class in Java and Scala.
     + Java:
       #+BEGIN_SRC java
       public class Person implements java.io.Serializable {
         private static final long serialVersionUID = 42L;
         ...
       }
       #+END_SRC

     + Scala:
       #+BEGIN_SRC scala
       @SerialVersionUID(42L) class Person extends Serializable
       #+END_SRC
       The ~Serializable~ trait is defined in the scala package and
       _does not require an import_.

   - _NOTE_:
     You can omit the ~@SerialVersionUID~ annotation if you are OK with the
     default ID.

   - You serialize and deserialize objects in the usual way:
     #+BEGIN_SRC scala
     val fred = new Person(...)
     import java.io._
     val out = new ObjectOutputStream(new FileOutputStream("/tmp/test.obj"))
     out.writeObject(fred)
     out.close()
     val in = new ObjectInputStream(new FileInputStream("/tmp/test.obj"))
     val savedFred = in.readObject().asInstanceOf[Person]
     #+END_SRC

   - _The Scala collections are serializable_, so you can have them as members of
     your serializable classes:
     #+BEGIN_SRC scala
     class Person extends Serializable {
       private val friends = new ArrayBuffer[Person] // OK—ArrayBuffer is serializable
       ..
     } 
     #+END_SRC
** DONE 9.9 Process Control _A2_ — page 107
   CLOSED: [2017-03-24 Fri 22:47]
   The ~scala.sys.process~ package provides utilities to interact with shell
   programs.
   + Basic Usages:
    #+BEGIN_SRC scala
    import sys.process._

    "ls -al .."! 
    val result = "ls -al .."!!
    "ls -al .." #| "grep sec"!
    "ls -al .." #> new File("output.txt")!
    "grep Scala" #< new URL("http://horstmann.com/index.html")!
    #+END_SRC
     * This library contains an implicit conversion
       from strings to ~ProcessBuilder~ objects.

     * ~!~ operator executes the ~ProcessBuilder~ objects. The reulst is the exit
       code of the executed program:
       * 0 if success
       * non-zero if fail

     * ~!!~ operator returns the output as a string

     * ~#|~ is the pipe operator.

     * ~#>~, ~#>>~, ~#<~ and ~#<<~ are redirection operators.

     * ~#&&~ and ~|&&~

   + Advanced Usages:
     Run process in a different directory, or different environment variables.
     =TODO= Construct the ~ProcessBuilder~ with the ~apply~ method of the
            ~Process~ object.
     #+BEGIN_SRC scala
     val p = Process(cmd, new File(dirName), ("LANG", "en_US"))
     #+END_SRC

** DONE 9.10 Regular Expressions — page 108
   CLOSED: [2017-03-24 Fri 23:26]
   - Use the ~r~ method to construct a ~Regex~ Object: ~val numPattern = "[0-9]+".r~

   - Raw string syntax: ~val wsnumwsPattern = """\s+[0-9]+\s+""".r~, which is
     equivalent to "\\s+[0-9]+\\s+".r

   - ~findAllIn~ method returns an iterator through all matches.

   - ~findFirstIn~ returns ~Option[String]~

   - ~findPrefixOf~ returns ~Option[String]~

   - ~replaceFirstIn~ returns ~String~

   - ~replaceAllIn~ returns ~String~

** DONE 9.11 Regular Expression Groups — page 109
   CLOSED: [2017-04-03 Mon 18:54]
   - To match the groups, use the regular expression object as an /extractor/:
     #+BEGIN_SRC scala
     val numitemPattern = "([0-9]+) ([a-z]+)".r
     val numitemPattern(num, item) = "99 bottles"
     #+END_SRC

   - To extract groups from multiple matches:
     #+BEGIN_SRC scala
     for (numitemPattern(num, item) <- numitemPattern.findAllIn("99 bottles, 98 bottles"))
       process(num, item)
     #+END_SRC
** TODO Exercises — page 109
   1. 
   2. 
   3. 
   4. 
   5. 
   6. 
   7. 
   8. 
   9. 
   10. 
* TODO Chapter 10  Traits
  - Unlike Java interfaces, Scal traits can supply default implementations for
    these features.

  - Key points of this chapter:
    + A class can implement any number of traits.
    + Traits can require that implementing classes have certain fields,
      methods, or superclasses.
    + Unlike Java interfaces, a Scala trait can provide implementations of
      methods and fields.
    + When you layer multiple traits, the order matters -- the trait whose
      methods execute first goes to the back =??? En=
      =TODO=

** DONE 10.1 Why No Multiple Inheritance? — page 111
   CLOSED: [2017-03-25 Sat 20:41]
   - =TODO= You will see in the following sections how Scala deals with the
     perils of conflicting methods and fields.

** DONE 10.2 Traits as Interfaces — page 113
   CLOSED: [2017-03-25 Sat 20:41]
   - You NEED NOT supply the ~override~ keyword when overriding an abstract
     method of a trait.

   - _NOTE_: traits can be much more similar to classes than Java interfaces.

   - Multiple ~trait~ (use ~with~):
     ~class ConsoleLogger extends Logger with Cloneable with Serializable~

** DONE 10.3 Traits with Concrete Implementations — page 114
   CLOSED: [2017-03-25 Sat 20:41]
   =CAUTION=
   There is one disadvantage of having traits with concrete behavior.

   When a trait changes, all classes that /mix in/ that trait must be
   _recompiled_.
** DONE 10.4 Objects with Traits — page 115
   CLOSED: [2017-03-25 Sat 20:41]
   - Examples:
     + Call the ~withdraw~ method of an instance of ~SavingsAccount~ will ~log~
       nothing:
       #+BEGIN_SRC scala
       trait Logged {
         def log(msg: String) {}
       }

       class SavingsAccount extends Account with Logged {
         def withdraw(amount: Double) {
           if (amount > balance) log("Insufficient funds")
           else ...
         }
         ...
       }
       #+END_SRC

     + Call the ~withdraw~ method of an instance of ~SavingsAccount~ (with proper
       traits) may log something.
       #+BEGIN_SRC scala
       trait ConsoleLogger extends Logged {
         override def log(msg: String) { println(msg) }
       } 
       
       val acct = new SavingsAccount with ConsoleLogger
       #+END_SRC
** TODO 10.5 Layered Traits — page 116
   - =TODO=

   - _NOTE_: =TODO=

   - _TIP_:
     If you need to control which trait's method is invoked, you can specify it
     in brackets: ~super[ConsoleLogger].log(...)~.
       The specified type must be an immediate supertype.
** DONE 10.6 Overriding Abstract Methods in Traits — page 117
   CLOSED: [2017-03-25 Sat 21:03]
   - ~abstract override~ is required if you override a abstract method for
     a new abstract method when you extends a trait to a new trait.
     #+BEGIN_SRC scala
     trait Logger {
     def log(msg: String) // This method is abstract
     }

     trait TimestampLogger extends Logger {
       abstract override def log(msg: String) { // Overrides an abstract method
         super.log(new java.util.Date() + " " + msg) // Is super.log defined?
       }
     }
     #+END_SRC
   - 
** DONE 10.7 Traits for Rich Interfaces — page 118
   CLOSED: [2017-03-25 Sat 21:09]
   Example:
   #+BEGIN_SRC scala
   trait Logger {
     def log(msg: String)
     def info(msg: String) { log("INFO: " + msg) }
     def warn(msg: String) { log("WARN: " + msg) }
     def severe(msg: String) { log("SEVERE: " + msg) }
   }

   class SavingsAccount extends Account with Logger {
     def withdraw(amount: Double) {
       if (amount > balance) severe("Insufficient funds")
       else ...
     }
     ...
     override def log(msg:String) { println(msg) }
   }
   #+END_SRC

** DONE 10.8 Concrete Fields in Traits — page 118
   CLOSED: [2017-03-25 Sat 21:17]
   - A field in a trait can be concrete or abstract.

   - Example:
     #+BEGIN_SRC scala
     trait ShortLogger extends Logged {
       val maxLength = 15 // A concrete field
       ...
     }

     class SavingsAccount extends Account with ConsoleLogger with ShortLogger {
       var interest = 0.0

       def withdraw(amount: Double) {
         if (amount > balance) log("Insufficient funds")
         else ...
       }
     }
     
     class Account {
       var balance = 0.0
     }
     #+END_SRC

   - ~SavingsAccount~ has field ~val maxLength = 15~ and ~var interest = 0.0~.
     It also inherits field ~var balance = 0.0~ from ~class Account~.

   - _INSIDE_:
     In the JVM, a class can only extend one superclass, so the trait fields
     can't be inherited in the same way. Instead, the trait (~maxLength~) field
     is added to the ~SavingsAccount~ class, next to the interest field.

** DONE 10.9 Abstract Fields in Traits — page 119
   CLOSED: [2017-03-25 Sat 21:25]
   - Example:
     #+BEGIN_SRC scala
     trait ShortLogger extends Logged {
       val maxLength: Int  // An abstract field
       override def log(msg: String) {
         super.log(
         if (msg.length <= maxLength) msg
         else msg.substring(0, maxLength - 3) + "...")
         // The maxLength field is used in the implementation
     } 
     
     class SavingsAccount extends Account with ConsoleLogger with ShortLogger {
       val maxLength = 20  // No override necessary
     }
     
     // construct objects on the fly
     val acct = new SavingsAccount with ConsoleLogger with ShortLogger {
       val maxLength = 20
     }
     #+END_SRC
** DONE 10.10 Trait Construction Order — page 120
   CLOSED: [2017-03-25 Sat 21:31]
   - Constructors execute in the following order: =IMPORTANT=
     + The superclass constructor is called first.
     + Trait constructors are executed after the superclass constructor but
       before the class constructor.
     + Traits are constructed left-to-right.
     + Within each trait, the parents get constructed first.
     + If multiple traits share a common parent, and that parent has already been
       constructed, it is not constructed again.
     + After all traits are constructed, the subclass is constructed.

   - _NOTE_: /linearization/ =TODO= =TODO=

** DONE 10.11 Initializing Trait Fields — page 122
   CLOSED: [2017-03-25 Sat 23:02]
   - Traits cannot have constructor parameters.
     Every trait has a single parameterless constructor.

   - _NOTE_: =IMPORTANT=
     Interestingly, the absence of constructor parameters is the
     _only technical difference_ between /traits/ and /classes/.

   - /early definition/:
     + example 1
       #+BEGIN_SRC scala
       val acct = new {  // Early definition block after ```new```
         val filename = "myapp.log"
       } with SavingsAccount with FileLogger
       #+END_SRC

     + If you need to do the same in a class, the syntax looks like this:
       #+BEGIN_SRC scala
       class SavingsAccount extends { // Early definition block after extends
         val filename = "savings.log"
       } with Account with FileLogger {
         ... // SavingsAccount implementation
       }
       #+END_SRC

     + Another alternative is to use a ~lazy~ value in the ~FileLogger~
       constructor, like this:
       #+BEGIN_SRC scala
       trait FileLogger extends Logger {
         val filename: String
         lazy val out = new PrintStream(filename)
         def log(msg: String) { out.println(msg) }  // No override needed
       }
       #+END_SRC

** DONE 10.12 Traits Extending Classes — page 123
   CLOSED: [2017-03-25 Sat 22:44]
   - =IMPORTANT= Less commonly, A trait can also extend a class.
     That class becomes a superclass of any class mixing in the trait.

   - It is OK to extends another class and this trait (which extended a class)
     as long as the "another class" is a subclass of the superclass of the trait.
     For example,
     ~class UnhappyException extends IOException with LoggedException~
       When mixing in the trait, its superclass is already present, and there is
     no need to add it.

** DONE 10.13 Self Types — page 124 =TODO RE-READ=
   CLOSED: [2017-03-25 Sat 22:50]
   - _Two methods_ of guaranteeing that the superclass is present in any class
     mixing in a trait.
     + Traits extending classes (last section)

     + /self types/:
       * A /trait/ can be be mixed into a class who is the subclass of the given
         type (~Exception~ here)
         #+BEGIN_SRC scala
         trait LoggedException extends Logged {
           this: Exception =>
             def log() { log(getMessage()) }
         }
         #+END_SRC

       * In the methods of a self typed trait, we can call any methods of the
         self type.

       * A trait with a self type is similar to a trait with a supertype.
         In both cases, it is ensured that a type is present in a class that
         mixes in the trait.

       * There are a few situations where the self type notation is more flexible
         than traits with supertypes. =TODO: Don't understand=

       * Self types can handle circular dependencies between traits. This can
         happen if you have two traits that need each other. =TODO=

       * Self types can also handle structural types -- types that _merely_
         specify the methods that a class must have, _without naming the class_.
         Here is the ~LoggedException~ using a structural type:
         #+BEGIN_SRC scala
         trait LoggedException extends Logged {
           this: { def getMessage() : String } =>
             def log() { log(getMessage()) }
         }
         #+END_SRC
         The trait can be mixed into _any class that has_ a ~getMessage~ method.

       * More detail in Chapter 18. =TODO=

** TODO 10.14 What Happens under the Hood — page 125
   - Scala needs to translate traits into classes and interfaces of the JVM.
   - =TODO=
** TODO Exercises — page 127
   1. 
   2. 
   3. 
   4. 
   5. 
   6. 
   7. 
   8. 
   9. 
   10. 
* TODO Chapter 11  Operators
  - /Operators/ are often used to build DSL.

  - /Implicit conversions/: type conversion functions that are applied
    automatically.

  - /Implicit conversions/ are another tool facilitating the creation of DSL.

  - This chapter also discusses the special methods ~apply~, ~update~, and
    ~unapply~.

  - The key points of this chapter are:
    + Identifiers contain either alphanumeric or operator characters.
    + Unary and binary operators are method calls.
    + Operator precedence depends on the first character,
      associativity on the last. =IMPORTANT=
    + The ~apply~ and ~update~ methods are called when evaluating ~expr~ (args).
    + Extractors extract tuples or sequences of values from an input. _L2_

** DONE 11.1 Identifiers — page 131 =TODO: RE-READ=
   CLOSED: [2017-03-25 Sat 23:17]
   - Choices are more than in Java:
     + Unicode characters

     + ASCII characters other than
       letters, digits, underscore (mentioned),
       parentheses ()[]{}, or
       delimiters .,:'`"

     + Unicode mathematical symbols or other symbols from the Unicode categories.
       For example, ~**~ and ~√~.

     + =IMPORTANT= Finally, you can include just about any sequence of characters
       in backquotes.
         For example, ~val `val` = 42~. This example is silly, but backquotes can
       sometimes be an "escape hatch."
         For example, in Scala, ~yield~ is a reserved word, but you may need to
       access a Java method of the same name. Backquotes to the rescue:
       ~Thread.`yield`()~.

** DONE 11.2 Infix Operators — page 132
   CLOSED: [2017-03-25 Sat 23:20]
   Any method with two parameters (one implicit, one explicit) can be used as a
   infix (binary) operator.
** DONE 11.3 Unary Operators — page 133
   CLOSED: [2017-03-26 Sun 00:20]
   Any method with one parameter (one implicit -- the object itself) can be used
   as an unary operator.
** DONE 11.4 Assignment Operators — page 133
   CLOSED: [2017-03-26 Sun 00:23]
   - An ssignment operator has the form ~operator=~, and the expression
     ~a operator= b~
     means the same as
     ~a = a operator b~

   - A few technical details:
     + ~<=~, ~>=~, and ~!=~ are NOT assignment operators.
     + An operator _starting with_ an ~=~ is never an assignment operator
       (~==~, ~===~, ~=/=~, and so on).
     + If a has a method called ~operator=~, then that method is called directly.
       =TODO ???=

** DONE 11.5 Precedence — page 134
   CLOSED: [2017-03-26 Sun 00:30]
   - _EXCEPT for assignment operators_,
     the /precedence/ is determined by the _first character_ of the operator.

   - Table of /precedence/ =IMPORTANT=
     | Highest precedence: An operator character other than those below |
     | * / %                                                            |
     | + -                                                              |
     | :                                                                |
     | < >                                                              |
     | !=                                                               |
     | &                                                                |
     | ^                                                                |
     | \bar{}                                                           |
     | A character that is not an operator character                    |
     | Lowest precedence: Assignment operators                          |

   - For example: ~+~ and ~->~ have the same precedence

   - Postfix operators have lower precedence than infix operators:
     ~a infixOp b postfixOp~ means ~(a infixOp b) postfixOp~

** DONE 11.6 Associativity — page 135
   CLOSED: [2017-03-26 Sun 00:44]
   - When you have a sequence of operators of the same precedence, the
     /associativity/ determines whether they are evaluated left-to-right or
     right-to-left

   - In Scala, all operators are left-associative
     _except_ for
     + Operators that end in a colon (:)
     + Assignment operators

   - ~2 :: Nil~ means ~Nil.::(2)~

** DONE 11.7 The apply and update Methods — page 135
   CLOSED: [2017-03-26 Sun 00:44]
   - These two methods extend the function call syntax ~f(arg1, arg2, ...)~ to
     values _other than_ functions.

   - ~apply~: If f is not a function or method, then this expression is
     equivalent to the call ~f.apply(arg1, arg2, ...)~

   - UNLESS it occurs to the left of an assignment.

   - ~update~: ~f(arg1, arg2, ...) = value~ corresponds to the call
     ~f.update(arg1, arg2, ..., value)~. For example,

     =From Jian=
     =TODO: double check= It seems this assignment syntax can only be used when
     both ~apply~ method and ~update~ method are implemented.
       Only ~update~ doesn't work. 

     #+BEGIN_SRC scala
     val scores = new scala.collection.mutable.HashMap[String, Int]

     // The whole expression means a call to ```scores.update("Bob", 100)```
     scores("Bob") = 100

     // The right side of ```=``` is a call to ```scores.apply("Bob")```
     val bobsScore = scores("Bob") 
     #+END_SRC

   - ~apply~ method is also commonly _used in companion objects_ to construct
     objects without calling ~new~. For example,
     #+BEGIN_SRC scala
     class Fraction(n: Int, d: Int) {
       ...
     }
     
     object Fraction {
       def apply(n: Int, d: Int) = new Fraction(n, d)
     }
     
     val result = Fraction(3, 4) * Fraction(2, 5)
     #+END_SRC

** DONE 11.8 Extractors — page 136
   CLOSED: [2017-03-27 Mon 04:22]
   - An /extractor/ is an object with an ~unapply~ method.

   - ~apply~ vs ~unapply~:
     + ~apply~
       1. takes construction parameters and
       2. turns them into an object.
     + ~unapply~
       1. takes an object and
       2. extracts values from it --
          usually the values from which the object was constructed.

   - The application (as the opposite of ~apply~) of the ~unapply~ method:
     #+BEGIN_SRC scala
     // The class Fraction is defined in the early sections

     // Implement unapply
     object Fraction {
       def unapply(input: Fraction) =
         if (input.den == 0) None else Some((input.num, input.den))
     }

     // application #0
     var Fraction(a, b) = Fraction(3, 4) * Fraction(2, 5)
     
     // application #1 (in pattern matching)
     ... match {
       case Fraction(a, b) => ...
     }
     #+END_SRC
     
   - The application (NOT as the opposite of ~apply~) of the ~unapply~ method:
     #+BEGIN_SRC scala
     // In this example, there is no Name class. The Name object is an extractor
     // for String objects.
     object Name {
       def unapply(input: String) = {
         val pos = input.indexOf(" ")
         if (pos == -1) None
         else Some((input.substring(0, pos), input.substring(pos + 1)))
       }
     }

     val author = "Cay Horstmann"
     val Name(first, last) = author  // Calls Name.unapply(author)
     #+END_SRC
     =I'm comfused with the comment in the code above, which is given in the book=

   - Every ~case class~ _automatically_ has ~apply~ and ~unapply~ methods.

** DONE 11.9 Extractors with One or No Arguments — page 138
   CLOSED: [2017-03-27 Mon 04:31]
   - In Scala, _there are NO tuples with one component_.

   - Thus for one argument extractors, just ~Some~ the required type, and _NO_
     tuple, as in multiple arguments extractors, required.
     #+BEGIN_SRC scala
     object Number {
       def unapply(input: String): Option[Int] =
         try {
           Some(Integer.parseInt(input.trim))
         } catch {
           case ex: NumberFormatException => None
         }
     }
     #+END_SRC

   - An extractor can just test its input without extracting any value.
     In that case, the ~unapply~ method should return a ~Boolean~.
     #+BEGIN_SRC scala
     object IsCompound {
       def unapply(input: String) = input.contains(" ")
     }

     author match {
       case Name(first, last @ Iscompound()) => ...
       case Name(first, last) => ...
     }
     #+END_SRC

** DONE 11.10 The unapplySeq Method — page 138
   CLOSED: [2017-03-27 Mon 04:38]
   ~unapplySeq~: extract an _arbitrary sequence of values_.
     Its return type is ~Option[Seq[A]]~, where ~A~ is the type of the extracted
     values.

   #+BEGIN_SRC scala
   object Name {
     def unapplySeq(input: String): Option[Seq[String]] =
       if (input.trim == "") None
       else Some(input.trim.split("\\s+"))
   }

   author match {
     case Name(first, last) => ...
     case Name(first, middle, last) => ...
     case Name(first, "van", "der", last) => ...
     case ... => ...
   }
   #+END_SRC

** TODO Exercises — page 139
   1. 
   2. 
   3. 
   4. 
   5. 
   6. 
   7. 
   8. 
   9. 
   10. 
* DONE Chapter 12  Higher-Order Functions
  CLOSED: [2017-03-29 Wed 01:14]
  - Highlights of the chapter include:
    + ... Some I already know.
    + There are syntax shortcuts that allow you to express function parameters in
      a way that is short and easy to read.
    + You can create functions that operate on blocks of code and look much like
      the built-in control statements.
** DONE 12.1 Functions as Values — page 143
   CLOSED: [2017-03-28 Tue 20:31]
   - Example:
     #+BEGIN_SRC scala
     import scala.math._
     val fun = ceil _
     #+END_SRC
     The ~_~ behind the ~ceil~ function indicates that you really meant the
     function, and you didn't just forget to supply the arguments.

   - _NOTE_: Technically, the ~_~ turns the ~ceil~ method into a function.
     In Scala, you can't manipulate methods, only functions.

** DONE 12.2 Anonymous Functions — page 144
   CLOSED: [2017-03-28 Tue 20:31]
   - If you prefer, you can enclose the function argument in _braces_ instead of
     _parentheses_, for example:
     #+BEGIN_SRC scala
     Array(3.14, 1.42, 2.0).map((x: Doulbe) => 3 * x)
     Array(3.14, 1.42, 2.0).map{(x: Doulbe) => 3 * x}
     #+END_SRC

** DONE 12.3 Functions with Function Parameters — page 145
   CLOSED: [2017-03-28 Tue 20:31]
   - /higher-order function/:
     + a function that receives a function/functions as parameter.
     + a function that produce a function as result.

** DONE 12.4 Parameter Inference — page 146
   CLOSED: [2017-03-28 Tue 20:37]
   - An anonymous function that has _just one parameter_, you can omit the ~()~
     around the parameter.

   - The ~_~ shortcut can only be applied when the data type is known.

** DONE 12.5 Useful Higher-Order Functions — page 146
   CLOSED: [2017-03-28 Tue 20:42]
   - ~foreach~: no return value.

   - ~reduceLeft~: ~(1 to 9).reduceLeft(_ * _)~ is actually
     ~((((1 * 2) * 3) * ...) * 9)~

   - ~sortWith~

** DONE 12.6 Closures — page 148
   CLOSED: [2017-03-28 Tue 20:46]
   - Java doesn't have /closures/ until versoin 8.
     Java 8 has a limited form of /closures/.
** TODO 12.7 SAM Conversions — page 149
   - Interactive with Java. =TODO=
** DONE 12.8 Currying — page 149
   CLOSED: [2017-03-28 Tue 21:54]
   - Syntax:
     #+BEGIN_SRC scala
     // Full
     def mulOneAtATime(x: Int) = (y: Int) => x * y

     // Shortcut
     def mulOneAtATime(x: Int)(y: Int) = x * y
     #+END_SRC

   - =TODO=:
     #+BEGIN_SRC scala
     val a = Array("Hello", "World")
     val b = Array("Hello", "World")
     a.corresponds(b)(_.equalsIgnoreCase(_))
     #+END_SRC

** DONE 12.9 Control Abstractions — page 150
   CLOSED: [2017-03-28 Tue 23:24]
   - In Scala, one can model a sequence of statements as a function with no
     parameters or return value:
     + Example:
       #+BEGIN_SRC scala
       def runInThread(block: () => Unit) {
         new Thread {
           override def run() { block() }
         }.start()
       }
     
       runInThread {
         () => println("Hi"); Thread.sleep(10000); println("Bye")
       }
       #+END_SRC
       Here, ~runInThread~ is like a keyword, and the anonymous function (with
       ~{}~) is like a code block after a keyword. However, there is one dis-
       advantage: ~() =>~.

     + Improvement (get rid of ~() =>~:
       #+BEGIN_SRC scala
       def runInThread(block: => Unit) {  // change 1
         new Thread {
           override def run() { block }  // change 2
         }.start()
       }
     
       runInThread {
         // change 3
         println("Hi"); Thread.sleep(10000); println("Bye")
       }
       #+END_SRC

     + Example ~until~:
       #+BEGIN_SRC scala
       def until(condition: => Boolean)(block: => Unit) {
         if (!condition) {
           block
           until(condition)(block)
         }
       } 

       var x = 10
       until (x == 0) {
         x -= 1
         println(x)
       }
       #+END_SRC
       If there is no currying, we have to write ~until(x ==0), {...})~. It is
       obviously that this is not a pretty simulation to a control flow in syntax
       aspect.

** DONE 12.10 The ~return~ Expression — page 152
   CLOSED: [2017-03-28 Tue 23:42]
   - Use ~return~ to return a value from an anonymous function to an enclosing named
     function.
     _This is useful in control abstractions._

   - Example:
     #+BEGIN_SRC scala
     def indexOf(str: String, ch: Char): Int = {
       var i = 0
       until (i == str.length) {
         if (str(i) == ch) return i
         i += 1
       }
       return -1
     }
     #+END_SRC

   - If you use ~return~ _inside a named function_, you need to specify its
     _return type_.
       For example, in the ~indexOf~ function above,
     _the compiler was NOT ABLE TO INFER that it returns an_ ~Int~.

   - ESSENCE of ~return~:
     The control flow is achieved with _a special exception_ that is thrown by
     the ~return~ expression in the anonymous function,
     + _passed_ out of the ~until~ function, and
     + _caught_ in the ~indexOf~ function.

   - _CAUTION_:
     If the exception is caught in a ~try~ block, before it is delivered to the
     named function, then the value will not be returned.

   - =Be Careful=, when use ~return~ and ~try~ together.

** DONE Exercises — page 152
   CLOSED: [2017-03-29 Wed 01:14]
* TODO Chapter 13  Collections
  - The key points of this chapter are:
    + All collections extend the ~Iterable~ trait.
    + The _THREE_ major categories of collections are:
      1. sequences;
      2. sets;
      3. maps.
    + Scala has _mutable_ and _immutable_ versions of most collections.
    + Use a ~LinkedHashSet~ to retain the insertion order or a ~SortedSet~ to
      iterate in sorted order.
    + ~+~ adds an element to an unordered collection;
      ~+:~ and ~:+~ prepend or append to a sequence;
      ~++~ concatenates two collections;
      ~-~ and ~--~ remove elements.
    + The ~Iterable~ and ~Seq~ traits have dozens of useful methods for common
      operations. Check them out before writing tedious loops.
    + _Mapping_, _folding_, and _zipping_ are useful techniques for applying a
      function or operation to the elements of a collection.
** DONE 13.1 The Main Collections Traits — page 156 =TODO: RE-READ=
   CLOSED: [2017-03-29 Wed 02:45]
   - Figure 13-1 Key traits in the Scala collections hierarchy
     + ~IndexedSeq~ extends ~Seq~, and ~Seq~ extends ~Iterable~
     + ~SortedSet~ extends ~Set~, and ~Set~ extends ~Iterable~
     + ~SortedMap~ extends ~Map~, and ~Map~ extends ~Iterable~

   - An ~Iterable~ is any collection that can yield an ~Iterator~ with which you
     can access all elements in the collection:
     #+BEGIN_SRC scala
     val coll = ... // some Iterable
     val iter = coll.iterator
     while (iter.hasNext)
     do something with iter.next()
     #+END_SRC
     This is the most basic way of traversing a collection, but there are usually
     more convenient way.

   - ~Seq~: an ordered sequence of values,
     Such as an array or list.
     An ~IndexedSeq~ allows fast random access through an integer index. For
     example,
     + an ~ArrayBuffer~ is indexed but
     + a linked list is _NOT_.

   - ~Set~: an unordered collection of values.
     ~SortedSet~: elements are always visited in sorted order.

   - ~Map~: a set of (key, value) pairs.
     ~SortedMap~: visits the entries as sorted by the keys.
     =TODO: re-do= See Chapter 4 for more information

   - This hierarchy is _similar to_ that in Java, with a couple of welcome
     improvements:
     1. ~Maps~ are a part of the hierarchy and _NOT_ a separate hierarchy.
     2. ~IndexedSeq~ is the _supertype_ of /arrays/ but _NOT_ of /lists/,
        allowing you to tell the two apart. =TODO: RE-READ=

   - _NOTE_(Explain to the above "improvements":
     _In Java_,
     both ~ArrayList~ and ~LinkedList~ implement a common ~List~ interface _===>_
     making it difficult to write efficient code when random access is preferred,
     for example when searching in a sorted sequence.
       _This was a flawed design decision_ in the original Java collections
     framework. In a later version, a marker interface ~RandomAccess~ was added
     to deal with this problem.

   - /uniform creation principle/: Each Scala collection trait or class has a
     companion object with an ~apply~ method for constructing an instance of
     the collection. For example,
     #+BEGIN_SRC scala
     Iterable(0xFF, 0xFF00, 0xFF0000)
     Set(Color.RED, Color.GREEN, Color.BLUE)
     Map(Color.RED -> 0xFF0000, Color.GREEN -> 0xFF00, Color.BLUE -> 0xFF)
     SortedSet("Hello", "World")
     #+END_SRC

** DONE 13.2 Mutable and Immutable Collections — page 157
   CLOSED: [2017-03-29 Wed 02:58]
   - For example:
     There is a ~scala.collection.mutable.Map~ and a ~scala.collection.mutable.Map~.
     Both have a common supertype ~scala.collection.Map~ (which, of course,
     contains NO mutation operations).

   - _NOTE_:
     + When you have a reference to a ~scala.collection.immutable.Map~,
       you know that _nobody can change_ the map.

     + If you have a ~scala.collection.Map~,
       then you _CAN'T_ change it,
       _but someone else might_.  =TODO: Don't understand=

   - Scala gives _a preference to immutable_ collections.
     + The companion objects in the ~scala.collection~ package
       _produce immutable_ collections. For example,
       ~scala.collection.Map("Hello" -> 42)~ is an _immutable_ map.

     + The scala package and the ~Predef~ object, which are always imported,
       have type aliases ~List~, ~Set~, and ~Map~ that _refer to the immutable_
       traits. For example,
       ~Predef.Map~ is the same as ~scala.collection.immutable.Map~.

** DONE 13.3 Sequences — page 158
   CLOSED: [2017-03-29 Wed 03:08]
   - Figure 13–2. Immutable sequences =IMPORTANT=
     + ~List~, ~Stream~, ~Stack~, and ~Queue~ extends ~Iterable~.
     + ~Vector~ extends ~IndexedSeq~, and ~IndexedSeq~ extends ~Iterable~.
     + ~Range~ extends ~IndexedSeq~, and ~IndexedSeq~ extends ~Iterable~.

   - ~Vector~: the immutable equivalent of an ArrayBuffer.

   - Detail about ~Vector~: =TODO: RE-READ=
     An indexed sequence with fast random access.
     ~Vectors~ are implemented as trees where each node has up to 32 children.
     For a vector with one million elements, one needs four layers of nodes.
       (Since 103 ≈ 210, 106 ≈ 324.) Accessing an element in such a list will
     take 4 hops, whereas in a linked list it would take an average of 500,000.

   - ~Range~: it represents an integer sequence. It doesn't save all the integers
     literally, and only the start, end, and increment.

   - Use ~to~ and ~until~ to generate a ~Range~

   - ~Stream~: read Section 13.13  =TODO=

   - Figure 13–3. Mutable sequences =IMPORTANT=
     + ~Stack~, ~Queue~, ~Priority Queue~, ~LinkedList~, and ~DoubleLinkedList~
       extends ~Iterable~.
     + ~ArrayBuffer~ extends ~IndexedSeq~, and ~IndexedSeq~ extends ~Iterable~.

** DONE 13.4 Lists — page 159
   CLOSED: [2017-03-29 Wed 03:09]
** DONE 13.5 Mutable Lists — page 160
   CLOSED: [2017-03-29 Wed 03:29]
   - =IMPORTANT=
     ~LinkedList~ is deprecated in Scala 2.11.x.
     There is a suggestion of using ~MutableList~.

   - The _mutable_ ~LinkedList~ works like the immutable List, _EXCEPT_ that
     _you can modify_ 
     + the _head_ by assigning to the ~elem~ reference, and
     + the _tail_ by assigning to the ~next~ reference.
     + _CAUTION_: Don't assign to ~head~ and ~tail~.

   - Exampe (tricky): =TODO: RE-READ=
     #+BEGIN_SRC scala
     // #1
     // Change all negative vlaues to zero.
     val lst = scala.collection.mutable.LinkedList(1, -2, 7, -9)
     var cur = lst
     while (cur != Nil) {
       if (cur.elem < 0) cur.elem = 0
       cur = cur.next
     }
     
     // #2
     // Remove every seoncd element from the list lst:
     var cur = lst
     while (cur != Nil && cur.next != Nil) {
       cur.next = cur.next.next
       cur = cur.next
     }
     #+END_SRC
     _Notice_: In #2, ~cur~ is a helper variable, the real result is the change
     of ~lst~ (the result of ~cur~ is an empty linked list, which is useless).

   - There is also a ~DoubleLinkedList~, with a mutable ~prev~ reference.

   - _CAUTION_: =TODO: Don't quite understand=
     If you want to make a list node the last node in the list, you _CANNOT_ set
     the next reference to ~Nil~.
       _Instead_, set it to ~LinkedList.empty~.
       _Do NOT_ set it to ~null~, or you will get a ~null~ pointer error when
     traversing the linked list. 

** DONE 13.6 Sets — page 161
   CLOSED: [2017-03-29 Wed 05:34]
   - By default, sets are implemented as /hash sets/ in which elements are
     organized by the value of the ~hashCode~ method.
     (In Scala, as in Java, every object has a ~hashCode~ method.)

   - A /linked hash set/ REMEMBERS the _order in which elements were inserted_.
     It keeps a linked list for this purpose.
     ~scala.collection.mutable.LinkedHashSet("Mo", "Tu", "We", "Th", "Fr")~

   - /sorted set/: this is implemented as red-black trees.
     ~scala.collection.immutable.SortedSet(1, 2, 3, 4, 5, 6)~

   - _CAUTION_: Scala 2.9 does not have a mutable sorted set. If you need one,
     you can use ~java.util.TreeSet~.

   - _NOTE_: =TODO= =IMPORTANT=
     The implementation of data structures such as hash tables and binary search
     trees, as well as the efficiency of operations on these structures, is
     standard material in an undergraduate computer science curriculum. If you
     would like a refresher, have a look at the free book at
     http://www.cs.williams.edu/javastructures/Welcome.html.

   - /bit set/: an implementation of a set of _nonnegative integers_ as a sequence
     of bits. ~BitSet~, both mutable and immutable.
     #+BEGIN_SRC scala
     val bs = collection.immutable.BitSet(1, 2 ,3, 9)
     bs(0) // false
     bs(1) // true
     bs(2) // true
     bs(4) // false
     bs(9) // true
     #+END_SRC

   - Useful methods:
     + ~contains~
     + ~subsetOf~
     + ~union~: ~|~ or ~++~
     + ~intersect~: ~&~
     + ~diff~: &~ or ~--~ (I think ~diff~ should be ~/~, WHY NOT???)

** DONE 13.7 Operators for Adding or Removing Elements — page 162
   CLOSED: [2017-03-29 Wed 05:49]
   - Table 13–1. Operators for Adding and Removing Elements
     =TODO: re-read= =IMPORTANT=

   - Generally,
     + ~+~ is used for adding an element to an _unordered collection_, and

     + ~+:~ and ~:+~ add an element to the _beginning_ or _end_ of an
       _ordered collection_.

   - ~+:~, like all operators ending in a colon, is _right-associative_, and
     that it is _a method of the RIGHT OPERAND_.

   - ~+=~ is no doubt using side effect, but it may not change the value, just
     change the reference.
     #+BEGIN_SRC scala
     val num = collection.mutable.Set(1, 2, 3)
     num += 4  // Now num has a value of collection.mutable.Set(1, 2, 3)
       // 1. num is val, you CAN'T change the reference of num;
       // 2. num refence a mutable collection, you CAN change the value of num.
     
     var numbers = Set(1, 2, 3)
     numbers += 5  // Now numbers reference a new immutable Set: Set(1, 2, 3, 5)
       // 1. numbers is var, you CAN change the reference of numbers;
       // 2. numbers refence a immutable collection, you CAN'T change the value
       //    of numbers.
     #+END_SRC

   - _NOTE_:
     For lists, you can use ~+:~ instead of ~::~ for consistency, with one
     _EXCEPTION_:
     Pattern matching (~case h::t~) does _NOT_ work with the ~+:~ operator.

** DONE 13.8 Common Methods — page 164 =TODO: RE-READ=
   CLOSED: [2017-03-29 Wed 05:54]
   - Table 13–2. Important Methods of the ~Iterable~ Trait =TODO= =IMPORTANT=
   - Table 13–3. Important Methods of the ~Seq~ Trait =TODO= =IMPORTANT=
   - /uniform return type/ principle :: methods metioned above never mutate a
        collection. They return a collection of the same type as the original.

** DONE 13.9 Mapping a Function — page 167
   CLOSED: [2017-04-02 Sun 21:01]
   - ~map~ method

   - ~flatMap~ method

   - ~collect~ method
     #+BEGIN_SRC scala
     "-3+4".collect { case '+' => 1 ; case '-' => -1 }
     #+END_SRC

   - ~foreach~ method

** DONE 13.10 Reducing, Folding, and Scanning — page 168
   CLOSED: [2017-04-02 Sun 22:14]
   - ~reduceLeft~ method
                  .
                 .
                .
               op
              /  \
             op coll(3)
            /  \
           op coll(2)
          /  \
     coll(0) coll(1)

   - ~reduceRight~ method

   - ~foldLeft~ and its equivalence ~/:~
     ~foldRight~ and its equivalence ~:\~
                  .
                   .
                    .
                    op
                   /  \
            coll(n-3) op
                     /  \
              coll(n-2) op
                       /  \
                coll(n-1) init

     #+BEGIN_SRC scala
     List(1, 7, 2, 9).foldLeft(0)(_ - _)
     (0 /: List(1, 7, 2, 9))(_ - _)
     
     List(1, 7, 2, 9).foldRight(0)(_ - _)
     (List(1, 7, 2, 9) :\ 0)(_ - _)
       // (1 - (7 - (2 - (9 - 0))))
     #+END_SRC

   - Example:
     #+BEGIN_SRC scala
     (Map[Char, Int]() /: "Mississippi") {
       (m, c) => m + (c -> (m.getOrElse(c, 0) + 1))
     } 
     #+END_SRC

   - _Note_

** DONE 13.11 Zipping — page 171
   CLOSED: [2017-04-02 Sun 22:29]
   - ~zip~

   - ~zipAll~
     #+BEGIN_SRC scala
     // Notice that 'X' is a Char, the second argument is usually set to the
     // parameter of this parameter type List[Char].
     "abc".zipAll(List(1, 2), 'X', 100)
       // List(('a', 1), ('b', 2"), ('c', 100))

     "ab".zipAll(List(1, 2, 3), 'X', 100)
       // List(('a', 1), ('b', 2), ('X', 3))
     #+END_SRC

   - ~zipWithIndex~
     #+BEGIN_SRC scala
     "Scala".zipWithIndex
       // Vector(('S', 0), ('c', 1), ('a', 2), ('l', 3), ('a', 4))
       
     "Scala".zipWithIndex.max 
      // ('l', 3)
     #+END_SRC

** DONE 13.12 Iterators — page 172
   CLOSED: [2017-04-03 Mon 00:25]
   - ~iterator~ method. This isn't as commom as in Java or C++.
     The sections before provide some other methods, and they are usually more
     easy to be used to iterate a iterable objects, even if they is not _NOT_
     iterator.

   - However, iterators are useful for collections that are expensive to
     construct fully. For example, ~Source.fromFile~ yields an iterator.

   - There are a few Iterable methods that yield an iterator, such as ~grouped~
     or ~sliding~.

   - Iterate over the elements of a /iterator/ with the ~next~ and ~hasNext~
     methods. For example,
     #+BEGIN_SRC scala
     while (iter.hasNext)
       do something with iter.next()

     // The author and I prefer the form below
     for (elem <- iter)
       do something with elem
     #+END_SRC

   - All ~Iterable~ methods listed in Section 13.8, "Common Methods," on page 164
     are available,
       _EXCEPT_ for ~head~, ~headOption~, ~last~, ~lastOption~, ~tail~, ~init~,
     ~takeRight~, and ~dropRight~.

   - Some methods such as ~map~, ~filter~, ~count~, ~sum~, or even ~length~ can
     be used, but they will _EXHAUST_ the iterator.

   - Conversions: ~toArray~, ~toIterable~, ~toSeq~, ~toSet~, or ~toMap~.

** DONE 13.13 Streams — page 173
   CLOSED: [2017-04-03 Mon 01:01]
   - _Iterators are fragile_: Each call to ~next~ mutates the iterator.
     /Streams/ _offer an immutable alternative._

   - /stream/: an immutable list in which the tail is computed lazily
     that is, only when you ask for it. For Example,
     #+BEGIN_SRC scala
     def numsFrom(n: BigInt): Stream[BigInt] = n #:: numsFrom(n + 1)
     
     val tenOrMore = numsFrom(10)
       //REPL tells that
       //  Stream[BigInt] = Stream(10, ?)
       
     tenOrMore.tail.tail.tail
      // Stream(13, ?)
     #+END_SRC

   - Stream methods are executed lazily. For example,
     #+BEGIN_SRC scala
     val squares = numsFrom(1).map(x => x * x) 
      // // yields
      // // Stream(1, ?)

     // Get more than one
     squares.take(5).force
     #+END_SRC
     ~force~

   - Usually, call ~aStreamObj.force~ is wrong. An stream object is often
     infinite, though not always.

   - /stream/ can remember its accessed elements.
     /stream/ can be revisted (not like /iterator/).
     =Jian= Kind of call-by-need.
     #+BEGIN_SRC scala
     val words = Source.fromFile("/usr/share/dict/words").getLines.toStream
     words  // Stream(A, ?)
     words(5)  // Aachen
     words  // Stream(A, A's, AOL, AOL's, Aachen, ?) 
     #+END_SRC

** DONE 13.14 Lazy Views — page 174
   CLOSED: [2017-04-03 Mon 01:13]
   - ~view~ method yields a collection on which methods are applied lazily. For
     example,
     #+BEGIN_SRC scala
     val powers = (0 until 1000).view.map(pow(10, _))
     
     powers(100)  // 1. only calculate pow(10, 100)
                  // 2. won't cache the results that were calculated
     #+END_SRC

   - Use ~force~ to _get back_ a collection of the _SAME type as the orginal_.

   - /Lazy views/ can be beneficial
     if a large collection is transformed in multiple ways, because it avoids
     building up large intermediate collections. For example:
     #+BEGIN_SRC scala
     // #1
     (0 to 1000).map(pow(10, _)).map(1 / _)
     
     // #2
     (0 to 1000).view.map(pow(10, _)).map(1 / _).force
     #+END_SRC

     + _The former_ computes a collection of the powers of 10, then applies the
       reciprocal to all of them.

     + _The latter_ computes a /view/ that _remembers both map operations_. When
       evaluation is forced, both operations are applied to each element,
       _without building an intermediate collection_.

   - _NOTE_:
     If a collection is processed in different parts of a program, you can pass
     along a view that accumulates the modifications.
     
** TODO 13.15 Interoperability with Java Collections — page 175
** DONE 13.16 Threadsafe Collections — page 177         :DEPRECATED:UseJava:
   CLOSED: [2017-04-03 Mon 01:34]
   - The Scala library provides _SIX traits_ that you can _mix in_ with
     collections to synchronize their operations (immutable collections don't
     need this):
     1. ~SynchronizedBuffer~
     2. ~SynchronizedMap~
     3. ~SynchronizedPriorityQueue~
     4. ~SynchronizedQueue~
     5. ~SynchronizedSet~
     6. ~SynchronizedStack~

   - Example:
     #+BEGIN_SRC scala
     val scores = new scala.collection.mutable.HashMap[String, Int] with
       scala.collection.mutable.SynchronizedMap[String, Int]
     #+END_SRC

   - _CAUTION_: (use the preceding example as illustration)
     + What these traits do:
       _The ~scores~ map won't be damaged_ -- any of its operations will run to
       completion before another thread can execute another operation.

     + What do These traits not do (NOT SAFE):
       _Concurrently mutating_ or _iterating over the collection_ IS NOT SAFE
       and
       will likely lead to errors in your code.

** DONE 13.17 Parallel Collections — page 178
   CLOSED: [2017-04-03 Mon 04:06]
   - The ~par~ method produces a parallel implementation of the collection.
     + Not only parallelization (when even possible),
     + but also good scheduling.

     For example, ~aCollection.par.sum~

   - =TODO=
     For arrays, buffers, hash tables, and balanced trees, the parallel
     implementations reuse the implementation of the underlying collection,
     which is very efficient.

   - To maintain the order of elemnts in a collection processed by parallel
     operations, side effect shouldn't be the operations.
     #+BEGIN_SRC scala
     // BAD
     for (i <- (0 until 100).par) print(i + " ")

     // GOOD
     for (i <- (0 until 100).par) yield i + " "
     #+END_SRC

   - _CAUTION_:
     If parallel computations mutate shared variables, the result is
     unpredictable. For example, do not update a shared counter:
     #+BEGIN_SRC scala
     // BAD!!!
     var count = 0
     for (c <- coll.par) { if (c % 2 == 0) count += 1 } // Error!
     #+END_SRC

   - The /parallel collections/ returned by the ~par~ method belong to types
     that extend the ~ParSeq~, ~ParSet~, or ~ParMap~ traits, all of which are
     _subtypes of_ ~ParIterable~.

       These are _NOT subtypes_ of ~Iterable~, so you _CANNOT_ pass a parallel
     collection to a method that expects an ~Iterable~, ~Seq~, ~Set~, or ~Map~.

   - ~ser~: convert a parallel collection back to a serial one with the method,

   - Or you can implement methods that take parameters of generic types
     ~GenIterable~, ~GenSeq~, ~GenSet~, or ~GenMap~. =TODO, DON'T UNDERSTAND=

   - _NOTE_ =TODO=
     + ~reduceLeft~ and ~reduceRight~ require that each operator is applied in
       sequence.

     + ~reduce~ won't do sequencial operation, but it requires the operation has
       /associativity/.

     + ~fold~ won't do sequencial operation, but it is not as flexible as
       ~foldLeft~ or ~foldRight~ -- both arguments (left ~_~ and right ~_~) of
       the operator must be elements. =TODO: ???=

     + ~aggregate~
       ~str.par.aggregate(Set[Char]())(_ + _, _ ++ _)~ 
       is the _equivalent_ of
       ~str.foldLeft(Set[Char]())(_ + _)~

** DONE Exercises — page 179                    :ReRead:concurrent_NOT_DONE:
   CLOSED: [2017-04-18 Tue 01:36]

* DONE Chapter 14  Pattern Matching and Case Classes
  CLOSED: [2017-03-29 Wed 22:59]
  - Pattern matching mechanism applications:
    + switch statements,
    + type inquiry, and
    + destructuring

  - The key points of this chapter are:
    + The match expression is a better switch, without fall-through.
    + If no pattern matches, a ~MatchError~ is thrown. Use the case ~_~ pattern
      to avoid that.
    + A pattern can _include an arbitrary condition_, called a /guard/.
    + You can match on the type of an expression; prefer this over
      ~isInstanceOf/asInstanceOf~.
    + You can match patterns of arrays, tuples, and case classes, and bind parts
      of the pattern to variables.
    + In a ~for~ expression, _nonmatches are silently skipped_.
    + A /case class/ is a /class/ for which the compiler automatically produces
      the methods that are needed for pattern matching.
    + The common superclass in a case class hierarchy should be ~sealed~.
    + Use the ~Option~ type for values that may or may not be present -- it is
      safer than using ~null~.
** DONE 14.1 A Better Switch — page 184
   CLOSED: [2017-03-07 Tue 00:31]
** DONE 14.2 /Guards/ — page 185
   CLOSED: [2017-03-07 Tue 00:31]
** DONE 14.3 Variables in Patterns — page 185
   CLOSED: [2017-03-07 Tue 00:31]
   - _Caution_
     Unfortunately, variable patterns can conflict with constant expressions, for
     example:
     #+BEGIN_SRC scala
     import scala.math._
     x match {
       case Pi => ...
       // ...
     }
     #+END_SRC
     The rule is that
     1. a variable (in match pattern) must start with a lowercase letter.
     2. enclose a lowercase constant in backquotes to tell the compiler it's a
        constant
        #+BEGIN_SRC scala
        import java.io.File._
        str match {
          case `pathSeparator` => ...
          ...
        }
        #+END_SRC

** DONE 14.4 Type Patterns — page 186
   CLOSED: [2017-03-07 Tue 00:31]
   - You can match on the type of an expression, for example:
     #+BEGIN_SRC scala
     obj match {
       case x: Int => x
       case s: String => Integer.parseInt(s)
       case _: BigInt => Int.MaxValue
       case _ => 0
     }
     #+END_SRC
     In Scala, this form is _preferred over_ using the ~isInstanceOf~ operator.
     ~No asInstanceOf casts are needed~!

   - =Caution=
     =TODO ??? `BigInt' has type `BitInt.type', not `Class'=
     When you match against a type, you must supply a variable name. Otherwise,
     you match the object:
     #+BEGIN_SRC scala
     obj match {
       case _: BigInt => Int.MaxValue // Matches any object of type BigInt
       case BigInt => -1 // Matches the BigInt object of type Class
     }
     #+END_SRC

   - =Caution=
     _Matches occur at runtime_, and generic types are _ERASED_ in the JVM.
     + For that reason, you _CANNOT_ make a type match for a specific ~Map~
       type. ~case m: Map[String, Int] => ... // Don't~.
     + You can match a generic map: ~case m: Map[_, _] => ... // OK~
     + However, arrays are _NOT_ erased (=TODO WHY=).
       You can match an ~Array[Int]~.
     + =TODO= How about ~List~???

** DONE 14.5 Matching ~Arrays~, ~Lists~, and ~Tuples~ — page 187
   CLOSED: [2017-03-07 Tue 00:32]
   - Match ~Array~ example:
     #+BEGIN_SRC scala
     arr match {
       case Array(0) => "0"
       case Array(x, y) => x + " " + y
       case Array(0, _*) => "0 ..."  // matches any array starting with 0
       case _ => "something else"
     } 
     #+END_SRC

   - Match ~List~: Similar as ~Array~, but ~::~ operator can be used.

   - Match tuples: Simple

** DONE 14.6 /Extractors/ — page 188
   CLOSED: [2017-03-29 Wed 06:09]
   - /extractors/: objects with an ~unapply~ or ~unapplySeq~ method that extract
     values from an object. =TODO Chapter 11=
     1. The ~unapply~ method is provided to extract a fixed number of objects,
        while
     2. ~unapplySeq~ extracts a sequence whose length can vary.

   - The Array companion object is an extractor -- it defines an ~unapplySeq~
     #+BEGIN_SRC scala
     arr match {
       case Array(0, x) => ...
       ...
     }
     #+END_SRC
     The call ~Array.unapplySeq(arr)~ yields _a sequence of values_, namely the
     values in the array. The first value is compared with zero, and the second
     one is assigned to x.

   - Regular expressions provide another good use of extractors. When a regular
     expression has groups, you can match each group with an extractor pattern.
     For example
     #+BEGIN_SRC scala
     val pattern = "([0-9]+) ([a-z]+)".r

     "99 bottles" match {
       case pattern(num, item) => ...
       // Sets num to "99", item to "bottles"
     } 
     #+END_SRC
     Note that here the extractor isn't a companion object but a regular
     expression object.

** DONE 14.7 Patterns in _Variable Declarations_ — page 188
   CLOSED: [2017-03-07 Tue 00:32]
   #+BEGIN_SRC scala
   val (x, y) = (1, 2) 
   val (q, r) = BigInt(10) /% 3
   val Array(first, second, _*) = arr
   #+END_SRC

** DONE 14.8 Patterns in ~for~ Expressions — page 189
   CLOSED: [2017-03-07 Tue 00:32]
   - In a ~for~ comprehension, _match failures are silently ignored_. For
     example, the following loop prints all keys with empty value, skipping over
     all others:
     #+BEGIN_SRC scala
     // Ver 1
     for ((k, "") <- System.getProperties())
       println(k)

     // Ver 2
     for ((k, v) <- System.getProperties() if v == "")
       println(k)
     #+END_SRC

** DONE 14.9 /Case Classes/ — page 189 
   CLOSED: [2017-03-29 Wed 06:24]
   Case classes are a special kind of classes that are optimized for use in
   pattern matching.

   - Example:
     #+BEGIN_SRC scala
     abstract class Amount
     case class Dollar(value: Double) extends Amount
     case class Currency(value: Double, unit: String) extends Amount
     // you can also have case objects for singletons:
     case object NothingAmount extends Amount
     
     amt match {
       case Dollar(v) => "$" + v
       case Currency(_, u) => "Oh noes, I got " + u
       case NothingAmount => ""
     }
     #+END_SRC

   - Use ~()~ (includes 0 to n required parameters) with _case class instances_,
     no parentheses with _case objects_.

   - When you declare a case class, several things happen automatically:
     + Each of the constructor parameters becomes a ~val~ unless it is explicitly
       declared as a ~var~ (which is not recommended). =IMPORTANT=

     + An ~apply~ method is provided for the companion object that lets you cons-
       truct objects without ~new~.

     + An ~unapply~ method is provided that makes pattern matching work.

     + Methods ~toString~, ~equals~, ~hashCode~, and ~copy~ are generated
       _unless_ they are explicitly provided. =IMPORTANT=

** DONE 14.10 The ~copy~ Method and Named Parameters — page 190
   CLOSED: [2017-03-29 Wed 06:27]
   - The ~copy~ method of a case class makes a new object with the same values as
     an existing one. For example,
     #+BEGIN_SRC scala
     val amt = Currency(29.95, "EUR")
     val price = amt.copy()
     #+END_SRC

     + By itself, that isn't very useful—after all, a Currency object is
       immutable, and one can just share the object reference.

     + However, you can use named parameters to _modify_ some of the properties:
       #+BEGIN_SRC scala
       val price = amt.copy(value = 19.95)  // Currency(19.95, "EUR")

       // or

       val price = amt.copy(unit = "CHF")  // Currency(29.95, "CHF")
       #+END_SRC

** DONE 14.11 Infix Notation in ~case~ Clauses — page 191
   CLOSED: [2017-03-29 Wed 06:36]
   - When an ~unapply~ method yields a pair, you can use infix notation in the
     ~case~ clause.
       In particular, you can use infix notation with a case class that has two
     parameters. For example:
     =TODO: Re-read this :: method in the future=
     #+BEGIN_SRC scala
     // case class ::[E](head: B, tail: List[E]) extends List[E]

     lst match {
       case h :: t => ...
       case Nil => ...
      }
       // Same as case ::(h, t), which calls ::.unapply(lst)
     #+END_SRC

   - _NOTE_: 
     Infix notation works with any ~unapply~ method that returns a pair.
     Here is an example: =TODO: Don't quite understand, re-think in the future=

** DONE 14.12 Matching Nested Structures — page 192
   CLOSED: [2017-03-29 Wed 06:41]
   - Use ~@ a-concrete-pattern~ and ~@ _*~
     #+BEGIN_SRC scala
     abstract class Item
     case class Article(description: String, price: Double) extends Item
     case class 
     
     itm match {
       // @ _* is required, or else rest will be binded to only one parameter.
       case Bundle(_, _, art @ Article(_, _), rest @ _*) => ...
       case ... => ...
     }
     #+END_SRC

** DONE 14.13 Are Case Classes Evil? — page 192
   CLOSED: [2017-03-29 Wed 20:12]
   - =case classes applicable scope=:
     Case classes work well for structures whose makeup doesn't change.
     For example, the Scala ~List~ is implemented with case classes.

   - When they are appropriate, case classes are quite convenient, for the
     following reasons:
     + Pattern matching often leads to more concise code than inheritance.
     + It is easier to read compound objects that are constructed without ~new~.
     + You get ~toString~, ~equals~, ~hashCode~, and ~copy~ _for free_.

   - /value classes/:
     Illustrate this name through an example, consider the ~Currency~ class:
     A ~Currency(10, "EUR")~ is the same as any other ~Currency(10, "EUR")~, and
     that's how ~equals~ and ~hashCode~ are implemented.
     
     =COMMENT= For certain kinds of classes, case classes give you exactly the
     right semantics.

   - Case classes with variable fields are somewhat SUSPECT, at least with
     respect to the hash code.
       _With mutable classes, one should always derive the hash code from fields
     that are never mutated, such as an ID._

   - _CAUTION_:
     The ~toString~, ~equals~, ~hashCode~, and ~copy~ methods are NOT generated
     for case classes that extend other case classes.
     + _You get a compiler warning if one case class inherits from another._

     + =TODO: check this in the current version of Scala= =IMPORTANT=
       A future version of Scala may outlaw such inheritance altogether.

     + =Solution/expedient=: If you need multiple levels of inheritance to factor
       out common behavior of case classes, make only the leaves of the
       inheritance tree into case classes.

** DONE 14.14 /Sealed Classes/ — page 193
   CLOSED: [2017-03-29 Wed 06:46]
   - When you use pattern matching with /case classes/,
     _you would like the compiler to check that you EXHAUSTED all alternatives._
     You achieve this by declaring the common superclass as ~sealed~: 
     #+BEGIN_SRC scala
     sealed abstract class Amount
     case ...
     case ...
     #+END_SRC
     All subclasses of a ~sealed class~ MUST be defined in the _same file_ as the
     class itself.

   - When a class is sealed, all of its subclasses are known at compile time
     (I think this is the reason why "in the same file" is required),
     enabling the compiler to check pattern clauses for completeness.

   - _It is a good idea for ALL /case classes/ to extend a_ /sealed class or trait/.

** DONE 14.15 Simulating Enumerations — page 194
   CLOSED: [2017-03-29 Wed 06:49]
   - Example:
     #+BEGIN_SRC scala
     sealed abstract class TrafficLightColor
     case object Red extends TrafficLightColor
     case object Yellow extends TrafficLightColor
     case object Green extends TrafficLightColor

     color match {
       case Red => "stop"
       case Yellow => "hurry up"
       case Green => "go"
     }
     #+END_SRC

   - If you find this a bit heavyweight,
     you may prefer using the ~Enumeration~ helper class that was described in
     Chapter 6. =TODO: REVIEW=
** DONE 14.16 The ~Option~ Type — page 194
   CLOSED: [2017-03-07 Tue 00:31]
   - The ~Option~ is a generic type in the standard library
     _uses case classes to express values that might or might not be present_.

   - Use ~Option~ type is
     + _less ambiguous_ than using _an empty string_ and
     + _safer_ than using ~null~ for a missing value.

   - For example:
     #+BEGIN_SRC scala
     // Ver 1 tedious
     scores.get("Alice") match {
       case Some(score) => println(score)
       case None => println("No score")
     } 

     // Ver 2-1 tedious
     val alicesScore = scores.get("Alice")
     if (alicesScore.isEmpty) println("No score")
     else println(alicesScore.get)

     // Ver 2-2 tedious
     // val alicesScore = scores.get("Alice")
     println(alicesScore.getOrElse("No score"))

     // Ver 3 PREFERED
     println(scores.getOrElse("Alice", "No score"))
     #+END_SRC

   - If you want to skip a ~None~ value, use a ~for~ comprehension:
     #+BEGIN_SRC scala
     for (score <- scores.get("Alice")) println(score) 
     #+END_SRC
     Bound only happens when ~Some(score)~ is returned. ~None~ is ignored.

   - ~scores.get("Alice").foreach(println _)~ does nothing if ~get~ returns
     ~None~.

** DONE 14.17 Partial Functions — page 195
   CLOSED: [2017-03-07 Tue 00:40]
   - /partial function/: A set of case clauses enclosed in braces, which may
     not be defined for all inputs.

   - It is an instance of a class ~PartialFunction[A, B]~
     + A :: the parameter type,
     + B :: the return type.

   - ~PartialFunction[A, B]~ has two methods:
     1. ~apply~, which computes the function value from the matching pattern, and 
     2. ~isDefinedAt~, which returns ~true~ if the input matches at least one of
        the patterns.

   - For example:
     #+BEGIN_SRC scala
     val f: PartialFunction[Char, Int] = { case '+' => 1 ; case '-' => -1 }
     f('-') // Calls f.apply('-'), returns -1
     f.isDefinedAt('0') // false
     f('0') // Throws MatchError 
     #+END_SRC

   - Some methods accept a ~PartialFunction~ as a parameter.
     For example,
     the ~collect~ method of the ~GenTraversable~ trait applies a partial
     function to all elements where it is defined, and returns a sequence of the
     results.

   - =Note=
     + _CONTEXT_: The partial function expression MUST be in a context where the
       _compiler can infer the return type_.

         This is the case when you assign it to a typed variable, or pass it to an
       argument.

** DONE Exercises — page 196
   CLOSED: [2017-03-29 Wed 23:11]
   1. Review

* TODO Chapter 15  Annotations =Read Later=
  /Annotations/ let you add information to program items.
  This information can be processed by the compiler or by external tools.

  - =TODO= In this chapter, you will learn how to interoperate with Java
    annotations and how to use the annotations that are specific to Scala.

  - The key points of this chapter are:
    + _OPERAND_:
      * classes,
      * methods,
      * fields,
      * local variables,
      * parameters,
      * expressions,
      * type parameters,
      * types.

    + _LAYOUT_: With expressions and types, the annotation follows the annotated
      item.

    + _SYNTAX_: /Annotations/ have the form
      * ~@Annotation~
      * ~@Annotation(value)~
      * ~@Annotation(name1 = value1, ...)~

    + Some common used annotations:
      * Java equivalent:
        - ~@volatile~
        - ~@transient~
        - ~@strictfp~
        - ~@native~

      * ~@throws~: generate Java-compatible throws specifications.

      * ~@tailrec~: lets you verify that a recursive function uses tail call
        optimization.

      * ~@deprecated~: mark deprecated features.

      * The ~assert~ function takes advantage of the ~@elidable~ annotation.
        You can optionally remove assertions from your Scala programs.

** DONE 15.1 What Are Annotations? — page 200
   CLOSED: [2017-03-29 Wed 23:35]
   - The syntax is just like in Java. For example:
     #+BEGIN_SRC scala
     @Test(timeout = 100) def testSomeFeature() { ... }

     @Entity class Credentials {
       @Id @BeanProperty var username : String = _
       @BeanProperty var password : String = _
     }
     #+END_SRC

   - _Note_: =TODO=
     see http://www.scala-lang.org/node/140 for an introduction of Implementing a
     compiler plugin.

   - Difference between Java annotations and Scala annotations:
     + Java annotations ::
       1. Do not affect how the compiler translates source code into bytecode;
       2. they merely add data to the bytecode that can be harvested by external
          tools.

     + Scala annotations ::
          Do affect the compilation process.
          =TODO: REVIEW= For example, the ~@BeanProperty~ annotation that you saw
          in Chapter 5 causes the generation of getter and setter methods.

** DONE 15.2 What Can Be Annotated? — page 200
   CLOSED: [2017-03-29 Wed 23:44]
   - The _order_ doesn't matter when apply _multiple_ annotations.

   - Like Java:
     annotate classes, methods, fields, local variables, and parameters.

   - Dislike Java: 
     + _primary constructor_ (Scala and Java are different in this part):
       1. place the annotation before the constructor, and
       2. add a set of parentheses if the annotation has no arguments.
       ~class Credentials @Inject() (var username: String, var password: String)~

     + _expressions_: Add a colon followed by the annotation
       ~(myMap.get(key): @unchecked) match { ... }~

     + _type parameters_: before
       ~class MyContainer[@specialized T]~

     + _actual type_: after
       ~String @cps[Unit]~

** TODO 15.3 Annotation Arguments — page 201
   - xxx
** TODO 15.4 Annotation Implementations — page 202
   - xxx
** TODO 15.5 Annotations for Java Features — page 203
       Java Modifiers. Marker Interfaces. Checked Exceptions. Variable Arguments. JavaBeans.
   - xxx
** TODO 15.6 Annotations for Optimizations — page 206
*** DONE 15.6.1 Tail Recursion
    CLOSED: [2017-03-29 Wed 23:54]
    - The Scala compiler _automatically_ applies the "tail recursion" optimization.

    - It is _sometimes blocked_ from doing so (tail recursion optimization)
      for nonobvious reasons.

    - Use ~@tailrec~ to tell the compiler to apply this optimization.
      Then if can not be applied, it will report an error.

    - The will be an error report in the example below:
      #+BEGIN_SRC scala
      class Util {
        @tailrec def sum2(xs: Seq[Int], partial: BigInt): BigInt =
          if (xs.isEmpty) partial else sum2(xs.tail, xs.head + partial)
          ...
      } 
      #+END_SRC
      The error message is
      "could not optimize @tailrec annotated method sum2: it is neither private
      nor final so can be overridden"
      + Solution:
        * Declare ~Util~ as an ~object~ rather than an ~class~.
        * Declare the method as ~private~ or ~final~.

    - _Note_: =TODO= =IMPORTANT=
      /trampolining/ example

*** DONE 15.6.2 Jump Table Generation and Inlining
    CLOSED: [2017-03-30 Thu 00:08]
    - ~@switch~: Jump table is more efficient than ~if/else~.

      Scala will try to generate jump table, and you can use ~@switch~ to check
      whether a Scala match clause is indeed compiled into one.
      #+BEGIN_SRC scala
      (n: @switch) match {
        case 0 => "Zero"
        case 1 => "One"
        case _ => "?"
      }
      #+END_SRC

    - ~@inline~ and ~@noinline~
      + Generally, /inlining/ _is done in the JVM_, whose "just in time" compiler
        does a good job without requiring annotations.

      + The two annotations let you direct the Scala compiler, in case you per-
        ceive the need to do so.

*** TODO 15.6.3 Eliding Methods
*** TODO 15.6.4 Specialization for Primitive Types
** DONE 15.7 Annotations for Errors and Warnings — page 210 =TODO: REVIEW=
   CLOSED: [2017-03-30 Thu 00:20]
   - ~@deprecated~: it has two optional arguments,
     + ~message~
     + ~since~ =TODO=
     #+BEGIN_SRC scala
     @deprecated(message = "Use factorial(n: BigInt) instead")
     def factorial(n: Int): Int = ...
     #+END_SRC

   - ~@deprecatedName~
     #+BEGIN_SRC scala
     def draw(@deprecatedName('sz) size: Int, style: Int = NORMAL)
     #+END_SRC
     You can still call ~draw(sz = 12)~ but you will get a deprecation warning.
     

   - /symbol/: =TODO=

   - ~@implicitNotFound~: =TODO=

   - ~@unchecked~: suppresses a warning that a match is not exhaustive
     #+BEGIN_SRC scala
     (lst: @unchecked) match {
       case head :: tail => ...
     }
     #+END_SRC

   - ~@uncheckedVariance~ =TODO=

** TODO Exercises — page 211
* TODO Chapter 16  XML Processing
  - The key points of this chapter:
    + XML literals =<like>this</like>= are of type ~NodeSeq~.

    + You can embed Scala code inside XML literals.

    + The ~child~ property of a ~Node~ yields the child nodes.

    + The ~attributes~ property of a ~Node~ yields a ~MetaData~ object containing
      the node attributes.

    + The ~\~ and ~\\~ operators carry out XPath-like matches.

    + You can match node patterns with XML literals in ~case~ clauses.

    + Use the ~RuleTransformer~ with ~RewriteRule~ instances to transform
      descendants of a node.

    + The ~XML~ object interfaces with Java XML methods for loading and saving.

    + The ~ConstructingParser~ is an alternate parser that preserves comments and
      ~CDATA~ sections.

** 16.1 XML Literals — page 214
   - Type types:
     + ~scala.xml.Elem~: an XML element
       #+BEGIN_SRC scala
       val doc = <html><head><title>Fred's Memoirs</title></head><body>...</body></html>
       #+END_SRC

     + ~scala.xml.NodeSeq~: a sequence of nodes
       #+BEGIN_SRC scala
       val items = <li>Fred</li><li>Wilma</li>
       #+END_SRC

   - _CAUTION_:
     Sometimes, the compiler suspects XML literals when none are intended. For example,
     #+BEGIN_SRC scala
     val (x, y) = (1, 2)
     x < y // OK
     x <y // Error—unclosed XML literal
     #+END_SRC
     In this case, the _REMEDY_ is to _add a space after the_ ~<~.

** 16.2 XML Nodes — page 214
   - Figure 16–1. XML node types =IMPORTANT=

   - Example:
     #+BEGIN_SRC scala
     val elem = <a href="http://scala-lang.org">The <em>Scala</em> language</a>
     #+END_SRC
     + The ~label~ property yields the tag name (here, "a");
     + ~child~ is the child node sequence (one ~Text~ node, one ~Elem~ node, and
       one ~Text~ node in this example).

   - Node sequences are of type ~NodeSeq~, a subtype of ~Seq[Node]~ that adds
     support for XPath-like operators. =TODO: section 16.7=
       Any of the ~Seq~ operations metioned in Chapter 13 can be applicable.

   - _Note_:
     The ~Node~ class extends ~NodeSeq~. A single node is a sequence of length 1.
     This is supposed to make it easier to deal with functions that can return a
     single node or a sequence.

     _It actually creates as many problems as it solves, so I don't recommend_
     _using this trick in your own designs._

   - _Caution_:
     A ~NodeBuffer~ is a ~Seq[Node]~. _It can be implicitly converted to_ a
     ~NodeSeq~.
       Once this conversion has occurred, you need to be careful not to mutate
     the node buffer any longer since XML node sequences are supposed to be
     immutable. =TODO: exercise=

** 16.3 Element Attributes — page 216
   - ~attributes~ property yields an object of type ~MetaData~.
     ~MetaData~ is almost, but not quite, a ~Map~ from attribute keys to values.

   - A value of ~MetaData~ is a node sequence, _NOT a string_.

   - ~EntityRef~ =TODO: ???=, =page 184=

   - _Tip_:
     If you find it inconvenient to deal with entity references in XML literals,
     you can use character references instead:
     ~<img alt="San Jos&#233; State University Logo" .../>~.

   - If there is no unresolved entities in you attributes, call ~text~ method to
     turn the node sequence into a string:
     ~val url = elem.attributes("href").text~.

   - If an attribute is not present, the ~()~ operator returns ~null~.

     If you dislike working with ~null~, use the ~get~ method, which returns an
     ~Option[Seq[Node]]~.

   - ~MetaData~ has no ~getOrElse~ method, but you can apply ~getOrElse~ to the
     ~Option~ that ~get~ returns:
     ~val url = elem.attributes.get("href").getOrElse(Text(""))~

   - Iterate over all attributes:
     1. ~for~
        #+BEGIN_SRC scala
        for (attr <- elem.attributes)
          process(attr.key, attr.value)
        #+END_SRC

     2. ~asAttrMap~
        #+BEGIN_SRC scala
        val image = <img alt="TODO" src="hamster.jpg"/>
        val map = image.attributes.asAttrMap
          // Map("alt" -> "TODO", "src" -> "hamster.jpg")
        #+END_SRC

** 16.4 Embedded Expressions — page 217
   You can include blocks of Scala code inside XML literals to dynamically
   compute items.

   - =TODO= NO Example for ~Atom[T]~.

   - If you have a list of items, you will want to place each item inside an ~li~
     element:
     #+BEGIN_SRC scala
     <ul>{for (i <- items) yield <li>{i}</li>}</ul>
     #+END_SRC

   - _Note_:
     To place an opening or closing brace into an XML literal, _use two braces_:
     #+BEGIN_SRC scala
     <h1>The Natural Numbers {{1, 2, 3, ...}}</h1>
       // produces
       // //
       // <h1>The Natural Numbers {1, 2, 3, ...}</h1>
     #+END_SRC

** 16.5 Expressions in Attributes — page 218
   - Example:
     #+BEGIN_SRC scala
     // WORK! The block will be evaluated
     <img src={makeURL(fileName)}/>

     // DOESN'T WORK! No block.
     <img src="{makeURL(fileName)}"/>
     #+END_SRC

   - The embedded block can also yield a node sequence.
     This is potentially useful if you want to include /entity references/ or
     /atoms/ in an attribute: ~<a id={new Atom(1)} ... />~

   - If the embedded block returns ~null~ or ~None~, _the attribute is not set_.

   - _Caution_:
     _syntax error_: if the block yields _something other than_
     + a ~String~
     + a ~Seq[Node]~
     + an ~Option[Seq[Node]]~.

     This is inconsistent with blocks inside elements, where the result would be
     wrapped in an Atom.

     If you want an atom in an attribute value, you must construct it yourself.
     =TODO= =???=

** TODO 16.6 Uncommon Node Types — page 219
   Include non-XML text into an XML document.
   - ~CDATA~
   - ~PCData~
   - ~Unparsed~
   - /group/ and /ungrouped/
** TODO 16.7 XPath-like Expressions — page 220
   -
** 16.8 Pattern Matching — page 221
   - You can use XML literals in pattern matching expressions.

   - Example:
     #+BEGIN_SRC scala
     node match {
       case <img/> => ...
       ...
     }
     #+END_SRC
     The first match succeeds if _node is an img element_:
     + with any attributes, AND
     + no child elements

   - Deal with child elements is a little tricky.
     + match a single child with: ~case <li>{_}</li> => ...~

     + match a single child and bind it to a variable ~child~ with:
       ~case <li>{child}</li> => ...~

     + match a single child of text node with:
       ~case <li>{Text(item)}</li> => item~

     + match any number of children with: ~case <li>{_*}</li> => ...~
       _CAUTION_: inside XML patterns, braces indicate code pattern, NOT code to
                  be evaluated.

     + match a node sequence and bind it to a variable:
       ~case <li>{children @ _*}</li> => for (c <- children) yield c~
       _CAUTION_: here ~children~ is a ~Seq[Node] and not a ~NodeSeq~.

     + _Only use one node in the case clause_. For example, the following
       is _not legal_:
       ~case <p>{_*}</p><br/> => ... // Not legal~

     + XML patterns can't have attributes. _To match an attribute_, use a
       /guard/:
       ~case n @ <img/> if (n.attributes("alt").text == "TODO") => ...~

** TODO 16.9 Modifying Elements and Attributes — page 222
   - 
** TODO 16.10 Transforming XML — page 223
   -
** TODO 16.11 Loading and Saving — page 223
   -
** TODO 16.12 Namespaces — page 226
   -
** TODO Exercises — page 227
   -

* TODO Chapter 17  Type Parameters
  The key points of this chapter are:
  - _subject_: _Classes_, _traits_, _methods_, and _functions_ can have type
    parameters.

  - _syntax_:
    + Place the type parameters _after_ the name,
    + _enclosed_ in square brackets.

  - _Type bounds_ have the form (and their combinations)
    + ~T <: UpperBound~
    + ~T >: LowerBound~
    + ~T <% ViewBound~
    + ~T : ContextBound~

  - You can _restrict_ a method with a _type constraint_
    such as (~implicit ev: T <:< UpperBound~).

  - Use
    + ~+T~ (/covariance/) to indicate that a generic type's subtype
      relationship is in the same direction as the parameter T, or

    + ~-T~ (/contravariance/) to indicate the reverse direction.

  - /Covariance/ is appropriate for parameters that denote _outputs_
    such as elements in an immutable collection.

  - /Contravariance/ is appropriate for parameters that denote _inputs_
    such as function arguments.

** DONE 17.1 Generic Classes — page 232
   CLOSED: [2017-03-30 Thu 04:38]
   - ~class Pair[T, S](val first: T, val second: S)~

   - A class with one or more type parameters is /generic/

   - Pleasantly, Scala attempts to infer the actual types from the construction
     parameters: ~val p = new Pair(42, "String")  // It's a Pair[Int, String]~

   - You can also specify the types yourself:
     ~val p2 = new Pair[Any, Any](42, "String")~

** DONE 17.2 Generic Functions — page 232
   CLOSED: [2017-03-30 Thu 04:38]
   - similar to the generic classes
** DONE 17.3 Bounds for Type Variables — page 232
   CLOSED: [2017-03-30 Thu 04:38]
   - Example 1: specify upper bound
     #+BEGIN_SRC scala
     // Error
     class Pair[T](val first: T, val second: T) {
       def smaller = if (first.compareTo(second) < 0) first else second
     }
     
     // right, with upper bound
     class Pair[T <: Comparable[T]](val first: T, val second: T) {
       def smaller = if (first.compareTo(second) < 0) first else second
     }
     #+END_SRC

   - _Caution_ =TODO=
     This example is a bit simplistic. If you try a ~new Pair(4, 2)~, you will be
     told that
        for ~T = Int~, the bound ~T <: Comparable[T]~ is _NOT fulfilled_.
     See Section 17.4, "View Bounds," on page 234 for a remedy. =TODO=

   - Example 2: specify lower bound
     #+BEGIN_SRC scala
     // OK
     class Pair[T](val first: T, val second: T) {
       def replaceFirst(newFirst: T) = new Pair[T](newFirst, second)
     } 

     // Better
       // The compiler knows the right type of the right hand side: Pair[R]
       def replaceFirst[R >: T](newFirst: R) = new Pair(newFirst, second)
       // def replaceFirst[R >: T](newFirst: R) = new Pair[R](newFirst, second)
     
     // Not good
       // The compiler identified the right hand side type as Pair[Any]
       def replaceFirst[R](newFirst: R) = new Pair(newFirst, second)
     #+END_SRC

** DONE 17.4 View Bounds — page 234 _DEPRECATED Use implicit type_
   CLOSED: [2017-03-30 Thu 17:52]
   - In the preceding section, we had an example of an upper bound:
     ~class Pair[T <: Comparable[T]]~

     Unfortunately, we can't ~new Pair(4, 2)~. Scala ~Int~ is not a subtype of
     ~Comparable[Int]~. However, ~RichInt~ does implement ~Comparable[Int]~, and
     there is an implicit conversion from ~Int~ to ~RichInt~. =TODO: CH21=
     
     + Solution: ~class Pair[T <% Comparable[T]]~
       The ~<%~ relation _means_ that ~T~ can be converted to a ~Comparable[T]~
       through an _implicit conversion._
       =COMMENT= it's nicer to use ~Ordered[T]~ which adds relational operators to
                 ~Comparable~

     + Strings have an implicit conversion to ~RichString~, which is a subtype of
       ~Ordered[String]~.

** TODO 17.5 Context Bounds — page 234
   =I DON'T UNDERSTAND=

   - /context bound/ has the form ~T : M~, where ~M~ is another generic type.
     It requires that there is an "implicit value" of type ~M[T]~.
     =TODO= We discuss /implicit values/ in detail in Chapter 21.

   - For example: ~class Pair[T: Ordering]~ requires that there is an
     /implicit value/ of type ~Ordering[T]~.

   - Then that /implicit value/ can then be used in the methods of the class.
     When you declare a method that uses the implicit value, you have to add an
     "implicit parameter." Here is an example:
     #+BEGIN_SRC scala
     class Pair[T : Ordering](val first: T, val second: T) {
       def smaller(implicit ord: Ordering[T]) =
         if (ord.compare(first, second) < 0) first else second
     }
     #+END_SRC

   - =TODO= =IMPORTANT=
     As you will see in Chapter 21,
     /implicit values/ are _more flexible_ than /implicit conversions/.

** TODO 17.6 The ~Manifest~ Context Bound — page 235
   =I DON'T UNDERSTAND=

   - To instantiate a generic ~Array[T]~, one needs a ~Manifest[T]~ object. This
     is required _for primitive type arrays_ to work correctly.

   - Example:
     #+BEGIN_SRC scala
     def makePair[T : Manifest](first: T, second: T) = {
       val r = new Array[T](2)
       r(0) = first;
       r(1) = second;
       r
     }
     #+END_SRC
     If you call ~makePair(4, 9)~, the compiler locates the _implicit_
     ~Manifest[Int]~ and actually calls ~makePair(4, 9)(intManifest)~. Then the
     method calls ~new Array(2)(intManifest)~, which returns a primitive array
     ~int[2]~.
     =IMPORTANT= This is due to the type erase.

** DONE 17.7 Multiple Bounds — page 235
   CLOSED: [2017-03-30 Thu 04:54]
   - A type variable can have both an upper and a lower bound.
     The syntax is this: ~T <: Upper >: Lower~

   - You can't have multiple upper or lower bounds.
     _However_,
     + you can still require that a type implements multiple traits, like this:
       ~T <: Comparable[T] with Serializable with Cloneable~

     + You can have more than one view bound:
       ~T <% Comparable[T] <% String~   =TODO: Deprecated. Use implicit type ????=

     + You can also have more than one context bound:
       ~T : Ordering : Manifest~

** DONE 17.8 Type Constraints — page 236
   CLOSED: [2017-03-30 Thu 15:37]
   - /Type constraints/ give you _another way of restricting types_.
     There are _THREE_ relationships that you can use:
     + ~T =:= U~   test whether T equals U
     + ~T <:< U~   test whether T is a subtype of U
     + ~T <%< U~   test whether T is view-convertible to U

   - =TODO=  page 198

   - Example:
     ~class Pair[T](val first: T, val second: T)(implicit ev: T <:< Comparable[T])~,
     There is no advantage to using a type constraint over a type bound
     ~class Pair[T <: Comparable[T]]~

   - When there is advantage:
     + Flexible than type bound, only if you don't access the method with
       constraint type when type is not constrainted

       * You can form a ~Pair[File]~, even though ~File~ is not orered.
         Use can use the instance of ~Pair[File]~ safely if you don't use the
         ~smaller~ method.
         #+BEGIN_SRC scala
         class Pair[T](val first: T, val second: T) {
           def smaller(implicit ev: T <:< Ordered[T]) =
             if (first < second) first else second
         } 
         #+END_SRC

       * The ~orNull~ method in the Option class uses a constraint ~Null <:< A~
           Thus, ~Option[Int]~ is ok, and the only constraint is that it doesn't
         hava ~orNull~ method.
         #+BEGIN_SRC scala
         val friends = Map("Fred" -> "Barney", ...)
         val friendOpt = friends.get("Wilma")  // An Option[String]
         val friendOrNull = friendOpt.orNull  // A String or null 
         #+END_SRC

     + Improve type inference
       _similar to the type inference improvement when apply curring definition_
       #+BEGIN_SRC scala
       def firstLast[A, C <: Iterable[A]](it: C) = (it.head, it.last)
       firstLast(List(1, 2, 3))
         // ERROR: you get a inferredd type arguments [Nothing, List[Int]],
         // which doesn't conform to [A, C <: Iterable[A]]
       #+END_SRC
         The type inferencer cannot figure out what ~A~ is from looking at
       ~List(1, 2, 3)~, because it matches ~A~ and ~C~ _in a single step_.
         To help it along, first match C and then A:
       #+BEGIN_SRC scala
       def firstLast[A, C](it: C)(inmplicit ev: C <:< Iterable[A]) =
         (it.head, it.last)
       #+END_SRC

** TODO 17.9 Variance — page 237
** TODO 17.10 Co- and Contravariant Positions — page 238
** DONE 17.11 Objects Can't Be Generic — page 240
   CLOSED: [2017-03-30 Thu 04:59]
   - For example: the definition of ~List~ (~List[+T]~).
     + ~class Empty[T] extends List[T]~ is silly.
     + ~object Empty[T] extends List[T]~ is _WRONG_.
     + ~object Empty extends List[Nothing]~ is _perfect_.
       Nothing type is a subtype of all types. =CHAPTER 8=

** TODO 17.12 Wildcards — page 241
** TODO Exercises — page 241
* TODO Chapter 18  Advanced Types
** 18.1 Singleton Types — page 246
** 18.2 Type Projections — page 247
** 18.3 Paths — page 248
** DONE 18.4 Type Aliases — page 249
   CLOSED: [2017-03-31 Fri 02:38]
   - Usage 1:
     ~type~ is used for alias complicated types. 
     Example: ~type Index = HashMap[String, (Int, Int)]~

     A ~type~ alias _must be nested inside_ a /class/ or /object/.
     It cannot appear at the top level of a Scala file.
       However, in the REPL, you can declare a ~type~ at the top level,
     since everything in the REPL is implicitly contained in a top-level object.

   - Usage 2:
     The ~type~ keyword is also used for ~abstract~ types that are made concrete
     in a subclass. For example,
     #+BEGIN_SRC scala
     abstract class Reader {
       type Contents
       def read(fileName: String): Contents
     }
     #+END_SRC

     =TODO=:
     We will discuss abstract types in Section 18.12, “Abstract Types,” on page 257.

   - 
** DONE 18.5 Structural Types — page 250
   CLOSED: [2017-03-31 Fri 02:38]
   _This is duck typing like_

   - /structural type/: a specification of
     + abstract methods
     + fields
     + types
     that a conforming type should possess.

   - Example:
     #+BEGIN_SRC scala
     def appendLines(target: { def append(str: String): Any },
                     lines: Iterable[String]) {
       for (l <- lines) {
         target.append(l)
         target.append("\n")
       }
     }
     #+END_SRC
     ~target~ can be _ANY_ class that has an ~append~ method.
       This is _more flexible_ than defining a ~Appendable~ trait, because you
     might not always be able to add that trait to the classes you are using.

** DONE 18.6 Compound Types — page 250
   CLOSED: [2017-03-31 Fri 02:38]
   - /compound type (intersection type)/: ~T1 with T2 with T3 ...~

   - Useage: manipulate values that must provide _multiple traits_.
     #+BEGIN_SRC scala
     val image = new ArrayBuffer[java.awt.Shape with java.io.Serializable]
     #+END_SRC
     Becase of this /compound type/, you can
     + draw the ~image~ object as ~for (s <- image) graphics.draw(s)~.
     + serialize the ~image~ object because you know that all elements are serializable.

   - Then, you can also/only add elements that both shapes and serializable objects:
     #+BEGIN_SRC scala
     val rect = new Rectangle(5, 10, 20, 30)
     image += rect // OK -- Rectangle is Serializable
     image += new Area(rect) // Error -- Area is a Shape but not Serializable
     #+END_SRC

   - /compound type/ can include a /structural type/ declaration. For exmaple,
     ~Shape with Serializable { def contains(p: Point): Boolean }~
     An instance of this compound type must be
     + must be a subtype of ~Shape~ and ~Serializable~, and
     + must have a ~contains~ method with a ~Point~ parameter.
     
   - Technically, =TODO: don't understand!!!=
     + the /structural type/ ~{ def append(str: String): Any }~ is an abbreviation for
       ~AnyRef { def append(str: String): Any }~

     + the /compound type/ ~Shape with Serializable~ is a shortcut for
       ~Shape with Serializable {}~

** DONE 18.7 Infix Types — page 251
   CLOSED: [2017-03-31 Fri 03:08]
   - /infix type/: a type with two type parameters, which can be written in
     "infix" syntax.
     For example, ~String Map Int~ is the same as ~Map[String, Int]~

   - The Infix notation is common in mathematics.

   - An infix type name
       _can be_ any sequence of operator characters,
       _except_ for a single ~*~. This rule _avoids confusion_ with variable
     argument declarations ~T*~.

** TODO 18.8 Existential Types — page 252
   - Read after finish CH 17
** TODO 18.9 The Scala Type System — page 253
   - Table 18-1. Scala Types =TODO=
     | Type | Syntax | Notes |
     |------+--------+-------|
     |      |        |       |
     Why _NO_ /structural type/ in this table. WHY!!!

** 18.10 Self Types — page 254
** 18.11 Dependency Injection — page 255
** 18.12 Abstract Types — page 257
** 18.13 Family Polymorphism — page 259
** 18.14 Higher-Kinded Types — page 263
** Exercises — page 265
* TODO Chapter 19  Parsing
  In this chapter, you will see how to use the "combinator parser" library to
  analyze data with fixed structure.
    Examples of such data are programs in a programming language or data in
  formats such as HTTP or JSON.

  - Scala parser library is a good example of a sophisticated /domain-specific
    language/ embedded in the Scala language.

  - The key points of this chapter are:
    + In Scala combinator parsers (in a grammar):
      * alternatives is ~|~
      * concatenation is ~\sim~
      * options is ~opt~
      * repetitions ~rep~

    + With ~RegexParsers~, _literal strings_ and _regular expressions_ match
      tokens.

    + Use ~^^~ to process parse results.

    + Use pattern matching in a function supplied to ~^^~ to take apart ~ results.

    + Use ~> and <~ to _DISCARD_ tokens that are no longer needed after matching.

    + The ~repsep~ combinator handles the common case of repeated items with a
      separator.

    + A token-based parser is useful for parsing languages with reserved words
      and operators. Be prepared to define your own lexer. =TODO=

    + /Parsers/: functions that
      1. consume a reader
      2. yield a parse result:
         * success
         * failure
         * error

    + The ~Failure~ result provides the details for error reporting.

    + You may want to add ~failure~ clauses to your grammar to improve the
      quality of error messages.

    + Thanks to operator symbols, implicit conversions, and pattern matching, the
      parser combinator library makes parser writing easy for anyone who under-
      stands /context-free grammars/.
        Even if you don't feel the urge to write your own parsers, you may find
      this an interesting case study for an effective domain-specific language.

** DONE 19.1 Grammars — page 270
   CLOSED: [2017-04-03 Mon 19:51]
   - /Backus-Naur Form (BNF)/ =TODO ???=

   - /extended Backus-Naur Form (EBNF)/
     EBNF is the most often used one, and it allows specifying
     + optional elements
     + repetition

   - Here is the BNF for our expression language:
     #+BEGIN_SRC bnf (# No support for ebnf)
     op ::= "+" | "-" | "*"
     expr ::= number | expr op expr | "(" expr ")"

     digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
     number ::= digit | digit number
     #+END_SRC

   - Here is the EBNF examples of our expression language:
     #+BEGIN_SRC ebnf
     
     numberList ::= number ( "," numberList )? 
     //COMMENT// Same as above: numberList ::= number ( "," number )*

     //COMMENT// Add support to operator precedence
     expr ::= term ( ( "+" | "-" ) expr )?
     term ::= factor ( "*" factor )*
     factor ::= number | "(" expr ")"
     #+END_SRC

   - /lexical analysis/ =TODO ???=

   - In practice, it is more efficient to collect numbers before parsing starts,
     in a separate step called /lexical analysis/.

   - A /lexer/
     + discards whitespace and comments, and
     + forms tokens—identifiers, numbers, or symbols
     In our expression language, tokens are number and the symbols + - * ( ).

   - _Note_
     _op_ and _expr_ are NOT /tokens/.
     They are structural elements that were invented by the author of the grammar,
     _in order to produce correct token sequences_.
       Such symbols are called /nonterminal symbols/.
     + One of the /nonterminal symbols/ is at the root of the hierarchy; in our
       case, that is _expr_. It is called the /start symbol/.

   - To produce correctly formatted strings, you
     1. start with the /start symbol/ and
     2. apply the grammar rules
     3. until all nonterminals have been replaced and _only tokens remain_.

** TODO 19.2 Combining Parser Operations — page 271
** TODO 19.3 Transforming Parser Results — page 273
** TODO 19.4 Discarding Tokens — page 274
** TODO 19.5 Generating Parse Trees — page 275
** TODO 19.6 Avoiding Left Recursion — page 276
** TODO 19.7 More Combinators — page 277
** TODO 19.8 Avoiding Backtracking — page 280
** TODO 19.9 Packrat Parsers — page 280
** TODO 19.10 What Exactly Are Parsers? — page 281
** TODO 19.11 Regex Parsers — page 282
** TODO 19.12 Token-Based Parsers — page 283
** TODO 19.13 Error Handling — page 285
** TODO Exercises — page 286
* TODO Chapter 20  Actors
** TODO 20.1 Creating and Starting Actors — page 290
** TODO 20.2 Sending Messages — page 291
** TODO 20.3 Receiving Messages — page 292
** TODO 20.4 Sending Messages to Other Actors — page 293
** TODO 20.5 Channels — page 294
** TODO 20.6 Synchronous Messages and Futures — page 295
** TODO 20.7 Thread Sharing — page 296
** TODO 20.8 The Actor Life Cycle — page 299
** TODO 20.9 Linking Actors — page 300
** TODO 20.10 Designing with Actors — page 301
** TODO Exercises — page 302
* TODO Chapter 21  Implicits =TODO TODO TODO TODO TODO=
  Implicit conversions and implicit parameters are Scala's power tools that do
  useful work behind the scenes. In this chapter, you will learn how implicit
  conversions can be used to enrich existing classes, and how implicit objects
  are summoned automatically to carry out conversions or other tasks. With
  implicits, you can provide elegant libraries that hide tedious details from
  library users.

  - Because implicit conversions can have pitfalls if used indiscriminately
    the compiler _warns_ when compiling the implicit conversion definition.

  - To turn off the warnings take either of these actions:
    + Import ~scala.language.implicitConversions~ into the scope of the implicit
      conversion definition
    + Invoke the compiler with =-language:implicitConversions=

    No warning is emitted when the conversion is applied by the compiler.

  - The key points of this chapter are: =TODO ???=
    + Implicit conversions are used to convert between types.

    + You MUST import implicit conversions so that they are in scope as single
      identifiers.
 
    + An implicit parameter list requests objects of a given type. They can be
      obtained from implicit objects that are defined as single identifiers in
      scope, or from the companion object of the desired type.

    + If an implicit parameter is a single-argument function, it is also used as
      an implicit conversion.

    + A context bound of a type parameter requires the existence of an implicit
      object of the given type.

    + If it is possible to locate an implicit object, this can serve as evidence
      that a type conversion is valid.

** DONE 21.1 Implicit Conversions — page 306
   CLOSED: [2017-04-03 Mon 20:06]
   - /implicit conversion function/: a function _with a single parameter_ that is
     declared with the ~implicit~ keyword.
       As the name suggests, such a function is _automatically applied_ to
     _convert values from one type to another_.

   - For example:
     #+BEGIN_SRC scala
     implicit def int2Fraction(n: Int) = Fraction(n, 1)
     val result = 3 * Fraction(4, 5) // Calls int2Fraction(3)
     #+END_SRC
     Since the existence of the implicit function, in the ~val result ...~ line,
     ~3~ is implicitly and automatically converted into a ~Fraction~ object, and
     then it is multiplied by ~Fraction(4, 5)~.

   - The name convention of /implicit conversion function/: =source2target=

   - Scala is not the first language that allows the programmer to provide
     automatic conversions.
       However, Scala _gives programmers a great deal of control over when_ to
     apply these conversions.

   - _NOTE_:
     In C++, you specify implicit conversions as
     + one-argument constructors or
       or
     + member functions with the name pattern ~operator Type()~.
           However, in C++, you _cannot selectively allow or disallow these
       functions_, and it is common to have unwanted conversions.

** DONE 21.2 Using Implicits for Enriching Existing Libraries — page 306
   CLOSED: [2017-04-07 Fri 22:05]
   _REQUIREMENT_: Add a lacked method ~m~ to a class ~A~.
   _DETAILS_: Suppose the enriched class is ~RichA~,
   + we want to use ~Aobj.m(...)~
   + we don't want to use
     * ~RichAobj.m(...)~ (an explicit conversion for type ~A~ to type ~RichAobj~
       before use).
     * ~RichAobj.m(Aobj)~ (a static method of ~RichAobj~).

   _SOLUTION_:
   1. Define an enriched type that provides what you want
      #+BEGIN_SRC scala
      class RichFile(val from: File) {
        def read = Source.fromFile(from.getPath).mkString
      }
      
      implicit def file2RichFile(from: File) = new RichFile(from)
      #+END_SRC

   2. Provide an implicit conversion to that type
      #+BEGIN_SRC scala
      implicit def file2RichFile(from: File) = new RichFile(from) 
      #+END_SRC

   _RESULT_: Now you can call ~read~ on a ~File~ object, which is implicitly
   converted to a ~RichFile~.

** DONE 21.3 Importing Implicits — page 307
   CLOSED: [2017-04-07 Fri 23:10]
   - Scala will consider the following implicit conversion functions:
     1. Implicit functions _in the companion object_ of the source or target type
     2. Implicit functions that are _in scope as a single identifier_

   - If the function is inside a ~FractionConversions~ object, which we defined
     in the ~com.horstmann.impatient~ package. Use:
     ~import com.horstmann.impatient.FractionConversions._~ OR
     ~import com.horstmann.impatient.FractionConversions.int2Fraction~
     (Select the specific conversions that you want, if there are other
      conversion functions besides ~in2Fraction~)
     You can't use:
     ~import com.horstmann.impatient.FractionConversions~
     (If use this one, the conversion function is
      ~FractionConversions.int2Fraction~, and this ~int2Fraction~ is not in the
      current namespace)

   - _Tip_: In the REPL,
     + type ~:implicits~ to see all implicits that have been imported from a
       source other than ~Predef~, or
     + type ~:implicits -v~ to see all implicits.

   - Localize the import to minimize unintended conversions. For example,
     #+BEGIN_SRC scala
     object Main extends App {
       import com.horstmann.impatient.FractionConversions._
       val result = 3 * Fraction(4, 5) // Uses imported conversion
       println(result)
     }
     #+END_SRC

   - You can also exclude a specific conversion if it causes you trouble:
     #+BEGIN_SRC scala
     import com.horstmann.impatient.FractionConversions.{fraction2Double => _, _}
     // Imports everything but fraction2Double 
     #+END_SRC

   - _Tip_: =IMPORTANT=
     If you want to find out why the compiler doesn't use an implicit conversion
     that you think it should use, try adding it explicitly, for example by
     calling ~fraction2Double(3) * Fraction(4, 5)~. You may get an error message
     that shows the problem.

** DONE 21.4 Rules for Implicit Conversions — page 308
   CLOSED: [2017-04-08 Sat 00:47]
   - Implicit conversions are considered in _THREE_ distinct situations:
     + If the type of an expression differs from the expected type:
       #+BEGIN_SRC scala
       sqrt(Fraction(1, 4))
         // Calls fraction2Double since sqrt expects a Double
       #+END_SRC

     + If an object accesses a nonexistent member:
       #+BEGIN_SRC scala
       new File("README").read
         // Calls file2RichFile since File has no read method
       #+END_SRC

     + If an object invokes a method whose parameters don't match the given
       arguments:
       #+BEGIN_SRC scala
       3 * Fraction(4, 5)
         // Calls int2Fraction since the * method of Int doesn't accept a Fraction
       #+END_SRC

   - On the other hand, there are _THREE_ situations when an implicit conversion
     is _NOT_ attempted:
     + No implicit conversion is used if the code compiles without it. For
       example, if ~a * b~ compiles, the compiler won't try ~a * convert(b)~ or
       ~convert(a) * b~.

     + The compiler will never attempt multiple conversions, such as
       ~convert1(convert2(a)) * b~.

     + Ambiguous conversions are an error. For example, if both ~convert1(a) * b~
       and ~convert2(a) * b~ are valid, the compiler will report an error.

   - _Caution_:
     The ambiguity rule only holds for the object on which the conversion is
     attempted. Consider the case
     ~Fraction(3, 4) * 5~
     It is not an ambiguity that both
     ~Fraction(3, 4) * int2Fraction(5)~ and ~fraction2Double(Fraction(3, 4)) * 5~
     are valid.
     =IMPORTANT=
     _The first conversion wins over the second_, since it does not require
     modification of the object to which the * method is applied.

   - _Tip_:
     If you want to find out which implicit conversion the compiler uses, compile
     your program as ~scalac -Xprint:typer MyProg.scala~
     You will see the source after implicit conversions have been added.

** DONE 21.5 Implicit Parameters — page 309
   CLOSED: [2017-04-21 Fri 18:55]
   - A function or method can have a parameter list that is marked ~implicit~.
     #+BEGIN_SRC scala
     case class Delimiters(left: String, right: String)

     def quote(what: String)(implicit delims: Delimiters) =
       delims.left + what + delims.right  
     #+END_SRC

     In this case, you can

     + call this method explicitly with all parameters
       #+BEGIN_SRC scala
       quote("Bonjour le monde")(Delimiters("«", "»"))
         // Returns // «Bonjour le monde»
       #+END_SRC

     + call this method without explicitly passing this implicit parameter the
       compiler will look for default values to supply with the
       function call. For example:
       #+BEGIN_SRC scala
       object FrenchPunctuation {
         implicit val quoteDelimiters = Delimiters("«", "»")
         // ...
       }
       
       import FrenchPunctuation._
       // or // import FrenchPunctuation.quoteDelimiters~

       quote("Bonjour le monde")
         // Returns // «Bonjour le monde»
       #+END_SRC

   - If omit the implicit parameter list: ~quote("Bonjour le monde")~, the
     compiler will look for an implicit value of type ~Delimiters~. This must be
     a value that is declared as ~implicit~. The compiler looks such an object in
     _TWO_ places:
     + Among all ~val~ and ~def~ _of the desired type_ that are _in scope_ as a
       single identifier.

     + In the /companion object/ of a _type_ that is associated with the desired
       type. Associated types include the desired type itself, and, if it is a
       parameterized type, its type parameters.

   - _Note_:
     There can _ONLY BE ONE_ implicit value for a given data type.

     =IMPORTANT= 
     Thus, it is _NOT_ a good idea to use implicit parameters of common types.

     For example,
     ~def quote(what: String)(implicit left: String, right: String) // No!~
     would not work -- _one could not supply two different strings_.

** DONE 21.6 Implicit Conversions with Implicit Parameters — page 310
   CLOSED: [2017-04-21 Fri 22:35]
   This is used to solve problems like you _CANNOT_ define a generic function
   like ~def smaller[T](a: T, b: T) = if (a < b) a else b~. The reason is that
   there is no promise for type ~T~ that it has ~<~ operator.

   #+BEGIN_SRC scala
   def smaller[T](a: T, b: T)(implicit order: T => Ordered[T])
     = if (a < b) a else b
       // Calls order(a) < b if a doesn't have a < operator
   #+END_SRC
   
   - Explantion of this example:
     Note that ~order~
     + is a function with a single parameter,
     + is tagged ~implicit~, and
     + has a name that is a single identifier. =??=
     Therefore, it is an /implicit conversion/, _in addition to_ being an implicit parameter.
     So, we can _omit_ the call to order in the body of the function.

** TODO 21.7 Context Bounds — page 311
   - xxx
** TODO 21.8 Evidence — page 312
   - xxx
** DONE 21.9 The @implicitNotFound Annotation — page 313
   CLOSED: [2017-04-21 Fri 22:47]
   ~@implicitNotFound~ raises an error message when the compiler CANNOT construct
   an implicit parameter of the annotated type.
   + _INTENT_: give a useful (should be better than the default) error message to
     the programmer.
     For example, the ~<:<~ class is annotated as
     #+BEGIN_SRC scala
     @implicitNotFound(msg = "Cannot prove that ${From} <:< ${To}.")
     abstract class <:<[-From, +To] extends Function1[From, To]
     
     firstLast[String, List[Int]](List(1, 2, 3))
      // ERROR // Cannot prove that List[Int] <:< Iterable[String]
     #+END_SRC
   
** TODO 21.10 ~CanBuildFrom~ Demystified — page 314
   - xxx

   - ex
     #+BEGIN_SRC scala
     def map[B, That](f : (A) => B)(implicit bf: CanBuildFrom[Repr, B, That]): That = {
       val builder = bf()
       val iter = iterator()
       while (iter.hasNext) builder += f(iter.next())
       builder.result
     } 
     #+END_SRC

   - _NOTE_ =TODO= =???= =???=
     In the Scala library, ~map~ is _actually_ defined in the
     ~TraversableLike[A, Repr]~ trait. That way, the more commonly used
     ~Iterable~ trait doesn't need to carry with it the ~Repr~ type parameter.

** TODO Exercises — page 316
   - xxx

* Chapter 22  Delimited Continuations
** 22.1 Capturing and Invoking a Continuation — page 320
** 22.2 The "Computation with a Hole" — page 321
** 22.3 The Control Flow of reset and shift — page 322
** 22.4 The Value of a reset Expression — page 323
** 22.5 The Types of reset and shift Expressions — page 323
** 22.6 CPS Annotations — page 325
** 22.7 Turning a Recursive Visit into an Iteration — page 326
** 22.8 Undoing Inversion of Control — page 329
** 22.9 The CPS Transformation — page 332
** 22.10 Transforming Nested Control Contexts — page 334
** Exercises — page 336

* TODO Tips (may not from this book)
  - Recursive function need an explicit return type in Scala.

  - In the REPL, you _MUST_ define the /class/ and the /companion object/ toge-
    ther in /paste mode/.

  - If you realize you have typed something wrong, but the interpreter is still
    waiting for more input, you can escape by pressing enter twice:
    #+BEGIN_SRC scala
    // scala>
    val oops =
      |
      |
    // You typed two blank lines. Starting a new command.
    // scala>
    #+END_SRC

  - substitution string ??? =From Jian=
    #+BEGIN_SRC scala
    val people = "PersonX"
    println(s"A people $people")
     // A people PersonX
    #+END_SRC

  - A type annotation _MUST FOLLOW every function parameter_, preceded by a
    colon, because the Scala compiler (and interpreter)
    _DOES NOT infer function parameter types_.

  - With the statement ~import scala.collection.mutable~, you can get an
    immutable map as ~Map~ and a mutable one as ~mutable.Map~.

  - As you can see, Scala provides many operators for adding and removing elements.
    Here is a summary:
    1. Append (~:+~) or prepend (~+:~) to a sequence.
    2. Add (~+~) to an unordered collection.
    3. Remove with ~-~.
    4. Use ~++~ and ~--~ for bulk add and remove.
    5. For lists, ~::~ and ~:::~ are preferred.
    6. Mutations are ~+=~ ~++=~ ~-=~ ~--=~.
    7. For sets, I prefer ~++~ ~&~ ~--~.
    8. I stay away from ~++:~ ~+=:~ ~++=:~.

  - If you want to skip a ~None~ value, use a ~for~ comprehension.
    Bound only happens when ~Some(score)~ is returned. ~None~ is ignored.

  - ~scores.get("Alice").foreach(println _)~ does nothing if ~get~ returns
    ~None~.

  - It is possible to replace any ~while~ loop with a /fold/.
    _This is always a good idea_ (=I need examples=)

  - ~scanLeft~ and ~scanRight~ methods combine /folding/ and /mapping/.
    You get a collection of all _intermediate_ results. For example,
    #+BEGIN_SRC scala
    (1 to 10).scanLeft(0)(_ + _)
      // yields all partial sums:
      // Vector(0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55)
    #+END_SRC

  - The ~#::~ operator is like the ~::~ operator for lists, but it constructs a
    /stream/.

  - /Lazy views/ can be beneficial
    if a large collection is transformed in multiple ways, because it avoids
    building up large intermediate collections.

  - If a collection is processed in different parts of a program, you can pass
    along a /view/ that accumulates the modifications.

  - For parallele operation (don't forget ~par~), with the operator associativity
    required,
    + ~aggregate~ can be used to replace ~foldLeft~ and ~foldRight~.
    + ~reduce~ can be used to replace ~reduceLeft~ and ~reduceRight~.
    
    ~fold~ is not as flexible as ~foldLeft~ and ~foldRight~.

  -_Tip_:
    If you want to find out why the compiler doesn't use an implicit conversion
    that you think it should use, try adding it explicitly, for example by
    calling ~fraction2Double(3) * Fraction(4, 5)~. You may get an error message
    that shows the problem.

  - _Tip_:
    If you want to find out which implicit conversion the compiler uses, compile
    your program as ~scalac -Xprint:typer MyProg.scala~
    You will see the source after implicit conversions have been added.

* TODO TodoList
   - If you find this a bit heavyweight,
     you may prefer using the ~Enumeration~ helper class that was described in
     Chapter 6. =TODO: REVIEW=

   - _THINKING_: Why Scala ~Map~ has ~head~ and ~tail~. It's reasonable that
     ~LinkedMap~ has them, but why the others also (they don't have order).
