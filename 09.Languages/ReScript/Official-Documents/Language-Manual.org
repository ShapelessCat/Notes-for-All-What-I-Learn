#+TITLE: ReScript
#+VERSION: v9.1 - v10.0
#+STARTUP: overview
#+STARTUP: entitiespretty

* Overview
** Introduction
** Installation
** Editor Plugins
** Migrate to ReScript Syntax =FIXME=
   # Migrate from BuckleScript/Reason

** Try

* Language Features
** DONE Overview
   CLOSED: [2022-11-05 Sat 19:34]
*** Comparison to JS
*** Common Features' JS Output

** DONE Let Binding
   CLOSED: [2022-11-05 Sat 19:43]
   - let binding :: "variable declaration" in other languages.

*** Block Scope
*** Binding Are Immutable
*** Binding Shadowing
*** Private let bindings =???= =Best Practices???=
    - Example: ~%%private(let a = 3)~

    - ~%%private~ also applies to /file level modules/,
      so in some cases, users do _NOT_ need to provide a separate interface file
      just to hide some particular values.
      =TODO= =???=

    - Note:
      interface files are still recommended as a general best practice
      SINCE
      * they give you better separate compilation units and
      * also they're better for documentation.
      =TODO= =???=


    - Still, ~%%private~ is useful in the following scenarios:
      * *Code generators*.
        Some code generators want to hide some values but it is sometimes very
        hard or time consuming for code generators to synthesize the types for
        public fields.

      * *Quick prototyping*.
        During prototyping, we still want to hide some values, but the interface
        file is not stable yet, ~%%private~ provide you such convenience.

** DONE Type
   CLOSED: [2022-11-05 Sat 20:01]
*** Inference
*** Type Annotation
    #+begin_src rescript
      let myInt = 5
      let myInt: int = 5
      let myInt = (5: int) + (4: int)
      let add = (x: int, y: int) : int => x + y
      let drawCircle = (~radius as r: int): circleType => /* code here */
    #+end_src

*** Type Alias
*** Type Parameter (Aka Generic)
    - Types can accept parameters, akin to generics in other languages.
      * The parameters' *names need to start with ~'~.*

    - Example:
      #+begin_src rescript
        type coordinates<'a> = ('a, 'a, 'a)

        let a: coordinates<int> = (10, 20, 20)
        let b: coordinates<float> = (10.5, 20.5, 20.5)
      #+end_src
      Since the types can be inferred, this example is for illustration only.

    - Example:
      #+begin_src rescript
        type result<'a, 'b> =
          | Ok('a)
          | Error('b)

        type myPayload = {data: string}

        type myPayloadResults<'errorType> = array<result<myPayload, 'errorType>>

        let payloadResults: myPayloadResults<string> = [
          Ok({data: "hi}),
          Ok({data: "bye}),
          Error("Something wrong happened!")
        ]
      #+end_src

*** Recursive Types
    #+begin_src rescript
      type rec person = {
        name: string,
        friends: array<person>
      }
    #+end_src

*** Mutally Recursive Types
    #+begin_src rescript
      type rec
           student = {taughtBy: teacher}
           and
           teacher = {students: array<student>}
    #+end_src

*** Type Escape Hatch =IMPORTANT=
    We expose a single escape hatch for you to *"lie" to the type system*:

    - Example:
      #+begin_src rescript
        external convertToFloat : int => float = "%identity"
        let age = 10
        let gpa = 2.1 +. convertToFloat(age)
      #+end_src

    - =IMPORTANT= =BEST PRACTICE=
      Do not abuse this feature.

      Use it tastefully when you're _working with_ *existing, overly dynamic JS
      code*, for example.

    - Note: =TODO= =???=
      this particular ~external~ is the only one that isn't preceded by a ~@~ attribute.

** DONE Primitive Types
   CLOSED: [2022-11-06 Sun 17:37]
   ReScript comes with the familiar /primitive types/ like ~string~, ~int~,
   ~float~, etc.

*** DONE String
    CLOSED: [2022-11-06 Sun 16:58]
**** String Interpolation
     - There's a special syntax for string that allows
       * multiline string just like before
       * no special character escaping
       * Interpolation
       * Proper unicode handling

     - Example:
       #+begin_src
         let name = "Joe"

         let greeting = `Hello
         World
         ðŸ‘‹
         ${name}
         `
       #+end_src
       * Just _LIKE_ /JavaScript's backtick string interpolation/,
         *EXCEPT* _without_ needing to escape special characters.

     - If you hope a non-string interpolated value can be _converted to ~string~ *IMPLICITLY*,_
       use prepend ~j~ to the interpolation string:
       #+begin_src
         let age = 10
         let message = j`Today I am $age years old.`
       #+end_src

**** Usage
**** Tips & Tricks

*** DONE Char
    CLOSED: [2022-11-06 Sun 17:01]
    - *Note*:
      Char *doesn't support* /Unicode/ or /UTF-8/ and is therefore *NOT recommended*.

    - String to Char: ~String.get("a", 0)~

    - Char to String: ~String.make(1, 'a')~

*** DONE Regular Expression
    CLOSED: [2022-11-06 Sun 17:15]
    /ReScript regular expressions/ compile cleanly to their _JavaScript COUNTERPART_:

    - Example:
      #+begin_src
        let r = %re("/b/g")
      #+end_src

    - The type is ~Js.Re.t~.

    - You can find helpers you have seen in JS from the /module/ ~Js.Re~.

*** DONE Boolean
    CLOSED: [2022-11-06 Sun 17:27]
    - Type: ~bool~; variants: ~true~ or ~false~.

    - Common operations:
      * ~&&~

      * ~||~

      * ~!~

      * ~<=~, ~>=~, ~<~, ~>~

      * ~==~:
        _structural EQUAL_, compares data structures deeply: ~(1, 2) == (1, 2)~
        is ~true~. *Convenient, but use with caution.*

      * ~===~:
        _referential EQUAL_, compares shalloly: ~(1, 2) == (1, 2)~ is ~false~.
        ~let myTuple = (1, 2); myTuple === myTuple~ is ~true~.

      * ~!=~:
        _structural UNEQUAL_

      * ~!==~
      * _referential UNEQUAL_


    - ReScript's ~true~ / ~false~ compiles into a JavaScript ~true~ / ~false~.

*** DONE Integers - =IMPORTANT= =CAUTION=
    CLOSED: [2022-11-06 Sun 17:37]
    *32-bits, truncated when necessary.*

    - See ~Js.Int~ for helper functions.

    - *CAUTION*:
      Since /ReScript integers/ have a *much SMALLER range* than /JavaScript
      numbers/, data might get lost when dealing with large numbers.

      * It's much safer to bind the numbers as ~float~.

      * Be extra mindful of this
        WHEN _binding to /JavaScript Dates/ and their /epoch time/._
        =TODO= =???=

    - Properly insert underscores in the middle of /numeric literals/ can improve
      the readability.

*** DONE Floats
    CLOSED: [2022-11-06 Sun 17:32]
    - =from Jian= NOT like most of other languages.
      /Float/ requires other operators: +., -., *., /., etc.
      * Like 0.5 +. 0.6. See Js.Float for helper functions.

    - As with /integers/, you may use _underscores_ within /float literals/ to improve
      readability.

*** DONE Unit
    CLOSED: [2022-11-06 Sun 17:28]
    - The ~unit~ /type/ has a _SINGLE value_, ~()~.
      It compiles to JavaScript's ~undefined~.

    - It's a /dummy type/ used as a _placeholder_ in various places.
      =TODO= =???=

** DONE Tuple
   CLOSED: [2022-11-06 Sun 17:44]
   - JavaScript doesn't have /tuples/.

   - /Tuples/ are
     * immutable
     * ordered
     * fix-sized at creation time
     * heterogeneous

   - The form of tuple can also be used in type annottions:
     #+begin_src
       let ageAndName: (int, string) = (24, "Lil' ReScript")
     #+end_src

   - *Note*:
     there's NO tuple of size 1. You'd just use the value itself.

*** Usage
    - Use /pattern matching/ to access a specific element in a /tuple/.
      #+begin_src
        let (_, y, _) = my3dCoordinates
      #+end_src

*** Tips & Tricks
    - _Try to keep the usage of /tuple/ *LOCAL*._

    - For data structures that are _long-living_ and _passed around often_,
      prefer a /record/, which has /named fields/.

** DONE Record
   CLOSED: [2022-11-07 Mon 00:02]
   - /Records/ are like /JavaScript objects/ BUT:
     * are immutable by default
     * have fixed fields (not extensible)

*** Type Declaration
    A record needs a mandatory type declaration:
    #+begin_src
      type person = {
        age: int,
        name: string,
      }
    #+end_src

*** Creation
    - Simple example:
      #+begin_src
        let me = {
          age: 5,
          name: "Big ReScript"
        }
      #+end_src

    - Example:
      if the /type/ instead resides in another _file_ or /module/,
      #+begin_src
        // School.res
        type person = {age: int, name: string}
      #+end_src

      #+begin_src
        // Example.res

        let me: School.person = {age: 20, name: "Big ReScript"}
        /* or */
        let me2 = {School.age: 20, name: "Big ReScript"}
      #+end_src
      The first one, the one with _explicit type annotation_, is the preferred one.

*** Access
    Use the dot notation: ~let name = me.name~

*** Immutable Update
    Create new records from old records with the ~...~ /spread operator/:
    #+begin_src
      let meNextYear = {...me, age: me.age + 1}
    #+end_src

*** Mutable Update
    /Record fields/ can optionally be *mutable*, and /mutable fields/ can be
    efficiently updated in-place with ~=~:

    #+begin_src
      type person = {
        name: string,
        mutable age: int,
      }

      let baby = {name: "Baby ReScript", age: 5}
      baby.age = baby.age + 1 // `baby.age` is now 6.
    #+end_src

*** JavaScript Output
    /ReScript records/ compile to straightforward /JavaScript objects/.

*** Optional Record Fields
    /Optional record fields/ is introduced in v10, suffix the field name with ~?~:
    #+begin_src
      type person = {
        age: int,
        name?: string
      }
    #+end_src

**** Creation
     Use the ~person~ definition
     #+begin_src
       let me = {
         age: 5,
         name: "Big ReScript"
       }

       let friend = {
         age: 7
       }
     #+end_src

**** Immutable Update =FIXME= =level=
     Use the ~person~ definition
     #+begin_src
       let me = {
         age: 123,
         name: "Hello"
       }

       let withoutName = {
         ...me,
         name: "New Name"
       }
     #+end_src

     - If you want to _set_ the /field/ to an /optional value/,
       you *prefix* that value with ~?~:
       #+begin_src
         let me = {
           age: 123,
           name: "Hello"
         }

         let maybeName = Some("My Name")

         let withoutName = {
           ...me,
           name: ?maybeName
         }
       #+end_src

     - Unset an /optional field's value/ via ~?None~.

***** Pattern Matching on Optional Fields
      - When matching on the value directly, it's an option. Example:
        #+begin_src
          type person = {
            age: int,
            name?: string,
          }

          let me = {
            age: 123,
            name: "Hello",
          }

          let isRescript = switch me.name {
          | Some("ReScript") => true
          | Some(_) | None   => false
          }
        #+end_src

      - When matching on the field as part of the general record structure,
        it's treated as the underlying, non-optional value:
        #+begin_src
          let me = {
            age: 123,
            name: "Hello",
          }

          let isRescript = switch me {
          | {name: "ReScript"} => true
          | _                  => false
          }
        #+end_src

      - Check whether the field was set or not:
        #+begin_src
          let me = {
            age: 123,
            name: "Hello",
          }

          let nameWasSet = switch me {
          | {name: ?None}    => false
          | {name: ?Some(_)} => true
          }
        #+end_src

*** Tips & Tricks
**** Record Types Are Found By Field Name
     =from Jian= /Scala-like structure type/ is not supported!

     - A function will infer its parameter type, and the *closet* /record type/
       will be choosed:
       #+begin_src
         type person = {age: int, name: string}
         type monster = {age: int, hasTentacles: bool}

         let getAge = (entity) => entity.age
       #+end_src
       * ~entity~ in ~getAg~ is inferred as ~monster~, and ~getAge~ can't be applied
         on a ~person~ value -- this is a type error.

     - If you need a /Scala-like structure type/ capability, use /ReScript objects/,
       described [[https://rescript-lang.org/docs/manual/latest/object][here]].
       =TODO= =???=

**** Optional Fields in Records Can Be useful for Bindings - =REDO=

*** Design Decisions
    =RE-READ= =Find more discussion=
    =TODO= =???=

** DONE Object
   CLOSED: [2022-11-08 Tue 23:42]
   - ReScript objects are like records, *BUT*:
     * No type declaration needed.

     * Structural and more polymorphic, _UNLIKE_ /records/.

     * *Doesn't support* _updates_
       *UNLESS* _the /object/ comes from the JS side._

     * *Doesn't support* /pattern matching/.

   - Although /ReScript records/ compile to *CLEAN* /JavaScript objects/,
     /ReScript objects/ are a *BETTER* candidate for _emulating/binding_ to
     /JS objects/.

*** Type Declaration
    *Optional*, unlike for /records/.

    - Syntax:
      #+begin_src
        type person = {
          "age": int,
          "name": string
        }
      #+end_src
      This is VISUALLY SIMILAR to /record type's syntax/, with the field names
      *quoted*.

*** Creation
    #+begin_src
      let me = {
        "age": 5,
        "name": "Big ReScript"
      }
    #+end_src

    - *Note*: =IMPORTANT=
      _Unlike_ for /record/, a /object value/ does *NOT* try to find a
      *conforming* /type declaration/ with the matched field names.
      * If you really want a value match a /type declaration/, and let the /type
        checker /do more,
        you can add *EXPLICIT* /type annotation/ tells the ReScript to find a
        conforming /type declaration/.

*** Access
    #+begin_src
      let age = me["age"]
    #+end_src

*** Update
    *Disallowed unless* the /object/ is a binding that _comes from the JavaScript side._
    In that case, use ~=~:
    #+begin_src
      type student = {
        @set "age": int,
        @set "name": string,
      }

      @module("MyJSFile") external student1: student = "student1"

      student1["name"] = "Mary"
    #+end_src

*** Combine Types
    The spread syntax:
    #+begin_src
      type point2d = {
        "x": float,
        "y": float,
      }
      type point3d = {
        ...point2d,
        "z": float,
      }

      let myPoint: point3d = {
        "x": 1.0,
        "y": 2.0,
        "z": 3.0,
      }
    #+end_src

    - *NOTE*:
      This spread syntax *ONLY* works with /object types/, *NOT* /object values/!

*** Tips & Tricks
    Since /ReScript objects/ don't require /type declarations/, and since
    ReScript infers all the types for you,
    you get to _very *QUICKLY* and *EASILY* (and *DANGEROUSLY*) /bind/ to any
    JavaScript API._

    - Check the JS output tab:
      #+begin_src
        // The type of document is just some random type 'a
        // that we won't bother to specify
        @val external document: 'a = "document"

        // call a method
        document["addEventListener"]("mouseup", _event => {
          Js.log("clicked!")
        })

        // get a property
        let loc = document["location"]

        // set a property
        document["location"]["href"] = "rescript-lang.org"
      #+end_src

      #+begin_src js
        document.addEventListener("mouseup", function(_event) {
            console.log("clicked!");
        });
        var loc = document.location;
        document.location.href = "rescript-lang.org";
      #+end_src

    - The external feature and the usage of this trick are also documented in
      the [[https://rescript-lang.org/docs/manual/latest/external#tips--tricks][external]] section later.
      * It's an excellent way to start writing some ReScript code _without worrying_
        about whether /bindings/ to a particular library exists.
        =AGAIN, this is DANGEROUS, THOUGH USEFUL and FLEXIBLE=

** DONE Variant
   CLOSED: [2022-11-07 Mon 13:53]
   - Example:
     #+begin_src
       type myResponse =
         | Yes
         | No
         | PrettyMuch

       let areYouCrushingIt = Yes  // `areYouCrushingIt` is a value of type `myResponse`.
     #+end_src
     * Here ~myResponse~ is a /variant type/ with the cases ~Yes~, ~No~, and ~PrettyMuch~,
       which are called *"variant constructors"* (or *"variant tag"*).

   - *Note*:
     a /variant's constructor/ need to be capitalized.
     =FIXME= =remove =a=

*** Variant Needs an Explicit Definition
*** Constructor Arguments
    =FIXME=
    A /variant constructor/ can hold extra data separated by comma.
    #+begin_src
      type account =
        | None
        | Instagram(string)
        | Facebook(string, int)
    #+end_src

**** Labeled Variant Payloads (Inline Record)
     If a /variant/ payload has MULTIPLE fields,
     you can use a _record-like syntax_ to *label* them for better readability:
     #+begin_src
       type user =
         | Numbr(int)
         | Id({name: string, passowrd: string})

       let me = Id({name: "Joe", password: "123"})
     #+end_src

     - This is technically called an /"inline record"/, and
       *ONLY allowed* within a /variant constructor/.

     - This form is also allowed:
       #+begin_src
         type u = {name: string, password: string}
         type user =
           | Number(int)
           | Id(u)

         let me = Id({name: "Joe", password: "123"})
       #+end_src
       The output is _slightly uglier_ and *less performant* than the former.

**** Pattern Matching On Variant =TODO= =later=

*** JavaScript Output - =RE-READ=
    - A /variant value/ compiles to *3 possible JavaScript outputs* _depending on
      its /type declaration/:_
      * If the variant value is a constructor with *no payload*,
        it compiles to a number.

      * If it's a constructor *with a payload*,
        it compiles to an /object/ with the field *TAG* and the
        field *_0* for the first payload, *_1* for the second payload, etc.

      * An *EXCEPTION* to the above is a variant whose /type declaration/ contains
        only a single constructor with payload. In that case, the constructor
        compiles to an /object/ *without* the *TAG* field.

      * /Labeled variant payloads/ (the /inline record/ trick earlier) compile to an
        object with the *label names* _instead of_ _0, _1, etc. The /object/
        _might or might NOT_ have the *TAG* field as per previous rule.

    - Examples: =TODO=

*** Tips & Tricks
**** Variants Must Have Constructors
     ~type myType = int | string~ is *illegal*.

     - You'd have to give each branch a /constructor/:
       ~type myType = Int(int) | String(string)~

     - The former looks nice, but causes lots of trouble down the line.
       =TODO= =???=

**** Interop with JavaScript =TODO=
**** Variant Types Are Found By Field Name =TODO=
     Please refer to this /record/ section. /Variants/ are the same:
     a function can't accept an arbitrary constructor _shared by two DIFFERENT
     /variants/._

     =TODO=
     Again, such feature exists; it's called a /polymorphic variant/.
     We'll talk about this in the future =).

*** Design Decisions

** TODO Polymorphic Variant - =RE-Reading=
   /Polymorphic variants/ (or /poly variant/) are a _cousin_ of /variant/.
   With these differences:

   * They _start with_ a ~#~ and the /constructor name/ _does *NOT* need to be capitalized_.

   * They *don't require* an /explicit type definition/.
     The type is inferred from usage.

   * Values of different /poly variant types/ *can share* the /constructors/ they
     have *in common* (aka, /poly variants/ are _"structurally" typed_, as
     opposed to _"nominally" typed_).

   They're a convenient and useful alternative to regular /variants/,
   but *should NOT be abused*.

   =TODO= See the drawbacks at the end of this page.

*** Creation
*** Type Declaration
*** Constructor Arguments
**** Combine Types and Pattern Match

*** Structural Sharing
*** JavaScript Output
**** Bind to Functions
**** Bind to String Enums

*** Extra Constraints on Types
**** Closed ~[~
**** Lower Bound ~[>~
**** Upper Bound ~[<~

*** Coercion
*** Tips & Tricks
**** Variant vs Polymorphic Variant

** DONE Null, Undefined and Option - =IMPORTANT=
   CLOSED: [2022-11-08 Tue 14:42]
  ReScript itself does *NOT* have the notion of ~null~ or ~undefined~.

  - However,
    the *concept* of a potentially /nonexistent value/ is
    * still useful, and
    * safely exists
    in our language.

  - Use ~option~ to represent the _EXISTENCE and NONEXISTENCE of a value_:
    #+begin_src
      type option<'a> = None | Some('a)
    #+end_src

    =FIXME= ''a

  - *Note* =FIXME= =???= how -> here???
    how the ~option~ type is just a regular /variant/.

*** Example
    - *A pure ReScript program does _NOT_ have ~null~ errors.*

*** Interoperate with JavaScript ~undefined~ and ~null~
    ~let x = Some(5)~ will be compiled to JS ~var x = 5;~
    ~let x = None~ will be compiled to JS ~var x;~ (then here ~x~ has an ~undefined~ value).

**** Caveat 1
     - Scenario and Rationale: =TODO= =NOTE=

     - =FIXME= ~Caml_option.some~ -- can't see this ~Caml_option~ in any above code snippet.

     - Just remember the following rule:
       * *Never, EVER,* _pass_ a nested option value (e.g. ~Some(Some(Some(5)))~)
         _into the JS side_.

       * *Never, EVER,* _annotate_ a value _coming from JS_ AS ~option<'a>~.
         *Always give the /concrete, non-polymorphic type/.*

**** Caveat 2
     - _UNFORTUNATELY_,
       lots of times, your JavaScript value might be both null or undefined. In
       that case, you unfortunately can't type such value as e.g. option<int>,
       since our option type only checks for undefined and not null when dealing
       with a None.

     - *Solution*: More Sophisticated ~undefined~ & ~null~ interop
       =TODO= =???= =LEARN=
       To solve this, we provide access to more elaborate ~null~ and ~undefined~
       helpers through the ~Js.Nullable~ /module/.

       This somewhat works *like* an ~option~ /type/, *but is different from it*.

***** Examples
      - To create a /JS null/, use the value ~Js.Nullable.null~.

      - To create a /JS undefined/, use ~Js.Nullable.undefined~
        * you can naturally use ~None~ too, but that's not the point here;
          the ~Js.Nullable.*~ helpers *wouldn't work with it*.

      - From JS, in ReScript,
        If you're *RECEIVING*,
        for example, a /JS string/ that can be ~null~ and ~undefined~, type it
        as:
        #+begin_src
          @module("MyConstant") external myId: Js.Nullable.t<string> = "myId"
        #+end_src

      - From ReScript to JS,
        To *CREATE* such a /nullable string/ from our side
        (presumably to *PASS* it to the JS side, for interop purpose), do:
        #+begin_src
          @module("MyIdValidator") external validate: Js.Nullable.t<string> => bool = "validate"
          let personId: Js.Nullable.t<string> = Js.Nullable.return("abc123")

          let result = validate(personId)
        #+end_src
        The ~return~ part "wraps" a string into a /nullable string/, to make the type
        system understand and track the fact that,
        _as you pass this value around, it's not just a string, but a string that
        can be ~null~ or ~undefined~._

***** Convert to/from ~option~
      - ~Js.Nullable.fromOption~ converts from a ~option~ to ~Js.Nullable.t~.

      - ~Js.Nullable.toOption~ does the opposite.

** DONE Array & List
   CLOSED: [2022-11-05 Sat 20:26]
*** Array
    - Example:
      #+begin_src rescript
        let myArray = ["hello", "world", "how are you"]
      #+end_src

    - ReScript /arrays/ work the same way as JavaScript arrays:
      they can be
      * randomly accessed, ~myArray[0]~
      * dynamically resized, ~let pushedValue = Js.Array2.push(myArray, "bye")~
      * updated, ~myArray[0] = "hey"~
      * etc.

**** Usage
     - See the [[https://rescript-lang.org/docs/manual/latest/api/js/array][Js.Array]] API

*** List
**** Usage
***** Immutable Prepend
      #+begin_src
        let myList = list{1, 2, 3}
        let anottherList = list{0, ...myList}
      #+end_src

      - *Note*:
        Since /multiple spread/ for a list, e.g. ~list{a, ...b, ...c}~ (a
        *imaginary* operation), could be an accidental linear operation *O(b)*,
        *ReScript doesn't support it!*

        * If you really want to concatenate lists, you can explicitly use ~List.concat~,
          but we highly discourage it.

***** Access
      ~switch~ is usually used to access list items.

** DONE Function
   CLOSED: [2022-11-08 Tue 01:16]
   _Cheat sheet for the full function syntax at the end._

*** Labeled Arguments
    #+begin_src
      let addCoordinates = (~x, ~y) => {
        // use x and y here, no prefix ~ required
      }

      // The order is not significant if we use labeled arguments
      addCoordinates(~x = 5, ~y = 6)
      aDdCoordinates(~y = 6, ~x = 5)
    #+end_src

    - As a matter of fact, ~(~x)~ is just a _shorthand_ for ~(~x as x)~.
      * Of course, if you write the ~as~ syntax explicitly,
        the label and the actual parameter name *can be different*!
        #+begin_src
          let drawCircle = (~radius as r, ~color as c) => {
            setColor(c)
            startAt(r, r)
            // ...
          }

          drawCircle(~radius = 10, ~color = "red")
        #+end_src

*** Optional Labeled Arguments
    /Labeled function arguments/ can be made _optional_ during DECLARATION.
    You can then _omit_ them when CALLING the function.

    - Example:
      #+begin_src
        // radius can be omitted
        let drawCircle = (~color, ~radius=?, ()) => {
          setColor(color)
          switch radius {
          | None     => startAt(1, 1)
          | Some(r_) => startAt(r_, r_)
          }
        }
      #+end_src
      When given in this syntax, ~radius~ is wrapped in _the standard library's ~option~
      type,_
      * _DEFAULTING to ~None~._
      * If provided, it'll be wrapped with a ~Some~.

      So ~radius~'s type value is ~None | Some(int)~ here.

    - More on ~option~ type here.
      =TODO= =???= Null, Undefined and Option

    - *Note*:
      for the sake of the /type system/,
      WHENEVER you have an /optional argument/,
      you *need to ensure* that
      1. there's also at least one /positional argument/ (aka /non-labeled/,
         /non-optional/ argument) after it.
      2. If there's *none*, provide a dummy ~unit~ (aka ~()~) argument.

**** Signatures and Type Annotations
     - Functions with /optional labeled arguments/ can be *confusing*
       when it comes to /signature/ and /type annotations/.

       * Indeed, the /type/ of an /optional labeled argument/ *looks different*
         DEPENDING ON
         + whether you're _calling the function_,
           a _raw value_ is
           - either passed in (~int~, for example), or
           - left off entirely.

         + or working _inside the /function body/._
           the parameter is always there, but its value is an /option/ (~option<int>~).

         This means that the /type signature/ is *different*,
         _DEPENDING ON_
         whether you're writing out the /function type/, or the /parameter type/ annotation.
         The first being a _raw value_, and the second being an /option/.

     - =IMPORTANT= =GOOD EXAMPLE for Illustration The Above Paragraph=
       If we get back to our previous example and both add a /signature/ and /type
       annotations/ to its argument, we get this:
       #+begin_src
         let drawCircle: (~color: color, ~radius: int = ?, unit) => unit =
           (~color: color, ~radius: option<int> = ?, ()) => {
             setColor(color)
             switch radius {
             | None     => startAt(1, 1)
             | Some(r_) => startAt(r_, r_)
             }
           }
       #+end_src
       1. The _first line_ is the /function's signature/,
          we would define it like that in an /interface file (see =TODO= _Signatures_)/.
          * The /function's signature/ describes the /types/ that the outside world
            interacts with, hence the type ~int~ for ~radius~ because it indeed
            EXPECTS an ~int~ when called.

       2. In the _second line_,
          we annotate the arguments to _help us remember_ the /types/ of the arguments
          WHEN we use them *INSIDE* the _function's body_,
          * here indeed ~radius~ will be an ~option<int>~ *INSIDE* the function.

       3. So if you happen to struggle when writing the /signature of a function/ with
          /optional labeled arguments/, try to remember this!

**** Explicitly Passed Optional
     Sometimes, you might want to forward a value to a function without knowing
     whether the value is ~None~ or ~Some(a)~.

     - Naively, you'd do:
       #+begin_src
         let result =
           switch payloadRadius {
           | None    => drawCircle(~color, ())
           | Some(r) => drawCircle(~color, ~radius = r, ())
           }
       #+end_src

     - A shortcut:
       ~let result = drawCircle(~color, ~radius = ?payloadRadius, ())~

**** Optional with Default Value
     /Optional labeled arguments/ can also be provided a *default value*.
     In this case, they are *NOT* wrapped in an /option type/.
     #+begin_src
       let drawCircle = (~radius = 1, ~color, ()) => {
         setColorr(color)
         startAt(radius, radius)
       }
     #+end_src

*** Recursive Functions
    - ReScript support /tail recursion optimization/ when compiling it.
      * Compile it into a fast JavaScript loop.

**** Mutually Recursive Functions
     Recursive functions chained with ~and~:
     #+begin_src
       let rec
         callSecond = () => callFirst()
       and
         callFirst = () => callSecond()
     #+end_src

*** Uncurried Function
    - ReScript's functions are curried *by default*, which is one of the few
      _performance penalties_ *we pay in the _compiled JS output_.*
      * =IMPORTANT= =LEARN MORE=
        The compiler does a best-effort job at removing those currying whenever
        possible.

        + However,
          in certain edge cases, you might want _GUARANTEED /uncurrying/._
          In those cases, put a dot in the /function's parameter list/:
          #+begin_src
            let add = (. x, y) => x + y
            add(. 1, 2)
          #+end_src

    - *Note*:
      *BOTH* the /declaration site/ and the /call site/ need to have the
      /uncurry annotation/.

      That's part of the _guarantee/requirement_.

    - This feature seems trivial,
      but is _actually one of our *MOST important features*,_ as a primarily
      functional language.

      * =IMPORTANT=
        We *ENCOURAGE* you to use it
        if you'd like to REMOVE any mention of ~Curry~ runtime in the _JS
        output_.

*** Async/Await (from v10.1)
    Just _as in JS,_
    an /async function/ can be declared by adding ~async~ before the definition, and
    ~await~ can be used *in the body of such functions.*

    - Example:
      #+begin_src
        let getUserName = async (userId) => userId

        let greetUser = async (userId) => {
          let name = await getUserName(userId)
          "Hello " ++ name ++ "!"
        }
      #+end_src

      The output looks like idiomatic JS:

      #+begin_src javascript
        async function greetUser(userId) {
            var name = await getUserName(userId);
            return "Hello " + name + "!";
        }
      #+end_src

      * The /return type/ of ~getUser~ is inferred to be ~promise<string>~.
        Similarly, ~await getUserName(userId)~ returns a ~string~ when the
        function returns ~promise<string>~.

        + Using ~await~ _OUTSIDE_ of an /async function/ (including in a non-async
          callback to an /async function/) is an *ERROR*.

**** Ergonomic error handling
     - /Error handling/ is done by
       * simply using ~try~ / ~catch~, or
       * a ~switch~ with an /exception case/,
       just as in functions that are not ~async~.

     - _BOTH_ /JS exceptions/ and /exceptions defined in ReScript/
       *can be CAUGHT*.

       * The compiler takes care of packaging /JS exceptions/ into the
         builtin ~JsError~ /exception/:

     - Example:
       #+begin_src
         exception SomeReScriptException

         let somethingThatMightThrow = async () => raise(SomeReScriptException)

         let someAsyncFn = async () => {
           switch await somethingThatMightThrow() {
           | data                            => Some(data)
           | exception JsError(_)            => None
           | exception SomeReScriptException => None
           }
         }
       #+end_src

*** The ~ignore()~ Function
    Occasionally you may want to _IGNORE the /return value/ of a function._

    - ReScript provides an ~ignore()~ function that discards the value of its
      argument and returns ~()~:
      #+begin_src
        mySideEffect() -> Promise.catch(handleError) -> ignore
        Js.Global.setTimeout(myFunc, 1000) -> ignore
      #+end_src
      =TODO= =???=
      =from Jian= I need to learn ~Promise~
      =TODO= =???=
      =TODO= =???=
      =TODO= =???=
      =TODO= =???=
      =TODO= =???=

*** Tips & Tricks
    Cheat sheet for the function syntaxes:

**** Declaration
***** With Type Annotation

**** Application
***** With Type Annotation

**** Standalone Type Signature
***** In Interface Files
      To annotate a function from the /implementation file/ (=.res=) in your
      /interface file/ (=.resi=):
      #+begin_src
        let add: (int, int) => int
      #+end_src

      - Don't confuse ~let add: myType~ with ~type add = myType~.
        * When used in =.resi= /interface files/,
          the former *exports* the binding ~add~
          while *annotating* it as type ~myType~.

        * The latter
          exports the type ~add~, whose value is the type ~myType~.

** DONE If-Else & Loops
   CLOSED: [2022-11-07 Mon 18:32]
*** If-Else & Ternary
    ReScript supports:
    - ~if~, ~else~
    - ternary expression ~a ? b : c~ (*we encourage you to prefer _if-else_ WHEN POSSIBLE*)
    - ~for~
    - ~while~

*** For Loops
    #+begin_src
      for x in 1 to 3 {
        Js.log(x)
      }

      for x in 3 downto 1 {
        Js.log(x)
      }
    #+end_src

*** While Loops
    #+begin_src
      while testCondition {
        // body here
      }
    #+end_src

**** Tips & Tricks
     - In ReScript: =IMPORTANT=
       * *NO* loop-breaking ~break~ keyword
       * *NO* early return from functions

     - However, we can break out of a while loop easily through using a /mutable binding/:
       #+begin_src
         let break = ref(false)

         while !break.contents {
           if Js.Math.random() > 0.3 {
             break := true
           } else {
             Js.log("Still running")
           }
         }
       #+end_src

** DONE Pipe - =TODO=
   CLOSED: [2022-11-06 Sun 16:48]
   - Example:
     #+begin_src
       validateAge(getAge(parseData(person)))
     #+end_src

     is equivalent to

     #+begin_src
       person
         -> parseData
         -> getAge
         -> validateAge
     #+end_src

   - *CAUTION*
     #+begin_src
       a(one, two, three)
     #+end_src

     is equivalent to

     #+begin_src
       one -> a(two, three)
     #+end_src

   - /Pipe/ also works with /labeled arguments/.

**** This works when the function takes more than one argument too.
     - *CAUTION*
       #+begin_src
         a(one, two, three)
       #+end_src

       is equivalent to

       #+begin_src
         one -> a(two, three)
       #+end_src

     - /Pipe/ also works with /labeled arguments/.

*** DONE Tips & Tricks
    CLOSED: [2022-11-06 Sun 16:40]
    =IMPORTANT=
    *Do not abuse pipes*; they're a means to an end.
    - Inexperienced engineers sometimes shape a library's API to take advantage of the pipe.
      This is backwards.

*** TODO JS Method Chaining - =TODO= _After reading "Bind to JS Function"_
*** DONE Pipe Into Variants
    CLOSED: [2022-11-06 Sun 16:40]
    #+begin_src
      let result = name -> preprocess -> Some
    #+end_src

    - *NOTE*:
      using a /variant constructor/ as a /function/ would *NOT work anywhere
      else* beside here.

*** DONE Pipe Placeholders
    CLOSED: [2022-11-06 Sun 16:48]
    You can use an underscore to tell ReScript that you want to fill in an
    argument of a function later. These two have *equivalent* meaning:
    #+begin_src
      let addTo7 = (x) => add3(3, x, 4)
      let addTo7 = add3(3, _, 4)
    #+end_src

    - This is especially useful
      IF you _don't_ want to pipe the value into the _first position_.
      * Example:
        Assume there is a function ~namePerson~, which takes a ~person~ then a
        ~name~ argument.
        #+begin_src
          makePerson(~age = 47, ())
            -> namePerson("Jane")


          getName(input)
            -> namePerson(personDetails, _)
        #+end_src

    - It also works for named arguments:
      #+begin_src
        getName(input)
          -> namePerson(~person = personDetails, ~name = _)
      #+end_src

*** DONE Triangle Pipe (Deprecated)
    CLOSED: [2022-11-06 Sun 16:48]
    |> is deprecated!

    - =from Jian=
      |> is different from ->

    - Unlike -> pipe, the |> pipe puts the subject as the *last (NOT first) argument* of th function.
      * ~a |> f(b)~ turns into ~f(b, a)~

    - For a more thorough discussion on the rationale and difference between the
      two operators, please refer to the [[https://www.javierchavarri.com/data-first-and-data-last-a-comparison/][Data-first and Data-last comparison by Javier ChÃ¡varri.]]
      =TODO= =???=

** DONE Pattern Matching / Destructuring
   CLOSED: [2022-11-08 Tue 15:18]
  ReScript's pattern matching:
  - Destructuring.
  - ~switch~ based on shape of data.
  - Exhaustiveness check.

*** Destructuring
    - Common usage in assignment

    - For /record/:
      #+begin_src
        type student = {name: string, age: int}
        let student1 = {name: "John", age: 10}
        let {name} = student1 // "John" assigned to `name`
      #+end_src

    - Anywhere you'd usually put a /binding/:
      #+begin_src
        type result =
          | Success(string)

        let displayMessage = (Success(m)) => {
          // we've directly extracted the success message
          // string by destructuring the parameter
          Js.log(m)
        }

        displayMessage(Success("You did it!"))
      #+end_src

    - Rename:
      ~let {name: n} = student1~
      will bind the ~student1.name~ value to ~n~.

*** ~switch~ Based on Shape of Data
**** Complex Examples
**** Fall-Through Patterns
     #+begin_src
       let myStatus = Vacations(10)

       switch myStatus {
       | Vacations(days)
       | Sabbatical(days) => Js.log(`Come back in ${Js.Int.toString(days)} days!`)
       | Sick
       | Present => Js.log("Hey! How are you?")
       }
     #+end_src

**** Ignore Part of a Value
     - *Do not* abuse a top-level catch-all condition.
       Instead, prefer writing out all the cases

**** If Clause
**** Match on Exceptions
     If the function *throws an exception* (covered later), you can also match
     on that, _in addition to_ the function's normally returned values.
     #+begin_src
       switch List.find(i => i === theItem, myItem) {
       | item                => Js.log(item)
       | exception Not_found => Js.log("No such item found!")
       }
     #+end_src

**** Match on Array
**** Match on List
**** Small Pitfall
     The pattern (or part of pattern) can be literal (i.e. concrete values),
     *but not /let binding/ names.*

*** Exhaustiveness Check
*** Conclusion & Tips & Tricks
    - Advice:
      * Avoid using the wildcard ~_~ unnecessarily
      * Use the ~if~ clause (=from Jian= guard) sparingly.
      * Flatten your pattern-match whenever you can.
        #+begin_src
          let optionBoolToBool = opt => {
            if opt == None {
              false
            } else if opt === Some(true) {
              true
            } else {
              false
            }
          }
        #+end_src

        can be better:
        #+begin_src
          let optionBoolToBool = opt => {
            switch opt {
            | None    => false
            | Some(a) => a ? true : false
            }
          }
        #+end_src

        can be improved further:
        #+begin_src
          let optionBoolToBool = opt => {
            switch opt {
            | None        => false
            | Some(true)  => true
            | Some(false) => false
            }
          }
        #+end_src

        and further:
        #+begin_src
          let optionBoolToBool = opt => {
            switch opt {
            | Some(true) => true
            | _          => false
            }
          }
        #+end_src

        + The last one is much more concise,
          *but* kills the exhaustiveness check; refrain from using that. This is the best:
          #+begin_src
            let optionBoolToBool = opt => {
              switch opt {
              | Some(trueOrFalse) => trueOrFalse
              | None              => false
              }
            }
          #+end_src

    - Comparing with ~if~ / ~else~ branches,
      /pattern matchin/g is more concise and [[https://rescript-lang.org/docs/manual/latest/variant#design-decisions][performant]] too.
      =TODO= =???=

** DONE Mutation
   CLOSED: [2022-11-08 Tue 15:23]
   ReScript has great traditional imperative & mutative programming capabilities.

   You should use these features _sparingly_,
   but *SOMETIMES* they allow your code to be *more performant* and written in a
   more familiar pattern.

*** Mutate Let-binding
    #+begin_src
      let myValue = ref(5)
    #+end_src

*** Usage
    - Access the actual value:
      ~let five = myValue.contents~

    - Assignment:
      ~myValue.contents = 6~

      * Syntax sugar:
        ~myValue := 6~

*** Tip & Tricks
    - *Note*:
      you might see in the JS output tabs above that ref *allocates* an
      /object/.

      + *Worry not;*
        /local, non-exported refs allocations/ are *optimized away*.

** TODO JSX
*** Capiitalized Tag
*** Uncapiitalized Tag
*** Fragment
**** Children
***** Children Spread

**** Usage

*** Departures From JS JSX
**** Punning

*** Tips & Tricks
*** Design Decisions

** DONE Exception
   CLOSED: [2022-11-08 Tue 21:21]
   /Exceptions/ are just a special kind of /variant/, thrown in *exceptional* cases
   _(don't abuse them!)_.

*** Usage
    - Illustration example:
      #+begin_src
        let getItem = (items) =>
          if callSomeFunctionThatThrows() {
            // return the found item here
            1
          } else {
            raise(Not_found)
          }

        let result =
          try {
            getItem([1, 2, 3])
          } catch {
          | Not_found => 0 // Default value if getItem throws
          }
      #+end_src
      * This is just for illustration.
        Use ~option<int>~ in the real world code.

      * Directly match /exceptions/ also work:
        #+begin_src
          switch List.find(i => i === theItem, myItems) {
          | item                => Js.log(item)
          | exception Not_found => Js.log("No such item found!")
          }
        #+end_src

    - Make your own /exceptions/:
      #+begin_src
        exception InputClosed(string)
        // later on
        raise(InputClosed("The stream has closed!"))
      #+end_src

*** Catching JS Exceptions
    - To *distinguish* between /JavaScript exceptions/ and /ReScript exceptions/,
      /ReScript namespaces JS exceptions/ under the ~Js.Exn.Error(payload)~
      /variant/.

    - To catch an exception thrown from the JS side:
      #+begin_src
        try {
          someJSFunctionThatThrows()
        } catch {
        | Js.Exn.Error(obj) =>
          switch Js.Exn.message(obj) {
          | Some(m) => Js.log("Caught a JS exception! Message: " ++ m)
          | None    => ()
          }
        }
      #+end_src
      * The ~obj~ here is of /type/ ~Js.Exn.t~, _INTENTIONALLY OPAQUE to disallow
        illegal operations._
        + To operate on ~Js.Exn.t~ values, do like the code above by using the
          standard library's ~Js.Exn~ /module/'s helpers.

*** Raise a JS Exception
    - ~raise(MyException)~ raises a /ReScript exception/.

    - To raise a /JavaScript exception/ (whatever your purpose is), use
      ~Js.Exn.raiseError~:
      #+begin_src
        let myTest = () => {
          Js.Exn.raiseError("Hello!")
        }
      #+end_src

      Catch it from JS side:
      #+begin_src js
        try {
          myTest()
        } catch (e) {
          console.log(e.message) // "Hello!"
        }
      #+end_src

*** Catch ReScript Exceptions from JS
    The previous section is *less useful* than you think; to let your _JS code_
    work with your _exception-throwing ReScript code_, the latter doesn't
    actually need to throw a /JS exception/.

    - /ReScript exceptions/ can be used by _JS code_!
      #+begin_src
        exception BadArgument({myMessage: string})

        let myTest = () => {
          raise(BadArgument({myMessage: "Oops!"}))
        }
      #+end_src

      Then, in your JS:
      #+begin_src js
        // after importing `myTest` ...
        try {
            myTest()
        } catch (e) {
            console.log(e.myMessage) // "Oops!"
            console.log(e.Error.stack) // the stack trace
        }
      #+end_src
      * *Note*:
        ~RE_EXN_ID~ is an /INTERNAL field/ for bookkeeping purposes.
        *Don't* use it on the _JS side_.

    - The above ~BadArgument~ exception takes an /inline record type/.
      We special-case compile the /exception/ as ~{RE_EXN_ID, myMessage, Error}~
      for good ergonomics.
      =TODO= =RECALL THE COMPILATION TO JS RULES=

      * If the /exception/ instead took /ordinary positional arguments/,
        I like the standard library's ~Invalid_argument("Oops!")~, which takes a
        _SINGLE argument_, the argument is compiled to JS as the field ~_1~ instead.
        A second /positional argument/ would compile to ~_2~, etc.

*** Tips & Tricks
    In many scenarios, You use ~option<item>~ instead of /exceptions/.

**** Catch Both ReScript and JS Exceptions in the Same ~catch~ Clause
     #+begin_src
       try {
         someOtherJSFunctionThatThrows()
       } catch {
       | Not_found           => ... // catch a ReScript exception
       | Invalid_argument(_) => ... // catch a second ReScript exception
       | Js.Exn.Error(obj)   => ... // catch the JS exception
       }
     #+end_src

     This technically works,
     BUT _hopefully you don't ever have to work with such code..._

** DONE Lazy Value
   CLOSED: [2022-11-08 Tue 21:48]
   If you have some _expensive computations_ you'd like to *defer and cache*
   subsequently, you can wrap it with ~lazy~:
   #+begin_src
     // Read the directory, only once
     let expensiveFilesRead = lazy({
       Js.log("Reading dir")
       Node.Fs.raddirSync("./pages")
     })
   #+end_src

   - *Note*:
     a /lazy value/ is *NOT* a [[https://rescript-lang.org/docs/manual/latest/shared-data-types][shared data type]].
     *Don't* rely on its _runtime representation_ in your JavaScript code.

*** Execute The Lazy Computation
    - [1]
      To actually run the _lazy value's computation_, use ~Lazy.force~ from the
      _globally available_ ~Lazy~ /module/:
      #+begin_src
        // First call. The computation happens
        Js.log(Lazy.force(expensiveFilesRead)) // logs "Reading dir" and the directory content

        // Second call. Will just return the already calculated result
        Js.log(Lazy.force(expensiveFilesRead)) // logs the directory content
      #+end_src
      1. The first time ~Lazy.force~ is called, the _expensive computation_ happens
         and the result is *cached*.

      2. The second time, the /cached value/ is directly used.

    - _You *CAN'T re-trigger* the computation after the first force call_.
      * =IMPORTANT=
        Make sure you _ONLY_ use a /lazy value/ with computations whose results
        *DON'T change* (e.g. an expensive server request whose response is always
        the same).

    - [2]
      Instead of using ~Lazy.force~, you can also use /pattern matching/ to trigger
      the computation:
      #+begin_src
        switch expensiveFilesRead {
        | lazy(result) => Js.log(result)
        }
      #+end_src

    - [3]
      Since /pattern matching/ also works on a ~let~ binding, you can also do:
      #+begin_src
        let lazy(result) = expensiveFilesRead
        Js.log(result)
      #+end_src

*** Exception Handling
    #+begin_src
      let result = try {
        Lazy.force(expensiveFilesRead)
      } catch {
      | Not_found => [] // empty array of files
      }
    #+end_src
    Though you _should probably handle the /exception/ *inside* the lazy
    computation itself._

** TODO Async & Promise
*** Promise (new)
*** Promise (legacy)
**** Usage

** TODO Module
*** Basics
    *Modules are like mini files!*

    - /Modules/ can contain
      * type definitions,
      * ~let~ bindings,
      * nested modules,
      * etc.

**** Creation
**** ~open~ ing a module
**** Use ~open!~ to ignore shadow warnings
**** Destructuring modules
     # Since 9.0.2

**** Extending modules
**** Every =.res= file is a module

*** Signatures
**** Creation
**** Extending module signatures
**** Every =.resi= file is a signature

*** Module Functions (functors)
**** Module functions types

*** Exotic Module Filenames
*** Tips & Tricks

** TODO Import & Export
*** Import a Module/File
*** Export Stuff
*** Work with JavaScript Import & Export

** DONE Attribute (Decorator) - =TODO= =LEARN MORE=
   CLOSED: [2022-11-08 Tue 22:26]
   ReScript allows annotating a piece of code to express extra functionality.

   - Example
     #+begin_src
       @inline
       let mode = "dev"

       let mode2 = mode
     #+end_src
     * We call the annotation syntax, e.g. ~@inline~, /attribute/ (or
       /decorator/ in JavaScript).

   - An /attribute/ starts with ~@~ and goes before the item it annotates.

*** Usage
    - *Note*:
      In *previous versions (< 8.3)* all our /interop related attributes/
      started with a ~bs.~ prefix (~bs.module~, ~bs.val~).
      * Our formatter will automatically drop them in newer ReScript versions.

    - You can put an /attribute/ *almost anywhere*.
      You can even add extra data to them by using them visually like a function
      call.

      * Here are a few famous attributes (explained in other sections):
        #+begin_src
          @@warning("-27")

          @unboxed
          type a = Name(string)

          @val external message: string = "message"

          type student = {
            age: int,
            @as("aria-label") ariaLabel: string,
          }

          @deprecated
          let customDouble = foo => foo * 2

          @deprecated("Use SomeOther.customTriple instead")
          let customTriple = foo => foo * 3
        #+end_src
        1. ~@@warning("-27")~ is a /standalone attribute/ that *annotates the entire file*.
           Those attributes start with ~@@~. Here, it carries the data "-27". You
           can find a full list of all available warnings here.
           =TODO= =???=
           =TODO= =???=
           =TODO= =???=

        2. ~@unboxed~ annotates the /type definition/.

        3. ~@val~ annotates the /external statement/.

        4. ~@as("aria-label")~ annotates /the ~ariaLabel~ record field/.
           =TODO= =???=

        5. ~@deprecated~ annotates the ~customDouble~ expression.
           This shows a warning while compiling telling consumers to not rely on
           this method long-term.

        6. ~@deprecated("Use SomeOther.customTriple instead")~ annotates the
           ~customTriple~ expression with a string to describe the REASON for
           deprecation.

*** Extension Point
    =TODO= =???=
    =TODO= =???=
    =TODO= =???=

    - There's a *second category* of /attributes/, called "extension points"
      (a remnant term of our early systems):
      #+begin_src
        %raw("var a = 1")
      #+end_src

    - /Extension points/ are /attributes/ that *DON'T* annotate an item;
      _they are the item_.
      * Usually they serve as placeholders for the compiler to implicitly
        substitute them with another item.

    - /Extension points/ start with ~%~.
      A /standalone extension point/ (*akin*
      to a /standalone regular attribute/) starts with ~%%~.

** DONE Unboxed
   CLOSED: [2022-11-08 Tue 22:57]
   Consider
   a /ReScript variant/ with _a *single* payload_, and
   a /record/ with _a *single* field_:
   #+begin_src
     type name = Name(string)
     let studentName = Name("Joe")

     type greeting = {message: string}
     let hi = {message: "hello!"}
   #+end_src

   - If you check the _JavaScript output_, you'll see
     * the ~studentName~ /JS object/
       and
     * the ~hi~ /JS object/,
     as expected (see the [[https://rescript-lang.org/docs/manual/latest/variant#javascript-output][variant JS output]] and [[https://rescript-lang.org/docs/manual/latest/record#javascript-output][record JS output]] sections for
     details).
     #+begin_src js
       var studentName = /* Name */{
         _0: "Joe"
       };

       var hi = {
         message: "hello!"
       };
     #+end_src

   - For _performance and certain JavaScript interop situations_,
     ReScript offers a way to _unwrap_ (aka /unbox/) the /JS object/ wrappers
     from the output for
     * /records/ with a _single_ /field/
       and
     * /variants/ with a _single_ /constructor/ and /single payload/.

     Annotate their /type declaration/ with the attribute ~@unboxed~:
     #+begin_src
       @unboxed
       type name = Name(string)
       let studentName = Name("Joe")

       @unboxed
       type greeting = {message: string}
       let hi = {message: "hello!"}
     #+end_src

     Check the new output! *Clean*
     #+begin_src js
       var studentName = "Joe";

       var hi = "hello";
     #+end_src

*** Usage
    - Example:
      =from Jian=
      Like Scala 3 /opaque type/, and also like the Scala newtype library.

    - As for a /record/ with a single field,
      the use-cases are a bit more edgy. We won't mention them here.
      =TODO= =???=
      =TODO= =???=
      =TODO= =???=

** TODO Reserved Keyword
** TODO Extensible Variant (Advanced Features Features)
*** Definition and Usage
*** Pattern Matching Caveats
*** Tips & Tricks

* TODO JavaScript Interop
** Interop Cheatsheet
*** List of Decorators
*** Raw JS
*** Global Value
*** Global Module's Value
*** Nullable
*** JS Object
*** Function
*** JS Module Interop
*** Dangerous Type Cast

** Embed Raw JavaScript
*** Paste Raw JS Code
*** Debugger
*** Tips & Tricks

** Shared Data Types
** External (Bind to Any JS Library)
*** Usage
*** Tips & Tricks
*** Performance & Output Readability
*** Design Decisions

** Bind to JS Object
*** Bind to Record-like JS Objects
*** Bind to Hash Map-like JS Object
*** Bind to a JS Object That's a Class

** Bind to JS Function
*** Labeled Arguments
*** Object Method
*** Variadic Function Arguments
*** Modeling Polymorphic Function
*** Constrain Arguments Better
*** Special-case: Event Listeners
*** Fixed Arguments
*** Ignore arguments
*** Curry & Uncurry
*** Modeling this-based Callbacks
*** Function Nullable Return Value Wrapping

** Import from / Export to JS
*** Output Format
*** Import From JavaScript
*** Export To JavaScript

** Bind to Global JS Values
*** Global Modules
*** Special Global Values

** JSON
*** Parse
*** Stringify
*** Advanced

** Inlining Constants
*** Tips & Tricks

** Use Illegal Identifier Names
** Generate Converters & Helpers
*** Generate Functions & Plain Values for Variants
*** Generate Field Accessors for Records
*** Generate Converters for JS Integer Enums and Variants
*** Convert Record Type to Abstract Record
*** Convert External into JS Object Creation Function

** Browser Support & Polyfills
** Libraries & Publishing
*** Tips & Tricks

* TODO Build System
** Overview
*** Options
*** Build Project
*** Clean Project

** Configuration
*** name, namespace
*** sources
*** bs-dependencies, bs-dev-dependencies
*** pinned-dependencies
*** external-stdlib
*** reason, refmt (old)
*** js-post-build
*** package-specs
*** suffix
*** warnings
*** bsc-flags
*** Environment Variables

** Configuration Schema
** External Stdlib
*** Configuration

** Pinned Dependencies
*** Package Types
*** Build System Package Rules
*** Examples

** Interop with JS Build Systems
*** Popular JS Build Systems
*** Use Loaders on ReScript Side
*** Getting Project's Dependencies
*** Run Script Per File Built

** Performance
*** Profile Your Build
*** Under the Hood
*** The JS Wrapper
*** Numbers
*** Incrementality & Correctness
*** Speed Up Incremental Build
*** Programmatic Usage
*** Hot Reloading

** Warning Numbers

* TODO Guides
** Converting from JS
*** Step 1: Install ReScript
*** Step 2: Copy Paste the Entire JS File
*** Step 3: Extract Parts into Idiomatic ReScript
*** Step 4: Add externals, Fix Types
*** (Optional) Step 5: Cleanup
*** Tips & Tricks
*** Conclusion

* TODO Extra
** Newcomer Examples
*** Use the option type
*** Create a Parametrized Type
*** Creating a JS Object
*** Modeling a JS Module with Default Export
*** Checking for JS nullable types using the option type

** Project Structure
*** File Casing
*** Ignore .merlin File
*** Folders
*** Third-party Dependencies
*** Documentation
*** PPX & Other Meta-tools
*** Paradigm
*** Publishing

** FAQ
