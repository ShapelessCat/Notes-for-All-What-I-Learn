#+TITLE: The Art of 64-Bit Assembly Language
#+SUBTITLE: Volume 1 - x86-64 Machine Organization and Programming
#+Copyright: 2022
#+AUTHOR: Randall Hyde
#+STARTUP: overview
#+STARTUP: entitiespretty

* FOREWORD - xxiii
* ACKNOWLEDGMENTS - xxv
* INTRODUCTION - xxvii
* PART I: MACHINE ORGANIZATION
** 1 HELLO, WORLD OF ASSEMBLY LANGUAGE - 3
*** 1.1 What You'll Need - 4
*** 1.2 Setting Up MASM on Your Machine - 4
*** 1.3 Setting Up a Text Editor on Your Machine - 5
*** 1.4 The Anatomy of a MASM Program - 5
*** 1.5 Running Your First MASM Program - 6
*** 1.6 Running Your First MASM/C++ Hybrid Program - 7
*** 1.7 An Introduction to the Intel x86-64 CPU Family - 9
*** 1.8 The Memory Subsystem - 13
*** 1.9 Declaring Memory Variables in MASM - 14
**** 1.9.1 Associating Memory Addresses with Variables - 16
**** 1.9.2 Associating Data Types with Variables - 17

*** 1.10 Declaring (Named) Constants in MASM - 18
*** 1.11 Some Basic Machine Instructions - 18
**** 1.11.1 The mov Instruction - 18
**** 1.11.2 Type Checking on Instruction Operands - 20
**** 1.11.3 The add and sub Instructions - 21
**** 1.11.4 The lea Instruction - 22
**** 1.11.5 The call and ret Instructions and MASM Procedures - 22

*** 1.12 Calling C/C++ Procedures - 24
*** 1.13 Hello, World! - 25
*** 1.14 Returning Function Results in Assembly Language - 27
*** 1.15 Automating the Build Process - 33
*** 1.16 Microsoft ABI Notes - 35
**** 1.16.1 Variable Size - 35
**** 1.16.2 Register Usage - 38
**** 1.16.3 Stack Alignment - 39

*** 1.17 For More Information - 39
*** 1.18 Test Yourself - 40

** 2 COMPUTER DATA REPRESENTATION AND OPERATIONS - 43
*** 2.1 Numbering Systems - 44
**** 2.1.1 A Review of the Decimal System - 44
**** 2.1.2 The Binary Numbering System - 44
**** 2.1.3 Binary Conventions - 45

*** 2.2 The Hexadecimal Numbering System - 46
*** 2.3 A Note About Numbers vs. Representation - 48
*** 2.4 Data Organization - 50
**** 2.4.1 Bits - 51
**** 2.4.2 Nibbles - 51
**** 2.4.3 Bytes - 52
**** 2.4.4 Words - 53
**** 2.4.5 Double Words - 54
**** 2.4.6 Quad Words and Octal Words - 55

*** 2.5 Logical Operations on Bits - 55
**** 2.5.1 The AND Operation - 55
**** 2.5.2 The OR Operation - 56
**** 2.5.3 The XOR Operation - 57
**** 2.5.4 The NOT Operation - 57

*** 2.6 Logical Operations on Binary Numbers and Bit Strings - 57
*** 2.7 Signed and Unsigned Numbers - 62
*** 2.8 Sign Extension and Zero Extension - 67
*** 2.9 Sign Contraction and Saturation - 68
*** 2.10 Brief Detour: An Introduction to Control Transfer Instructions - 69
**** 2.10.1 The jmp Instruction - 69
**** 2.10.2 The Conditional Jump Instructions - 70
**** 2.10.3 The cmp Instruction and Corresponding Conditional Jumps - 72
**** 2.10.4 Conditional Jump Synonyms - 73

*** 2.11 Shifts and Rotates - 74
*** 2.12 Bit Fields and Packed Data - 79
*** 2.13 IEEE Floating-Point Formats - 86
**** 2.13.1 Single-Precision Format - 87
**** 2.13.2 Double-Precision Format - 88
**** 2.13.3 Extended-Precision Format - 89
**** 2.13.4 Normalized Floating-Point Values - 89
**** 2.13.5 Non-Numeric Values - 90
**** 2.13.6 MASM Support for Floating-Point Values - 90

*** 2.14 Binary-Coded Decimal Representation - 91
*** 2.15 Characters - 92
**** 2.15.1 The ASCII Character Encoding - 93
**** 2.15.2 MASM Support for ASCII Characters - 95

*** 2.16 The Unicode Character Set - 96
**** 2.16.1 Unicode Code Points - 96
**** 2.16.2 Unicode Code Planes - 97
**** 2.16.3 Unicode Encodings - 97

*** 2.17 MASM Support for Unicode - 98
*** 2.18 For More Information - 99
*** 2.19 Test Yourself - 99

** 3 MEMORY ACCESS AND ORGANIZATION - 105
*** 3.1 Runtime Memory Organization - 106
**** 3.1.1 The .code Section - 108
**** 3.1.2 The .data Section - 108
**** 3.1.3 The .const Section - 109
**** 3.1.4 The .data? Section - 110
**** 3.1.5 Organization of Declaration Sections Within Your Programs - 110
**** 3.1.6 Memory Access and 4K Memory Management Unit Pages - 111

*** 3.2 How MASM Allocates Memory for Variables - 113
*** 3.3 The Label Declaration - 114
*** 3.4 Little-Endian and Big-Endian Data Organization - 114
*** 3.5 Memory Access - 116
*** 3.6 MASM Support for Data Alignment - 119
*** 3.7 The x86-64 Addressing Modes - 122
**** 3.7.1 x86-64 Register Addressing Modes - 122
**** 3.7.2 x86-64 64-Bit Memory Addressing Modes - 123
**** 3.7.3 Large Address Unaware Applications - 127

*** 3.8 Address Expressions - 130
*** 3.9 The Stack Segment and the push and pop Instructions - 134
**** 3.9.1 The Basic push Instruction - 134
**** 3.9.2 The Basic pop Instruction - 135
**** 3.9.3 Preserving Registers with the push and pop Instructions - 137

*** 3.10 The Stack Is a LIFO Data Structure - 137
*** 3.11 Other push and pop Instructions - 140
*** 3.12 Removing Data from the Stack Without Popping It - 140
*** 3.13 Accessing Data You've Pushed onto the Stack Without Popping It - 142
*** 3.14 Microsoft ABI Notes - 144
*** 3.15 For More Information - 144
*** 3.16 Test Yourself - 145

** 4 CONSTANTS, VARIABLES, AND DATA TYPES - 147
*** 4.1 The imul Instruction - 148
*** 4.2 The inc and dec Instructions - 149
*** 4.3 MASM Constant Declarations - 149
**** 4.3.1 Constant Expressions - 152
**** 4.3.2 this and $ Operators - 154
**** 4.3.3 Constant Expression Evaluation - 156

*** 4.4 The MASM typedef Statement - 156
*** 4.5 Type Coercion - 157
*** 4.6 Pointer Data Types - 161
**** 4.6.1 Using Pointers in Assembly Language - 162
**** 4.6.2 Declaring Pointers in MASM - 163
**** 4.6.3 Pointer Constants and Pointer Constant Expressions - 164
**** 4.6.4 Pointer Variables and Dynamic Memory Allocation - 166
**** 4.6.5 Common Pointer Problems - 167

*** 4.7 Composite Data Types - 174
*** 4.8 Character Strings - 174
**** 4.8.1 Zero-Terminated Strings - 174
**** 4.8.2 Length-Prefixed Strings - 175
**** 4.8.3 String Descriptors - 176
**** 4.8.4 Pointers to Strings - 177
**** 4.8.5 String Functions - 177

*** 4.9 Arrays - 181
**** 4.9.1 Declaring Arrays in Your MASM Programs - 182
**** 4.9.2 Accessing Elements of a Single-Dimensional Array - 183
**** 4.9.3 Sorting an Array of Values - 185

*** 4.10 Multidimensional Arrays - 189
**** 4.10.1 Row-Major Ordering - 190
**** 4.10.2 Column-Major Ordering - 193
**** 4.10.3 Allocating Storage for Multidimensional Arrays - 194
**** 4.10.4 Accessing Multidimensional Array Elements in Assembly Language - 196

*** 4.11 Records/Structs - 197
**** 4.11.1 MASM Struct Declarations - 198
**** 4.11.2 Accessing Record/Struct Fields - 199
**** 4.11.3 Nesting MASM Structs - 200
**** 4.11.4 Initializing Struct Fields - 200
**** 4.11.5 Arrays of Structs - 203
**** 4.11.6 Aligning Fields Within a Record - 204

*** 4.12 Unions - 206
**** 4.12.1 Anonymous Unions - 208
**** 4.12.2 Variant Types - 209

*** 4.13 Microsoft ABI Notes - 210
*** 4.14 For More Information - 210
*** 4.15 Test Yourself - 210

* TODO PART II: ASSEMBLY LANGUAGE PROGRAMMING
** TODO 5 PROCEDURES - 215
** TODO 6 ARITHMETIC - 287
** TODO 7 LOW-LEVEL CONTROL STRUCTURES - 377
** TODO 8 ADVANCED ARITHMETIC - 453
** TODO 9 NUMERIC CONVERSION - 491
** TODO 10 TABLE LOOKUPS - 583
** TODO 11 SIMD INSTRUCTIONS - 595
** TODO 12 BIT MANIPULATION - 707
** TODO 13 MACROS AND THE MASM COMPILE-TIME LANGUAGE - 747
** TODO 14 THE STRING INSTRUCTIONS - 825
** TODO 15 MANAGING COMPLEX PROJECTS - 847
** TODO 16 STAND-ALONE ASSEMBLY LANGUAGE PROGRAMS - 873

* TODO PART III: REFERENCE MATERIAL - 899
** A ASCII CHARACTER SET - 901
** B GLOSSARY - 905
** C INSTALLING AND USING VISUAL STUDIO - 919
** D THE WINDOWS COMMAND LINE INTERPRETER - 925
** E ANSWERS TO QUESTIONS - 935
** INDEX - 967
