#+TITLE: The Rust Programming Language
#+VERSION: 2nd
#+AUTHOR: Community
#+STARTUP: overview
#+STARTUP: entitiespretty

* Foreword - xix  =TODO=
  -- Nicholas Matsakis and Aaron Turon
  
* Preface - xxi
* Acknowledgments - xxiii
* Introduction - xxv
** Who Rust Is For - xxvi
*** Teams of Developers - xxvi
*** Students - xxvi
*** Companies - xxvi
*** Open Source Developers - xxvi
*** People Who Value Speed and Stability - xxvii

** Who This Book Is For - xxvii
** How to Use This Book - xxvii
** Resources and How to Contribute to This Book - xxix

* DONE 1. Getting Started - 1
  CLOSED: [2021-01-01 Fri 15:54]
  - There's a lot to learn, but every journey starts somewhere.
    In this chapter, we'll discuss:
    * Installing Rust on Linux, macOS, and Windows
    * Writing a program that prints ~Hello, world!~
    * Using _cargo_, Rust’s package manager and build system

  - Rust package registry site, [[https://crates.io/][crates.io]]

** DONE Installation - 1
   CLOSED: [2017-08-16 Wed 00:43]
   - Convention: =$= prompt means normal user, and =#= means super user.

*** Installing rustup on Linux or macOS
*** Installing rustup on Windows
*** Updating and Uninstalling
*** Troubleshooting
*** Local Documentation

** DONE Hello, World! - 4
   CLOSED: [2021-01-01 Fri 01:39]
*** DONE Creating a Project Directory - 4
    CLOSED: [2021-01-01 Fri 01:38]
*** DONE Writing and Running a Rust Program - 5
    CLOSED: [2021-01-01 Fri 01:39]
    The source code:
    #+begin_src rust
      // main.rs
      fn main() {
          println!("Hello, world!");
      }
    #+end_src

    ~$ rustc main.rs~

    ~$ ./main~
    =From Jian=: NOT ~a.out~ anymore!!!
    The output is ="Hello, world!"=

*** DONE Anatomy of a Rust Program - 5
    CLOSED: [2021-01-01 Fri 01:39]
    - rustfmt

    - It's good style to place the _opening curly bracket_ *on the same line* as
      the function declaration, adding one space in between.

    - ~println!~ is a /Rust macro/.
      =TODO= Discuss Rust macros in more details in Appendix E.
      ~!~ means you're calling a macro instead of a normal function.

    - There are four important details to notice here:
      1. Rust style is to indent with four spaces, not a tab.

      2. ~println!~ is a /Rust macro/.
         It will be discussed in Chapter 19.

      3. You see the ~"Hello, world!"~ string. We pass this string as an argument
         to ~println!~, and the string is printed to the screen.

      4. End the line with a semicolon (~;~), which indicates that this expression
         is over and the next one is ready to begin.
         =TODO= Most lines of Rust code end with a semicolon.
         =from Jian= Why _MOST_???

*** DONE Compiling and Running Are Separate Steps - 6
    CLOSED: [2021-01-01 Fri 01:39]
    The command is mentioned in the _Writing and Running a Rust Program_ section.
    
    - ~rustc main.rs~

    - In Linux and macOS,
      =main= and =main.rs=

    - In Windows,
      =main.exe=, =main.pdb=, and =main.rs=
      * =main.pdb= is a file containing debugging information

    - Just compiling with =rustc= is fine for simple programs,
      but as your project grows, you'll want to manage all the options and make
      it easy to share your code.
      * Next, we'll introduce you to the _Cargo tool_, which will help you write
        real-world Rust programs.

** DONE Hello, Cargo! - 7
   CLOSED: [2021-01-01 Fri 15:53]
   Cargo is Rust's build system and package manager.
   
   - Most Rustaceans use this tool to manage their Rust projects because Cargo
     handles a lot of tasks for you, such as
     * building your code,
     * downloading the libraries your code depends on, and
     * building those libraries. (We call libraries your code needs dependencies.)
   
   - If you installed Rust with the given command (Section 1.1)
     ~$ curl https://sh.rustup.rs -sSf | sh~, *Cargo* should have been installed.
     * Use ~cargo --version~ to check if it is installed properly.

*** DONE Creating a Project with Cargo - 8
    CLOSED: [2021-01-01 Fri 15:53]
    ~cargo new hello_cargo --bin~
    - ~--bin~ argument (to ~cargo new~):
      make an _executable application_, as opposed to a _library_.

    - The new project contains three files:
      * =Cargo.toml=: a structured plain text file.
      * =src= folder
      * =.gitignore= file and =.git= folder
        + This won't be generated if you run =cargo new= within an existing Git repository
        + Override this behavior by using
          =cargo new --vcs=some-vcs-system=, or
          =cargo new --vcs some-vcs-system=.
          - Current (1.51.0-nightly) [possible values: fossil, git, hg, none, pijul]

    - This simple =Cargo.toml= file:
      #+begin_src toml
        [package]
        name = "hello_cargo"
        version = "0.1.0"
        authors = ["Your Name <you@example.com>"]
        edition = "2018"

        [dependencies]
      #+end_src
      This file is the *TOML* (Tom's Obvious, Minimal Language) format.
      *TOML* is similar to *INI* but has some extra goodies and is used as
      Cargo's configuration format.
      * ~[package]~ is a section heading that indicates that the following
        statements are configuring a /package/.
        + The next four lines set the _configuration information Cargo needs to
          compile your program_:
          - the name,
          - the version,
          - who wrote it, and
          - the edition of Rust to use.

          Cargo gets your name and email information from your environment, so
          if that information is not correct, fix the information now and then
          save the file. =from Jian= From where???
          =TODO= We'll talk about the edition key in _Appendix E_.

      * =TODO= =SIMPLIFY NOTE=
        ~[dependencies]~ is the start of a section for you to list any of your
        project's dependencies.
        + In Rust, packages of code are referred to as /crates/.

    - The =src/main.rs= file is initialized as a simple _hello world_ program.

    - Cargo EXPECTS your source files to live *INSIDE* the =src= directory.

    - The top-level project directory is just for
      * =READMEs=
      * license info
      * configuration files
      * anything else not related to your code

    - Using Cargo helps you organize your projects.
      There's a place for everything, and everything is in its place.

*** DONE Building and Running a Cargo Project - 9
    CLOSED: [2021-01-01 Fri 15:53]
    - Build:
      ~$ cargo build~

      The output:
      #+begin_src text
        Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
         Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
      #+end_src

    - This should have created an executable file in =target/debug/hello_cargo=.

    - Manually Run (just a try, not recommended):
      ~$ ./target/debug/hello_cargo~

      The output:
      ="Hello, world!"=
      
    - The first time you run ~cargo build~ in a project, a =Cargo.lock= file
      will be added in the top level of this project.
      #+begin_src toml
        [root]
        name = "hello_cargo"
        version = "0.1.0"
      #+end_src

    - Run:
      ~$ cargo run~
      * The output:
        #+begin_src text
             Compiling hello_cargo v0.1.0 (/home/shapeless-cat/Practices/hello_cargo)
              Finished dev [unoptimized + debuginfo] target(s) in 0.42s
               Running `target/debug/hello_cargo`
          Hello, world!
        #+end_src

    - Cargo also provides a command called ~cargo check~.
      This command quickly checks your code to make sure it compiles but doesn’t
      produce an executable:
      ~$ cargo check~
      The output:
      #+begin_src text
        Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
         Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
      #+end_src

    - Q :: Why would you not want an executable?
    - A :: Often, ~cargo check~ is much faster than ~cargo build~,
           because it *skips the step of producing an executable.*
      * Many Rustaceans run ~cargo check~ periodically as they write their program
        to make sure it compiles.
          Then they run ~cargo build~ when they're ready to use the executable.

    - Let's recap what we've learned so far about Cargo:
      * We can build a project using ~cargo build~.

      * We can build and run a project in one step using ~cargo run~.

      * We can build a project *without producing a binary* to check for errors
        using ~cargo check~.

      * Instead of saving the result of the build in the same directory as our
        code, Cargo stores it in the =target/debug= directory.

    - An additional advantage of using Cargo is that the commands are the same no
      matter which operating system you're working on.

*** DONE Building for Release - 10
    CLOSED: [2021-01-01 Fri 15:53]
    When your project is finally ready for release, you can use
    ~cargo build --release~ to compile it with optimizations.

    - This command will create an executable in =target/release= instead of
      =target/debug=.

    - The optimizations make your Rust code run faster, but turning them on
      lengthens the time it takes for your program to compile.

    - This is why there are _TWO_ different profiles:
      * _one for development_, when you want to *rebuild quickly and often*, and
      * another for building the final program you'll give to a user that won't
        be rebuilt repeatedly and that will run as fast as possible.

    - If you're _benchmarking_ your code's running time,
      be sure to run ~cargo build --release~ and benchmark with the executable
      in =target/release=.
    
*** DONE Cargo as Convention - 11
    CLOSED: [2021-01-01 Fri 15:53]
    You can always expect to do this:
    ~$ git clone someurl.com/someproject~
    ~$ cd someproject~
    ~$ cargo build~

** DONE Summary - 11
   CLOSED: [2021-01-01 Fri 15:53]

* DONE 2. Programming a Guessing Game - 13
  CLOSED: [2021-01-02 Sat 01:26]
  Generate a random integer between 1 and 100.
  Try to guess.
  The program tells you if it is right, too low, or to high?
  If not right keep guessing.
  If right print congratulations and exit.
  
** DONE Setting Up a New Project - 14
   CLOSED: [2021-01-02 Sat 01:23]
   ~$ cargo new guessing_game~
   ~$ cd guessing_game~

   - Look at the generated =Cargo.toml= file:
     #+begin_src toml
       [package]
       name = "guessing_game"
       version = "0.1.0"
       author = ["Your Name <you@example.com>"]
       edition = "2018"

       [dependencies]
     #+end_src
     If the author information that Cargo obtained from your environment is not
     correct, fix that in the file and save it again.
     
** DONE Processing a Guess - 14
   CLOSED: [2021-01-02 Sat 01:24]
   #+begin_src rust
     // src/main.rs

     use std::io;

     fn main() {
         println!("Guess the number!");

         println!("Please input your guess.");

         let mut guess = String::new();

         io::stdin()
             .read_line(&mut guess)
             .expect("Failed to read line");

         println!("You guessed: {}", guess);
     }
   #+end_src

   - ~std~ means the standard library.
     ~io~ library comes from the standard library.

   - Use ~use~ when the required libraries are not in the /prelude/.

   - This code is printing a prompt stating what the game is and requesting input
     from the user.

*** Storing Values with Variables - 15
    - ~String~ is a /string type/ provided by the /standard library/ that is a
      growable, UTF-8 encoded bit of text.

      * The ~::~ syntax in the ~::new~ line indicates that new is an /associated
        function/ of the ~String~ type.

        + /an associated function/ ::
          a function that is implemented *on a /type/,* in this case ~String~,
          _rather than on a particular instance_ of a ~String~ (Some languages
          call this a /static method/).

      * ~String::new()~ create a _NEW, EMPTY string._

      * TO SUMMARIZE,
        the ~let mut guess = String::new();~ line has *created* a
        /mutable variable/ that is currently bound to a NEW, EMPTY /instance/ of
        a ~String~.

    - ~io::stdin~ should be written as ~std::io::stdin~ if you did NOT
      ~use std::io~.

    - The job of ~read_line~ is to
      1. take whatever the user types into standard input
         and
      2. place that into a /string/, so it takes that string as an argument.
         
    - The /string argument/ of ~read_line~, ~guess~,
      needs to be /mutable/
      so the /method/ can change the _string's content_ by adding the user input.

    - The ~&~ indicates that this argument is a /reference/, which gives you a way
      to let multiple parts of your code access one piece of data _without_ needing
      to copy that data into memory multiple times.

    - /References/ are a COMPLEX feature, and one of Rust's major advantages is
      how safe and easy it is to use /references/.
      * /references/ are *immutable* BY DEFAULT.
        Hence, you need to write ~&mut guess~ rather than ~&guess~ to make it /mutable/.
        =TODO= (Chapter 4 will explain references more thoroughly.)

*** Handling Potential Failure with the ~Result~ Type - 17
    - ~read_line~ also returns a value -- an ~io::Result~ typed value.

    - Rust has a number of /types/ named ~Result~ in its standard library:
      * a generic ~Rusult~
      * a specific versions for submodules, such as ~io::Result~.

    - The ~Result~ types are /enumerations/, often referred to as ~enums~.
        An enumeration is a type that can have a _fixed_ set of values, and those
      values are called the /enum's variants/.
      =TODO= CHAPTER 6

    - For ~Result~, the /variants/ are ~Ok~ or ~Err~.
      * ~Ok~ indicates the operation was successful, and it contains the success-
        fully generated value.

      * ~Err~ indicates the operation was failed, and it contains info about
        _how_ and _why_ the operation failed.

    - ~io::Result~ has an ~expect~ method that you can call.
      * With an ~Err~ value, ~expect~ will cause the program to crash and
        display the message that you passed as an argument to ~expect~.

      * With an ~Ok~ value, ~expect~ will take the return value that ~Ok~ is
        holding and return just the value to you.

    - If you have a ~Result~ type value, and you don't use ~expect~ method or try
      to catch the error (=TODO= CHAPTER 9), The compiler will issue a warning
      becuase of _unused value_ issue.

    - =TODO=
      Chapter 9 will show how to recover from errors.

*** Printing Values with ~println!~ Placeholders - 18
    The ~{}~ syntax for ~println!~ ......
    
*** Testing the First Part - 18
    ~cargo run~ and try it (we currently only finished the input part).
    
    Output:
    #+begin_src text
        Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
         Finished dev [unoptimized + debuginfo] target(s) in 6.44s
          Running `target/debug/guessing_game`
      Guess the number!
      Please input your guess.
      6
      You guessed: 6
    #+end_src
    
** DONE Generating a Secret Number - 19
   CLOSED: [2021-01-02 Sat 01:24]
   Not random number functionality in /standard library/, however, the Rust team
   does provide a =rand= /create/.

*** DONE Using a Crate to Get More Functionality - 19
    CLOSED: [2021-01-02 Sat 01:24]
     - /crate/ is a collection of Rust source code files.

       * The project we've been building is a /binary crate/, which is an
         executable.

       * The =rand= /crate/ is a /library crate/, which contains code intended to be
         used in other programs.

     - To use a crate in a Rust project, we need to modify the =Cargo.toml= -- add
       a /dependency/:
       #+begin_src toml
         [dependencies]
         rand = "0.5.5"
       #+end_src

     - Cargo understand [[http://semver.org][Semantic Versioning]] (/SemVer/ for short), which is a
       standard for writing version numbers.
       * The =0.5.5= is a _shorthand_ for =^0.5.5=, which means
         "any version that has a public API compatible with version =0.5.5=".
         =IMPORTANT=

     - /Crates.io/ :: a place people in the Rust ecosystem post their open source
                      Rust projects for others to use.

     - /registry/ :: a copy of data from Crates.io.

     - Now that we have an _external dependency_,
       Cargo fetches the latest versions of everything from the /registry/.

     - ~$ cargo build~
       Output:
       #+begin_src text
           Updating crates.io index
         Downloaded rand v0.5.5
         Downloaded libc v0.2.62
         Downloaded rand_core v0.2.2
         Downloaded rand_core v0.3.1
         Downloaded rand_core v0.4.2
          Compiling rand_core v0.4.2
          Compiling libc v0.2.62
          Compiling rand_core v0.3.1
          Compiling rand_core v0.2.2
          Compiling rand v0.5.5
          Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
           Finished dev [unoptimized + debuginfo] target(s) in 2.53s
       #+end_src
       * Cargo also grabbed =libc= and =rand_core=, because =rand= depends on them.

     - Run ~cargo build~ again, and we can only see the =Finished dev ...= line.
       * Only when we modify =src/main.rs=, we can see the =Compiling ...= lines.

       * Only when we modify the ~[dependencies]~ section,
         we can see the =Downloaded ...= lines.

**** Ensuring Reproducible Builds with the =Cargo.lock= File
     The first time you run ~$ cargo build~ (or ~$cargo run~) Cargo tries to
     figure out the versions of the dependencies that fit the criteria and then
     writes them to the =Cargo.lock= file.

     When you build in the future, Cargo will read =Cargo.lock= rather then tries
     to figure out the verions of dependencies again through parsing =Cargo.toml=.

     _Remember_: the acutally used versions of dependencies (info is in
     =Cargo.lock=) are different from the ones written in =Cargo.toml= -- Cargo
     may choose a higher but can fit version.

**** Updating a Crate to Get a New Version
     - ~$ cargo update~ will help you to update the dependencies to the lastest
       fit version. For instance, 0.5.5 to 0.5.6.

     - If the *first time* you run ~$ cargo build~ it used version _0.5.5_, the
       later ~$ cargo update~ will choose version _exclusively_ between _0.5.5_
       and _0.6.0_.

     - If you want a higher version, like _0.6.0_, you must manually update the
       =Cargo.toml= file.

*** DONE Generating a Random Number - 21
    CLOSED: [2021-01-02 Sat 01:24]
    Update the =src/main.rs=.

    #+BEGIN_SRC rust
      extern crate rand;

      use std::io;
      use rand::Rng;

      fn main() {
          println!("Guess the number!");

          let secret_number = rand::thread_rng().gen_range(1, 101);
          // let secret_number = rand::thread_rng().gen_range(1..101);  // when use rand 0.8

          println!("The secret number is: {}", secret_number);

          println!("Please input your guess.");

          let mut guess = String::new();

          io::stdin().read_line(&mut guess)
              .expect("Failed to read line");

          println!("You guessed: {}", guess);
      }
    #+END_SRC

    - ~Rng~ is a /trait/ that defines /methods/ that /random number generators/
      IMPLEMENT, and this /trait/ MUST BE *in scope* for us to use those /methods/.
      =TODO= CHAPTER 10 =details=

    - ~rand::thread_rng~ function will give us the PARTICULAR /random number generator/
      to be used:
      one that is
      * local to the CURRENT /thread/ of execution
      * *seeded by* the operating system.

    - The ~gen_range~ /method/ is defined by the ~Rng~ trait.

    - Note:
      Run the ~cargo doc --open~ command that will BUILD documentation provided
      by all of your dependencies locally and open it in your browser.
      =IMPORTANT= Then you know what /traits/ you should ~use~.

** DONE Comparing the Guess to the Secret Number - 23
   CLOSED: [2021-01-02 Sat 01:24]
   #+begin_src rust
     use rand::Rng;
     use std::cmp::Ordering;
     use std::io;

     fn main() {
         // --snip--

         println!("You guessed: {}", guess);

         match guess.cmp(&secret_number) {
             Ordering::Less    => println!("Too small!"),
             Ordering::Greater => println!("Too big!"),
             Ordering::Equal   => println!("You win!"),
         }
     }
   #+end_src

   - ~Ordering~ is a type, and it has three variants:
     ~Less~, ~Greater~, and ~Equal~.

   - A ~match~ expression is made up of /arms/.

   - An /arm/ consists of a /pattern/ and the code that should be run when
     pattern matching can be applied.

   - The code above CANNOT be compiled -- type mismatching:
     ~guess~ should be a number if we want to compare it with ~secret_number~.

   - Integer types: ~i32~, ~u32~, ~i64~.
     Rust defaults to an ~i32~, which is the type of ~secret_number~.
     Here, ~u32~ is more reasonable.

   - The corrected code:
     #+BEGIN_SRC rust
       use rand::Rng;
       use std::cmp::Ordering;
       use std::io;

       fn main() {
           println!("Guess the number!");
           let secret_number = rand::thread_rng().gen_range(1, 101);
           println!("The secret number is: {}", secret_number);
           println!("Please input your guess.");

           let mut guess = String::new();

           io::stdin()
               .read_line(&mut guess)
               .expect("Failed to read line");

           let guess: u32 = guess.trim().parse().expect("Please type a number!");

           println!("You guessed: {}", guess);

           match guess.cmp(&secret_number) {
               Ordering::Less    => println!("Too small!"),
               Ordering::Greater => println!("Too big!"),
               Ordering::Equal   => println!("You win!"),
           }
       }
     #+END_SRC

     * =from Jian= I DO NOT like the /shadow/ feature. Here is what I prefered:
       =TODO= CHAPTER 3 - more about the /shadow/ feature.
       #+BEGIN_SRC rust
         use rand::Rng;
         use std::cmp::Ordering;
         use std::io;

         fn main() {
             println!("Guess the number!");
             let secret_number = rand::thread_rng().gen_range(1, 101);
             println!("The secret number is: {}", secret_number);
             println!("Please input your guess.");

             // `line` can be an alternative name.
             let mut input = String::new();

             io::stdin().read_line(&mut input)
                 .expect("Failed to read line");

             println!("You guessed: {}", input);

             let guess: u32 = input.trim().parse().expect("Please type a number!");

             match guess.cmp(&secret_number) {
                 Ordering::Less    => println!("Too small!"),
                 Ordering::Greater => println!("Too big!"),
                 Ordering::Equal   => println!("You win!"),
             }
         }
       #+END_SRC

     * ~trim~ eliminate any WHITESPACE _at the beginning and end_.

     * The ~parse~ /method/ on /strings/ parses a /string/ into some kind of
       /number/. 
       + ~parse~ can parse a variety of /number types/,
         we need to tell Rust the EXACT /number type/ we want by using ~let
         guess: u32~.

     * with the help of ~u32~, ~parse~ knows what's essential type (_essential_
       here means the cotent of the ~Result~ value) of its result.

     * =TODO=
       Need a loop to given the users MULTIPLE choices to guesses.

** DONE Allowing Multiple Guesses with Looping - 26
   CLOSED: [2021-01-02 Sat 01:25]
   Make a simple forever loop with ~loop~
   #+begin_src rust
     use rand::Rng;
     use std::cmp::Ordering;
     use std::io;

     fn main() {
         println!("Guess the number!");
         let secret_number = rand::thread_rng().gen_range(1, 101);
         println!("The secret number is: {}", secret_number);

         loop {
             println!("Please input your guess.");

             // `line` can be an alternative name.
             let mut input = String::new();

             io::stdin().read_line(&mut input)
                 .expect("Failed to read line");

             println!("You guessed: {}", input);

             let guess: u32 = input.trim().parse()
                 .expect("Please type a number!");

             match guess.cmp(&secret_number) {
                 Ordering::Less    => println!("Too small!"),
                 Ordering::Greater => println!("Too big!"),
                 Ordering::Equal   => println!("You win!"),
             }
         }
     }
   #+end_src

*** DONE Quitting After a Correct Guess - 27
    CLOSED: [2021-01-02 Sat 01:25]
    ~break~ when ="You win!"=.

   #+begin_src rust
     use rand::Rng;
     use std::cmp::Ordering;
     use std::io;

     fn main() {
         println!("Guess the number!");
         let secret_number = rand::thread_rng().gen_range(1, 101);
         println!("The secret number is: {}", secret_number);

         loop {
             println!("Please input your guess.");

             // `line` can be an alternative name.
             let mut input = String::new();

             io::stdin().read_line(&mut input)
                 .expect("Failed to read line");

             println!("You guessed: {}", input);

             let guess: u32 = input.trim().parse()
                 .expect("Please type a number!");

             match guess.cmp(&secret_number) {
                 Ordering::Less    => println!("Too small!"),
                 Ordering::Greater => println!("Too big!"),
                 Ordering::Equal   => {
                     println!("You win!");
                     break;
                 }
             }
         }
     }
   #+end_src

*** DONE Handling Invalid Input - 28
    CLOSED: [2021-01-02 Sat 01:25]
    To further refine the game's behavior, rather than crashing the program when
    the user inputs a non-number, _let's make the game ignore a non-number so the
    user can continue guessing._
    
    Do that by altering the line where ~guess~ in converted from a ~String~ to a
    ~u32~.
    
    The final version is:
    #+begin_src rust
      use rand::Rng;
      use std::cmp::Ordering;
      use std::io;

      fn main() {
          println!("Guess the positive integer number!");

          let secret_number = rand::thread_rng().gen_range(1, 101);

          loop {
              println!("Please input your guess.");

              let mut input = String::new();

              io::stdin().read_line(&mut input)
                  .expect("Failed to read line");

              let guess: u32 = match input.trim().parse() {
                  Ok(num) => num,
                  Err(_)  => continue,
              };

              println!("You guessed: {}", guess);

              match guess.cmp(&secret_number) {
                  Ordering::Less    => println!("Too small!"),
                  Ordering::Greater => println!("Too big!"),
                  Ordering::Equal   => {
                      println!("You win!");
                      break;
                  }
              }
          }
      }
    #+end_src
    - Switching from an ~expect~ call to a ~match~ expression is
      how you generally _move from crashing on an error to handling the error._

    - Delete the ~secret_number~ print.

    - =from Jian=
      Add a ~println!~ before ~continue~ to tell one invalid ~guess~ is ignored
      is a good tweak.

** DONE Summary - 30
   CLOSED: [2021-01-02 Sat 01:25]
   
* DONE 3. Common Programming Concepts - 31
  CLOSED: [2021-01-03 Sun 03:16]
  This chapter covers *concepts* that APPEAR IN ALMOST EVERY programming language
  and how they work in Rust.
    Many programming languages have much in common at their core. _NONE of the
  concepts presented in this chapter are unique to Rust_, but we'll _discuss them
  in the context_ of Rust and explain the conventions around using these concepts.
    
  - Specifically, you'll learn about
    * variables
    * basic types
    * functions
    * comments
    * control flow

    These foundations will be in every Rust program, and learning them early
    will give you a strong core to start from.

  - *Keywords* See Appendix A =TODO=
    
** DONE Variables and Mutability - 32
   CLOSED: [2021-01-02 Sat 14:02]
*** DONE Differences Between Variables and Constants - 34
    CLOSED: [2021-01-02 Sat 13:54]
    - Rust has ~const~ keyword.

    - /Constants/ *must be* /immutable/.

    - The /type/ of /constant/ (declared with ~const~) *must be* annotated.

    - /Constants/ can be declared in any /scope/, including the /global scope/.

    - A /constant/ can ONLY be set to a /constant expression/,
      (=from Jian= I use *ONLY* here, and WHY does this book use *may be*???)
      NOT
      * the result of a function call
        or
      * any other value that could only be computed at runtime.

    - Example:
      #+begin_src rust
        const MAX_POINTS: u32 = 100_000;
      #+end_src

    - /Constants/ are *valid*
      * for the entire time a program runs,
      * within the scope they were declared in,
        
      making them a useful choice for values in your application domain that
      multiple parts of the program might need to know about

    - Naming hardcoded values used throughout your program as /constants/ is useful
      in _conveying the meaning of that value to future maintainers of the code._
      
*** DONE Shadowing - 34
    CLOSED: [2021-01-02 Sat 14:02]
    _I think the /shadowing/ feature is BAD._

    - Shadowing is different from ~mut~.
      * It actually create a new variable (~mut~ or not).
        Since it is NEW, it can have a DIFFERENT /type/.

    =From Jian=
    From my point of view, the only natural way of shadowing is in embeded scope.
    I don't want to see shadowing happend in a flat structure, though it is actually
    a new scope -- start from the point that the shadowing happens.

** DONE Data Types - 36
   CLOSED: [2021-01-03 Sun 01:59]
   Look at two data type subsets: /scalar/ and /compound/.
   
*** DONE Scalar Types - 36
    CLOSED: [2021-01-03 Sun 00:32]
    - /scala type/ :: A type represents a single value.

    - _FOUR_ primary /scalar types/ in Rust:
      + integers
      + floating-point numbers
      + Booleans
      + characters

**** DONE Integer Types
     CLOSED: [2021-01-03 Sun 00:32]
     - integer :: a number WITHOUT a fractional component.

     - Each variant can be either /signed/ or /unsigned/ and has an explicit size.

     - Table 3-1: Integer Types in Rust
       | Length  | Signed | Unsigned |
       |---------+--------+----------|
       | 8-bit   | i8     | u8       |
       | 16-bit  | i16    | u16      |
       | 32-bit  | i32    | u32      |
       | 64-bit  | i64    | u64      |
       | 128-bit | i128   | u128     |
       | arch    | isize  | usize    |

     - Each signed variant range: -(2 ^ (n-1)) to (2 ^ (n-1)) - 1 inclusive.

     - Each unsigned variant can store numbers from 0 to 2^n - 1

     - Signed numbers are stored using /two's complement/ representation.

     - ~isize~ and ~usize~ depend on the architectures:
       32-bit for 32-bit architecture;
       64-bit for 64-bit architecture.

     - All number literals _except the byte literal_ allow a /type suffix/, for
       example: ~57u8~

     - ~_~ as a visual separator, such as ~1_000~. You can put the ~_~ anywhere
       in numbers.

     - Table 3-2: Integer Literals in Rust
       | Number literals | Example       |
       |-----------------+---------------|
       | Decimal         | ~98\under222~      |
       | Hex             | ~0xff~        |
       | Octal           | ~0o77~        |
       | Binary          | ~0b1111\under0000~ |
       | Byte(~u8~ only) | ~b'A'~        |

     - If you don't know which type of integer to use,
       use the default ~i32~. _It is generally the fastest, even on 64-bit systems._

     - The primary situation in which you'd use ~isize~ or ~usize~ is when
       indexing some sort of collection.
       =From Jian= This sounds like the ~size_t~ type in C.

     - *Integer Overflow*
       - Compile in *debug mode*,
         Rust includes checks for /integer overflow/ that cause your program to
         panic at runtime if this behavior occurs.
         * =TODO= "Unrecoverable Errors with panic!" section in Chapter 9.

       - Compile in *release mode* with the ~--release~ flag,
         1. Rust does _not include checks_ for /integer overflow/ that cause
            /panics/.
         2. Instead, if overflow occurs, Rust performs /two's complement wrapping/.
            * The program won't /panic/,
              BUT the variable will have a value that probably isn't what you
              were expecting it to have.

            * *Relying on integer overflow's wrapping behavior is considered an error.*
              If you want to _wrap EXPLICITLY_, you can use the /standard library
              type/ ~Wrapping~.

**** DONE Floating-Point Types
     CLOSED: [2021-01-03 Sun 00:32]
     ~f32~ (IEEE-754 single-precision) and ~f64~ (IEEE-754 double-precision).

     - *By default* the /floating type/ is ~f64~
       because
       on modern CPUs it's *roughly the same speed* as ~f32~
       but is capable of _more precision_.
       
     - Example:
       #+begin_src rust
         fn main() {
             let x = 2.0; // f64
             let y: f32 = 3.0; // f32
         }
       #+end_src

**** DONE Numeric Operations
     CLOSED: [2021-01-03 Sun 00:32]
     ~+~, ~-~, ~*~, ~/~, ~%~
     Read Appendix B.

**** DONE The Boolean Type
     CLOSED: [2021-01-03 Sun 00:32]
     Type name ~bool~. Its values: ~true~ and ~false~.

**** DONE The Character Type
     CLOSED: [2021-01-03 Sun 00:32]
     In Rust, ~char~ type values are /Unicode Scalar Values/.
     Range: from =U+0000= to =U+D7FF= and =U+E000= to =U+10FFFF= inclusive.

     - However, a "character" is NOT really a concept in Unicode, so your human
       intuition for what a "charactr" is may NOT match up with what a ~char~ is
       in Rust.
       =TODO=
       Discuss this topic in detail in "Strong UTF-8 Encoded Text with Strings"
       in Chapter 8

*** DONE Compound Types - 40
    CLOSED: [2021-01-03 Sun 01:59]
**** DONE The Tuple Type
     CLOSED: [2021-01-03 Sun 01:15]
    - ~let tup: (i32, f64, u8) = (500, 6.4, 1);~
      * Pattern matching is a good way to extract value(s) from a tuple.
        ~let (x, y, z) = tup;~

      * ~.~ syntax
        ~tup.0~ is ~500~.

**** DONE The Array Type
     CLOSED: [2021-01-03 Sun 01:59]
     Rust /arrays/ have a fixed length: once declared, they CANNOT grow or shrink
     in size.
     ~let a: [i32; 5] = [1, 2, 3, 4, 5];~

     - /Arrays/ are useful
       * when you want your data allocated on the /stack/ _rather than_ the
         /heap/ (=TODO= we will discuss the /stack/ and the /heap/ more in
         Chapter 4),
         or
       * when you want to ensure you always have a fixed number of elements.

     - /Arrays/ are not as flexible as /vectors/.
       If you're unsure whether to use an /array/ or a /vector/, you should probably
       use a /vector/.
       =TODO= Chapter 8 discusses /vectors/ in more detail.

     - Create an array that contains the _same_ value for EACH element:
       ~let a = [3; 5];~
       
***** DONE Accessing Array Elements
      CLOSED: [2021-01-03 Sun 01:59]
      An /array/ is a SINGLE chunk of memory allocated on the /stack/.
      
      - Acces elements of an /array/ using /indexing/, ~a[0]~.
      
***** DONE Invalid Array Element Access
      CLOSED: [2021-01-03 Sun 01:59]
      - When this happens,
        Generally speaking, compilation wouldn't produce any errors,
        * BUT when the index info can be known at compile time, errors can be
          reported.

        * When the index info is unknown at compile time (most cases), Rust will
          /panic/ at runtime.
          
      - /panic/ :: a program exits with an error.

      - =TODO= Chapter 9 error handling.
        
      - In many low-level languages, such as C, this kind of check is NOT done.
        
** DONE Functions - 43
   CLOSED: [2021-01-03 Sun 02:30]
   - Rust function name convention: /snake case/.

   - /snake case/: all letters are lowercase and underscores separate words.

*** DONE Function Parameters - 44
    CLOSED: [2021-01-03 Sun 02:04]
    - Technically, the concrete values are called /arguments/.

    - In casual conversation people tend to use the words "parameter" and
      "argument" interchangeably.

    - In /function signatures/, you *must* declare the /type/ of EACH /parameter/.

    - Example:
      #+begin_src rust
        // src/main.rs
        fn main() {
            another_function(5, 6);
        }

        fun another_function(x: i32, y: i32) {
            println!("The value of x is: {}", x);
            println!("The vlaue of y is: {}", y);
        }
      #+end_src

*** DONE Function Bodies Contain Statements and Expressions - 45
    CLOSED: [2021-01-03 Sun 02:24]
    - /Function bodies/ are made up of a series of /statements/ OPTIONALLY ENDING
      in an /expressions/.

    - Because Rust is an /expression-based language/,
      the distinction between /statements/ and /expressions/ is IMPORTANT.

    - /statements/ :: instructions that perform some action and do not return a
                      value.

    - /expressions/ :: evaluate to a resulting value.

    - Calling a _function_ is an expression.

    - Calling a _macro_ is an expression.

    - =IMPORTANT=
      Different from many other languages, a /Rust statement/ does *NOT* have
      /return value/.
      * The ~let x = (let y = 6);~ is *illegal*.
        In many other languages, a similar /statement/ is illegal.
        + In C (Ruby is similar), both ~x~ and ~y~ are ~6~.
          =from Jian= I don't like this way.
          #+begin_src c
            #include <stdio.h>

            int main(void) {
              int y = 4;
              int x = (y = 6);
              printf("x = %d, y = %d\n", x, y);
            }
          #+end_src

        + In Scala, ~x~ is ~()~, a ~Unit~ value. _This is reasonable._
          #+begin_src scala
            var y = 4

            val x = (y = 6)
            // x: Unit = ()
            // y: Int = 6
          #+end_src

    - The _block_ that we use to *create new* /scopes/, ~{}~, is an /expression/.
      #+BEGIN_SRC rust
        let y = {
            let x = 3;
            x + 1
        };
      #+END_SRC

    - =IMPORTANT= =CRITICAL=
      /Expressions/  *MUSTN'T* include ending semicolons.
        If you add a semicolon to the end of an /expression/, you turn it into a
      /statement/, which _will then NOT return a value_.
      
*** DONE Functions with Return Values - 47
    CLOSED: [2021-01-03 Sun 02:28]
    Anotate the /return value type/ of a function:
    #+begin_src rust
      fn plus_one(x: i32) -> i32 {
          x + 1
          // NO ;
      }

      fn main() {
          let x = plus_one(5);
          println!("The value of x is: {}", x);
      }
    #+end_src

    - GOOD NEWS:
      If you add a ~;~ after the ~x + 1~ in ~plus_one~,
      since no /return value/ from a /statement/, you will see a compile error
      of "mismatch types", and a suggestion:
      =- help: consider removing this semicolon=

** DONE Comments - 49
   CLOSED: [2021-01-03 Sun 02:30]
   ~//~
   
   - Rust also has _another kind_ of /comment/, /documentation comments/,
     =TODO=
     which we'll discuss in the “Publishing a Crate to Crates.io” section of
     _Chapter 14_.
     
** DONE Control Flow - 49
   CLOSED: [2021-01-03 Sun 03:15]
*** DONE ~if~ Expressions - 49
    CLOSED: [2021-01-03 Sun 02:45]
    #+begin_src rust
      if number < 5 {
          println!("condition was true");
      } else {
          println!("condition was false");
      }
    #+end_src

    The _branches_ of a ~if ... else~ structure is also called /arms/.
    Just like the /arms/ in ~match~ /expression/.

**** DONE Handling Multiple Conditions with ~else if~
     CLOSED: [2021-01-03 Sun 02:39]
     In many cases,
     to avoid cluter your code with too many ~else if~ expressions,
     ~match~ is a better way.
     
     =TODO= CHAPTER 6 describes ~match~.
     
**** DONE Using ~if~ in a ~let~ statement
     CLOSED: [2021-01-03 Sun 02:45]
     Because ~if~ is an /expression/,
     we can use it on the right side of a ~let~ /statement/.

     - In this way, all /arms/ *must* have the *same* /type/.
     
*** DONE Repetition with Loops - 54
    CLOSED: [2021-01-03 Sun 03:15]
    Rust has _THREE_ kinds of /loops/:
    - ~loop~
    - ~while~
    - ~for~
    
**** DONE Repeating Code with ~loop~
     CLOSED: [2021-01-03 Sun 02:49]
     ~loop~ is like the ~while(true)~ in the C programming language.

     - Use ~break~ to quite programmatically.

     - Use =^C= (Ctrl-C) to quite in terminal at runtime.

**** DONE Returning Values from Loops
     CLOSED: [2021-01-03 Sun 02:52]
     #+begin_src rust
       fn main() {
           let mut counter = 0;

           let result = loop {
               counter += 1;

               if counter == 10 {
                   break counter * 2;
               }
           };

           println!("The result is {}", result);
       }
     #+end_src

     - =from Jian=
       This is a feature that is different from other languages.
     
**** DONE Conditional Loops with ~while~
     CLOSED: [2021-01-03 Sun 02:54]
     #+begin_src rust
       while number != 0 {
           println!("{}!", number);
    
           number -= 1;
       }
     #+end_src

     - ~while~ could be implemented using a combination of ~loop~, ~if~,
       ~else~, and ~break~; you could try that now in a program, if you'd like.
         However, this pattern is so common that Rust has a built-in language
       construct for it. This pattern is eliminate a lot of nesting that would
       be necessary if you used ~loop~, ~if~, ~else~, and ~break~, and it's
       CLEARER.
       
**** DONE Looping Through a Collection with ~for~
     CLOSED: [2021-01-03 Sun 03:15]
     #+begin_src rust
       fn main() {
           let a = [10, 20, 30, 40, 50];

           for element in a.iter() {
               println!("the value is: {}", element);
           }
       }
     #+end_src

     We prefer ~for~ to ~while~. We use ~for~ to *iterate* a collection of data,
     and no index boundary check is needed.

     - The *safety* and *conciseness* of ~for~ /loops/ make them the _most commonly
       used_ /loop/ construct in Rust.
       * Even in situations in which you want to run some code a certain number
         of times, as in the countdown example that used a ~while~ loop, most
         Rustaceans would use a ~for~ loop, combined with ~Range~.
         #+begin_src rust
           fn main() {
               for number in (1..4).rev() {
                   println!("{}!", number);
               }
               println!("LIFTOFF!!!");
           }
         #+end_src
       
** DONE Summary - 57
   CLOSED: [2021-01-03 Sun 03:16]
   
* DONE 4. Understanding Ownership - 59
  CLOSED: [2021-01-05 Tue 15:51]
  /ownership/ is the *MOST UNIQUE feature* of Rust,
  and
  it enables Rust to make
  /memory safety/ guarantees _without_ needing a /garbage collector/.

  This chapter will talk about several related features:
  - /ownership/
  - /borrowing/
  - /slice/
  - how Rust lays data out in memory.

** DONE What is Ownership? - 59
   CLOSED: [2021-01-04 Mon 03:27]
   - ~ownership~ is the central feature of Rust.

   - _Most languages_ can be grouped to _TWO_ categories
     if considering _the ways they manage memory_:
     + With garbage collector
     + Explicitly call _allocate_ and _deallocate (free)_ operations to manage
       the memory.

   - HOWEVER,
     Rust is different from these two categories -- it has its own approach to
     manage memory:
       Memory is managed through a system of /ownership/ with a set of rules that
     the compiler checks at compile time.
     * _NO run-time costs_ are incurred for ANY of the /ownership/ features.

   - =TODO=
     This chapter we work through some examples to learn how /ownership/
     works. The examples focus on a very common data structure:
     *strings*.

   - *The Stack and the Heap*
     - In a systems programming language like Rust, whether a value is on the
       /stack/ or the /heap/ has _more of an effect on_
       * HOW the language behaves
       * WHY we have to make certain decision.

     - Here is a brief explanation in preparation
       (We'll describe parts of /ownership/ in relation to the /stack/ and the
        /heap/ _later_ in this chapter).

       * Both the /stack/ and the /heap/ are parts of /memory/ that is available
         to your code _at runtime_.

       * /stack/ -- LIFO.
         /push on to/ and /pop off/

       * Use the data in /stack/ is fast:
         + no need to search (top frame(s))
         + fixed size

       * The process of get space from /heap/ is called /allocating on the heap/.

       * /pointers/ (rather than the data it points to, some of which can be
         fixed size but not all) are known and have *fixed size*. They can be
         stored on the /stack/.

       * Keeping track of what parts of code are using what data on the /heap/,
         _minimizing the amount of duplicate data_ on the /heap/,
         and /cleaning up/ unused data on the /heap/ so we don't run out of space
         are all problems that /ownership/ addresses.
         =IMPORTANT=

         Once you understand /ownership/, you won't need to think about the /stack/
         and the /heap/ very often, but knowing that managing /heap/ data is why
         /ownership/ exists can help explain why it works the way it does.

*** DONE Ownership Rules - 61
    CLOSED: [2021-01-03 Sun 03:31]
    =FIXME= ordered list

    1. _EACH_ value in Rust has a variable that's called its /owner/.
       (/owner/ is one variable)

    2. There can ONLY be ONE /owner/ at a time.

    3. When the /owner/ goes _out of /scope/,_ the value will be *dropped*.

*** DONE Variable Scope - 61
    CLOSED: [2021-01-03 Sun 03:31]
    As in C/C++, the boundaries of a /scope/ is marked with a pair of curly braces.
    
    =NEXT= Now we'll build on top of this understanding by introducing the ~String~ type.
    
*** DONE The ~String~ Type - 62
    CLOSED: [2021-01-03 Sun 03:40]
    To illustrate the rules of /ownership/, we need data that stored on the
    /heap/. The data type we mentioned in Chapter 3 are all stored on the
    /stack/ (they will be popped off the /stack/ when their scope is over, NO
    need for /ownership/).

    - /String literals/ are NOT enough.
      /String literals/ are *immutable*, and they have *known size* (of course,
      "literal" indicates they are _hard coded_, and _hard coded_ things are
      ALWAYS of known sizes).

      * Q :: What if we want _immutable_, and _unknow size_ space to store a
             sequence of characters?
      * A :: Then we need ~String~ variables.
             Another /string type/ provided by Rust.
               This type is allocated on the /heap/ and as such is able to store
             an amount of text that is _unknown to us at /compile time/._

    - WHY ~String~ CAN be mutated but literals CANNOT?
      #+BEGIN_SRC rust
        let mut s = String::from("hello");
        s.push_str(", world!");
        println!("{}", s);  // This will print "hello, world!"
      #+END_SRC

      _The difference is how these two types deal with memory._

    - The ~::~ syntax will be discussed more
      in "Method Syntax" section of _Chapter 5_ and
      when we talk about namespacing with modules in
      "Paths for Referring to an item in the Module Tree" in _Chapter 7_.

*** DONE Memory and Allocation - 63
    CLOSED: [2021-01-04 Mon 03:20]
    - Q :: WHY /string literals/ are immutable?
    - A :: All the info about /string literals/ are fixed, they are hardcoded
           directly into the final executable (saved in the /stack/), _making
           /string literals/ *fast* and *efficient*._
      * These properties only come from its /immutability/.

    - With the ~String~ /type/,
      IN ORDER TO support a /mutable/, /growable/ piece of text,
      we need to *allocate* an amount of /memory/ on the /heap/:
      * allocation :: The /memory/ must be requested from the operating system
                      _at runtime_.

      * /deallocation/ :: We need a way of *returning* this /memory/ to the operating
                          system when we're done with our ~String~.

    - /allocation/ is done when we call ~String::from~.
      This is pretty much universal in programming languages.

    - /deallocation/ is different in different languages.
      + Some languages use GC.

      + Without GC, it is usually hard
        * if we forget, we'll waste memory -- _memory leak_.

        * if we do it too early, we'll have an invalid variable. =TODO= segFault???

        * if we do it twice (or more), that's a bug too.

    - We need to _PAIR_
      *exactly one* ~allocate~ with *exactly one* ~free~.

    - Rust does NOT use GC, but it also takes a different path from the tradition
      way of explicitly using /allocation/ and /deallocation/:
        the /memory/ is AUTOMATICALLY returned once the variable that owns it goes
      _out of /scope/._
      * Rust *automatically* calls the special function ~drop~ and *implicitly* at
        the closing ~}~.

    - Note: =TODO= =LEARN from C++=
      In C++, this pattern of deallocating resources at the end of an item's
      /lifetime/ is sometimes called /Resource Acquisition Is Initialization (RAII)/.
        The ~drop~ function in Rust will be familiar to you if you've used RAII
      patterns in C++.

    - =IMPORTANT=
      The Rust way _seems simple_,
      BUT it can be _unexpected in more complicated situations_
      when we want to have multiple variables use the data we've allocated on
      the /heap/.

**** DONE Ways Variables and Data Interact: /Move/
     CLOSED: [2021-01-04 Mon 03:07]
     #+BEGIN_SRC rust
       let s1 = String::from("hello");
       let s2 = s1;
     #+END_SRC

     - A ~String~ basic info is made up of three parts:
       * a /pointer/ to the (/heap/) memory that _holds_ the contents of the string
       * a /length/
       * a /capacity/

       This group of data is stored on the /stack/.

     - /length/ :: how much memory, in bytes, the contents of the ~String~ is
                   currently using.

     - /capacity/ :: the total amount of memory, in bytes, that the ~String~ has
                     received from the OS.

     - When we _assign_ ~s1~ to ~s2~, the ~String~ info data is copied, meaning
       we copy the /pointer/, the /length/, and the /capacity/ that are on the
       /stack/.

       _We do *NOT copy* the data on the /heap/ that the /pointer/ refers to._

     - For the discussion about the above example till now,
       if ~drop~ is naive, there will be a /double free error/, and it is one of
       the memory safety bugs.
       * Rust does one extra thing, it invalidate ~s1~ after ~s2 = s1;~.

     - /move/ :: when do operations like assignment,
       1. copy the meta info of this varaible (/pointer/ combined with other info)
          that is on /stack/;
       2. invalidate the old one on /stack/.

     - CAUTION:
       Here we discuss /move/, which is unrelated to the stack-only data.

     - The step 1 in /move/ is just like the "shallow copy", a concept we learn
       in almost all languages,
       BUT now we also have the step 2, that's why we have this new concept /move/.

     - In addition, there’s a design choice that's implied by this:
       * Rust will _NEVER automatically_ create “deep” copies of your data.
         
       Therefore, in Rust, any _automatic copying_ can be assumed to be
       *inexpensive* in terms of runtime performance.

**** DONE Ways Variables and Data Interact: /Clone/
     CLOSED: [2021-01-04 Mon 03:10]
     If you do want to *copy the heap data* of a an object,
     like the ~String~ in the above example:
     #+BEGIN_SRC rust
       let s1 = String::from("hello");
       let s2 = s1.clone();

       println!("s1 = {}, s2 = {}", s1, s2);
     #+END_SRC

     - This is called /clone/, which might be _expensive_ -- the implementation of
       ~clone~ can be arbitrary code.

     - ~clone~ is a visual indicator that something different is going on.

**** DONE Stack-Only Data: /Copy/
     CLOSED: [2021-01-04 Mon 03:20]
     #+BEGIN_SRC rust
       let x = 5;
       let y = x;

       println!("x = {}, y = {}", x, y);
     #+END_SRC

     - No compile error, ~x~ is still valid in the ~println!~ line.

     - Values of types like integer are stored on /stack/.
       Copy a value in /stack/ is *NOT expensive* (even in the /move/ operation,
       we copy the data in /stack/ which is cheap, we just DID NOT copy the data
       in /heap/ which can be expensive).
       Thus, NO reason to prevent ~x~ from being valid after we create ~y~.

     - ~Copy~ trait:
       * If a type has the ~Copy~ trait, an older variable is still valid after
         assignment.

       * Rust WON'T let us annotate a type with the ~Copy~ /trait/ if the type,
         or any of its parts, has implemented the ~Drop~ /trait/ -- the
         _exclusive property_ between the ~Copy~ /trait/ and the ~Drop~ /trait/.

       * If
         1. a type needs something special to happen when the value goes out of scope
         2. we add ~Copy~ annotation to that /type/, we'll get a /compile time error/.

         =TODO= see Appendix C on _Derivable Traits_ to learn about how to add the
         ~Copy~ annotation to your type.

     - As a general rule, any group of _simple_ /scalar values/ can be ~Copy~.
       =from Jian=
       See below, the /tuples/ case, you will know what does this _simple_ mean.

     - Examples of the types that are ~Copy~:
       * All integer types
       * The boolean type
       * All floating point types
       * Tuples, but ONLY if they contain types that are also ~Copy~:
         Values of type ~(i32, i32)~ are ~Copy~.
         Values of type ~(i32, String)~ are _NOT_.

*** DONE Ownership and Functions - 68
    CLOSED: [2021-01-04 Mon 03:22]
    The semantics for *passing a value to a function* are SIMILAR TO
    *assigning a value to a variable* -- /move/ or /copy/.

*** DONE Return Values and Scope - 68
    CLOSED: [2021-01-04 Mon 03:27]
    /Returning values/ can also *transfer* /ownership/.

    - Example:
      #+begin_src rust
        fn main() {
            let s1 = gives_ownership();         // gives_ownership moves its return
                                                // value into s1

            let s2 = String::from("hello");     // s2 comes into scope

            let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                                // takes_and_gives_back, which also
                                                // moves its return value into s3
        } // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
          // moved, so nothing happens. s1 goes out of scope and is dropped.

        fn gives_ownership() -> String {             // gives_ownership will move its
                                                     // return value into the function
                                                     // that calls it

            let some_string = String::from("hello"); // some_string comes into scope

            some_string                              // some_string is returned and
                                                     // moves out to the calling
                                                     // function
        }

        // takes_and_gives_back will take a String and return one
        fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                              // scope

            a_string  // a_string is returned and moves out to the calling function
        }
      #+end_src

    - If we pass the value of a variable into a function and we still want to use
      this value after this call, we can return this value back:
      #+BEGIN_SRC rust
        fn main() {
            let s1 = String::from("hello");

            let (s2, len) = calculate_length(s1);

            println!("The length of '{}' is {}.", s2, len);
        }

        fn calculate_length(s: String) -> (String, usize) {
            let length = s.len(); // len() returns the length of a String.

            (s, length)
        }
      #+END_SRC
      *However, this is tedious.
      Luckily for us, Rust has a feature called /references/.*

** DONE References & Borrowing - 70
   CLOSED: [2021-01-05 Tue 00:10]
   The last example of the last section, with the help of /reference/:
   #+begin_src rust
     fn main() {
         let s1 = String::from("hello");
         let len = calculate_length(&s1);
         println!("The length of '{}' is {}.", s1, len);
     }

     fn calculate_length(s: &String) -> usize {
         s.len()
     }
   #+end_src

   - These _ampersands_ above are /references/.

   - *NOTE*:
     The opposite of referencing by using ~&~ is /dereferencing/, which is
     accomplished with the /dereference operator/, ~*~.
     =TODO=
     We'll see _some uses of the /dereference operator/ in Chapter 8_ and
     _discuss details of /dereferencing/ in Chapter 15._

   - A /reference/ is essentially a pointer points to the basic info data (a
     pointer, string length, and its capacity) of ~s1~.

   - The name /reference/ indicates _NOT OWN_.
     NO ~drop~ will be applied to the data it refers to when ~s~ goes out of
     scope.
       On the other hand, since /pointers/ are on /stack/, they will be poped
     out automatically.

   - We call _having references as function parameters_ /borrowing/ -- when it's
     done, give it back.

   - If you try to _MODIFY_ the /borrowed value/, the compiler will issue an error
     =error: cannot borrow immutable borrowed content `*some_string` as mutable=
     Just as variables are _immutable BY DEFAULT_, so are /references/.

*** DONE Mutable References - 72
    CLOSED: [2021-01-04 Mon 23:48]
    #+BEGIN_SRC rust
      fn main() {
          let mut s = String::from("hello");
          change(&mut s);
      }

      fn change(some_string: &mut String) {
          some_string.push_str(", world");
      }
    #+END_SRC

    =IMPORATN=
    ONE big _restriction_ to /mutable references/:
    you can ONLY have _one_ /mutable reference/ to a particular piece of data
    _in a particular scope_.

    - Example of fail (CANNOT be compiled):
      =error[E0499]: cannot borrow `s` as mutable more than once at a time=
      #+BEGIN_SRC rust
        let mut s = String::from("hello");

        let r1 = &mut s;
        let r2 = &mut s;
      #+END_SRC

    - This restriction _allows for mutation BUT in a very controlled fashion_.
      * PROS: Rust can prevent /data races/ at compile time
      * CONS: new Rustaceans struggle with this restrictin -- NOT a real cons

    - A /data race/ is a particular type of race condition in which these _THREE_
      behaviors occur:
      1. Two or more /pointers/ access the same data at the same time.
      2. At least one of the /pointers/ is being used to write to the data.
      3. There's NO mechanism being used to synchronize access to the data.

    - /Data races/ cause /undefined behavior/ and can be difficult to diagnose
      and fix when you're trying to track them down at runtime;
        Rust prevents this problem from happening because it won't even compile
      code with data races!

    - As always, we can use curly brackets to create a new scope, allowing for
      multiple mutable references, just NOT simultaneous ones:
      #+BEGIN_SRC rust
        let mut s = String::from("hello");

        {
            let r1 = &mut s;
        } // r1 goes out of scope here, so we can make a new reference with no problems.

        let r2 = &mut s;
      #+END_SRC

    - A similar rule exists for combining mutable and immutable references.
      #+BEGIN_SRC rust
        let mut s = String::from("hello");

        let r1 = &s;  // NO problem
        let r2 = &s;  // NO problem
        let r3 = &mut s;  // BIG PROBLEM
      #+END_SRC
      With compile the error:
      =error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable=

    - Some conclusions:
      * _A_ /mutable reference/ is EXCLUSIVE with the other /references/ (both
        mutable or immutable).

      * Any /immutable reference/ are compatible with the other /immutable
        references/.
          This is reasonable. Users of an _immutable references_ don't expect
        the value to suddenly change out from under them.

      * On the other hand, ONLY multiple /immutable references/ is ok.

    - Note that
      a /reference/'s /scope/ starts from where it is introduced and continues
      through the LAST time that /reference/ is used.
      #+begin_src rust
        let mut s = String::from("hello");

        let r1 = &s;  // no problem
        let r2 = &s;  // no problem
        println!("{} and {}", r1, r2);
        // r1 and r2 are no longer used after this point

        let r3 = &mut s;  // no problem
        println!("{}", r3);
      #+end_src
      =IMPORTANT=
      The /scopes/ of the /immutable references/ ~r1~ and ~r2~ end after the
      ~println!~ _where they are LAST used_, which is BEFORE the /mutable reference/
      ~r3~ is created. *These scopes _don't overlap_, so this code is allowed.*

*** DONE Dangling References - 74
    CLOSED: [2021-01-05 Tue 00:10]
    - In languages with /pointers/, it's easy to erroneously create a /dangling
      pointer/.

    - /a dangling pointer/ ::
      a /pointer/ that /references/ a location in memory that may have been given to
      someone else, by _freeing some memory while preserving a pointer to that
      memory._

    - In Rust, by contrast, the compiler *guarantees* that /references/ will never
      be /dangling references/:
      if you have a reference to some data, the compiler will ensure that the
      data will not go out of scope before the reference to the data does.

    - Example of trying to create a /dangling reference/ (but fail when compile):
      #+BEGIN_SRC rust
        fn main() {
            let references_to_nothing = dangle();
        }

        fn dangle() -> &String {
            let s = String::from("hello");
            &s
        }
      #+END_SRC

      The error message:
      #+BEGIN_SRC text
        error[E0106]: missing lifetime specifier
         --> dangle.rs:5:16
          |
        5 | fn dangle() -> &String {
          |                ^^^^^^^
          |
          = help: this function's return type contains a borrowed value, but there is no
            value for it to be borrowed from
          = help: consider giving it a 'static lifetime

        error: aborting due to previous error
      #+END_SRC

      * This error message refers to a feature /lifetimes/ which will be covered
        in Chapter 10.
        =TODO=
        Just disregard this, and read the =help= part, we can know what happened.

      * The way to correct this error:
        #+BEGIN_SRC rust
          fn no_dangle() -> String {
              let s = String::from("hello");
              s
          }
        #+END_SRC

*** DONE The Rules of References - 75
    CLOSED: [2021-01-05 Tue 00:10]
    1. At ANY given time, you can have _either but NOT both_ of:
       * *One* /mutable reference/.
       * *Any number* of /immutable references/.

    2. /References/ *must always* be valid.

    Next, we'll look at a different kind of /reference/: /slices/.
    
** DONE The Slice Type - 75
   CLOSED: [2021-01-05 Tue 15:46]
   - Another data type that does _NOT_ have /ownership/ is the /slice/.

   - /slices/ let you *reference* a /contiguous sequence of elements/
     in a collection rather than the whole collection.

   - Let's use a example to illustrate this:
     * Q ::
       WRITE a /function/ that
       TAKES a /string/ and
       RETURNS the _first word_ it finds in that /string/.
               If no space can be found, return the whole string.
               
     * A :: The signature should be like ~fn first_word(s: &String) -> ?~.
            We don't want /ownership/, so this is fine.

     * Q :: BUT what should we return?
       1. Since we don't have the /ownership/,
          we don't really have a way to talk about part of a /string/.

       2. However, we could _return the /index/ of the end of the word._
          Let's try that, as shown in Listing 4-7.
          #+begin_src rust
            fn first_word(s: &String) -> usize {
                let bytes = s.as_bytes();

                for (i, &item) in bytes.iter().enumerate() {
                    if item == b' ' {
                        return i;
                    }
                }

                s.len()
            }
          #+end_src
          + =TODO= We'll discuss /iterators/ in more detail in Chapter 13.

          + Since the returned value of ~usize~ is a separate value from the
            ~String~, there's no guarantee that it will still be valid in the
            future. *THIS IS BAD!*
            #+begin_src rust
              fn main() {
                  let mut s = String::from("hello world");
                  let word = first_word(&s);
                  s.clear();

                  // operate `s` with `word` can lead to a crash.
              }
            #+end_src

            - If we want to write a ~second_word~, the /return value type/ is
              ~(usize, usize)~, which is tedious and even more brittle.

   - =NEXT= Rust has a solution to this problem: /string slices/.
     
*** DONE String Slices - 77
    CLOSED: [2021-01-05 Tue 15:46]
    #+BEGIN_SRC rust
      let s = String::from("hello world");

      let hello = &s[0..5];
      let hello_ = &s[..5]; // for short

      let world = &s[6..11];
      let world_ = &s[6..]; // for short
    #+END_SRC

    - Note:
      /String slice/ _range indices_ *must* occur at _valid /UTF-8 character/
      boundaries_.
        If you attempt to create a /string slice/ in the middle of a multibyte
      character, your program will exit with an error. For the purposes of
      introducing /string slices/, we are assuming ASCII only in this section;
      =TODO=
      a more thorough discussion of UTF-8 handling is in the “Storing UTF-8
      Encoded Text with Strings” section of Chapter 8.

    - Then, let's re-write the ~first_word~ function ("string slice" is written
      as ~&str~):
      #+BEGIN_SRC rust
        fn first_word(s: &String) -> &str {
            let bytes = a.as_bytes();

            for (i, &item) in bytes.iter().enumerate() {
                if item == b' ' {
                    return &s[0..i];
                }
            }

            &s[..]
        }
      #+END_SRC

    - With the help of /string slice/, invalid code cannot be compiled:
      #+BEGIN_SRC rust
        fn main() {
            let mut s = String::from("hello world");
            let word = first_word(&s);
            s.clear();  // error!
            println!("the first word is: {}", word);
        }
      #+END_SRC
      * Compiler error:
        #+begin_src text
             Compiling ownership v0.1.0 (file:///projects/ownership)
          error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
            --> src/main.rs:18:5
             |
          16 |     let word = first_word(&s);
             |                           -- immutable borrow occurs here
          17 | 
          18 |     s.clear(); // error!
             |     ^^^^^^^^^ mutable borrow occurs here
          19 | 
          20 |     println!("the first word is: {}", word);
             |                                       ---- immutable borrow later used here

          error: aborting due to previous error

          For more information about this error, try `rustc --explain E0502`.
          error: could not compile `ownership`.

          To learn more, run the command again with --verbose.
        #+end_src

      * The error message is:
        #+BEGIN_SRC text
          17:6 error: cannot borrow `s` as mutable because it is also borrowed as
                      immutable [E0502]
              s.clear(); // Error!
              ^
          15:29 note: previous borrow of `s` occurs here; the immutable borrow prevents
                      subsequent moves or mutable borrows of `s` until the borrow ends
              let word = first_word(&s);
                                     ^
          18:2 note: previous borrow ends here
          fn main() {

          }
          ^
        #+END_SRC

      * Explanation to the error message:
        ~clear~ needs to truncate the ~String~, it tries to get a /mutable
        reference/, which fails due to the rule that if we have an /immutable
        reference/ to a variable, we _CANNOT_ also take a /mutable reference/.

**** DONE String Literals Are Slices
     CLOSED: [2021-01-05 Tue 15:46]
     Recall that we talked about /string literals/ being stored inside the binary.
     Now that we know about /slices/, we can properly understand /string literals/:
     ~let s = "Hello, world!";~, where the /type/ of ~s~ is ~&str~.
       It's a /slice/ pointing to that specific point of the binary. This is also
     why /string literals/ are *IMMUTABLE*; ~&str~ is an /immutable reference/.

**** DONE String Slices as Parameters
     CLOSED: [2021-01-05 Tue 15:46]
     One move improvement on ~first_word~:
     change its /type signature/
     FROM ~fn first_word(s: &String) -> &str {~
     TO ~fn first_word(s: &str) -> &str {~

     - This change *makes our API more general and useful* WITHOUT losing any
       functionality:
       #+begin_src rust
         fn main() {
             let my_string = String::from("hello world");

             // first_word works on slices of `String`s
             let word_1 = first_word(&my_string[..]);

             let my_string_literal = "hello world";

             // first_word works on slices of string literals
             let word_2 = first_word(&my_string_literal[..]);

             // since string literals *are* string slices already,
             // this works too, without the slice syntax!
             let word_3 = first_word(my_string_literal);
         }
       #+end_src
       * If we have a /string slice/, we can pass that directly.

       * If we have a ~String~, we can pass a /slice/ of the entire ~String~.
     
**** DONE Other Slices
     CLOSED: [2021-01-05 Tue 15:46]
     /String slices/, as you might imagine, are specific to /strings/.
     BUT there's a _MORE GENERAL_ /slice type/, too.
     
     - For example (arrays),
       #+begin_src rust
         let a = [1, 2, 3, 4, 5];

         let slice = &a[1..3];
       #+end_src
       * This /slice/ has the type ~&[i32]~.

       * It works the same way as /string slices/ do, by storing a /reference/ to
         the first element and a length.

       * *You'll use this kind of /slice/ for all sorts of other collections.*
         =TODO=
         We'll discuss these collections in detail when we talk about vectors in
         Chapter 8.

*** Other Slices - 81 - =START=

** DONE Summary - 81
   CLOSED: [2021-01-05 Tue 15:51]

* DONE 5. Using Structs to Structure Related Data - 83
  CLOSED: [2021-01-06 Wed 02:18]
  - ~struct~ :: a custom data type that lets us
    * *name* and
    * *package* together multiple related values that make up a meaningful group.

  - If you're familiar with an object-oriented language, a /struct/ is like an
    object's data attributes.

  - In this chapter, we'll
    * compare and contrast /tuples/ with /structs/,
      demonstrate how to use /structs/,

    * discuss how to define /methods/ and /associated functions on structs/ to
      specify behavior associated with a struct's data.

  - The /struct/ and /enum/ (which is discussed in Chapter 6 =TODO=) concepts are
    the building blocks for *creasing* NEW /types/ in your program's domain to
    take full advantage of Rust's compile time type checking.

** DONE Defining and Instantiating Structs - 83
   CLOSED: [2021-01-06 Wed 00:57]
   #+begin_src rust
     struct User {
         username: String,
         email: String,
         sign_in_count: u64,
         active: bool,
     }
   #+end_src

   - Create an /instance/ of a /struct/ by specifying concrete values for each of
     the fields. The order of fields is not important.
     #+begin_src rust
       let mut user1 = User {
           email: String::from("someone@example.com"),
           username: String::from("someusername123"),
           active: true,
           sign_in_count: 1,
       };
     #+end_src

   - Dot notation:
     * *get* the value of a /field/:
       ~user1.email~

     * if a /field/ is /mutable/:
       ~user1.email = String::from("someone-else@example.com");~
       + Note:
         the *ENTIRE* /instance/ MUST be /mutable/;
         Rust *doesn't allow* us to mark ONLY CERTAIN /fields/ as /mutable/.
         
   - Define a /function/ to create a new /struct/ with some specified values of
     /fields/:
     #+begin_src rust
       fn build_user(email: String, username: String) -> User {
           User {
               email: email,
               username: username,
               active: true,
               sign_in_count: 1,
           }
       }
     #+end_src
     =NEXT=
     We have a convention shorthand to *simpify* the assignment when /variable
     names/ match /field names/, which can help avoiding repeating the ~email~
     and ~username~ in the example above.

*** DONE Using the Field Init Shorthand when Variables and Fields Have the Same Name - 85
    CLOSED: [2021-01-05 Tue 17:17]
    If some /variables/ have the *SAME names* as /struct fields/, we can do
    /field init shorthand/ syntax
    #+begin_src rust
      fn build_user(email: String, username: String) -> User {
          User {
              email,
              username,
              active: true,
              sign_in_count: 1,
          }
      }
    #+end_src

*** DONE Creating Instances From Other Instances With Struct Update Syntax - 86
    CLOSED: [2021-01-06 Wed 00:43]
    Struct update syntax:
    
    #+begin_src rust
      // Suppose `user1` is in scope, and
      // the `active` field and `sign_in_count` of `user2` are the same as `user1`
      let user2 = User {
          email: String::from("another@example.com"),
          username: String::from("anotherusername567"),
          ..user1
      };
    #+end_src
    
    is a shorthand for
    
    #+begin_src rust
      let user2 = User {
          email: String::from("another@example.com"),
          username: String::from("anotherusername567"),
          ..user1
      };
    #+end_src
    
*** DONE Using Tuple Structs Without Named Fields to Create Different Types - 86
    CLOSED: [2021-01-06 Wed 00:51]
    - /Tuple structs/ are useful when you want to give the whole /tuple/ a name
      and make the /tuple/ be a different type _from other tuples_.
      * =from Jian=
        Especially for other /tuples/ (named or not) that have the SAME _field
        types combination_.
    
    #+begin_src rust
      struct Color(i32, i32, i32);
      struct Point(i32, i32, i32);

      // The types in the definitions of `Color` and `Point` are the same,
      // but we can use the *name* to differentiate them.
      let black = Color(0, 0, 0);
      let origin = Point(0, 0, 0);

      println!("origin x coordinate {}", origin.0);
    #+end_src

*** DONE Unit-Like Structs Without Any Fields - 87
    CLOSED: [2021-01-06 Wed 00:57]
    - /unit-like struct/
      * it behave similarly to ~()~, the /unit type/.

      * it is useful in situations such as
        WHEN you need to implement a /trait/ on some /type/,
        BUT you don't have any data you want to store in the type itself.
        =TODO= CHAPTER 10

    - *Ownership of Struct Data*
      * in the examples above, when we define a /struct/, for its /string type
        fields/, we chose ~String~ rather than ~&str~.
          This is a deliberate choice because we want instances of this /struct/
        to own all of its data and for that data to be valid for as long as the
        ENTIRE /struct/ is valid.

      * We can have /structs/ that store /references/, but then we need to specify
        /lifetimes/, but then we need to specify /lifetimes/.
        =TODO= CHAPTER 10.
        For now, we just not use reference.

** DONE An Example Program Using Structs - 88
   CLOSED: [2021-01-06 Wed 01:45]
   The evalution of a example
   #+begin_src rust
     // Ver 1
     fn main() {
         let width1 = 30;
         let height1 = 50;

         println!(
             "The area of the rectangle is {} square pixels.",
             area(width1, height1)
         );
     }

     fn area(width: u32, height: u32) -> u32 {
         width * height
     }
   #+end_src
   It would be MORE _readable_ and MORE _manageable_ to group ~width~ and
   ~height~ together.
   =from Jian=
   If not, there is possibility to pass in ~width~ and ~height~ together that
   belongs to different rectangles.
   =NEXT=

*** DONE Refactoring with Tuples - 89
    CLOSED: [2021-01-06 Wed 01:31]
    #+begin_src rust
      fn main() {
          let rect1 = (50, 30);

          println!(
              "The area of the rectangle is {} square pixels.",
              area(rect1)
          );
      }

      fn area(dimensions: (u32, u32)) -> u32 {
          dimensions.0 * dimensions.1
      }
    #+end_src
    It's better if we can have a clearer way to distinguish the _width_ and
    _height_.
    =NEXT=

*** DONE Refactoring with Structs: Adding More Meaning - 89
    CLOSED: [2021-01-06 Wed 01:32]
    #+begin_src rust
      struct Rectangle {
          width: u32,
          height: u32,
      }

      fn main() {
          let rect1 = Rectangle {
              width: 30,
              height: 50,
          };

          println!(
              "The area of the rectangle is {} square pixels.",
              area(&rect1)
          );
      }

      fn area(rectangle: &Rectangle) -> u32 {
          rectangle.width * rectangle.height
      }
    #+end_src

*** DONE Adding Useful Functionality with Derived Traits - 90
    CLOSED: [2021-01-06 Wed 01:45]
    1. If we try to *print* the /struct/ we defined with
       ~println!("rect1 is {}", rect1);~, we will receive an error message:
       #+begin_src text
         error[E0277]: the trait bound `Rectangle: std::fmt::Display` is not satisfied
       #+end_src

       Continue reading the errors, we'll find some helpful note:
    
       #+begin_src text
         = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
         = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
       #+end_src

    2. Then try ~println!("rect1 is {:?}", rect1);~, the ~{:?}~ tells this /macro
      call/ we want to use an output format called ~Debug~.
       * ~Debug~ is a /trait/ that enables us to print out our /struct/ in a way
         that is useful for developers so we can see its value while we're
         debugging our code.

    3. However, only ~{:?}~ doesn't work, because we also didn't implement it for
       our /struct/.
       #+begin_src text
         error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug`
       #+end_src
      
    4. Continue reading the errors for hint:
       #+begin_src text
         = help: the trait `std::fmt::Debug` is not implemented for `Rectangle`
         = note: add `#[derive(Debug)]` or manually implement it `std::fmt::Debug`
       #+end_src
       
    5. Let's try this:
       #+begin_src rust
         #[derive(Debug)]

         struct Rectangle {
             length: u32,
             width: u32,
         }

         fn main() {
             let rect1 = Rectangle { length: 50, width: 30 };

             println!("rect1 is {:?}", rect1);
         }
       #+end_src
       The output is =rect1 is Rectangle { width: 30, height: 50 }=

       * Use ~{:#?}~ instead of ~{:?}~, we can a different style of print:
         #+BEGIN_SRC text
           rect1 is Rectangle {
               width: 30,
               height: 50,
           }
         #+END_SRC
         
    6. Our ~area~ function is very specific. It would be helpful to tie this
       behavior more closely to our ~Rectangle~ /struct/, because it won't work
       with any other type.
       =NEXT= 
       /method/

** DONE Method Syntax - 92
   CLOSED: [2021-01-06 Wed 02:17]
   /methods/ are different from /functions/ in that they're defined within the
   context of
   * a struct
   * an enum =TODO= Chapter 6
   * a trait object =TODO= Chapter 17

   Their _FIRST parameter_ is ALWAYS ~self~, which represents the /instance/ of
   the /struct/ the /method/ is being called on.

*** DONE Defining Methods - 92
    CLOSED: [2021-01-06 Wed 02:03]
    Re-write the example in the last section, make ~area~ a /method/ of the
    ~Rectangle~ /struct/.
    
    #+begin_src rust
      #[derive(Debug)]
      struct Rectangle {
          width: u32,
          height: u32,
      }

      impl Rectangle {
          fn area(&self) -> u32 {
              self.width * self.height
          }
      }

      fn main() {
          let rect1 = Rectangle {
              width: 30,
              height: 50,
          };

          println!(
              "The area of the rectangle is {} square pixels.",
              rect1.area()
          );
      }
    #+end_src

    - ~impl~ block.

    - /Methods/ can, just like any other parameter,
      * take ownership of ~self~,
      * borrow ~self~ immutably as we've done here,
      * borrow ~self~ mutably.

    - Having a /method/ that takes /ownership/ of the /instance/ by using just
      ~self~ as the first parameter is *RARE*:
      this technique is usually used when the /method/
      1. transforms ~self~ into something else
      2. we want to *PREVENT the caller FROM using the original instance AFTER
         the transformation.*
      
      =TODO= you can imagine -- it's rare to call a method and then the passed in
      object is no longer valid. Of course, this method can return a new object
      and disable the old one (=FROM Jian= a functional way, but I doubt if this
      is often used in Rust).

    - *Where's the -> Operator?* =TODO=
      * In C++,
        if ~object~ is a /pointer/,
        there are two equivalent ways to call a /method/:
        - ~object->something()~
        - ~(*object).something()~

      * Rust does NOT have an equivalent to the ~->~ operator;
        *Rust has a feature called /automatic referencing and dereferencing/.*
        Calling /methods/ is one of the few places in Rust that has this behavior.

        + Here's how it works:
          when calling a /method/ with ~object.something()~,
          Rust AUTOMATICALLY adds in ~&~, ~&mut~, or ~*~ so ~object~ *matches* the
          /signatue/ of the /method/.
          - In other words, the following are the same: =FIXME= =broken textframe=
            * ~p1.distance(&p2);~
            * ~(&p1).distance(&p2);~

      * The first one, ~p1.distance(&p2);~, looks much cleaner.
        This *automatic referencing behavior* works because /methods/ have a CLEAR
        /receiver/ -- the type of ~self~.
        + Given the /receiver/ and name of a /method/, Rust can figure out
          definitively whether the /method/ is *reading* (~&self~), *mutating*
          (~&mut self~), or *consuming* (~self~).

        + The fact that Rust *makes /borrowing/ implicit* for /method receivers/
          is a big part of *making /ownership/ ergonomic* in practice.
          =from Jian= If not, use Rust in practice can be horrible.

*** DONE Methods with More Parameters - 94
    CLOSED: [2021-01-06 Wed 02:07]
    #+begin_src rust
      impl Rectangle {
          fn area(&self) -> u32 {
              self.width * self.height
          }

          fn can_hold(&self, other: &Rectangle) -> bool {
              self.width > other.width && self.height > other.height
          }
      }

      fn main() {
          let rect1 = Rectangle {
              width: 30,
              height: 50,
          };

          let rect2 = Rectangle {
              width: 10,
              height: 40,
          };
          let rect3 = Rectangle {
              width: 60,
              height: 45,
          };

          println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));  // true
          println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));  // false
      }
    #+end_src
    
*** DONE Associated Functions - 95
    CLOSED: [2021-01-06 Wed 02:14]
    - associated functions :: functions that don't take ~self~ as the first
      parameter.

    - =from Jian=
      I think this is the /static methods/ in the other OOP languages.
      However, in Rust, we consider /associated functions/ as /functions/, not
      /methods/.

    - /Associated functions/ are often used for constructors (=from Jian= in
      general meaning, including /factory methods/) that will return a NEW
      /instance/ of the /struct/.

    - Example:
      #+begin_src rust
        impl Rectangle {
            fn square(size: u32) -> Rectangle {
                Rectangle {
                    width: size,
                    height: size,
                }
            }
        }
      #+end_src
      Call /associated functions/ with the syntax like ~Rectangle::square(3);~

    - This /function/ is namespaced by the /struct/:
      the ~::~ syntax is used for both
      /associated functions/
      AND
      _namespaces created by modules._
      =TODO= We'll discuss /modules/ in Chapter 7.
      
*** DONE Multiple ~impl~ Blocks - 96
    CLOSED: [2021-01-06 Wed 02:16]
    Each /struct/ is allowed to have /MULTIPLE ~impl~ blocks/.

    - Of course,
      for the ~Rectangle~ example, there is _no reason to split_ the only ~impl~
      block we created, though that is valid syntax.

    - =TODO=
      We'll see a case in which /MULTIPLE ~impl~ blocks/ are useful in Chapter
      10, where we discuss /generic types/ and /traits/.
    
** DONE Summary - 96
   CLOSED: [2021-01-06 Wed 02:17]
   - =NEXT=
     Structs are NOT the only way we can create custom types:
     let's turn to Rust's _enum_ feature to add another tool to our toolbox.

* DONE 6. Enums and Pattern Matching - 97
  CLOSED: [2021-01-10 Sun 15:29]
  - enums :: a type that enumerates its possible variants.

  - This chapter will discuss:
    1. DEFINE and USE an /enum/ to show how an /enum/ can encode meaning along
       with data.

    2. EXPLORE a particularly useful /enum/, called ~Option~.

    3. LOOK AT how /pattern matching/ in the /match expression/ makes it easy to
       run different code for different values of an /enum/.
      
    4. COVER how the ~if let~ construct is another _convenient and concise_ idiom
       available to you to handle /enums/ in your code.

  - /Enums/ are a feature in many languages, but their capabilities _differ_ in
    each language.
      /Rust's enums/ are most similar to algebraic data types in functional
    languages, such as F#, OCaml, and Haskell.
    
** DONE Defining an Enum - 98
   CLOSED: [2021-01-06 Wed 13:56]
   For example, define a data type that can be used to anotate all IP v4 and
   IP v6 addresses.
   #+begin_src rust
     enum IpAddrKind {
         V4,
         V6,
     }
   #+end_src

*** DONE Enum Values - 98
    CLOSED: [2021-01-06 Wed 10:58]
    - Use the TWO variants of ~IpAddrKind~ in the syntax
      #+begin_src rust
        let four = IpAddrKind::V4;
        let six = IpAddrKind::V6;
      #+end_src
      Both values ~IpAddrKind::V4~ and ~IpAddrKind::V6~ are of the *SAME* /type/:
      ~IpAddrKind~.

    - Example:
      #+BEGIN_SRC rust
        // The definition of `IpAddrKind` is in scope

        struct IpAddr {
            kind: IpAddrKind,
            address: String,
        }

        let home = IpAddr {
            kind: IpAddrKind::V4,
            address: String::from("127.0.0.1"),
        };

        let loopback = IpAddr {
            kind: IpAddrKind::V6,
            address: String::from("::1"),
        };
      #+END_SRC

    - _Usually we *don't* use /enums/ in the way above._
      Here is a concise and practical way to use /enums/ only (with its usages):
      #+BEGIN_SRC rust
        enum IpAddr {
            V4(String),
            V6(String),
        }

        let home = IpAddr::V4(String::from("127.0.0.1"));
        let loopback = IpAddr::V6(String::from("::1"));
      #+END_SRC

      * This better than the way of composing ~enum~ and ~struct~ together:
        + more concise
        + No limitations about the address info
          - Since ipv4 always have four numeric components that will have values
            between 0 and 255, we want to store ~V4~ addresses as four ~u8~ values,
            and keep the ~V4~ addresses as one ~String~ value.
              This is not applicable if we use ~struct~:
            #+begin_src rust
              // Illegal syntax, just a illustration.
              struct IpAddr {
                  kind: IpAddrKind,
                  address: if kind is V6 then String else (u8, u8, u8, u8),
              }
            #+end_src
            
            /Enums/ can handle this case with ease:
            #+begin_src rust
              // We can do
              enum IpAddr {
                  V4(u8, u8, u8, u8),
                  V6(String),
              }

              let home = IpAddr::V4(127, 0, 0, 1);
              let loopback = IpAddr::V6(String::from("::1"));
            #+end_src

      * The standard library ~std::new~ has a /enum/ ~IpAddr~, its definition is:
        #+BEGIN_SRC rust
          struct Ipv4Addr {
              // details elided
          }

          struct Ipv4Addr {
              // details elided
          }

          enum IpAddr {
              V4(Ipv4Addr),
              V6(Ipv6Addr),
          }
        #+END_SRC
        The standard library also define a specific ~struct~ for ~Ipv6Addr~ to
        make sure its content is legal for the ipv6 standard.

    - Another example:
      #+BEGIN_SRC rust
        // Use `enum`, all variants have the same type.
        // Write a function with this type of parameter(s) is simple.
        enum Message {
            Quit,  // no data
            Move { x: i32, y: i32 },  // include an anonymous struct
            Write(String),  // a single `String`
            ChangeColor(i32, i32, i32),  // include three `i32` values
        }

        // If we use `struct`'s. There will be four types.
        //   It's hard to define a function to take any of these kinds of messages
        // as we could easily do with the `Message` enum.
        struct QuitMessage; // unit struct
        struct MoveMessage {
            x: i32,
            y: i32,
        }
        struct WriteMessage(String); // tuple struct
        struct ChangeColorMessage(i32, i32, i32); // tuple struct
      #+END_SRC

    - There is one _more similarity_ between /enums/ and /structs/:
      we're also able to define /methods/ on /enums/.
      * Here's a /method/ named ~call~ that we could define on our ~Message~ /enum/:
        #+begin_src rust
          impl Message {
              fn call(&self) {
                  // method body would be defined here
              }
          }

          let m = Message::Write(String::from("hello"));
          m.call();
        #+end_src

*** DONE The ~Option~ Enum and Its Advantages Over Null Values - 101
    CLOSED: [2021-01-06 Wed 13:56]
    A case study:
    the ~Option~ enum in the standard library.

    As Tony Hoare, the inventor of null, mentioned, introduce /null/ to programming
    languages is a big mistake. However, the concept that /null/ is trying to
    express is still a useful one: a /null/ is a value that is currently invalid
    or absent for some reason. A new design is required! Here it is in Rust:
    #+BEGIN_SRC rust
      // Defined in the standard library (the prelude).
      // NO `Option::` prefix required.
      enum Option<T> {
          Some(T),
          None,
      }
    #+END_SRC
    - It is so useful that it's even included in the /prelude/.
      So do its variants -- no need to use ~Option::~ prefix to reference them.

    - The ~<T>~ part, /generics/, =TODO= Chapter 10

    - If we use ~None~ rahter than ~Some~, we need to tell Rust what type of
      ~Option<T>~ we have, because the compiler _CANNOT_ infer the type that the
      type that the ~Some~ variant will hold by looking only at a ~None~ value.

    - Discussion about WHY the ~Option<T>~ is better than ~null~.

** DONE The ~match~ Control Flow Operator - 104
   CLOSED: [2021-01-06 Wed 14:19]
   =TODO= Chapter 18 will cover all the different kinds of patterns and what they do.

   - Example:
     #+begin_src rust
       enum Coin {
           Penny,
           Nickel,
           Dime,
           Quarter,
       }

       fn value_in_cents(coin: Coin) -> i32 {
           match coin {
               Coin::Penny   => 1,
               Coin::Nickel  => 5,
               Coin::Dime    => 10,
               Coin::Quarter => 25,
           }
       }
     #+end_src
     
     * Curly braces is only used when you want multiple lines in a match arm.
       #+begin_src rust
         fn value_in_cents(coin: Coin) -> i32 {
             match coin {
                 Coin::Penny   => {
                     println!("Lucky penny!");
                     1
                 },  // This , is optional
                 Coin::Nickel  => 5,
                 Coin::Dime    => 10,
                 Coin::Quarter => 25,
             }
         }
       #+end_src
       =TODO=
       =from Jian=
       I'm not sure the reason why the ~,~ is optional when curly braces is there
       in the => RHS of a /match arm/.

*** DONE Patterns that Bind to Values - 106
    CLOSED: [2021-01-06 Wed 14:13]
    #+begin_src rust
      #[derive(Debug)] // So we can inspect the state in a minute
      enum UsState {
          Alabama,
          Alaska,
          // --snip--
      }

      enum Coin {
          Penny,
          Nickel,
          Dime,
          Quarter(UsState),
      }

      fn value_in_cents(coin: Coin) -> i32 {
          match coin {
              Coin::Penny          => 1,
              Coin::Nickel         => 5,
              Coin::Dime           => 10,
              Coin::Quarter(state) => {
                  println!("State quarter from {:?}!", state);
                  25
              }
          }
      }
    #+end_src

*** DONE Matching with ~Option<T>~ - 107
    CLOSED: [2021-01-06 Wed 14:16]
    =From Jian=
    In other languages, /pattern matching/ is NOT the best (the most concise)
    way to process ~Option<T>~ type values when there is a chaining call on it
    -- too verbose.

    #+begin_src rust
      fn plus_one(x: Option<i32>) -> Option<i32> {
          match x {
              None    => None,
              Some(i) => Some(i + 1),
          }
      }

      let five = Some(5);
      let six = plus_one(five);
      let none = plus_one(None);
    #+end_src

*** DONE Matches Are Exhaustive - 108
    CLOSED: [2021-01-06 Wed 14:17]
    Rust Compiler has /exhaustive check/ for pattern matching.
    Non-exhaustive result in an error, rather than warning as in other languages.
    #+begin_src rust
      fn plus_one(x: Option<i32>) -> Option<i32> {
          match x {
              Some(i) => Some(i + 1),
          }
      }

      // error[E0004]: non-exhaustive patterns: `None` not covered.
      //  -->
      //   |
      // 6 |         match x {
      //   |               ^ pattern `None` not covered
    #+end_src
    
    - =from Jian= =TODO=
      There should be a walkaround as in other languages, right?

*** DONE The ~_~ Placeholder - 108
    CLOSED: [2021-01-06 Wed 14:18]
    ~_~ is a pattern that can match all values, and it ALWAYS shows up as the
    last pattern (or other patterns can never be matched).
    #+begin_src rust
      let some_u8_value = 0u8;
      match some_u8_value {
          1 => println!("one"),
          3 => println!("three"),
          5 => println!("five"),
          7 => println!("seven"),
          _ => (),
      }
    #+end_src

** DONE Concise Control Flow with ~if let~ - 109
   CLOSED: [2021-01-06 Wed 14:22]
   The ~if let~ syntax lets you combine ~if~ and ~let~ into a less verbose way to
   handle values that match one pattern and ignore the rest.
   #+begin_src rust
     let some_u8_value = Some(0u8);
     match some_u8_value {
         Some(3) => println!("three"),
         _ => (),
     }

     // With `if let`
     if let Some(3) = some_u8_value {
         println!("three");
     }
   #+end_src
   * With ~if let~ we *lose* /exhaustive checking/, but more concise.
     Choose ~if let~ or ~match~ is a trade-off.

   + ~if let~ can have an ~else~ branch.
     #+begin_src rust
       let mut count = 0;
       match coin {
           Coin::Quarter(state) => println!("State quarter from {:?}!", state),
           _ => count += 1,
       }
     #+end_src

     Or use ~if let~ and ~else~

     #+begin_src rust
       let mut count = 0;
       if let Coin::Quarter(state) = coin {
           println!("State quarter from {:?}!", state);
       } else {
           count += 1;
       }
     #+end_src

** Summary - 110

* DONE 7. Managing Growing Projects with Packages, Crates, and Modules - 111
  CLOSED: [2021-01-10 Sun 02:29]
  As you write large programs, organizing your code will be important because
  keeping track of your entire program in your head will become impossible.
    
  - By grouping related functionality and separating code with distinct features,
    you'll clarify where to find code that implements a particular feature and
    where to go to change how a feature works.

  - The programs we've written SO FAR have been _in *one* /module/ in *one* file._
    
    1. As a project grows, you can organize code by splitting it into *multiple*
       /modules/ and then *multiple* /files/.

    2. A /package/ can contain *multiple* /binary crates/ and _OPTIONALLY_ *one*
       /library crate/.
       * As a /package/ grows, you can extract parts into SEPARATE /crates/ that
         become /external dependencies/.

  - This chapter covers all these techniques.
    For very large projects of a set of INTERRELATED /packages/ that evolve
    together, Cargo provides /workspaces/, which we'll cover in the “Cargo
    Workspaces” section in Chapter 14. =TODO=

  - Rust has a number of features that allow you to manage your code's organization,
    including
    * which details are *exposed*,
    * which details are *private*, and
    * what _names_ are in each /scope/ in your programs.

  - These features, sometimes collectively referred to as the /module system/,
    include:
    * Packages :: A Cargo feature that lets you *build*, *test*, and *share* /crates/
    * Crates :: A tree of /modules/ that produces a /library/ or /executable/
    * Modules AND use :: Let you control the _organization_, /scope/, and _PRIVACY of paths_
    * Paths :: A way of naming an item, such as a /struct/, /function/, or /module/

  - In this chapter, we'll cover all these features,
    1. discuss how they interact, and

    2. explain how to use them to manage scope.

    3. By the end, you should have a solid understanding of the /module system/
       and be able to work with scopes like a pro!

** DONE Packages and Crates - 112
   CLOSED: [2021-01-07 Thu 15:21]
   The first parts of the /module system/ we'll cover are /packages/ and /crates/.

   - A /crate/ is a /binary/ OR /library/.
     The /crate root/ is a source file that the Rust compiler starts from and
     makes up the /root module/ of your /crate/ (=TODO= we'll explain /modules/
     in depth in the “Defining Modules to Control Scope and Privacy” section). A
     /package/ is one or more /crates/ that provide a set of functionality. A
     /package/ contains a =Cargo.toml= file that _describes how to build_ those
     /crates/.

   - Several rules determine what a /package/ can contain.
     * A /package/ *must* contain zero or one /library crates/, and no more.

     * It can contain as many /binary crates/ as you'd like,
       but it *must* contain _at least one_ /crate/ (either /library/ or
       /binary/).

   - Let's walk through what happens when we create a /package/.
     1. =cargo new my-project=.
        Cargo created a =Cargo.toml= file, giving us a /package/.
        
        * Looking at the contents of =Cargo.toml=, there's no mention of
          =src/main.rs= because Cargo follows a convention that =src/main.rs= is
          the /crate root/ of a /binary crate/ with the *same name* as the
          /package/.
        
        * Likewise, Cargo knows that if the /package directory/ contains
          =src/lib.rs=, the /package/ contains a /library crate/ with the *same
          name* as the /package/, and =src/lib.rs= is its /crate root/. Cargo
          passes the /crate root/ files to =rustc= to *build* the /library/ or
          /binary/.

        * Here, we have a /package/ that only contains =src/main.rs=, meaning it
          ONLY contains a /binary crate/ named =my-project=.
            If a /package/ contains =src/main.rs= and =src/lib.rs=, it has *two*
          /crates/: a /library/ and a /binary/, both with the *same name* as the
          /package/.

        * A /package/ can have *multiple* /binary crates/ by placing files in
          the =src/bin= directory: _each file_ will be a separate /binary crate/.

   - A /crate/ will group related functionality together in a scope so the
     functionality is easy to share between *multiple* projects.

   - Keeping a /crate/'s functionality in its own scope clarifies whether particular
     functionality is defined in our /crate/ or the =rand= /crate/ and prevents
     potential conflicts.

   - =TODO= Let's move on and talk about the /module system/!
     
** DONE Defining Modules to Control Scope and Privacy - 113
   CLOSED: [2021-01-08 Fri 15:51]
   - In this section,
     * we'll talk about
       + /modules/
       + other parts of the /module system/, namely
         - /paths/ that allow you to name items
         - the ~use~ /keyword/ that brings a /path/ into /scope/
         - the ~pub~ /keyword/ to make items public

     * We'll also discuss
       + the ~as~ /keyword/
       + /external packages/
       + the /glob operator/ =???= =TODO=

   - /Modules/ let us _organize code within a /crate/ into groups_ for readability
     and easy reuse.

   - /Modules/ also _control the PRIVACY of items_.

   - As an example,
     let's write a library crate that provides the functionality of a
     restaurant.

     * In the restaurant industry,
       some parts of a restaurant are referred to as _front of house_ and others
       as _back of house_.

       + Front of house ::
         where customers are; this is where hosts seat customers, servers take
         orders and payment, and bartenders make drinks.

       + Back of house ::
         where the chefs and cooks work in the kitchen, dishwashers clean up,
         and managers do administrative work.

     * To structure our /crate/ in the same way that a real restaurant works,
       we can organize the /functions/ into /nested modules/:
       Create a new library named restaurant by running
       =cargo new --lib restaurant=; then put the code in
       #+begin_src rust
         // Listing 7-1:
         // into src/lib.rs to define some modules and function signatures.
         mod front_of_house {
             mod hosting {
                 fn add_to_waitlist() {}

                 fn seat_at_table() {}
             }

             mod serving {
                 fn take_order() {}

                 fn serve_order() {}

                 fn take_payment() {}
             }
         }
       #+end_src

   - Earlier, we mentioned that =src/main.rs= and =src/lib.rs= are called /crate
     roots/.
       The reason for their name is that the contents of either of these two
     files form a /module named crate/ at the root of the _crate's module
     structure_, known as the _module tree_.
     #+begin_src text
       Listing 7-2 shows the module tree for the structure in Listing 7-1.

       crate
        └── front_of_house
            ├── hosting
            │   ├── add_to_waitlist
            │   └── seat_at_table
            └── serving
                ├── take_order
                ├── serve_order
                └── take_payment
     #+end_src
     * This tree shows
       + how some of the /modules/ nest inside one another (for example, hosting
         nests inside ~front_of_house~).

       + some /modules/ are siblings to each other, meaning they're defined in
         the *same* /module/ (~hosting~ and ~serving~ are defined within
         ~front_of_house~).
         - Notice that the entire /module tree/ is rooted under the _implicit_
           /module named crate/.
     
** DONE Paths for Referring to an Item in the Module Tree - 115
   CLOSED: [2021-01-09 Sat 01:52]
   To show Rust where to find an item in a /module tree/, we use a /path/ in the
   same way we use a /path/ when navigating a filesystem.

   - If we want to call a /function/, we need to know its /path/.
   
   - A /path/ can take *TWO* forms:
     * An /absolute path/
       starts from a /crate root/ by using
       + a _crate name_
         OR
       + a literal ~crate~.

     * A /relative path/
       starts from the CURRENT /module/ and uses
       + ~self~
       + ~super~, or
       + an identifier in the CURRENT /module/.
   
   - BOTH /absolute and relative paths/ are followed by one or more identifiers
     _SEPARATED_ by double colons (~::~).

   - Let's return to the example in Listing 7-1.
     * Q :: How do we call the ~add_to_waitlist~ function?
            This is the same as asking, what's the path of the ~add_to_waitlist~
            function?

     * A :: We'll show _TWO_ ways to call the ~add_to_waitlist~ /function/ from a
            new function ~eat_at_restaurant~ defined in the /crate root/.
       *Note*: _this example *won't compile* just yet; =TODO= we'll explain why
               in a bit._
       #+begin_src rust
         // In Listing 7-3: we simplified our code a bit by removing some of the
         //                 modules and functions.
         mod front_of_house {
             mod hosting {
                 fn add_to_waitlist() {}
             }
         }

         pub fn eat_at_restaurant() {
             // Absolute path
             crate::front_of_house::hosting::add_to_waitlist();

             // Relative path
             front_of_house::hosting::add_to_waitlist();
         }
       #+end_src
       + The ~eat_at_restaurant~ function is part of our /library crate's public
         API/, so we mark it with the ~pub~ keyword.

       + =NEXT= In the ”Exposing Paths with the ~pub~ Keyword” section, we'll go
         into more detail about ~pub~.
         =FIXME= - =open quote use close quote character=.

   - The first time we call the ~add_to_waitlist~ function in ~eat_at_restaurant~,
     we use an absolute path. The ~add_to_waitlist~ function is defined in the same
     crate as ~eat_at_restaurant~, which means we can use the ~crate~ keyword to
     start an absolute path.

   - Choosing whether to use a /relative or absolute path/ is a decision you'll
     make based on your project. The decision should depend on
     * WHETHER you're more likely to move item /definition/ code *separately* from
     * OR *together* with
     the code that uses the item.

   - For example,
     * if we move the ~front_of_house~ /module/ and the ~eat_at_restaurant~
       /function/ into ~mod customer_experience~,
       we'd need to *update* the /absolute path/ to ~add_to_waitlist~,
       BUT the /relative path/ would *still be valid*.

     * However,
       if we moved the ~eat_at_restaurant~ /function/ *SEPARATELY* into
       ~mod dining~,
       the /absolute path/ to the ~add_to_waitlist~ call would *stay the same*,
       BUT the /relative path/ would need to be *updated*.

     Our preference is to specify /absolute paths/ because it's more likely to
     move code /definitions/ and item calls *independently* of each other.

   - /Modules/ aren't useful only for organizing your code.
     They also define Rust's /privacy boundary/.

   - The way /privacy/ works in Rust is that *ALL items (/functions/, /methods/,
     /structs/, /enums/, /modules/, and /constants/) are private by default*.
     * Same level object can use each other.
     * /parent module/ can't use the _private_ items inside /child modules/
     * items in /child modules/ can use the items in their /ancestor modules/

*** DONE Exposing Paths with the ~pub~ Keyword - 117
    CLOSED: [2021-01-09 Sat 01:29]
    Add ~pub~ to ~hosting~ and ~add_to_waitlist~.
    #+begin_src rust
      mod front_of_house {
          pub mod hosting {
              pub fn add_to_waitlist() {}
          }
      }

      pub fn eat_at_restaurant() {
          // Absolute path
          crate::front_of_house::hosting::add_to_waitlist();

          // Relative path
          front_of_house::hosting::add_to_waitlist();
      }
    #+end_src
    
*** DONE Starting Relative Paths with ~super~ - 119
    CLOSED: [2021-01-09 Sat 01:32]
    ~super~ is like the ~..~ syntax in filesystem.
    
    #+begin_src rust
      fn serve_order() {}

      mod back_of_house {
          fn fix_incorrect_order() {
              cook_order();
              super::serve_order();
          }

          fn cook_order() {}
      }
    #+end_src
    
*** DONE Making Structs and Enums Public - 120
    CLOSED: [2021-01-09 Sat 01:52]
    We can also use ~pub~ to designate /structs/ and /enums/ as _public_, but
    there are a few extra details.

    - If we use ~pub~ before a /struct definition/,
      we _make the /struct/ public_, but the /struct's fields/ will STILL be _private_.
      We can make each field public or not on a case-by-case basis.
      The ~pub~ on ~struct~ *dosen't affect* the privacy of this /struct fields/.
      #+begin_src rust
        mod back_of_house {
            pub struct Breakfast {
                pub toast: String,
                seasonal_fruit: String,
            }

            impl Breakfast {
                pub fn summer(toast: &str) -> Breakfast {
                    Breakfast {
                        toast: String::from(toast),
                        seasonal_fruit: String::from("peaches"),
                    }
                }
            }
        }

        pub fn eat_at_restaurant() {
            // Order a breakfast in the summer with Rye toast
            let mut meal = back_of_house::Breakfast::summer("Rye");
            // Change our mind about what bread we'd like
            meal.toast = String::from("Wheat");
            println!("I'd like {} toast please", meal.toast);

            // The next line won't compile if we uncomment it; we're not allowed
            // to see or modify the seasonal fruit that comes with the meal
            // meal.seasonal_fruit = String::from("blueberries");
        }
      #+end_src
      * If there is no the associated ~summer~ function, we can't construct a
        an instance of ~Breakfast~ -- ~Breakfast~ has /a private field/.
     

    - In contrast, if we make _an /enum/ PUBLIC_,
      _all of its /variants/ are then PUBLIC._
      We only need the ~pub~ before the ~enum~ keyword, as shown in Listing 7-10.
      #+begin_src rust
        // Listing 7-10: Designating an enum as public makes all its variants public
        mod back_of_house {
            pub enum Appetizer {
                Soup,
                Salad,
            }
        }

        pub fn eat_at_restaurant() {
            let order1 = back_of_house::Appetizer::Soup;
            let order2 = back_of_house::Appetizer::Salad;
        }
      #+end_src

    - =TODO=
      There's one more situation involving ~pub~ that we haven't covered, and
      that is our LAST /module system/ feature: the ~use~ keyword.
        We'll cover ~use~ by itself first, and then we'll show how to *combine*
      ~pub~ and ~use~.

** DONE Bringing Paths into Scope with the ~use~ Keyword - 121
   CLOSED: [2021-01-10 Sun 01:08]
   - Use ~use~ and an /absolute path/:
     #+begin_src rust
       mod front_of_house {
           pub mod hosting {
               pub fn add_to_waitlist() {}
           }
       }

       use crate::front_of_house::hosting;

       pub fn eat_at_restaurant() {
           hosting::add_to_waitlist();
           hosting::add_to_waitlist();
           hosting::add_to_waitlist();
       }
     #+end_src

   - Use ~use~ and a /relative path/:
     #+begin_src rust
       // Listing 7-12: Bringing a module into scope with use and a relative path
       mod front_of_house {
           pub mod hosting {
               pub fn add_to_waitlist() {}
           }
       }

       use self::front_of_house::hosting;

       pub fn eat_at_restaurant() {
           hosting::add_to_waitlist();
           hosting::add_to_waitlist();
           hosting::add_to_waitlist();
       }
     #+end_src
   
*** DONE Creating Idiomatic ~use~ Paths - 123
    CLOSED: [2021-01-10 Sun 00:25]
    - _CONVENTION 1_:
      See Listing 7-11 in the last section, which is the idiomatic way to bring
      /functions/ into scope with ~use~:
      Bringing the /function's parent module/ into /scope/ with ~use~ so we have
      to specify the /parent module/ when calling the /function/ makes it clear
      that the /function/ isn't locally defined while still *minimizing*
      repetition of the /full path/.

    - _CONVENTION 2_:
      When bringing in /structs/, /enums/, and other items with ~use~, it's
      idiomatic to specify the /full path/.
      #+begin_src rust
        // Listing 7-14: shows the _idiomatic way_ to bring the standard library's
        //               HashMap struct into the scope of a binary crate.
        use std::collections::HashMap;

        fn main() {
            let mut map = HashMap::new();
            map.insert(1, 2);
        }
      #+end_src

      * There's no strong reason behind this idiom:
        it's just the *convention* that has emerged, and folks have gotten used to
        reading and writing Rust code this way.

      * _The *EXCEPTION* to this idiom:_
        if we're bringing two items with the _SAME name_ into /scope/ with ~use~
        statements, because Rust doesn't allow that.
        #+begin_src rust
          use std::fmt;
          use std::io;

          fn function1() -> fmt::Result {
              // --snip--
          }

          fn function2() -> io:Result<()> {
              // --snip--
          }
        #+end_src
    
*** DONE Providing New Names with the ~as~ Keyword - 124
    CLOSED: [2021-01-10 Sun 00:29]
    Alias one of the _SAME name_ to distinguish them:
    #+begin_src rust
      // Listing 7-16: Renaming a type when it’s brought into scope with the `as` keyword
      use std::fmt::Result;
      use std::io::Result as IoResult;

      fn function1() -> Result {
          // --snip--
      }

      fn function2() -> IoResult<()> {
          // --snip--
      }
    #+end_src
      
*** DONE Re-exporting Names with ~pub use~ - 124
    CLOSED: [2021-01-10 Sun 00:42]
    Use ~pub use~ to pull names into a /module/ while simultaneously *exposing
    those names outside* of that /module/.
    #+begin_src rust
      mod front_of_house {
          pub mod hosting {
              pub fn add_to_waitlist() {}
          }
      }

      pub use crate::front_of_house::hosting;

      pub fn eat_at_restaurant() {
          hosting::add_to_waitlist();
          hosting::add_to_waitlist();
          hosting::add_to_waitlist();
      }
    #+end_src
      
    - /Re-exporting/ is useful when the internal structure of your code is
      _DIFFERENT from_ how programmers calling your code would think about the
      domain.
      * For example, in this _restaurant metaphor_,
        + the _people running the restaurant_ think about “front of house” and
          “back of house.”

        + BUT _customers_ visiting a restaurant probably won't think about the
          parts of the restaurant in those terms.
            With ~pub use~, we can *write our code with one structure but expose
          a different structure.* Doing so makes our library well organized for
          programmers working on the library and programmers calling the library.
      
*** DONE Using External Packages - 125
    CLOSED: [2021-01-10 Sun 00:53]
    - Members of the Rust community have made many packages available at
      crates.io, and pulling any of them into your package involves these same
      steps:
      listing them in your package's =Cargo.toml= file and using ~use~ to bring
      items _from their /crates/ into /scope/._ For example,
      #+begin_src toml
        [dependencies]
        rand = "0.5.5"
      #+end_src

    - Note that the /standard library (~std~)/ is also a /crate/ that's external
      to our /package/.
        Because the /standard library/ is shipped with the Rust language, _we don't
      need to change =Cargo.toml= to include ~std~._ BUT we do need to refer to it
      with use to bring items from there into our /package's scope/. For example,
      with ~HashMap~ we would use this line:
      #+begin_src rust
        use std::collections::HashMap;
      #+end_src
      
*** DONE Using Nested Paths to Clean Up Large ~use~ Lists - 126
    CLOSED: [2021-01-10 Sun 01:08]
    If we're using multiple items defined in the same /crate/ or same /module/,
    listing each item on its own line can take up a lot of vertical space in
    our files. We can use /nested paths/ to simplify this:
      
    - Import items in the same level:
      #+begin_src rust
        // --snip--
        use std::cmp::Ordering;
        use std::io;
        // --snip--
      #+end_src
      
      can be simplified as
      
      #+begin_src rust
        // Listing 7-18: Specifying a nested path to bring multiple items with the same
        //               prefix into scope
        // --snip--
        use std::{cmp::Ordering, io};
        // --snip--
      #+end_src

    - Import items in different levels:
      #+begin_src rust
        // Listing 7-19: Two use statements where one is a subpath of the other
        use std::io;
        use std::io::Write;
      #+end_src
      
      can be simplified as

      #+begin_src rust
        // Listing 7-20: Combining the paths in Listing 7-19 into one use statement
        use std::io::{self, Write};
      #+end_src
      
*** DONE The Glob Operator - 127
    CLOSED: [2021-01-10 Sun 01:08]
    Bring *all* /public items/ defined in a path into scope.
    #+begin_src rust
      use std::collections::*;
    #+end_src
    
    - Be careful when using the /glob operator/!
      /Glob/ can *make it harder to tell*
      * what names are in scope and
      * where a name used in your program was defined.

    - The /glob operator/
      * It is often used
        WHEN testing to bring everything under _test_ into the /tests module/;
        =TODO=
        we'll talk about that in the “How to Write Tests” section in Chapter 11.
      
      * =TODO= =TODO= =TODO=
        It is also sometimes used as part of the /prelude pattern/:
        see the standard library documentation for more information on that
        pattern.

** DONE Separating Modules into Different Files - 127
   CLOSED: [2021-01-10 Sun 02:28]
   So far, all the examples in this chapter _defined MULTIPLE /modules/ in ONE
   /file/._
     _When /modules/ get *large*,_ you might want to *MOVE their definitions TO a
   _separate file_ to make the code easier to navigate.*

   - For example,
     1. Let's start from the code in Listing 7-17
        #+begin_src rust
          // Listing 7-17

          // src/lib.rs
          mod front_of_house {
              pub mod hosting {
                  pub fn add_to_waitlist() {}
              }
          }

          pub use crate::front_of_house::hosting;

          pub fn eat_at_restaurant() {
              hosting::add_to_waitlist();
              hosting::add_to_waitlist();
              hosting::add_to_waitlist();
          }
        #+end_src
        
     2. Move the ~front_of_house~ /module/ to its own file =src/front_of_house.rs=
        by changing the /crate root/ file so it contains the code shown in
        Listing 7-21.
        *In this case, the /crate root file/ is =src/lib.rs=, but this procedure
        also works with /binary crates/ whose /crate root file/ is =src/main.rs=.*
        #+begin_src rust
          // Listing 7-21: Declaring the front_of_house module whose body will be in
          //               src/front_of_house.rs
          mod front_of_house;

          pub use crate::front_of_house::hosting;

          pub fn eat_at_restaurant() {
              hosting::add_to_waitlist();
              hosting::add_to_waitlist();
              hosting::add_to_waitlist();
          }
        #+end_src
        =src/front_of_house.rs= gets the definitions FROM _the body of the
        ~front_of_house~ /module/._
        #+begin_src rust
          // Listing 7-22: Definitions inside the front_of_house module in
          //               src/front_of_house.rs
          pub mod hosting {
              pub fn add_to_waitlist() {}
          }
        #+end_src
        Use ~mod front_of_house;~ RATHER THAN using a /block/ tells Rust to
        *load the contents of the /module/ from another file with the same
        name as the /module/.*
           
     3. To continue with our example and extract the ~hosting~ /module/ to its
        own file as well, we change =src/front_of_house.rs= to contain only the
        declaration of the ~hosting~ /module/:
        #+begin_src rust
          pub mod hosting;
        #+end_src
        Then we create a =src/front_of_house= directory and a file
        =src/front_of_house/hosting.rs= to contain the definitions made in
        the ~hosting~ /module/:
        #+begin_src rust
          pub fn add_to_waitlist() {}
        #+end_src

   - _The /module tree/ remains the SAME, and the /function/ calls in
     ~eat_at_restaurant~ will work *WITHOUT ANY MODIFICATION*,_ even though the
     definitions live in different files.
     * This technique lets you move modules to new files as they grow in size.

   - Note that the ~pub use crate::front_of_house::hosting~ statement in
     =src/lib.rs= also *HASN'T CHANGED*, nor does use have any impact on what
     files are compiled as part of the /crate/.
     
** DONE Summary - 128
   CLOSED: [2021-01-10 Sun 02:28]

* DONE 8. Common Collections - 131 - =TODO= =PRACTICE=
  CLOSED: [2021-01-11 Mon 22:26]
  Rust's standard library includes a number of very useful data structures called
  /collections/.

  - *Unlike* the built-in /array/ and /tuple/ types,
    the data these collections point to is *stored on the /heap/,*
    which means the amount of data does _not need to be known at compile time_ and
    can *grow or shrink* as the program runs.

  - In this chapter, we'll discuss *THREE* /collections/ that are used very often
    in Rust programs:
    * A /vector/ allows you to store a _variable number of values_
      *next to each other*.

    * A /string/ is a _collection of characters_.
      We've mentioned the ~String~ type previously,
      BUT in this chapter we'll talk about it in depth.

    * A /hash map/ allows you to _associate a value with a particular key_.
      It's a particular implementation of the more general data structure called
      a map.

  - We'll discuss
    * how to *create* and *update*
      + /vectors/
      + /strings/
      + /hash maps/,
      as well as
    * what makes each special.
    
** DONE Storing Lists of Values with Vectors - 132
   CLOSED: [2021-01-06 Wed 16:59]
   - /vector/ :: ~Vec<T>~.

*** DONE Creating a New Vector - 132
    CLOSED: [2021-01-06 Wed 15:24]
    - Create an empty /vector/: ~let v: Vec<i32> = Vec::new();~
      The /type annotation/ is required.

    - Use /macro/ ~vec!~ to create a /vector/ with _initial values_:
      ~let v = vec![1, 2, 3];~

*** DONE Updating a Vector - 132
    CLOSED: [2021-01-06 Wed 15:25]
    #+BEGIN_SRC rust
      let mut v = Vec::new();

      v.push(5);
      v.push(6);
      // Rust can infer that the type of `v` is `Vec<i32>`
    #+END_SRC
    The ~mut~ is for the inside of this /vector/.

    - =From Jian=
      The book doesn't mention if this ~mut~ is for the ~v~ itself.
      However, since Rust has /shadow/ feature, I'm pretty sure that ~mut~ is
      NOT for ~v~ itself

*** DONE Dropping a Vector Drops Its Elements - 133
    CLOSED: [2021-01-06 Wed 15:26]
    #+BEGIN_SRC rust
      {
          let v = vec![1, 2, 3, 4];

          // do stuff with `v`

      }  // <- `v` goes out of scope and is freed here
    #+END_SRC
    =TODO=
    This may seem like a straightforward point, but can get a little more
    complicated once we start to introduce /references/ to the elements of the
    /vector/. Let's tackle that next!

*** DONE Reading Elements of Vectors - 133
    CLOSED: [2021-01-06 Wed 15:57]
    - Two ways:
      #+begin_src rust
        let v = vec![1, 2, 3, 4, 5];

        let third: &i32 = &v[2];
        println!("the third element is {}", third);

        match v.get(2) {
            Some(third) => println!("The third element is {}", third),
            None        => println!("There is no third element.")
        }
      #+end_src

    - When the program has a valid reference, the borrow checker enforces the
      /ownership/ and /borrowing rules/ (covered in Chapter 4) to ensure THIS
      /reference/ and ANY OTHER /references/ to the contents of the /vector/
      remain valid.
        Recall the rule that states you *can't* have /mutable and immutable
      references/ in the SAME /scope/. That rule applies in Listing 8-7, where we
      hold an /immutable reference/ to the first element in a /vector/ and try to
      add an element to the end, *which won't work if we also try to refer to
      that element later in the function*:
      =TODO= =RE-NOTE=
      #+begin_src rust
        // Listing 8-7:
        // Attempting to add an element to a vector while holding a reference to an item

        let mut v = vec![1, 2, 3, 4, 5];

        let first = &v[0];
        v.push(6);

        println!("The first element is: {}", first);
      #+end_src
      
      Compiling this code will result in this error (~cargo run~):
      #+begin_src text
           Compiling collections v0.1.0 (file:///projects/collections)
        error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
         --> src/main.rs:6:5
          |
        4 |     let first = &v[0];
          |                  - immutable borrow occurs here
        5 | 
        6 |     v.push(6);
          |     ^^^^^^^^^ mutable borrow occurs here
        7 | 
        8 |     println!("The first element is: {}", first);
          |                                          ----- immutable borrow later used here

        error: aborting due to previous error

        For more information about this error, try `rustc --explain E0502`.
        error: could not compile `collections`.

        To learn more, run the command again with --verbose.
      #+end_src
      The code in Listing 8-7 might look like it should work:
      * Q ::
        why should a /reference/ to the first element care about what changes at
        the end of the vector?

      * A ::
        This error is due to the way /vectors/ work:
        adding a new element onto the end of the /vector/ *might require allocating
        new memory and copying the old elements to the new space*, if there isn't
        enough room to put all the elements next to each other where the /vector/
        currently is.
          In that case, the /reference/ to the first element would be pointing to
        /deallocated memory/. The /borrowing rules/ *prevent* programs from
        ending up in that situation.

    - =TODO=
      *Note*:
      For more on the implementation details of the ~Vec<T>~ type, see “The
      Rustonomicon”.
    
*** DONE Iterating over the Values in a Vector - 135
    CLOSED: [2021-01-06 Wed 16:16]
    - We can iterate through all of the elements of a /vector/
      RATHER THAN use indices to access one at a time.
      #+begin_src rust
        // Listing 8-8:
        // Printing each element in a vector by iterating over the elements using a `for` loop

        let v = vec![100, 32, 57];
        for i in &v {
            println!("{}", i);
        }
      #+end_src

    - Iterate over /mutable references/ to each element in a /mutable vector/ in
      order to make changes to all the elements.
      #+begin_src rust
        // Listing 8-9:
        // Iterating over mutable references to elements in a vector

        let mut v = vec![100, 32, 57];
        for i in &mut v {
            *i += 50;
        }
      #+end_src
      To change the value that the /mutable reference/ refers to,
      we have to use the /dereference operator/ (~*~) to get to the value in ~i~
      before we can use the ~+=~ operator.
        =TODO= We'll talk more about the /dereference operator/ in the “Following
      the Pointer to the Value with the Dereference Operator” section of Chapter 15.
    
*** DONE Using an Enum to Store Multiple Types - 136
    CLOSED: [2021-01-06 Wed 16:59]
    Combine /enum/ with /vectors/ to effectively save values of DIFFERENT /types/
    in to one /vector/, meanwhile keep the safety -- combine /enum/ with ~match~
    exhaustive checking feature can guarantee this.

    - For example,
      #+begin_src rust
        // Listing 8-10:
        // Defining an enum to store values of different types in one vector

        enum SpreadsheetCell {
            Int(i32),
            Float(f64),
            Text(String),
        }

        let row = vec![
            SpreadsheetCell::Int(3),
            SpreadsheetCell::Text(String::from("blue")),
            SpreadsheetCell::Float(10.12),
        ];
      #+end_src

    - Rust needs to know what /types/ will be in the /vector/ _at compile time_
      so it knows *exactly how much /memory/ on the /heap/ will be needed* to
      store each element.
      
    - =TODO= =???=
      When you're writing a program, if you don't know the exhaustive set of
      types the program will get _at runtime_ to store in a /vector/, the /enum/
      technique won't work.
      =TODO= =???=
      Instead, you can use a /trait object/, which we'll cover in Chapter 17.

    - Now that we've discussed some of the most common ways to use /vectors/,
      =TODO= be sure to review the API documentation for all the many useful methods
      defined on ~Vec<T>~ by the standard library.
        For example, in addition to push, a pop method removes and returns the
      last element. Let’s move on to the next collection type: ~String~!

** DONE Storing UTF-8 Encoded Text with Strings - 137
   CLOSED: [2021-01-06 Wed 22:36]
   - Strings are an area that new Rustaceans commonly get stuck on.
     This is due to a combination of three things:  =???= =TODO=
     * Rust's propensity for making sure to expose possible errors,

     * strings being a more complicated data structure than many programmers give
       them credit for, and

     * UTF-8

   - It's useful to discuss /strings/ in the context of collections
     because
     /strings/ are implemented
     * as a /collection/ of /bytes/,
     * plus some /methods/ to provide useful functionality
       when those /bytes/ are interpreted as text.
     
   - In this section, we'll talk about the operations on ~String~ that every
     collection type has, such as *creating*, *updating*, and *reading*.

   - We'll also discuss the ways in which ~String~ is different from the other
     collections, namely how indexing into a ~String~ is complicated by the
     differences between how people and computers interpret String data.
     
*** DONE What Is a String? - 137 - =RE-READ=
    CLOSED: [2021-01-06 Wed 19:46]
   Rust _actually_ *only has one* /string type/ in the _core language_ itself:
   ~str~, the /string slice/, which is usually seen in its /borrowed form/, ~&str~.

   - ~String~ is provided in the standard library of Rust, rather than coded into
     the *core language*, and is a _growable_, _mutable_, _owned_, _UTF-8 encoded_
     /string type/.

   - When Rustaceans talk about "strings", they usually mean both the ~String~
     and the /string slice/ ~&str~ types.

   - Alghough this section is largely about ~String~, both /types/ are used
     heavily in Rust's standard library.

   - Both ~String~ and /string slices/ are UTF-8 encoded.

   - =TODO=
     Read the API doc to get more details about the other /string types/,
     * standard library:
       + ~OsString~
       + ~OsStr~
       + ~CString~
       + ~CStr~

     * /library crates/ can provide even more options for storing string data.

     * See how those _names_ all end in ~String~ or ~Str~?
         They _refer to_ /owned and borrowed variants/, just like the ~String~ and
       ~str~ types you've seen previously.

     * These /string types/ can store text *in different encodings* OR *be
       represented in memory in a different way*, for example. We won't discuss
       these OTHER /string types/ in this chapter; =TODO= see their API
       documentation for more about how to use them and when each is
       appropriate.

*** DONE Creating a New String - 137
    CLOSED: [2021-01-06 Wed 22:36]
    - Many of the same operations available with ~Vec<T>~ are available with
      ~String~ as well, starting with the ~new~ function to create a /string/:
      #+begin_src rust
        // Listing 8-11: Creating a new, empty `String`
        let mut s = String::new();
      #+end_src
      This line creates a NEW /empty string/ called ~s~, which we can then *load*
      data into.

    - Often, we'll have some initial data that we want to start the string with.
      For that, we use the ~to_string~ /method/, which is available on any type
      that implements the ~Display~ /trait/, as /string literals/ do. Listing
      8-12 shows two examples.
      #+begin_src rust
        // Listing 8-12:
        // Using the `to_string` method to create a `String` from a string literal

        let data = "initial contents";
        let s = data.to_string();

        // the method also works on a literal directly:
        let s = "initial contents".to_string();
      #+end_src

    - Two equivalent ways to get a ~String~ from a /string literal/.
      * ~let s = "initial contents".to_string();~
      * ~let s = String::from("initial contents");~
      Which you choose is a matter of style.

    - Remember that /strings/ are *UTF-8 encoded*, so we can include any properly
      encoded data in them, as shown in Listing 8-14.
      #+begin_src rust
        let hello = String::from("السلام عليكم");
        let hello = String::from("Dobrý den");
        let hello = String::from("Hello");
        let hello = String::from("שָׁלוֹם");
        let hello = String::from("नमस्ते");
        let hello = String::from("こんにちは");
        let hello = String::from("안녕하세요");
        let hello = String::from("你好");
        let hello = String::from("Olá");
        let hello = String::from("Здравствуйте");
        let hello = String::from("Hola");
      #+end_src

*** DONE Updating a String - 138
    CLOSED: [2021-01-06 Wed 20:26]
    A ~String~ can *grow* in _size_ and its _contents_ can change,
    just like the contents of a ~Vec<T>~, if you push more data into it.
      
    - Update ~String~'s with ~+~ or ~format!~.
    
**** DONE Appending to a String with ~push_str~ and ~push~ - 139
     CLOSED: [2021-01-06 Wed 20:09]
     #+BEGIN_SRC rust
       let mut s = String::from("foo");
       s.push_str("bar");

       let mut s1 = String::from("foo");
       let s2 = "bar";
       s1.push_str(s2);
       // s2 is still valid

       let mut s3 = String::from("lo");
       s.push('l');
     #+END_SRC

**** DONE Concatenation with the ~+~ Operator or the ~format!~ Macro - 139
     CLOSED: [2021-01-06 Wed 20:26]
     - ~+~
       #+BEGIN_SRC rust
         let s1 = String::from("Hello, ");
         let s2 = String::from("world!");
         let s3 = s1 + &s2; // Note that s1 has been moved here and can no longer be used.
         // this is due to what does `+` do under the hood
         // `fn add(self, s: &str) -> String`.
       #+END_SRC
       ~fn add(self, s: &str) -> String~ is not the exact signature in the standard
       library. It is just a specific version that the /generics/ part is replaced
       with a concrete type ~String~.

       1. The ~&s2~ is ~&String~, and the ~add~ method requires ~&str~.
          * Q :: What happened makes this right?
          * A :: The compiler can /coerce/ the ~&String~ argument into a ~&str~.
              
          * When the ~add~ /method/ is called, Rust uses /deref coercion/, which
            here turns ~&s2~ into ~&s2[..]~.

          * =TODO= - =TODO= - =TODO=
            Discuss /deref coercion/ in more depth in Chapter 15.

          * Because ~add~ does NOT take /ownership/ of the ~s~ parameter, ~s2~ will still
            be a valid ~String~ after this operation.
          
       2. We can see the signature of ~add~ takes /ownership/ of ~self~, because
          ~self~ does NOT have an ~&~.
            This means s1 in Listing 8-18 will be moved into the add call and no
          longer be valid after that. So although let s3 = s1 + &s2; looks like it
          will copy both strings and create a new one, this statement actually
          takes ownership of s1, appends a copy of the contents of s2, and then
          returns ownership of the result. In other words, it looks like it’s
          making a lot of copies but isn’t; the implementation is more efficient
          than copying.

     - Concatenate multiple strings:
       * The behavior of the ~+~ operator gets unwieldy (=from Jian= because of
         ~+~ is not symmetric to its LHS and RHS):
         #+begin_src rust
           let s1 = String::from("tic");
           let s2 = String::from("tac");
           let s3 = String::from("toe");

           let s = s1 + "-" + &s2 + "-" + &s3;
         #+end_src
         
       * Use the ~format!~ macro:
         #+begin_src rust
           let s = format!("{}-{}-{}", s1, s2, s3);
         #+end_src
         This doesn't take /ownership/ of any of its parameters.
         The format string part of ~format!~ is the same as the ~println!~.

*** DONE Indexing into Strings - 141
    CLOSED: [2021-01-06 Wed 22:22]
    Try the indexing operation (as in other languages).
    You'll get an error message:
    #+BEGIN_SRC text
         Compiling collections v0.1.0 (file:///projects/collections)
      error[E0277]: the type `std::string::String` cannot be indexed by `{integer}`
       --> src/main.rs:3:13
        |
      3 |     let h = s1[0];
        |             ^^^^^ `std::string::String` cannot be indexed by `{integer}`
        |
        = help: the trait `std::ops::Index<{integer}>` is not implemented for `std::string::String`

      error: aborting due to previous error

      For more information about this error, try `rustc --explain E0277`.
      error: could not compile `collections`.

      To learn more, run the command again with --verbose.
    #+END_SRC
    - This indicate that *Rust strings do _NOT_ support indexing.*

    - Q :: WHY?

    - A :: In order to answer that, we have to talk a bit about
           _HOW Rust stores /strings/ in memory._

**** DONE Internal Representation - 141
     CLOSED: [2021-01-06 Wed 22:22]
     A ~String~ is a wrapper over a ~Vec<u8>~.

     1. Let's look at some of our properly encoded UTF-8 example strings from
        Listing 8-14.
        #+begin_src rust
          let hello = String::from("Hola");  // 4 letters, 4 bytes long

          let hello = String::from("Здравствуйте");  // 12 letters, 24 bytes long
        #+end_src
        From these two examples we know index into the string's bytes will *NOT
        ALWAYS* correlate to a valid /Unicode scalar value/.

     2. The above example can illustrate that
        index a UTF-8 string is completely different from indexing the bytes in
        a string.
          To avoid returning an unexpected value and causing bugs that might
        not be discovered immediately, Rust doesn't allow index a /string/.

**** DONE Bytes and Scalar Values and Grapheme Clusters! Oh My! - 142
     CLOSED: [2021-01-06 Wed 22:22]
     - Another point about UTF-8 is that there are actually *THREE* relevant ways
       to look at /strings/ from Rust's perspective:
       * bytes,
       * scalar values,
       * /grapheme clusters/ (the closest thing to what we would call /letters/).

     - If we look at the Hindi word “नमस्ते” written in the Devanagari script, it
       is stored as a /vector/ of ~u8~ values that looks like this:
       #+begin_src text
         [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
         224, 165, 135]
       #+end_src
       * That's 18 bytes and is how computers ultimately store this data.
         If we look at them as /Unicode scalar values/, which are what /Rust's
         ~char~ type/ is, those bytes look like this:
         #+begin_src text
           ['न', 'म', 'स', '्', 'त', 'े']
         #+end_src
         + There are six char values here, but the fourth and sixth are *not*
           /letters/ -- they're /diacritics/ that don't make sense on their own.

       * Finally, if we look at them as /grapheme clusters/, we'd get what a
         person would call the *four* /letters/ that make up the Hindi word:
         #+begin_src text
           ["न", "म", "स्", "ते"]
         #+end_src

     - Rust provides different ways of interpreting the raw string data that
       computers store so that each program can choose the interpretation it
       needs, no matter what human language the data is in.

     - *A final reason Rust doesn't allow us to index into a ~String~ to get a
       character*:
       indexing operations are expected to always take constant time O(1).
       But *it isn't possible to guarantee that performance with a ~String~,*
       because Rust would have to walk through the contents from the beginning
       to the index to determine how many valid characters there were.

*** DONE Slicing Strings - 142
    CLOSED: [2021-01-06 Wed 22:34]
    - Indexing into a string is often a bad idea because it's not clear what the
      return type of the string-indexing operation should be:
      * a byte value?
      * a character?
      * a grapheme cluster?
      * a string slice?
        
    - *THEREFORE*,
      Rust asks you to be more specific if you really need to use indices to
      create /string slices/.
        To be more specific in your indexing and indicate that you want a /string
      slice/,
      RATHER THAN indexing using ~[]~ with a single number,
      you can *use ~[]~ with a range* to create a /string slice/ containing
      particular bytes:
      #+begin_src rust
        let hello = "Здравствуйте";

        let s = &hello[0..4];
      #+end_src
      Here, ~s~ will be a ~&str~ that contains the _first 4 bytes_ of the /string/.
      Earlier, we mentioned that each of these characters was _2 bytes_, which
      means s will be ~Зд~.

    - Q :: What would happen if we used ~&hello[0..1]~?
    - A :: Rust would /panic/ _at runtime_
           in the same way as if an invalid index were accessed in a /vector/
      * ~cargo run~:
        #+begin_src text
             Compiling collections v0.1.0 (file:///projects/collections)
              Finished dev [unoptimized + debuginfo] target(s) in 0.43s
               Running `target/debug/collections`
          thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2069:5
          note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
        #+end_src
        =IMPORTANT=
        *You should use /ranges/ to create /string slices/ with caution, because
        doing so can crash your program.*
      
*** DONE Methods for Iterating over Strings - 143
    CLOSED: [2021-01-06 Wed 20:53]
    Fortunately, you can access elements in a /string/ in other ways.
    
    - Perform operations on individual /Unicode scalar/ values, the
      best way to do so is to use the ~chars~ /method/:
      #+begin_src rust
        for c in "नमस्ते".chars() {
            println!("{}", c);
        }
      #+end_src
      
      Output:
      
      #+begin_src text
        न
        म
        स
        ्
        त
        े
      #+end_src
      
    - Iterate bytes in a ~String~:
      #+begin_src rust
        for b in "नमस्ते".bytes() {
            println!("{}", b);
        }
      #+end_src
      
      Output:
      
      #+begin_src text
        224
        164
        // --snip--
        165
        135
      #+end_src

    - Getting /grapheme clusters/ from /strings/ is *complex*,
      so this functionality is *not provided* by the /standard library/.
      * Crates are available on crates.io if this is the functionality you need.
    
*** DONE Strings Are Not So Simple - 144
    CLOSED: [2021-01-06 Wed 22:36]
    *To summarize, /strings/ are complicated.*

    Different programming languages make different choices about how to present
    this complexity to the programmer.
      Rust has chosen to make the correct handling of ~String~ data the default
    behavior for all Rust programs, which means programmers have to put more
    thought into handling UTF-8 data upfront.
    - This trade-off
      * exposes more of the complexity of /strings/ than is apparent in other
        programming languages,
      * BUT it prevents you from having to handle errors involving non-ASCII
        characters later in your development life cycle.

** DONE Storing Keys with Associated Values in Hash Maps - 144
   CLOSED: [2021-01-06 Wed 17:58]
   ~HashMap<K, V>~
   
   - Many programming languages support this kind of data structure,
     but they often use a DIFFERENT NAME, such as
     * hash
     * map
     * object
     * hash table
     * dictionary
     * associative array
     * ... just to name a few
   
*** DONE Creating a New Hash Map - 144
    CLOSED: [2021-01-06 Wed 17:29]
    - *Create* an /EMPTY hash map/ with ~new~ and add elements with insert.
      #+begin_src rust
        // Listing 8-20:
        // Creating a new hash map and inserting some keys and values

        use std::collections::HashMap;

        let mut scores = HashMap::new();

        scores.insert(String::from("Blue"), 10);
        scores.insert(String::from("Yellow"), 50);
      #+end_src
      * Of our three common collections (mentioned in this chapter),
        this one is the least often used, so it's *not* included in the features
        brought into scope automatically in the /prelude/.

      * /Hash maps/ also have *less* support from the standard library;
        there's *no* built-in /macro/ to construct them, for example.
        =TODO= =TODO= =TODO=

    - Just like /vectors/, /hash maps/ store their data on the /heap/.

    - /Hash maps/ are *homogeneous*.

    - Another way of constructing a hash map is by using /iterators/ and the
      ~collect~ method on a /vector/ of /tuples/, where each /tuple/ consists of
      a key and its value.

    - =TODO=
      We'll be going into more detail about /iterators/ and their associated
      /methods/ in the ”Processing a Series of Items with Iterators” section of
      Chapter 13.

    - The ~collect~ /method/ gathers data into _a number of /collection types/,_
      including ~HashMap~. =from Jian= NOT only ~HashMap~.
      * For example, 
        #+begin_src rust
          // Listing 8-21:
          // Creating a hash map from a list of teams and a list of scores

          use std::collections::HashMap;

          let teams = vec![String::from("Blue"), String::from("Yellow")];
          let initial_scores = vec![10, 50];

          let mut scores: HashMap<_, _> =
              teams.into_iter().zip(initial_scores.into_iter()).collect();
        #+end_src
        Since ~collect~ can generate multiple types of collections, the /type
        annotation/ for ~scores~ must be given to tell what type of result it
        wants. However, the types of keys and values can be inferred, and this is
        why we can put two ~_~'s in the type parameters sites of ~HashMap~.

*** DONE Hash Maps and Ownership - 145
    CLOSED: [2021-01-06 Wed 17:47]
    #+begin_src rust
      use std::collections::HashMap;

      let field_name = String::from("Favorite color");
      let field_value = String::from("Blue");

      let mut map = HashMap::new();
      map.insert(field_name, field_value);
      // `field_name` and `field_value` are invalid at this point.
      // The _move_ is done by the `insert` method.
    #+end_src
    - For /types/ that implement the ~Copy~ /trait/, like ~i32~,
      the values are _copied into_ the /hash map/.

    - For /owned values/ like ~String~,
      the values will be moved and the /hash map/ will be the owner of those
      values.

    - If we insert /references/ to /values/ into the /hash map/,
      the values _won't be moved into_ the /hash map/.
        The values that the /references/ point to *must be valid for at least as
      long as the hash map is valid.*
      =TODO= =TODO= =TODO=
      We'll talk more about these issues in the “Validating References with
      Lifetimes” section in Chapter 10.

*** DONE Accessing Values in a Hash Map - 146
    CLOSED: [2021-01-06 Wed 17:48]
    #+BEGIN_SRC rust
      use std::collections::HashMap;

      let mut scores = HashMap::new();

      scores.insert(String::from("Blue"), 10);
      scores.insert(String::from("Yellow"), 50);

      // #1. The `get` method (the return value is `Option<&V>`):
      let team_name = String::from("Blue");
      let score = scores.get(&team_name);

      // #2. Iterate over each key/value pair in a hash map in a similar manner
      //     as we do with vectors:
      for (key, value) in &scores {
          println!("{}: {}", key, value);
      }
    #+END_SRC

*** DONE Updating a Hash Map - 147
    CLOSED: [2021-01-06 Wed 17:58]
**** DONE Overwriting a Value - 147
     CLOSED: [2021-01-06 Wed 17:49]
     Do ~insert~ more than one times for one key.

**** DONE Only Inserting a Value If the Key Has No Value - 147
     CLOSED: [2021-01-06 Wed 17:50]
     #+BEGIN_SRC rust
       use std::collections::HashMap;

       let mut scores = HashMap::new();
       scores.insert(String::from("Blue"), 10);

       scores.entry(String::from("Yellow")).or_insert(50);
       scores.entry(String::from("Blue")).or_insert(50);

       println!("{:?}", scores);
       // Only "Blue" and its value
     #+END_SRC

     - ~entry~ returan a value of enum, ~Entry~.

     - The ~or_insert~ method on ~Entry~ returns
       * the value for the corresponding ~Entry~ key if it exists, and
       * if not, inserts its argument as the new value for this key and returns
         the modified ~Entry~.

       This is much cleaner than writing the logic ourselves, and in addition,
       plays more nicely with the borrow checker.

**** DONE Updating a Value Based on the Old Value - 148
     CLOSED: [2021-01-06 Wed 17:55]
     #+BEGIN_SRC rust
       use std::collections::HashMap;

       let text = "hello world wonderful world";

       let mut map = HashMap::new();

       for word in text.split_whitespace() {
           let count = map.entry(word).or_insert(0);
           *count += 1;
       }

       println!("{:?}", map);
     #+END_SRC
     1. The ~or_insert~ method actually returns a /mutable reference/ (~&mut V~).
     2. We save it in the ~count~ variable, so in order to *assign to* that value
        we must first *dereference* ~count~ using the ~*~.

**** DONE Hashing Functions - 149
     CLOSED: [2021-01-06 Wed 17:58]
     1. _By default_, ~HashMap~ uses a *"cryptographically strong" hashing function*
        that can provide resistance to Denial of Service (DoS) attacks.

     2. _This default is not the fastest hashing algorithm out there_, but the
        tradeoff for _better security_ that comes with the drop in performance
        is *worth it*.

     3. You can switch to another function by specifying a different /hasher/.
        - /hasher/ :: a type that implements the ~BuildHasher~ trait.

** TODO Summary - 149
   - Given a list of integers, use a vector and return the mean (average),
     median (when sorted, the value in the middle position), and mode (the
     value that occurs most often; a hash map will be helpful here) of the
     list.
     =TODO=

   - Convert strings to Pig Latin, where the first consonant of each word is
     moved to the end of the word with an added “ay”, so “first” becomes
     “irst-fay”. Words that start with a vowel get “hay” added to the end
     instead (“apple” becomes “apple-hay”). Remember about UTF-8 encoding!
     =TODO=

   - Using a hash map and vectors, create a text interface to allow a user to
     add employee names to a department in the company. For example, “Add
     Sally to Engineering” or “Add Amir to Sales”. Then let the user retrieve
     a list of all people in a department or all people in the company by
     department, sorted alphabetically.
     =TODO=

* DONE 9. Error Handling - 151
  CLOSED: [2021-01-13 Wed 03:09]
  - Rust groups errors into TWO major categories:
    * recoverable errors
    * unrecoverable errors - always symptoms of bugs

  - Most languages don't distinguish between these TWO kinds of errors and
    handle both in the same way, using mechanisms such as /exceptions/.

  - Rust doesn't have exceptions.
    Instead, it has
    * the type ~Result<T, E>~ for recoverable errors.
    * the ~panic!~ macro that stops execution when it encounters unrecoverable
      errors.

** DONE Unrecoverable Errors with ~panic!~ - 152
   CLOSED: [2021-01-07 Thu 01:25]
   - When this /macro/ executes, your program will:
     1. print a failure message
     2. unwind and clean up the stack
     3. quit

   - This most commonly occurs when a bug of some kind has been detected and
     it's _not clear_ to the programmer how to handle the error.

   - *Unwinding the Stack or Aborting in Response to a Panic*
     * /unwinding/ :: walks back up the /stack/ and cleans up the data from each
                      function it encounters, but this walking and cleanup is a
                      lot of work.


     * the alternative is to _immediately abort_.
       1. No cleanup by the program.
       2. Memory need to be cleaned up by the OS.

     * If you want to make your _resulting binary as small as possible_,
       you can switch from /unwinding/ to /aborting/ on /panic/ by adding
       ~panic = 'abort'~ to the appropriate ~[profile]~ sections in the =Cargo.toml=.
       For example, if you want to abort on /panic/ in release mode, add this:
       #+BEGIN_SRC toml
         [profile.release]
         panic = 'abort'
       #+END_SRC

    - We can use the backtrace of the functions the ~panic!~ call came from to
      figure this out.

*** DONE Using a ~panic!~ Backtrace - 153
    CLOSED: [2021-01-07 Thu 01:25]
    - /buffer overread/
      * In Rust will trigger a /panic/
      * In C/C++ will trigger an /undefined behavior/.

    - A example:
      #+BEGIN_SRC rust
        fn main() {
            let v = vec![1, 2, 3];

            v[100];
        }
      #+END_SRC

      * Command ~cargo run~
        #+BEGIN_SRC text
             Compiling panic v0.1.0 (file:///projects/panic)
              Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
               Running `target/debug/panic`
          thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
          100', /stable-dist-rustc/build/src/libcollections/vec.rs:1362
          note: Run with `RUST_BACKTRACE=1` for a backtrace.
          error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
        #+END_SRC

      * Command ~RUST_BAKTRACE=1 cargo run~
        #+BEGIN_SRC text
          $ RUST_BACKTRACE=1 cargo run
          thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
          stack backtrace:
             0: backtrace::backtrace::libunwind::trace
                       at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88
             1: backtrace::backtrace::trace_unsynchronized
                       at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66
             2: std::sys_common::backtrace::_print_fmt
                       at src/libstd/sys_common/backtrace.rs:84
             3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt
                       at src/libstd/sys_common/backtrace.rs:61
             4: core::fmt::ArgumentV1::show_usize
             5: std::io::Write::write_fmt
                       at src/libstd/io/mod.rs:1426
             6: std::sys_common::backtrace::_print
                       at src/libstd/sys_common/backtrace.rs:65
             7: std::sys_common::backtrace::print
                       at src/libstd/sys_common/backtrace.rs:50
             8: std::panicking::default_hook::{{closure}}
                       at src/libstd/panicking.rs:193
             9: std::panicking::default_hook
                       at src/libstd/panicking.rs:210
            10: std::panicking::rust_panic_with_hook
                       at src/libstd/panicking.rs:471
            11: rust_begin_unwind
                       at src/libstd/panicking.rs:375
            12: core::panicking::panic_fmt
                       at src/libcore/panicking.rs:84
            13: core::panicking::panic_bounds_check
                       at src/libcore/panicking.rs:62
            14: <usize as core::slice::SliceIndex<[T]>>::index
                       at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806
            15: core::slice::<impl core::ops::index::Index<I> for [T]>::index
                       at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2657
            16: <alloc::vec::Vec<T> as core::ops::index::Index<I>>::index
                       at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/liballoc/vec.rs:1871
            17: panic::main
                       at src/main.rs:4
            18: std::rt::lang_start::{{closure}}
                       at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
            19: std::rt::lang_start_internal::{{closure}}
                       at src/libstd/rt.rs:52
            20: std::panicking::try::do_call
                       at src/libstd/panicking.rs:292
            21: __rust_maybe_catch_panic
                       at src/libpanic_unwind/lib.rs:78
            22: std::panicking::try
                       at src/libstd/panicking.rs:270
            23: std::panic::catch_unwind
                       at src/libstd/panic.rs:394
            24: std::rt::lang_start_internal
                       at src/libstd/rt.rs:51
            25: std::rt::lang_start
                       at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
            26: panic::main
        #+END_SRC
        * In order to get /backtraces/ with this information, /debug symbols/
          *must be enabled.*
          
        * /Debug symbols/ *are enabled by default* when
          + using ~cargo build~ or ~cargo run~ *without* the ~--release~ flag,
            as we have here. 

    - backtrace :: a list of all the /functions/ that have been called to get to
                   this point.

    - /Backtraces/ in Rust work like they do in other languages:
      the key to reading the backtrace is to _start from_ the top and read _until_
      you see files you wrote.
      1. The lines above the lines mentioning your files are code that your code
         called;
      2. the lines below are code that called your code.

** DONE Recoverable Errors with ~Result~ - 155
   CLOSED: [2021-01-12 Tue 16:39]
   Most errors aren't serious enough to require the program to stop entirely.
   Sometimes, when a function fails, it's for a reason that you can easily
   interpret and respond to.

   - Definition
     #+BEGIN_SRC rust
       enum Result<T, E> {
           Ok(T),
           Err(E),
       }
     #+END_SRC
     
   - Note that, like the ~Option~ /enum/, the ~Result~ /enum/ and its /variants/
     have been brought into /scope/ by the /prelude/, so we don't need to specify
     ~Result::~ before the ~Ok~ and ~Err~ /variants/ in the /match arms/.

   - Example:
     #+begin_src rust
       // Listing 9-4: Using a match expression to handle the Result variants that might
       //              be returned
       use std::fs::File;

       fn main() {
           let f = File::open("hello.txt");

           let f = match f {
               Ok(file)   => file,
               Err(error) => panic!("Problem opening the file: {:?}", error),
           };
       }
     #+end_src

*** DONE Matching on Different Errors - 158
    CLOSED: [2021-01-07 Thu 01:40]
    #+BEGIN_SRC rust
      // Listing 9-5: Handling different kinds of errors in different ways

      use std::fs::File;
      use std::io::ErrorKind;

      fn main() {
          let f = File::open("hello.txt");

          let f = match f {
              Ok(file) => file,
              Err(error) => match error.kind() {
                  ErrorKind::NotFound => match File::create("hello.txt") {
                      Ok(fc) => fc,
                      Err(e) => panic!("Problem creating the file: {:?}", e),
                  },
                  other_error => panic!("Problem opening the file: {:?}", other_error),
              },
          };
      }
    #+END_SRC

    - That's a lot of ~match~!
      The ~match~ expression is very useful but also very much a primitive.
      * =from Jian=
        The readability of nested ~match~ expressions can be bad.
        This means we need to consider some other better ways to do chained
        error handlings.

    - A more seasoned Rustacean might write
      #+begin_src rust
        use std::fs::File;
        use std::io::ErrorKind;

        fn main() {
            let f = File::open("hello.txt").unwrap_or_else(|error| {
                if error.kind() == ErrorKind::NotFound {
                    File::create("hello.txt").unwrap_or_else(|error| {
                        panic!("Problem creating the file: {:?}", error);
                    })
                } else {
                    panic!("Problem opening the file: {:?}", error);
                }
            });
        }
      #+end_src

*** DONE Shortcuts for Panic on Error: ~unwrap~ and ~expect~ - 159
    CLOSED: [2021-01-07 Thu 01:44]
    /Pattern matching/ is NOT always concise and communicate intent well.

    - ~unwrap~:
      ~let f = File::open("hello.txt").unwrap();~
      If the value is the ~Ok~ /variant/, the inside value will be returned.
      If the value is the ~Err~ /variant/, a ~panic!~ /macro/ will be called.

    - ~expect~:
      Similar as ~unwrap~, but can take a message for the ~panic!~
      ~let f = File::open("hello.txt").expect("Failed to open hello.txt");~

    - If we call ~unwrap~ in multiple places, it will take time to find out
      which one is /panic/. For ~expect~, since different ones have different
      error messages, distinguish them is simple.

*** DONE Propagating Errors - 160
    CLOSED: [2021-01-12 Tue 16:38]
    Propagate errors, and give the control to the caller:

    - Example:
      #+BEGIN_SRC rust
        // Listing 9-6: A function that returns errors to the calling code using `match`
        use std::fs::File;
        use std::io;
        use std::io::Read;

        fn read_username_from_file() -> Result<String, io::Error> {
            let f = File::open("hello.txt");

            let mut f = match f {
                Ok(file) => file,
                Err(e)   => return Err(e),
            };

            let mut s = String::new();

            match f.read_to_string(&mut s) {
                Ok(_)  => Ok(s),
                Err(e) => Err(e),
            }
        }
      #+END_SRC
      * The ~return~ above is imporatant!
        If NO ~return~, that ~Err(e)~ will be assigned to ~f~, rather than being
        returned. With this ~return~, we achieve "propagating errors".

    - This pattern of _propagating errors_ is so common in Rust that there is
      _dedicated syntax to make this easier_: ~?~.

**** DONE A Shortcut for Propagating Errors: the ~?~ Operator - 162
     CLOSED: [2021-01-07 Thu 02:06]
     #+BEGIN_SRC rust
       // Listing 9-7:
       // A function that returns errors to the calling code using the `?` operator
       use std::fs::File;
       use std::io;
       use std::io::Read;

       fn read_username_from_file() -> Result<String, io::Error> {
           let mut f = File::open("hello.txt")?;
           let mut s = String::new();
           f.read_to_string(&mut s)?;
           Ok(s)
       }
     #+END_SRC

     - ~?~ expressions can be chained
       #+begin_src rust
         use std::fs::File;
         use std::io;
         use std::io::Read;

         fn read_username_from_file() -> Result<String, io::Error> {
             let mut s = String::new();
             File::open("hello.txt")?.read_to_string(&mut s)?;
             Ok(s)
         }
       #+end_src

     - /error values/ that have the ~?~ operator called on them go through /the
       ~from~ function/, defined in the ~From~ /trait/ in the standard library,
       which is used to _CONVERT errors FROM one type INTO another._

       * When the ~?~ operator calls the ~from~ function, the /error type/
         received is converted into the /error type/ defined in the /return
         type/ of _the CURRENT function_.

       * This is useful when a /function/ returns *one* /error type/ to represent
         all the ways a function might fail, even if parts might fail for many
         different reasons.
           As long as each error type implements the ~from~ function to define
         how to convert itself to the returned /error type/, then the ~?~ operator
         _takes care of the *conversion* AUTOMATICALLY._

     - The functions ~read_username_from_file~ of different versions in this
       ~Result<T, E>~ section are designed for illustrating error handling.
       If we don't care about this illustration, there is a standard library
       fucntion can do this with a single line:
       #+begin_src rust
         use std::fs;
         use std::io;

         fn read_username_from_file() -> Result<String, io::Error> {
             fs::read_to_string("hello.txt")
         }
       #+end_src

**** DONE The ~?~ Operator Can Be Used in Functions That Return ~Result~ - 163
     CLOSED: [2021-01-12 Tue 16:38]
     We're *only allowed* to use the ~?~ operator in a function that returns
     ~Result~ or ~Option~ or another type that implements ~std::ops::Try~.

     - We will see _compilation error_ when we use the ~?~ operator in
       ~fn main() { }~, because its return type is ~()~, not ~Result<T, E>~.
       * However, ~main~ function is special, its another valid return type is
         ~Result<T, E>~. For example,
         #+begin_src rust
           use std::error::Error;
           use std::fs::File;

           fn main() -> Result<(), Box<dyn Error>> {
               let f = File::open("hello.txt")?;
               Ok(())
           }
         #+end_src

** DONE To ~panic!~ or Not To ~panic!~ - 164
   CLOSED: [2021-01-13 Wed 03:09]
   - Q :: So how do you decide
     * when you should call ~panic!~ and
     * when you should return ~Result~?

   - A :: When code /panics/, there's no way to recover.

   - You could call ~panic!~ for any error situation, whether there's a possible
     way to recover or not,
     BUT then *you're making the decision on behalf of the code calling your
     code that a situation is unrecoverable.*
     * When you choose to return a ~Result~ value, you give the calling code
       options rather than making the decision for it.
         Therefore, *returning ~Result~ is a default choice* when you're defining
       a function that might fail.
       
   - In rare situations, it's more appropriate to write code that /panics/ instead
     of returning a ~Result~. =NEXT= Let's explore why it's appropriate to panic in
     * examples
     * prototype code
     * tests.

   - =NEXT=
     Then we'll discuss situations in which the compiler can't tell that failure
     is impossible, but you as a human can.

   - =NEXT=
     The chapter will conclude with
     _some general guidelines on how to decide whether to *panic* in library
     code._
   
*** DONE Examples, Prototype Code, and Tests - 165
    CLOSED: [2021-01-13 Wed 01:00]
    - *EXAMPLES*:
      Have _robust error-handling code_ in the example
      as well can make the example _less clear_.

    - *PROTOTYPING*:
      the ~unwrap~ and ~expect~ /methods/ are very handy *when prototyping*,
      _BEFORE you're ready to decide how to handle errors._
        They leave clear markers in your code for when you're ready to make
      your program more robust.

    - *TESTS*
      You'd want the whole test to fail, even if that method isn't the
      functionality under test. Because ~panic!~ is how a test is marked as a
      failure, calling ~unwrap~ or ~expect~ is exactly what should happen.
        
*** DONE Cases in Which You Have More Information Than The Compiler -  165
    CLOSED: [2021-01-13 Wed 01:22]
    Sometimes, you may use a function that returns ~Result<T, E>~ values in such
    a specific context that you have more information than the compiler that you
    know the result is always a ~Ok<T>~ value. Then you can use ~unwrap~.
    
    - =from Jian=
      If the function you are using *ALWAYS* can do this, it means the design
      choice of your /function signature/ is wrong, and you should change your
      function return type from ~Result<T, E>~ to ~T~.

    - Example:
      #+begin_src rust
        use std::net::IpAddr;

        let home: IpAddr = "127.0.0.1".parse().unwrap();
      #+end_src
      * Here you provide a _string literal representation_ of a valid IP.
        You know the parse should and must be success.
    
      * However, when the data is _from the input_, there is _no promise to ~Ok~._

*** DONE Guidelines for Error Handling - 166 - =Re-READ=
    CLOSED: [2021-01-13 Wed 03:09]
    - It's advisable to have your code /panic/ =IMPORTANT= =RE-READ= =RE-READ= =RE-READ=
      when it's possible that your code could end up in a *bad state*.
      * bad state (in this context) :: when some _assumption_, _guarantee_,
        _contract_, or _invariant_ has been *broken*, such as
        + when /invalid values/, /contradictory values/, or /missing values/ are
          passed to your code -- plus one or more of the following:
          - The _bad state_ is
            *NOT* something that's EXPECTED to happen OCCASIONALLY.

          - Your code *after this point* needs
            to rely on *NOT* being in this _bad state_.

          - There's *NOT* a good way to
            encode this information in the /types/ you use.

    - _Your library,
      the others call functions defined inside your library:_
      1. Some well typed but invalid inputs are passed in;
      2. Use ~panic!~ to alert the person using your library to the bug in their code,
         so they can fix it during development.
         
    - Your are calling _external code_ that is _out of your control_ and
      it returns an _invalid state_ that you have no way of fixing.

    - However, _when failure is expected_, it's more appropriate to return a
      ~Result~ than to make a ~panic!~ call.
      * Examples:
        + a parser being given malformed data
        + an HTTP request returning a status that indicates you have hit a rate
          limit

      * In these cases, returning a ~Result~ indicates that _failure_ is an
        _EXPECTED POSSIBILITY_ that
        *the calling code must decide how to handle.*

    - When your code performs operations on values,
      your code should
      1. *verify* the values are _VALID_
      2. *panic* if the values are _NOT VALID_.

    - This is mostly for safety reasons:
      attempting to operate on _INVALID data_ can expose your code to
      *vulnerabilities*.

      * This is the main reason the _standard library_ will call ~panic!~ if you
        ATTEMPT an /out-of-bounds memory access/:
        trying to access memory that doesn't belong to the current data
        structure is a *common security problem*.
      
    - /Functions/ often have /contracts/:
      their behavior is only guaranteed if the inputs meet particular
      requirements.

      * *Panicking* when the /contract/ is VIOLATED makes sense
        because
        *a _contract violation_ ALWAYS INDICATES a /caller-side bug/ and it's not
        a kind of error you want the calling code to have to explicitly handle.*

        + In fact, there's no reasonable way for calling code to recover;
          the calling programmers need to fix the code.

        + /Contracts/ for a /function/, especially when a VIOLATION will cause a
          /panic/, should be explained in _the API documentation_ for the function.

    - However, having lots of /error checks/ in all of your /functions/ would be
      _VERBOSE and ANNOYING_.

      1. /Rust's type system/ (and thus the type checking the compiler does) to
         do many of the checks for you.

      2. /Function/ has a _particular type_ as a /parameter/, you can proceed
         with your code's logic knowing that the compiler has already ensured
         you have a valid value.

*** DONE Creating Custom Types for Validation - 167 - =RE-READ=
    CLOSED: [2021-01-13 Wed 03:03]
    In the "guessing game" in Chapter 2, we never validate the user's guess
    before before checking it against our secret number; we only validated
    that the guess was positive.

    - It would be a useful enhancement to guide the user toward valid guesses and
      have different behavior when a user guesses a number that's out of range
      versus when a user types, for example, letters instead.

    - One way to do this would be to parse the _guess_ as an ~i32~ instead of only
      a ~u32~ to allow potentially negative numbers, and then add a check for the
      number being in range, like so:
      #+begin_src rust
        loop {
            // --snip--

            let guess: i32 = match guess.trim().parse() {
                Ok(num) => num,
                Err(_) => continue,
            };

            if guess < 1 || guess > 100 {
                println!("The secret number will be between 1 and 100.");
                continue;
            }

            match guess.cmp(&secret_number) {
                // --snip--
            }
        }
      #+end_src
      * However, _this is *not* an ideal solution_:
        if it was absolutely critical that the program only operated on values
        between 1 and 100, and it had many functions with this requirement,
        having a check like this in every function would be tedious (and might
        impact performance).

    - Instead, we can
      _make a new type_ and
      _put the validations in a function to create an instance of the type
      rather than repeating the validations everywhere._ Then
      1. it's safe for functions to use the new type in their signatures
      2. confidently use the values they receive.
      #+begin_src rust
        // Listing 9-10: A Guess type that will only continue with values between 1 and 100
        pub struct Guess {
            value: i32,
        }

        impl Guess {
            pub fn new(value: i32) -> Guess {
                if value < 1 || value > 100 {
                    panic!("Guess value must be between 1 and 100, got {}.", value);
                }

                Guess { value }
            }

            pub fn value(&self) -> i32 {
                self.value
            }
        }
      #+end_src
      * Remember, the non-~pub~ /field/ of a /struct/ is *private*.

      * Implement an /associated function/ named ~new~ on ~Guess~ that
        _creates instances of ~Guess~ values._
        + If value doesn't pass the range check, we make a ~panic!~ call, which
          will alert the programmer who is author of the calling code that they
          have a bug they need to fix,
          because _creating a ~Guess~ with a value outside this range would
          violate the contract that ~Guess::new~ is relying on._

        + The conditions in which ~Guess::new~ might *panic* should be discussed
          in its public-facing API documentation;
          =TODO= we'll cover documentation conventions indicating the possibility
          of a ~panic!~ in the API documentation that you create in Chapter 14.

      * The /public method/ ~value~ is a getter, which is used to get the value
        of the /private field/ ~value~ of ~Guess~ /struct/.
        + code _outside the module_ *must* use the ~Guess::new~ /function/ to
          create an /instance/ of ~Guess~,
          thereby ENSURING _there's *no way* for a ~Guess~ to have a value that
          hasn't been checked by the conditions in the ~Guess::new~ function._

      * Use ~Guess~ as a /parameter/ or /returns/ of a /function/
        CAN GUARANTEE
        the ~value~ in it is in the range from 1 to 100 exclusive.
        Then there is not need to do any additional checks in its body.

** DONE Summary - 169
   CLOSED: [2017-08-23 Wed 18:46]

* DONE 10. Generic Types, Traits, and Lifetimes - 171
  CLOSED: [2021-01-11 Mon 22:24]
  In this chapter, you'll explore how to *DEFINE your own /types/, /functions/,
  and /methods/ with /generics/!*
  1. code duplication --> functions --> generic function
     * Explain how to use /generic types/ in ~struct~ and ~enum~ definitions.

  2. Learn how to use /traits/ to define behavior _in a generic way_.
     * Combine /traits/ with /generic types/ to *constrain* a /generic type/ to
       only those types/ /that have a particular behavior, as opposed to just
       ANY /type/.

  3. Discuss /lifetimes/, a variety of generics that give the compiler
     information about _how /references/ relate to each other._
     * /Lifetimes/ allow us to borrow values in many situations
       while still enabling the compiler to check that the /references/ are
       _VALID_.
  
** DONE Removing Duplication by Extracting a Function - 172
   CLOSED: [2021-01-10 Sun 02:44]
** DONE 10.1 Generic Data Types - 174
   CLOSED: [2021-01-11 Mon 22:19]
*** DONE In Function Definitions - 174
    CLOSED: [2021-01-11 Mon 22:11]
    #+begin_src rust
      use std::cmp::PartialOrd;

      fn largest<T: PartialOrd>(list: &[T]) -> &T {
          let mut largest = &list[0];

          for item in list {
              if item > largest {
                  largest = item;
              }
          }

          largest
      }

      fn main() {
          let number_list = vec![34, 50, 25, 100, 65];

          let result = largest(&number_list);
          println!("The largest number is {}", result);

          let char_list = vec!['y', 'm', 'a', 'q'];

          let result = largest(&char_list);
          println!("The largest char is {}", result);
      }
    #+end_src 
    =from Jian=
    The original code example of this Listing 10-5 doesn't include the
    ~PartialOrd~ /trait bound/.

*** DONE In Struct Definitions - 177
    CLOSED: [2021-01-11 Mon 22:12]
    Examples:

    - Single type variable
      #+BEGIN_SRC rust
        struct Point<T> {
            x: T,
            y: T,
        }

        fn main() {
            let integer = Point { x: 5, y: 10 };
            let float = Point { x: 1.0, y: 4.0 };
        }
      #+END_SRC

    - Double type variables
      #+BEGIN_SRC rust
        struct Point<T, U> {
            x: T,
            y: U,
        }

        fn main() {
            let both_integer = Point { x: 5, y: 10 };
            let both_float = Point { x: 1.0, y: 4.0 };
            let integer_and_float = Point { x: 5, y: 4.0 };
        }
      #+END_SRC

*** DONE In Enum Definitions - 178
    CLOSED: [2021-01-11 Mon 22:12]
    #+BEGIN_SRC rust
      enum Option<T> {
          Some(T),
          None,
      }

      enum Result<T, E> {
          Ok(T),
          Err(E),
      }
    #+END_SRC

*** DONE In Method Definitions - 179
    CLOSED: [2021-01-11 Mon 22:15]
    #+BEGIN_SRC rust
      struct Point<T> {
          x: T,
          y: T,
      }

      impl<T> Point<T> {
          fn x(&self) -> &T {
              &self.x
          }
      }

      fn main() {
          let p = Point { x: 5, y: 10 };
          println!("p.x = {}", p.x());
      }
    #+END_SRC

    The methods can have different generic types:
    #+BEGIN_SRC rust
      // src/main.rs

      struct Point<T, U> {
          x: T,
          y: U,
      }

      impl<T, U> Point<T, U> {
          fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
              Point {
                  x: self.x,
                  y: other.y,
              }
          }
      }

      fn main() {
          let p1 = Point { x: 5, y: 10.4 };
          let p2 = Point { x: "Hello", y: 'c' };

          let p3 = p1.mixup(p2);

          println!("p3.x = {}, p3.y ={}", p3.x, p3.y);
      }
    #+END_SRC

*** DONE Performance of Code Using Generics - 181
    CLOSED: [2021-01-11 Mon 22:19]
    - Rust generics has no runtime cost if you had specified concrete types.

    - Rust accomplishes this by performing /monomorphization/ of the code that is
      using /generics/ _at compile time._

    - /monomorphization/ :: the process of turning generic code into specific
         code with the concrete types that are actually used filled in.
      * The _monomorphized version of the code_ looks like the following:
        #+begin_src rust
          // You write the code below in `main`:
          //
          // let integer = Some(5);
          // let float = Some(5.0);

          enum Option_i32 {
              Some(i32),
              None,
          }

          enum Option_f64 {
              Some(f64),
              None,
          }

          fn main() {
              let integer = Option_i32::Some(5);
              let float = Option_f64::Some(5.0);
          }
        #+end_src

** DONE 10.2 Traits: Defining Shared Behavior - 182
   CLOSED: [2021-01-10 Sun 23:56]
   - We can use /traits/ to DEFINE _shared behavior_ _in an abstract way_.

   - We can use /trait bounds/ to specify that a /generic/ can be any /type/ that
     has _certain behavior_.

*** DONE Defining a Trait - 182
    CLOSED: [2017-08-23 Wed 22:54]
    - /Trait definitions/ are a way to _group /method signatures/ together_ to
      DEFINE _a set of behaviors_ necessary to accomplish some purpose.

    - Description:
      #+BEGIN_SRC rust
        // Listing 10-12
        pub trait Summary {
            fn summarize(&self) -> String;
        }
      #+END_SRC
      
*** DONE Implementing a Trait on a Type - 183
    CLOSED: [2021-01-10 Sun 03:03]
    #+begin_src rust
      // lib.rs
      pub struct NewsArticle {
          pub headline: String,
          pub location: String,
          pub author: String,
          pub content: String,
      }

      impl Summary for NewsArticle {
          fn summarize(&self) -> String {
              format!("{}, by {} ({})", self.headline, self.author, self.location)
          }
      }

      pub struct Tweet {
          pub username: String,
          pub content: String,
          pub reply: bool,
          pub retweet: bool,
      }

      impl Summary for Tweet {
          fn summarize(&self) -> String {
              format!("{}: {}", self.username, self.content)
          }
      }
    #+end_src

    - _Restriction_: =IMPORTANT=
      We can implement a /trait/ on a /type/ ONLY IF
      _either_ the /trait/ _or_ the /type/ are local to our crate.
      * This restriction is part of a property of programs called /coherence/, and
        more specifically the /orphan rule/, *so named because the parent type is
        not present.*
        + This rule ensures that other people's code can't break your code and
          vice versa.

        + Without the rule, two /crates/ could implement the SAME /trait/
          for the SAME /type/, and Rust wouldn't know which implementation to
          use.
          =TODO=
          =CONSIDER MORE and Write some code that violate this to check the details=

*** DONE Default Implementations - 185
    CLOSED: [2021-01-10 Sun 15:42]
    Sometimes it's useful to have /default behavior/ for some or all of the
    /methods/ in a /trait/ instead of requiring implementations for ALL
    /methods/ on EVERY /type/.
      Then, as we implement the /trait/ _on a PARTICULAR /type/,_ we can keep or
    *override* each /method's default behavior/.
    
    - A /trait definition/ that includes a /default implemention/,
      #+begin_src rust
        // Listing 10-14: Definition of a Summary trait with a default implementation of
        //                the summarize method
        pub trait Summary {
            fn summarize(&self) -> String {
                String::from("(Read more...)")
            }
        }
      #+end_src
      * To implement a /trait/ for a /type/, and use the /default implementation/
        that included in this /trait/:
        #+begin_src rust
          impl Summary for NewArticle {}
        #+end_src

    - The syntax for overriding a default implementation is exactly _the same as_
      the syntax for implementing a trait method that doesn't have a /default
      implementation/.
      * This is why even if we include a /default implemention/ in ~Summary~,
        this won't affect the code in 10-13 about ~Tweet~.
      
    - /Default implementations/ are allowed to call the other methods in the same
      trait, even if those other methods don't have a /default implementation/.
      #+BEGIN_SRC rust
        pub trait Summary {
            fn summarize_author(&self) -> String;

            fn summarize(&self) -> String {
                format!("(Read more from {}...)", self.summarize_author())
            }
        }
      #+END_SRC
      In order to use this version of ~Summary~, we're _only_ required to define
      ~summarize_author~ when we implement the /trait/ on a /type/:
      #+BEGIN_SRC rust
        // This implementation of `Tweet` use the default implementation of `summarize`
        impl Summary for Tweet {
            fn summarize_author(&self) -> String {
                format!("@{}", self.username)
            }
        }
      #+END_SRC

    - Note:
      that it is _not possible_ to call the default implementation from an
      overriding implementation.
      =TODO=
      _Kind of reasonable, but not always good. Why with this restriction???_

*** DONE Trait as Parameters - 186
    CLOSED: [2021-01-10 Sun 16:14]
    We can explore how to use /traits/ to define functions that _accept many
    different types._
    #+begin_src rust
      pub fn notify(item: &impl Summary) {
          println!("Breaking news! {}", item.summarize());
      }
    #+end_src
      
**** DONE Trait Bound Syntax - 187
     CLOSED: [2021-01-10 Sun 15:57]
     The ~impl Trait~ syntax works for straightforward cases but is _actually
     syntax sugar for a longer form, which is called a /trait bound/;_ it looks
     like this:
     #+begin_src rust
       pub fn notify<T: Summary>(item: &T) {
           println!("Breaking news! {}", item.summarize());
       }
     #+end_src
     
     - The ~impl Trait~ syntax is _convenient_ and makes for _more concise_ code
       _in simple cases._
       The /trait bound/ syntax _can express more complexity_ in other cases.

       Here is a example:
       #+begin_src rust
         pub fn notify(item1: &impl Summary, item2: &impl Summary) {}
       #+end_src
       * If ~item1~ and ~item2~ have *different types*, using ~impl Trait~ would
         be appropriate.

       * If we wanted to _FORCE BOTH parameters to have the *same type*,_
         that's only possible to express using a /trait bound/, and we _MUST_
         re-write the above example as:
         #+begin_src rust
           pub fn notify<T: Summary>(item1: &T, item2: &T) {}
         #+end_src
     
**** DONE Specifying Multiple Trait Bound with the ~+~ Syntax  - 187
     CLOSED: [2021-01-10 Sun 15:59]
     - Use the ~impl Trait~ syntax:
       #+begin_src rust
         pub fn notify(item: &(impl Summary + Display)) {}
       #+end_src
       
     - Use the /trait bound/ syntax:
       #+begin_src rust
         pub fn notify<T: Summary + Display>(item: &T) {}
       #+end_src
     
**** DONE Clearer Trait Bounds with ~where~ Clauses - 188
     CLOSED: [2021-01-10 Sun 16:04]
     Rust has _ALTERNATE syntax_ for specifying /trait bounds/ inside a ~where~
     clause after the /function signature/.
       This syntax is less cluttered than the syntax we see before this section
     when using *many* /trait bounds/:
     #+begin_src rust
       fn some_function<T: Clone + Display , U: Clone + Debug>(t: &T, u: &U) -> i32 {}
     #+end_src
     
     can be written with ~where~ as:
     
     #+begin_src rust
       fn some_function<T, U>(t: &T, u: &U) -> i32
           where T: Clone + Display,
                 U: Clone + Debug {
       }
     #+end_src
     
**** DONE Returning Types that Implement Traits - 188
     CLOSED: [2021-01-10 Sun 16:14]
     We can also use the ~impl Trait~ syntax in the _return position_ to return a
     value of some /type/ that implements a /trait/.

     - Example:
       #+BEGIN_SRC rust
         pub fn return_summarizable() -> impl Summary {
             Tweet {
                 username: String::from("horse_ebooks"),
                 content: String::from("of course, as you probably already know, people"),
                 reply: false,
                 retweet: false
             }
         }
       #+END_SRC

     - =TODO=
       The ability to _return a /type/ that is only specified by the /trait/ it
       implements_ is especially useful in the context of /closures/ and /iterators/,
       =TODO= which we cover in Chapter 13.

       * /Closures/ and /iterators/ create /types/ that _only the compiler knows_
         or _types that are very long to specify_.
           The ~impl Trait~ syntax lets you concisely specify that a function
         returns some type that implements the ~Iterator~ /trait/ *WITHOUT
         needing to write out a very LONG /type/.*

     - However, you can only use ~impl Trait~ if you're returning a single type.
       For example, this code that returns either a ~NewsArticle~ or a ~Tweet~
       with _the /return type/ specified as ~impl Summary~ *wouldn't work*:_
       #+begin_src rust
         // DOESN'T COMPILE!!!

         fn returns_summarizable(switch: bool) -> impl Summary {
             if switch {
                 NewsArticle {
                     headline: String::from(
                         "Penguins win the Stanley Cup Championship!",
                     ),
                     location: String::from("Pittsburgh, PA, USA"),
                     author: String::from("Iceburgh"),
                     content: String::from(
                         "The Pittsburgh Penguins once again are the best \
                          hockey team in the NHL.",
                     ),
                 }
             } else {
                 Tweet {
                     username: String::from("horse_ebooks"),
                     content: String::from(
                         "of course, as you probably already know, people",
                     ),
                     reply: false,
                     retweet: false,
                 }
             }
         }
       #+end_src
       This is due to the restrictions around how the ~impl Trait~ syntax is
       implemented in the compiler.
       =TODO= =TODO= =TODO=
         We'll cover how to write a function with this behavior in the “Using
       Trait Objects That Allow for Values of Different Types” section of
       Chapter 17.
       
*** DONE Fixing the ~largest~ Function with Trait Bounds - 189
    CLOSED: [2021-01-10 Sun 16:25]
    - Wrong version:
      * Without the /trait bounds/ ~std::cmp::PartialOrd~

      * Only ~std::cmp::PartialOrd~ is OK, but the /type signature/ should be
        ~&[T] -> &T~ and some change(s) should be make to the body of this
        function (Check the last implementation in this section of this note,
        which is not given in this book).

    - ~+ Copy~ version
      #+BEGIN_SRC rust
        use std::cmp::PartialOrd;

        fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
            let mut largest_item = list[0];

            for &item in list {
                if item > largest_item {
                    largest_item = item;
                }
            }

            largest_item
        }

        fn main() {
            let number_list = vec![34, 50, 25, 100, 65];

            let result = largest(&number_list);
            println!("The largest number is {}", result);

            let char_list = vec!['y', 'm', 'a', 'q'];

            let result = largest(&char_list);
            println!("The largest char is {}", result);
        }
      #+END_SRC

    - ~+ Clone~ version
      Using the ~clone~ /function/ means we're potentially making more /heap
      allocations/ in the case of _types that own heap data_ like ~String~, and
      /heap allocations/ can be slow if we're working with large amounts of data.

    - Return ~&T~ version (least /trait bounds/):
      #+BEGIN_SRC rust
        fn largest<T: PartialOrd>(list: &[T]) -> &T {
            let mut largest_item = &list[0];
            // 1. precedence:
            //    `&list[0]` means `&(list[0])` (type `&T`)
            //    rather than `(&list)[0]` (type `T`).
            //
            // 2. Use `&` ONLY here is the simplest way to implement a function
            //    of this type signature.

            for item in list {
            // `iter()` of a &[T] returns `&T`, which is the type of `item`
                if item > largest_item {
                    largest_item = item;
                }
            }

            largest_item
        }
      #+END_SRC

*** DONE Using Trait Bounds to Conditionally Implement Methods - 191
    CLOSED: [2021-01-10 Sun 23:56]
    - We can
      implement some /methods/ for all kind of /type parameters/, and
      *conditionally* implement some /methods/ for /type parameters/ that satisfy
      some /trait bound(s)/.
      * Here we use multiple ~impl~ blocks.

      * For example,
        #+begin_src rust
          // Listing 10-16: Conditionally implement methods on a generic type
          //                depending on trait bounds

          use std::fmt::Display;

          struct Pair<T> {
              x: T,
              y: T,
          }

          impl<T> Pair<T> {
              fn new(x: T, y: T) -> Self {
                  Self { x, y }
              }
          }

          impl<T: Display + PartialOrd> Pair<T> {
              fn cmp_display(&self) {
                  if self.x >= self.y {
                      println!("The largest member is x = {}", self.x);
                  } else {
                      println!("The largest member is y = {}", self.y);
                  }
              }
          }
        #+end_src

    - We can
      *conditionally* implement a /trait/ for _ANY_ /type/ that implements ANOTHER
      /trait/.
      * blanket implementations :: implementations of a /trait/ on any /type/ that
        satisfies the /trait bounds/.

      * /blanket implementations/ are extensively used in the Rust standard library.

      * For example, the standard library implements the ~ToString~ /trait/ on
        ANY /type/ that implements the ~Display~ /trait/.
        The ~impl~ block in the standard library looks similar to this code:
        #+begin_src rust
          impl<T: Display> ToString for T {
              // --snip--
          }
        #+end_src

      * /Blanket implementations/ appear in the documentation for the /trait/ in
        the “Implementors” section.

** DONE 10.3 Validating References with Lifetimes - 192
   CLOSED: [2021-01-11 Mon 03:55]
   - One detail we didn't discuss in
     _the “References and Borrowing” section in Chapter 4_
     is that EVERY /reference/ in Rust has a /lifetime/, which is the /scope/ for
     which that /reference/ is VALID.
     * =from Jian=
       This is a completion of the “References and Borrowing” section.
       Go back to read this seciton again.

   - MOST of the time /lifetimes/ are _implict_ and _inferred_, just like most of
     the time /types/ are inferred.

   - Since there are cases that the /lifetimes/ of /references/ could be related
     in a few DIFFERENT WAYS, Rust needs us to annotate the relationships using
     /generic lifetime parameters/ so that it can make sure the actual references
     used at runtime will definitely be valid.

   - Although we won't cover /lifetimes/ in their entirety in this chapter, we'll
     discuss common ways you might encounter /lifetime/ syntax so you can become
     familiar with the concepts.
     =TODO= =Learn more about the comprehensive knowledge=

*** DONE Preventing Dangling References with Lifetimes - 193
    CLOSED: [2021-01-11 Mon 00:27]
    - Example:
      #+BEGIN_SRC rust
        // NOT compilable
        {
            let r;

            {
                let x = 5;
                r = &x;
            }

            println!("r: {}", r);
        }
      #+END_SRC
      
      Compile error:
      #+begin_src text
           Compiling chapter10 v0.1.0 (file:///projects/chapter10)
        error[E0597]: `x` does not live long enough
          --> src/main.rs:7:17
           |
        7  |             r = &x;
           |                 ^^ borrowed value does not live long enough
        8  |         }
           |         - `x` dropped here while still borrowed
        9  | 
        10 |         println!("r: {}", r);
           |                           - borrow later used here

        error: aborting due to previous error

        For more information about this error, try `rustc --explain E0597`.
        error: could not compile `chapter10`.

        To learn more, run the command again with --verbose.
      #+end_src

    - *Uninitialized Variables Cannot Be Used*
      At the first glance, code like
      #+begin_src rust
        {
            let r: i32;
            {
                let r = 3;
            }
            println!("r: {}", r);
        }
      #+end_src
      is conflict with Rust's having no null values.
      However, it isn't. The compiler can detect the use of /uninitialized
      variables/. The ~r~ above is initialized before being used.

    - Q :: How does Rust determine that this code is invalid?
    - A :: It uses a /borrow checker/.

*** DONE The Borrow Checker - 194
    CLOSED: [2021-01-11 Mon 00:31]
    - /borrow checker/ :: a part of the Rust compiler, which compares /scopes/ to
                          determine that all borrows are valid.

    - An example of lifetime:
      #+BEGIN_SRC rust
        {
            let r;         // ---------+-- 'a
                           //          |
            {              //          |
                let x = 5; // -+-- 'b  |
                r = &x;    //  |       |
            }              // -+       |
                           //          |
            println!("r: {}", r); //   |
                           //          |
                           // ---------+
        }
      #+END_SRC

    - Fix the example above by *removing* the /inner scope boundary/:
      #+BEGIN_SRC rust
        {
            let x = 5;            // ----------+-- 'b
                                  //           |
            let r = &x;           // --+-- 'a  |
                                  //   |       |
            println!("r: {}", r); //   |       |
                                  // --+       |
        }                         // ----------+
      #+END_SRC

*** DONE Generic Lifetimes in Functions - 195
    CLOSED: [2021-01-11 Mon 01:39]
    #+BEGIN_SRC rust
      // NOT compilable
      fn longest(x: &str, y: &str) -> &str {
          if x.len() > y.len() {
              x
          } else {
              y
          }
      }
    #+END_SRC
    
    Compile error:
    #+begin_src text
         Compiling chapter10 v0.1.0 (file:///projects/chapter10)
      error[E0106]: missing lifetime specifier
       --> src/main.rs:9:33
        |
      9 | fn longest(x: &str, y: &str) -> &str {
        |                                 ^ expected lifetime parameter
        |
        = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`

      error: aborting due to previous error

      For more information about this error, try `rustc --explain E0106`.
      error: could not compile `chapter10`.

      To learn more, run the command again with --verbose.
    #+end_src

    - When we're defining this function,
      * we _DON'T KNOW_ the CONCRETE /values/ that will be passed into this function,
        so we *don't* know whether the ~if~ case or the ~else~ case will execute.

      * we also _DON'T KNOW_ the CONCRETE /lifetimes/ of the /references/ that
        will be passed in, so we *can't* look at the /scopes/ as we did in
        Listings 10-18 and 10-19 to determine whether the /reference/ we return
        will always be VALID.
          The _borrow checker_ *can't* determine this either,
        because it _DOESN'T KNOW_ HOW the /lifetimes/ of ~x~ and ~y~ relate to
        the /lifetime/ of the _return value_.

      * To fix this error,
        we'll add /generic lifetime parameters/ that define _the relationship
        between the /references/_ so the /borrow checker/ can perform its
        analysis.
      
*** DONE Lifetime Annotation Syntax - 196
    CLOSED: [2021-01-11 Mon 00:46]
    - /Lifetime/ annotations DO NOT change how long any of the /references/
      involved live.

    - Just as /functions/ can accept _ANY /type/_ when the /signature/ specifies
      a /generic TYPE parameter/, functions can accept /references/ with _ANY
      /lifetime/_ by specifying a /generic LIFETIME parameter/.
      * This means *isolated single* /lifetime annotation/ deesn't have much
        meaning.

    - /lifetime annotations/ *relate* the /lifetimes/ of multiple /references/ to
      each other.

    - /Lifetime annotation/ syntax:
      * start with ~'~
      * usually all lowercase
      * usually very short
      * after the ~&~ of a reference, and
      * a space *separates* the /lifetime annotation/ from the /reference's type/.

    - Examples:
      * a reference: ~&i32~
      * a reference with an explicit lifetime: ~&'a i32~
      * a mutable reference with an explicit lifetime: ~&'a mut i32~

*** DONE Lifetime Annotations in Function Signatures - 197
    CLOSED: [2021-01-11 Mon 03:55]
    Now let's examine /lifetime annotations/ in the context of the ~longest~
    /function/. 
    #+BEGIN_SRC rust
      fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
          if x.len() > y.len() {
              x
          } else {
              y
          }
      }
    #+END_SRC
    - The /function signature/ now tells Rust that
      for some /lifetime/ ~'a~,
      * the function takes two /parameters/, both of which are /string slices/
        that *live at least as long as /lifetime/ ~'a~.*

      * the /string slice/ returned from the /function/ will
        *live at least as long as /lifetime/ ~'a~.*

    - In practice, the /function signature/ means that
      the /lifetime/ of the _returned /reference/_ is *the same as the smaller*
      of the /lifetimes/ of the _passed-in /references/._ -- these constraints
      are what we want Rust to enforce.

    - Remember,
      when we specify the /lifetime parameters/ in a /function signature/,
      we're *NOT* changing the /lifetimes/ of any values passed in or returned.
        Rather, we're specifying that the _borrow checker_ should *reject* _any
      values that don't adhere to these /constraints/._

    - Note:
      the ~longest~ /function/
      * *doesn't need to know* EXACTLY how long ~x~ and ~y~ will live,
      * ONLY that some /scope/ can be substituted for ~'a~ that will satisfy this
        /signature/.

    - When annotating /lifetimes/ in /functions/,
      * the annotations go in the /function signature/,
      * *not* in the /function body/.

    - Rust can analyze the code *within* the function without any help.
    - However, when a /function/ has /references/ *to or from code outside* that
      /function/, it becomes *ALMOST IMPOSSIBLE* for Rust to figure out _the
      /lifetimes/ of the parameters_ or _return values_ on its own.
      The /lifetimes/ might be different each time the /function/ is called.
      * =from Jian=
        This is why we need manually annotated /lifetime/ relationship, which can
        help providing extra info to eliminate ambiguity.

    - When we pass /concrete references/ to ~longest~, the /concrete lifetime/
      that is substituted for ~'a~ is the part of the /scope/ of ~x~ that overlaps
      with the /scope/ of ~y~.
        In other words, the /generic lifetime/ ~'a~ will get the /concrete
      lifetime/ that _is EQUAL to_ *the _SMALLER_ of the /lifetimes/ of ~x~ and
      ~y~.*

        Because we've annotated the /returned reference/ with the SAME /lifetime
      parameter/ ~'a~, *the /returned reference/ will also be valid for the
      length of the _SMALLER_ of the /lifetimes/ of ~x~ and ~y~.*

    - Let's look at how the lifetime annotations restrict the longest function by
      passing in references that have different concrete lifetimes. Listing
      10-23 is a straightforward example.
      #+begin_src rust
        // Listing 10-23: Using the longest function with references to String values
        //                that have different concrete lifetimes
        fn main() {
            let string1 = String::from("long string is long");
            {
                let string2 = String::from("xyz");
                let result = longest(string1.as_str(), string2.as_str());
                println!("The longest string is {}", result);
            }
        }
      #+end_src
      * In this compilable (approved by /borrow checker/) example,
        1. ~string1~ is _VALID until_ the end of the /outer scope/,
        2. ~string2~ is _VALID until_ the end of the /inner scope/, and
        3. ~result~ references something that is _VALID until_ the end of the
           /inner scope/.
           
    - In this *NOT* compilable (rejected by /borrow checker/) example,
      #+begin_src rust
        // NOT compilable

        // List 10-24: Attempting to use `result` after `string2` has gone out of scope
        fn main() {
            let string1 = String::from("long string is long");
            let result;
            {
                let string2 = String::from("xyz");
                result = longest(string1.as_str(), string2.as_str());
            }
            println!("The longest string is {}", result);
        }
      #+end_src

      Compile error:
      #+begin_src text
           Compiling chapter10 v0.1.0 (file:///projects/chapter10)
        error[E0597]: `string2` does not live long enough
         --> src/main.rs:6:44
          |
        6 |         result = longest(string1.as_str(), string2.as_str());
          |                                            ^^^^^^^ borrowed value does not live long enough
        7 |     }
          |     - `string2` dropped here while still borrowed
        8 |     println!("The longest string is {}", result);
          |                                          ------ borrow later used here

        error: aborting due to previous error

        For more information about this error, try `rustc --explain E0597`.
        error: could not compile `chapter10`.

        To learn more, run the command again with --verbose.
      #+end_src
      * Since we human know the value of ~string1~ and ~string2~ here,
        we know this is a piece of workible code if the borrow checker is turned
        off.
          However, the compiler can't do this -- the passed in values will change
        in other call sites. The compiler must use the /borrow checker/ to do a
        general check according to the /lifetime annotations/.

*** DONE Thinking in Terms of Lifetimes - 199
    CLOSED: [2021-01-11 Mon 01:20]
    The way in which you need to specify /lifetime parameters/ depends on _what
    your /function/ is doing._

    - For example,
      if the result is only related to some parameters, just annotate those
      parameters.
      #+BEGIN_SRC rust
        // Of course, `y` does NOT have any relationship with the lifetime of `x`
        // or the return value.
        fn longest<'a>(x: &'a str, y: &str) -> &'a str {
            x
        }
      #+END_SRC
      * Actually, you CANNOT annotate the unrelated lifetime:
        ~fn longest<'a>(x: &'a str, y: &'b str) -> &'a str {~ cannot be accepted
        by the compiler -- the /lifetime/ of ~y~ does not have any relationship
        with the /lifetime/ of ~x~ or the _return value_.

    - You _CANNOT_ do this:
      #+BEGIN_SRC rust
        fn longest<'a>(x: &str, y: &str) -> &'a str {
            let result = String::from("really long string");
            result.as_str()  // this is a string slice
        }
      #+END_SRC
      
      Compile error:
      #+begin_src text
           Compiling chapter10 v0.1.0 (file:///projects/chapter10)
        error[E0515]: cannot return value referencing local variable `result`
          --> src/main.rs:11:5
           |
        11 |     result.as_str()
           |     ------^^^^^^^^^
           |     |
           |     returns a value referencing data owned by the current function
           |     `result` is borrowed here

        error: aborting due to previous error

        For more information about this error, try `rustc --explain E0515`.
        error: could not compile `chapter10`.

        To learn more, run the command again with --verbose.
      #+end_src
      The problem is that ~result~ _goes out of scope_ and _gets cleaned up at the
      end of the ~longest~ function._ There is no way we can specify /lifetime
      parameters/ that would change the /dangling reference/, and Rust won't let
      us create a /dangling reference/.
      * In this case, the best fix would be return an /owned data type/:
        ~String~.

    - Ultimately, _lifetime syntax_ is about *connecting* the /lifetimes/ of _various
      arguments_ *and* _return values_ of functions.
        Once they're connected, Rust has enough information to allow memory-safe
      operations and disallow operations that would create /dangling pointers/ or
      _otherwise violate memory safety_.

*** DONE Lifetime Annotations in Struct Definitions - 200
    CLOSED: [2021-01-11 Mon 01:31]
    _Till now_, we've only defined _/structs/ to hold owned types_.
      It is also possible for /structs/ to hold /references/, but we need to add
    a /lifetime annotation/ on *EVERY* /reference/ in the _struct's definition_.

    #+BEGIN_SRC rust
      // Listing 10-25: A struct that holds a reference, so its definition needs a
      //                lifetime annotation
      struct ImportantExcerpt<'a> {
          part: &'a str,
      }

      fn main() {
          let novel = String::from("Call me Ishmael. Some years ago...");
          let first_sentence = novel.split('.').next().expect("Could not find a '.'");
          let i = ImportantExcerpt {
              part: first_sentence
          };
      }
    #+END_SRC
    - Struct definition:
      * This /struct/ has one /field/, ~part~, that holds a /string slice/, which
        is a /reference/.

      * The /generic lifetime parameter/ in this _struct definition_ means an
        /instance/ of ~ImportantExcerpt~ can't outlive the /reference/ it holds
        in its ~part~ /field/.
        =IMPORTANT=

    - Usage:
      In the ~main~ function, the data in ~novel~ exists before the
      ~ImportantExcerpt~ /instance/ is created, and ~novel~ _DOESN'T go out of
      scope UNTIL AFTER the ~ImportantExcerpt~ goes out of scope,_ so the
      /reference/ in the ~ImportantExcerpt~ /instance/ is VALID.

*** DONE Lifetime Elision - 201
    CLOSED: [2021-01-11 Mon 02:04]
    - EVERY /reference/ has a /lifetime/, and /lifetime parameters/ need to be
      specified for /functions/ or /structs/ that use /references/.
      _However, here "specify" *doesn't* always mean "manually specify"._
      #+BEGIN_SRC rust
        // Listing 10-26: A function we defined in Listing 4-9 that compiled without
        //                lifetime annotations, even though the parameter and return type
        //                are references
        fn first_word(s: &str) -> &str {
            let bytes = s.as_bytes();

            for (i, &item) in bytes.iter().enumerate() {
                if item == b' ' {
                    return &s[0..i];
                }
            }

            &s[..]
        }
      #+END_SRC
      * Pre-1.0 Rust wouldn't have this program compiled.
        EVERY /reference/ needed an EXPLICIT /lifetime/.

      * After coding a lot, the Rust team found there are some situations that
        were predictable and followed a few deterministic patterns.
          Then the Rust team code programmed these patterns into the compiler's
        code so the _borrow checker_ could infer the /lifetimes/ in these
        situations and wouldn't need EXPLICIT annotations.

      * This piece of Rust history is relevant
        BECAUSE it's possible that more deterministic patterns will emerge and
        be added to the compiler. In the future, even fewer lifetime annotations
        might be required.

    - /lifetime elision rules/ ::
      a set of particular cases that the compiler will consider, and if your
      code fits these cases, you don't need to write the /lifetimes/ EXPLICITLY.

    - The /elision rules/ do *NOT* provide _FULL_ inference:
      if there is still ambiguity after applying these rules, Rust will issue an
      error.

    - /input lifetimes/: lifetimes on function parameters or method parameters.

    - /output lifetimes/: lifetimes on return values.

    - The compiler uses _THREE_ rules to figure out what /lifetimes/ /references/
      have when there aren't EXPLICIT annotations.
      * The _first_ rule applies to /input lifetimes/
      * the _second and third_ rules apply to /output lifetimes/.

      If the compiler gets to the end of the _THREE_ rules and there are still
      /references/ for which it can't figure out /lifetimes/, the compiler will
      stop with an error. These rules apply to ~fn~ definitions as well as ~impl~
      blocks.

    - /Elision Rules/:
      1. Each parameter that is a /reference/ gets its _OWN_ /lifetime parameter/.
         In other words,
         * a function with one parameter gets one /lifetime parameter/:
           #+begin_src rust
             fn foo<'a>(x: &'a i32)
           #+end_src
         * a function with two arguments gets two separate lifetime parameters:
           #+begin_src rust
             fn foo<'a, 'b>(x: &'a i32, y: &'b i32)
           #+end_src
         * and so on.

      2. If there is *exactly one* /input lifetime parameter/, that /lifetime/ is
         assigned to *ALL* /output lifetime parameters/:
         #+begin_src rust
           fn foo<'a>(x: &'a i32) -> &'a i32
         #+end_src

      3. If there are MULTIPLE /input lifetime parameters/, but one of them is
         ~&self~ or ~&mut self~ because this is a /method/, then the /lifetime/
         of ~self~ is assigned to *all* /output lifetime parameters/.
         _This makes /methods/ much nicer to read and write because it gets rid of
         cluter symbols._

    - Let's practice to apply these rules:
      * ~fn first_word(s: str) -> &str {~
        + rule 1 - ~fn first_word<'a>(s: &'a str) -> &str {~
        + rule 2 - ~fn first_word<'a>(s: &'a str) -> &'a str {~

      * ~fn longest(x: &str, y: &str) -> &str {~
        + rule 1 - ~fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {~
        + rule 2 - NOT *exactly one* /input parameter/, can't apply this rule
        + rule 2 - NOT a /method/, can't apply this rule

    - =NEXT=
      Because the _third rule_ only really applied in /method signatures/,
      let's look at /lifetimes/ in that context now, and see why the _third rule_
      means we don't have to annotate /lifetimes/ in /method signatures/ very often.

*** DONE Lifetime Annotations in Method Definitions - 203
    CLOSED: [2021-01-11 Mon 02:54]
    - Apply rule 1
      #+BEGIN_SRC rust
        // The lifetime parameter declaration
        // after `impl` and
        // use after the type name is required, but we're not required to
        // annotate the lifetime of the first elition rule.
        //
        // first elison rule
        impl<'a> ImportantExcerpt<'a> {
            fn level<'b>(&self: &'b Self) -> i32 {
                3
            }
        }
      #+END_SRC

    - Apply rule 3
      #+BEGIN_SRC rust
        impl<'a> ImportantExcerpt<'a> {
            fn announce_and_return_part<'b, 'c>(&self: &'b Self,
                                                announcement: &'c str) -> &'b str {
                pinntln!("Attention please: {}", announcement);
                self.part
            }
        }
      #+END_SRC

*** DONE The Static Lifetime - 204
    CLOSED: [2021-01-11 Mon 01:08]
    - ~'stack~ :: the entire duration of the program.

    - Example:
      #+begin_src rust
        let s: &'static str = "I have a static lifetime.";
      #+end_src
      The text of this /string/ is _stored directly in the binary of your program_
      and the binary of your program is always available.
      Therefore, *the lifetime of all /string literals/ is ~'static~.*

    - Sometimes compiler suggests you to use ~'static~ somewhere. =IMPORTANT=
      * But before specifying ~'static~ as the /lifetime/ for a /reference/,
        Ask yourself
        + Q :: WHETHER the /reference/ you have actually lives the ENTIRE /lifetime/
                of your program or not.

        + You might consider whether you want it to live that long, even if it
          could.

        + _MOST of the time,_
          the problem results from attempting to /create a dangling reference/
          or _a mismatch of the available /lifetimes/._
            In such cases, the solution is fixing those problems, not specifying
          the ~'static~ /lifetime/ to walkaround.

** DONE Generic Type Parameters, Trait Bounds, and Lifetimes Together - 205
   CLOSED: [2021-01-11 Mon 02:58]
   Let's briefly look at the syntax of specifying /generic type parameters/,
   /trait bounds/, and /lifetimes/ ALL in one /function/!
   #+BEGIN_SRC rust
     use std::fmt::Display;

     fn longest_with_an_announcement<'a, T>(
         x: &'a str,
         y: &'a str,
         ann: T,
     ) -> &'a str
     where
         T: Display,
     {
         println!("Announcement! {}", ann);
         if x.len() > y.len() {
             x
         } else {
             y
         }
     }
   #+END_SRC

** DONE Summary - 205
   CLOSED: [2021-01-11 Mon 02:59]

* DONE 11. Writing Automated Tests - 207
  CLOSED: [2021-01-15 Fri 03:46]
  - We'll discuss the mechanics of Rust's testing facilities.
    We'll talk about
    * the /annotations/ and /macros/
      available to you when *writing* your tests,

    * the _default behavior_ and _options_
      provided for *running* your tests,

    * how to *organize* tests *into* /unit tests/ and /integration tests/.

** DONE How to Write Tests - 208
   CLOSED: [2021-01-15 Fri 02:21]
   The features Rust provides specifically for writing tests:
   - the ~test~ /attribute/
   - a few /macros/
   - the ~should_panic~ /attribute/.

*** DONE The Anatomy of a Test Function - 208
    CLOSED: [2021-01-15 Fri 01:46]
    - At its simplest,
      a /test/ in Rust is a /function/ that's annotated with the ~test~
      /attribute/.

    - attributes :: metadata about pieces of Rust code.
      * Examples:
        + The ~derive~ we see in Chapter 5
        + The ~test~ we will see in this Chapter

    - When you run your _tests_ with the =cargo test= command,
      Rust builds a /test runner binary/ that
      1. *runs* the functions annotated with the ~test~ /attribute/
        and
      2. *reports* on whether each _test function_ passes or fails.

    - TEST
      1. Use =cargo new addr --lib= to
         create a new library project called =adder=.
         In its =src/lib.rs=
         #+BEGIN_SRC rust
           #[cfg(test)]
           mod tests {
               #[test]
               fn it_works() {
                   assert_eq!(2 + 2, 4);
               }
           }
         #+END_SRC
         * For now, ignore the first twolines and focus on the function to see how
           it works. =TODO=

         * The ~#[test]~ /attribute/ indicates this is a _test function_.
           + There are _non-test helper functions_ in the ~tests~ /module/,
             so we need to *indicate* which /functions/ are _tests_ with the
             ~#[test]~ /attribute/.

      2. Use ~cargo test~ to run the test(s).
         * test 1: one test, should be ok
           #+BEGIN_SRC rust
             #[cfg(test)]
             mod tests {
                 #[test]
                 fn exploration() {
                 }
             }
           #+END_SRC
           
           + =cargo test= result
             #+begin_src text
                  Compiling adder v0.1.0 (file:///projects/adder)
                   Finished test [unoptimized + debuginfo] target(s) in 0.57s
                    Running target/debug/deps/adder-92948b65e88960b4

               running 1 test
               test tests::exploration ... ok

               test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

                  Doc-tests adder

               running 0 tests

               test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
             #+end_src

         * test 2: two tests, one should be ok, and the other should fail
           #+BEGIN_SRC rust
             #[cfg(test)]
             mod tests {
                 #[test]
                 fn exploration() {
                 }

                 #[test]
                 fn another() {
                     panic!("Make this test fail");
                 }
             }
           #+END_SRC

           + =cargo test= result
             #+begin_src text
                  Compiling adder v0.1.0 (file:///projects/adder)
                   Finished test [unoptimized + debuginfo] target(s) in 0.72s
                    Running target/debug/deps/adder-92948b65e88960b4

               running 2 tests
               test tests::another ... FAILED
               test tests::exploration ... ok

               failures:

               ---- tests::another stdout ----
               thread 'main' panicked at 'Make this test fail', src/lib.rs:10:9
               note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


               failures:
                   tests::another

               test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

               error: test failed, to rerun pass '--lib'
             #+end_src
             - The second to the last line mentioned statistics of _different kind_
               of tests.
               * =TODO= Talk about =ignored= and =filtered= later.
               * =TODO= =measured= is for benchmark tests.

*** DONE Checking Results with the ~assert!~ Macro - 211
    CLOSED: [2021-01-15 Fri 01:52]
    - ~assert!~ is useful when you want to ensure that some condition in a test
      evaluates to ~true~.
      * If is ~true~, do nothing
      * If is ~false~, it calls the ~panic!~

    - In Chapter 4, Listing 5-15, we have =src/lib.rs=:
      #+begin_src rust
        #[derive(Debug)]
        pub struct Rectangle {
            width: u32,
            height: u32,
        }

        impl Rectangle {
            pub fn can_hold(&self, other: &Rectangle) -> bool {
                self.width > other.width && self.height > other.height
            }
        }
      #+end_src

      We can add tests like:
      #+begin_src rust
        #[cfg(test)]
        mod tests {
            use super::*;

            #[test]
            fn larger_can_hold_smaller() {
                let larger = Rectangle {
                    width: 8,
                    height: 7,
                };
                let smaller = Rectangle {
                    width: 5,
                    height: 1,
                };

                assert!(larger.can_hold(&smaller));
            }
        }
      #+end_src

*** DONE Testing Equality with the ~assert_eq!~ and ~assert_ne!~ Macros - 214
    CLOSED: [2021-01-15 Fri 02:04]
    - ~assert_eq!~ and ~assert_ne!~ also print out the two compared values
      if the assertion fails, which makes it easier to see WHY the test failed.

    - Example:
      #+BEGIN_SRC rust
        pub fn add_two(a: i32) -> i32 {
            a + 2
        }

        #[cfg(test)]
        mod tests {
            use super::*;

            #[test]
            fn it_adds_two() {
                assert_eq!(4, add_two(2));
            }
        }

        // ...
        // running 1 test
        // test tests::it_adds_two ... ok
        //
        // test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
        // ...
      #+END_SRC
      * If we define the ~add_two~ as ~a + 3~, when testing we will see:
        #+begin_src text
          ...
          running 1 test
          test tests::it_adds_two ... FAILED

          failures:

          ---- tests::it_adds_two stdout ----
          thread 'main' panicked at 'assertion failed: `(left == right)`
            left: `4`,
           right: `5`', src/lib.rs:11:9
          note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


          failures:
              tests::it_adds_two

          test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
          ...
        #+end_src
        + ~assert_eq!~ and ~assert_ne!~ take arguments with no order constraints:
          In some languages test framework, there is =expected= and =actual=,
          while Rust doesn't -- it uses the terms =left= and =right=.

    - ~assert_ne!~ is most useful for cases
      when we're not sure what a value will be,
      but we know what the value definitely won't be if our code is functioning
      as we intend.

    - ~assert_eq!~ and ~assert_ne!~ /macros/ can only compare values whoes types
      implement
      * ~PartialEq~, because under the surface these /macros/ uses ~==~ and ~!=~.
      * ~Debug~, because when the _assertions fail_, these /macros/ *print* their
        arguments using /debug formatting/.

*** DONE Adding Custom Failure Messages - 216
    CLOSED: [2021-01-15 Fri 02:10]
    - Additional optional arguments as _failure message_ can be passed to ~assert!~,
      ~assert_eq!~, and ~assert_ne!~.
      * *Any* arguments specified _AFTER_
        the one required argument to ~assert!~
        OR
        the two required arguments to ~assert_eq!~ and ~assert_ne!~
        are passed along to the ~format!~ /macro/,
        so you can pass a /format string/ that contains ~{}~ placeholders and
        values to go in those placeholders.

    - Example:
      #+BEGIN_SRC rust
        pub fn greeting(name: &str) -> String {
            format!("Hello {}!", name)
        }

        #[cfg(test)]
        mod tests {
            use super::*;

            #[test]
            fn greeting_contains_name() {
                let result = greeting("Carol");
                assert!(
                    result.constants("Carol"),
                    "Greeting did not contain name, value was `{}`", result
                );
            }
        }
      #+END_SRC

*** DONE Checking for Panics with ~should_panic~ - 218
    CLOSED: [2021-01-15 Fri 02:18]
    #+begin_src rust
      // Listing 11-8: Testing that a condition will cause a panic!
      struct Guess {
          value: u32,
      }

      impl Guess {
          pub fn new(value: u32) -> Guess {
              if value < 1 || value > 100 {
                  panic!("Guess value must be between 1 and 100, got {}", value);
              }

              Guess { value }
          }
      }

      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          #[should_panic]
          fn greater_than_100() {
              Guess::new(200);
          }
      }
    #+end_src

    - ~#[should_panic]~ goes *after* ~#[test]~ and *before* the function.

    - We can create a bug by removing the ~|| value > 100~ part,
      and the test will fail. We will see the message is _NOT very useful_.
      * The above ~should_panic~ can be imprecise:
        ANY /panic/ can satisfy it, even though it's not what we expect.
        We can add an _optional ~expected~ parameter_ to the ~should_panic~
        /attribute/. A _substring_ of the /panic message/ is enough.
        #+BEGIN_SRC rust
          struct Guess {
              value: u32,
          }

          impl Guess {
              pub fn new(value: u32) -> Guess {
                  if value < 1 {
                      panic!("Guess value must be greater than or equal to 1, got {}.",
                             value);
                  } else value > 100 {
                      panic!("Guess value must be less than or equal to 100, got {}.",
                             value);
                  }

                  Guess {
                      value
                  }
              }
          }

          #[cfg(test)]
          mod tests {
              use super::*;

              #[test]
              #[should_panic(expected = "Guess value must be less than or equal to 100")]
              fn greater_than_100() {
                  Guess::new(200);
              }
          }
        #+END_SRC
        + If we create a bug by swap the /panic messages/ in the ~new~ function,
          we can see the test failure messages when ~expected~ /panic messages/
          can't match.

*** DONE Using ~Result<T, E>~ in Tests - 221
    CLOSED: [2021-01-15 Fri 02:21]
    - We can also write tests taht use ~Result<T, E>~!

    - Example: 
      #+begin_src rust
        #[cfg(test)]
        mod tests {
            #[test]
            fn it_works() -> Result<(), String> {
                if 2 + 2 == 4 {
                    Ok(())
                } else {
                    Err(String::from("two plus two does not equal four"))
                }
            }
        }
      #+end_src

    - You *can't* use the ~#[should_panic]~ /annotation/ on tests that use
      ~Result<T, E>~.
      Instead, you should *return an ~Err~ value directly* when the test _should
      fail_.

** DONE Controlling How Tests Are Run - 221
   CLOSED: [2021-01-15 Fri 02:58]
   - Just as =cargo run= compiles your code and then *runs* the _resulting binary_,
     =cargo test= compiles your code in test mode and *runs* the _resulting test
     binary_.
     
   - Can specify command line options to change the _defaut behavior_ of =cargo test=.
     * The _default behavior_ of the binary produced by =cargo test= is to
       1. run all the tests in parallel
       2. capture output generated during test runs,
          preventing the output from being displayed and
       3. making it easier to read the output related to the test results.

   - =IMPORTANT=
     Some command line options go to =cargo test=, and
     some go to the =resulting test binary=.
     * _To *separate* these two types of arguments,_ you list
       1. the arguments that go to =cargo test=
       2. followed by the separator ~--~ and
       3. then the ones that go to the _test binary_.
       

     * For examle,
       + Running =cargo test --help= displays the options you can use with
         =cargo test=;

       + Running =cargo test -- --help= displays the options you can use after
         the separator ~--~.
     
*** DONE Running Tests in Parallel or Consecutively - 222
    CLOSED: [2021-01-15 Fri 02:38]
    - When you run multiple tests,
      *by default* they run _in parallel using threads_.
      * =IMPORTANT=
        Because of this parallelism, you should take care that
        + your tests do *NOT* depend on each other

        + your tests do *NOT* depend on on any _shared state_, including a
          _shared environment_ such as the current working directory or
          environment variables.

    - ~--test-threads~ flag
      * If you *don't* want to run the tests in parallel,
        ~$ cargo test -- --test-threads=1~ does not use any parallelism.
      
      * If you want more fine-grained control over the _number of threads_ used,
        ~$ cargo test -- --test-threads=2~

*** DONE Showing Function Output - 222
    CLOSED: [2021-01-15 Fri 02:42]
    - *By default*
      * if a test _passes_, all its to standard output prints will be captured by
        the Rust's test library.

      * If a test _fails_, we'll see whatever was printed to standard output with
        the rest of the failure message.

    - *Disable the output capture of tests*: use the ~--show-output~ flag.
      ~$ cargo test -- --show-output~
      * We usually *don't use this option alone*, since the default parallelism,
        the output will be interleaved -- we usually disable /parallelism/ and
        _output capture_ together by using
        ~$ cargo test -- --show-output --test-threads=1~

*** DONE Running a Subset of Tests by Name - 224
    CLOSED: [2021-01-15 Fri 02:47]
    You can choose which test(s) to run by _passing ~cargo test~ the name or
    names of the test(s)_ you want to run as an argument.
    #+BEGIN_SRC rust
      // src/lib.rs

      pub fn add_two(a: i32) -> i32 {
          a + 2
      }

      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          fn add_two_and_two() {
              assert_eq!(4, add_two(2));
          }

          #[test]
          fn add_three_and_two() {
              assert_eq!(5, add_two(3));
          }

          #[test]
          fn one_hundred() {
              assert_eq!(102, add_two(100));
          }
      }
    #+END_SRC

**** DONE Running Single Tests - 225
     CLOSED: [2021-01-15 Fri 02:45]
     ~$ cargo test one_hundred~
     
     * *Caution*:
       _We *can't* specify the names of multiple tests in this way;_

**** DONE Filtering to Run Multiple Tests - 225
     CLOSED: [2021-01-15 Fri 02:46]
     Specify *part of a test name*, multiple tests will run if they share this
     specified word.
     ~$ cargo test add~ will run tests whose names contain =add=.

*** DONE Ignore Some Tests Unless Specifically Requested - 226
    CLOSED: [2021-01-15 Fri 02:50]
    You often want to ignore some time-consuming tests during most runs of
    =cargo test=.

    - Example:
      #+begin_src rust
        #[test]
        fn it_works() {
            assert_eq!(2 + 2, 4);
        }

        #[test]
        #[ignore]
        fn expensive_test() {
            // code that takes an hour to run
        }
      #+end_src
      * Use the ~#[ignore]~ /attribute/
        *after* ~#[test]~ and *before* the /function/.

      * If you want to _run *only* the IGNORED tests,_
        run ~$ cargo test -- --ignored~

      * Use ~--include-ignored~ option to run all tests.
        + Only in NIGHTLY version.

** DONE Test Organization - 227
   CLOSED: [2021-01-15 Fri 03:45]
   - The Rust community thinks about tests in terms of _TWO main categories_:
     * unit tests ::
       _small_ and _more focused_, testing _one module in isolation_ at a time,
       and *can test /private interfaces/.*

     * integration tests ::
       *entirely external* to your library and use your code _in the same way
       any other external code would_, using
       + *ONLY* the /public interface/
       + potentially exercising *MULTIPLE* /modules/ per test.

   - Writing both kinds of tests is important to ensure that the pieces of your
     library are doing what you expect them to, _separately and together._

*** DONE Unit Tests - 227
    CLOSED: [2021-01-15 Fri 03:15]
    - Put /unit tests/ in the =src= directory, in each file with the code that
      they're testing.

    - _CONVENTION_:
      create a /module/ named ~tests~ *in each file* to contain the _test
      functions_, and we annotate the /module/ with ~cfg(test)~.

**** DONE The Tests Module and ~#[cfg(test)]~ - 227
     CLOSED: [2021-01-15 Fri 03:08]
     - The ~#[cfg(test)]~ annotation on the /tests module/ tells Rust to compile
       and run the test code _ONLY_ when we run ~cargo test~, and not when we run
       ~cargo build~. This
       * *saves* /compile time/
         when you only want to BUILD the library

       * *saves* _space_ in the _resulting compiled artifact_
         because the tests are not included. 

     - /integration tests/ go in a different directory, they don't need the
       ~[cfg(test)]~ annotation.

**** DONE Testing Private Functions - 227
     CLOSED: [2021-01-15 Fri 03:15]
     There's debate within the testing community about
     *whether or not private functions should be tested directly,*
     and other languages make it difficult or impossible to test private functions.

     Regardless of which testing ideology you adhere to,
     =IMPORTANT= _Rust's privacy rules do *allow* you to TEST /private functions/._
     
     - Example:
       #+begin_src rust
         pub fn add_two(a: i32) -> i32 {
             internal_adder(a, 2)
         }

         // a function is *private* by default
         fn internal_adder(a: i32, b: i32) -> i32 {
             a + b
         }

         #[cfg(test)]
         mod tests {
             use super::*;

             #[test]
             fn internal() {
                 assert_eq!(4, internal_adder(2, 2))
             }
         }
       #+end_src

*** DONE Integration Tests - 228
    CLOSED: [2021-01-15 Fri 03:45]
    In Rust, integration tests are _entirely external_ to your library -- they
    use your library in the same way any other code would, which means they can
    only call functions that are part of your library's public API (/private
    functions/ tests are already done in the /unit tests/ part).
    
    - Units of code that work correctly on their own could have problems when
      integrated, so *test /coverage/ of the /integrated code/ is important as
      well.*

    - To create /integration tests/, you first need a =tests= directory.

**** DONE The =tests= Directory - 229
     CLOSED: [2021-01-15 Fri 03:45]
     - Make a =tests= directory in the top level of your project, next to =src=.
       * Cargo knows to look for /integration test/ files in this directory.

       * We can make as many test files as we want =FIXME= (remove "to") in this
         directory, and Cargo will compile *each* of the files as an *individual*
         /crate/.
         
     - Example:
       #+begin_src rust
         // Listing 11-13: An integration test of a function in the adder crate

         // tests/integration_test.rs
         use adder;

         #[test]
         fn it_adds_two() {
             assert_eq!(4, adder::add_two(2));
         }
       #+end_src
       * ~use adder~:
         _each file_ in the tests directory is a *separate* /crate/,
         so we need to bring our library into each test /crate's scope/.

       * ~$ cargo test~ output:
         #+begin_src text
              Compiling adder v0.1.0 (file:///projects/adder)
               Finished test [unoptimized + debuginfo] target(s) in 0.73s
                Running target/debug/deps/adder-92948b65e88960b4

           running 1 test
           test tests::internal ... ok

           test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

                Running target/debug/deps/integration_test-82e7799c1bc62298

           running 1 test
           test it_adds_two ... ok

           test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

              Doc-tests adder

           running 0 tests

           test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
         #+end_src
         The /integration tests/ section starts with the line
         =Running target/debug/deps/integration_test-ce99bcc2479f4607=
         =FIXME= this hash is different from the one above.

     - We can still run a *particular* _integration test function_
       by specifying the _test function's name_ as an argument to ~cargo test~.

     - To run _ALL the tests_ in a PARTICULAR _integration test file,_
       use the ~--test~ argument of ~cargo test~ followed by the name of the
       file: ~cargo test --test integration_test~

**** DONE Submodules in integration Tests - 230
     CLOSED: [2021-01-15 Fri 03:45]
     As mentioned earlier, _each file_ in the =tests= directory is compiled as
     its own *separate* /crate/.

     - Treating _each /integration test/ file_ as _its own crate_ is useful to
       create *separate* /scopes/ that are more like the way end users will be
       using your /crate/ (=from Jian= Every /integration test/ file simulate
       one end user use case. Of course differnt users use cases should be in
       DIFFERENT /scope/).
       =TODO= =RECALL=
         However, this means files in the =tests= directory don't share the
       same behavior as files in =src= do, as you learned in Chapter 7 regarding
       how to separate code into /modules/ and /files/.
     
     - Sometimes you want to _extract some common functions into a file_, and
       the other /integration tests/ (in multiple files) use it.
       * If you put it in a file (assume its name is =common.rs=) directly in
         =tests=, Cargo will consider it as a /integration tests/, even if it may
         not contain any ~#[test]~, and add a section for it in th output of
         ~cargo test~ -- _this is usually *NOT* what we want._

       * Rather than =common.rs=, we should put the common code into
         =tests/common/mod.rs=. This is an _alternate naming convention_ that
         Rust also understands.
           Naming the file this way _tells Rust *not* to treat the ~common~
         /module/ as an /integration test file/._ Then we have a expected output
         in ~cargo test~.

     - Example:
       #+begin_src rust
         use adder;

         mod common;

         #[test]
         fn it_adds_two() {
             common::setup();
             assert_eq!(4, adder::add_two(2));
         }
       #+end_src
       * Note:
         the ~mod common;~ /declaration/ is the same as the /module declaration/
         we demonstrated in Listing 7-21.

**** DONE Integration Tests for Binary Crates - 232
     CLOSED: [2021-01-15 Fri 03:45]
     - If our project is a binary crate that _ONLY_ contains a =src/main.rs= and
       does not have a =src/lib.rs=, we are *NOT able* to create /integration tests/
       in the =tests= directory and bring functions defined in the =src/main.rs=
       file into scope with a ~use~ statement.

     - Only /library crates/ expose functions that OTHER /crates/ are able to call
       and use; /binary crates/ are meant to be run on their own.

       * This is one of the reasons Rust projects that provide a binary have a
         STRAIGHTFORWARD =src/main.rs= that calls logic that lives in
         =src/lib.rs=.
           With that structure, /integration tests/ *can test* the /library
         crate/ with ~use~ to make the important functionality available.
         + If the important functionality works, the small amount of code in
           =src/main.rs= will work as well, and that small amount of code does
           not need to be tested.
           - =From Jian= Keep your =src/main.rs= simple!!!!!!!!!!!!!!!

** DONE Summary - 232
   CLOSED: [2021-01-15 Fri 03:46]

* TODO 12. An I/O Project: Building a Command Line Program - 233 - =start=
  - This chapter is both
    * a recap of many skills
    * an exploration of a few more standard library features

  - Make our own version of the classic command line tool ~grep~ (Globally search
    a Regular Expression and Print).

  - In the simplest use case, ~grep~ searches a specified file for a specified
    string using the following steps:
    * Take as arguments a filename and a string.
    * Read the file.
    * Find lines in the file that contain the string argument.
    * Print out those lines.

  - We'll also show how to use environment variables and print to standard error
    instead of standard out; these tech are commonly used in command line tools.

  - ~ripgrep~ is a fully-featured and faster version of ~grep~ implemented by
    Andrew Gallant by using Rust.

  - This project will bring together a number of concepts you've learned so far:
    * Organizing code (using what we learned in modules, _Chapter 7_)
    * Using vectors and strings (collections, _Chapter 8_)
    * Handling errors (_Chapter 9_)
    * Using traits and lifetimes where appropriate (_Chapter 10_)
    * Writing tests (_Chapter 11_)

  - We'll also briefly introduce /closures/, /iterators/, and /trait objects/,
    which Chapter 13 and 17 will cover in detail =TODO=.

  - ~cargo new --bin greprs~

** DONE Accepting Command Line Arguments - 234
   CLOSED: [2017-08-27 Sun 18:48]
   Our first task is to make ~greprs~ able to accept its two command line
   arguments:
   - the file name
   - a string to search for.

   The result is we can use a command of the pattern
   ~cargo run searchstring example-filename.txt~

*** DONE Reading the Argument Values - 234
    CLOSED: [2017-08-27 Sun 18:44]
    Use Rust standard library ~std::env::args~, which returns an /iterator/ of
    the command line arguments that were given to our program.

    - =TODO= /iterator/ will be fully covered in Chapter 13.

    - For now, two things we need to know about the /iterator/:
      1. Iterator produce a series of values
      2. We can call the ~collect~ function on iterator to turn it into a vector
         containing all of the elements the iterator produces.

    - Example (use /iterator/):
      #+BEGIN_SRC rust
        use std::env;

        fn main() {
            let args: Vec<String> = env::args().collect();
            println!("{:?}", args);
        }
      #+END_SRC
      * As we talked about in Chapter 7,
        in cases where the desired function is nested in more than one module,
        it's CONVENTIONAL to _bring the parent module into scope_, rather than
        the function itself.

      * ~std::env::args~ will panic if any argument containts invalid Unicode.

      * To take arguments with invalid Unicode, use ~std::env::args_os~, which
        returns ~OsString~.

          ~OsString~ values differ per-platform and are more complex to work
        with than ~String~ values.

      * Run:
        #+BEGIN_SRC bash
          cargo run
          # ["target/debug/greprs"]

          cargo run needle haystack
          # ...snip...
          # ["target/debug/greprs", "needle", "haystack"]
        #+END_SRC

*** DONE Saving the Argument Values in Variables - 236
    CLOSED: [2017-08-27 Sun 18:48]
    #+BEGIN_SRC rust
      use std::env;

      fn main() {
          let args: Vec<String> = env::args().collect();

          let query = &args[1];
          let filename = &args[2];

          println!("Searching for {}", query);
          println!("In file {}", filename);
      }
    #+END_SRC

    - =TODO= Later we'll add some error handling to deal with situations like no
      argument.
** DONE Reading a File - 237
   CLOSED: [2017-08-27 Sun 20:05]
   #+BEGIN_SRC rust
     use std::env;
     use std::fs::File;
     use std::io::prelude::*;

     fn main() {
         let args: Vec<String> = env::args().collect();

         let query = &args[1];
         let filename = &args[2];

         println!("Searching for {}", query);
         println!("In file {}", filename);

         let mut f = File::open(filename).expect("file not found");

         let mut contents = String::new();
         f.read_to_string(&mut contents).expect("something went wrong reading the file");

         println!("With text:\n{}", contents);
     }
   #+END_SRC

   - ~std::io::prelude::*~ contains various traits taht are useful when doing
     I/O, including file I/O.

   - Don't be confused with /prelude/
     * Here we use ~std::io::prelude::*~
     * There is also a general ~prelude~ which is always brought in
       automatically, unless you disable it (=From Jian= HOW TO???).

   - We've got a few flaws though:
     * the ~main~ function has multiple responsibilities
     * we're not handling errors as well as we could be.

   - While our program is still small, these flaws aren't a big problem, but as
     our program grows, it will be harder to fix them cleanly.

     _Refactor earlier is good, while optimize earlier is bad_
     It's good practice to begin _refactoring early_ on when developing a
     program, as it's much easier to refactor smaller amounts of code, so we'll
     do that now.

** DONE Refactoring to Improve Modularity and Error Handling - 238
   CLOSED: [2017-08-28 Mon 02:19]
   - _OLD TITLE_: Improving Error Handling and Modularity

   - There are _FOUR_ problems that we'd like to fix to improve our program, they
     have to do with:
     * the way the program is structured
     * how it's handling potential errors

   - Problem 1 :: ~main~ contains more than one tasks:
     1. parse arguments
     2. open up files.

   - Solution to P1 :: It's better to separate out functionality so that each
                      function is responsible for one task.

   - Problem 2 :: If later we have more configuration variables (like ~filename~,
                  ~contents~), it will become hard to track them.

   - Solution to P2 :: It's better to group the configuration variables into one
                       structure to make their purpose clear.

   - Problem 3 :: If there is an error when opening up the given file, the
                       error message is always =file not found=, which should NOT
                       always the case.

   - Solution to P3 :: Find a way to give right advices through the error
                       message.

   - Problem 4 :: It would be better if all our error handling code was in
                  one place so that future maintainers only have on place
                  to consult in the code if the error handling logic needs to
                  change.

   - Solution to P4 :: Put them together.

*** DONE Separation of Concerns for Binary Projects - 239
    CLOSED: [2017-08-27 Sun 21:43]
    - The organizational guidelines has the following steps:
      1. Split your program into both a ~main.rs~ and a ~lib.rs~ and move your
         program's logic into ~lib.rs~.

      2. While your command line parsing logic is small, it can remain in
         ~main.rs~.

      3. When the command line parsing logic starts getting complicated, extract
         it from ~main.rs~ into ~lib.rs~ as well.

      4. The responsibilities that remain in the ~main~ function after this
         process should be:
         * Calling the command line parsing logic with the argument values
         * Setting up any other configuration
         * Calling a ~run~ function in ~lib.rs~
         * If ~run~ returns an error, handling that error

    - This pattern is all about separating concerns:
      * ~main.rs~ handles running the program
      * ~lib.rs~ handles all of the logic of the task at hand.

      Because we can't test the ~main~ function directly, this structure lets us
      test all of our program's logic by moving it into functions in ~lib.rs~.
      The only code that remains in ~main.rs~ will be small enough to verify its
      correctness by reading it. Let's re-work our program by following this
      process.

**** DONE Extracting the Argument Parser - 240
     CLOSED: [2017-08-27 Sun 21:48]
     #+BEGIN_SRC rust
       // src/main.rs
       fn main() {
           let args: Vec<String> = env::args().collect();
           let (query, filename) = parse_config(&args);
           // ...snip...
       }

       fn parse_config(args: &[String]) -> (&str, &str) {
           let query = &args[1];
           let filename = &args[2];
           (query, filename)
       }
     #+END_SRC

**** DONE Grouping Configuration Values - 240
     CLOSED: [2017-08-27 Sun 23:29]
     - A sign that we don't have the right abstraction yet:
         We're returning a tuple, but when we immediately break that tuple up into
       individual parts again.

     - Another indicator:
       The two values we return are related and are both part of one configuration
       value. We're not currently conveying this meaning in the structure of the
       data other than grouping the two values into a tuple -- the can be a
       stronger structure -- ~struct~.

       This will make it easier for future maintainers of this code to understand
       how the different values relate to each other and what their purpose is.

     - /primitive obsession/ :: using primitive values when a complex type would
          be more appropriate.

     - Refactored Code:
       #+BEGIN_SRC rust
         fn main() {
             let args: Vec<String> = env::args().collect();
             let config = parse_config(&args);

             println!("Searching for {}", config.query);
             println!("In file {}", config.filename);

             let mut f = File::open(config.filename).expect("file not found");
             // ...snip...
         }

         struct Config {
             query: String,
             filename: String,
         }

         fn parse_config(args: &[String]) -> Config {
             let query = args[1].clone();
             let filename = args[2].clone();
             Config { query, filename }
         }
       #+END_SRC

       + It's simple to give the ownership of a vector to a parameter of a
         function, but =Jian= don't know a simple way to use the elements of this
         vector. An error =cannot move out of indexed content= will happen.

         This is why we pass ~&args~ to ~parse_config~.

       + The ~clone~ is the most straightforward way, though in this circumstance
         giveing up a little performance.

       + Another way to write this code (=From Jian=):
         #+BEGIN_SRC rust
           fn main() {
               let args: Vec<String> = env::args().collect();
               let config = parse_config(&args);

               println!("Searching for {}", config.query);
               println!("In file {}", config.filename);

               let mut f = File::open(config.filename).expect("file not found");
               // ...snip...
           }

           // Hope the compiler can simplify this in the future
           struct Config<'a> {
               query: &'a str,
               filename: &'a str,
           }

           fn parse_config(args: &[String]) -> Config {
               let query = &args[1];
               let filename = &args[2];
               Config { query, filename }
           }
         #+END_SRC

     - *The Tradeoffs of Using* ~clone~
       =TODO= In Chapter 13 on iterators,
       you'll learn how to use more efficient methods in this kind of situation,
       but for now, it's okay to copy a few strings to keep making progress since
       we'll only make these copies once, and our filename and query string are
       both very small.

**** DONE Creating a Constructor for ~Config~ - 242
     CLOSED: [2017-08-28 Mon 01:15]
     The function ~parse_config~ is used to create the instances of ~Config~.
     Why not make it an associated function of of ~Config~, and change it name to
     ~new~. This is an idiomatic: it essentially a constructor.
     #+BEGIN_SRC rust
       fn main() {
           let args: Vec<String> = env::args().collect();
           let config = Config::new(&args);

           // ...snip...
       }

       // ...snip...

       impl Config {
           fn new(args: &[String]) -> Config {
               let query = args[1].clone();
               let filename = args[2].clone();

               Config { query, filename }
           }
       }
     #+END_SRC

*** DONE Fixing the Error Handling - 243
    CLOSED: [2017-08-28 Mon 01:43]
    - =TODO=
**** DONE Improving the Error Message - 243
     CLOSED: [2017-08-28 Mon 01:35]
     #+BEGIN_SRC rust
       // ...snip...
       fn new(args: &[String]) -> Config {
           if args.len() < 3 {
               panic!("not enought arguments");
           }
           // ...snip...
       }
     #+END_SRC
     The output of NO enough argument is better now, but there is still noise.
     ~panic!~ is GOOD for programming, but it's not good for users.

     Try to use ~Result~ type values.

**** DONE Returning a ~Result~ from ~new~ Instead of Calling ~panic!~ - 244
     CLOSED: [2017-08-28 Mon 01:38]
     #+BEGIN_SRC rust
       impl Config {
           fn new(args: &[String]) -> Rssult<Config, &'static str> {
               if args.len() < 3 {
                   return Err("not enough arguments");
               }

               let query = args[1].clone();
               let filename = args[2].clone();

               Ok(Config { query, filename })
           }
       }
     #+END_SRC
**** DONE Calling ~Config::new~ and Handling Errors - 245
     CLOSED: [2017-08-28 Mon 01:42]
     #+BEGIN_SRC rust
       use std::process;

       fn main() {
           let args: Vec<String> = env::args().collect();

           let config = Config::new(&args).unwrap_or_else(|err| {
               println!("Problem parsing arguemnts: {}", err);
               process::exit(1);
           });

           // ...snip...
       }
     #+END_SRC

     - The ~unwrap_or_else~ method of a ~Result~ type value.

     - /closure/

*** DONE Extracting Logic from ~main~ - 246
    CLOSED: [2017-08-28 Mon 02:11]
    #+BEGIN_SRC rust
      fn main() {
          // ...snip...

          println!("Searching for {}", config.query);
          println!("In file {}", config.filename);

          run(config);
      }

      fn run(config: Config) {
          let mut f = File::open(config.filename).expect("file not found");

          let mut contents = String::new();
          f.read_to_string(&mut contents).expect("something went wrong reading the file");

          println!("With text:\n{}", contents);
      }

      // ...snip...
    #+END_SRC

**** DONE Returning Errors from the ~run~ Function - 247
     CLOSED: [2017-08-28 Mon 02:07]
     #+BEGIN_SRC rust
       use std::error::Error;

       // ...snip...

       fn run(config: Config) -> Result<(), Box<Error>> {
           let mut f = File::open(config.filename)?;

           let mut contents = String::new();
           f.read_to_string(&mut contents)?;

           println!("With text:\n{}", contents);

           Ok(())
       }
     #+END_SRC

     - The body of old ~run~ was the body of ~main~, which returns ~()~, now we
       make it return ~Result<(), Box<Error>>~

     - ~Box<Error>~ is a /trait object/. Here it means the returned type should
       have implemented the ~Error~ trait (but no specific type is given).
       =TODO= Chapter 17

     -

**** DONE Handling Errors Returned from ~run~ in ~main~ - 248
     CLOSED: [2017-08-28 Mon 02:11]
     #+BEGIN_SRC rust
       fn main() {
           // ...snip...

           println!("Searching for {}", config.query);
           println!("In file {}", config.filename);

           if let Err(e) = run(config) {
               println!("Application error: {}", e);

               process::exit(1f;)
           }
       }
     #+END_SRC
*** DONE Splitting Code into a Library Crate - 248
    CLOSED: [2017-08-28 Mon 02:14]
    - The following pieces of code will be moved to =src/lib.rs=:
      * The ~run~ function definition
      * The relevant ~use~ statements
      * The difinition of ~Config~
      * The ~Config::new~ function definition

    - The =src/lib.rs=:
      #+BEGIN_SRC rust
        use std::error::Error;
        use std::fs::File;
        use std::io::prelude::*;

        pub struct Config {
            pub query: String,
            pub filename: String,
        }

        impl Config {
            pub fn new(args: &[String]) -> Result<Config, &'static str> {
                if args.len() < 3 {
                    return Err("not enough arguments");
                }

                let query = args[1].clone();
                let filename = args[2].clone();

                Ok(Config { query, filename })
            }
        }

        pub fn run(config: Config) -> Result<(), Box<Error>>{
            let mut f = File::open(config.filename)?;

            let mut contents = String::new();
            f.read_to_string(&mut contents)?;

            println!("With text:\n{}", contents);

            Ok(())
        }
      #+END_SRC

**** DONE Calling the Library Crate from the Binary Crate
     CLOSED: [2017-08-28 Mon 02:19]
     #+BEGIN_SRC rust
       extern crate greprs;

       use std::env;
       use std::process;

       use greprs::Config;

       fn main() {
           let args: Vec<String> = env::args().collect();

           let config = Config::new(&args).unwrap_or_else(|err| {
               println!("Problem parsing arguments: {}", err);
               process::exit(1);
           });

           println!("Searching for {}", config.query);
           println!("In file {}", config.filename);

           if let Err(e) = greps::run(config) {
               println!("Application error: {}", e);

               process::exit(1);
           }
       }
     #+END_SRC

** DONE Developing the Library's Functionality with Test-Driven Development - 250 =TODO=
   CLOSED: [2017-08-30 Wed 05:23]
   - =TODO=
*** TODO Writing a Failing Test - 250
*** TODO Writing Code to Pass the Test - 253
**** TODO Iterating Through Lines with the ~lines~ Method - 253
**** TODO Searching Each Line for the Query - 253
**** TODO Storing Matching Lines - 254
**** TODO Using the ~search~ Function in the ~run~ Function - 254

** DONE Working with Environment Variables - 255 =TODO=
   CLOSED: [2017-08-30 Wed 05:39]
   - x
*** TODO Writing a Failing Test for the Case-Insensitive ~search~ Function - 255
*** TODO Implementing the ~search_case_insensitive~ Function - 257
** TODO Writing Error Message to Standard Error Instead of Standard Output - 260
*** Checking Where Errors Are Written - 260
*** Printing Errors to Standard Error - 261
    - ~println!~ is ONLY capable of printing to standard out (~stdout~).

    - Exmaple:
      Listing 12-23: Writing error messages to ~stderr~ instead of ~stdout~ using
      ~writeln!~
      #+BEGIN_SRC rust
        extern crate greprs;

        use std::env;
        use std::process;
        use std::io::prelude::*;

        use greprs::Config;

        fn main() {
            let args: Vec<String> = env::args().collect();
            let mut stderr = std::io::stderr();

            let config = Config::new(&args).unwrap_or_else(|err| {
                writeln!(
                    &mut stderr,
                    "Problem parsing arguments: {}",
                    err
                ).expect("Could not write to stderr");
                process::exit(1);
            });

            if let Err(e) = greprs::run(config) {
                writeln!(
                    &mut stderr,
                    "Application error: {}",
                    e
                ).expect("Could not write to stderr");

                process::exit(1);
            }
        }
      #+END_SRC

      * we need ~stderr~ to be /mutable/ so we can write to it!

** DONE Summary - 262
   CLOSED: [2017-08-30 Wed 05:32]

* DONE 13. Functional Language Features: Iterators and Closures - 263 - =TODO=
  CLOSED: [2021-01-16 Sat 23:58]
  - In this chapter,
    1. we *won't debate* the issue of what functional programming is or isn't
    2. but will instead discuss some features of Rust that are similar to features
       in many languages often referred to as /functional/.

  - More specifically, we'll cover:
    * Closures :: a function-like construct you can store in a variable
    * Iterators :: a way of processing a series of elements
    * How to use these two features to improve the I/O project in Chapter 12
    * The _performance_ of these two features (Spoiler alert: they're faster than you might think!)

  - Mastering /closures/ and /iterators/ is an important part of writing idiomatic,
    fast Rust code, so we'll devote this entire chapter to them.
  
** DONE Closures: Anonymous Functions That Can Capture Their Environment - 264
   CLOSED: [2021-01-16 Sat 03:34]
   - /Rust's closures/ are _allowed to *capture* values_ from the /scope/ in which
     they are defined.

   - Rust /functions/ are _NOT allowed to capture values_ from the /scope/ in which
     they are defined,
     =from Jian= which is _different_ from most of they other languages.

*** DONE Creating an Abstraction of Behavior with Closure - 264
    CLOSED: [2021-01-16 Sat 01:57]
    =from Jian= This section is trivial for people have coding experience.
    Only some basic example to illustrate 
    1. write code with duplicate calls to a pure /function/.
    2. save duplicate calls to one variable, and use it multiple times.
    3. introduce a /closure/ which replaces the pure /function/,
       but again call it multiple times. =WHY=
    
**** Refactoring Using Functions - 266
**** Refactoring with Closures to Store Code - 267

*** DONE Closure Type Inference and Annotation - 269
    CLOSED: [2021-01-16 Sat 01:57]
    - /Type annotations/ are required on /functions/
      because they're part of an /explicit interface/ *exposed to* your users.
      Defining this interface rigidly is important for ensuring that everyone
      agrees on what types of values a function uses and returns.
        But /closures/ *AREN'T used in an exposed interface* like this: they're
      stored in /variables/ and used without naming them and exposing them to
      users of our library.
      
    - Closure with type annotations (mostly not required and recommended):
      #+begin_src rust
        let expensive_closure = |num: u32| -> u32 {
            println!("calculating slowly...");
            thread::sleep(Duration::from_secs(2));
            num
        }
      #+end_src

    - The curly braces are _optional_ if the closure body only has one line.

*** DONE Storing Closures Using Generic Parameters and the ~Fn~ Traits - 270
    CLOSED: [2021-01-16 Sat 02:32]
    Create a /struct/ and use memoization to *cache* this expensive calculation.
    #+begin_src rust
      struct Cacher<T>
      where
          T: Fn(u32) -> u32,
      {
          calculation: T,
          value: Option<u32>,
      }
    #+end_src
    
    - All /closures/ implement *at least one* of the /traits/:
      * ~Fn~
      * ~FnMut~
      * ~FnOnce~

    - Note:
      /Functions/ can implement *all three* of the ~Fn~ /traits/ too.
      * If what we want to do doesn't require capturing a value from the environment,
        we can use a /function/ rather than _a /closure/ where we need something that
        implements an ~Fn~ /trait/._

    - =NEXT=
      We'll discuss the difference between these /traits/ in the “Capturing the
      Environment with Closures” section;

    - In this example, we can use the ~Fn~ /trait/.

    - Implement methods for ~Cacher<T>~:
      #+begin_src rust
        impl<T> Cacher<T>
        where
            T: Fn(u32) -> u32,
        {
            fn new(calculation: T) -> Cacher<T> {
                Cacher {
                    calculation,
                    value: None,
                }
            }

            fn value(&mut self, arg: u32) -> u32 {
                match self.value {
                    Some(v) => v,
                    None => {
                        let v = (self.calculation)(arg);
                        self.value = Some(v);
                        v
                    }
                }
            }
        }
      #+end_src
      
      Then we can write:
      #+begin_src rust
        fn generate_workout(intensity: u32, random_number: u32) {
            let mut expensive_result = Cacher::new(|num| {
                println!("calculating slowly...");
                thread::sleep(Duration::from_secs(2));
                num
            });

            if intensity < 25 {
                println!("Today, do {} pushups!", expensive_result.value(intensity));
                println!("Next, do {} situps!", expensive_result.value(intensity));
            } else {
                if random_number == 3 {
                    println!("Take a break today! Remember to stay hydrated!");
                } else {
                    println!("Today, run for {} minutes!", expensive_result.value(intensity));
                }
            }
        }
      #+end_src

*** DONE Limitations of the ~Cacher~ Implementation - 273
    CLOSED: [2021-01-16 Sat 03:12]
    There are *two problems* with the _current implementation_ of ~Cacher~ that
    would make reusing it in different contexts difficult.

    - Problem 1:
      _a ~Cacher~ instance_ *assumes* it will ALWAYS get the _same value_ for
      the parameter ~arg~ to the ~value~ /method/.
      #+begin_src rust
        // This test of `Cacher` will fail!
        #[test]
        fn call_with_different_values() {
            let mut c = Cacher::new(|a| a);

            let v1 = c.value(1);
            let v2 = c.value(2);

            assert_eq!(v2, 2);
        }
      #+end_src
      * Try modifying ~Cacher~ to hold a /hash map/, from ~arg~'s of different
        calls to the result of calling the /closure/, rather than a SINGLE value.
        
      * The ~value~ /function/ will
        + look up the ~arg~ in the /hash map/ and return the value if it's present.

        + If it's not present,
          the ~Cacher~ will call the /closure/ and save the resulting value in
          the /hash map/ associated with its ~arg~ value.
          
      * =from Jian= New implementation:
        #+begin_src rust
          use std::collections::HashMap;

          struct Cacher<T>
          where
              T: Fn(u32) -> u32,
          {
              calculation: T,
              values: HashMap<u32, u32>,
          }

          impl<T> Cacher<T>
          where
              T: Fn(u32) -> u32,
          {
              fn new(calculation: T) -> Cacher<T> {
                  Cacher {
                      calculation,
                      values: HashMap::new(),
                  }
              }

              fn value(&mut self, arg: u32) -> u32 {
                  match self.values.get(&arg) {
                      Some(v) => *v,
                      None => {
                          let v = (self.calculation)(arg);
                          self.values.insert(arg, v);
                          v
                      }
                  }
              }
          }
        #+end_src

    - Problem 2:
      * The current ~Cacher~ implementation is that it _only accepts_ /closures/
        that
        + TAKE one parameter of type ~u32~
        + RETURN a ~u32~.
      
      * We might want to cache the results of /closures/ that, for example,
        + TAKE a /string slice/
        + RETURN ~usize~ values,
          
        To fix this issue, =TODO=
        try INTRODUCING *more* /generic parameters/ to _INCREASE the flexibility_
        of the ~Cacher~ functionality.

*** DONE Capturing the Environment with Closures - 274
    CLOSED: [2021-01-16 Sat 03:34]
    - *Overhead* of captureing values from the /definition site environment/:
      * /closures/ use memory to *store* the _values for use in the /closure/
        body._

      * /functions/ are *NEVER allowed to capture* their environment, defining
        and using functions will *NEVER incur this _overhead_.*

    - _THREE ways (taking ownership, borrowing immutably, and borrowing
      mutably) of capturing values_ are encoded in the _THREE ~Fn~ traits_ as
      follows:
      * ~FnOnce~
        *takes* /ownership/ of the variables it captures from the environment and
        *moves* those variables *into* the /closure/ when the /closure/ is defined.

        + Therefore,
          a ~FnOnce~ /closure/ *cannot be called more than once* _in the SAME
          context_.
          
      * ~FnMut~ *can change* the environment since it *mutably borrows* values.

      * ~Fn~ *borrows* values from the environment _immutably_.

    - When you create a /closure/,
      Rust *infers* which /trait/ to use *based on* how the /closure/ uses the
      _values from the environment_. 
      * *ALL* /closures/ implement ~FnOnce~ because they can ALL _be called at
        least once_.

      * /Closures/ that *don't move* the _captured variables_ also implement
        ~FnMut~,

      * /Closures/ that *don't need mutable access* to the _captured variables_
        also implement ~Fn~.

    - If we want to FORCE the /closure/ to _take ownership_ of the values it uses
      in the environment, we can use the ~move~ keyword before the parameter
      list.
      _This is mostly useful when passing a closure to a new thread in order to
      move the data to be owned by the new thread._

      * =TODO=
        We'll have more examples of move closures in Chapter 16 when we talk
        about concurrency.

      * For now here's the code with the ~move~ /keyword/ added to the /closure/
        definition and using /vectors/ instead of /integers/, since /integers/
        can be /copied/ rather than /moved/:
        #+BEGIN_SRC rust
          // Listing 13-12: Example of a closure that refers to a variable in its enclosing scope

          fn main() {
              let x = vec![1, 2, 3];

              let equal_to_x = move |z| z == x;

              println!("can't use x here: {:?}", x);

              let y = vec![1, 2, 3];

              assert!(equal_to_x(y));
          }
        #+END_SRC
        This *won't compile* because of the ~println!~ line.

    - Most of the time when specifying _one of the ~Fn~ /trait/ bounds,_

    - The Rust compiler can guide you how to pick a ~Fn~ /trait/:
      1. you can start with ~Fn~

      2. the compiler will tell you if you need ~FnMut~ or ~FnOnce~
         based on _what happens in the /closure/ body._

** DONE Processing a Series of Items with Iterators - 276
   CLOSED: [2021-01-16 Sat 23:42]
   The /iterator pattern/ allows you to perform some task on a sequence of items
   in turn.

   - An /iterator/ is responsible for the logic of
     ITERATING over each item and
     DETERMINING when the sequence has finished.
     * When you use /iterators/, you don't have to reimplement that logic yourself.

   - In Rust, *iterators are LAZY,* meaning they have no effect until you call
     /methods/ that consume the /iterator/ to use it up.
     * For example,
       #+begin_src rust
         let v1 = vec![1, 2, 3];
         let v1_iter = v1.iter();
       #+end_src

   - Example:
     #+begin_src rust
       let v1 = vec![1, 2, 3];
       let v1_iter = v1.iter();

       for val in v1_iter {
           println!("Got: {}", val);
       }
     #+end_src

*** DONE The ~Iterator~ Trait and the ~next~ Method - 277
    CLOSED: [2021-01-16 Sat 19:57]
    #+BEGIN_SRC rust
      trait Iterator {
          type Item;

          fn next(&mut self) => Option<Self::Item>;

          // methods with default implementations elided
      }
    #+END_SRC

    - ~type Item~ and ~Self::Item~.
      Define an /associated type/ with this /trait/. =TODO= Chapter 19
      
    - The ~next~ /method/
      1. returns one item of the /iterator/ at a time wrapped in ~Some~ and,
      2. WHEN _iteration is over_,
         returns ~None~.

    - ~next~
      #+BEGIN_SRC rust
        // src/lib.rs

        #[test]
        fn iterator_demostration() {
            let v1 = vec![1, 2, 3];

            let mut v1_iter = v1.iter();

            assert_eq!(v1_iter.next(), Some(&1));
            assert_eq!(v1_iter.next(), Some(&2));
            assert_eq!(v1_iter.next(), Some(&3));
            assert_eq!(v1_iter.next(), None);
        }
      #+END_SRC
      * ~v1_iter~ should be *mutable*:
        calling the ~next~ /method/ on an /iterator/ _changes internal state_
        that the /iterator/ uses to keep track of where it is in the sequence.
        + _NO need to make ~v1_iter~ MUTABLE_
          WHEN we used a ~for~ loop because the loop
          1. took /ownership/ of ~v1_iter~ and 
          2. made it *mutable* _behind the scenes._

      * The values we get from the calls to ~next~ are /immutable references/ to
        the values in the /vector/.
        + The ~iter~ /method/ produces an /iterator/ over /immutable references/.

        + If we want to
          *create* an /iterator/ that *takes ownership* of ~v1~ and
          *returns* _OWNED values_,
          we can call ~into_iter~ instead of ~iter~.

        + Similarly, if we want to iterate over /mutable references/,
          we can call ~iter_mut~ instead of ~iter~.
        
*** DONE Methods that Consume the Iterator - 278
    CLOSED: [2021-01-16 Sat 20:03]
    - The ~Iterator~ /trait/ has a number of different /methods/ with _default
      implementations_ provided by the standard library.

    - The /methods/ that call the ~next~ /method/ are called /consuming adaptors/,
      because calling them uses up the /iterator/.

    - Example:
      The ~sum~ /method/
      *takes* /ownership/ of the /iterator/ and
      *iterates through* the items by repeatedly calling ~next~, thus CONSUMING
      the /iterator/.
      #+BEGIN_SRC rust
        // src/lib.rs

        #[test]
        fn iterator_sum() {
            let v1 = vec![1, 2, 3];

            let v1_iter = v1.iter();

            let total: i32 = v1_iter.sum();

            assert_eq!(total, 6);
        }
      #+END_SRC
      The ~sum~ /method/ takes the /ownership/ of ~v1_iter~,
      and ~v1_iter~ CANNOT be used after the ~let total~ line.

*** DONE Methods that Produce Other Iterators - 279
    CLOSED: [2021-01-16 Sat 20:31]
    - /iterator adaptors/ :: methods defined on the ~Iterator~ trait that allow
                             you to change /iterators/ into different kinds of /iterators/.

    - /iterator adaptor/ ~map~
      #+BEGIN_SRC rust
        let v1: Vec<i32> = vec![1, 2, 3];
        v1.iter().map(|x| x + 1);
      #+END_SRC
      Compile this code, and a =warning= (=note: iterators are lazy and do nothing
      unless consumed=) shows up: /iterator adaptors/ are /lazy/, and we need to
      consume the /iterator/ here.
      * We can use the ~collect~ /method/:
        #+begin_src rust
          let v1: Vec<i32> = vec![1, 2, 3];
          let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
          assert_eq!(v2, vec![2, 3, 4]);
        #+end_src

*** DONE Using Closures that Capture Their Environment - 280
    CLOSED: [2021-01-16 Sat 23:19]
    We can demonstrate a common use of /closures/ that _capture their environment_
    by using the ~filter~ /iterator adaptor/.

    #+BEGIN_SRC rust
      // Listing 13-19: Using the `filter` method with a closure that captures `shoe_size`
      #[derive(PartialEq, Debug)]
      struct Shoe {
          size: i32,
          style: String,
      }

      fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: i32) -> Vec<Shoe> {
          shoes.into_iter().filter(|s| s.size == shoe_size).collect()
      }

      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          fn filters_by_size() {
              let shoes = vec![
                  Shoe { size: 10, style: String::from("sneaker") },
                  Shoe { size: 13, style: String::from("sandal") },
                  Shoe { size: 10, style: String::from("boot") },
              ];

              let in_my_size = shoes_in_my_size(shoes, 10);

              assert_eq!(
                  in_my_size,
                  vec![
                      Shoe { size: 10, style: String::from("sneaker") },
                      Shoe { size: 10, style: String::from("boot") },
                  ]
              );
          }
      }

      fn main() {}
    #+END_SRC
    - The /closure/ *captures* the ~shoe_size~ parameter _from the environment_.

*** DONE Creating Our Own Iterators with the ~Iterator~ Trait - 281
    CLOSED: [2021-01-16 Sat 23:42]
    #+BEGIN_SRC rust
      // Listing 13-20: Defining the Counter struct and a new function that creates
      //                instances of Counter with an initial value of 0 for count

      // src/lib.rs

      struct Counter {
          count: u32,
      }

      impl Counter {
          fn new() -> Counter {
              Counter { count: 0 }
          }
      }

      impl Iterator for Counter {
          type Item = u32;

          fn next(&mut self) -> Option<Self::Item> {
              if self.count < 5 {
                  self.count += 1;
                  Some(self.count)
              } else {
                  None
              }
          }
      }
    #+END_SRC
    - =TODO= Don't worry about /associated types/ yet, we'll cover them in Chapter 19.

    - If the value of ~count~ is less than 5,
      * ~next~ will
        + INCREMENT ~count~ and
        + RETURN the current value wrapped in ~Some~.
    - Once count is 5,
      our iterator will _stop incrementing_ ~count~ and always return ~None~.

**** DONE Using Our ~Counter~ Iterator's ~next~ Method - 282
     CLOSED: [2021-01-16 Sat 23:42]
     #+BEGIN_SRC rust
       #[test]
       fn calling_next_directly() {
           let mut counter = Counter::new();

           assert_eq!(counter.next(), Some(1));
           assert_eq!(counter.next(), Some(2));
           assert_eq!(counter.next(), Some(3));
           assert_eq!(counter.next(), Some(4));
           assert_eq!(counter.next(), Some(5));
           assert_eq!(counter.next(), None);
       }
     #+END_SRC

**** DONE Using Other ~Iterator~ Trait Methods - 282
     CLOSED: [2021-01-16 Sat 23:42]
     #+BEGIN_SRC rust
       #[test]
       fn using_other_iterator_trait_methods() {
           let sum: u32 = Counter::new()
               .zip(Counter::new().skip(1))
               .map(|(a, b)| a * b)
               .filter(|x| x % 3 == 0)
               .sum();

           assert_eq!(18, sum);
       }
     #+END_SRC
     ~zip~ produces only four pairs -- ~(5, None)~ is never produced -- ~zip~
     returns ~None~ when either of its input iterators return ~None~.

** Improving Our I/O Project - 283
   Use iterators to make places in the code clearer and more concise.
   
*** DONE Removing a ~clone~ Using an Iterator - 284
    CLOSED: [2017-08-30 Wed 19:41]
**** DONE Using the Returned Iterator Directly - 284
     CLOSED: [2017-08-30 Wed 12:36]
     - =src/main.rs=
       #+BEGIN_SRC rust
         fn main() {
             // delete
             // let args: Vec<String> = env::args().collect();
             let mut stderr = std::io::stderr();

             // delete
             // let config = Config::new(&args).unwrap_or_else(|err| {
             let config = Config::new(env::args()).unwrap_or_else(|err| {
                 writeln!(
                     &mut stderr,
                     "Problem parsing arguments: {}",
                     err
                 ).expect("Could not write to stderr");;
                 process::exit(1);
             });
             // ...snip...
         }
       #+END_SRC

     - =src/lib.rs=
       #+BEGIN_SRC rust
         impl Config {
             // Use `std::env::Args` instead of `&[String]`
             fn new(args: std::env::Args) -> Result<Config, &'static str> {
                 // ...snip...
             }
         }
       #+END_SRC

**** DONE Using ~Iterator~ Trait Methods Instead of Indexing - 285
     CLOSED: [2017-08-30 Wed 19:40]
     - =src/lib.rs=
       #+BEGIN_SRC rust
         impl Config {
             fn new(mut args: std::env::Args) -> Result<Config, &'static str> {
                 args.next();

                 let query = match args.next() {
                     Some(arg) => arg,
                     None => return Err("Didn't get a query string"),
                 };

                 let filename = match args.next() {
                     Some(arg) => arg,
                     None => return Err("Didn't get a file name"),
                 };

                 Ok(Config {
                     query, filename
                 })
             }
         }
       #+END_SRC

*** DONE Making Code Clearer with Iterator Adaptors - 286
    CLOSED: [2017-08-30 Wed 19:41]
    Use /iterator adapter/ to eliminate the mutable variable.
    #+BEGIN_SRC rust
      fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
          contents.lines()
              .filter(|line| line.contains(query))
              .collect()
      }
    #+END_SRC

** DONE Comparing Performance: Loops vs. Iterators - 287
   CLOSED: [2021-01-16 Sat 23:57]
   - Benchmark by loading the entire contents of "The Adventures of Sherlock
     Holmes" by Sir Arthur Conan Doyle into a String and looking for the word
     =the= in the contents.
     * Conclusion: the /iterator/ version is a little faster.

   - /Iterators/ are one of Rust's /zero-cost abstractions/.

   - /zero-cost abstractions/ ::
     #+begin_quote
       In general, C++ implementations obey the zero-overhead principle:
       What you don't use, you don't pay for.
       An further: What you do use, you couldn't hand code any better.
                                   -- by Bjarne Stroustrup in "Foundations of C++"
     #+end_quote

   - Example (from an audio decoder):
     The decoding algorithm uses the linear prediction mathematical operation to
     estimate future values based on a linear function of the previous samples.
     #+BEGIN_SRC rust
       let buffer: &mut [i32];
       let coefficients: [i64; 12];
       let qlp_shift: i16;

       for i in 12..buffer.len() {
           let prediction = coefficients.iter()
                                        .zip(&buffer[i - 12..i])
                                        .map(|(&c, &s)| c * s as i64)
                                        .sum::<i64>() >> qlp_shift;

           let delta = buffer[i];
           buffer[i] = prediction as i32 + delta;
       }
     #+END_SRC
     * Q :: What assembly code would this Rust code compile to?
     * A :: It compiles down to the same assembly you'd write by hand.
       + There's *no loop* at all corresponding to the iteration over the values
         in ~coefficients~:
         Rust knows that there are 12 iterations, so it “unrolls” the loop.
         /Unrolling/ is an optimization that removes the overhead of the loop
         controlling code and instead generates repetitive code for each
         iteration of the loop.

     * All of the ~coefficients~ get stored in /registers/,
       which means accessing the values is *very fast*.

     * There are no /bounds checks/ on the array access at runtime.

     * CONCLUSION:
       All these optimizations that Rust is able to apply make the resulting
       code extremely efficient.

   - Summary:
     *Now that you know this, you can use /iterators/ and /closures/ without fear!*
     They make code seem like it's higher level
     BUT *don't* impose a /runtime performance penalty/ for doing so.

** Summary - 289

* TODO 14. More About Cargo and Crates.io - 291 - =TODO= =publish=
  In this chapter, we'll discuss some of its other, more advanced features to
  show you how to do the following:
  * *Customize* your build through /release profiles/
  * *Publish* libraries *on* crates.io
  * *Organize* LARGE projects with /workspaces/
  * *Install* binaries *from* crates.io
  * *Extend* Cargo using _custom commands_

** DONE Customizing Builds with Release Profiles - 292
   CLOSED: [2021-01-17 Sun 00:27]
   In Rust, /release profiles/ are *predefined* and *customizable* /profiles/
   with different configurations that allow a programmer to have more control
   over various options for compiling code. Each profile is configured
   independently of the others.

   - Cargo has two MAIN /profiles/:
     * ~cargo build~ uses the ~dev~ /profile/
       + The ~dev~ /profile/ is defined with *good defaults for _DEVELOPMENT_.*

     * ~cargo build --release~ uses the ~release~ /profile/
       + the ~release~ /profile/ has *good defaults for _RELEASE_ builds.*

   - These /profile/ names might be familiar from the OUTPUT of your _builds_:
     * ~cargo build~: Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     * ~cargo build --release~: Finished release [optimized] target(s) in 0.0s

   - Cargo has *default settings* for each of the /profiles/ that apply
     when there aren't any ~[profile.*]~ sections in the project's =Cargo.toml=
     file.

   - By adding ~[profile.*]~ sections for any /profile/ you want to customize,
     you can *override* any subset of the _default settings_.
     * For example,
       here are the default values for the ~opt-level~ setting for the ~dev~ and
       ~release~ /profiles/:
       #+begin_src toml
         [profile.dev]
         opt-level = 0

         [profile.release]
         opt-level = 3
       #+end_src
       + ~opt-level~ controls the _number of optimizations_ Rust will apply to
         your code, with a *range of 0 to 3.*

** TODO Publishing a Crate to Crates.io - 293
*** TODO Making Useful Documentation Comments - 293
**** Commonly Used Sections - 294
**** Documentation Comments as Tests - 295
**** Commenting Contained Items - 295

*** TODO Exporting a Convenient Public API with ~pub use~ - 296
*** TODO Setting Up a Crates.io Account - 300
*** TODO Adding Metadata to a New Crate - 300
*** TODO Publishing to Crates.io - 301
*** TODO Publishing a New Version of an Existing Crate - 302
*** TODO Removing Versions from Crate.io with ~cargo yank~ - 302

** DONE Cargo Workspaces - 303
   CLOSED: [2021-01-17 Sun 01:27]
   As your project develops, you might find that the /library crate/ continues to
   get bigger and you want to *split up* your /package/ further into _MULTIPLE
   /library crates/._
     In this situation, Cargo offers a feature called /workspaces/ that can help
   manage _MULTIPLE related packages_ that are developed in tandem.
   
*** DONE Creating a Workspace - 303
    CLOSED: [2021-01-17 Sun 01:27]
    Create a project named as =add=, which includes ONE /binary crate/ and TWO
    /library crates/. The /binary crate/, which will provide the _main
    functionality_, will depend on the TWO /libraries/: one provides a function
    ~add_one~, and the other one provides ~add_two~.
    
    - There are multiple ways to structure a workspace; =TODO= =???=
      we're going to show one common way.
      1. ~mkdir add~ and then ~cd add~

      2. Add =Cargo.toml=
         #+begin_src toml
           [workspace]

           members = [
               "adder",
           ]
         #+end_src

      3. ~cargo new adder~
         Then the project directory structure:
         #+begin_src text
           ├── Cargo.lock
           ├── Cargo.toml
           ├── adder
           │   ├── Cargo.toml
           │   └── src
           │       └── main.rs
           └── target
         #+end_src
         One /workspace/ has one =target= directory at the top level for the
         /compiled artifacts/ to be placed into;
         * EXAMPLE:
           =adder= doesn't have its own =target=, even if run ~cargo build~ just
           INSIDE =adder=.

         * RATIONALE:
           + The /crates/ in a /workspace/ are meant to depend on each other.
              =from Jian= If not, we shouldn't use /workspace/.

           + By sharing _ONE_ =target= directory, the /crates/ can *AVOID
             unnecessary rebuilding*:
             If each /crate/ had its own =target= directory, EACH /crate/ would
             have to *recompile* EACH of the other /crates/ in the /workspace/ to
             have the /artifacts/ in its own =target= directory.
    
*** DONE Creating the Second Package in the Workspace - 304
    CLOSED: [2021-01-17 Sun 01:27]
    Next, create another /member package/ in the /workspace/ and call it =add-one=.
    
    1. Change the top level =Cargo.toml=:
       #+begin_src toml
         [workspace]

         members = [
             "adder",
             "add-one",
         ]
       #+end_src

    2. ~cargo new add-one --lib~
       Then the project directory structure is like:
       #+begin_src text
         ├── Cargo.lock
         ├── Cargo.toml
         ├── add-one
         │   ├── Cargo.toml
         │   └── src
         │       └── lib.rs
         ├── adder
         │   ├── Cargo.toml
         │   └── src
         │       └── main.rs
         └── target
       #+end_src

    3. Add =add-one/src/lib.rs=
       #+begin_src rust
         pub fn add_one(x: i32) -> i32 {
             x + 1
         }
       #+end_src
       
    4. Edit the =adder/Cargo.toml=:
       #+begin_src toml
         [dependencies]

         add-one = { path = "../add-one" }
       #+end_src
       Cargo does *NOT assume* that /crates/ in a /workspace/ will depend on each
       other, so we need to be explicit about the dependency relationships
       between the /crates/.
       * =from Jian=
         I think this is reasonable, if assue this,
         *circular dependency will be introduced AUTOMATICALLY*.

    5. Use the ~add_one~ function from the =add-one= /crate/.
       #+begin_src rust
         // adder/src/main.rs

         use add_one;

         fn main() {
             let num = 10;
             println!(
                 "Hello, world! {} plus one is {}!",
                 num,
                 add_one::add_one(num)
             );
         }
       #+end_src

     6. We can ~cargo build~, and then ~cargo run -p adder~.
        * The ~-p~ flag specifies which /package/ in the /workspace/ we want to run.
       
**** DONE Depending on an External Package in a Workspace - 305
     CLOSED: [2021-01-17 Sun 01:27]
     Add /external packages/ to corresponding =[dependencies]= section of
     corresponding =Cargo.toml=.
     
     - Example:
       ~add_one~ depends on ~rand~.
       Then add ~rand~ to the =[dependencies]= section of =add-one/Cargo.toml=.
       
     - /Crates/ in the SAME /workspace/ doesn't share dependencies.
       If =adder/src/main.rs= wants to use ~rand~, then edit =adder/Cargo.toml=.

     - Building the =adder= /package/ will *add* ~rand~ to the list of /dependencies/
       for =adder= in =Cargo.lock=, but *no additional copies of =rand= will be
       downloaded*.
       
       * Cargo has *ensured* that EVERY /crate/ in EVERY /package/ in the /workspace/
         using the ~rand~ /package/ *will be using the _SAME version_.*
         + This
           - *saves space*
           - ensures that the /crates/ in the /workspace/ will be *compatible*
             with each other.

**** DONE Adding a Test to a Workspace - 306
     CLOSED: [2021-01-17 Sun 01:27]
     1. Add a /unit test/ to =add-one/src/lib.rs=.

     2. Run ~cargo test~ in the top-level =add= directory, and it will run all tests
        from EACH /crate/. Of course, currently only =add-one= has a /unit test/.
        #+begin_src text
             Compiling add-one v0.1.0 (file:///projects/add/add-one)
             Compiling adder v0.1.0 (file:///projects/add/adder)
              Finished test [unoptimized + debuginfo] target(s) in 0.27s
               Running target/debug/deps/add_one-f0253159197f7841

          running 1 test
          test tests::it_works ... ok

          test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

               Running target/debug/deps/adder-49979ff40686fa8e

          running 0 tests

          test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

             Doc-tests add-one

          running 0 tests

          test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
        #+end_src
        
        - ~cargo test -p add-one~ can be used to run the ONLY tests for the
          =add-one= /crate/.
          #+begin_src text
                 Finished test [unoptimized + debuginfo] target(s) in 0.00s
                 Running target/debug/deps/add_one-b3235fea9a156f74

            running 1 test
            test tests::it_works ... ok

            test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

               Doc-tests add-one

            running 0 tests

            test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
          #+end_src
          
     3. If you *publish* the /crates/ in the /workspace/ to crates.io,
        *EACH /crate/ in the /workspace/ will need to be _published SEPARATELY_.* 
        - The ~cargo publish~ does *NOT* have an ~--all~ flag or a ~-p~ flag.

     4. _SUMMARY:_
        As your project grows, consider using a /workspace/:
        * it's easier to understand smaller, individual components than one big
          blob of code.
        * Furthermore, keeping the /crates/ in a /workspace/ can *make coordination
          between them easier if they are often changed at the same time.*

** DONE Installing Binaries from Crates.io with ~cargo install~ - 308
   CLOSED: [2021-01-17 Sun 01:44]
   - The ~cargo install~ command allows you to install and use /binary crates/
     LOCALLY.
     * This isn’t intended to replace system packages; it’s meant to be a convenient
       way for Rust developers to install tools that others have shared on crates.io.

     * NOTE:
       you can *ONLY install* packages that have /binary targets/.

       + binary target :: the runnable program that is created if the /crate/ has
                           a =src/main.rs= file or another file specified as a
                           /binary/, as opposed to a /library target/.
                           
       + library target :: isn't runnable on its own
                            but is suitable for including within other programs.

       + USUALLY, =IMPORTANT=
         /crates/ have information in the README file *ABOUT*
         whether a /crate/ is a /library/, has a /binary target/, or _both_.

   - _All binaries_ installed with ~cargo install~ are stored in _the installation
     root's bin folder_.
       If you installed Rust using =rustup.rs= and *don't* have any _custom
     configurations_, this directory will be =$HOME/.cargo/bin=.
     * Ensure that directory is in your ~$PATH~, then use the installed binary can
       be simpler.

   - For example,
     in Chapter 12 we mentioned that there's a Rust implementation of the ~grep~
     tool called ~ripgrep~ for searching files. If we want to install ~ripgrep~,
     we can run the following:
     ~cargo install ripgrep~
     #+begin_src text
           Updating crates.io index
         Downloaded ripgrep v11.0.2
         Downloaded 1 crate (243.3 KB) in 0.88s
         Installing ripgrep v11.0.2
       --snip--
          Compiling ripgrep v11.0.2
           Finished release [optimized] target(s) in 3m 10s
         Installing ~/.cargo/bin/rg
          Installed package `ripgrep v11.0.2` (executable `rg`)
     #+end_src
     * The _second-to-last line of the output_ shows
       the _LOCATION_ (=~/.cargo/bin/=)
       AND
       the _NAME_ of the installed binary, which in the case of ~ripgrep~ is ~rg~.
     
** DONE Extending Cargo with Custom Commands - 309
   CLOSED: [2021-01-17 Sun 01:30]
   Cargo is designed so you can _extend it with new subcommands_
   *WITHOUT having to modify* Cargo.

   - If a binary in your ~$PATH~ is named ~cargo-something~,
     you can run it *as if it was a Cargo subcommand* by running ~cargo something~.

   - /Custom commands/ like this are also *listed* when you run ~cargo --list~.

   - Being able to use ~cargo install~ to install extensions and then run them just
     like the built-in Cargo tools is a super convenient benefit of Cargo's
     design!
     
** DONE Summary - 309
   CLOSED: [2021-01-17 Sun 01:30]

* TODO 15. Smart Pointers - 311
  - /pointer/ :: a generic programming term for something that refers to a
                 location that stores some other data.

  - /smart pointers/ :: data structures that
    * act like a pointer
    * have additional metadata and capabilities, such as /reference counting/.

  - The /smart pointers/ pattern originated in C++.

  - In Rust, an additional difference between /plain references/ and
    /smart pointers/ is that
    * /references/ are a kind of pointer that ONLY borrow data;
    * by contrast, in many cases, /smart pointers/ own the data that they point to.

  - We've actually already encountered a few smart pointers in this book,
    even though we didn't call them that by name at the time.

    For example, ~String~ and ~Vec<T>~ are both /smart pointers/.

  - /smart pointers/
    * _own_ some memory and allow you to manipulate it,
    * have
      + metadata (like their /capacity/)
      + extra capabilities or guarantees (~String~ data will always be valid UTF-8).

  - The characteristics that distinguish a /smart pointer/ from an
    /ordinary struct/ are:
    /smart pointers/ implement the ~Deref~ and ~Drop~ traits, and in this chapter
    we'll be discussing both of those traits and why they're important to smart pointers.
    =TODO= _in this chapter_

  - There won't be complete coverage of all the features of the /smart pointer/
    pattern.

    The ones we cover here are the most common ones from the standard library:
    * ~Box<T>~, for allocating values on the /heap/.

    * ~Rc<T>~, a reference counted type so data can have multiple owners
      (=From Jian= as I know, reference count can solve /circular reference/
      =double check here=).

    * ~RefCell<T>~, which isn't a /smart pointer/ itself, but manages access to
      the /smart pointers/ ~Ref~ and ~RefMut~ to enforce the borrowing rules
      _at runtime_ instead of compile time.

    Along the way, we'll also cover:
    * The /interior mutability/ pattern where an immutable type exposes an API
      for mutating an interior value, and the borrowing rules apply _at runtime_
      instead of compile time.

    * Reference cycles, how they can leak memory, and how to prevent them.

** DONE Using ~Box<T>~ to Point to Data on the Heap - 312
   CLOSED: [2017-08-31 Thu 10:30]
*** Using a ~Box<T>~ to Store Data on the Heap - 313
*** Enabling Recursive Types with Boxes - 314
**** More Information About the Cons List - 314
**** Computing the Size of a Non-Recursive type - 315
**** Using ~Box<T>~ to Get a Recursive Type with a Known Size - 316
     - /box/ is the most straightforward smart pointer.
       Its type is written as ~Box<T>~.

     - Boxes allow you to put a single value on the /heap/.

     - Example (non-compilable):
       #+BEGIN_SRC rust
         enum List {
             Cons(i32, List),
             Nil,
         }

         fn main() {
             let list = Cons(1, Cons(2, Cons(3, Nil)));
         }
       #+END_SRC

     - *More Information About the Cons List*

     - Example (compilable):
       #+BEGIN_SRC rust
         enum List {
             Cons(i32, Box<List>),
             Nil,
         }

         use List::{Cons, Nil};

         fn main() {
             let list = Cons(1,
                             Box::new(Cons(2,
                                           Box::new(Cons(3,
                                                         Box::new(Nil))))));
         }
       #+END_SRC

     - The main area where /boxes/ are useful:
       breaking up an infinite data structure so that the compiler can know what
       size it is.

       =WHY need to know???=

** DONE Treating Smart Pointers Like Regular References with the ~Deref~ Trait - 317
   CLOSED: [2017-08-31 Thu 19:58]
*** Following the Pointer to the Value with the Dereference Operator - 318
*** Using ~Box<T>~ Like a Reference - 318
*** Defining Our Own Smart Pointer - 319
*** Treating a Type Like a Reference by Implementing the ~Deref~ Trait - 320
*** Implicit ~Deref~ Coercions with Functions and Methods - 321
*** How ~Deref~ Coercion Interacts with Mutability - 322
   - The ~Deref~ allows us to override ~*~ (the dereference operator).

   - Override ~*~ for smart pointers makes accessing the data behind the smart
     pointer convenient.
     * With /references/ that are _NOT_ /smart pointers/, there's _only one_
       value that the reference is pointing to, so the dereference operation is
       straightforward.

     * /Smart pointers/ can also store metadata about the pointer of the data.

       We usually do ONLY want the data, NOT the metadata. If we don't override
       the ~*~ (through implementing the ~Deref~ trait), we need to manually
       strip out the metadata.

   - =Review= /dereference operator/ was mentioned in Chapter 8.
     #+BEGIN_SRC rust
       let mut x = 5;
       {
           let y = &mut x;
           ,*y += 1
       }

       assert_eq!(6, x);
     #+END_SRC

   - Example:
     #+BEGIN_SRC rust
       use std::ops::Deref;

       struct Mp3 {
           audio: Vec<u8>,
           artist: Option<String>,
           title: Option<String>,
       }

       impl Deref for Mp3 {
           type Target = Vec<u8>;

           fn deref(&self) -> &Vec<u8> {
               &self.audio
           }
       }

       fn main() {
           let my_favorite_song = Mp3 {
               // we would read the actual audio data from an mp3 file
               audio: vec![1, 2, 3],
               artist: Some(String::from("Nirvana")),
               title: Some(String::from("Smells Like Teen Spirit")),
           };

           assert_eq!(vec![1, 2, 3], *my_favorite_song);
       }
     #+END_SRC

   - =TODO= =TODO=
     The ~type Target = T;~ syntax is defining an /associated type/, which is
     covered in more detail in _Chapter 19_. Don't worry about that part of the
     example too much; it is a slightly different way of declaring a generic
     parameter.

   - In order to get a ~&~ reference that ~*~ can dereference, the compiler
     expands ~*my_favorite_song~ to:
     ~*(my_favorite_song.deref())~

     * Rust tends to favor _explicitness_ over _implicitness_.

       One exception: /deref coercions/ of arguments to functions and methods.

     * A /deref coercion/ will automatically convert a reference to any pointer
       into a reference to that pointer's contents.

     * A /deref coercion/ happens when the reference type of the argument passed
       into the function _differs_ from the reference type of the parameter
       defined in that function's signature.

     * /Deref coercion/ was added to Rust to make calling functions and methods
       _NOT_ need as many explicit references and dereferences with ~&~ and ~*~.

     * Example:
       #+BEGIN_SRC rust
         fn compress_mp3(audio: &[u8]) -> Vec<u8> {
             // the actual implementation would go here
         }

         // If there is NOT *deref coercions*, we need
         compress_mp3(my_favorite_song.audio.as_slice());

         // Luckily that we have *deref coercions*
         compress_mp3(&my_favorite_song);
       #+END_SRC

     * Similar to how we use the ~Deref~ trait to override ~*~ on ~&T~'s, there is
       also a ~DerefMut~ trait for overriding ~*~ on ~&mut T~.

     * Rust does /deref coercion/ when it finds types and trait implementations in
       _three_ cases:
       + From ~&T~ to ~&U~ when ~T: Deref<Target=U>~.
       + From ~&mut T~ to ~&mut U~ when ~T: DerefMut<Target=U>~.
       + From ~&mut T~ to ~&U~ when ~T: Deref<Target=U>~.

** DONE Running Code on Cleanup with the ~Drop~ Trait - 323
   CLOSED: [2017-08-31 Thu 21:34]
*** Dropping a Value Early with ~std::mem::drop~ - 325
    - =TODO=

    - The ~Drop~ trait requires us to implement one method named ~drop~ that takes
      a /mutable reference/ to ~self~.

    - Example:
      #+BEGIN_SRC rust
        // Filename: src/main.rs

        struct CustomSmartPointer {
            data: String,
        }

        impl Drop for CustomSmartPointer {
            fn drop(&mut self) {
                println!("Dropping CustomSmartPointer!");
            }
        }

        fn main() {
            let c = CustomSmartPointer { data: String::from("some data") };
            println!("CustomSmartPointer created.");
            println!("Wait for it...");
        }

        // CustomSmartPointer created.
        // Wait for it...
        // Dropping CustomSmartPointer!
      #+END_SRC

    - Manually drop (use ~std::mem::drop~):
      #+BEGIN_SRC rust
        fn main() {
            let c = CustomSmartPointer { data: String::from("some data") };
            println!("CustomSmartPointer created.");
            drop(c);
            println!("Wait for it...");
        }

        // CustomSmartPointer created.
        // Dropping CustomSmartPointer!
        // Wait for it...
      #+END_SRC
      * We are NOT allowed to call the ~drop~ method that we defined (like
        ~c.drop~) directly. If we did it, the error message will be
        =explicit destructor calls not allowed=.

      * We are also NOT allowed to call ~Drop::drop~ directly because Rust inserts
        its call to ~Drop::drop~ automatically when the value goes out of scope,
        if we are allowed to do this manually, there will be doulbe (or multiple)
        free problem.

      * The definition of ~std::mem::drop~:
        #+BEGIN_SRC rust
          pub mod std {
              pub mod mem {
                  pub fn drop<T>(x: T) { }
              }
          }
        #+END_SRC
        NO function body. It only takes the ownership of ~x~.

    - We've gone over ~Box<T>~ and some of the characteristics of smart pointers.
      =TODO= let's talk about a few other smart pointers defined in the standard
      library that add different kinds of useful functionality.

** DONE ~Rc<T>~, the Reference Counted Smart Pointer - 326
   CLOSED: [2017-09-01 Fri 14:39]
   - Sometimes, you may actually need multiple owners.
     For this, use ~Rc<T>~, whose name is an abbr for /reference counting/.

   - ~Rc<T>~ is for use when we want to allocate some data on the /heap/ for
     multiple parts of our program to read, and we _CANNOT_ determine at compile
     time which part of our program using this data will finish using it last.

     (If we knew which part would finish last, we could make that part the owner
      of the data and the normal ownership rules enforced at compile time would
      kick in
      =FROM JIAN= I don't think this sentence is completely right.
      I think
      If we only know the last owner, and we don't know the order of operations,
      which may not be fixed everytime, ~Rc<T>~ is still useful.).

   - =IMPORTANT=
     ~Rc<T>~ is only for use in single-threaded scenarios. If you try to use
     ~Rc<T>~ with multiple threads, you'll get a compile-time error.
     =TODO=
     the next chapter on concurrency will cover how to do reference counting in
     multithreaded programs.

*** DONE Using ~Rc<T>~ to Share Data - 327
    CLOSED: [2017-09-01 Fri 14:38]
    - With ~Box<T>~ you cannot share data:
      #+BEGIN_SRC rust
        // src/main.rs
        enum List {
            Cons(i32, Box<List>),
            Nil,
        }

        use List::{Cons, Nil};

        fn main() {
            let a = Cons(5,
                         Box::new(Cons(10,
                                       Box::new(Nil))));

            let b = Cons(3, Box::new(a));
            let b = Cons(4, Box::new(a));
        }

        // error[E0382]: use of moved value: `a`
        //   --> src/main.rs:13:30
        //    |
        // 12 |     let b = Cons(3, Box::new(a));
        //    |                              - value moved here
        // 13 |     let c = Cons(4, Box::new(a));
        //    |                              ^ value used here after move
        //    |
        //    = note: move occurs because `a` has type `List`, which does not
        //    implement the `Copy` trait
      #+END_SRC

    - We could change the definition of ~Cons~ to hold references instead, but
      then we'd have to specify /lifetime/ parameters and we'd have to construct
      elements of a list such that every element lives at least as long as the
      list itself. Otherwise, the borrow checker won't even let us compile the
      code. =TODO=

    - Use ~Rc<T>~
      #+BEGIN_SRC rust
        // src/main.rs
        enum List {
            Cons(i32, Rc<List>),
            Nil,
        }

        use List::{Cons, Nil};
        use std::rc::Rc; // why here? why not before the `List` definition.

        fn main() {
            let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
            let b = Cons(3, a.clone());
            let b = Cons(4, a.clone());
        }
      #+END_SRC

*** DONE Cloning an ~Rc<T>~ Increases the Reference Count - 329
    CLOSED: [2017-09-01 Fri 14:38]
    - The ~clone~ method of the ~Rc<T>~ dosen't make a full copy, and it just
      increase the /reference count/.

    - Use ~Rc::strong_count~ to returns the /reference count/.
      For example,
      #+BEGIN_SRC rust
        fn main() {
            let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
            println!("rc = {}", Rc::strong_count(&a));
            let b = Cons(3, a.clone());
            println!("rc after creating b = {}", Rc::strong_count(&a));
            {
                let c = Cons(4, a.clone());
                println!("rc after creating c = {}", Rc::strong_count(&a));
            }
            println!("rc after c goes out of scope = {}", Rc::strong_count(&a));
        }

        // rc = 1
        // rc after creating b = 2
        // rc after creating c = 3
        // rc after c goes out of scope = 2
      #+END_SRC
      The ~Rc<T>~ implements the ~Drop~ trait, and that's why the /reference
      count/ of a ~Rc<T>~ value decreases when the variables include this ~Rc<T>~
      go out of their scopes.

    - ~Rc<T>~ only allows you to share data for multiple parts of your program to
      read through _immutable references_ to the ~T~ value the ~Rc<T>~ contains.

      This follows the requirement mentioned in Chapter 4:
      two mutable borrows to the same palce can cause data races and
      inconsistencies.

    - However, mutating data is very useful in some scenarios.
      =TODO= /interior mutability pattern/ and the ~RefCell<T>~ type that we can
      use in conjunction with an ~Rc<T>~ to work with this restriction on
      immutability.

** DONE ~RefCell<T>~ and the Interior Mutability Pattern - 330
   CLOSED: [2017-09-01 Fri 16:31]
   - interior mutability ::

*** Enforcing Borrowing Rules at Runtime with ~RefCell<T>~ - 330
*** Interior Mutability: A Mutable Borrow to an Immutable Value - 331
**** A Use Case for Interior Mutability: Mock Objects - 332
**** Keeping Track of Borrows at Runtime with ~RefCell<T>~ - 336
    - Similarly to ~Rc<T>~, ~RefCell<T>~ is only for use in _single-threaded_
      scenarios.

      We'll talk about how to get the functionality of ~RefCell<T>~ in a multi-
      threaded program in the next chapter on concurrency =TODO=.

      For now, all you need to know is that if you try to use ~RefCell<T>~ in a
      multithreaded context, you'll get a compile time error.

    - With references, we use the ~&~ and ~&mut~ syntax to create references and
      mutable references, respectively.

      _But_ with ~RefCell<T>~, we use the ~borrow~ and ~borrow_mut~ methods, which
      are part of the _safe API_ that ~RefCell<T>~ has.
      * ~borrow~ returns the smart pointer type ~Ref~
      * ~borrow_mut~ returns the smart pointer type ~RefMut~.

     - Example:
       =NOTE=: ~data~ is immutable, though we change its inner value through
       ~RefCell<T>~.

       #+BEGIN_SRC rust
         // src/main.rs

         use std::cell::RefCell;

         fn a_fn_that_immutably_borrows(a: &i32) {
             println!("a is {}", a);
         }

         fn a_fn_that_mutably_borrows(b: &mut i32) {
             *b += 1;
         }

         fn demo(r: &RefCell<i32>) {
             a_fn_that_immutably_borrows(&r.borrow());
             a_fn_that_mutably_borrows(&mut r.borrow_mut());
             a_fn_that_immutably_borrows(&r.borrow());
         }

         fn main() {
             let data = RefCell::new(5);
             demo(&data);
         }

         // a is 5
         // a is 6
       #+END_SRC

*** Having Multiple Owners of Mutable Data by Combining ~Rc<T>~ and ~RefCell<T>~ - 337

** Reference Cycles Can Leak Memory - 339
*** Creating a Reference Cycle - 339
*** Preventing Reference Cycles: Turning an ~Rc<T>~ into a ~Weak<T>~ - 341
**** Creating a Tree Data Structure: a Node with Child Nodes - 342
**** Adding a Reference from a Child to Its Parent - 343
**** Visualizing Changes to ~strong_count~ and ~weak_count~ - 344

** Summary - 346

* TODO 16. Fearless Concurrency - 347
** TODO Using Threads to Run Code Simultaneously - 348
*** TODO Creating a New Thread with ~spawn~ - 350
*** TODO Waiting for All Threads to Finish Using ~join~ Handles - 351
*** TODO Using ~move~ Closures with Threads - 353

** TODO Using Message Passing to Transfer Data Between Threads - 355
*** TODO Channels and Ownership Transference - 358
*** TODO Sending Multiple Values and Seeing the Receiver Waiting - 359
*** TODO Create Multiple Producers by Cloning the Transmitter - 360

** TODO Shared-State Concurrency - 361
*** TODO Using Mutexes to Allow Access to Data from One Thread at a Time - 362
**** TODO The API of ~Mutex<T>~ - 362
**** TODO Sharing a ~Mutex<T>~ Between Multiple Threads - 363
**** TODO Multiple Ownership with Multiple Threads - 366
**** TODO Atomic Reference Counting with ~Arc<T>~ - 367

*** TODO Similarities Between ~RefCell<T>~ / ~Rc<T>~ and ~Mutex<T>~ / ~Arc<T>~ - 368

** TODO Extensible Concurrency with the ~Sync~ and ~Send~ Traits - 368
*** TODO Allowwing Transference of Ownership Between Threads with ~Send~ - 369
*** TODO Allowwing Access from Multiple Thread with ~Sync~ - 369
*** TODO Implementing ~Send~ and ~Sync~ Manually is ~Unsafe~ - 369

** TODO Summary - 370

* TODO 17. Object-Oriented Programming Features of Rust - 371
  - Object-Oriented Programming is a way of modeling programs that originated
    with *Simula* in the 1960s and became popular with *C++* in the 1990s.
    =From Jian= The milestones should be mentioned: *Smalltalk* and *Java*.

  - There are many _competing definitions_ for what OOP is:
    * under some definitions, Rust is object-oriented;
    * under other definitions, Rust is not.

    =From Jian= Let's see which parts is the good parts in OOP in Rust's point of
    view.

  - In this chapter, we'll explore
    * some characteristics that are commonly considered to be object-oriented.
    * how those characteristics translate to idiomatic Rust.

** DONE Characteristics of Object-Oriented Languages - 371
   CLOSED: [2017-08-30 Wed 21:26]
   There isn't consensus in the programming community about the features a
   language needs to have in order to be called object-oriented.

*** DONE Objects Contain Data and Behavior - 372
    CLOSED: [2017-08-30 Wed 20:53]
    - "The Gang of Four book" defines OOP in this way:
       #+BEGIN_QUOTE
       Object-oriented programs are made up of /objects/.

       An object _packages_ both data and the procedures that operate on that
       data.

       The procedures are typically called /methods/ or /operations/.
       #+END_QUOTE

    - In Rust, /structs/ provide the same functionality as of /objects/, though
      we don't call them /objects/.

*** DONE Encapsulation that Hides Implementation Details - 372
    CLOSED: [2017-08-30 Wed 21:09]
    - /encapsulation/ :: the implementation details of an object aren't
         accessible to code using that object.

    - The public API is important. If the code is well encapsulated, and
      the API is fixed, it should let user fill the internal change when
      only considering the results (of course, things like speed can change).

    - Example:
      #+BEGIN_SRC rust
        pub struct AveragedCollection {
            list: Vec<i32>,
            average: f64,
        }

        impl AveragedCollection {
            pub fn add(&mut self, value: i32) {
                self.list.push(value);
                self.update_average();
            }

            pub fn remove(&mut self) -> Option<i32> {
                let result = self.list.pop();
                match result {
                    Some(value) => {
                        self.update_average();
                        Some(value)
                    },
                    None => None,
                }
            }

            pub fn average(&self) -> f64 {
                self.average
            }

            fn update_average(&mut self) {
                let total: i32 = self.list.iter().sum();
                self.average = total as f64 / self.list.len() as f64;
            }
        }
      #+END_SRC

      + The fields of ~AveragedCollection~ are private by default.
        The are not parts of the public API the object offers.

      + The public API are the parts with ~pub~ keywords.

      + Since the inner data structure is not a part of the public API, we can
        later change the type of the field ~list~ to the type of HashSet.

        As long as the signature of the ~add~, ~remove~, and ~average~ stay the
        same, code using ~AveragedCollection~ wouldn't need to change.

      + If we expose the ~list~ as public API (with ~pub~), not only the data
        structure change can change the API, but also the public API of the new
        data structure of the ~list~ is mixed into the public API.

        This can completely destory the /encapsulation/:
        * different type has different opertions.
        * detials that doesn't follow any common contract become parts of the
          public API.

        The result is all the code using ~AveragedCollection~ may need to be
        changed.

*** DONE Inheritance as a Type System and as Code Sharing - 374 =RE-READ=
    CLOSED: [2017-08-30 Wed 21:26]
    - Rust doesn't support /inheritance/.
      However, Rust use /traits/ (=From Jian= and /enums/, which I think should
      be mentioned in this section, though it is NOT) to do

    - While many people use "polymorphism" to describe inheritance, it's actually
      a specific kind of polymorphism, called "sub-type polymorphism."

      There are other forms as well;

      a generic parameter with a trait bound in Rust is also polymorphism, more
      specifically "parametric polymorphism."

      The exact details between the different kinds of polymorphism aren't
      crucial here (=TODO= =From Jian= BUT I want to know), so don't worry too
      much about the details:
      just know that
      _Rust has multiple polymorphism-related features, unlike many OOP languages_.
      =TODO=

** TODO Using Trait Objects That Allow for Values of Differnt Types - 375
   =RE-READ=
   /enums/ is a way we can use to hold some variants, and use them as one
   single data type.

   This is useful, but not enough -- it is closed, and we can't add variants
   to an /enum/ after its definition.

   /traits/ is a way to get rid of the _closed_ feature of /enums/.

   Example: In a GUI library, a lot of /structs/ need a ~draw~ method. We don't
   know how many /structs/ we have -- acutally, the number can increase.
   /enums/ CANNOT help, but /taits/ can.


*** DONE Defining a Trait for the Common Behavior - 375
    CLOSED: [2017-08-30 Wed 22:22]
    - In Rust, though, we can define a trait that we'll name ~Draw~ and that will
      have one method named ~draw~. Then we can define a vector that takes a
      /trait object/, which is _a trait behind some sort of pointer_, such as a
      ~&~ reference or a ~Box<T>~ smart pointer.

    - =TODO= We'll talk about the reason trait objects have to be behind a
      pointer in Chapter 19.

    - Example:
      #+BEGIN_SRC rust
        // src/lib.rs

        pub trait Draw {
            fn draw(&self);
        }

        pub struct Screen {
            pub components: Vec<Box<Draw>>,
        }

        impl Screen {
            pub fn run(&self) {
                for component in self.components.iter() {
                    component.draw();
                }
            }
        }
      #+END_SRC

      In the below code, the ~components~ can only be a _homogeneous_
      collections, which is not required in the above code:
      #+BEGIN_SRC rust
        pub struct Screen<T: Draw> {
            pub components: Vec<T>,
        }

        impl Screen<T>
            where T: Draw {
            pub fn run(&self) {
                for component in self.components.iter() {
                    component.draw();
                }
            }
        }
      #+END_SRC
      
*** DONE Implementations the Trait - 377
    CLOSED: [2017-08-30 Wed 22:30]
    #+BEGIN_SRC rust
      // src/lib.rs

      pub struct Button {
          pub width: u32,
          pub height: u32,
          pub label: String,
      }

      impl Draw for Button {
          fn draw(&self) {
              // Code to actually draw a button
          }
      }
    #+END_SRC

    #+BEGIN_SRC rust
      // src/main.rs

      extern crate rust_gui;
      use rust_gui::{Draw, Screen, Button};

      struct SelectBox {
          width: u32,
          height: u32,
          options: Vec<String>,
      }

      impl Draw for SelectBox {
          fn draw(&self) {
              // Code to acutally draw a select box
          }
      }

      fn main() {
          let screen = Screen {
              components: vec![
                  Box::new(SelectBox {
                      width: 75,
                      height: 10,
                      options: vec![
                          String::from("Yes"),
                          String::from("Maybe"),
                          String::from("No")
                      ],
                  }),
                  Box::new(Button {
                      width: 50,
                      height: 10,
                      label: String::from("OK"),
                  }),
              ],
          };

          screen.run();
      }
    #+END_SRC

    - /duck typing/

*** DONE Trait Objects Perform Dynamic Dispatch - 380
    CLOSED: [2017-08-30 Wed 22:43]
    - The code that results from /monomorphization/ is doing static dispatch:
      when the method is called, the code that goes with that method call
      _has been determined_ at compile time, and looking up that code is very
      _FAST_.

    - When we use trait objects, the compiler can't perform /monomorphization/.
      Rust can figure it out when a method is called at /runtime/ (of course,
      there is runtime cost).
        This is called /dynamic dispatch/.

    - Dynamic dispatch also _prevents_ the compiler from choosing to /inline/ a
      method's code, which _prevents some optimizations_.

      Tradeoff between performance (extra runtime cost) and extra flexibility.

*** TODO Object Safety is Required for Trait Objects - 380 =RE-READ= =HARD=
    =MORE EXAMPLES REQUIRED=
    NOT all /traits/ can be made into /trait objects/; ONLY /object safe/
    /traits/ can.

    - The requirements of /object safe/:
      + The trait does NOT require ~Self~ to be ~Sized~
      + All of the trait's methods are /object safe/.

    - ~Self~ :: a keyword that is an alias for the type that we're implementing
                traits or methods on.

    - ~Sized~ :: a marker trait like the ~Send~ and ~Sync~ traits that we talked
                 about in Chapter 16 =TODO=.

    - ~Sized~ is automatically implemented on types that have a known size at
      compile time, such as ~i32~ and references.

      Types that do NOT have a known size include slices(~[T]~) and
      /trait objects/.

    - ~Sized~ is an implicit trait bound on all generic type parameters by
      default. Most useful operations in Rust require a type to be ~Sized~, so
      making ~Sized~ a default requirement on trait bounds means we don't have
      to write ~T: Sized~ with most every use of generics. If we want to be able
      to use a trait on slices, however, we need to opt out of the ~Sized~ trait
      bound, and we can do that by specifying ~T: ?Sized~ as a trait bound.
      =TODO=

    - /supertraits/ =TODO= CHAPTER 19

    - The reason a trait like ~Foo~ that requires ~Self~ to be ~Sized~ is
      _NOT allowed_ to be a /trait object/ is that it would be impossible to
      implement the trait ~Foo~ for the /trait object/ ~Foo~:
      /trait objects/ are NOT sized, but ~Foo~ requires ~Self~ to be ~Sized~.

      _A type can't be both sized and unsized at the same time!_

    - A method is /object safe/ if either:
      * It requires ~Self~ to be ~Sized~ or

      * It meets _ALL_ three of the following:
        + It _MUST NOT_ have any generic type parameters

        + Its first argument _MUST_ be
          - of type ~Self~
            or
          - a type that dereferences to the ~Self~ type (that is, it must be a
            method rather than an associated function and have ~self~, ~&self~,
            or ~&mut self~ as the first argument)

        + It _MUST NOT_ use ~Self~ anywhere else in the signature except for the
          first argument.

** TODO Implementating on Object-Oriented Design Pattern - 382
*** TODO Defining ~Post~ and Creating a New Instance in the Draft State - 383
*** TODO Storing the Text of the Post Content - 384
*** TODO Ensuring the Content of a Draft Post Is Empty - 384
*** TODO Requesting a Review of the Post Changes Its State - 385
*** TODO Adding the ~approve~ Method that Changes the Behavior of ~content~ - 386
*** TODO Trade-offs of the State Pattern - 389
**** TODO Encoding States and Behavior as Types
**** TODO Implementing Transitions as Transformations into Different Types

** TODO Summary - 393

* DONE 18. Patterns and Maching - 395
  CLOSED: [2017-08-30 Wed 04:43]
  - =TODO= the difference between /refutable/ and /irrefutable/ patterns,
** DONE All the Places Patterns May be Used - 396
   CLOSED: [2017-08-30 Wed 00:58]
*** DONE ~match~ Arms - 396
    CLOSED: [2017-08-29 Tue 23:15]
*** DONE Conditional ~if let~ Expressions - 396
    CLOSED: [2017-08-29 Tue 23:22]
    It's possbile to mix and match ~if let~, ~else if~, and ~else if let~.
    =IMPORTANT= NOT like ~match~!!! NO exhaustiveness check!!!

    #+BEGIN_SRC rust
      fn main() {
          let favorite_color: Option<&str> = None;
          let is_tuesday = false;
          let age: Result<u8, _> = "34".parse();

          if let Some(color) = favorite_color {
              println!("Using your favorite color, {}, as the background", color);
          } else if is_tuesday {
              println!("Tuesday is green day!");
          } else if let Ok(age) = age {
              // shadowed variables !!!
              if age > 30 {
                  println!("Using purple as the background color");
              } else {
                  println!("Using orange as the background color");
              }
          } else {
              println!("Using blue as the background color");
          }
      }
    #+END_SRC

*** DONE ~while let~ Conditional Loops - 398
    CLOSED: [2017-08-30 Wed 00:43]
    #+BEGIN_SRC rust
      let mut stack = Vec::new();

      stack.push(1);
      stack.push(2);
      stack.push(3);

      while let Some(top) = stack.pop() {
          println!("{}", top);
      }
    #+END_SRC

*** DONE ~for~ loops - 398
    CLOSED: [2017-08-30 Wed 00:44]
    #+BEGIN_SRC rust
      let v = vec![1, 2, 3];

      for (index, value) in v.iter().enumerate() {
          println!("{} is at index {}", value, index);
      }
    #+END_SRC

*** DONE ~let~ Statements - 399
    CLOSED: [2017-08-30 Wed 00:45]
    =TODO=We saw another example of destructuring a tuple in _Chapter 16_,
    Listing 16-6, where we destructured the return value of ~mpsc::channel()~
    into the ~tx~ (transmitter) and ~rx~ (receiver) parts.

*** DONE Function Parameters - 400
    CLOSED: [2017-08-30 Wed 00:58]
    #+BEGIN_SRC rust
      // src/main.rs

      fn print_coordinates(&(x, y): &(i32, i32)) {
          println!("Current location: ({}, {})", x, y);
      }

      fn main() {
          let point = (3, 5);
          print_coordinates(&point);
      }
    #+END_SRC

    - =IMPORTANT=
      One difference between the places we can use patterns is that with
      + ~for~ loops
      + ~let~
      + in function parameters
      the patterns must be /irrefutable/. =TODO= next section.

** DONE Refutability: Whether a Pattern Might Fail to Match - 401
   CLOSED: [2017-08-30 Wed 01:10]
   - Patterns come in _two_ forms:
     + /refutable/: patterns which can fail to match for some possible value.

     + /irrefutable/: patterns which CANNOT fail to match for any possible value.

   - ~let~ statements, function parameters, and ~for~ loops are restricted to
     _ONLY accept_ /irrefutable patterns/,

     since there's nothing correct the program could do if the pattern fails to
     match.

   - ~if let~, and ~while let~ expressions are restricted to _ONLY accept_
     /refutable patterns/,

     since they're made to handle possible failure and we wouldn't need their
     functionality if the pattern could never fail.

   - When we use these two concepts, nothing complicated.

     What we really need to know is that when these concepts show up in an error
     message, which should know what do they mean.

   - For example,
     #+BEGIN_SRC rust
       let Some(x) = some_option_value; // Can be `None`

       // error[E0005]: refutable pattern in local binding: `None` not covered
       //  --> <anon>:3:5
       //   |
       // 3 | let Some(x) = some_option_value;
       //   |     ^^^^^^^ pattern `None` not covered
     #+END_SRC

     Solution:
     #+BEGIN_SRC rust
       if let Some(x) = some_option_value {
           println!("{}", x);
       }
     #+END_SRC

   - For example,
     #+BEGIN_SRC rust
       if let x = 5 {
           println!("{}", x);
       };

       // error[E0162]: irrefutable if-let pattern
       //  --> <anon>:2:8
       //   |
       // 2 | if let x = 5 {
       //   |        ^ irrefutable pattern
     #+END_SRC

     Solution: ~let x = 5; println!("{}", x);~ or just ~println!("{}", x);~

** DONE Pattern Syntax - 402
   CLOSED: [2017-08-30 Wed 04:43]
*** DONE Matching Literals - 402
    CLOSED: [2017-08-30 Wed 01:12]
    #+BEGIN_SRC rust
      // Suppose `x` is a number

      match x {
          1 => println!("one"),
          2 => println!("two"),
          3 => println!("three"),
          _ => println!("anything"),
      }
    #+END_SRC
    This is like a non-fall-through switch in C/C++/Java.

*** DONE Matching Named Variables - 403
    CLOSED: [2017-08-30 Wed 01:19]
    - Named variables are irrefutable patterns that match any value.
      For example, if an arm of ~match~ is ~Some(y)~, here ~y~ is the named
      variables.

    - In order to make a ~match~ expression that compares the values of the outer
      ~x~ and ~y~ rather than introducing a shadowed variable, we would need to
      use a /match guard/ conditional instead.

      =TODO= We'll be talking about match guards later in this section.

*** DONE Multiple Patterns - 404
    CLOSED: [2017-08-30 Wed 01:19]
    Use ~|~
    #+BEGIN_SRC rust
      match x {
          1 | 2 => println!("one or two"),
          3 => println!("three"),
          _ => println!("anything"),
      }
    #+END_SRC

*** DONE Matching Ranges of Values with ~..=~ - 404
    CLOSED: [2017-08-30 Wed 01:23]
    - ~..=~ is used to match an _inclusive_ range.

    - Ranges are only allowed with
      + numeric values (=TODO= =From Jian= CANNOT be Flotaing, Right???)
      + ~char~ values

    - Example:
      #+BEGIN_SRC rust
        // Suppose `x` is number
        match x {
            1..=5 => println!("one through five"),
            _ => println!("something else"),
        }
      #+END_SRC

      #+BEGIN_SRC rust
        match x {
            'a'..='j' => println!("early ASCII letter"),
            'k'..='z' => println!("late ASCII letter"),
            _ => println!("something else"),
        }
      #+END_SRC

*** DONE Destructuring to Break Apart Values - 405
    CLOSED: [2017-08-30 Wed 01:30]
**** Destructuring Structs
**** Destructuring Enums
**** Destructuring Nested Structs and Enums
**** Destructuring Structs and Tuples

     - =OLD NOTE !!!=

     - Patterns can be used to _destructure_
       + structs
       + enums
       + tuples
       + references

     - Example:
       #+BEGIN_SRC rust
         struct Point {
             x: i32,
             y: i32,
         }

         fn main() {
             let p = Point { x: 0, y: 7 };

             let Point { x, y } = p;
             assert_eq!(0, x);
             assert_eq!(7, y);

             // The below code is also available:
             //
             // let Point { x: a, y: b } = p;
             // assert_eq!(0, a);
             // assert_eq!(7, b);
         }
       #+END_SRC

     - Example:
       #+BEGIN_SRC rust
         fn main() {
             let p = Point { x: 0, y: 7 };

             match p {
                 Point { x, y: 0 } => println!("On the x axis at {}", x),
                 Point { x: 0, y } => println!("On the y axis at {}", y),
                 Point { x, y } => println!("On neither axis: ({}, {})", x, y),
             }
         }
       #+END_SRC

     - Example:
       #+BEGIN_SRC rust
         let points = vec![
             Point { x: 0, y: 0 },
             Point { x: 1, y: 5 },
             Point { x: 10, y: -3 },
         ];

         let sum_of_squares: i32 = points
             .iter()
             .map(|&Point {x, y}| x * x + y * y)
             .sum();


         // If we forget the `&`
         //
         // The error message is:
         // error[E0308]: mismatched types
         //   -->
         //    |
         // 14 |         .map(|Point {x, y}| x * x + y * y)
         //    |               ^^^^^^^^^^^^ expected &Point, found struct `Point`
         //    |
         //    = note: expected type `&Point`
         //               found type `Point`
       #+END_SRC

*** DONE Ignoring Values in a Pattern - 409
    CLOSED: [2017-08-30 Wed 01:48]
    ~_~ and ~..~

**** DONE Ignoring an Entire Value with ~_~
     CLOSED: [2017-08-30 Wed 01:33]
     - Example:
       #+BEGIN_SRC rust
         fn foo(_: i32) {
             // code goes here
         }
       #+END_SRC

     - In cases such as implementing a /trait/, where you need a certain type
       signature, using an underscore lets you ignore a parameter, and the
       compiler won't warn about unused function parameters like it would if we
       had used a name instead.

       _Use underscore to avoid that the compiler warns you about unused function
       parameters_

**** DONE Ignoring Parts of a Value with a Nested ~_~
     CLOSED: [2017-08-30 Wed 01:35]
     #+BEGIN_SRC rust
       match x {
           Some(_) => println!("got a Some and I don't care what's inside"),
           None => (),
       }


       // let numbers = (2, 4, 8, 16, 32);

       match numbers {
           (first, _, third, _, fifth) => {
               println!("Some numbers: {}, {}, {}", first, third, fifth)
           },
       }
     #+END_SRC

**** DONE Ignoring an Unused Variable by Starting Its Name with ~_~
     CLOSED: [2017-08-30 Wed 01:48]
     - The difference between ~_x~ and ~_~:
       + ~_x~ still binds the value, though there is no warning when ~_x~ is
         unused.

       + ~_~ doesn't bind at all.

     - Underscore prefixed variables are useful when you want to /move/ a
       variable when do pattern matchings -- disable that variable.

       #+BEGIN_SRC rust
         let s = Some(String::from("Hello!"));

         if let Some(_s) = s {
             println!("found a string");
         }

         // If there is a
         //
         // `println!("{:?}", s);`
         //
         // there will be a compiling error.
       #+END_SRC

**** DONE Ignoring Remaining Parts of a Value with ~..~
     CLOSED: [2017-08-30 Wed 01:48]
     - Example:
       #+BEGIN_SRC rust
         struct Point {
             x: i32,
             y: i32,
             z: i32,
         }

         let origin = Point { x: 0, y: 0, z: 0 };

         match origin {
             Point { x, .. } => println!("x is {}", x),
         }
       #+END_SRC

       Using ~..~ is shorter to type than having to list out ~y: _~ and ~z: _~.

       =IMPORTANT=
       The ~..~ pattern is especially useful when working with structs that have
       lots of fields in situations where only one or two fields are relevant.

     - ~..~ will expand to _as many values as it needs to be_.
       #+BEGIN_SRC rust
         fn main() {
             let numbers = (2, 4, 8, 16, 32);

             match numbers {
                 (first, .., last) => {
                     println!("Some numbers: {}, {}", first, last);
                 },
             }
         }
       #+END_SRC

     - ~..~ mustn't be ambiguous.
       For example, one arm of ~match~ CANNOT be ~(.., second, ..)~

     - =From Jian=
       ~..~ syntax should be expanded, and people can specify the number of
       elements they indicate.

*** DONE Extra Conditionals with March Guards - 413
    CLOSED: [2017-08-30 Wed 02:10]
    #+BEGIN_SRC rust
      let num = Some(4);

      match num {
          Some(x) if x < 5 => println!("less than five: {}", x),
          Some(x) => println!("{}", x),
          None => (),
      }
    #+END_SRC

    - Example (fight against shadowning):
      #+BEGIN_SRC rust
        fn main() {
            let x = Some(5);
            let y = 10;

            match x {
                Some(50) => println!("Got 50"),
                Some(n) if n == y => println!("Matched, n = {:?}", n),
                _ => println!("Default case, x = {:?}", x),
            }

            println!("at the end: x = {:?}, y = {:?}", x, y);
        }
      #+END_SRC

      The ~y~ shows up ONLY in the guard part, which makes it clear that this ~y~
      should be the one in the outside scope.

      =NOTE= You definitely cannot write like ~Some(y) if y == y => ...~.

    - Example (guard that should be applied to all the ~|~ separated patterns):
      #+BEGIN_SRC rust
        // let x = 4;
        // let y = false;

        match x {
            4 | 5 | 6 if y => println!("yes"),
            _ => println!("no"),
        }
      #+END_SRC

      In other words,
      + it is ~(4 | 5 | 6) if y => ...~
      + it is NOT ~4 | 5 | (6 if y) => ...~, though this is NOT compilable.

    - If you just want to use guard when only part of the ~|~ patterns match,
      just split and re-group the patterns.

*** DONE ~@~ Bindings - 415
    CLOSED: [2017-08-30 Wed 04:43]
    #+BEGIN_SRC rust
      enum Message {
          Hello { id: i32 },
      }

      let msg = Message::Hello { id: 5 };

      match msg {
          Message::Hello { id: id @ 3...7 } => {
              println!("Found an id in range: {}", id)
          },
          Message::Hello { id: 10...12 } => {
              println!("Found an id in another range")
          },
          Message::Hello { id } => {
              println!("Found some other id: {}", id)
          },
      }
    #+END_SRC

    - The first arm:
      we bind the exact value of the ~id~ of ~msg~ to the ~id~ after ~:~, and
      also test if it is in the range of ~3...7~.

    - The second arm:
      match a range of numbers, but no binding.

    - The third arm:
      bind the value of the ~id~ field of a ~Message~ instance to the variable
      ~id~.

** DONE Summary - 416
   CLOSED: [2017-08-30 Wed 04:43]

* TODO 19. Advanced Features - 417
** TODO Unsafe Rust - 418
*** TODO Unsafe Superpowers - 418
*** TODO Dereferencing a Raw Pointer - 419
*** TODO Calling an Unsafe Function or Method - 421
**** TODO Creating a Safe Abstraction over Unsafe Code
**** TODO Using ~extern~ Functions to Call External Code
     - *Calling Rust Functions from Other Languages*

*** TODO Accessing or Modifying a Mutable Static Variable - 425
*** TODO Implementing an Unsafe Trait - 426
*** TODO Accessing Fields of a Union
*** TODO When to Use Unsafe Code - 427

** TODO Advanced Traits - 427
*** TODO Specifying Placeholder Types in Trait Definitions with Associated Types - 427
**** TODO Associated Types Versus Generics
**** TODO Trait Objects with Associated Types

*** TODO Default Generic Type Parameters and Operator Overloading - 429
*** TODO Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name - 431
*** TODO Using Supertraits to Require One Trait's Functionality Within Another Trait - 434
*** TODO Using the Newtype Pattern to Implement External Traits on External Types - 436

** TODO Advanced Types - 437
*** TODO Using the Newtype Pattern for Type Safety and Abstraction - 437
*** TODO Creating Type Synonyms with Type Aliases - 438
*** TODO The Never Type That Never Returns - 440
*** TODO Dynamically Sized Types and ~Sized~ Trait - 441
**** TODO The ~Sized~ Trait

** TODO Advanced Functions and Closures - 443
*** TODO Function Pointers - 443
*** TODO Returning Closures - 445

** TODO Macros - 446
*** The Difference Between Macros and Functions - 446
*** Declarative Macros with ~macro_rules!~ for General Metaprogramming - 446
*** Procedural Macros for Generating Code from Attributes - 449
*** How to Write a Custom ~derive~ Macro - 449
*** Attribute-like macros - 454
*** Function-like macros - 455

** TODO Summary - 455

* TODO 20. Final Project: Building a Multithreaded Web Server - 457
** TODO Building a Single-Threaded Web Server - 458
*** TODO Listening to the TCP Connection - 458
*** TODO Reading the Request - 460
*** TODO A Closer Look at an HTTP Request - 462
*** TODO Writing a Response - 463
*** TODO Returning Real HTML - 464
*** TODO Validating the Request and Selectively Responding - 465
*** TODO A Touch of Refactoring - 466

** TODO Turning Our Single-Threaded Server into a Multithreaded Server - 468
*** TODO Simulating a Slow Request in the Current Server Implementation - 468
*** TODO Improving Throughput with a Thread Pool - 469
**** Code Structure If We Could Spawn a Thread for Each Request - 470
**** Creating a Similar Interface for a Finite Number of Threads - 470
**** Building the ~ThreadPool~ Struct Using Compiler Driven Development - 471
**** Validating the Number of Threads in ~new~ - 474
**** Creating Space to Store the Threads - 475
**** A ~Worker~ Struct Responsible for Sending Code from the ~ThreadPool~ to a Thread - 476
**** Sending Requests to Threads via Channels - 478
**** Implementing the ~execute~ Method - 481

** TODO Graceful Shutdown and Cleanup - 487
*** TODO Implementing the ~Drop~ Trait on ~ThreadPool~ - 487
*** TODO Signaling to the Threads to Stop Listening for Jobs - 489

** TODO Summary - 493

* TODO 21. Appendix
** TODO 21.1. A - Keywords
*** TODO Keywords Currently in Use
    take =NOTE=

*** TODO Keywords Reserved for Future Use
    take =Note=
    
*** DONE Raw Identifiers
    CLOSED: [2021-01-06 Wed 14:32]
    /Keywords/ can be used as /identifiers/ if they are prefixed with ~r#~.
    
    - Use case:
      Rust 2015 doesn't include a /keyword/ ~try~.
      If your code in Rust 2018 want to use a library written in Rust 2015, which
      contains a function ~try~, you need to invoke it with ~r#try~.
 
    - =TODO=
      More in Appendix E.

** TODO 21.2. B - Operators and Symbols
*** TODO Operators
*** TODO Non-operator Symbols

** TODO 21.3. C - Derivable Traits
*** ~Debug~ for Programmer Output - 508
*** ~PartialEq~ and ~Eq~ for Equality Comparisons - 508
*** ~PartialOrd~ and ~Ord~ for Ordering Comparisons - 509
*** ~Clone~ and ~Copy~ for Duplicating Values - 509
*** ~Hash~ for Mapping a Value to a Value of Fixed Size - 510
*** ~Default~ for Default Values - 510
*
** TODO 21.4. D - Useful Development Tools
*** Automatic Formatting with =rustfmt= - 511
*** Fix Your Code with =rustfix= - 512
*** More Lints with Clippy - 513
*** IDE Integration Using the Rust Language Server - 514
*
** TODO 21.5. E - Editions
** DONE 21.6. F - Translations of the Book
   CLOSED: [2021-01-06 Wed 14:36]
** TODO 21.7. G - How Rust is Made and "Nightly Rust"
