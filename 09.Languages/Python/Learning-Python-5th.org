#+TITLE: Learning Python
#+SUBTITLE: Powerful Object-Oriented Programming
#+VERSION: 5th (Updated for 3.3 and 2.7)
#+AUTHOR: Mark Lutz
#+STARTUP: overview
#+STARTUP: entitiespretty
#+STARTUP: indent

* Preface - xxxiii
* Part I. Getting Started
** 1. A Python Q&A Session - 3
*** Why Do People Use Python? - 3
**** Software Quality 4
**** Developer Productivity 5

*** Is Python a “Scripting Language”? - 5
*** OK, but What’s the Downside? - 7
*** Who Uses Python Today? - 9
*** What Can I Do with Python? - 10
**** Systems Programming 11
**** GUIs 11
**** Internet Scripting 11
**** Component Integration 12
**** Database Programming 12
**** Rapid Prototyping 13
**** Numeric and Scientific Programming 13
**** And More: Gaming, Images, Data Mining, Robots, Excel... 14

*** How Is Python Developed and Supported? - 15
**** Open Source Tradeoffs 15

*** What Are Python’s Technical Strengths? - 16
**** It’s Object-Oriented and Functional 16
**** It’s Free 17
**** It’s Portable 17
**** It’s Powerful 18
**** It’s Mixable 19
**** It’s Relatively Easy to Use 19
**** It’s Relatively Easy to Learn 20
**** It’s Named After Monty Python 20

*** How Does Python Stack Up to Language X? - 21
*** Chapter Summary - 22
*** Test Your Knowledge: Quiz - 23
*** Test Your Knowledge: Answers - 23

** 2. How Python Runs Programs - 27
*** Introducing the Python Interpreter - 27
*** Program Execution - 28
**** The Programmer’s View 28
**** Python’s View 30

*** Execution Model Variations - 33
**** Python Implementation Alternatives - 33
**** Execution Optimization Tools - 37
**** Frozen Binaries - 39
**** Future Possibilities? - 40

*** Chapter Summary - 40
*** Test Your Knowledge: Quiz - 41
*** Test Your Knowledge: Answers - 41

** 3. How You Run Programs - 43
*** The Interactive Prompt 43
**** Starting an Interactive Session 44
**** The System Path 45
**** New Windows Options in 3.3: PATH, Launcher 46
**** Where to Run: Code Directories 47
**** What Not to Type: Prompts and Comments 48
**** Running Code Interactively 49
**** Why the Interactive Prompt? 50
**** Usage Notes: The Interactive Prompt 52

*** System Command Lines and Files 54
**** A First Script 55
**** Running Files with Command Lines 56
**** Command-Line Usage Variations 57
**** Usage Notes: Command Lines and Files 58

*** Unix-Style Executable Scripts: #! 59
**** Unix Script Basics 59
**** The Unix env Lookup Trick 60
**** The Python 3.3 Windows Launcher: #! Comes to Windows 60

*** Clicking File Icons 62
**** Icon-Click Basics 62
**** Clicking Icons on Windows 63
**** The input Trick on Windows 63
**** Other Icon-Click Limitations 66

*** Module Imports and Reloads 66
**** Import and Reload Basics 66
**** The Grander Module Story: Attributes 68
**** Usage Notes: import and reload 71

*** Using exec to Run Module Files 72
*** The IDLE User Interface 73
**** IDLE Startup Details 74
**** IDLE Basic Usage 75
**** IDLE Usability Features 76
**** Advanced IDLE Tools 77
**** Usage Notes: IDLE 78

*** Other IDEs 79
*** Other Launch Options 81
**** Embedding Calls 81
**** Frozen Binary Executables 82
**** Text Editor Launch Options 82
**** Still Other Launch Options 82
**** Future Possibilities? 83

*** Which Option Should I Use? 83
*** Chapter Summary 85
*** Test Your Knowledge: Quiz 85
*** Test Your Knowledge: Answers 86
*** Test Your Knowledge: Part I Exercises 87

* Part II. Types and Operations
** 4. Introducing Python Object Types - 93
*** The Python Conceptual Hierarchy 93
*** Why Use Built-in Types? 94
*** Python’s Core Data Types 95
*** Numbers 97
*** Strings 99
**** Sequence Operations 99
**** Immutability 101
**** Type-Specific Methods 102
**** Getting Help 104
**** Other Ways to Code Strings 105
**** Unicode Strings 106
**** Pattern Matching 108

*** Lists 109
**** Sequence Operations 109
**** Type-Specific Operations 109
**** Bounds Checking 110
**** Nesting 110
**** Comprehensions 111

*** Dictionaries 113
**** Mapping Operations 114
**** Nesting Revisited 115
**** Missing Keys: if Tests 116
**** Sorting Keys: for Loops 118
**** Iteration and Optimization 120

*** Tuples 121
**** Why Tuples? 122

*** Files 122
**** Binary Bytes Files 123
**** Unicode Text Files 124
**** Other File-Like Tools 126

*** Other Core Types 126
**** How to Break Your Code’s Flexibility 128
**** User-Defined Classes 129
**** And Everything Else 130

*** Chapter Summary 130
*** Test Your Knowledge: Quiz 131
*** Test Your Knowledge: Answers 131

** 5. Numeric Types - 133
*** Numeric Type Basics 133
**** Numeric Literals 134
**** Built-in Numeric Tools 136
**** Python Expression Operators 136

*** Numbers in Action 141
**** Variables and Basic Expressions 141
**** Numeric Display Formats 143
**** Comparisons: Normal and Chained 144
**** Division: Classic, Floor, and True 146
**** Integer Precision 150
**** Complex Numbers 151
**** Hex, Octal, Binary: Literals and Conversions 151
**** Bitwise Operations 153
**** Other Built-in Numeric Tools 155

*** Other Numeric Types 157
**** Decimal Type 157
**** Fraction Type 160
**** Sets 163
**** Booleans 171

*** Numeric Extensions 172
*** Chapter Summary 172
*** Test Your Knowledge: Quiz 173
*** Test Your Knowledge: Answers 173

** 6. The Dynamic Typing Interlude - 175
*** The Case of the Missing Declaration Statements 175
**** Variables, Objects, and References 176
**** Types Live with Objects, Not Variables 177
**** Objects Are Garbage-Collected 178

*** Shared References 180
**** Shared References and In-Place Changes 181
**** Shared References and Equality 183

*** Dynamic Typing Is Everywhere 185
*** Chapter Summary 186
*** Test Your Knowledge: Quiz 186
*** Test Your Knowledge: Answers 186

** 7. String Fundamentals - 189
*** This Chapter’s Scope 189
**** Unicode: The Short Story 189

*** String Basics 190
*** String Literals 192
**** Single- and Double-Quoted Strings Are the Same 193
**** Escape Sequences Represent Special Characters 193
**** Raw Strings Suppress Escapes 196
**** Triple Quotes Code Multiline Block Strings 198

*** Strings in Action 200
**** Basic Operations 200
**** Indexing and Slicing 201
**** String Conversion Tools 205
**** Changing Strings I 208

*** String Methods 209
**** Method Call Syntax 209
**** Methods of Strings 210
**** String Method Examples: Changing Strings II 211
**** String Method Examples: Parsing Text 213
**** Other Common String Methods in Action 214
**** The Original string Module’s Functions (Gone in 3.X) 215

*** String Formatting Expressions 216
**** Formatting Expression Basics 217
**** Advanced Formatting Expression Syntax 218
**** Advanced Formatting Expression Examples 220
**** Dictionary-Based Formatting Expressions 221

*** String Formatting Method Calls 222
**** Formatting Method Basics 222
**** Adding Keys, Attributes, and Offsets 223
**** Advanced Formatting Method Syntax 224
**** Advanced Formatting Method Examples 225
**** Comparison to the % Formatting Expression 227
**** Why the Format Method? 230

*** General Type Categories 235
**** Types Share Operation Sets by Categories 235
**** Mutable Types Can Be Changed in Place 236

*** Chapter Summary 237
*** Test Your Knowledge: Quiz 237
*** Test Your Knowledge: Answers 237

** 8. Lists and Dictionaries - 239
*** Lists 239
*** Lists in Action 242
**** Basic List Operations 242
**** List Iteration and Comprehensions 242
**** Indexing, Slicing, and Matrixes 243
**** Changing Lists in Place 244

*** Dictionaries 250
*** Dictionaries in Action 252
**** Basic Dictionary Operations 253
**** Changing Dictionaries in Place 254
**** More Dictionary Methods 254
**** Example: Movie Database 256
**** Dictionary Usage Notes 258
**** Other Ways to Make Dictionaries 262
**** Dictionary Changes in Python 3.X and 2.7 264

*** Chapter Summary 271
*** Test Your Knowledge: Quiz 272
*** Test Your Knowledge: Answers 272

** 9. Tuples, Files, and Everything Else - 275
*** Tuples 276
**** Tuples in Action 277
**** Why Lists and Tuples? 279
**** Records Revisited: Named Tuples 280

*** Files 282
**** Opening Files 283
**** Using Files 284
**** Files in Action 285
**** Text and Binary Files: The Short Story 287
**** Storing Python Objects in Files: Conversions 288
**** Storing Native Python Objects: pickle 290
**** Storing Python Objects in JSON Format 291
**** Storing Packed Binary Data: struct 293
**** File Context Managers 294
**** Other File Tools 294

*** Core Types Review and Summary 295
**** Object Flexibility 297
**** References Versus Copies 297
**** Comparisons, Equality, and Truth 300
**** The Meaning of True and False in Python 304
**** Python’s Type Hierarchies 306
**** Type Objects 306
**** Other Types in Python 308

*** Built-in Type Gotchas 308
**** Assignment Creates References, Not Copies 308
**** Repetition Adds One Level Deep 309
**** Beware of Cyclic Data Structures 310
**** Immutable Types Can’t Be Changed in Place 311

*** Chapter Summary 311
*** Test Your Knowledge: Quiz 311
*** Test Your Knowledge: Answers 312
*** Test Your Knowledge: Part II Exercises 313

* Part III. Statements and Syntax
** 10. Introducing Python Statements - 319
*** The Python Conceptual Hierarchy Revisited 319
*** Python’s Statements 320
*** A Tale of Two ifs 322
**** What Python Adds 322
**** What Python Removes 323
**** Why Indentation Syntax? 324
**** A Few Special Cases 327

*** A Quick Example: Interactive Loops 329
**** A Simple Interactive Loop 329
**** Doing Math on User Inputs 331
**** Handling Errors by Testing Inputs 332
**** Handling Errors with try Statements 333
**** Nesting Code Three Levels Deep 335

*** Chapter Summary 336
*** Test Your Knowledge: Quiz 336
*** Test Your Knowledge: Answers 336

** 11. Assignments, Expressions, and Prints - 339
*** Assignment Statements 339
**** Assignment Statement Forms 340
**** Sequence Assignments 341
**** Extended Sequence Unpacking in Python 3.X 344
**** Multiple-Target Assignments 348
**** Augmented Assignments 350
**** Variable Name Rules 352

*** Expression Statements 356
**** Expression Statements and In-Place Changes 357

*** Print Operations 358
**** The Python 3.X print Function 359
**** The Python 2.X print Statement 361
**** Print Stream Redirection 363
**** Version-Neutral Printing 366

*** Chapter Summary 369
*** Test Your Knowledge: Quiz 370
*** Test Your Knowledge: Answers 370

** 12. ~if~ Tests and Syntax Rules - 371
*** if Statements 371
**** General Format 371
**** Basic Examples 372
**** Multiway Branching 372

*** Python Syntax Revisited 375
**** Block Delimiters: Indentation Rules 376
**** Statement Delimiters: Lines and Continuations 378
**** A Few Special Cases 379

*** Truth Values and Boolean Tests 380
*** The if/else Ternary Expression 382
*** Chapter Summary 385
*** Test Your Knowledge: Quiz 385
*** Test Your Knowledge: Answers 386

** 13. ~while~ and ~for~ Loops - 387
*** while Loops 387
**** General Format 388
**** Examples 388

*** break, continue, pass, and the Loop else 389
**** General Loop Format 389
**** pass 390
**** continue 391
**** break 391
**** Loop else 392

*** for Loops 395
**** General Format 395
**** Examples 395

*** Loop Coding Techniques 402
**** Counter Loops: range 402
**** Sequence Scans: while and range Versus for 403
**** Sequence Shufflers: range and len 404
**** Nonexhaustive Traversals: range Versus Slices 405
**** Changing Lists: range Versus Comprehensions 406
**** Parallel Traversals: zip and map 407
**** Generating Both Offsets and Items: enumerate 410

*** Chapter Summary 413
*** Test Your Knowledge: Quiz 414
*** Test Your Knowledge: Answers 414

** 14. Iterations and Comprehensions - 415
*** Iterations: A First Look 416
**** The Iteration Protocol: File Iterators 416
**** Manual Iteration: iter and next 419
**** Other Built-in Type Iterables 422

*** List Comprehensions: A First Detailed Look 424
**** List Comprehension Basics 425
**** Using List Comprehensions on Files 426
**** Extended List Comprehension Syntax 427

*** Other Iteration Contexts 429
*** New Iterables in Python 3.X 434
**** Impacts on 2.X Code: Pros and Cons 434
**** The range Iterable 435
**** The map, zip, and filter Iterables 436
**** Multiple Versus Single Pass Iterators 438
**** Dictionary View Iterables 439

*** Other Iteration Topics 440
*** Chapter Summary 441
*** Test Your Knowledge: Quiz 441
*** Test Your Knowledge: Answers 441

** 15. The Documentation Interlude - 443
*** Python Documentation Sources 443
**** # Comments 444
**** The dir Function 444
**** Docstrings: __doc__ 446
**** PyDoc: The help Function 449
**** PyDoc: HTML Reports 452
**** Beyond docstrings: Sphinx 461
**** The Standard Manual Set 461
**** Web Resources 462
**** Published Books 463

*** Common Coding Gotchas 463
*** Chapter Summary 465
*** Test Your Knowledge: Quiz 466
*** Test Your Knowledge: Answers 466
*** Test Your Knowledge: Part III Exercises 467

* Part IV. Functions and Generators
** 16 Function Basics - 473
*** Why Use Functions? - 474
*** Coding Functions - 475
**** def Statements - 476
**** def Executes at Runtime - 477

*** A First Example: Definitions and Calls - 478
**** Definition - 478
**** Calls - 478
**** Polymorphism in Python - 479

*** A Second Example: Intersecting Sequences - 480
**** Definition - 481
**** Calls - 481
**** Polymorphism Revisited - 482
**** Local Variables - 483

*** Chapter Summary - 483
*** Test Your Knowledge: Quiz - 483
*** Test Your Knowledge: Answers - 484

** 17 Scopes - 485
*** Python Scope Basics - 485
**** Scope Details - 486
**** Name Resolution: The LEGB Rule - 488
**** Scope Example - 490
**** The Built-in Scope - 491

*** The global Statement - 494
**** Program Design: Minimize Global Variables - 495
**** Program Design: Minimize Cross-File Changes - 497
**** Other Ways to Access Globals - 498

*** Scopes and Nested Functions - 499
**** Nested Scope Details - 500
**** Nested Scope Examples - 500
**** Factory Functions: Closures - 501
**** Retaining Enclosing Scope State with Defaults - 504

*** The nonlocal Statement in 3.X - 508
**** nonlocal Basics - 508
**** nonlocal in Action - 509

*** Why nonlocal? State Retention Options - 512
**** State with nonlocal: 3.X only - 512
**** State with Globals: A Single Copy Only - 513
**** State with Classes: Explicit Attributes (Preview) - 513
**** State with Function Attributes: 3.X and 2.X - 515

*** Chapter Summary - 519
*** Test Your Knowledge: Quiz - 519
*** Test Your Knowledge: Answers - 520

** 18 Arguments - 523
*** Argument-Passing Basics - 523
**** Arguments and Shared References - 524
**** Avoiding Mutable Argument Changes - 526
**** Simulating Output Parameters and Multiple Results - 527

*** Special Argument-Matching Modes - 528
**** Argument Matching Basics - 529
**** Argument Matching Syntax - 530
**** The Gritty Details - 531
**** Keyword and Default Examples - 532
**** Arbitrary Arguments Examples - 534
**** Python 3.X Keyword-Only Arguments - 539

*** The min Wakeup Call! - 542
**** Full Credit - 542
**** Bonus Points - 544
**** The Punch Line... - 544

*** Generalized Set Functions - 545
*** Emulating the Python 3.X print Function - 547
**** Using Keyword-Only Arguments - 548

*** Chapter Summary - 550
*** Test Your Knowledge: Quiz - 551
*** Test Your Knowledge: Answers - 552

** 19 Advanced Function Topics - 553
*** Function Design Concepts - 553
*** Recursive Functions - 555
**** Summation with Recursion - 555
**** Coding Alternatives - 556
**** Loop Statements Versus Recursion - 557
**** Handling Arbitrary Structures - 558

*** Function Objects: Attributes and Annotations - 562
**** Indirect Function Calls: “First Class” Objects - 562
**** Function Introspection - 563
**** Function Attributes - 564
**** Function Annotations in 3.X - 565

*** Anonymous Functions: ~lambda~ - 567
**** lambda Basics - 568
**** Why Use lambda? - 569
**** How (Not) to Obfuscate Your Python Code - 571
**** Scopes: lambdas Can Be Nested Too - 572

*** Functional Programming Tools - 574
**** Mapping Functions over Iterables: map - 574
**** Selecting Items in Iterables: filter - 576
**** Combining Items in Iterables: reduce - 576

*** Chapter Summary - 578
*** Test Your Knowledge: Quiz - 578
*** Test Your Knowledge: Answers - 578

** 20 Comprehensions and Generations - 581
*** List Comprehensions and Functional Tools - 581
**** List Comprehensions Versus map - 582
**** Adding Tests and Nested Loops: filter - 583
**** Example: List Comprehensions and Matrixes - 586
**** Don’t Abuse List Comprehensions: KISS - 588

*** Generator Functions and Expressions - 591
**** Generator Functions: yield Versus return - 592
**** Generator Expressions: Iterables Meet Comprehensions - 597
**** Generator Functions Versus Generator Expressions - 602
**** Generators Are Single-Iteration Objects - 604
**** Generation in Built-in Types, Tools, and Classes - 606
**** Example: Generating Scrambled Sequences - 609
**** Don’t Abuse Generators: EIBTI - 614
**** Example: Emulating zip and map with Iteration Tools - 617

*** Comprehension Syntax Summary - 622
**** Scopes and Comprehension Variables - 623
**** Comprehending Set and Dictionary Comprehensions - 624
**** Extended Comprehension Syntax for Sets and Dictionaries - 625

*** Chapter Summary - 626
*** Test Your Knowledge: Quiz - 626
*** Test Your Knowledge: Answers - 626

** TODO 21 The Benchmarking Interlude - 629
*** Timing Iteration Alternatives - 629
**** Timing Module: Homegrown - 630
**** Timing Script - 634
**** Timing Results - 635
**** Timing Module Alternatives - 638
**** Other Suggestions - 642

*** Timing Iterations and Pythons with timeit - 642
**** Basic timeit Usage - 643
**** Benchmark Module and Script: timeit - 647
**** Benchmark Script Results - 649
**** More Fun with Benchmarks - 651

*** Other Benchmarking Topics: pystones - 656
*** Function Gotchas - 656
**** Local Names Are Detected Statically - 657
**** Defaults and Mutable Objects - 658
**** Functions Without returns - 660
**** Miscellaneous Function Gotchas - 661

*** Chapter Summary - 661
*** Test Your Knowledge: Quiz - 662
*** Test Your Knowledge: Answers - 662
*** Test Your Knowledge: Part IV Exercises - 663

* TODO Part V. Modules and Packages
  This chapter begins our in-depth look at the /Python module/ --
  *the highest-level program organization unit*.

** 22. Modules: The Big Picture - 669
   This chapter begins our in-depth look at the /Python module/ --
   *the highest-level program organization unit*.

   - /Python module/
     * *packages* _program code_ and _data_ for REUSE.
     * *provides* _self-contained namespaces_ that
       *minimize* _variable name clashes_ across your programs.

   - In concrete terms,
     /modules/ typically CORRESPOND TO _Python program files_.

   - /Modules/ might also CORRESPOND TO _extensions coded in external languages_
     such as C, Java, or C#, and even to _directories in package imports._ =???=

   - /Modules/ are processed with
     * _TWO statements_:
       + ~import~
       + ~from~

     * _ONE important function_:
       + ~imp.reload~ (~reload~ in 2.X)
         Provides a way to *reload* a /module/'s code _WITHOUT stopping Python._

   - Chapter 3 introduced /module/ FUNDAMENTALS.

   - This chapter
     * reviews module basics 
     * offers a general look 

   - The following chapters help us
     digging into the coding details behind the theory.

   - We will learn:
     * /reloads/
     * ~__name__~ attribute
     * ~__all__~ attribute
     * /package/ imports
     * relative import syntax
     * 3.3 namespace packages
     * and so on.

   - Because /modules/ and /classes/ are really just GLORIFIED /namespaces/,
     we'll *formalize* /namespace/ concepts here as well.

*** Why Use Modules? - 669
    - =TODO=

    - /Modules/ have at least _THREE_ roles:
      * Code reuse
      * System namespace partitioning
      * Implementing shared services or data

*** Python Program Architecture - 670
**** DONE How to Structure a Program - 671
     CLOSED: [2021-03-09 Tue 16:54]
**** Imports and Attributes - 671
**** Standard Library Modules - 673
- 
*** How Imports Work - 674
**** 1. Find It - 674
**** 2. Compile It (Maybe) - 675
**** 3. Run It - 675
- 
*** Byte Code Files: ~__pycache__~ in Python 3.2+ - 676
**** Byte Code File Models in Action - 677
- 
*** The Module Search Path - 678
**** Configuring the Search Path - 681
**** Search Path Variations - 681
**** The ~sys.path~ List - 681
**** Module File Selection - 682
- 
*** Chapter Summary - 685
*** Test Your Knowledge: Quiz - 685
*** Test Your Knowledge: Answers - 685
- 
** 23. Module Coding Basics - 687
*** Module Creation - 687
**** Module Filenames - 687
**** Other Kinds of Modules - 688

*** Module Usage - 688
**** The import Statement - 689
**** The from Statement - 689
**** The from * Statement - 689
**** Imports Happen Only Once - 690
**** import and from Are Assignments - 691
**** import and from Equivalence - 692
**** Potential Pitfalls of the from Statement - 693

*** Module Namespaces - 694
**** Files Generate Namespaces - 695
**** Namespace Dictionaries: ~__dict__~ - 696
**** Attribute Name Qualification - 697
**** Imports Versus Scopes - 698
**** Namespace Nesting - 699

*** Reloading Modules - 700
**** reload Basics - 701
**** reload Example - 702

*** Chapter Summary - 703
*** Test Your Knowledge: Quiz - 704
*** Test Your Knowledge: Answers - 704

** 24. Module Packages - 707
*** Package Import Basics - 708
**** Packages and Search Path Settings - 708
**** Package =__init__.py= Files - 709

*** Package Import Example - 711
**** from Versus import with Packages - 713

*** Why Use Package Imports? - 713
**** A Tale of Three Systems - 714

*** Package Relative Imports - 717
**** Changes in Python 3.X - 718
**** Relative Import Basics - 718
**** Why Relative Imports? - 720
**** The Scope of Relative Imports - 722
**** Module Lookup Rules Summary - 723
**** Relative Imports in Action - 723
**** Pitfalls of Package-Relative Imports: Mixed Use - 729

*** Python 3.3 Namespace Packages - 734
**** Namespace Package Semantics - 735
**** Impacts on Regular Packages: Optional =__init__.py= - 736
**** Namespace Packages in Action - 737
**** Namespace Package Nesting - 738
**** Files Still Have Precedence over Directories - 740

*** Chapter Summary - 742
*** Test Your Knowledge: Quiz - 742
*** Test Your Knowledge: Answers - 742

** 25. Advanced Module Topics - 745
   - This chapter concludes this part of the book with a collection of more
     advanced module-related topics:
     * data hiding
     * the ~__future__~ module
     * the ~__name__~ variable
     * ~sys.path~ changes
     * listing tools =TODO= =???= =???= =???=
     * importing modules by name string
     * transitive reloads
     * and so on

   - /Modules/, like /functions/, are more effective when their _interfaces_ are
     well defined, so this chapter also briefly _reviews_ *module design concepts*,
     some of which we have explored in prior chapters. =from Jian= WHERE? =TODO=

   - This chapter is mostly a grab-bag assortment of addtional /module/ topics.
     *Not all* topics here are *advanced*.

*** DONE Module Design Concepts - 745
    CLOSED: [2021-04-06 Tue 01:29]
    - General ideas:
      * _You're *ALWAYS* in a /module/ in Python._
        + Even code typed at the interactive prompt really goes in a *built-in
          module* ~__main__~.

      * _Minimize module coupling: global variables._

      * _Maximize module cohesion: unified purpose._

      * _Modules should rarely change other modules' variables._
        + *Changing* /globals/ in ANOTHER /module/ is *often a symptom of a design
          problem.* Mostly, you can communicate results through devices such as
          _function arguments_ and _return values_, rather than cross-module changes.

        + =from Jian=
          I'd like to replace the "Mostly" in the above point with "Always" in my
          personal practice.

*** DONE Data Hiding in Modules - 747
    CLOSED: [2021-04-06 Tue 01:37]
    In Python, _data hiding_ in /modules/ is a _convention_, *not* a _syntactical
    constraint_.
    - =from Jian= Let me translate this sentence:
      There is no way to do a strict check for Python about the _data hiding_
      (encapsulation) of /modules/.

    - =from Jian=
      Don't trust the propaganda here.
      My conclusion: _Data hiding_ is *BAD*!!!

**** Minimizing ~from *~ Damage: ~_X~ and ~__all__~ - 747
     ~from *~ can't import any ~_X~ pattern module attributes
     if they re not listed in the ~__all__~ list.

*** DONE Enabling Future Language Features: ~__future__~ - 748
    CLOSED: [2021-04-06 Tue 01:47]
    - When used in a script, the ~from __future__ import featurename~ statement
      _MUST appear as the *first executable statement* in the file_ (possibly
      following a /docstring/ or /comment/),
      BECAUSE it ENABLES _special compilation_ of code on a _per-module basis_.

    - Try to learn what is in the ~__future__~ of the Python version that you are
      using:
      in command line run ~python --c 'import __future__; print(dir(__future__))'~.

*** DONE Mixed Usage Modes: ~__name__~ and ~"__main__"~ - 749
    CLOSED: [2021-04-06 Tue 01:55]
    - In effect, a module’s ~__name__~ variable serves as a /usage mode flag/.

    - Coding _self-test code_ at the bottom of a file under the ~__name__~ test
      is probably the _most common and simplest unit-testing protocol in Python_.

    - In addition, the ~__name__~ trick is also commonly used when you're writing
      files that can be used *BOTH* as _command-line utilities_ and as _tool
      libraries_ -- when ~__name__~ equals to ~"__main__"~, the tool will run as
      an application.

**** DONE Unit Tests with ~__name__~ - 750
     CLOSED: [2021-04-06 Tue 01:56]

*** TODO Example: Dual Mode Code - 751
**** Currency Symbols: Unicode in Action - 754
**** Docstrings: Module Documentation at Work - 756

*** DONE Changing the Module Search Path - 756
    CLOSED: [2021-04-06 Tue 02:47]
    - In Chapter 22, we learned that the /module search path/ is a list of
      directories that can *be customized via*
      * the environment variable ~PYTHONPATH~,
        and
      * possibly via ~.pth~ files.

    - Actually, Python program itself can *change* the /search path/ by changing
      the built-in ~sys.path~ list.
      _Per Chapter 22, ~sys.path~ is initialized on startup,_
      BUT thereafter you can _delete_, _append_, and _reset_ its components
      however you like:
      #+begin_src python
        import sys

        sys.path
        # ['', 'c:\\temp', 'C:\\Windows\\system32\\python33.zip', ...]

        sys.path.append('C:\\sourcedir')
        # ['', 'c:\\temp', 'C:\\Windows\\system32\\python33.zip', ..., 'C:\\sourcedir']
      #+end_src

    - Once you've made such a change, it will impact all *future imports* anywhere
      while a Python program runs, as all importers share the same single
      ~sys.path~ list (there's *only one copy* of a given /module/ in memory
      during a program’s run—that’s why ~reload~ exists). In fact, this list may
      be changed arbitrarily.
      * Change the ~sys.path~ can make Python not work -- if the ~sys.path~ includes
        wrong paths, even the simple ~import string~ may not work.
        + =from Jian=
          This is right to source file and the official Python REPL.
          However, this is _NOT_ right to tools like IPython.
          - For example,
            simply empty the ~sys.path~ list can make ~import string~ throw
            ~ModuleNotFoundError~ exception in Python REPL, but no error in
            IPython.

    - Compare the way of configure /module search path/:
      * ~sys.path~ is
        + flexible (can easily be edited at run time),
        + process only, and
        + NOT persistent -- it lives in a running Python program (process)

      * ~PYTHONPATH~ and ~.pth~ file path configurations are
        + persistent -- they live in the OS
        + more global:
          they are picked up by every program on your machine and live on after
          a program completes.
          - On some systems,
            * the former can be _per-user_
            * the latter can be _installation-wide_.

    - Print out what are in the ~PYTHONPATH~:
      #+begin_src python
        import os


        try:
            user_paths = os.environ['PYTHONPATH'].split(os.pathsep)
        except KeyError:
            user_paths = []
      #+end_src

*** DONE The ~as~ Extension for ~import~ and ~from~ - 758
    CLOSED: [2021-04-06 Tue 02:08]
    - ~import modulename as name~
      is equivalent to
      #+begin_src python
        import modulename
        name = modulename
        del modulename  # Don't keep original name
      #+end_src

    - This technique is commonly used
      * to *provide short synonyms* for _longer names_, and
        #+begin_src python
          import dir1.dir2.mod as mod
          # from Jian: same as `from dir1.dir2.mod import mod`
        #+end_src

      * to *avoid name clashes*
        #+begin_src python
          import dir1.dir2.mod as mod_dir12
          import dir1.dir3.mod as mod_dir13

          from dir1.dir2.mod import func as mod_func
        #+end_src

    - =IMPORTANT=
      This is also something of a hedge against _name changes_.
      You can use it to smooth migration when there are _name changes_ in the new
      release.

*** TODO Example: Modules Are Objects - 759
*** TODO Importing Modules by Name String - 761
**** Running Code Strings - 762
**** Direct Calls: Two Options - 762

*** TODO Example: Transitive Module Reloads - 763
**** A Recursive Reloader - 764
**** Alternative Codings - 767

*** TODO Module Gotchas - 770
**** DONE Module Name Clashes: Package and Package-Relative Imports - 771
     CLOSED: [2021-04-06 Tue 03:22]
     =from Jian= Good to avoid this, rather than try to resolve!

     - By default, if two in-search-path modules have the same name, the one in
       the leftmost path in ~sys.path~ will be imported.
       * Mostly this is not a issue, because mostly you want a module in your
         top-level script's directory, which is *always the first* in the
         /module search path/.
         
     - =IMPORTANT=
       Use a module name that can be found in the standard library as the name of
       your module is always a *DISASTER*. It can shadow that /module/ in the
       standard library.
       * =from Jian=
         I accidentally have a =time.py= in my working directory, and I see an
         error when run a script, which includes ~time~ importing and usages,
         also in that directory. I was trying to import the ~time~ in stanard
         library, and use a function defined in it. The error message said that
         function can be found. Of course, luckily, =time.py= in my working
         directory doesn't have a function of that name, and fail fast helped me
         finding this debug.

     - Sometimes, package-relative can help.

**** DONE Statement Order Matters in Top-Level Code - 771
     CLOSED: [2021-04-06 Tue 03:52]
     =from Jian= Common sense

**** DONE from Copies Names but Doesn’t Link - 772
     CLOSED: [2021-04-06 Tue 03:59]
     Although it's commonly used, *the ~from~ statement is the source of a variety
     of _potential gotchas_ in Python.*

     - As we've learned,
       the ~from~ statement is really an _assignment_ to names in the /importer's
       scope/ -- _a name-copy operation, *not* a name aliasing._

       * Example:
         #+NAME: nested1.py
         #+begin_src python
           x = 99

           def printer():
               print(x)
         #+end_src

         + Use ~from~:
           #+NAME: nested2.py
           #+begin_src python
             from nested1 import x, printer

             x = 88
             printer()
           #+end_src
           Run this =nested2.py= and get output =99=.

         + Without ~from~:
           #+NAME: nested3.py
           #+begin_src python
             import nested1

             nested1.x = 88
             printer()
           #+end_src
           Run this =nested3.py= and get output =88=.

**** ~from *~ Can Obscure the Meaning of Variables - 773
**** ~reload~ May Not Impact from Imports - 773
**** ~reload~, ~from~, and Interactive Testing - 774
**** Recursive from Imports May Not Work - 775

*** Chapter Summary - 776
*** Test Your Knowledge: Quiz - 777
*** Test Your Knowledge: Answers - 777
*** Test Your Knowledge: Part V Exercises - 778

* TODO Part VI. Classes and OOP - 797
** DONE 26. OOP: The Big Picture - 783
   CLOSED: [2021-04-06 Tue 01:02]
   =from Jian=
   No need to read the 2nd time. Refresh with the following note is enough.

*** DONE Why Use Classes? - 784
    CLOSED: [2021-04-05 Mon 16:31]
    - Two aspects of OOP prove useful here:
      * Inheritance
      * Composition

    - Compared to other program units (/functions/ and /modules/) we've already
      seen, /Classes/ have _THREE critical distinctions_ that make them more
      useful when it comes to building new objects:
      * Multiple instances
      * Customization via inheritance and overwriting
      * Operator overloading

*** DONE OOP from 30,000 Feet - 785
    CLOSED: [2021-04-06 Tue 00:48]
**** DONE Attribute Inheritance Search - 785
     CLOSED: [2021-04-06 Tue 00:01]
     - Find the first occurrence of ~attribute~ by looking
       1. in current object,
       2. then in all /classes/ above it in the inheritance hierarchies,
          * from *bottom to top* and *left to right*.

     - In other words, _attribute fetches_ are simply _tree searches_.

**** DONE Classes and Instances - 788
     CLOSED: [2021-04-06 Tue 00:10]
     - The primary difference between classes and instances is that classes are a
       kind of factory for generating instances.

     - /classes/, /class instances/, and /modules/ are all /namespaces/, but the
       /namespace/ of one /class/ or /class instance/ automatically links to its
       /superclasses/.

     - Each /module/ can only have one /instance/, but a /class/ can have as many
       /instances/ as we need.

**** DONE Method Calls - 788
     CLOSED: [2021-04-06 Tue 00:14]
     A call to a /method/ ~certainInstance.mth(...)~ will always be mapped to
     ~classOfThisInstance.mth(certainInstance, ...)~.

**** DONE Coding Class Trees - 789
     CLOSED: [2021-04-06 Tue 00:36]
**** DONE Operator Overloading - 791
     CLOSED: [2021-04-06 Tue 00:38]
     - Before here, this chapter didn't discuss how to initialize the values of
       attributes. Always manually do it is not applicable in practice.
       * Mostly, use the optional /constructor/ ~__init__~, which will be called
         automatically when you create an /instance/ of a /class/.

**** DONE OOP Is About Code Reuse - 792
     CLOSED: [2021-04-06 Tue 00:48]
***** DONE Polymorphism and classes - 792
      CLOSED: [2021-04-06 Tue 00:46]
      =from Jian=
      Here is talking about the /subtyping polymorphism/ -- the only /polymorphism/
      supported by Python.

***** DONE Programming by customization - 794
      CLOSED: [2021-04-06 Tue 00:48]

*** DONE Chapter Summary - 795
    CLOSED: [2021-04-06 Tue 00:59]
*** DONE Test Your Knowledge: Quiz - 795
    CLOSED: [2021-04-06 Tue 00:59]
    1. Q :: What is the main point of OOP in Python?
       A :: Code reuse.

    2. Q :: Where does an inheritance search look for an attribute?
       A :: current instance, and then superclasses.
            Bottom up, and left to right.

    3. Q :: What is the difference between a class object and an instance object?
       A ::
       * /Classes/ serve as _instance factories_, and they are abstract.
         =from Jian= They include all computation logic, and data that _SHARED_
         by /instances/.

       * /Instances/ represent the CONCRETE items in a program's domain.
         =from Jian= It also include all the per instance specific data.

    4. Q :: Why is the first argument in a class’s method function special?
       A :: It is passed in automatically, and it represents the /instance/, from
            which it is called.

    5. Q :: What is the ~__init__~ method used for?
       A :: Attributes values automatic initializer.

    6. Q :: How do you create a class instance?
       A :: ~a_instance = ClassName()~

    7. Q :: How do you create a class?
       A :: ~class ClassName(superclasses): ...~

    8. Q :: How do you specify a class’s superclasses?
       A :: ~class ClassName(superclass0, superclass1, ...): ...~

*** DONE Test Your Knowledge: Answers - 795
    CLOSED: [2021-04-06 Tue 01:01]

** TODO 27. Class Coding Basics - 797
*** Classes Generate Multiple Instance Objects - 797
**** Class Objects Provide Default Behavior - 798
**** Instance Objects Are Concrete Items - 798
**** A First Example - 799

*** Classes Are Customized by Inheritance - 801
**** A Second Example - 802
**** Classes Are Attributes in Modules - 804

*** Classes Can Intercept Python Operators - 805
**** A Third Example - 806
**** Why Use Operator Overloading? - 808

*** The World’s Simplest Python Class - 809
**** Records Revisited: Classes Versus Dictionaries - 812

*** Chapter Summary - 814
*** Test Your Knowledge: Quiz - 815
*** Test Your Knowledge: Answers - 815

** TODO 28. A More Realistic Example - 817
*** Step 1: Making Instances - 818
**** Coding Constructors - 818
**** Testing As You Go - 819
**** Using Code Two Ways - 820

*** Step 2: Adding Behavior Methods - 822
**** Coding Methods - 824

*** Step 3: Operator Overloading - 826
**** Providing Print Displays - 826

*** Step 4: Customizing Behavior by Subclassing - 828
**** Coding Subclasses - 828
**** Augmenting Methods: The Bad Way - 829
**** Augmenting Methods: The Good Way - 829
**** Polymorphism in Action - 832
**** Inherit, Customize, and Extend - 833
**** OOP: The Big Idea - 833

*** Step 5: Customizing Constructors, Too - 834
**** OOP Is Simpler Than You May Think - 836
**** Other Ways to Combine Classes - 836

*** Step 6: Using Introspection Tools - 840
**** Special Class Attributes - 840
**** A Generic Display Tool - 842
**** Instance Versus Class Attributes - 843
**** Name Considerations in Tool Classes - 844
**** Our Classes’ Final Form - 845

*** Step 7 (Final): Storing Objects in a Database - 847
**** Pickles and Shelves - 847
**** Storing Objects on a Shelve Database - 848
**** Exploring Shelves Interactively - 849
**** Updating Objects on a Shelve - 851

*** Future Directions - 853
*** Chapter Summary - 855
*** Test Your Knowledge: Quiz - 855
*** Test Your Knowledge: Answers - 856

** TODO 29. Class Coding Details - 859
*** The class Statement - 859
**** General Form - 860
**** Example - 860

*** Methods - 862
**** Method Example - 863
**** Calling Superclass Constructors - 864
**** Other Method Call Possibilities - 864

*** Inheritance - 865
**** Attribute Tree Construction - 865
**** Specializing Inherited Methods - 866
**** Class Interface Techniques - 867
**** Abstract Superclasses - 869

*** Namespaces: The Conclusion - 872
**** Simple Names: Global Unless Assigned - 872
**** Attribute Names: Object Namespaces - 872
**** The “Zen” of Namespaces: Assignments Classify Names - 873
**** Nested Classes: The LEGB Scopes Rule Revisited - 875
**** Namespace Dictionaries: Review - 878
**** Namespace Links: A Tree Climber - 880

*** Documentation Strings Revisited - 882
*** Classes Versus Modules - 884
*** Chapter Summary - 884
*** Test Your Knowledge: Quiz - 884
*** Test Your Knowledge: Answers - 885

** DONE 30. Operator Overloading - 887 - =RE-READ=
   CLOSED: [2021-04-05 Mon 02:48]
*** DONE The Basics - 887
    CLOSED: [2021-03-16 Tue 14:02]
**** DONE Constructors and Expressions: ~__init__~ and ~__sub__~ - 888
     CLOSED: [2021-03-16 Tue 13:11]
     - *TIPS*:
       Technically,
       /instance creation/ *first triggers* the ~__new__~ /method/, which
       *creates and returns* the /new instance object/, which is then passed
       into ~__init__~ for _initialization_.
         Since ~__new__~ has a _built-in implementation_ and is redefined in
       *only* very limited roles, though, nearly all _Python classes initialize_
       by defining an ~__init__~ method.
       * We'll see one use case for ~__new__~ when we study /metaclasses/ in
         Chapter 40;
         though rare, it is sometimes also used to *customize creation* of
         /instances of mutable types/.

**** DONE Common Operator Overloading Methods - 888
     CLOSED: [2021-03-16 Tue 14:02]
     - See _the Python language reference manual_,
       for an _exhaustive list_ of the special /method/ names available.

     - Table 30-1. Common operator overloading methods

     - ALL /overloading methods/ have names that *start and end with two
       underscores*.
       * Q :: How to read? =from Jian=
       * A :: For example, read ~__init__~ as _dunder (double-underscore) init_.
       
     - *TIPS*:
       In fact, calling the /operator method/ directly *might be twice as slow,*
       presumably because of the /overhead/ of a _function call_, which Python
       *avoids* or *optimizes* in built-in cases.
       
       * Here's the story for ~len~ and ~__len__~ using Appendix B's Windows
         launcher and Chapter 21's timing techniques on Python 3 (similar in
         Python 2):
         #+begin_src shell
           python -m timeit -n 1000 -r 5 -s "L = list(range(100))" "x = L.__len__()"
           # 1000 loops, best of 5: 0.134 usec per loop

           python -m timeit -n 1000 -r 5 -s "L = list(range(100))" "x = len(L)"
           # 1000 loops, best of 5: 0.063 usec per loop
         #+end_src

*** DONE Indexing and Slicing: ~__getitem__~ and ~__setitem__~ - 890
    CLOSED: [2021-03-17 Wed 04:49]
    Example:
    #+begin_src python
      class Indexer:
          def __getitem__(self, index):
              return index ** 2

      X = Indexer()
      X[2]  # X[i] calls X.__getitem__(i)
      # 4
    #+end_src
    
**** DONE Intercepting Slices - 891
     CLOSED: [2021-03-17 Wed 04:40]
     The ~__getitem__~ can be used to extract /slices/.

     - To make it work with ~slice~, the operation in the ~__getitem__~ body
       should be legal for ~slice~'s. Because of this the previous example
       ~Indexer~ implementation doesn't work with ~slice~'s -- ~slice~ doesn't
       support the ~**~ operation.

     - Write a different ~Indexer~, whose ~__getitem__~ body only contains a
       legal ~slice~ operation:
       #+begin_src python
         class Indexer:
             data = [5, 6, 7, 8, 9]

             def __getitem__(self, index):
                 print('getitem: ', index)
                 return self.data[index]

         X = Indexer()

         X[0]
         # getitem: 0
         5

         X[1]
         # getitem: 1
         6

         X[-1]
         # getitem: -1
         9

         X[2:4]
         # getitem: slice(2, 4, None)
         [7, 8]

         X[1:]
         # getitem: slice(1, None, None)
         [6, 7, 8, 9]

         X[:-1]
         # getitem: slice(None, −1, None)
         [5, 6, 7, 8]

         X[::2]
         # getitem: slice(None, None, 2)
         [5, 7, 9]
       #+end_src

     - If used, the ~__setitem__~ index assignment method _SIMILARLY_ intercepts
       BOTH _index and slice assignments_.

     - In fact, ~__getitem__~ may be called AUTOMATICALLY in even _MORE contexts_
       than /indexing/ and /slicing/ -- it's also an *iteration fallback* option,
       as we'll see in a moment. =TODO=
     
**** DONE Slicing and Indexing in Python 2.X - 893
     CLOSED: [2021-03-17 Wed 04:40]
     For /two-limit slices/, ~__getslice__~ and ~setslice__~ have a higher
     priority in Python 2.X. Avoid using them, and use ~__getitem__~ and
     ~setitem__~ handle /index/, /two-limit slices/, and /three-limit slices/ in
     the *same* way can make the code concise, and be compatible to the future.
     
**** DONE But 3.X's ~__index__~ Is Not Indexing! - 894
     CLOSED: [2021-03-17 Wed 04:49]
     ~__index__~ is a bad name. Since it is not used for /indexing/, ~_as_index_~ 
     can be a better name!

     - ~__index__~ is used when a integer value is required:
       #+begin_src python
         class C:
             def __index__(self):
                 return 255

         x = C()
         hex(x)  # '0xff'
         bin(x)  # '0b11111111'
         oct(x)  # '0o377'

         ('C' * 256)[255]  # 'C'
         ('C' * 256)[X]    # 'C'  ## As index (not x[i])
         ('C' * 256)[X:]   # 'C'  ## As index (not x[i])
       #+end_src
       
     - This /method/ works the _SAME way_ in Python 2.X,
       *except* that it is *not* called for the ~hex~ and ~oct~ /built-in
       functions/; use ~__hex__~ and ~__oct__~ in 2.X (only) instead to
       intercept these calls.

*** DONE Index Iteration: ~__getitem__~ - 894
    CLOSED: [2021-03-17 Wed 05:00]
    In the *absence* of _MORE-SPECIFIC_ /iteration methods/ (we'll get to in the
    next section), the iteration operations works by *repeatedly indexing* a
    sequence _from zero to higher indexes_, until an out-of-bounds ~IndexError~
    exception is detected.

    - Implement ~__getitem__~ is like a case of "code one, get a bunch free":
      you implement it for indexing and slicing operations, and you also get
      _all /iteration contexts/(presented in Chapter 14) =TODO= in Python_.
      For example:
      * membership test
      * list comprehensions
      * ~map~ built-in
      * /list/ and /tuple/ assignments
      * /type constructors/ will also call ~__getitem__~ automatically,
        if it's defined:
        #+begin_src python
          class StepperIndex:
              def __getitem__(self, i):
                  return self.data[i]

          x = StepperIndex()
          x.data = "Spam"

          list(x)     # ['S', 'p', 'a', 'm']
          tuple(x)    # ('S', 'p', 'a', 'm')
          ''.join(x)  # 'Spam'
        #+end_src

      - In practice, this technique can be used to create objects that PROVIDE a
        /sequence interface/ and to add logic to built-in sequence type operations;
        =TODO= =NEXT= we’ll REVISIT this idea when extending built-in types in
        Chapter 32.
    
*** DONE Iterable Objects: ~__iter__~ and ~__next__~ - 895
    CLOSED: [2021-03-18 Thu 01:54]
    All /iteration contexts/ in Python will try the ~__iter__~ method first,
    before trying ~__getitem__~.

    - ~__iter__~ supports general /iteration contexts/ better than ~__getitem__~
      can.
      =from Jian= Not details. Need details and illustration examples.

    - Technically, /iteration contexts/ work by passing an /iterable object/ to
      _the ~iter~ built-in function_ to invoke an ~__iter__~ method, which is
      expected to RETURN an /iterator object/.
      * If it's provided, Python then repeatedly calls this /iterator object/'s 
        ~__next__~ method to produce items until a ~StopIteration~ exception is
        raised.
        + A ~next~ built-in function exist. ~next(I)~ is the same as
          ~I.__next__()~.
    
    - *TIPs*
      Python 2.X uses the method name ~next~ instead of ~__next__~.
      All the other things works the same.
      
**** DONE User-Defined Iterables - 896
     CLOSED: [2021-03-18 Thu 00:24]
     - Example:
       #+begin_src python
         class Squares:
             def __init__(self, start, stop):
                 self.value = start - 1
                 self.stop = stop

             def __iter__(self):
                 return self

             def __next__(self):
                 if self.value == self.stop:
                     raise StopIteration
                 self.value += 1
                 return self.value ** 2
       #+end_src
       Here, the /iterator object/ returned by ~__iter__~ is simply the instance
       ~self~, because the ~__next__~ method is part of this class itself.
         In more complex scenarios, the /iterator object/ may be defined as a
       *separate* class and object with its own state information to support
       _multiple active iterations_ over the same data (we'll see an example of
       this in a moment =TODO=).

     - =TODO=
       An equivalent coding of this iterable with ~__getitem__~ might be less
       natural, because the for would then iterate through all offsets zero and
       higher; the offsets passed in would be only indirectly related to the
       range of values produced (0..N would need to map to start..stop). Because
       ~__iter__~ objects retain explicitly managed state between next calls,
       they can be more general than ~__getitem__~.
       
***** Single versus multiple scans - 897
      - The ~Squres~ is a single scan iterator.
        #+begin_src python
          x = Squares(1, 5)
          [n for n in x]  # [1, 4, 9, 16, 25]
          [n for n in x]  # []
        #+end_src
      
      - =TODO=
        To support /multiple iterations/ more directly, we could also recode this
        example with an *extra* /class/ or other technique, as we will in a moment.
        =TOOD= =NEXT=
      
***** Classes versus generators - 898
      Use /generator/ for simple use cases, while use /class/ for richer use
      cases (multiple scans iterators, complex iterators, or when not only
      /iterator interface/ is enough).
      
**** DONE Multiple Iterators on One Object - 899
     CLOSED: [2021-03-18 Thu 01:10]
     Example:
     #+begin_src python
       class SkipObject:
           def __init__(self, wrapped):
               self.wrapped = wrapped

           def __iter__(self):
               return SkipIterator(self.wrapped)


       class SkipIterator:
           def __init__(self, wrapped):
               self.wrapped = wrapped
               self.offset = 0

           def __next__(self):
               if self.offset >= len(self.wrapped):
                   raise StopIteration
               else:
                   item = self.wrapped[self.offset]
                   self.offset += 2
                   return item

       if __name__ == '__main__':
           alpha = 'abcdef'
           skipper = SkipObject(alpha)
           I = iter(skipper)
           print(next(I), next(I), next(I))  # 0, 2, 4

           for x in skipper:
               for y in skipper:
                   print(x + y, end=' ')
     #+end_src
     
***** Classes versus slices - 901
      Compare the _class implementation_ and the /slice/ way:
      - /slices/ are Not lazy

      - /slices/ produce _NEW objects_, so we're not really iterating over the
        same object in multiple places, while all ~SkipIterator~ instances from
        one ~SkipObject~ instance share the same object (the ~wrapped~ passed to
        their ~__init__~).

      - _class implementations_ always have the potential to satisfy richer
        behaviors.
     
**** DONE Coding Alternative: ~__iter__~ plus ~yield~ - 902
     CLOSED: [2021-03-18 Thu 01:54]
     - Example:
       #+begin_src python
         def gen(x):
             for i in range(x):
                 yield i ** 2

         g = gen(5)
         g.__iter__() = g  # True
         I = iter(G)
         next(I), next(I)  # (0, 1)
       #+end_src
       When a /generator function/ is called, it returns a _NEW_ /generator object/
       with
       * automatic retention of local scope and code position,

       * an automatically created ~__iter__~ method
         that simply returns itself, and

       * an automatically created ~__next__~ method (~next~ in 2.X)
         that starts the function or resumes it where it last left off.
       
     - Example:
       #+begin_src python
         class Squares:
             def __init__(self, start, stop):
                 self.start = start
                 self.stop = stop

             def __iter__(self):
                 for value in range(self.start, self.stop + 1):
                     yield value ** 2
       #+end_src
       * This one is more concise

       * A bonus:
         it support _multiple iterations_ without defining a *separate* /iterator
         class/.

       * Of course, you can use other names instead of ~__iter__~.
         The only difference is you should no longer expect implicit calls to
         ~__iter__~ in /iteration contexts/, and can't apply the ~iter~ built-in.
     
***** Multiple iterators with ~yield~
      - If we don't use the ~yield~, we define a _multiple iterations_ ~Squares~
        like:
        #+begin_src python
          class Squares:
              def __init__(self, start, stop):
                  self.start = start
                  self.stop = stop

              def __iter__(self):
                  return SquaresIter(self.start, self.stop)


          class SquaresIter:
              def __init__(self, start, stop):
                  self.value = start - 1
                  self.stop = stop

              def __next__(self):
                  if self.value == self.stop:
                      raise StopIteration
                  self.value += 1
                  return self.value ** 2
        #+end_src

      - Implement the ~SkipObject~ with ~yield~, and no ~SkipIterator~ required:
        #+begin_src python
          class SkipObject:
              def __init__(self, wrapped):
                  self.wrapped = wrapped

              def __iter__(self):
                  offset = 0
                  while offset < len(self.wrapped):
                      item = self.wrapped[offset]
                      offset += 2
                      yield item
        #+end_src
        
*** DONE Membership: ~__contains__~, ~__iter__~, and ~__getitem__~ - 906
    CLOSED: [2021-03-21 Sun 04:54]
    - In the iterations domain, classes can implement the ~in~ /membership operator/
      as an iteration, using either the ~__iter__~ or ~__getitem__~ methods.
        To support more SPECIFIC membership, though, classes may code a
      ~__contains__~ method.
      
    - ~__iter__~ is preferred over ~__getitem__~.

    - =from Jian=
      I don't like the first example code, which create an iterable/iterator class
      that can have multiple scan, but only a new scan can't have overlap with a
      old scan -- this is too tricky, and not every code. This is why I don't want
      to paste the code here.
      
    - The second example code is a /multiple scan iterable/, whose ~__iter__~
      /method/ is implemented in ~yield~. This one doesn't have the tricky
      limitation in the last example code, and it all the others are the same.
      #+begin_src python
        class Iters:
            def __init__(self, value):
                self.data = value

            def __getitem__(self, i):          # Fallback for iteration
                print('get[%s]:' % i, end='')  # Also for index, slice
                return self.data[i]

            def __iter__(self):                # Preferred for iteration
                print('iter=> next:', end='')  # Allows multiple active iterators
                for x in self.data:            # no __next__ to alias to next
                    yield x
                    print('next:', end='')

            def __contains__(self, x):         # Preferred for 'in'
                print('contains: ', end='')
                return x in self.data


        if __name__ == '__main__':
            X = Iters([1, 2, 3, 4, 5])  # Make instance
            print(3 in X) # Membership
            for i in X: # for loops
                print(i, end=' | ')

            print()
            print([i ** 2 for i in X])  # Other iteration contexts
            print( list(map(bin, X)) )

            I = iter(X)  # Manual iteration (what other contexts do)
            while True:
                try:
                    print(next(I), end=' @ ')
                except StopIteration:
                    break
      #+end_src
      1. Current output:
         #+begin_src text
           contains: True
           iter=> next:1 | next:2 | next:3 | next:4 | next:5 | next:
           iter=> next:next:next:next:next:next:[1, 4, 9, 16, 25]
           iter=> next:next:next:next:next:next:['0b1', '0b10', '0b11', '0b100', '0b101']
           iter=> next:1 @ next:2 @ next:3 @ next:4 @ next:5 @ next:
         #+end_src

      2. After removing ~__contains__~:
         #+begin_src text
           iter=> next:next:next:True
           iter=> next:1 | next:2 | next:3 | next:4 | next:5 | next:
           iter=> next:next:next:next:next:next:[1, 4, 9, 16, 25]
           iter=> next:next:next:next:next:next:['0b1', '0b10', '0b11', '0b100', '0b101']
           iter=> next:1 @ next:2 @ next:3 @ next:4 @ next:5 @ next:
         #+end_src
         
      3. After removing both ~__contains__~ and ~__iter__~:
         #+begin_src text
           get[0]:get[1]:get[2]:True
           get[0]:1 | get[1]:2 | get[2]:3 | get[3]:4 | get[4]:5 | get[5]:
           get[0]:get[1]:get[2]:get[3]:get[4]:get[5]:[1, 4, 9, 16, 25]
           get[0]:get[1]:get[2]:get[3]:get[4]:get[5]:['0b1', '0b10', '0b11', '0b100','0b101']
           get[0]:1 @ get[1]:2 @ get[2]:3 @ get[3]:4 @ get[4]:5 @ get[5]:
         #+end_src

    - In more realistic iteration use cases that are *not* _sequence-oriented_,
      though, the ~__iter__~ method may be _easier to write_ since it *must not*
      manage an integer index, and ~__contains__~ allows for _membership
      optimization_ as a special case.
         
*** DONE Attribute Access: ~__getattr__~ and ~__setattr__~ - 909
    CLOSED: [2021-04-05 Mon 02:36]
    In Python, /classes/ can also *intercept* basic _attribute access_ (a.k.a.
    qualification) when needed or useful.

**** DONE Attribute Reference - 909
     CLOSED: [2021-03-21 Sun 05:28]
     The ~__getattr__~ /method/ intercepts _attribute references_,
     but *only* when the the given name /attribute/ *doesn't exist*.
     
     - Because of its behavior, ~__getattr__~ is useful as a hook for responding
       to _attribute requests_ IN A GENERIC FASHION.
         It's commonly used to /delegate calls/ to embedded (or “wrapped”) objects
       from a /proxy controller object/ --
       =TODO= =READ= of the sort introduced in Chapter 28's introduction to
       delegation.

     - Example:
       #+begin_src python
         class Empty:
             def __getattr__(self, attribute_name):
                 if attribute_name == 'age':
                     return 40
                 else:
                     raise AttributeError(attribute_name)
       #+end_src
     
**** DONE Attribute Assignment and Deletion - 910
     CLOSED: [2021-03-24 Wed 19:00]
     In the same department, the ~__setattr__~ *intercepts all* _attribute
     assignments_.

     - If ~__setattr__~ is *defined* or *inherited*, ~self.attr = value~ becomes
       ~self.__setattr__('attr', value)~. Like ~__getattr__~, this allows your
       class to *catch* attribute changes, and *validate* or *transform* as
       desired.

     - =IMPORTANT= =!!!= =IMPORTANT=
       The ~__setattr__~ can be tricky!
       Since it intercepts ALL _attribute assignments_, *infinite recursion loop*
       can easily be triggered.
       * Use ~self.__dict__['attr_name'] = x~ instead of ~self.name = x~.
         Example:
         #+begin_src python
           class AccessControl:
               def __setattr__(self, attr, value):
                   if attr == 'age':
                       self.__dict__[attr] = value + 10
                   else:
                       raise AttributeError(f"{attr} not allowed")

           X = AccessControl()
           X.age = 40
           X.age  # 50

           X.name = 'Bob'
           # ...text omitted...
           # AttributeError: name not allowed
         #+end_src
         + Wrong implementations:
           If the line ~self.__dict__[attr] = value + 10~ is replaced by the
           following two implementation, *infinite recursion loop and exception
           will be triggered* when the assignment to ~age~ happen outside (e.g.
           ~X.age = 40~):
           #+begin_src python
             self.age = value + 10            # Loops
             setattr(self, attr, value + 10)  # Loops (attr is 'age')
           #+end_src
           
         + Right implementations:
           #+begin_src python
             self.__dict__[attr] = value + 10            # Loops
             object.__setattr__(self, attr, value + 10)  # Loops (attr is 'age')
           #+end_src
           Because the ~object~ form requires use of /new-style classes/ in 2.X,
           though, =TODO= =NEXT= we'll _POSTPONE_ details on this form until
           Chapter 38's deeper look at _attribute management_ at large.
     
     - A third attribute management method, ~__delattr__~, is passed the _attribute
       name string_ and invoked on *ALL* _attribute deletions_ (i.e.,
       ~del object.attr~).
       * Like ~__setattr__~, it *must avoid recursive loops* by *routing*
         _attribute deletions_ with the using class through ~__dict__~ or a
         /superclass/.

     - *TIPs*:
       As we'll learn in Chapter 32, /attributes/ implemented with /new-style class/
       features such as
       */slots/ and /properties/ are not physically stored in the instance's
       ~__dict__~ (and /slots/ may even preclude its existence entirely!).*
       * Because of this, code that wishes to support such attributes
         _SHOULD_ code ~__setattr__~ to assign with the ~object.__setattr__~
         scheme shown here,
         _NOT_ by ~self.__dict__~ indexing UNLESS it's known that subject classes
         store all their data in the instance itself.

       * =TODO=
         In Chapter 38 we'll also see that the new-style ~__getattribute__~ has
         *similar requirements.* This change is *mandated* in Python 3.X, but also
         applies to 2.X if /new-style classes/ are used.
       
**** DONE Other Attribute Management Tools - 912
     CLOSED: [2021-03-24 Wed 19:22]
     - For another example of ~__getattr__~ at work,
       =TODO= see Chapter 28's =person-composite.py=.

     - For _future reference_,
       keep in mind that there are other ways to _manage attribute_ access in
       Python:
       * ~__getattribute__~
         A method that intercepts *ALL*

       * ~property~

       * /Descriptors provide a protocol for associating ~__get__~ and ~__set__~ 
         /methods/ of a /class/ with accesses to _one SPECIFIC attribute_.
       

     - =TODO= =NEXT=
       Details about these three ways are in
       * Chapter 32 - /properties/
       * Chapter 38 - detailed coverage of *all* the _attribute management_
         techniques
       
**** DONE Emulating Privacy for Instance Attributes: Part 1 - 912
     CLOSED: [2021-04-05 Mon 02:35]
     #+name: private0.py
     #+begin_src python
       class PrivateExc(Exception):
           pass


       class Privacy(abc.ABC):
           @property
           def privates(self):
               raise NotImplemented

           def __setattr__(self, attrname, value):
               if attrname in self.privates:
                   raise PrivateExc(attrname, self)
               else:
                   self.__dict__[attrname] = value


       class Test1(Privacy):
           __privates = ['age']

           @property
           def privates(self):
               return type(self).__privates


       class Test2(Privacy):
           __privates = ['name', 'pay']

           @property
           def privates(self):
               return type(self).__privates

           def __init__(self):
               self.__dict__['name'] = 'Tom'  # TODO: To do better, see Chapter 39!


       def __name__ == '__main__':
           x = Test1()
           y = Test2()

           x.name = 'Bob'    # Works
           # y.name = 'Sue'  # Fails

           x.age = 30    # Works
           # x.age = 40  # Fails
     #+end_src
     - This is a first-cut solution for an implementation of /attribute privacy/
       in Python.

     - This is a *PARTIAL* -- and even *CLUMSY—solution*, though;
       _to make it MORE EFFECTIVE,_
       we must augment it to allow /classes/ to set their /private attributes/
       more naturally, WITHOUT having to go through ~__dict__~ each time, as the
       /constructor/ must do here to avoid triggering ~__setattr__~ and an
       exception.

       =TODO= =TODO= =TODO= =TODO= =TODO= =TODO= =TODO= =TODO=
       * A better and more complete approach might require
         + a /wrapper (“proxy”) class/ to *check* for _private attribute accesses_
           _made OUTSIDE the /class/ only_, and
         + a ~__getattr__~ to *validate* _attribute fetches_ too.

     - =TODO=
       *We'll POSTPONE a more complete solution to attribute privacy until Chapter 39,*
       where we'll use /class decorators/ to *intercept* and *validate* /attributes/
       more generally.
       * Even though privacy can be emulated this way, though,
         *it almost _NEVER_ is in practice.* 

     - Still, catching attribute references and assignments is generally a useful technique; it
       supports delegation, a design technique that allows controller objects to wrap up embedded
       objects, add new behaviors, and route other operations back to the wrapped
       objects. Because they involve design topics, we’ll revisit delegation and wrapper classes
       in the next chapter.

*** DONE String Representation: ~__repr__~ and ~__str__~ - 913
    CLOSED: [2020-11-04 Wed 02:00]
    As we've learned, the _DEFAULT display_ of /instance objects/ for a /class/
    like this is _NEITHER generally useful_ _NOR aesthetically pretty_:

**** DONE Why Two Display Methods? - 914
     CLOSED: [2020-11-04 Wed 01:37]
     - Python provides _TWO_ /display methods/ to support alternative displays *for
       DIFFERENT audiences*:
       1. ~__str__~
          + The *first choice* of (~__repr__~ is the fallback)
            * the ~print~ function
            * the built-in ~str~ function (the internal equivalent of which ~print~ runs)

          + It generally should return a *user-friendly display*.

       2. ~__repr__~
          + *Be used in ALL OTHER contexts*:
            * for interactive echoes,
            * the built-in ~repr~ function,
            * nested appearances,
            * by ~print~ and ~str~ *if NO* ~__str__~ is present.

          + It should generally return an *as-code string* that
            * could be used to *re-create the object*,
              OR
            * a *detailed display for developers*.
     
     - ~__repr__~ is the fallback of ~__str__~,
       and the INVERSE is *NOT* true.

     - That is, ~__repr__~ is used *EVERYWHERE*,
       *EXCEPT* by ~print~ and ~str~ when a ~__str__~ is defined.

     - _If you code either, the other is available for an additional display_:
       + As noted in Chapter 28, 
         (In practice) general tools may also *prefer* ~__str__~ to leave other
         /classes/ the option of adding an alternative ~__repr__~ display for use in
         other contexts, as long as ~print~ and ~str~ displays suffice for the tool.
       
       + Conversely, a general tool that codes a ~__repr__~ still leaves clients the
         option of adding alternative displays with a ~__str__~ for ~print~ and ~str~.

     - Because of this, ~__repr__~ may be best if you want a single display for
       all contexts. 
       
     - Example:
       #+begin_src python
         class addboth(adder):
             def __str__(self):  # User-friendly string
                 return f"[Value: {self.data}]"

             def __repr__(self):  # As-code string
                 return f"addboth({self.data})"


         x = addboth(4)
         x + 1

         x
         # addboth(5)

         print(x)
         # [Value: 5]

         str(x), repr(x)
         # ('[Value: 5]', 'addboth(5)')
       #+end_src
     
**** DONE Display Usage Notes - 916
     CLOSED: [2020-11-04 Wed 01:59]
     - Though generally simple to use, there are
       _THREE usage notes_ regarding these methods here:

       1. ~__str__~ and ~__repr__~ *must* both return /strings/;
          other result types are not converted and raise errors,
          + so be sure to run them through a _to-string converter_
            if the the initial value you construct is not a string.

       2. Depending on a container's string-conversion logic,
          #+begin_src python
            class Printer:
                def __init__(self, val):
                    self.val = val

                def __str__(self):
                    return str(self.val)

            objs = [Printer(2), Printer(3)]
            for x in objs:
                print(x)
            # 2
            # 3

            print(objs)
            # [<__main__.Printer object at 0x000000000297AB38>, <__main__.Printer obj...etc...>]

            objs
            # [<__main__.Printer object at 0x000000000297AB38>, <__main__.Printer obj...etc...>]
          #+end_src
          + the ~__str__~ might ONLY apply
            when /objects/ appear *at the top level* of a print operation;

          + _objects nested in larger objects_ might still print with their ~__repr__~
            or its default. The following illustrates both of these points:

          + To ensure that a custom display is run in all contexts regardless of the
            container, code ~__repr__~, *not* ~__str__~:
            #+begin_src python
              class Printer:
                  def __init__(self, val):
                      self.val = val

                  def __repr__(self):       # `__repr__` used by print if no `__str__`
                      return str(self.val)  # `__repr__` used if echoed or nested


              objs = [Printer(2), Printer(3)]
              for x in objs:
                  print(x)  # No `__str__`; runs `__repr__`
              # 2
              # 3


              print(objs)  # Runs `__repr__`, not `__str__`
              # [2, 3]

              objs
              # [2, 3]
            #+end_src

       3. *CAUTION* (perhaps *most SUBTLE*):
          *the /display methods/ also have the potential to trigger infinite recursion
          loops in rare contexts* -- because some objects' displays include displays
          of other objects, it's not impossible that a display may trigger a display
          of an object being displayed, and thus loop. This is rare and obscure enough
          to skip here, but watch for an example of this looping potential to
          appear for these methods in a note near the end of the next chapter in
          its =listinherited.py= example’s class, where ~__repr__~ can loop.
          =TODO= =TODO= =TODO= =TODO= =TODO= =TODO= =TODO=

     - Summary:
       In practice,
       + ~__str__~, and its more inclusive relative ~__repr__~, seem to be the second
         most commonly used operator overloading methods in Python scripts, behind
         ~__init__~.
       
       + For additional examples of these tools at work and the design tradeoffs
         they imply, see
         * Chapter 28’s case study,

         * Chapter 31’s class lister mix-ins,

         * their role in Chapter 35’s exception classes,
           where ~__str__~ is required over ~__repr__~.
     
*** DONE Right-Side and In-Place Uses: ~__radd__~ and ~__iadd__~ - 917
    CLOSED: [2021-03-24 Wed 02:00]
    Our next group of /overloading methods/ extends the functionality of /binary
    operator methods/ such as ~__add__~ and ~__sub__~ (called for ~+~ and ~-~),
    which we've already seen.

    - As mentioned earlier, part of the _REASON_ there are so many operator
      /overloading methods/ is _BECAUSE_ they come in *multiple flavors* --
      for _EVERY_ binary expression, we can implement a *left*, *right*, and
      *in-place* variant.
      * Though _defaults_ are also applied if you don't code all three, your
        objects' roles dictate how many variants you'll need to code.

**** DONE Right-Side Addition - 917
     CLOSED: [2021-03-24 Wed 01:43]
     - Q :: Why do we need right-side operaton, for example, right-side addition?
     - A :: If we don't have it: 
       #+begin_src python
         class Adder:
             def __init__(self, value = 0):
                 self.data = value

             def __add__(self, other):
                 return self.data + other

         x = Adder(5)
         x + 2  # 7
         2 + x  ## TypeError: unsupported operand type(s) for +: 'int' add 'Adder'
       #+end_src
       * Use ~__radd__~ to fix this:
         We can add tracing messages.
         #+begin_src python
           class Commuter1:
               def __init__(self, value = 0):
                   self.data = value

               def __add__(self, other):
                   print('add', self.val, other)
                   return self.data + other

               def __radd__(self, other):
                   print('radd', self.val, other)
                   return other + self.val


           x = Commuter1(88)
           y = Commuter1(99)

           x + 1             # __add__: commuter1 + non-commuter1
           # add 88 1
           # 89

           1 + y             # __radd__: non-commuter1 + commuter1
           # radd 99 1
           # 100


           x + y             # __add__: commuter1 + commuter1
           # add 88 <commuter.Commuter1 object at 0x00000000029B39E8>
           # radd 99 88
           # 187
         #+end_src
       
***** DONE Reusing ~__add__~ in ~__radd__~ - 918
      CLOSED: [2021-03-24 Wed 01:43]
      For *truly commutative operations* that do *NOT* require special-casing by
      position, it is also sometimes sufficient to *reuse* ~__add__~ for
      ~__radd__~.

      - Q :: In this context, how to reuse?
      - A :: Usually three ways:
        * call ~__add__~ directly
          #+begin_src python
            class Commuter2:
                def __init__(self, val):
                    self.val = val

                def __add__(self, other):
                    print('add', self.val, other)
                    return self.val + other

                def __radd__(self, other):
                    return self.__add__(other)  # Call __add__ explicitly
          #+end_src

        * swap order and re-add to trigger ~__add__~ indirectly
          #+begin_src python
            class Commuter3:
                def __init__(self, val):
                    self.val = val

                def __add__(self, other):
                    print('add', self.val, other)
                    return self.val + other

                def __radd__(self, other):
                    return self + other  # Swap order and re-add
          #+end_src

        * simply assining ~__radd__~ to be an alias for ~__add__~ at the top level
          of the /class statement/ (i.e., in the class's scope).
          #+begin_src python
            class Commuter4:
                def __init__(self, val):
                    self.val = val

                def __add__(self, other):
                    print('add', self.val, other)
                    return self.val + other

                __radd__ = __add__  # Alias: cut out the middleman
          #+end_src
      
***** DONE Propagating class type - 919
      CLOSED: [2021-03-24 Wed 01:39]
      - Q :: Often, you want to create a closed system, and the _class types_ should
             be passed when operations are close to this system.

      - A :: Usually you need to do /type test/ in some place(s) in some specific
             places in the definition to avoid generating nesting in the final result.
        * =from Jian=
          This is rarely happen in static typing languages -- mostly /type
          checking/ will stop people doing this if no specific design.

        * For example,
          #+begin_src python
            class Commuter5:
                def __init__(self, val):
                    self.val = val

                def __add__(self, other):
                    if isinstance(other, Commuter5):
                        other = other.val
                    return Commuter5(self.val + other)

                def __radd__(self, other):
                    return Commuter5(other + self.val)

                def __str__(self):
                    return '<Commuter 5: %s>' % self.val
          #+end_src
          If we remove the ~isinstance~ line, in some scenarios, we can see
          the results can be nested ~Commuter5~.
       
**** DONE In-Place Addition - 920
     CLOSED: [2021-03-24 Wed 02:00]
     Use ~__iadd__~ to implement ~+=~.
     ~__add__~ is the fallback.

     - =???=
       For mutable objects, this method can often specialize for quicker
       in-place changes:

*** DONE Call Expressions: ~__call__~ - 921
    CLOSED: [2021-03-16 Tue 04:59]
    - The ~__call__~ may seem a bit gratuitous at first glance. A simple /method/
      can provide similar utility
        However, ~__call__~ can become more useful when *interfacing* with *APIs
      (i.e., libraries) that EXPECT functions* -- it allows us to
      * code objects that conform to an expected _function call interface_,
      * but also retain state information, and
      * other class assets such as inheritance.

    - In fact, it may be _the *THIRD most commonly* used /operator overloading
      method/,_ behind the ~__init__~ and the ~__str__~ and ~__repr__~.

**** Function Interfaces and Callback-Based Code - 923
     - This is DIFFERENT than other /state retention techniques/ 
       which rely on more *limited* or *implicit* behavior.
       * e.g.,
         + global variables,
       
         + enclosing function scope references,
           #+begin_src python
             def callback(color): # Enclosing scope versus attrs
                 def oncall():
                     print('turn', color)
                 return oncall

             cb3 = callback('yellow') # Handler to be registered
             cb3()
           #+end_src
       
         + and default mutable arguments),
           #+begin_src python
             class Callback:
                 def __init__(self, color): # Class with state information
                     self.color = color

                 def changeColor(self): # A normal named method
                     print('turn', self.color)

             cb1 = Callback('blue')
             cb2 = Callback('yellow')

             B1 = Button(command=cb1.changeColor) # Bound method: reference, don't call
             B2 = Button(command=cb2.changeColor) # Remembers function + self pair
           #+end_src
       
       * Moreover, the added structure and customization in /classes/ goes *beyond*
         /state retention/.

     - =TODO=
       * You'll also see another ~__call__~ example in Chapter 32, where we will
         use it to implement something known as a /function decorator/.
       
       * Because ~__call__~ allows us to attach state information to a /callable
         object/, it's a natural implementation technique for a function that
         must remember to call another function when called itself.

       * For more ~__call__~ examples, see
         + the state retention preview examples in *Chapter 17*, and
         + the more advanced /decorators/ and /metaclasses/ of *Chapter 39 and
           Chapter 40*.

*** DONE Comparisons: ~__lt__~, ~__gt__~, and Others - 925
    CLOSED: [2021-03-18 Thu 02:08]
    - These methods are generally straightforward to use, but keep the following
      qualifications in mind:
      * _Reflective methods_ are used when only one operand supports comparison
        (e.g., ~__lt__~ and ~__gt__~ are each other's reflection).
        =TODO= =???= =???= =???=

      * There are *NO* implicit relationships among the comparison operators.
        *The truth of ~==~ does not imply that ~!=~ is false,* for example, so
        both ~__eq__~ and ~__ne__~ should be defined to ensure that both
        operators behave correctly.

    - Both ~__cmp__~ and the built-in function ~cmp~, supported by Python 2.X,
      are removed from Python 3.X. In Python 2.X, ~__cmp__~ is a fallback, when no
      more specific comparison dunder method are defined.
      
**** The ~__cmp__~ Method in Python 2.X - 926

*** DONE Boolean Tests: ~__bool__~ and ~__len__~ - 927
    CLOSED: [2021-03-16 Tue 04:29]
    *Works for Python 3.X*
    Try the retruned value from the /method/ ~__bool__~ first,
    and then fallback to the retruned value from the /method/ ~__len__~,
    and then, finally, fallback to the default value ~True~.
    
**** Boolean Methods in Python 2.X - 928
     In Python 2.X, there is no ~__bool__~ /method/, the ~__nonzero__~ /method/
     will be checked first, as the ~__bool__~ in Python 3.X.
     
     - Python 3.X rename ~__nonzero__~ to ~__bool_~.

     - Python 2.X's always *ignore* the ~__bool__~ /method/!
       Python 3.X's always *ignore* the ~__nonzero__~ /method/!

*** TODO Object Destruction: ~__del__~ - 929 - =RE-READ= =TAKE NOTE=
**** Destructor Usage Notes 930

*** DONE Chapter Summary - 931
    CLOSED: [2021-04-05 Mon 02:46]
    - Most of the other /operator overloading methods/ work *similarly* to the
      ones we've explored, and
      all are just _hooks_ for *intercepting* _built-in type operations_.

    - We'll see a few others in action later in the book:
      * Chapter 34:
        uses ~__enter__~ and ~__exit__~ in ~with~ statement _context managers_.

      * Chapter 38:
        uses the ~__get__~ and ~__set__~ /class descriptor fetch/set methods/.

      * Chapter 40:
        uses the ~__new__~ /object creation method/ in the context of /metaclasses/.

*** TODO Test Your Knowledge: Quiz - 931
*** TODO Test Your Knowledge: Answers - 931

** TODO 31. Designing with Classes - 933
*** Python and OOP - 933
**** Polymorphism Means Interfaces, Not Call Signatures - 934

*** OOP and Inheritance: “Is-a” Relationships - 935
*** OOP and Composition: “Has-a” Relationships - 937
**** Stream Processors Revisited - 938

*** OOP and Delegation: “Wrapper” Proxy Objects - 942
*** Pseudoprivate Class Attributes - 944
**** Name Mangling Overview - 945
**** Why Use Pseudoprivate Attributes? - 945

*** Methods Are Objects: Bound or Unbound - 948
**** Unbound Methods Are Functions in 3.X - 950
**** Bound Methods and Other Callable Objects - 951

*** Classes Are Objects: Generic Object Factories - 954
**** Why Factories? - 955

*** Multiple Inheritance: “Mix-in” Classes - 956
**** Coding Mix-in Display Classes - 957

*** Other Design-Related Topics - 977
*** Chapter Summary - 977
*** Test Your Knowledge: Quiz - 978
*** Test Your Knowledge: Answers - 978

** TODO 32. Advanced Class Topics - - 979
*** Extending Built-in Types - 980
**** Extending Types by Embedding - 980
**** Extending Types by Subclassing - 981

*** TODO The “New Style” Class Model - 983
**** Just How New Is New-Style? - 984

*** TODO New-Style Class Changes - 985
**** Attribute Fetch for Built-ins Skips Instances - 987
**** Type Model Changes - 992
**** All Classes Derive from “object” - 995
**** Diamond Inheritance Change - 997
**** More on the MRO: Method Resolution Order - 1001
**** Example: Mapping Attributes to Inheritance Sources - 1004

*** TODO New-Style Class Extensions - 1010
**** Slots: Attribute Declarations - 1010
**** Properties: Attribute Accessors - 1020
**** ~__getattribute__~ and Descriptors: Attribute Tools - 1023
**** Other Class Changes and Extensions - 1023

*** TODO Static and Class Methods - 1024
**** Why the Special Methods? - 1024
**** Static Methods in 2.X and 3.X - 1025
**** Static Method Alternatives - 1027
**** Using Static and Class Methods - 1028
**** Counting Instances with Static Methods - 1030
**** Counting Instances with Class Methods - 1031

*** TODO Decorators and Metaclasses: Part 1 - 1034
**** Function Decorator Basics - 1035
**** A First Look at User-Defined Function Decorators - 1037
**** A First Look at Class Decorators and Metaclasses - 1038
**** For More Details - 1040

*** TODO The super Built-in Function: For Better or Worse? - 1041
**** The Great super Debate - 1041
**** Traditional Superclass Call Form: Portable, General - 1042
**** Basic super Usage and Its Tradeoffs - 1043
**** The super Upsides: Tree Changes and Dispatch - 1049
**** Runtime Class Changes and super - 1049
**** Cooperative Multiple Inheritance Method Dispatch - 1050
**** The super Summary - 1062

*** TODO Class Gotchas - 1064
**** Changing Class Attributes Can Have Side Effects - 1064
**** Changing Mutable Class Attributes Can Have Side Effects, Too - 1065
**** Multiple Inheritance: Order Matters - 1066
**** Scopes in Methods and Classes - 1068
**** Miscellaneous Class Gotchas - 1069
**** KISS Revisited: “Overwrapping-itis” - 1070

*** Chapter Summary - 1070
*** Test Your Knowledge: Quiz - 1071
*** Test Your Knowledge: Answers - 1071
*** Test Your Knowledge: Part VI Exercises - 1072
    
* Part VII. Exceptions and Tools
** TODO 33. Exception Basics - 1081
   - /Exceptions/ can *modify* the _flow of control_.
     =from Jian=
     This is why /exceptions/ are flexible, powerful, and tricky!!!

   - Four statements that can handle (*trigger* and/or *intercept*) /exceptions/:
     * ~try ... except~:
       *Catch* and *recover* from /exceptions/ raised in between ~try~ and ~catch~.

     * ~try ... final~
       Perform *cleanup* actions, whether /exceptions/ *occur or not*.

     * ~raise~
       Trigger an /exception/ manually.

     * ~assert~
       Conditionally trigger an exception
       =from Jian= when some expected (should be guaranteed) values are not given.

     * ~with ... as~
       Implement context managers in _Python 2.6, 3.0, and later_
       (_OPTIONAL in 2.5_).
     
*** DONE Why Use Exceptions? - 1081
    CLOSED: [2021-03-16 Tue 03:08]
    In a nutshell, /exceptions/ let us jump out of arbitrarily large chucks of a
    program.

    - The exactly what /exceptions/ let you do:
      * *jump* to an /exception handler/ in a SINGLE step,
      * *abandoning* all function calls begun
        since the /exception handler/ was entered.
        
    - An /exception/ is as a sort of _structured “super go to.”_
      1. An /exception handler/ (~try~ statement) leaves a *marker* and executes
         some code.
      2. Somewhere further ahead in the program, an /exception/ is raised that
         makes Python
         * *jump back* to that _marker_,
         * *abandoning* any active functions that were called _AFTER the marker_
           was left.

      This protocol provides a coherent way to respond to unusual events.
        
**** Exception Roles - 1082
     - In Python programs, /exceptions/ are TYPICALLY used for a variety of
       purposes. Here are some of their most common roles:
       * Error handling

       * Event notification
         For instance,
         a search routine may raise an /exception/ on failure, instead of returning
         a result code.
       
       * Special-case handling
         Sometimes a condition may occur so _RARELY_ that it's hard to justify
         convoluting your code to handle it _in multiple places_.
           You can often *eliminate* special-case code *by handling unusual cases
         in /exception handlers/ in _higher levels_ of your program.*
         =from Jian=
         GOOD IDEA

       * Termination actions
         ~try ... finally~ and ~with~ statement allow you to guarantee that
         required closing-time operations will be performed,
         *REGARDLESS of the _presence_ or _absence_ of* /exceptions/ in your
         programs.

       * Unusual control flow
         =IMPORTANT= =RE-READ=
         =IMPORTANT= footnote 1.
         =IMPORTANT= =!!!=

     - =from Jian=
       /Exceptions/ in most language implementations are expensive, and they are
       only used for _Error handling_.
       
*** TODO Exceptions: The Short Story - 1083
**** Default Exception Handler - 1083
**** Catching Exceptions - 1084
**** Raising Exceptions - 1085
**** User-Defined Exceptions - 1086
**** Termination Actions - 1087

*** Chapter Summary - 1089
*** Test Your Knowledge: Quiz - 1090
*** Test Your Knowledge: Answers - 1090

** 34. Exception Coding Details - 1093
*** The ~try~ / ~except~ / ~else~ Statement - 1093
**** How ~try~ Statements Work - 1094
**** try Statement Clauses - 1095
**** The try else Clause - 1098
**** Example: Default Behavior - 1098
**** Example: Catching Built-in Exceptions - 1100

*** The ~try~ / ~finally~ Statement - 1100
**** Example: Coding Termination Actions with ~try~ / ~finally~ - 1101

*** Unified ~try~ / ~except~ / ~finally~ - 1102
**** Unified ~try~ Statement Syntax - 1104
**** Combining ~finally~ and ~except~ by Nesting - 1104
**** Unified ~try~ Example - 1105

*** The ~raise~ Statement - 1106
**** Raising Exceptions - 1107
**** Scopes and ~try~ ~except~ Variables - 1108
**** Propagating Exceptions with ~raise~ - 1110
**** Python 3.X Exception Chaining: ~raise from~ - 1110

*** The ~assert~ Statement - 1112
**** Example: Trapping Constraints (but Not Errors!) - 1113

*** ~with~ / ~as~ Context Managers - 1114
**** Basic Usage - 1114
**** The Context Management Protocol - 1116
**** Multiple Context Managers in 3.1, 2.7, and Later - 1118

*** Chapter Summary - 1119
*** Test Your Knowledge: Quiz - 1120
*** Test Your Knowledge: Answers - 1120

** 35. Exception Objects - 1123
*** Exceptions: Back to the Future - 1124
**** String Exceptions Are Right Out! - 1124
**** Class-Based Exceptions - 1125
**** Coding Exceptions Classes - 1126

*** Why Exception Hierarchies? - 1128
*** Built-in Exception Classes - 1131
**** Built-in Exception Categories - 1132
**** Default Printing and State - 1133

*** Custom Print Displays - 1135
*** Custom Data and Behavior - 1136
**** Providing Exception Details - 1136
**** Providing Exception Methods - 1137

*** Chapter Summary - 1139
*** Test Your Knowledge: Quiz - 1139
*** Test Your Knowledge: Answers - 1139

** 36. Designing with Exceptions - 1141
*** Nesting Exception Handlers - 1141
**** Example: Control-Flow Nesting - 1143
**** Example: Syntactic Nesting - 1143

*** Exception Idioms - 1145
**** Breaking Out of Multiple Nested Loops: “go to” - 1145
**** Exceptions Aren’t Always Errors - 1146
**** Functions Can Signal Conditions with raise - 1147
**** Closing Files and Server Connections - 1148
**** Debugging with Outer try Statements - 1149
**** Running In-Process Tests - 1149
**** More on ~sys.exc_info~ - 1150
**** Displaying Errors and Tracebacks - 1151

*** Exception Design Tips and Gotchas - 1152
**** What Should Be Wrapped - 1152
**** Catching Too Much: Avoid Empty except and Exception - 1153
**** Catching Too Little: Use Class-Based Categories - 1155

*** Core Language Summary - 1155
**** The Python Toolset - 1156
**** Development Tools for Larger Projects - 1157

*** Chapter Summary - 1160
*** Test Your Knowledge: Quiz - 1161
*** Test Your Knowledge: Answers - 1161
*** Test Your Knowledge: Part VII Exercises - 1161

* Part VIII. Advanced Topics
** 37. Unicode and Byte Strings - 1165
*** String Changes in 3.X - 1166
*** String Basics - 1167
**** Character Encoding Schemes - 1167
**** How Python Stores Strings in Memory - 1170
**** Python’s String Types - 1171
**** Text and Binary Files - 1173

*** Coding Basic Strings - 1174
**** Python 3.X String Literals - 1175
**** Python 2.X String Literals - 1176
**** String Type Conversions - 1177

*** Coding Unicode Strings - 1178
**** Coding ASCII Text - 1178
**** Coding Non-ASCII Text - 1179
**** Encoding and Decoding Non-ASCII text - 1180
**** Other Encoding Schemes - 1181
**** Byte String Literals: Encoded Text - 1183
**** Converting Encodings - 1184
**** Coding Unicode Strings in Python 2.X - 1185
**** Source File Character Set Encoding Declarations - 1187

*** Using 3.X bytes Objects - 1189
**** Method Calls - 1189
**** Sequence Operations - 1190
**** Other Ways to Make bytes Objects - 1191
**** Mixing String Types - 1192

*** Using 3.X/2.6+ bytearray Objects - 1192
**** bytearrays in Action - 1193
**** Python 3.X String Types Summary - 1195

*** Using Text and Binary Files - 1195
**** Text File Basics - 1196
**** Text and Binary Modes in 2.X and 3.X - 1197
**** Type and Content Mismatches in 3.X - 1198

*** Using Unicode Files - 1199
**** Reading and Writing Unicode in 3.X - 1199
**** Handling the BOM in 3.X - 1201
**** Unicode Files in 2.X - 1204
**** Unicode Filenames and Streams - 1205

*** Other String Tool Changes in 3.X - 1206
**** The re Pattern-Matching Module - 1206
**** The struct Binary Data Module - 1207
**** The pickle Object Serialization Module - 1209
**** XML Parsing Tools - 1211

*** Chapter Summary - 1215
*** Test Your Knowledge: Quiz - 1215
*** Test Your Knowledge: Answers - 1216

** TODO 38. Managed Attributes - 1219
   - For tools builders, _managing attribute access_ can be an important part of
     flexible APIs.

   - Moreover, an understanding of the /descriptor model/ covered here can
     make related tools such as /slots/ and /properties/ more tangible.

*** DONE Why Manage Attributes? - 1219
    CLOSED: [2020-10-28 Wed 21:20]
    - Q :: Why do we need to manage attributes?

    - A :: Explain this with an example:
           Suppose we have an attribute ~name~ for a project ~person~ of the class
           ~Person~.
      1. First, we access the attribute directly, which is natural with the first
         glance: ~person.name~ and ~person.name = value~

      2. Later, you want to add some logic to this attribute, for example:
         do something when set or mutate it, or provide a default value when no
         valid value ("uninitialized" is a common cause, though not the only one)
         #+BEGIN_SRC python
           class Person:
               def getName(self):
                   if not valid():
                       raise TypeError('cannot fetch name')
                   else:
                       return self.name.transform()

               def setName(self, value):
                   if not valid(value):
                       raise TypeError('cannot change name')
                   else:
                       self.name = transform(value)

           person = Person()
           person.getName()
           person.setName('value')
         #+END_SRC

       From 1 to 2, there is an API change, which is NOT what we want.
       
    - Conclusion ::
      + If you begin with a /method-based interface/ to data, clients are immune to
        changes;
      + if you do NOT, they can become *PROBLEMATIC*.

**** DONE Inserting Code to Run on Attribute Access - 1220
     CLOSED: [2020-10-28 Wed 22:16]
     - /attribute accessor/ method can help fix the API even in the future in
       most cases.

     - This chapter presents _FOUR_ accessor techniques:
       + The ~__getattr__~ and ~__setattr__~ /methods/, for *routing*
         _undefined attribute fetches_ and _all attribute assignments_ *to*
         /generic handler methods/.

       + The ~__getattribute__~ /method/, for
         *routing* _all attribute fetches_
         *to* a /generic handler method/.

       + The ~property~ /built-in/, for
         *routing* _specific attribute access_
         *to* /GET and SET handler functions/.

       + The /descriptor protocol/, for
         *routing* _specific attribute accesses_
         *to* /instances of classes with *arbitrary* GET and SET handler
         methods/, and the basis for other tools such as /properties/ and
         /slots/. =TODO= =TODO= =TODO=

     - _VERSIONS_: =IMPORTANT=
       + The tools in the _FIRST_ of these above bullets are available in _ALL_
         Pythons.

       + The last _THREE_ bullets' tools are available
         * in Python _3.X_ and _new-style classes_ in 2.2+ --
           - they _first appeared_ in Python 2.2, along with many of the other
             advanced tools of Chapter 32 such as /slots/ and /super/.
             =TODO= =TODO= =TODO= Chapter 32

       + We briefly met the _FIRST_ and _THIRD_ of these in Chapter 30 and Chapter
         32, respectively;
       + the _SECOND_ and _FOURTH_ are largely new topics we'll explore in full
         here. =TODO=

     - Four methods do differ in some imporant ways. =TODO=
       For example,
       + the _LAST TWO_ techniques listed here apply to /SPECIFIC attributes/,

       + the _FIRST TWO_ are *GENERIC* enough to be used by /delegation-based
         proxy classes/ that *MUST route ARBITRARY* /attributes/ *to* wrapped
         objects.

       + _We'll see_ all four schemes also differ in BOTH _complexity_ and
         _aesthetics_, in ways you must see in action to judge for yourself.

*** DONE Properties - 1221
    CLOSED: [2020-10-28 Wed 22:43]
    - The /property protocol/ allows us to:
      + *route* a specific attribute's ~get~, ~set~, and ~delete~ operations
        *to* /functions/ or /methods/ we provide

      + ENABLING us to insert code to be _run AUTOMATICALLY_ *on* /attribute access/

      + INTERCEPT /attribute deletions/

      + PROVIDE /documentation/ for the attributes if desired

    - Properties are created with the ~property~ /built-in/ and are assigned to
      /class attributes/, just LIKE /method functions/.

    - *A* /property/ manages *a* _SINGLE_, _SPECIFIC_ /attribute/; =IMPORTANT=
      It allows us to control BOTH /fetch/ and /assignment/ freely, without
      breaking existing code.

    - As we'll see, properties are strongly related to /descriptors/;
      in fact, they are essentially a restricted form of them.
      =IMPORANT=
      =TODO=

**** DONE The Basics - 1222
     CLOSED: [2020-10-28 Wed 22:25]
     A /property/ is created by assigning the result of a /built-in function/ to
     a /class attribute/
     #+begin_src python
       attribute = property(fget, fset, fdel, doc)
     #+end_src
     - *None* of this built-in's arguments *are required*, and
       ALL _DEFAULT to_ ~None~.

     - Suppose you didn't set ~fget~, and then when you call it,
       it will ~raise~ an ~AttributeError~.

     - =TODO= =IMPORTANT=
       Technically, all three of the first three arguments accept *any* /callable/,
       including
       + a /class's method/, having a first argument to receive the instance being
         qualified.
         =TODO= give a NOT method example.

     - This /built-in/ ~property~ call *returns* a /property object/, which we
       assign to the name of the /attribute/ to be managed _in the class scope_,
       where it *will be inherited by* EVERY /instance/.

**** DONE A First Example - 1222
     CLOSED: [2020-10-28 Wed 22:27]
     A trivial, which only is used to illustrate how does a /property/ works.
     #+BEGIN_SRC python
       class Person:                            # Add (object) in 2.X
           def __init__(self, name):
               self._name = name

           def getName(self):
               print('fetch...')
               return self._name

           def setName(self, value):
               print('change...')
               self._name = value

           def delName(self):
               print('remove...')
               del self._name

           name = property(getName, setName, delName, "name property docs")

       bob = Person('Bob Smith')                # bob has a managed attribute
       print(bob.name)                          # Runs getName
       bob.name = 'Robert Smith'                # Runs setName
       print(bob.name)
       del bob.name                             # Runs delName

       print('-'*20)

       sue = Person('Sue Jones')                # sue inherits property too
       print(sue.name)
       print(Person.name.__doc__)               # Or help(Person.name)
     #+END_SRC

     - Store data into ~self._name~ so it *does NOT clash* with the  ~name~
       /property/.

     - Like all /class attributes/, /properties/ are inherited by its /subclasses/.
       + Here is a example whoes behavior is the same as the example code above:
         #+begin_src python
           class Super:
               # ... the original `Person` class code ...
               name = property(getName, setName, delName, 'name property docs')

           class Person(Super):
               pass
         #+end_src

**** DONE Computed Attributes - 1224
     CLOSED: [2020-10-28 Wed 22:37]
     #+BEGIN_SRC python
       class PropSquare:                     # Add (object) in 2.X
           def __init__(self, start):
               self.value = start

           def getX(self):
               return self.value ** 2

           def setX(self, value):
               self.value = value

           x = property(getX, setX)

       p = PropSquare(3)
       q = PropSquare(32)

       print(p.x)    # 3**2
       p.X = 4
       print(p.x)    # 4**2
       print(q.x)    # 32 ** 2
     #+END_SRC

     - The ~property~ methods automatically receive a ~self~ argument, they have
       access to the state information stored in /instances/.
       
**** DONE Coding Properties with Decorators - 1224
     CLOSED: [2020-10-28 Wed 22:43]
     The ~property~ built-in can serve as a /decorator/.
     #+BEGIN_SRC python
       class Person:
           @property
           def name(self): ...

       # is the same as

       class Person:
           def name(self): ...
           name = property(name)
     #+END_SRC

***** DONE Setter and deleter decorators
      CLOSED: [2020-10-28 Wed 22:42]
      - As of Python 2.6 and 3.0,
        /property/ objects also have ~getter~, ~setter~, and ~deleter~ /methods/
        that
        + *assign* the corresponding /property accessor methods/ and
        + *return* a copy of the /property/ itself.
      
      #+BEGIN_SRC python
        class Person:
            def __init__(self, name):
            self._name = name

            @property
            def name(self): # name = property(name)
                "name property docs"
                print('fetch...')
                return self._name

            @name.setter
            def name(self, value):   # name = name.setter(name)
                print('change...')
                self._name = value

            @name.deleter
            def name(self):    # name = name.deleter(name)
                print('remove...')
                del self._name

        bob = Person('Bob Smith')  # bob has a managed attribute
        print(bob.name)            # Runs name getter (name 1)
        bob.name = 'Robert Smith'  # Runs name setter (name 2)
        print(bob.name)
        del bob.name               # Runs name deleter (name 3)

        print('-'*20)

        sue = Person('Sue Jones')  # sue inherits property too
        print(sue.name)
        print(Person.name.__doc__) # Or help(Person.name)
      #+END_SRC

*** TODO Descriptors - 1226
    /descriptors/ provide an _alternative_ way to *intercept* /attribute access/;
    they are _STRONGLY RELATED TO_ the /properties/ discussed in the prior section.
    
    - A /property/ is a kind of /descriptor/.

    - /Descriptors/ are the _underlying implementation mechanism_ for a variety
      of class tools, including both:
      + /properties/
      + /slots/
      + etc.

    - Functionally speaking, the descriptor protocol allows us to route a specific
      attribute’s get, set, and delete operations to methods of a separate
      class’s instance object that we provide. This allows us to insert code to
      be run automatically on attribute fetches and assignments, intercept
      attribute deletions, and provide documentation for the attributes if
      desired.
      =TODO= =TODO= =TODO=

    - /Descriptors/:
      + They are created as *INDEPENDENT* /classes/, and
        they *are assigned to* /class attributes/ just like /method functions/.

      + Like any other /class attribute/, they are *inherited by* /subclasses/ and
        /instances/.

      + Their /access-interception methods/ are provided with BOTH
        * a ~self~ for the /descriptor instance/ ITSELF, as well as
        * the /instance/ of the /client class/ whose /attribute/ *references* the
          /descriptor object/.

      Because of this,
      they can *retain* and *use* state information of their own,
      as well as /state/ information of the subject /instance/.
      
        For example, a /descriptor/ may call /methods/ *available* in the /client
      class/, as well as /descriptor specific methods/ *it defines*.
      
**** DONE The Basics - 1227
     CLOSED: [2020-10-29 Thu 00:39]
     /descriptors/ are coded as *separate* /classes/ and provide *specially named*
     /accessor methods/ for the /attribute access operations/ they wish to _INTERCEPT_
     -- *get*, *set*, and *deletion* methods in the /descriptor class/ are
     AUTOMATICALLY run when the attribute assigned to the /descriptor class
     instance/ is accessed in the corresponding way:
     #+begin_src python
       class Descriptor:
           "docstring goes here"
           def __get__(self, instance, owner): ...  # Return attr value
           def __set__(self, instance, value): ...  # Return nothing (None)
           def __delete__(self, instance): ...      # Return nothing (None)
     #+end_src
     - /Classes/ with _ANY_ of these /methods/ are CONSIDERED /descriptors/,
       + their /methods/ are special when one of their instances is assigned to
         another class’s attribute -- when the attribute is accessed, they are
         automatically invoked.

       + If any of these /methods/ are _ABSENT_, it generally means that the
         corresponding type of access is *not supported*.

       + *Unlike /properties/,* however, omitting a ~__set__~ allows the /descriptor
         attribute's name/ to be assigned and thus _redefined_ in an instance,
         thereby *hiding* the /descriptor/ --
         _to make an attribute *read-only*,_ you *must* define ~__set__~ to
         _CATCH assignments_ and _RAISE an exception_.

     - /Descriptors/ with ~__set__~ methods also have some special-case implications
       for inheritance that we'll largely defer until Chapter 40's coverage of
       /metaclasses/ and the _COMPLETE_ /inheritance specification/.
       =TODO= =TODO= =TODO= 
       + In short, a /descriptor/ with a ~__set__~ is known formally as
         /data descriptor/, and is given *precedence OVER* other names located
         by /normal inheritance rules/.

       + The /inherited descriptor/ for name ~__class__~, for example, *overrides*
         the SAME name IN an /instance's namespace dictionary/.
         * This also works to ensure that /data descriptors/ you code in your own
           /classes/ *take precedence over* others.

***** DONE Descriptor method arguments - 1227
      CLOSED: [2020-10-29 Thu 00:39]
      Before we code anything realistic, let's take a brief look at some
      _FUNDAMENTALS_.

      - *All three* /descriptor methods/ outlined in the prior section are passed
        both
        + the /descriptor class instance (~self~)/, and
        + the /instance/ of the /client class/ to which the /descriptor instance/
          is attached (~instance~).

      - The ~__get__~ /access method/ ADDITIONALLY receives an ~owner~ argument,
        specifying the /class/ to which the /descriptor instance/ is attached.
        + Its ~instance~ argument is
          * EITHER the /instance/ through which the attribute was accessed (for
            ~instance.attr~),

          * OR ~None~ when the attribute is accessed through the /owner class/ directly
            (for ~Class.attr~).

        + The _FORMER_ of these generally _computes a value_ for /instance access/,

        + The _LATTER_ usually returns ~self~
          IF /descriptor object ACCESS/ is *supported*.
          =TODO= =???= =TODO=

      - For example:
        #+begin_src python
          class Descriptor:
              def __get__(self, instance, owner):
                  print(self, instance, owner, sep='\n')

          class Subject:
              attr = Descriptor()

          Subject.attr
          ## <__main__.Descriptor object at 0x0281E690>
          ## None
          ## <class '__main__.Subject'>


          x = Subject()
          x.attr
          ## <__main__.Descriptor object at 0x0281E690>
          ## <__main__.Subject object at 0x028289B0>
          ## <class '__main__.Subject'>
        #+end_src
        + Notice the arguments *AUTOMATICALLY passed into* the ~__get__~ method
          in the first attribute fetch -- when ~x.attr~ is fetched, it's as
          though the following translation occurs (though the ~Subject.attr~
          here doesn't invoke ~__get__~ again):
          ~X.attr~ -> ~Descriptor.__get__(Subject.attr, X, Subject)~

        + The /descriptor/ knows it is being accessed directly when its /instance
          argument/ is ~None~.
      
***** DONE Read-only descriptor - 1228
      CLOSED: [2020-10-29 Thu 00:17]
      - Example:
        #+begin_src python
          class D:
              def __get__(*args): print('get')

          class C:
              a = D()  ## Attribute `a` is a descriptor instance

          x = C()
          x.a          ## Run inherited descriptor `__get__`
          # get

          C.a
          # get

          list(X.__dict__.keys())
          # []


          x.a = 99     ## Stored on `x`, hiding `C.a`!
          x.a
          # 99

          list(X.__dict__.keys())
          # ['a']
        #+end_src
        + Can't be ignored if /read-only descriptor/ is required:
          #+begin_src python
            # defined in `D`
            def __set__(*args):
                raise AttributeError('cannot set')
          #+end_src

        + If not /read-only descriptor/, the assignment can happen, and the
          /descriptor/ will be hided. The lines from ~x.a = 99~ to the end in
          the above example can show this.

        + =IMPORTANT= =from Jian=
          This example can prove that /no ~__set__~ descriptor/ is never the
          /descriptor/ you want if you want to write reasonable code!!!

      - TIPs:
        Don't confuse the /descriptor ~__delete__~ method/ with the GENERAL
        ~__del__~ /method/:
        + ~__delete__~ attempts to *delete* the /managed attribute name/ on an
          /instance/ of the /owner class/;
          * It is more closely related to the ~__delattr__~ /generic attribute
            deletion method/ =TOOD= LATER IN THIS CHAPTER.

        + ~__del__~ is an /instance destructor method/, which is called when an
          /instance/ of any kind of /class/ is about to be *garbage-collected*.

**** DONE A First Example - 1229
     CLOSED: [2020-10-28 Wed 23:03]
     #+BEGIN_SRC python
       class Name:                                 # Use (object) in 2.X
           "name descriptor docs"
           def __get__(self, instance, owner):
               print('fetch...')
               return instance._name

           def __set__(self, instance, value):
               print('change...')
               instance._name = value

           def __delete__(self, instance):
               print('remove...')
               del instance._name


       class Person:                               # Use (object) in 2.X
           def __init__(self, name):
               self._name = name

           name = Name()                           # Assign descriptor to attr


       bob = Person('Bob Smith')  ## bob has a managed attribute
       print(bob.name)            ## Runs Name.__get__
       # fetch...
       # Bob Smith

       bob.name = 'Robert Smith'  ## Runs Name.__set__
       print(bob.name)
       # fetch...
       # Robert Smith

       del bob.name               ## Runs Name.__delete__

       print('-'*20)
       # --------------------

       sue = Person('Sue Jones')  ## sue inherits descriptor too
       print(sue.name)
       # fetch...
       # Sue Jones

       print(Name.__doc__)        ## Or help(Name)
       # name descriptor docs
     #+END_SRC

     - we must assign the /descriptor/ to a class attribute like this — it won’t
       work if assigned to a ~self~ instance attribute instead.

     - When the descriptor's ~__get__~ method is run, it is passed three objects
       to define its context:
       + ~self~ is the ~Name~ class instance.
       + ~instance~ is the ~Person~ class instance.
       + ~owner~ is the ~Person~ class.

     - If a descriptor class is ONLY used in one class, just embed it into this
       class.
       #+BEGIN_SRC python
         class Person:
             def __init__(self, name):
                 self._name = name

             class Name:
                 """name descriptor docs"""
                 def __get__(self, instance, owner):
                     print('fetch...')
                     return instance._name

                 def __set__(self, instance, value):
                     print('change...')
                     instance._name = value

                 def __delete__(self, instance):
                     print('remove...')
                     del instance._name

             name = Name()
       #+END_SRC

**** DONE Computed Attributes - 1231
     CLOSED: [2020-10-28 Wed 23:08]
     Re-implement the example in the subsection "Computed Attributes" of the
     section "Properties"
     #+BEGIN_SRC python
       class DescSquare:
           def __init__(self, start):           # Each desc has own state
               self.value = start

           def __get__(self, instance, owner):  # On attr fetch
               return self.value**2

           def __set__(self, instance, value):  # On attr assign
               self.value = value               # No delete or docs

       class Client1:
           x = DescSquare(3)                    # Assign descriptor instance to class attr

       class Client2:
           x = DescSquare(32)                   # Assign descriptor instance to class attr

       c1 = Client1()
       c2 = Client2()

       print(c1.x)                              # 3 ** 2 (9)
       c1.x = 4
       print(c1.x)                              # 4 ** 2 (16)
       print(c2.x)                              # 32 ** 2 (1024)
     #+END_SRC

**** TODO Using State Information in Descriptors - 1232
**** TODO How Properties and Descriptors Relate - 1236
     _NOT from this book_
     From https://docs.python.org/3.6/howto/descriptor.html#properties
     #+BEGIN_SRC python
       class Property(object):
           """Emulate PyProperty_Type() in Objects/descrobject.c"""

           def __init__(self, fget=None, fset=None, fdel=None, doc=None):
               self.fget = fget
               self.fset = fset
               self.fdel = fdel
               if doc is None and fget is not None:
                   doc = fget.__doc__
               self.__doc__ = doc

           def __get__(self, obj, objtype=None):
               if obj is None:
                   return self
               if self.fget is None:
                   raise AttributeError("unreadable attribute")
               return self.fget(obj)

           def __set__(self, obj, value):
               if self.fset is None:
                   raise AttributeError("can't set attribute")
               self.fset(obj, value)

           def __delete__(self, obj):
               if self.fdel is None:
                   raise AttributeError("can't delete attribute")
               self.fdel(obj)

           def getter(self, fget):
               return type(self)(fget, self.fset, self.fdel, self.__doc__)

           def setter(self, fset):
               return type(self)(self.fget, fset, self.fdel, self.__doc__)

           def deleter(self, fdel):
               return type(self)(self.fget, self.fset, fdel, self.__doc__)
     #+END_SRC
     - Without the ~getter~, ~setter~, and ~deleter~, this cannot be used as a
       decorator.

***** TODO Descriptors and slots and more
      =TODO=

*** TODO ~__getattr__~ and ~__getattribute__~ - 1237
    We have learned /properties/ and /descriptors/, which are used to
    *manage* _SPECIFIC_ /attributes/.
      The ~__getattr__~ and ~__getattribute__~ operator *overloading* /methods/
    provide still OTHER WAYS to *intercept* attribute fetches for /class
    instances/.

    - Like /properties/ and /descriptors/,
      they allow us to insert code to be run automatically when attributes are
      accessed.

      + As we'll see, though, these two methods can also be used in _more general
        ways_. =TODO=

      + Because they *intercept* _ARBITRARY_ names, they apply in _BROADER_ roles
        such as /delegation/ =TODO=, =???=
        but may also _incur extra calls_ in some contexts, and are *too dynamic* to
        register in ~dir~ results =TODO=. =???=

    - _Attribute fetch_ *interception* comes in _TWO_ flavors, coded with _TWO_
      DIFFERENT /methods/:
      + ~__getattr__~ is run _for UNDEFINED attributes_ -- its use is STRAIGHTFORWARD,
        because it is run ONLY for /attributes/ *NOT*
        * stored on an /instance/
          OR
        * inherited from one of its /classes/, 

      + ~__getattribute__~ is run _for EVERY attribute_ --
        because it is *all-inclusive*,
        you *must be cautious* when using this /method/ *to*
        *AVOID recursive loops* _by PASSING /attribute accesses/ TO a /superclass/._
        * for example,
          if you use ~__getattribute__~ to get ~self.name~, and you use
          ~self.name~ inside ~__getattribute__~, there is a recursive loops!!!

    - These _TWO_ /methods/ are representatives of a set of /attribute interception/
      /methods/ that also includes ~__setattr__~ and ~__delattr_~.
        Because these methods have _SIMILAR_ roles, though, we will generally
      treat them all as a single topic here.

    - *UNLIKE* /properties/ and /descriptors/,
      these /methods/ are part of /Python's GENERAL operator overloading protocol/.

    - The ~__getattr__~ and ~__getattribute__~ methods are also more _generic_ in
      the sense of *intercepting* access to ANY (or even ALL) instance attribute
      fetches, NOT just a single specific name.
      =TODO= =???=
        Because of this, these two methods are well suited to general
      delegation-based coding patterns - they can be used to implement wrapper
      (a.k.a. /proxy/) objects that manage all attribute accesses for an embedded
      object.

    - These two methods are more _narrowly focused_ -- they do fetch only, NO
      assignments.

      + ~__setattr__~ and ~__delattr__~ must be set to do /assignment/ and /deletion/.

      + You must avoid _recursive loops_ when use ~__setattr__~.

    - By contrast, /properties/ and /descriptors/ catch /get/, /set/, and /delete/
      operations by design.

**** DONE The Basics - 1238
     CLOSED: [2020-10-30 Fri 18:32]
     - Functionalities of /methods/:
       #+begin_src python
         def __getattr__(self, name):        # On undefined attribute fetch [obj.name]
         def __getattribute__(self, name):   # On all attribute fetch [obj.name]
         def __setattr__(self, name, value): # On all attribute assignment [obj.name=value]
         def __delattr__(self, name):        # On all attribute deletion [del obj.name]
       #+end_src
       + ~__getattr__~ and ~__getattribute__~ normally return an _attribute value_.
       + ~__setattr__~ and ~__delattr__~ return ~None~
       + They all can _raise exceptions_ to signal prohibited access.

     - Example 1:
       #+BEGIN_SRC python
         # both Python 2.X and 3.X
         class Catcher:
             def __getattr__(self, name):
                 print('Get: %s' % name)

             def __setattr__(self, name, value):
                 print('Set: %s %s' % (name, value))

         x = Catcher()
         x.job # Prints "Get: job"
         x.pay # Prints "Get: pay"
         x.pay = 99 # Prints "Set: pay 99"
       #+END_SRC

     - Example 2:
       #+BEGIN_SRC python
         # new style class required in Python 2.X
         class Catcher(object):
             def __getattribute__(self, name):
                 print('Get: %s' % name)

             def __setattr__(self, name, value):
                 print('Set: %s %s' % (name, value))
       #+END_SRC

     - Example 3 (delegation):
       #+BEGIN_SRC python
         # from Chapter 31
         class Wrapper:
             def __init__(self, object):
                 self.wrapped = object                    # Save object

             def __getattr__(self, attrname):
                 print('Trace: ' + attrname)              # Trace fetch
                 return getattr(self.wrapped, attrname)   # Delegate fetch

         x = Wrapper([1, 2, 3])
         x.append(4)                                      # Prints "Trace: append"
         print(x.wrapped)                                 # Prints "[1, 2, 3, 4]"
       #+END_SRC

       There is no analog of this for /properties/ and /descriptors/.

***** Avoiding loops in attribute interception methods
      - ~__getattribute__~
        Resolve the loops through fetching the attributes from a higher super class.
        #+BEGIN_SRC python
          def __getattribute__(self, name):
              """Wrong! LOOP!"""
              x = self.other                     # LOOPS!

          # self.name
          # self.other
          # self.other
          # ...


          def __getattribute__(self, name):
              """Right!"""
              x = object.__getattribute__(self, 'other')  # Force higher to avoid loops.
        #+END_SRC

      - ~__setattr__~
        #+BEGIN_SRC python
          def __setattr__(self, name, value):
              "Wrong"
              self.other = value                             # Recurs (and might LOOP!)


          def __setattr__(self, name, value):
              "Right"
              self.__dict__['other'] = value                 # Use attr dict to avoid Recurs


          def __setattr__(self, name, value):
              "Right"
              object.__setattr__(self, 'other', value)       # Force higher to aovid Recurs
        #+END_SRC

      - You mustn't use the ~__dict__~ method to resolve the recurs problem of
        ~__getattribute__~: it will trigger ~__getattribute__~!!!

      - Tips:
        For ~__setattr__~, the ~object.__setattr__~ is more general than the
        ~self.__dict__~ method -- ~object.__setattr__~ can work with /slots/ and
        /properties/ that are NOT physically stored in the instance's ~__dict__~
        namespace dictionary.

**** DONE A First Example - 1241
     CLOSED: [2020-10-31 Sat 00:50]
     #+BEGIN_SRC python
       class Person:                            # Portable: 2.X or 3.X
           def __init__(self, name):            # On [Person()]
               self._name = name                # Triggers __setattr__!

           def __getattr__(self, attr):         # On [obj.undefined_attr]
               print('get: ' + attr)
               if attr == 'name':               # Intercept name: not stored
                   return self._name            # Does not loop: real attr
               else: # Others are errors
                   raise AttributeError(attr)

           def __setattr__(self, attr, value):  # On [obj.any_attr = value]
               print('set: ' + attr)
               if attr == 'name':
                   attr = '_name'               # Set internal name
               self.__dict__[attr] = value      # Avoid looping here

           def __delattr__(self, attr):         # On [del obj.any_attr]
               print('del: ' + attr)
               if attr == 'name':
                   attr = '_name'               # Avoid looping here too
               del self.__dict__[attr]          # but much less common


       bob = Person('Bob Smith')                # bob has a managed attribute
       ## set: _name

       print(bob.name)                          # Runs __getattr__
       ## get: name
       ## Bob Smith

       bob.name = 'Robert Smith'                # Runs __setattr__
       ## set: name

       print(bob.name)                          # Runs __getattr__
       ## get: name
       ## Robert Smith

       del bob.name                             # Runs __delattr__
       ## del: name

       print('-'*20)

       sue = Person('Sue Jones') # sue inherits property too
       ## set: _name

       print(sue.name)
       ## get: name
       ## Sue Jones

       # print(Person.name.__doc__) # No equivalent here
     #+END_SRC
     - The /attribute assignment/ in the ~__init__~ /constructor/
       TRIGGERS
       ~__setattr__~ too -- this method catches *every* /attribute assignment/,
       even those anywhere within the class itself.

     - (To compare with /properties/ and /descriptors/, we have the last commented
       line in the above example code)
       *UNLIKE* with /properties/ and /descriptors/,
       there's NO direct notion of specifying _documentation_ for our attribute here;
       + /managed attributes/ exist *within* the code of our /interception methods/,
         not as DISTINCT /objects/.

***** Using ~__getattribute__~
      To achieve exactly the same results with ~__getattribute__~, replace the
      ~__getattr__~ in the example with
      #+begin_src python
        def __getattribute__(self, attr):               # On [obj.any]
            print(f"get: {attr}"
            if attr == 'name':                          # Intercept all names
                attr = '_name'                          # Map to internal name
            return object.__getattribute__(self, attr)  # Avoid looping here!!!!!!!!!!!
      #+end_src

      - *CAUTION*:
        Because ~__getattribute__~ catches _ALL_ /attributes fetches/,
        + this version must be careful to
          *AVOID* LOOPING *BY* passing new fetches to /superclass/,
          AND
        + it _CAN'T_ generally assume UNKNOWN names are errors.

      - Try with this new version ~Person~:
        #+begin_src python
          bob = Person('Bob Smith')                # bob has a managed attribute
          ## set: _name
          ## get: __dict__

          print(bob.name)                          # Runs __getattr__
          ## get: name
          ## Bob Smith

          bob.name = 'Robert Smith'                # Runs __setattr__
          ## set: name
          ## get: __dict__

          print(bob.name)                          # Runs __getattr__
          ## get: name
          ## Robert Smith

          del bob.name                             # Runs __delattr__
          ## del: name
          ## get: __dict__

          print('-'*20)

          sue = Person('Sue Jones')
          ## set: _name
          ## get: __dict__

          print(sue.name)
          ## get: name
          ## Sue Jones
        #+end_src
        
**** DONE Computed Attributes - 1243
     CLOSED: [2020-10-31 Sat 02:08]
     Nothing special than /properties/ and /descriptors/:
     #+begin_src python
       class AttrSquare:
           def __init__(self, start):
               self.value = start                  # Triggers __setattr__!

           def __getattr__(self, attr):            # On undefined attr fetch
               if attr == 'X':
                   return self.value ** 2
               else:                               # value is not undefined
                   raise AttributeError(attr)

           def __setattr_(self, attr, value):      # On all attr assignments
               if attr == 'X':
                   attr = 'value'
               self.__dict__[attr] = value
     #+end_src
     
***** Using ~__getattribute__~ - 1244
      To use ~__getattribute__~, besides replace ~__getattr__~ with ~__getattribute__~,
      changes the ~__setattr__~ assignment method to *avoid looping* _BY_ using /direct
      superclass method/ calls instead of ~__dict__~ keys:
      #+begin_src python
        class AttrSquare:                           # Add (object) for 2.X
            def __init__(self, start):
                self.value = start                  # Triggers __setattr__!

            def __getattribute__(self, attr):       # On all attr fetches
                if attr == 'X':
                    return self.value ** 2          # Triggers __getattribute__ again!
                else:
                    return object.__getattribute__(self, attr)

            def __setattr__(self, attr, value):     # On all attr assignments
                if attr == 'X':
                    attr = 'value'
                object.__setattr__(self, attr, value)
      #+end_src
      - Notice, the implicit *routing* going on inside this class's methods:
        + ~self.vlaue = start~ inside the /constructor/ TRIGGERS ~__setattr__~
        + ~self.vlaue~ inside ~_getattribute_~ TRIGGERS ~__getattribute__~ again

      - In fact, ~__getattribute__~ is run *twice* each time we fetch /attribute/ ~X~.
        + This does *NOT happen* in the ~__getattr__~ version, because the ~value~
          attribute is _not undefined_.

        + If you care about speed and want to avoid this, change ~__getattribute__~
          to use the /superlcass/ to fetch ~value~ as well:
          #+begin_src python
            def __getattribute__(self, attr):
                if attr == 'X':
                    return object.__getattribute__(self, 'value') ** 2
          #+end_src
          This *STILL* incurs a call to the /superclass method/,
          BUT *NOT* an additional recursive call before we get there.
          Add ~print~ calls to these methods to trace how and when they run.
     
**** DONE ~__getattr__~ and ~__getattribute__~ Compared - 1245
     CLOSED: [2020-10-31 Sat 02:26]
     #+begin_src python
       class GetAttr:
           attr1 = 1

           def __init__(self):
               self.attr2 = 2

           def __getattr__(self, attr):  # On undefined attrs only
               print(f"get: {attr}")     # Not on attr1: inherited from class
               if attr == 'attr3':       # Not on attr2: stored on instance
                   return 3
               else:
                   raise AttributeError(attr)


       x = GetAttr()

       print(x.attr1)
       ## 1

       print(x.attr2)
       ## 2

       print(x.attr3)
       ## 3


       class GetAttribute:
           attr1 = 1

           def __init__(self):
               self.attr2 = 2

           def __getattribute__(self, attr):  # On all attr fetches
               print(f"get: {attr}")          # Use superclass to avoid looping here
               if attr == 'attr3':
                   return 3
               else:
                   return object.__getattribute__(self, attr)

       y = GetAttr()

       print(y.attr1)
       ## get: attr1
       ## 1

       print(y.attr2)
       ## get: attr2
       ## 2

       print(y.attr3)
       ## get: attr3
       ## 3
     #+end_src
     - To summarize the coding differences between ~__getattr__~ and ~__getattribute__~,
       the following example uses both to implement _THREE_ /attributes/:
       + ~attr1~: a /class attribute/
       + ~attr2~: an /instance attribute/
       + ~attr3~: a VIRTUAL /managed attribute/ computed when fetched.

     - Although ~__getattribute__~ can catch *MORE* /attribute fetches/ *than*
       ~__getattr__~, in practice they are often just variations on a theme --
       if /attributes/ are *NOT* _physically stored_,
       the two have the *same* effect.
     
**** TODO Management Techniques Compared - 1246
**** TODO Intercepting Built-in Operation Attributes - 1249
***** Delegation-based managers revisited - 1253

*** TODO Example: Attribute Validations - 1256
**** TODO Using Properties to Validate - 1256
***** TODO Testing code - 1258
      
**** TODO Using Descriptors to Validate - 1259
***** Option 1: Validating with shared descriptor instance state - 1259
***** Option 2: Validating with per-client-instance state - 1261
      
**** TODO Using ~__getattr__~ to Validate - 1263
**** TODO Using ~__getattribute__~ to Validate - 1265

*** TODO Chapter Summary - 1266
*** TODO Test Your Knowledge: Quiz - 1266
*** TODO Test Your Knowledge: Answers - 1267

** TODO 39. Decorators - 1269 - =READING!=
*** DONE What's a Decorator? - 1269
    CLOSED: [2020-04-04 Sat 16:41]
    - /Decoration/ is a way to specify *management* or *augmentation* code for
      /functions/ and /classes/.

    - /Decorators/ themselves take _the form of /callable objects/ (e.g., functions)
      that process other /callable objects/._

    - _TWO_ flavors of Python decorators:
      + /Function decorators/
        * Added in Python 2.4

        * Do name rebinding at function definition time, providing a layer of logic
          that can _manage /functions/ and /methods/, or later calls to them_.

      + Class decorators
        * Added in Python 2.6 and 3.0

        * Do name rebinding at class definition time, providing a layer of logic
          that can _manage /classes/, or the /instances/ created by later calls
          to them._

**** DONE Managing Calls and Instances - 1270
     CLOSED: [2020-04-04 Sat 15:20]
     - Wrapper (a.k.a. proxy):
       + Call proxies (=from Jian= for /functions/)
       + Interface proxies (=from Jian= for /classes/)

     - Decorators achieve these effects by _automatically *rebinding* /function/
       and /class/ names to other callables_, at the end of ~def~ and ~class~
       statements.

**** TODO Managing Functions and Classes - 1270
     - xx
       + /Function managers/
       + /Class managers/

     - xx

**** TODO Using and Defining Decorators - 1271
**** DONE Why Decorators? - 1271
     CLOSED: [2020-04-04 Sat 16:41]
     - /Decorators/ are *NEVER strictly REQUIRED*.
       However, it can help
       + making intent clearer
         A very explicit syntax makes /decorators/ easier to spot than helper
         function calls, which can be arbitrarily far-removed.

       + minimizing augmentation code redundancy
         /decorators/ are applied once at their definition sites.
           Not like helper functions that need to be called everytime there is a
         call to the _decorated objects_.

       + ensuring correct API usage
         For a /decorated objects/, when use them, there is no way to forget related
         helper functions.

     - In other words, beyond their technical model, decorators offer some advantages
       in terms of both code maintenance and consistency. Moreover, as structuring
       tools, decorators naturally foster encapsulation of code, which reduces
       redundancy and makes future changes easier.
       TODO RE-PHRASE

     - Drawbacks: TODO Explore these in code later in this chapter TODO
       Because of insert wrapper logic,
       + Alter the types of the decorated objects;
       + Incur extra calls when used as call proxies or interface proxies.

     - On the other hand, the same considerations apply to any technique that adds
       wrapping logic to objects.

     - *Decorators versus macros*:
       + /Python's decorators/ bear _similarities_ to what some call /aspect-oriented
         programming/ in other languages.

       + /Python's decorator syntax/ also very _closely resembles_ /Java's annotations/,
         though Python's model is usually considered more flexible and general.
         TODO ??? TODO ??? TODO

       + /Decorators/ are a /runtime/ operation, based upon name rebinding.
         Not like /macros/ in other languages that typically associated with
         code generation in /compile time/.
           They are fundamentally different in scope, implementation, and coding
         pattern.

       + /Decorators/ are about /callable objects/ *managing* /callable objects/.

*** TODO The Basics - 1273 - =TODO= =CLASS DECORATORS=
    Let's get started with a _first-pass_ look at _decoration behavior_
    from a _symbolic perspective._

    - We'll write real and more substantial code soon,
      but since
      _most of the magic of /decorators/ boils down to an *automatic rebinding
      operation*,_ it's important to understand this mapping first.

**** DONE Function Decorators - 1273
     CLOSED: [2021-03-14 Sun 04:14]
     - /Function decorators/ have been available in Python *since version 2.4.*

     - /Function decorators/ are largely just /syntactic sugar/ that
       1. _runs one /function/ through another_ at the end of a ~def~ statement, and
       2. *rebinds* the _ORIGINAL function name_ to the result.

***** DONE Usage - 1273
      CLOSED: [2020-10-31 Sat 03:37]
      - A /function decorator/ is a kind of /runtime declaration/ about the function
        whose definition follows.

      - The /decorator/ is coded on _a line *just before* the ~def~ statement_ that
        defines a /function/ or /method/, and it consists of
        1. the ~@~ symbol
           followed by
        2. a reference to a /metafunction/ -- a function (or other /callable object/)
           that *manages another function*.

      - Example:
        #+begin_src python
          @decorator  # Decorate function
          def f(arg):
              ...

          f(99)       # Call function
        #+end_src
        
        This is EQUIVALENT TO
        
        #+begin_src python
          def f(arg):
              ...

          f = decorator(f)  # Rebind function name to decorator result

          f(99)             # Essentially calls `decorator(F)(99)`
        #+end_src

      - This *AUTOMATIC name rebinding* works on any ~def~ statement, whether it's for
        a simple /function/ or a /method within a class/.

      - This *AUTOMATIC name rebinding* accounts for
        the /static method/ and /property decoration/ syntax
        we met earlier in the book:
        #+begin_src python
          class C:
              @staticmethod
              def meth(...): ...   # meth = staticmethod(meth)


          class C:
              @property
              def name(self): ...  # name = property(name)
        #+end_src
        * ~staticmethod~ and ~property~ are Python /built-in function decorator/.

***** DONE Implementation - 1274
      CLOSED: [2020-10-31 Sat 20:23]
      - decorator :: a /callable/ that returns a /callable/.
        * The _returned callable_ will be called through the corresponding
          decorated name.

        * Here the /callable/, a _decorator itself_ or the _returned callable_,
          can be *ANY* /callable/.
            *ANY COMBINATION* of /functions/ and /classes/ may be used, though
          some are better suited to certain contexts.
          
      - In general, a /decorator/ is *defined* and *used* in the way like:
        #+begin_src python
          def decorator(f):
              ...

          @decorator
          def func(): # func = decorator(func)
              ...
        #+end_src
        * Here the /callable/ is a /function/ (other /callable/ also works).

        * Theoretically, a _returned callable_ can be ANY /callable/.
          In practice, mostly, a _returned callable_ must be an /object/ that uses
          the _decorated function ~f~._

      - The _returned callable_ can be:
        * EITHER
          the _ORIGINAL function augmented_ in some way:
          To tap into the /decoration protocol/ in order to *manage* a /function/
          just after it is created, we might code a /decorator/ of this form:
          #+begin_src python
            def decorator(f):
                # Process function `f`
                return f
                # In general, for decorators, here not always return `f` -- see
                # the implementation subsection

            @decorator
            def func():  # func = decorator(func)
                ...
          #+end_src
          + Because the _ORIGINAL decorated function_ is *ASSIGNED BACK* to its name,
            this simply
            *adds* _a post-creation step_ *to* /function definition/.
            - Such a structure might be used to (these usages exploit the run
              *ONLY once* feature mentioned in the next point below, marked with
              =from Jian=)
              * *register* a /function/ *to* an _API_.
              * *assign* /function attributes/,
              * and so on.

          + =from Jian=
            It's easy to notice that the code before th ~return f~ will run
            *ONLY once* for each decorated by ~decorator~ function *at the
            decoration time*.

        * OR (*more typical use*)
          a /wrapper object/ to intercept later calls:
          To *insert* logic that *intercepts* _later calls_ to a _decorated_
          /function/, we might code a /decorator/ to return a _DIFFERENT object_
          than the _original function_ -- a /proxy/ for later calls:
          #+begin_src python
            def decorator(f):
                # Save or use function `f`
                # Return a different callable: nested `def`, `class` with `__call__`, etc.

            @decorator
            def func(): # func = decorator(func)
                ...
          #+end_src
          + This /decorator/ is invoked AT DECORATION TIME, and the /callable/ it
            returns is invoked when the _ORIGINAL function name_ is later called.

          + The /decorator/ itself RECEIVES the /decorated function/;

          + _the /callable/ returned_ receives *whatever arguments are later passed
            to* _the decorated function's name_.

          + When coded properly, this works the same for /class-level methods/:
            the implied /instance object/ simply shows up in the _FIRST argument_
            of the returned /callable/.

      - In skeleton terms, here's one common coding pattern that captures this
        idea -- the /decorator/ returns a /wrapper/ that retains the _ORIGINAL
        function_ in an enclosing scope:
        #+begin_src python
          def decorator(f):        # On @ decoration
              def wrapper(*args):  # On wrapped function call
                  # Use `f` and args
                  # `f(*args)` calls original function

              return wrapper

          @decorator       # `func = decorator(func)`
          def func(x, y):  # `func` is passed to decorator's `f`
              ...

          func(6, 7)  # 6, 7 are passed to wrapper's *args
        #+end_src
        * When the name ~func~ is later called, it really invokes the ~wrapper~
          function returned by ~decorator~; the ~wrapper~ function can then run
          the ORIGINAL ~func~ because it is still available in an /enclosing scope/.
          + When coded this way,
            _each /decorated function/ produces a *new* /scope/ to *retain* /state/._

      - To do the same with /classes/, we can overload ~__call__~ and use /instance
        attributes/ instead of /enclosing scopes/:
        #+begin_src python
          class decorator:
              def __init__(self, func):  # On @ decoration
                  self.func = func

              def __call__(self, *args):  # On wrapped function call
                  # Use `self.func` and `args`
                  # `self.func(*args)` calls original function


          @decorator
          def func(x, y):  # `func = decorator(func)`
              ...          # `func` is passed to `_init_`

          func(6, 7)
        #+end_src
        * Call ~func~ will actually invokes the ~__call__~ /method/ of the
          /instance/ created by ~decorator~; the ~__call__~ /method/ can then
          run the ORIGINAL ~func~ because it is still available in an /instance
          attribute/.

        * When coded this way,
          *EACH* /decorated function/ produces a *NEW* /instance/ to *retain
          state*.

***** DONE Supporting method decoration - 1275
      CLOSED: [2020-10-31 Sat 20:39]
      One subtle point about the prior class-based coding is that
      it *works* to intercept _simple function calls_,
      WHILE it does *NOT quite work* when applied to _class-level method functions_:
      #+begin_src python
        class decorator:
            def __init__(self, func):          # `func` is method without instance
                self.func = func

            def __call__(self, *args):         # `self` is decorator instance
                # `self.func(*args)` fails!    # C instance not in args!


        class C:
            @decorator
            def method(self, x, y):  # `method = decorator(method)`
                ...                  # Rebound to decorator instance
      #+end_src
      When coded this way, the /decorated method/ is *rebound* to /an instance of the
      decorator class/, *instead of* a simple function.

      - The problem with this is that the ~self~ in the decorator's ~__call__~
        receives /the ~decorator~ class instance/ when the /method/ is later
        run, and the /instance/ of /class/ ~C~ is never included in ~*args~.
        This makes it impossible to dispatch the call to the ORIGINAL /method/
        -- the /decorator object/ retains the _original method function_, but it
        has *no /instance/ to pass to it.*

      - To support _BOTH_ /functions/ and /methods/, the /nested function/ alternative
        works better:
        #+begin_src python
          def decorator(f):        # `f` is function or method without instance
              def wrapper(*args):  # class instance in `args[0]` for method
                  ...              # `f(*args)` runs function or method

              return wrapper


          @decorator
          def func(x, y):  # `func = decorator(func)`
              ...

          func(6, 7)       # Really calls `wrapper(6, 7)`


          class C:
              @decorator
              def method(self, x, y):  # `method = decorator(method)`
                  ...                  # Rebound to simple function


          x = C()
          x.method(6, 7)               # Really calls wrapper(x, 6, 7)
        #+end_src
        When coded this way ~wrapper~ receives the ~C~ /class instance/ in its first
        argument, so it can dispatch to the ORGINAL /method/ and *access state
        information*.

        + Technically, this /nested-function/ version works because
          * Python creates a /bound method object/ and thus passes the /subject
            class instance/ to the ~self~ argument only when a /method attribute/
            references a _simple function_;

          * when it references _an instance of a callable class_ instead, the
            /callable class's instance/ is passed to ~self~ to give the
            /callable class/ *access* to its own _state information_.
            =TODO=
            We'll see how this subtle difference can matter in more realistic
            examples later in this chapter.

      - Also *NOTE* that
        1. /nested functions/ are perhaps the *most straightforward way* to SUPPORT
           /decoration/ of *both* /functions/ and /methods/,

        2. BUT *NOT necessarily the ONLY way*.
           The prior chapter's /descriptors/, for example, receive _BOTH_ the
           /descriptor/ and /subject class instance/ when called.
           =TODO= =TODO= =TODO=
           Though more complex, later in this chapter we'll see how this tool
           can be leveraged in this context as well.

**** TODO Class Decorators - 1277
     /Function decorators/ proved so useful that the model was extended to allow
     /class decoration/ as of _Python 2.6 and 3.0_.

     - History:
       1. /class decorators/ were *initially resisted*
          BECAUSE of *role overlap* with /metaclasses/;

       2. In the end, though,
          they were adopted
          BECAUSE they provide a *SIMPLER* way to achieve many of the same
          goals.

     - /Class decorators/ are strongly related to /function decorators/:
       + SAME syntax
       + very SIMILAR coding patterns.

     - _RATHER THAN_ wrapping INDIVIDUAL /functions/ or /methods/, though,
       /class decorators/ are a way to
       + manage /classes/, or
       + wrap up /instance construction calls/ with _extra logic_ that
         _MANAGES_ or _AUGMENTS_ *instances created* from a /class/.

     - In the latter role above, they may manage *FULL* object interfaces.
       =TODO= =TODO= =TODO=
       
***** DONE Usage - 1277
      CLOSED: [2020-11-01 Sun 19:21]
      Syntactically, /class decorators/ appear just before _class definition_, in
      the same way that /function decorators/ appear just before _funciton/method
      definition_.
      
      - In symbolic terms, for a /decorator/ that *MUST be* a /one-argument callable/
        that returns a /callable/.
        #+begin_src python
          @decorator
          class C:
              ...

          x = C(99)
        #+end_src
        
        is equivalent to
        
        #+begin_src python
          class C:
              ...

          C = decorator(C)
          x = C(99)
        #+end_src
        _The net effect_:
        calling the _class name_ later to create an /instance/ winds up triggering
        the callable returned by the /decorator/, which *may or may NOT* call the
        _ORIGINAL class_ itself.

***** DONE Implementation - 1277 - =RE-READ=
      CLOSED: [2020-11-01 Sun 19:51]
      - New /class decorators/ are coded with many of the same techniques used for
        /function decorators/, though some may involve *two levels of augmentation*
        -- to manage both /instance construction/ calls, as well as /instance
        interface access/. Because a /class decorator/ is also a /callable/ that
        returns a /callable/, most combinations of /functions/ and /classes/
        suffice.

      - Usages:
        + Simply MANAGE a /class/ just after it is created, return the _ORIGINAL
          class_ itself:
          #+begin_src python
            def decorator(C):
                # Process class C
                return C

            @decorator
            class C:  # `C = decorator(C)`
                ...
          #+end_src

        + Do more works, and return a *different* callable object:
          #+begin_src python
            def decorator(C):
                # Save or use class C
                # Return a different callable: nested `def`, class with `__call__`, etc.

            @decorator
            class C:  # `C = decorator(C)`
                ...
          #+end_src
          * For example,
            the following inserts an /object/ that intercepts *UNDEFINED* /attributes/
            of a /class instance/:
            #+begin_src python
              def decorator(cls):                   # On @ decoration
                  class Wrapper:
                      def __init__(self, *args):    # On instance creation
                          self.wrapped = cls(*args)

                      def __getattr__(self, name):  # On attribute fetch
                          return getattr(self.wrapped, name)

                  return Wrapper

              @decorator
              class C:                       # C = decorator(C)
                  def __init__(self, x, y):  # Run by Wrapper.__init__
                      self.attr = 'spam'

              x = C(6, 7)    # Really calls Wrapper(6, 7)
              print(x.attr)  # Runs Wrapper.__getattr__, prints "spam"
            #+end_src
            In this example, the decorator rebinds the class name to another
            class, which retains the original class in an enclosing scope and
            creates and embeds an instance of the original class when it’s
            called. When an attribute is later fetched from the instance, it is
            intercepted by the wrapper’s ~__getattr__~ and delegated to the
            embedded instance of the original class. Moreover, each decorated
            class creates a new scope, which remembers the original class. We’ll
            flesh out this example into some more useful code later in this
            chapter. =TODO= =???= =TODO= =???= =TODO=

      - Like /function decorators/, /class decorators/ are commonly coded as either
        _"factory" functions_ that *create* and *return* /callables/, /classes/
        that use ~__init__~ or ~__call__~ /methods/ to *intercept* _call operations_,
        or some combination thereof.
        + /Factory functions/ typically retain /state/ in
          * _enclosing scope references_, and
          * _classes in attributes_.
        
***** TODO Supporting method decoration - 1279
      As for /function decorators/, some /callable type/ COMBINATIONS work better
      for /class decorators/ than others. Consider the following invalid
      alternative to the /class decorator/ of the prior example:
      #+begin_src python
        class Decorator:                      # On `@` decoration
            def __init__(self, C):
                self.C = C

            def __call__(self, *args):        # On instance creation
                self.wrapped = self.C(*args)
                return self

            def __getattr__(self, attrname):  # On attribute fetch
                return getattr(self.wrapped, attrname)


        @Decorator
        class C:     # `C = Decorator(C)`
            ...

        x = C()
        y = C()      # Overwrites `x`!
      #+end_src
      
      - This code handles MULTIPLE /decorated classes/ (each makes a new ~Decorator~
        instance) and will *intercept* _instance creation calls_ (each runs ~__call__~).
        
      - UNLIKE the prior version, however, this version *FAILS to* handle _MULTIPLE
        instances_ of a given /class/ -- each _instance creation call_ *overwrites*
        the prior saved /instance/.
          The original version does support multiple instances, because each
        _instance creation call_ makes a new *independent wrapper object*. More
        generally, either of the following patterns supports multiple wrapped
        instances:
        #+begin_src python
          def decorator(C):                    # On @ decoration
              class Wrapper:
                  def __init__(self, *args):   # On instance creation: new Wrapper
                      self.wrapped = C(*args)  # Embed instance in instance

              return Wrapper


          class Wrapper:
              ...


          def decorator(C):                 # On `@` decoration
              def onCall(*args):            # On instance creation: new `Wrapper`
                  return Wrapper(C(*args))  # Embed instance in instance

              return onCall
        #+end_src

      - We'll study this phenomenon in a more realistic context later in the chapter
        too; in practice, though, we must be careful to combine callable types properly
        to support our intent, and choose state policies wisely.

**** DONE Decorator Nesting - 1279
     CLOSED: [2021-03-16 Tue 03:22]
     Sometimes ONE /decorator/ isn't enough.
     A combination of multiple /decorators/ is required.
     
     - _Decorator syntax_ allows you to add multiple layers of wrapper logic to a
       decorated function or method.
       * When this feature is used,
         *EACH /decorator/ must appear on a line of its own*:
         #+begin_src python
           @A
           @B
           @C
           def f(...):
               ...
         #+end_src
         
         runs the same as the following:
         
         #+begin_src python
           def f(...):
               ...


           f = A(B(C(f)))
         #+end_src
         The last decorator listed is the first applied

     - Just as for functions, multiple class decorators result in multiple nested
       function calls, and possibly multiple levels and steps of wrapper logic
       around _instance creation calls_. For example,
       #+begin_src python
         @spam
         @eggs
         class C:
             ...


         x = C()
       #+end_src
       
       runs the same as the following:
         
       #+begin_src python
         def f(...):
             ...

         f = A(B(C(f)))
       #+end_src

     - =From Jian= 
       The order of decorators can be import in many cases,
       though NOT ALWAYS!

**** DONE Decorator Arguments - 1281
     CLOSED: [2021-03-16 Tue 03:49]
     =from Jian= Actually, I think we can all this section "Decorator Generator
     Arguments" -- the objects that accept arguments are *not* themselves
     /decorators/, in my opinion -- they should be called /decorator generator/.
     
     - By nature, this usually sets up _multiple levels of state retention_.

     - In other words,
       /decorator arguments/ often imply *THREE _levels_ of /callables/:*
       a /callable/ (1) to accept /decorator arguments/,
       which returns a /callable/ (2) to serve as /decorator/,
       which returns a /callable/ (3) to handle calls to the _ORIGINAL
       /function/ or /class/._
         Each of the *THREE levels* may be a /function/ or /class/ and
       may *retain* /state/ in the form of /scopes/ or /class attributes/.

     - /Decorator arguments/ can be used to provide
       =from Jian= =TODO= Find examples for the entries listed below!!! =!!!=
       * attribute initialization values,
       * call trace message labels,
       * attribute names to be validated, and
       * much more -- any sort of
         _configuration parameter_ for objects or their _proxies_ is a candidate.
     
**** DONE Decorators Manage Functions and Classes, Too - 1282
     CLOSED: [2021-03-16 Tue 03:53]
     - =TODO= =???=
       As long as we return the original decorated object this way instead of a
       proxy, we can manage functions and classes themselves, not just later
       calls to them.

     - We'll see more realistic examples later in this chapter that use this idea
       to =TODO= =NEXT=
       * *register* /callable objects/ to an API with decoration and
       * *assign* /attributes/ to /functions/ when they are created.

*** TODO Coding Function Decorators - 1283
    - PLAN =TODO= =NOTE=
      
**** DONE Tracing Calls - 1283 - =TODO= =NOTE=
     CLOSED: [2021-03-16 Tue 04:02]
**** DONE Decorator State Retention Options - 1285 - =TODO= =NOTE=
     CLOSED: [2021-03-16 Tue 04:12]
***** Class instance attributes - 1285
***** Enclosing scopes and globals - 1286
***** Enclosing scopes and nonlocals - 1287
***** Function attributes - 1288

**** TODO Class Blunders I: Decorating Methods - 1289
***** Using nested functions to decorate methods - 1291
***** Using descriptors to decorate methods - 1292

**** TODO Timing Calls - 1295
***** Decorators versus per-call timing - 1297
***** Testing subtleties - 1297

**** TODO Adding Decorator Arguments - 1298
***** Timing with decorator arguments - 1299

*** TODO Coding Class Decorators - 1301
**** TODO Singleton Classes - 1301
***** Coding alternatives - 1302

**** TODO Tracing Object Interfaces - 1303
***** Tracing interfaces with class decorators - 1304
***** Applying class decorators to built-in types - 1306

**** TODO Class Blunders II: Retaining Multiple Instances - 1308
**** TODO Decorators Versus Manager Functions - 1309
**** TODO Why Decorators? (Revisited) - 1310

*** TODO Managing Functions and Classes Directly - 1312
*** TODO Example: "Private" and "Public" Attributes - 1314
**** TODO Implementing Private Attributes - 1314
**** TODO Implementation Details I - 1317
***** Inheritance versus delegation - 1317
***** Decorator arguments - 1317
***** State retention and enclosing scopes - 1317
***** Using ~_dict_~ and ~__slot__~ (and other virtual names) - 1318

**** TODO Generalizing for Public Declarations, Too - 1318
**** TODO Implementation Details II - 1320
***** Using ~__X~ pseudoprivate names - 1321
***** Breaking privacy - 1321
***** Decorator tradeoffs - 1321

**** TODO Open Issues - 1321
***** Caveat: Implicitly run operator overloading methods fail to delegate under 3.X - 1322
***** Approaches to redefining operator overloading methods for 3.X - 1324
****** Inline definition - 1324
****** Mix-in superclasses - 1325
****** Coding variations: Routers, descriptors, automation - 1326

***** Should operator methods be validated? - 1327
****** Implementation alternatives: ~__getattribute__~ inserts, call stack inspection - 1328

**** TODO Python Isn't About Control - 1329

*** TODO Example: Validating Function Arguments - 1330
**** TODO The Goal - 1330
**** TODO A Basic Range-Testing Decorator for Positional Arguments - 1331
**** TODO Generalizing for Keywords and Defaults, Too - 1333
**** TODO Implementation Details - 1336
***** Function introspection - 1336
***** Argument assumptions - 1337
***** Matching algorithm - 1338

**** TODO Open Issues - 1338
***** Invalid calls - 1338
***** Arbitrary arguments - 1339
***** Decorator nesting - 1340

**** TODO Decorator Arguments Versus Function Annotations - 1340
**** TODO Other Applications: Type Testing (If You Insist!) - 1342

*** TODO Chapter Summary - 1343
**** TODO Test Your Knowledge: Quiz - 1344
**** TODO Test Your Knowledge: Answers - 1345

** TODO 40. Metaclasses - 1355
- In a sense, /metaclasses/ simply *extend* the _code-insertion model of
  /decorators/._
  * As we learned, /function decorators/ and /class decorators/ allow us to
    *intercept and augment*
    /function calls/ and /class instance creation calls/.

  * In a similar spirit, /metaclasses/ allow us to *intercept and augment*
    _class creation_ -- they provide an API for inserting extra logic to be
    run at the conclusion of a class statement, albeit _in different ways than
    /decorators/._
    + Accordingly, they provide a _general protocol_ for managing /class objects/
      in a program.

- In practice, /metaclasses/ allow us to
  GAIN a _high level of control_ OVER _how a set of /classes/ works_.

- On the other hand, /metaclasses/ open the door to a variety of coding patterns
  that may be difficult or impossible to achieve otherwise, and they are
  especially of interest to programmers seeking to write _flexible APIs_ or
  programming tools for others to use.

- Also /metaclasses/ can teach you much about /Python's class model/ in general
  (as we'll see, they even impact /inheritance/), and are prerequisite to
  understanding code that employs them.

*** TODO To Metaclass or Not to Metaclass - 1356
    - /Metaclasses/ have a wide variety of potential roles.
      For example,
      * they can be used to *enhance* /classes/ with features like
        + _tracing_,
        + _object persistence_,
        + _exception logging_,
        + and more.

      * they can also be used to
        + *construct* portions of a /class/ _AT RUNTIME_
          based upon _configuration files_,
        + *apply* /function decorators/ to *EVERY* /method/ of a /class/ generically,
        + *verify* conformance to expected /interfaces/,
        + and so on.

    - In their more grandiose incarnations, /metaclasses/ can even be used to
      implement _alternative coding patterns_ such as
      * /aspect-oriented programming/, =???= =TODO= =concept=
      * *object/relational mappers (ORMs)* for databases,
      * and more.

    - Although there are often alternative ways to achieve such results -- as
      we'll see,
      the roles of /class decorators/ and /metaclasses/ OFTEN *intersect* --
      /metaclasses/ provide _a FORMAL model TAILORED_ to those tasks.

    - We DON'T have space to explore all such applications first-hand in this
      chapter. Try to search and learn from the internet.

    - Learning /metaclasses/ can help
      *demystifying Python's class mechanics* in general.

    - =EN=
      cursory understanding

**** DONE Increasing Levels of "Magic" - 1357 - =TODO= =RE-NOTE=
     CLOSED: [2021-03-12 Fri 02:39]
     We've seen a variety of tools that allow us to control Python's behavior
     in generic ways, and that often have more to do with _Python internals_ or
     _tool building_ THAN with _application-programming domains_.

     - As a review, and to help us place /metaclasses/ in the tools spectrum:

       * Introspection attributes and tools
         ~__class__~ and ~__dict__~
         ~dir~ and ~getattr~
         =TODO= =NOTE=

       * Operator overloading methods
         ~__str__~ and ~__add__~
         =TODO= =NOTE=

       * Attribute interception methods
         ~__getattr__~, ~__setattr__~, ~__delattr__~, and ~__getattribute__~
         =TODO= =NOTE=

       * Class properties
         ~property~
         =TODO= =NOTE=

       * Class attribute descriptors
         ~property~
         ~__get__~, ~__set__~, and ~__delete__~
         =TODO= =NOTE=

       * Function and class decorators
         ~@callable~
         =TODO= =NOTE=

       * /Metaclasses/

     - /Metaclasses/ are a CONTINUATION of this story --
       they allow us to *insert* logic to be run AUTOMATICALLY at the
       end of a ~class~ statement, when a /class object/ is being created.

       * THOUGH strongly reminiscent of /class decorators/,
         + _the /metaclass/ mechanism_ does *NOT rebind* the _class name_ to a
           /decorator callable/'s result,
         + BUT rather *routes* _creation of the class_ itself to
           specialized logic.
       
**** TODO A Language of Hooks - 1358 - =NOTE=
**** TODO The Downside of "Helper" Functions - 1359 - =NOTE=
     - 0
       #+begin_src python
         class Extras:
             def extra(self, args):  # Normal inheritance: too static
                 ...

         class Client1(Extras): ...  # Clients inherit extra methods
         class Client2(Extras): ...
         class Client3(Extras): ...

         X = Client1()               # Make an instance
         X.extra()                   # Run the extra methods
       #+end_src

     - 1
       #+begin_src python
         def extra(self, arg): ...

         class Client1: ...          # Client augments: too distributed
         if required():
             Client1.extra = extra

         class Client2: ...
         if required():
             Client2.extra = extra

         class Client3: ...
         if required():
             Client3.extra = extra

         X = Client1()
         X.extra()
       #+end_src

     - 2
       #+begin_src python
         def extra(self, arg): ...

         def extras(Class):          # Manager function: too manual
             if required():
                 Class.extra = extra

         class Client1: ...
         extra(Client1)

         class Client2: ...
         extra(Client2)

         class Client3: ...
         extra(Client3)

         X = Client1()
         X.extra()
       #+end_src

     - 3
       #+begin_src python
         def extra(self, arg): ...

         class Extras(type):
             def __init__(Class, classname, superclasses, attributedict):
                 if required():
                     Class.extra = extra


         class Client1(metaclass=Extras): ...  # Metaclass declaration only (3.X form)
         class Client2(metaclass=Extras): ...  # Client class is instance of meta
         class Client3(metaclass=Extras): ...

         X = Client1()
         X.extra()
       #+end_src

**** TODO Metaclasses Versus Class Decorators: Round 1 - 1361

*** TODO The Metaclass Model - 1364
    Pre-knowledge of understanding /metaclasses/:
    - Python's type model
    - What happens at the end of a ~class~ statement
    
**** TODO Classes Are Instances of type - 1364
     - As we've seen, /instances/ of /classes/
       + have some _state information attributes_ of their own,
       + but they also _inherit behavioral attributes_ from the /classes/ from
         which they are made.

     - While we can get a lot done with such /instance objects/, /Python's type
       model/ turns out to be a bit richer than I've formally described.

       + Really, there's a hole in the model we've seen thus far:
         * Q :: if /instances/ are created from /classes/, what is it that creates
           our /classes/?

         * A :: It turns out that /classes/ are /instances/ of something, too:
           - In Python 3.X,
             /user-defined class objects/ are /instances/ of the object named ~type~,
             which is itself a /class/.

           - In Python 2.X,
             * /new-style classes/ inherit from ~object~, which is a /subclass/ of ~type~;

             * /classic classes/
               + are /instances/ of ~type~ and
               + are NOT created from a /class/.

     - =TODO=
     - =TODO=
     - =TODO=
     - =TODO=
     - =TODO=
     - =TODO=
     - =TODO=
     - =TODO=

**** TODO Metaclasses Are Subclasses of Type - 1366
**** TODO Class Statement Protocol - 1367

*** TODO Declaring Metaclasses - 1368
**** Declaration in 3.X - 1369
**** Declaration in 2.X - 1369
**** Metaclass Dispatch in Both 3.X and 2.X - 1370

*** TODO Coding Metaclasses - 1370
**** A Basic Metaclass - 1371
**** Customizing Construction and Initialization - 1372
**** Other Metaclass Coding Techniques - 1373

*** TODO Inheritance and Instance - 1378
**** Metaclass Versus Superclass - 1381
**** Inheritance: The Full Story - 1382

*** TODO Metaclass Methods - 1388
**** Metaclass Methods Versus Class Methods - 1389
**** Operator Overloading in Metaclass Methods - 1390

*** TODO Example: Adding Methods to Classes - 1391
**** Manual Augmentation - 1391
**** Metaclass-Based Augmentation - 1393
**** Metaclasses Versus Class Decorators: Round 2 - 1394

*** TODO Example: Applying Decorators to Methods - 1400
**** Tracing with Decoration Manually - 1400
**** Tracing with Metaclasses and Decorators - 1401
**** Applying Any Decorator to Methods - 1403
**** Metaclasses Versus Class Decorators: Round 3 (and Last) - 1404

*** TODO Chapter Summary - 1407
*** TODO Test Your Knowledge: Quiz - 1407
*** TODO Test Your Knowledge: Answers - 1408

** 41. All Good Things - 1409
*** The Python Paradox - 1409
**** On "Optional" Language Features - 1410
**** Against Disquieting Improvements - 1411
**** Complexity Versus Power - 1412
**** Simplicity Versus Elitism - 1412
**** Closing Thoughts - 1413

*** Where to Go From Here - 1414
*** Encore: Print Your Own Completion Certificate! - 1414

* Part IX. Appendixes
** A. Installation and Configuration - 1421
*** Installing the Python Interpreter 1421
**** Is Python Already Present? 1421
**** Where to Get Python 1422
**** Installation Steps 1423

*** Configuring Python 1427
**** Python Environment Variables 1427
**** How to Set Configuration Options 1429
**** Python Command-Line Arguments 1432
**** Python 3.3 Windows Launcher Command Lines 1435

*** For More Help 1436

** B. The Python 3.3 Windows Launcher - 1437
*** The Unix Legacy 1437
*** The Windows Legacy 1438
*** Introducing the New Windows Launcher 1439
*** A Windows Launcher Tutorial 1441
**** Step 1: Using Version Directives in Files 1441
**** Step 2: Using Command-Line Version Switches 1444
**** Step 3: Using and Changing Defaults 1445

*** Pitfalls of the New Windows Launcher 1447
**** Pitfall 1: Unrecognized Unix ~!#~ Lines Fail 1447
**** Pitfall 2: The Launcher Defaults to 2.X 1448
**** Pitfall 3: The New PATH Extension Option 1449

*** Conclusions: A Net Win for Windows 1450

** C. Python Changes and This Book - 1451
*** Major 2.X/3.X Differences 1451
**** 3.X Differences 1452
**** 3.X-Only Extensions 1453

*** General Remarks: 3.X Changes 1454
**** Changes in Libraries and Tools 1454
**** Migrating to 3.X 1455

*** Fifth Edition Python Changes: 2.7, 3.2, 3.3 1456
**** Changes in Python 2.7 1456
**** Changes in Python 3.3 1457
**** Changes in Python 3.2 1458

*** Fourth Edition Python Changes: 2.6, 3.0, 3.1 1458
**** Changes in Python 3.1 1458
**** Changes in Python 3.0 and 2.6 1459
**** Specific Language Removals in 3.0 1460

*** Third Edition Python Changes: 2.3, 2.4, 2.5 1462
*** Earlier and Later Python Changes 1463

** D. Solutions to End-of-Part Exercises - 1465
*** Part I, Getting Started 1465
*** Part II, Types and Operations 1467
*** Part III, Statements and Syntax 1473
*** Part IV, Functions and Generators 1475
*** Part V, Modules and Packages 1485
*** Part VI, Classes and OOP 1489
*** Part VII, Exceptions and Tools 1497

* Index
