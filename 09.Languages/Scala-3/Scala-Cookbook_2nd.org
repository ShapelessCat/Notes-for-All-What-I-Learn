#+TITLE: Scala Cookbook
#+SUBTITLE: Recipes for Object-Oriented and Functional Programming
#+VERSION: 2nd, 2021
#+AUTHOR: Alvin Alexander
#+STARTUP: overview
#+STARTUP: entitiespretty

* Preface - xiii
** The Scala 3 Language - xiii
*** Scala Features - xv
*** Scala Feel Light and Dynamic - xvi
*** Audience - xvii
*** Contents of This Book - xvii
*** Installing Scala - xxi
*** Conventions in This Book - xxi
*** Support - xxii

** Conventions Used in This Book - xxii
** Using Code Examples - xxiii
** O'Reilly Online Learning - xxiv
** How to Contact Us - xxiv
*** Acknowledgements - xxv

* 1. Command-Line Tasks - 1
** TODO 1.1. Getting Started with the Scala REPL - 3
*** Problem
*** Solution
**** Tab completion
     
*** Discussion
*** See Also

** TODO 1.2. Loading Source Code and JAR Files into the REPL - 6
*** Problem
*** Solution
*** Discussion

** TODO 1.3. Getting Started with the Ammonite REPL - 8
*** Problem
*** Solution
*** Discussion
   
** TODO 1.4. Compiling with =scalac= and Running with =scala= - 11
*** Problem
*** Solution
*** Discussion
**** Main methods

** TODO 1.5. Disassembling and Decompiling Scala Code - 13
*** Problem
*** Solution
**** Using ~javap~

*** Discussion
*** See Also

** TODO 1.6. Running JAR Files with Scala and Java - 17
*** Problem
*** Solution
*** Discussion
**** Why use sbt-assembly?
     
*** See Also
   
* 2. Strings
*** Scala ~String~ Features
**** ~String~'s are a sequence of characters
     
*** Chaining Method Calls Together
**** Where do those methods come from?

** DONE 2.1. Testing String Equality
   CLOSED: [2018-03-01 Thu 19:12]
*** DONE Problem
    CLOSED: [2018-03-01 Thu 19:08]
*** DONE Solution
    CLOSED: [2018-03-01 Thu 19:08]
    - Use ~==~, NOT like Java.

    - Since use ~==~, also NOT like Java, there is no longer
      ~java.lang.NullPointerException~

    - To compare two strings while ignoring their case, you can
      + ~str1.toUpperCase == str2.toUpperCase~

        *CAUTION*: Since you call method on ~str1~ and ~str2~, the
        ~java.lang.NullPointerException~ may show up again.

      + fall back to Java
        ~str1.equalsIgnoreCase(str2)~

*** DONE Discussion
    CLOSED: [2018-03-01 Thu 19:12]
    - In Scala, the ~==~ /method/ defined in the ~AnyRef~ class
      1. It first checks for ~null~ values,
      2. then it calls the ~equals~ /method/ on the first object (i.e., this) to
         see if the two objects are equal.

      As a result, you don't have to check for ~null~ values when comparing
      strings.

    - In *idiomatic Scala*, you _NEVER_ use ~null~.

    - =REDO= See Recipe 4.15 "Defining an equals Method (Object Equality)".

*** See Also
    
** DONE 2.2. Creating Multiline Strings
   CLOSED: [2018-03-01 Thu 19:44]
*** DONE Problem
    CLOSED: [2018-03-01 Thu 19:40]
    
*** DONE Solution
    CLOSED: [2018-03-01 Thu 19:40]
    Use _three double quotes_:
    #+BEGIN_SRC scala
      val foo = """This is
      a multiline
      String"""
    #+END_SRC

*** DONE Discussion
    CLOSED: [2018-03-01 Thu 19:44]
    You cannot expect left end alignment when you do something like
    #+BEGIN_SRC scala
      val foo = """This is
                   a multiline
                   String"""
    #+END_SRC
    The second and third lines will have _prefixed spaces_.

    - *SOLUTION*
      #+BEGIN_SRC scala
        val speech = """Four score and
                       |seven years ago
                       |our fathers""".stripMargin


        val speech1 = """Four score and
                        #seven years ago
                        #our fathers""".stripMargin('#')
      #+END_SRC

** DONE 2.3. Splitting Strings
   CLOSED: [2018-03-01 Thu 19:02]
*** DONE Problem
    CLOSED: [2018-03-01 Thu 07:15]
*** DONE Solution
    CLOSED: [2018-03-01 Thu 07:15]
    The ~split~ method of ~String~ (acutally, ~String~ or ~StringLike~).

*** DONE Discussion
    CLOSED: [2018-03-01 Thu 19:02]
**** About that ~split~ method...
     - The ~split~ method is _overloaded_, with some versions of the method
       coming from the _Java ~String~ class_ and some coming from the _Scala
       ~StringLike~ class_.

** DONE 2.4. Substituting Variables into Strings
   CLOSED: [2018-03-01 Thu 22:12]
*** DONE Problem
    CLOSED: [2018-03-01 Thu 19:45]
*** DONE Solution
    CLOSED: [2018-03-01 Thu 21:21]
    Since Scala 2.10, you can use /string interpolation/

    - Basic /string interpolation/
      + use ~s~ method
      + use ~$~ to insert variable
      + use ~${variableName}~ to eliminate ambiguity.

      #+BEGIN_SRC scala
        val name = "Fred"
        val age = 33
        val weight = 200.0

        println(s"$name is $age years old, and weighs $weight pounds.")
        // Fred is 33 years old, and weighs 200.0 pounds.
      #+END_SRC

**** DONE Using expressions in string literals
     CLOSED: [2018-03-01 Thu 20:56]
     - the official string interpolation documentation:
       #+BEGIN_QUOTE
       Any arbitrary expression can be embedded in ~${}~.
       #+END_QUOTE

     - Wrap /object fields/ in curly braces, or there will be a wrong
       interpretation.
       #+BEGIN_SRC scala
         // error: this is intentionally wrong

         println(s"$hannah.name has a score of $hannah.score")
         // Student(Hannah,95).name has a score of Student(Hannah,95).score
       #+END_SRC

*** DONE Discussion
    CLOSED: [2018-03-01 Thu 22:10]
    - Prior to version 2.10, Scala didn't include the /string interpolation/
      functionality just described. Use ~format~ /method/.

    - =From Jian=
      I think there is an error in the
      Table 1-1. Common printf style format sepcifiers

      There should be no ~%u~ format specifier !?!?
      NOT 100% sure.
      
    - The ~s~ that's placed before each string literal is actually a /method/.

    - This seems not as convenient as the other languages that use interploation
      as default, but it has at least _two benefits_:
      * Scala provides other off-shelf interpolation funcitons to give you more
        power.

      * You can define your own string interpolation functions.

**** DONE The ~f~ string interpolator (~printf~ style formatting)
     CLOSED: [2018-03-01 Thu 21:07]
     #+BEGIN_SRC scala
       println(f"$name is $age years old, and weighs $weight%.2f pounds.")
       // Fred is 33 years old, and weighs 200.00 pounds.

       ////  and then with no decimal places:
       println(f"$name is $age years old, and weighs $weight%.0f pounds.")
       // Fred is 33 years old, and weighs 200 pounds.

       // For fields
       case class S(i: Int, d: Double)
       val s = S(1, 200.03)
       println(f"${s.i}, ${s.d}%.0f")
       // Only variable names can be inside the ${}
       // You can't use `${s.d%.0f}`
     #+END_SRC

**** DONE The ~raw~ interpolator
     CLOSED: [2018-03-01 Thu 21:21]
     /The official string interpolation documentation/ for ~raw~:
     #+BEGIN_QUOTE
     performs no escaping of literals within the string.
     #+END_QUOTE

     - Example:
       #+BEGIN_SRC scala
         s"foo\nbar"
         // foo
         // bar

         raw"foo\nbar"
         // foo\nbar
       #+END_SRC

     - _Triple double quote_ also performs no escaping of literals within the
       string, and you can instert newline literally without escaping.

     - Both ~raw~ and _triple double quote_ are especially useful when you work
       with Regex.

     - =TODO= =???=
       =Now is 2.12, how about this feature now?=
       String interpolation does not work with pattern-matching statements
       in Scala 2.10. This feature is planned for inclusion in Scala 2.11.

*** TODO See Also

** DONE 2.5. Formatting String Output
   CLOSED: [2020-11-19 Thu 01:21]
*** DONE Problem
    CLOSED: [2020-11-19 Thu 00:50]
    Format string output, including strings that contain
    - integers
    - floats
    - doubles
    - characters

*** DONE Solution
    CLOSED: [2020-11-19 Thu 01:13]
    Use ~printf~-style formatting strings with /the ~f~ interpolator/.
    
    - Many configuration options are shown in the following examples.

    - Note:
      Data/time formatting - Recipe 2.12

**** DONE Formatting strings
     CLOSED: [2020-11-19 Thu 00:50]
     #+begin_src scala
       val h = "Hello"

       f"'${h}%s'"       // 'Hello'
       f"'${h}%10s'"     // '     Hello'
       f"'${h}%-10s'"    // 'Hello     '
     #+end_src
     The ~{}~'s here are optional, they are there only for better readability.
     
**** DONE Formatting floating-point numbers
     CLOSED: [2020-11-19 Thu 00:53]
     /Floating-point numbers/ are printed with the ~%f~ /format specifier/.
     Here are several examples that show the effects of formatting
     floating-point numbers, including ~Double~ and ~Float~ values:
     #+begin_src scala
       val a = 10.3456         // a: Double = 10.3456
       val b = 101234567.3456  // b: Double = 1.012345673456E8

       f"'${a}%.1f'"     // '10.3'
       f"'${a}%.2f'"     // '10.35'
       f"'${a}%8.2f'"    // '   10.35'
       f"'${a}%8.4f'"    // ' 10.3456'
       f"'${a}%08.2f'"   // '00010.35'
       f"'${a}%-8.2f'"   // '10.35   '

       f"'${b}%-2.2f'"   // '101234567.35'
       f"'${b}%-8.2f'"   // '101234567.35'
       f"'${b}%-14.2f'"  // '101234567.35  '
     #+end_src
     The same syntax as above works with ~Float~ values.
     
**** DONE Integer formatting
     CLOSED: [2020-11-19 Thu 00:56]
     /Integers/ are printed with /the ~%d~ format specifier/.
     #+begin_src scala
       val ten = 10
       f"'${ten}%d"    // '10'
       f"'${ten}%5d"   // '   10'
       f"'${ten}%-5d"  // '10   '

       val maxInt = Int.MaxValue
       f"'${maxInt}%5d"  // '2147483647'

       val maxLong = Long.MaxValue
       f"'${maxLong}%5d'"    // '9223372036854775807'
       f"'${maxLong}%22d'"   // '   9223372036854775807'
     #+end_src
     
**** DONE Zero-fill integer options
     CLOSED: [2020-11-19 Thu 01:04]
     #+begin_src scala
       val zero = 0
       val one = 1
       val negTen = -10
       val bigPos = 12345
       val bigNeg = -12345
       val maxInt = Int.MaxValue

       // non-negative integers
       f"${zero}%03d"      // 000
       f"${one}%03d"       // 001
       f"${bigPos}%03d"    // 12345
       f"${bigPos}%08d"    // 00012345
       f"${maxInt}%08d"    // 2147483647
       f"${maxInt}%012d"   // 002147483647

       // negative integers
       f"${negTen}%03d"    // -10
       f"${negTen}%05d"    // -0010
       f"${bigNeg}%03d"    // -12345
       f"${bigNeg}%08d"    // -0012345
     #+end_src
     
**** DONE Character formatting
     CLOSED: [2020-11-19 Thu 01:06]
     /Characters/ are printed with /the ~%c~ format specifier/.
     #+begin_src scala
       val s = 's'
       f"|${s}%c|"    // |s|
       f"|${s}%5c|"   // |    s|
       f"|${s}%-5c|"  // |s    |
     #+end_src
     
**** DONE ~f~ works with multiline strings
     CLOSED: [2020-11-19 Thu 01:12]
     It's important to note that /the ~f~ interpolator/ works with _multiline
     strings_, as shown in this example:
     #+begin_src scala
       val n = "Al"
       val w = 200.0
       val s = f"""Hi, my name is ${n}
         |and I weigh ${w}%.1f pounds.
         |""".stripMargin.replaceAll("\n", " ")

       println(s)
       // Hi, my name is Al and I weigh 200.0 pounds.
     #+end_src
     As noted in Recipe 1.2, there is no need to escape single- and double-quotes
     when using multiline strings (triple-quoted).
     
*** DONE Discussion
    CLOSED: [2020-11-19 Thu 01:18]
    - Table 1-1. Common printf style format specifiers
      Not mentioned before this section:
      * ~%e~: Exponential floating-point number 

      * ~%i~: Integer (base 10)
      * ~%o~: Octal number (base 8)
      * ~%x~: Hexadecimal number (base 16)

      * ~%u~: Unsigned decimal (integer) number
      
    - Escape ~%~, ~$~, and ~\~ inside a string with /the ~f~ interpolator/:
      #+begin_src scala
        f"%%"  // %
        f"$$"  // $
        f"\\"  // \
      #+end_src

    - Table 1-2 shows special characters you can use when formatting string output.
      
*** TODO See Also
    The The ~java.util.Formatter~ /class/ documentation shows all of the
    available /formatting characters/.

** DONE 2.6. Processing a String One Character at a Time
   CLOSED: [2018-03-01 Thu 01:08]
*** DONE Problem
    CLOSED: [2018-02-28 Wed 22:22]
*** DONE Solution
    CLOSED: [2018-02-28 Wed 22:21]
    ~map~, ~foreach~, for-loop, for-iteration
**** Transformers
**** Side effects
**** Working on string bytes

*** DONE Discussion
    CLOSED: [2018-03-01 Thu 01:08]
    Corresponding Java code (if not use ~Stream~):
    #+BEGIN_SRC java
      String s = "Hello";
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < s.length(); i++) {
          char c = s.charAt(i);
          // do something with the character ...
          // sb.append ...
      }
      String result = sb.toString();
    #+END_SRC

**** ~for~ + ~yield~
**** Transformer methods
**** Side effect approaches
     
*** TODO A complete example
*** TODO See Also

** DONE 2.7. Finding Patterns in Strings
   CLOSED: [2018-03-01 Thu 22:20]
*** TODO Problem
*** TODO Solution
    Use the ~r~ method of string to create ~Regex~, and then use the
    ~findFirstIn~ or the ~findAllIn~ methods to get the result.

    - ~findFirstIn~ returns an ~Option[String]~ result.

    - ~findAllIn~ returns an /iterator/ result.

*** TODO Discussion 
    You can also use the ~scala.util.matching.Regex~ more explicity.
    For example, ~new Regex(raw"[0-9]+")~
    
**** A brief discussion of the ~Option~ returned by  ~findFirstIn~

*** TODO See Also- 20

    



    


** 2.8. Replacing Patterns in Strings
*** DONE Problem
    CLOSED: [2018-03-01 Thu 22:22]
*** DONE Solution
    CLOSED: [2018-03-01 Thu 22:27]
    Two kinds of solutions:
    - ~String~ /method/:
      #+BEGIN_SRC scala
        val address = "123 Main Street"

        address.replaceAll(raw"[0-9]", "x")
        // xxx Main Street

        address.replaceFirst(raw"[0-9]", "x")
        // x23 Main Street
      #+END_SRC

    - ~Regex~ /method/
      #+BEGIN_SRC scala
        val address = "123 Main Street"
        val regex = raw"[0-9]".r

        regex.replaceAllIn(address, "x")
        // xxx Main Street

        regex.replaceFirstIn(address, "x")
        // x23 Main Street
      #+END_SRC

*** TODO See Also
    
** DONE 2.9. Extracting Parts of a String That Match Patterns
   CLOSED: [2018-03-01 Thu 22:39]
*** DONE Problem 
    CLOSED: [2018-03-01 Thu 22:32]
*** DONE Solution
    CLOSED: [2018-03-01 Thu 22:32]
    #+BEGIN_SRC scala
      val pattern = "([0-9]+) ([A-Za-z]+)".r
      val pattern(count, fruit) = "100 Bananas"
      // count: String = 100
      // fruit: String = Bananas
    #+END_SRC

*** DONE Discussion
    CLOSED: [2018-03-01 Thu 22:39]
*** TODO See Also

** DONE 2.10. Accessing a Character in a String
   CLOSED: [2018-03-01 Thu 22:41]
*** DONE Problem
    CLOSED: [2018-03-01 Thu 22:39]
*** DONE Solution
    CLOSED: [2018-03-01 Thu 22:41]
    - Java use the way of ~"hello".charAt(0)~, and Scala do it like ~"hello"(0)~.
*** DONE Discussion
    CLOSED: [2018-03-01 Thu 22:41]
    Scala actully call the ~apply~ method.
    ~"hello"(0)~ is converted to ~"hello".apply(0)~ in the background.

** TODO 2.11. Creating Your Own String Interpolator
*** DONE Problem
    CLOSED: [2020-11-19 Thu 01:45]
    Create your own /string interpolator/.
    
*** TODO Solution
    To create _YOUR OWN_ /string interpolator/, create an /implicit class/ that
    adds your /method/ to the ~StringContext~ /class/.

    - Your /class/ will take a ~StringContext~ /constructor parameter/, and define
      a /method/ that handles the behavior you want.
      To demonstrate this I'll share a string interpolator I wrote.
    
**** TODO BACKGROUND
**** TODO UNDERSTANDING THE SOLUTION
**** TODO SOURCE CODE FOR THE SOLUTION
     - Implementation: =TODO= =TRY-THIS-CODE=
       #+begin_src scala
         object QInterpolator {
           extension (sc: StringContext)
           def Q(expressions: Any*): Seq[String] = {
             // for my purpose I can just put the original string back together
             // by calling the `s` interpolator
             val originalString: String = sc.s(expressions: _*)
             originalString.split("\n")
               .toVector
               .map(_.trim)
               .filter(_ != "")
           }
         }
       #+end_src
       Here's an explanation of this code:
       The code adds a NEW /method/ named ~Q~ to the ~StringContext~ /class/.
       * As shown in the earlier source code, the StringContext constructor takes
         a variable number of parameters. While it’s not shown in this current
         code, those parameters are embedded in the sc input parameter that
         QHelper receives. (You can see the strings that sc contains by calling
         sc.parts, which returns a Seq[String].)
         =TODO= =???= =TODO=
       
       * The ~expressions~ variable contains a sequence of the /expressions/ that
         were in the _original string_.
           Note that these /expressions/ have *ALREADY* been evaluated *BEFORE*
         they're passed in here.
       
       * For the purposes of ~Q~, I take a simple solution and put the original
         string back together by calling /the ~s~ interpolator/ of the
         ~StringContext~ /instance/ ~sc~.
       
       * In the ~sc.s(expressions: _*)~ code, the ~_*~ operator converts ~expressions~,
         which is a ~WrappedArray~, into a list of _SEPARATE_ /arguments/, because the
         ~s~ method requires a ~String*~ /varargs parameter/.
       
       * After that initial processing work the final line of code that includes
         ~split~, ~toVector~, ~map~, and ~filter~ is run.
       
     - In the ~listOfFruits~ example, by the time the final line of code receives
       ~originalString~, it's a _multiline string_ that looks like this:     
       #+begin_src scala
         """
             apple
             banana
             cherry
         """
       #+end_src
     
*** TODO Discussion
*** TODO See Also

** TODO 2.12. Creating Random Strings
*** DONE Problem
    CLOSED: [2020-11-19 Thu 01:41]
    When you try to generate a /random string/ using the ~nextString~ /method/ of
    the ~Random~ /class/ you see a lot of unusual output or ~?~ characters.
    For instance:
    #+begin_src scala
      val r = new scala.util.Random
      // val r: scala.util.Random = scala.util.Random@360d41d0
      
      r.nextString(10)
      // res0: String = ??????????
    #+end_src
    
*** DONE Solution
    CLOSED: [2020-11-19 Thu 01:41]
    What's happening with ~nextString~ is that it returns /Unicode characters/,
    which may or may _not display well on your system_.
      To generate *only* _alphanumeric characters_ — the letters ~[A-Za-z]~ and
    the numbers ~[0-9]~ — use this approach:
    #+begin_src scala
      import scala.util.Random

      Random.alphanumeric.take(10).mkString  // 7qowB9jjPt
      Random.alphanumeric.take(10).mkString  // a0WylvJKmX
    #+end_src
    ~Random.alphanumeric~ returns a ~LazyList~.
    
*** DONE Discussion
    CLOSED: [2020-11-19 Thu 01:35]
    If you want a *wider range* of characters, the ~nextPrintableChar~ /method/
    returns values in _the ASCII range 33-126_.

    - This includes almost every simple character on your keyboard, including
      * letters
      * numbers
      * characters like !, -, +, ], >, etc.

    - See http://www.asciitable.com/ or a similar website for the complete list
      of characters in that range.

**** Lazy methods
     
*** See Also
      


* DONE 3. Numbers and Dates
  CLOSED: [2021-08-14 Sat 21:18]
*** Underscores in Numeric Literals
*** Complex Numbers
*** Dates and Times
    
** DONE 3.1. Parsing a Number from a String
   CLOSED: [2018-02-28 Wed 17:16]
*** DONE Problem
    CLOSED: [2018-02-28 Wed 17:05]
*** DONE Solution
    CLOSED: [2018-02-28 Wed 17:05]
    - Use ~toXXX~ pattern /methods/ for ~Short~, ~Int~, ~Long~, ~Float~, and
      ~Double~.

    - Use the ~apply~ /method/ of ~BigInt~ and ~BigDecimal~.
      #+BEGIN_SRC scala
        BigInt("1")

        BigInt("3.14159")
      #+END_SRC

**** Handling a base and radix - 33
     - You need to use Java's method to solve this problem.
       #+BEGIN_SRC scala
         Integer.parserInt("1", 2)
       #+END_SRC

     - You can also create /implict class/ with a ~toInt~ method with ~radix~
       parameter.
       #+BEGIN_SRC scala
         implicit class StringToInt(s: String) {
           def toInt(radix: Int) = Integer.parseInt(s, radix)
         }
       #+END_SRC

*** DONE Discussion
    CLOSED: [2018-02-28 Wed 17:16]
    - If your scala code, which includes ~String~ to numbers conversion, will be
      used by Java, you'd better take care of the ~NumberFormatException~ with
      the ~@throws~ annotation.

    - For scala itself, you can use ~Option~ or ~Try~ (since Scala 2.10).
      =From Jian= For dealing with exceptions, I think ~Try~ is better.
      #+BEGIN_SRC scala
        def toIntOpt(s: String): Option[Int] =
          try {
            Some(s.toInt)
          } catch {
            case e: NumberFormatException => None
          }

      #+END_SRC

**** Alternatives to ~Option~
     ~Try~ (since Scala 2.10) or ~Either~

*** TODO See Also

** DONE 3.2. Converting Between Numeric Types (Casting)
   CLOSED: [2018-02-28 Wed 15:55]
*** DONE Problem
    CLOSED: [2018-02-28 Wed 15:52]
*** DONE Solution
    CLOSED: [2018-02-28 Wed 15:53]
    - ~toByte~
    - ~toChar~
    - ~toDouble~
    - ~toFloat~
    - ~toInt~
    - ~toLong~
    - ~toShort~
    - ~toString~

*** DONE Discussion
    CLOSED: [2018-02-28 Wed 15:54]
    If you want to _avoid potential conversion errors_ when casting from one
    numeric type to another, you can use the related ~isValidXXXX~.
      For example, ~a.isValidByte~

*** TODO See Also

** DONE 3.3. Overriding the Default Numeric Type
   CLOSED: [2018-02-28 Wed 16:06]
*** DONE Problem
    CLOSED: [2018-02-28 Wed 16:02]
*** DONE Solution
    CLOSED: [2018-02-28 Wed 16:02]
    #+BEGIN_SRC scala
      // Method 1
      val a = 1D
      val b = 1F

      // Method 2 (type ascription)
      val c = 1 : Double
      val d = 1 : Long

      // Method 3 (For simple variable initialization, Method 3 is prefered)
      val c: Double = 1
      val d: Long = 1
    #+END_SRC

*** DONE Discussion
    CLOSED: [2018-02-28 Wed 16:06]
    - You can use the *underscore* character as a placeholder when assigning an
      initial value.
      #+BEGIN_SRC scala
        class Foo {
          var a: Short = 0
          var b: Short = _  // defaults to 0
        }
      #+END_SRC

      This works when creating /class variables/, but *does NOT work in other
      places*, such as inside a method.

    - For numeric types this isn't an issue -- you can just assign the type the
      value zero -- but with most other types, you can use this approach inside a
      method: ~var name = null.asInstanceOf[String]~

*** TODO See Also

** DONE 3.4. Replacements for ~++~ and ~−−~ - 39
   CLOSED: [2018-02-28 Wed 15:16]
*** DONE Problem - 40
    CLOSED: [2018-02-28 Wed 15:16]
    Find the replacement of ~++~ and ~--~, which are NOT supported by Scala.

*** DONE Solution - 41
    CLOSED: [2018-02-28 Wed 15:14]
    Use the /methods/ like ~+=~ and ~-=~.

    =From Jian=
    Like Java, Scala doesn't support operator overloading.

    However, operators in Java like ~+~ and ~-~ are /methods/ in Scala, and you
    can overload them.

*** DONE Discussion - 41
    CLOSED: [2018-02-28 Wed 15:16]
    /Methods/ like ~+=~ and ~-=~ are more general then ~++~ and ~--~.
    You can use them with non-integer types.

*** TODO See Also - 41

** DONE 3.5. Comparing Floating-Point Numbers - 41
   CLOSED: [2018-02-28 Wed 15:31]
*** DONE Problem - 41
    CLOSED: [2018-02-28 Wed 15:24]
    Like most other languages that use IEEE standard to save floating numbers,
    Scala also cannot compare floating numbers directly. Then how to do it in
    Scala

*** DONE Solution - 41
    CLOSED: [2018-02-28 Wed 15:23]
    Use a funcition like
    #+BEGIN_SRC scala
      def ~=(x: Double, y: Double, tolerance: Double) =
        (x - y).abs < tolerance
    #+END_SRC

*** DONE Discussion - 42
    CLOSED: [2018-02-28 Wed 15:30]
    How to use the ~~=~ function in the Solution section?

    + Write it in an utility object.
      As a function with three parameters, alphabetical names, like
      ~approximatelyEqual~ or ~equalWithinTolerance~, might be better.


    + Use a default ~tolerance~ setting, create an implicit conversion to
      floating numbers, and use ~+=~ as an infix-operator-like /method/.

*** TODO See Also - 43

** DONE 3.6. Handling Large Numbers - 43
   CLOSED: [2018-02-28 Wed 17:25]
*** DONE Problem - 43
    CLOSED: [2018-02-28 Wed 17:19]
*** DONE Solution - 43
    CLOSED: [2018-02-28 Wed 17:19]
    ~BigInt~ and ~BigDecimal~
    Unlike their Java equivalents, these classes support all the operators
    (actually operator-like methods) you're used to using with numeric types:
    #+BEGIN_SRC scala
      var b = BigInt(1234567890)
      val bb = b + b
      b += 1
    #+END_SRC

*** DONE Discussion - 44
    CLOSED: [2018-02-28 Wed 17:25]
    - Although the Scala ~BigInt~ and ~BigDecimal~ classes are backed by the Java
      ~BigInteger~ and ~BigDecimal~ classes, they are simpler to use than their
      Java counterparts.

    - Before using ~BigInt~ or ~BigDecimal~, you may want to check the range of
      the non-Big numeric types like:
      #+BEGIN_SRC scala
        Byte.MaxValue    // 127
        Short.MaxValue   // 32767
        Int.MaxValue     // 2147483647
        Long.MaxValue    // 9223372036854775807
        Double.MaxValue  // 1.7976931348623157E308

        Double.PositiveInfinity  // Infinity
        Double.NegativeInfinity  // -Infinity

        // CAUTION: compare floating numbers simply with `>`, `<`, and `==` is NOT a good
        //          idea!
        1.7976931348623157E308 > Double.PositiveInfinity  // false
      #+END_SRC

*** TODO See Also - 45

** DONE 3.7. Generating Random Numbers - 45
   CLOSED: [2018-02-28 Wed 17:02]
*** DONE Problem - 45
    CLOSED: [2018-02-28 Wed 16:33]
*** DONE Solution - 45
    CLOSED: [2018-02-28 Wed 16:38]
    Use ~scala.util.Random~ class
    #+BEGIN_SRC scala
      val r = scala.util.Random

      r.nextInt

      r.nextInt(100)  // with limit 0 (inclusive) and 100 (exclusive)

      r.nextFloat

      r.nextDouble

      // Set the seed value using an `Int` or `Long`
      // 1. When new an instance
      val rr = new scala.util.Random(100)

      // 2. After the creation of an `Random` instance
      val rrr = new scala.util.Random
      rrr.setSeed(1000L)
    #+END_SRC

*** DONE Discussion - 46
    CLOSED: [2018-02-28 Wed 17:01]
    - The ~Random~ class handles all the usual use cases.
      For example, generate random characters ~r.nextPrintableChar~

    - Random-length ranges:
      ~0 to r.nextInt(10)~

    - Random number collections (with bound):
      ~(1 to 5).map(_ => r.nextInt(100))~

*** TODO See Also - 47

** DONE 3.8. Formatting Numbers and Currency - 49
   CLOSED: [2018-02-28 Wed 18:05]
*** DONE Problem - 49
    CLOSED: [2018-02-28 Wed 18:00]
*** DONE Solution - 49
    CLOSED: [2018-02-28 Wed 17:43]
    :LOGBOOK:
    CLOCK: [2018-02-28 Wed 17:57]--[2018-02-28 Wed 18:22] =>  0:25
    :END:
    - For basic number formatting, use ~f~ string interpolator. For example,
      #+BEGIN_SRC scala
        val pi = scala.math.Pi

        println(f"$pi%1.5f")   // 3.14159
        println(f"$pi%1.2f")   // 3.14
        println(f"$pi%06.2f")  // 003.14
      #+END_SRC

      + Prior to Scala 2.10, you don't have the ~f~ string interpolator.
        You need to use the ~format~ method like ~"%06.2f".format(pi)~.

      + Use ~java.text.NumberFormat.getIntegerInstance~ to add commas to numbers
        for clarity.
        #+BEGIN_SRC scala
          val formatter = java.text.NumberFormat.getIntegerInstance

          formatter.format(10000)
          // res0: String = 10,000
          formatter.format(1000000)  // 1,000,000
          // res1: String = 1,000,000
        #+END_SRC

        * You can also set a locale with the ~getIntegerInstance~ /method/
          #+BEGIN_SRC scala
            val locale = new java.util.Locale("de", "DE")
            val formatter = java.text.NumberFormat.getIntegerInstance(locale)
            formatter.format(1000000)
            //res2: String = 1.000.000
          #+END_SRC

        * You can also handle floating numbers:
          #+BEGIN_SRC scala
            val formatter = java.text.NumberFormat.getInstance
            formatter.format(10000.33)
            // res0: String = 10,000.33
          #+END_SRC

    - For /currency/ output, use the ~getCurrencyInstance~ formatter:
      #+BEGIN_SRC scala
        val formatter = java.text.NumberFormat.getCurrencyInstance

        println(formatter.format(123.456789))
        // $123.46

        println(formatter.format(1234.56789))
        // $1,234.57

        println(formatter.format(12345.6789))
        // $12,345.68

        println(formatter.format(123456.789))
        // $123,456.79
      #+END_SRC

      + For international currency:
        #+BEGIN_SRC scala
          import java.util.{Currency, Locale}

          val de = Currency.getInstance(new Locale("de", "DE"))
          // de: java.util.Currency = EUR

          formatter.setCurrency(de)
          println(formatter.format(123456.789))
          // EUR123,456.79
        #+END_SRC

*** DONE Discussion - 51
    CLOSED: [2018-02-28 Wed 18:04]
    This recipe falls back to the Java approach for dealing with /currency/.

    In the experience of the author of this book, as a consultant, most companies
    he know use Java ~BigDecimal~ to process currency, and others create their
    own custom currency classes, which are typically wrappers around ~BigDecimal~.

*** TODO See Also - 51
    - JSR 354

** DONE 3.9. Creating New Date and Time Instances
** DONE 3.10. Calculating the Difference Between Two Dates
   CLOSED: [2018-02-28 Wed 15:46]
*** DONE Problem - 47
    CLOSED: [2018-02-28 Wed 15:43]
*** DONE Solution - 47
    CLOSED: [2018-02-28 Wed 15:43]
    - ~1 to 10~

    - ~1 to 10 by 2~

    - ~1 until 10~

    - ~1 until 10 by 2~

*** DONE Discussion - 48
    CLOSED: [2018-02-28 Wed 15:46]
    - ~Range~ can be converted to ~List~ and ~Array~ easily.
      Just use the ~toListl~ and ~toArray~ method.

    - You are actually invoking the ~to~ or ~until~ method of ~RichInt~.
      Scala help you to implictly do the converstion from ~Int~ to ~RichInt~.

*** TODO See Also - 49

** DONE 3.11. Formatting Dates
** DONE 3.12. Parsing Strings into Dates
   
* DONE 4. Control Structures - 53
  CLOSED: [2021-08-14 Sat 23:31]
*** ~for~ Loops and ~for~ Expressions
*** ~if~ / ~then~ / ~else~ - ~if~ Expressions
*** ~match~ Expressions and Pattern Matching
*** ~try~ / ~catch~ / ~finally~ Blocks
*** ~while~ Loops
*** Control Structures as a Defining Feature of Programming Languages
    
** TODO 4.1. Looping Over Data Structures with ~for~
*** DONE Problem
    CLOSED: [2017-07-18 Tue 12:03]
*** DONE Solution
    CLOSED: [2017-07-18 Tue 12:09]
   - Loops in Scala:
     + ~for~ loop
     + ~while~ loop
     + collection methods:
       * ~foreach~
       * ~map~
       * ~flatMap~, and more

   - This section concentrate on ~for~ loop and ~foreach~ method.

**** DONE Returning values from a for loop
     CLOSED: [2017-07-18 Tue 12:04]
     ~yield~

**** DONE ~for~ loop counters
     CLOSED: [2017-07-18 Tue 12:07]
     #+BEGIN_SRC scala
       for (i <- 0 until a.length) {
         println(s"$i is ${a(i)}")
       }

       for ((e, count) <- a.zipWithIndex) {
         println(s"$count is $e")
       }
     #+END_SRC

     =TODO= Recipe 10.11 ~zipWithIndex~
**** DONE Generators and guards
     CLOSED: [2017-07-18 Tue 12:07]
     ~Range~
     #+BEGIN_SRC scala
       for (i <- 1 to 3) println(i)

       // With guard
       for (i <- 1 to 10 if i < 4) println(i)
     #+END_SRC
**** DONE Looping over a Map
     CLOSED: [2017-07-18 Tue 12:09]
     #+BEGIN_SRC scala
       for ((k,v) <- names) println(s"key: $k, value: $v")
     #+END_SRC

     =TODO= Recipe 11.17, "Traversing a Map"
*** DONE Discussioin
    CLOSED: [2017-07-18 Tue 13:40]
**** DONE How ~for~ loops are translated
     CLOSED: [2017-07-18 Tue 13:40]
     - A _simplification_ of the rules in /Scala Language Specification/:
       1. a ~for~ loop on a collection -> ~foreach~ method;

       2. a ~for~ loop with a guard -> a ~withFilter~ methods call on the
          collection followed by a ~foreach~ call;

       3. a ~for~ comprehension -> ~map~ method;

       4. a ~for~ comprehension with a guard -> a ~withFilter~ methods call on
          the collection followed by a ~map~ call;

     - Example:
       #+BEGIN_SRC scala
         class Main {
           for (i <- 1 to 10) println(i)
         }

         // In CLI:
         // scalac -Xprint:parse Main.scala

         // [[syntax trees at end of parser]] // Main.scala
         // package <empty> {
         //   class Main extends scala.AnyRef {
         //     def <init>() = {
         //       super.<init>();
         //       ()
         //     };
         //     1.to(10).foreach(((i) => println(i)))
         //   }
         // }
       #+END_SRC

     - ~-Xprint:parse~ shows the result after the first step.

     - ~-Xprint:all~ shows the result after all steps in the compilation process.

** DONE 4.2. Using for Loops with Multiple Counters - 60
   CLOSED: [2017-07-18 Tue 13:45]
*** DONE Problem
    CLOSED: [2017-07-18 Tue 13:45]

*** DONE Solution
    CLOSED: [2017-07-18 Tue 13:44]
    #+BEGIN_SRC scala
      val array = Array.ofDim[Int](2, 2)
      array(0)(0) = 0
      array(0)(1) = 1
      array(1)(0) = 2
      array(1)(1) = 3

      for {
        i <- 0 to 1
        j <- 0 to 1
      } println(s"($i)($j) = ${array(i)(j)}")
    #+END_SRC

*** DONE Discussion
    CLOSED: [2017-07-18 Tue 13:45]

** DONE 4.3. Using a for Loop with Embedded if Statements (Guards) - 62
   CLOSED: [2017-07-18 Tue 13:47]
*** Problem
*** Solution
*** Discussion
** TODO 4.4. Create a New Collection From an Existing Collection With ~for~ / ~yield~ - 63
*** Problem
*** Solution
*** Discussion
** DONE 4.5. Using the ~if~ Construct Like a Ternary Operator - 71
   CLOSED: [2017-07-19 Wed 01:09]
*** Problem
*** Solution
*** Discussion
** DONE 4.6. Using a Match Expression Like a switch Statement - 72
   CLOSED: [2017-07-19 Wed 02:07]
*** DONE Problem
    CLOSED: [2017-07-19 Wed 02:03]
*** DONE Solution
    CLOSED: [2017-07-19 Wed 02:03]
**** DONE The ~@switch~ annotation
     CLOSED: [2017-07-19 Wed 02:03]
     Issue a warning if the pattern matching can't be compiled to ~tableswitch~
     or ~lookupswitch~.

     ~tableswitch~ and ~lookupswitch~ have good performance, because they are
     /branch tables/ rather than /decision trees/. They use _jump_ rather than
     walk through the decision tree.

     - Example: =SwitchDemo.scala= Version _1_, which has no warning.
       #+BEGIN_SRC scala
         // Version 1 - compiles to a tableswitch
         import scala.annotation.switch

         class SwitchDemo {
           val i = 1
           val x = (i: @switch) match {
             case 1 => "One"
             case 2 => "Two"
             case _ => "Other"
           }
         }
       #+END_SRC
       =SwitchDemo.scala= can be compiled without warnings

       The output of ~javap -c SwitchDemo~
       #+BEGIN_SRC text
         16:  tableswitch{ //1 to 2
                     1: 50;
                     2: 45;
                     defalut: 40 }
       #+END_SRC

     - Example: =SwitchDemo.scala= Version _2_, which has a warning.
       #+BEGIN_SRC scala
         // Version 2 - leads to a compiler warning
         import scala.annotation.switch

         class SwitchDemo {
           val i = 1
           val Two = 2  // added compared to Ver 1
           val x = (i: @switch) match {
             case 1 => "One"
             case Two => "Two"   // replaced the '2'
             case _ => "Other"
           }
         }
       #+END_SRC

       ~scalac SwitchDemo.scala~ will issue a warning:
       #+BEGIN_SRC text
         SwitchDemo.scala:7: warning: could not emit switch for @switch annotated match
         val x = (i: @switch) match {
         ^
         one warning found
       #+END_SRC

     - Rules (from the book *Scala In Depth* by Joshua Suereth) for Scala to
       apply the ~tableswitch~ optimization:
       1. The matched value must be a known integer

       2. The matched expression must be "simple". It can't contain any type
          checks, if statements, or extractors.

       3. The expression must also have its value available at compile time.

       4. There should be more than two ~case~ statements.

     - =From Jian= Where are the rules for ~lookupswitch~???

*** DONE Discussion
    CLOSED: [2017-07-19 Wed 02:07]
**** DONE Handling the default case
     CLOSED: [2017-07-19 Wed 02:05]
     =TODO= Recipe 9.8, "Creating Partial Functions".
**** DONE Do you really need a switch statement?
     CLOSED: [2017-07-19 Wed 02:07]
     Use ~Map~.

     #+BEGIN_SRC scala
       val monthNumberToName = Map(
         1 -> "January",
         2 -> "February",
         3 -> "March",
         4 -> "April",
         5 -> "May",
         6 -> "June",
         7 -> "July",
         8 -> "August",
         9 -> "September",
         10 -> "October",
         11 -> "November",
         12 -> "December"
       )

       val monthName = monthNumberToName(4)
       println(monthName) // prints "April"
     #+END_SRC

** DONE 4.7. Matching Multiple Conditions with One Case Statement - 76
   CLOSED: [2017-07-19 Wed 02:08]
*** DONE Problem
    CLOSED: [2017-07-19 Wed 02:09]
*** DONE Solution
    CLOSED: [2017-07-19 Wed 02:09]
    Use ~|~ to separate patterns
*** DONE Discussion
    CLOSED: [2017-07-19 Wed 02:09]

** DONE 4.8. Assigning the Result of a Match Expression to a Variable - 77
   CLOSED: [2017-07-19 Wed 02:11]
*** Problem
*** Solution
*** Discussion

** DONE 4.9. Accessing the Value of the Default Case in a Match Expression - 78
   CLOSED: [2017-07-19 Wed 02:12]
*** DONE Problem
    CLOSED: [2017-07-19 Wed 02:11]

*** DONE Solution
    CLOSED: [2017-07-19 Wed 02:11]
    In the last case use a name, rather than ~_~.

*** DONE Discussion
    CLOSED: [2017-07-19 Wed 02:12]

** DONE 4.10. Using Pattern Matching in Match Expressions - 79
   CLOSED: [2018-03-01 Thu 23:35]
*** DONE Problem - 79
    CLOSED: [2018-03-01 Thu 22:44]
    You need to match one or more patterns in a match expression, and the
    pattern may be a
    - constant pattern
    - variable pattern
    - constructor pattern
    - sequence pattern
    - tuple pattern
    - type pattern

*** DONE Solution - 79
    CLOSED: [2018-03-01 Thu 23:02]
    - Use ~_*~ to match the tail of a sequence:
      #+BEGIN_SRC scala
        case List(1, _*) => "a list beginning with 1, having any number of elements"
        case Vector(1, _*) => "a vector starting with 1, having any number of elements"
      #+END_SRC

    - Use /type wildcard/ to match arbitrary type:
      #+BEGIN_SRC scala
        case list: List[_] => s"thanks for the List: $list"
        case m: Map[_, _] => m.toString
      #+END_SRC

      =IMPORTANT=
      This is not mandatory! You can use type like ~List[x]~ to annotate your
      pattern. However, due to /type erasure/ in the JVM, nothing you can do with
      the ~x~. Therefore, before JVM solves this problem, there is NO reason to
      a named variable to match the actually erased type.

    - *Tips*: =IMPORTANT=
      About /type erasure/, if you write something like
      ~case l: List[Int] => "List"~, the Scala compiler will give you a warning
      #+BEGIN_QUOTE
      Test1.scala:7: warning: non-variable type argument Int in type pattern
      List[Int] is unchecked since it is eliminated by erasure
          case l: List[Int] => "List[Int]"
      #+END_QUOTE

      =From Jian=
      Before JVM solves the /type erasure/ problem, /generics type annotation/ in
      pattern matching is useless!

*** DONE Discussion - 82
    CLOSED: [2018-03-01 Thu 23:27]
**** DONE Patterns - 82
     CLOSED: [2018-03-01 Thu 23:21]
**** DONE Adding variables to patterns - 84
     CLOSED: [2018-03-01 Thu 23:21]
     - ~case list @ List(1, _*) => s"$list"~

     - ~case List(1, tl @ _*) => s"$list"~

**** DONE Using ~Some~ and ~None~ in match expressions - 85
     CLOSED: [2018-03-01 Thu 23:27]
     - =From Jian=
       Mostly you work with ~Option~ type and ~Try~ type with ~map~, ~flatMap~,
       and ~foreach~. Only when you try to get the inside value out, you may use
       /pattern matching/.

     - =From Jian=
       The /wave-particle duality/ of ~Option~'s and ~Try~'s:
       + particle: When you want to interact with them, use /pattern matching/.

       + wave: when you want them to propagate, use ~map~, ~flatMap~, and
         ~foreach~.

*** TODO See Also - 86
    =IMPORTANT=

** DONE 4.11. Using Enums and Case Classes in Match Expressions - 86
   CLOSED: [2017-07-19 Wed 02:13]
*** DONE Problem - 86
    CLOSED: [2018-03-01 Thu 22:49]
*** DONE Solution - 86
    CLOSED: [2018-03-01 Thu 22:49]

** DONE 4.12. Adding if Expressions (Guards) to Case Statements - 87
   CLOSED: [2017-07-19 Wed 02:13]
*** Problem
*** Solution
*** Discussion

** DONE 4.13. Using a Match Expression Instead of ~isInstanceOf~ - 88
   CLOSED: [2017-07-19 Wed 02:31]
*** DONE Problem
    CLOSED: [2017-07-19 Wed 02:28]

*** DONE Solution
    CLOSED: [2017-07-19 Wed 02:28]
    ~if (x.isInstanceOf[Foo]) { do something ... }~
    NOT ALWAYS BAD! This is good ONLY for some simple cases.

    For most situations use the TWO solutions listed below:
    #+BEGIN_SRC scala
      // 1
      def isPerson(x: Any): Boolean = x match {
        case p: Person => true
        case _ => false
      }



      // 2: case classes extended from some base class
      trait SentientBeing
      trait Animal extends SentientBeing
      case class Dog(name: String) extends Animal
      case class Person(name: String, age: Int) extends SentientBeing

      def printInfo(x: SentientBeing) = x match {
        case Person(name, age) => // handle the Person
        case Dog(name) => // handle the Dog
      }
    #+END_SRC

*** DONE Discussion
    CLOSED: [2017-07-19 Wed 02:30]

** DONE 4.14. Working with a List in a Match Expression - 89
   CLOSED: [2017-07-19 Wed 02:31]
*** Problem
*** Solution
*** Discussion

** DONE 4.15. Matching One or More Exceptions with ~try~ / ~catch~ - 91
   CLOSED: [2017-07-19 Wed 02:43]
*** DONE Problem
    CLOSED: [2017-07-19 Wed 02:32]

*** DONE Solution
    CLOSED: [2017-07-19 Wed 02:34]
    The Scala ~try/catch/finally~ syntax is _similar_ to Java,
    BUT it uses the _match expression approach_ in the ~catch~ block:
    #+BEGIN_SRC scala
      val s = "Foo"

      try {
        val i = s.toInt
      } catch {
        case e: Exception => e.printStackTrace
        // case ...
      }
    #+END_SRC
*** DONE Discussion
    CLOSED: [2017-07-19 Wed 02:43]
    A catch-all ~try ... catch~ should use a type ~Throwable~ case variable,
    rather than just ~_~ with no type specified.

    (NOTE form Jian: ~Throwable~ is a super class of ~Exception~,
     as well as ~Error~)

    #+BEGIN_SRC scala
      try {
        openAndReadAFile("foo")
      } catch {
        case t: Throwable => t.printStackTrace()
      }
    #+END_SRC

    If you prefer to declare the exceptions that your method throws,
    or you need to interact with Java,
    add the ~@throws~ annotation to your method definition:
    #+BEGIN_SRC scala
      @throws(classOf[NumberFormatException])
      def toInt(s: String): Option[Int] =
        try {
          Some(s.toInt)
        } catch {
          case e: NumberFormatException => throw e
        }
    #+END_SRC

** DONE 4.16. Declaring a Variable Before Using It in a ~try~ / ~catch~ / ~finally~ Block - 92
   CLOSED: [2017-07-19 Wed 02:53]
*** Problem
*** Solution
    #+BEGIN_SRC scala
      import java.io._

      object CopyBytes extends App {
        var in = None: Option[FileInputStream]
        var out = None: Option[FileOutputStream]
        try {
          in = Some(new FileInputStream("/tmp/Test.class"))
          out = Some(new FileOutputStream("/tmp/Test.class.copy"))
          var c = 0
          while ({c = in.get.read; c != −1}) {
            out.get.write(c)
          }
        } catch {
          case e: IOException => e.printStackTrace
        } finally {
          println("entered finally ...")
          if (in.isDefined) in.get.close
          if (out.isDefined) out.get.close
        }
      }
    #+END_SRC
*** Discussion

** DONE 4.17. Creating Your Own Control Structures - 95
   CLOSED: [2018-03-01 Thu 23:53]
*** DONE Problem - 95
    CLOSED: [2018-03-01 Thu 23:38]
*** DONE Solution - 95
    CLOSED: [2018-03-01 Thu 23:42]
    - =From Jian= Summary
      When _defining_ it, combine the features of
      + /funciton definition/

      + /currying/
        Since it is a control structure, you don't want to evaluate all parts of
        it when you see its header. Or else, this is NOT a control structure --
        a real control structure is used to decide what to do and what not to do,
        rather than do them all.

      + /lazy parameter(s)/
        The body of the control structure shouldn't be evaluated when the
        condition in the header isn't fulfilled.

    - For example,
      #+BEGIN_SRC scala
        package com.alvinalexander.controls

        import scala.annotation.tailrec


        object Whilst {
          // 2nd attempt
          @tailrec
          def whilst(testCondition: => Boolean)(codeBlock: => Unit) {
            if (testCondition) {
              codeBlock
              whilst(testCondition)(codeBlock)
            }
          }
        }
      #+END_SRC

    - When _using_ it, use the feature that function can accept /code blocks/ as
      parameters

    - For example
      #+BEGIN_SRC scala
        package foo

        import com.alvinalexander.controls.Whilst._


        object WhilstDemo extends App {

          var i = 0

          whilst (i < 5) {
            println(i)
            i += 1
          }

        }
      #+END_SRC

*** DONE Discussion - 96
    CLOSED: [2018-03-01 Thu 23:53]
    #+BEGIN_SRC scala
      def doubleif(test1: => Boolean)(test2: => Boolean)(codeBlock: => Unit) {
        if (test1 && test2) {
          codeBlock
        }
      }


      doubleif(age > 18)(numAccidents == 0) {
        println("Discount!")
      }
    #+END_SRC

* DONE 5. Classes
  CLOSED: [2021-08-14 Sat 23:38]
*** Classes and Case Classes
** 5.1. Choosing from Domain Modeling Options
** 5.2. Creating a Primary Constructor
** 5.3. Controlling the Visibility of Constructor Fields 
** 5.4. Defining Auxiliary Constructors for Classes
   
** DONE 5.5. Defining a Private Primary Constructor
   CLOSED: [2022-05-18 Wed 16:42]
*** Problem - 112
    How to make the /primary constructor/ of a /class/ *private*,
    such as to _ENFORCE the /singleton pattern/?_

*** Solution - 112
    #+begin_src scala
      // a private no-args primary constructor
      class Order private {
        // ...
      }

      // a private one-arg primary constructor
      class Person private (name: String) {
          //...
      }
    #+end_src
    The way to remember this syntax: just read the code out loud as you scan it,
    "This is a ~Person~ class with a *private constructor*...".

*** Discussion - 112
    - Example of the /Singleton pattern/ in Scala
      #+begin_src scala
        class Brain private {
          override def toString = "This is the brain."
        }

        object Brain {
          val brain = new Brain
          def getInstance = brain
        }

        object SingletonTest extends App {
          // this won't compile
          // val brain = new Brain

          // this works
          val brain = Brain.getInstance
          println(brain)
        }
      #+end_src
      The name of the accessor method ~getInstance~ follows a Java convention, and
      you *don't need* to follow it in Scala.

    - *Companion Objects*
      A /companion object/ can be used for several purposes.
      For example, see
      * _Recipe 7.4, “Creating Static Members with Companion Objects”_,
        for more information on creating the equivalent of /Java's static methods/,
        =TODO=

      * _Recipe 7.6, “Implementing a Static Factory with apply”_,
        for examples of *how* (and *why*) to define ~apply~ methods in a
        /companion object/.
        =TODO=
    
    - =from Jian=
      Another use case:
      Combine the /private constructor/ and ~apply~ method, a class can simulate
      a function -- this is similar to the usage of the ~__call__~ in Python:
      #+begin_src scala
        class A private (x: Int) {
          def theOnlyPublicAPI: Int = process

          private def process: Int = ???  // process `x`
        }

        object A {
          def apply(x: Int): Int =
            new A(x).theOnlyPublicAPI
        }


        val result: Int = A(3)
      #+end_src
      You can also make the ~A~ /companion object/ a instance of a function type:
      ~object A extends (Int => Int) { ... }~.

**** Utility classes - 113
     Java has some /utility classes/, which only contain definitions of /static
     methods/.

     Scala doesn't need this, it can define a /singleton object/ DIRECTLY with ~object~.

** DONE 5.6. Providing Default Values for Constructor Parameters
   CLOSED: [2022-05-18 Wed 16:51]
*** Problem - 114
*** Solution - 114
    #+begin_src scala
      class Socket(val timeout: Int = 10000)

      val s1 = Socket()
      s1.timeout  // 10000

      val s2 = Socket(5000)  // Or Socket(timeout = 5000)
      s2.timeout  // 5000
    #+end_src

*** Discussion - 114
    This recipe demonstrates a powerful feature that can
    *ELIMINATE the need for /auxiliary constructors/.*

    - Example:
      With a default value, the single constructor in the "Solution" section is
      _the EQUIVALENT of *two* constructors without default values_:
      * In Scala
        #+begin_src scala
          class Socket(val timeout: Int) {

            def this() = this(10000)  // Here the `()` is mandatory!!!

            override def toString = s"timeout: $timeout"
          }
        #+end_src

      * In Java
        #+begin_src java
          class Socket {
              final int timeout;

              public Socket() {
                  this.timeout = 10000;
              }

              public Socket(int timeout) {
                  this.timeout = timeout;
              }
          }
        #+end_src

**** DONE Multiple parameters - 115
     CLOSED: [2022-05-18 Wed 16:51]

**** DONE Using named parameters - 115
     CLOSED: [2022-05-18 Wed 16:51]

*** See Also - 115
    Recipe 4.3, "Defining Auxiliary Constructors", for more information on
    creating /auxiliary class constructors/

** DONE 5.7. Handling Constructor Parameters When Extending a Class
   CLOSED: [2020-04-30 Thu 12:15]
*** Problem - 124
*** Solution - 124
    #+begin_src scala
      class Person(var name: String, var address: Address) {
        override def toString = if (address == null) name else s"$name @ $address"
      }

      class Employee(name: String, address: Address, var age: Int) extends Person(name, address)
    #+end_src
*** Discussion - 125
    We use =javap= to check the generated code:
    #+begin_src java
      // Compiled from "Person.scala"
      public class Person {
          public java.lang.String name();
          public void name_$eq(java.lang.String);
          public Address address();
          public void address_$eq(Address);
          public java.lang.String toString();
          public Person(java.lang.String, Address);
      }

      // Compiled from "Person.scala"
      public class Employee extends Person {
          public Employee(java.lang.String, Address);
      }
    #+end_src
    - Here you can't see the /getters/ and /setters/ for ~name~ and ~address~,
      because for ~Empolyee~ you declare them without ~var~ or ~val~ and
      ~Employee~ inherits them from ~Person~.

** DONE 5.8. Calling a Superclass Constructor
   CLOSED: [2020-05-01 Fri 01:24]
*** Problem - 127
    How to control the /superclass constructor/ that's called when you create
    /subclass constructors/?

*** Solution - 127
    - This is a bit of a trick question, because
      + you *CAN* CONTROL the /superclass constructor/ that's called by _the /primary
        constructor/ in a /subclass/,_

      + but you *CANNOT* CONTROL the /superclass constructor/ that's called by _an
        /auxiliary constructor/ in the /subclass/._

    - The /subclass primary constructor/ can call any /superclass constructor/:
      #+begin_src scala
        // Primary constructor
        class Animal(val name: String, val age: Int) {
          // Auxiliary constructor
          def this(name: String) {
            this(name, 0)
          }

          override def toString = s"$name is $age years old"
        }
      #+end_src
      Then you can define its /subclass/ ~Dog~ as:
      + Call the _two-arg_ /primary constructor/ of ~Animal~
        #+begin_src scala
          class Dog(name: String) extends Animal(name, 0) {
            println("Dog constructor called")
          }
        #+end_src

      + Call the _one-arg_ /auxiliary constructor/ of ~Animal~
        #+begin_src scala
          class Dog(name: String) extends Animal(name) {
            println("Dog constructor called")
          }
        #+end_src

**** Auxiliary constructors - 128
     - Regarding (/subclass/) /auxiliary constructors/,
       because *the FIRST LINE of an /auxiliary constructor/ must be a call to
       ANOTHER /constructor/ of the CURRENT /class/,* there is no way for
       /auxiliary constructors/ to call a /superclass constructor/.
       + In fact, because EACH /auxiliary constructor/ MUST call a _previously
         defined_ /constructor/ in the SAME /class/, all /auxiliary constructors/
         will *eventually* call the SAME /superclass constructor/ that's called
         from the /subclass/'s /primary constructor/.
         * =from Jian=
           However, since every constructor has their own settings (the reason
           why these constructors exist), *eventually* here is _COMPLETELY
           different from_ *directly*.


     - Example:
       #+begin_src scala
         // from Jian: I modify the code from the book to make it more idiomatic
         final case class Address(city: String, state: String)

         final case class Role(role: String)

         class Person(val name: String, val address: Option[Address]) {
           // no way for `Employee` auxiliary constructors to call this constructor
           def this(name: String) {
             this(name, None)
           }

           override def toString =
             address
               .map(a => s"$name @ $a")
               .getOrElse(name)
         }

         class Employee(name: String, address: Option[Address], val role: Option[Role]) extends Person(name, address) {
           def this(name: String) {
             this(name, None, None)
           }

           def this(name: String, role: Option[Role]) {
             this(name, role, None)
           }

           def this(name: String, address: Option[Address]) {
             this(name, None, address)
           }
         }
       #+end_src

** TODO 5.9. Defining an ~equals~ Method (Object Equality)
*** Problem - 140
*** Solution - 140
*** Discussion - 141
**** Theory - 142

*** See Also - 143

** TODO 5.10. Preventing Accessor and Mutator Methods from Being Generated - 119
** DONE 5.11. Overriding Default Accessor and Mutators
   CLOSED: [2020-04-30 Thu 04:08]
*** Problem - 116
*** Solution - 116
    - WRONG WAY (can't compile):
      #+begin_src scala
        // error: this won't work
        class Person(private var name: String) {
          // this line essentially create a circular reference
          def name = name

          def name_=(aName: String) { name = aName }
        }
        // Person.scala:3: error: overloaded method name needs result type
        //   def name = name
        //              ^
        // Person.scala:4: error: ambiguous reference to overloaded definition,
        // both method name_= in class Person of type (aName: String)Unit
        // and method name_= in class Person of type (x$1: String)Unit
        // match argument types (String)
        //   def name_=(aName: String) { name = aName }
        //                               ^
        // Person.scala:4: error: method name_= is defined twice
        //   def name_=(aName: String) { name = aName }
        //       ^
        // three errors found
      #+end_src

    - The right way with a naming convention in Scala:
      #+begin_src scala
        class Person(private var _name: String) {
          def name = _name

          def name_=(aName: String) { _name = aName }
        }
      #+end_src

*** Discussion - 117
    - ~class Stock (var symbol: String)~
      The output of =javap Stock=
      #+begin_src java
        public class Stock extends java.lang.Object {
            public java.lang.String symbol();
            public void symbol_$eq(java.lang.String);
            public Stock(java.lang.String);
        }
      #+end_src

**** Summary - 118
     - As shown in the Solution,
       the recipe for *overriding* default /getter and setter methods/ is:
       1. Create a /private ~var~ constructor parameter/ with a name you want to
          reference from within your class. In the example in the Solution, the
          field is named ~_name~.

       2. Define /getter/ and /setter/ names that you want other classes to use.
          In the Solution the /getter name/ is ~name~, and the /setter name/ is
          ~name_=~ (which, combined with /Scala's syntactic sugar/, lets users
          write ~p.name = "Jony"~).

       3. Modify the body of the /getter and setter methods/ as desired.
          =from Jian=
          If no this 3 step, you actually don't need to override the accessor.
          Compiler will insert the default accessors.

     - If we forget the ~private~ modifier, and write
       #+begin_src scala
         class Stock(var _symbol: String) {
           def symbol = _symbol

           def symbol_=(s: String) {
             _symbol = s
             println(s"symbol was updated, new value is $symbol")
           }
         }
       #+end_src
       The output of =javap Stock=
       #+begin_src java
         public class Stock extends java.lang.Object{
             public java.lang.String _symbol();         // defect, because of forget `private` before `var _symbol: String`
             public void _symbol_$eq(java.lang.String); // defect, because of forget `private` before `var _symbol: String`
             public java.lang.String symbol();
             public void symbol_$eq(java.lang.String);
             public Stock(java.lang.String);
         }
       #+end_src

     - Remember the ~private~ modifier, and write
       #+begin_src scala
         class Stock(private var _symbol: String) {
           def symbol = _symbol

           def symbol_=(s: String) {
             _symbol = s
             println(s"symbol was updated, new value is $symbol")
           }
         }
       #+end_src
       The output of =javap Stock=
       #+begin_src java
         public class Stock extends java.lang.Object{
             public java.lang.String symbol();
             public void symbol_$eq(java.lang.String);
             public Stock(java.lang.String);
         }
       #+end_src

** TODO 5.12. Assigning a Block or Function ot a (~lazy~) Field
*** Problem
*** Solution
*** Discussion

** TODO 5.13. Setting Uninitialized ~var~ Field Types
*** Problem - 122
*** Solution - 123
    Default value or ~None~
*** Discussion - 124
*** See Also - 124

** 5.14. Generating Boilerplate Code with Case Classes
*** Problem - 136
*** Solution - 136
*** TODO Discussion - 138
**** TODO Generated code - 138

*** TODO See Also - 140
    
** 5.15. Defining Auxiliary Constructors for Case Classes
   
* DONE 6. Traits And Enums - 203
  CLOSED: [2021-08-15 Sun 20:27]
*** A Brief Introduction to Traits
*** Trait Construction Order
   
** DONE 6.1. Using a Trait as an Interface - 203
   CLOSED: [2020-05-08 Fri 02:11]
*** Problem - 203
*** Solution - 203
*** Discussion - 205
    - How to use ~extends~ and ~with~:
      + If extend *one* /trait/, use the ~extends~ keyword.

      + If extend MULTIPLE /traits/, use
        * ~extends~ for the *first* /trait/
        * ~with~ to extend (/mix in/) the other /traits/.

      + If extends a /class/ (or /abstract class/) and a /trait/, _ALWAYS_ use
        ~extends~ before the /class/ name, and use ~with~ before the trait name(s).

    - When a /class/ has *multiple* /traits/, *those /traits/ are said to _be mixed
      in to_ the class.* The term *mixed in* is also used when _extending_ a
      /single object instance/ _with_ a /trait/, like this: ~val f = new Foo with Trait1~
      TODO See Recipe 8.8, "Adding a Trait to an Object Instance".

** DONE 6.2. Defining Abstract Fields in Traits - 206
   CLOSED: [2020-05-08 Fri 02:11]
*** Problem - 206
*** Solution - 206
*** Discussion - 206
    - /Fields/ of a /trait/ can be declared as either ~var~ or ~val~.
      You don't need to use the ~override~ keyword to _override_ a ~var~ /field/
      in a /subclass/ (or /trait/), but you DO NEED to use it to _override_ a
      ~val~ /field/.

    - Recipie 4.13, "Defining Properties in an Abstract Base Class (or Trait)"

** DONE 6.3. Using a Trait Like an Abstract Class - 207
   CLOSED: [2020-05-08 Fri 01:43]
*** Problem - 207
*** Solution - 207
*** Discussion - 207
*** See Also - 208

** DONE 6.4. Using Traits as Mixins
   CLOSED: [2020-05-08 Fri 01:46]
*** Problem - 208
*** TODO Solution - 208
    - *Tips*
      To see a great demonstration of the power of /mixins/, read _Artima's short
      "Stackable Trait Pattern" article._ By defining /traits/ and /classes/ as
      base, core, and stackable components, they demonstrate how sixteen
      different classes can be derived from three traits by “stacking” the
      traits together.

*** See Also - 209

** DONE 6.5. Resolving Method Name Conflicts and Understanding ~super~
** DONE 6.6. Marking Traits So They Can Only Be Used by Subclasses of a Certain Type - 211
   CLOSED: [2020-05-08 Fri 02:00]
*** Problem - 211
*** Solution - 211
    #+begin_src scala
      trait MyTrait { this: BaseType =>
      }
    #+end_src
*** Discussion - 212
*** See Also - 213

** DONE 6.7. Ensuring a Trait Can Only Be Added to a Type That Has a Specific Method - 213
   CLOSED: [2020-05-08 Fri 01:59]
*** Problem - 213
*** Solution - 213
    #+begin_src scala
      trait WrapCore { this: { def ejectWrapCore(password: String): Boolean } =>
      }
    #+end_src
*** Discussion - 214
*** See Also - 214

** DONE 6.8. Limiting Which Classes Can Use a Trait by Inheritance - 209
   CLOSED: [2020-05-08 Fri 02:10]
*** Problem - 209
*** Solution - 209
    Use the of restriction that one class/object can ONLY extends /traits/ or
    /classes/ that have the same /superclasses/ as a tool to "Limiting Which
    Classes Can Use a Trait by Inheritance".

    - See the example in _Discussion - 210_

*** Discussion - 210
    Assume there is a rule that "people who deliver pizzas to customers must be a
    /subclass/ of ~StoreEmployee~ and cannot be a /subclass/ of ~CorporateEmployee~."
    #+begin_src scala
      abstract class Employee
      class CorporateEmployee extends Employee
      class StoreEmployee extends Employee

      trait DeliversFood extends StoreEmployee
      class DeliveryPerson extends StoreEmployee with DeliversFood

      // Won't compile
      class Receptionist extends CorporateEmployee with DeliversFood
    #+end_src

*** Discussion - 211 - =CAUTION= can be a better name
    _It seems *RARE* that a /trait/ and a /class/ the /trait/ will be mixed into
    should both have the same superclass_,
    so I suspect the need for this recipe is also rare.
    + Advice:
      When you want to limit the /classes/ a /trait/ can be mixed into,
      1. *don't create an artificial inheritance tree to use this recipe*;
      2. *use one of the following recipes instead.*

*** See Also - 211

** DONE 6.9. Working with Parameterized Trait
** DONE 6.10. Using Trait Parameters
** DONE 6.11. Using Traits to Create Modules
** TODO 6.12. How to Create Sets of Named Values with Enums
*** Problem
*** Solution
*** Discussion
**** Enums can have members
**** When to use enums
**** Compatibility with Java

*** See Also
    
** TODO 6.13. Modeling Algebraic Data Types with Enums
*** Problem
*** Solution
**** Sum types
**** Product types

*** Discussion
**** The Sum type
**** The Product type
**** Much more different than Scala 2
     
*** See Also
    
* DONE 7. Objects - 171
  CLOSED: [2021-08-15 Sun 20:27]
  /object/ has two meanings in Scala:
  - An instance of a class

  - An singleton object define with ~object~

** DONE 7.1. Casting Object - 172
   CLOSED: [2018-02-21 Wed 21:07]
*** DONE Problem - 172
    CLOSED: [2018-02-21 Wed 21:07]
*** DONE Solution - 172
    CLOSED: [2018-02-21 Wed 21:07]
    The /method/ ~asInstanceOf[aType]~ is defined in the ~Any~ /class/ and is
    therefore available on *all* /objects/.

    Same meaning in semantics in different languages:
    - Scala:
      ~val recognizer = cm.lookup("recognizer").asInstanceOf[Recognizer]~

    - Java:
      ~Recognizer recognizer = (Recognizer)cm.lookup("recognizer")~

*** DONE Discussion - 172
    CLOSED: [2018-05-23 Wed 12:58]
    As with Java, /cast/ can lead to a ~ClassCastException~.

*** TODO See Also - 173

** DONE 7.2. Passing a Class Type with the ~classOf~ Method
** DONE 7.3. Creating Singletons with ~object~
   CLOSED: [2018-05-23 Wed 14:10]
*** DONE Problem - 178
    CLOSED: [2018-05-23 Wed 14:10]
*** DONE Solution - 178
    CLOSED: [2018-05-23 Wed 14:10]
*** DONE Discussion - 180
    CLOSED: [2018-05-23 Wed 14:10]

   
** DONE 7.4. Creating Static Members with Companion Objects - 180
   CLOSED: [2018-02-21 Wed 21:04]
*** DONE Problem - 180
    CLOSED: [2018-02-21 Wed 21:04]
    Scala does NOT have the ~static~ keyword.
    Create /static members/ in a /class's companion object/.

*** DONE Solution - 180
    CLOSED: [2018-02-21 Wed 21:03]
    - companion object :: an object fulfill the requirements:
      + it must have the *same name* as its /companion class/
      + it must reside in the *same file* as its /companion class/

*** DONE Discussion - 181
    CLOSED: [2018-02-21 Wed 21:03]
    Although this approach is different than Java, the recipe is straightforward:
    - Define your ~class~ and ~object~ in the *SAME file*, giving them the
      *SAME name*.

    - Define members that should appear to be /static/ in the ~object~.

    - Define nonstatic (instance) members in the /class/.

**** Accessing private members - 181
     - =From Jian=
       A /class/ and its /companion object/ can access each other's
       /private members/. More concretely,
       + The /companion object/ accesses the /private members/ of the passed in
         its /companion class/'s instance(s).
         #+BEGIN_SRC scala
           class Foo {
             private val secret = 2
           }

           object Foo {
             // access the private class field 'secret'
             def double(foo: Foo) = foo.secret * 2
           }

           object Driver extends App {
             val f = new Foo
             println(Foo.double(f)) // prints 4
           }
         #+END_SRC

       + The /companion class/ accesses the /private members/ of its /companion
         object/ through the prefix of /companion object/'s name.

         =From Jian= I forget about this prefix for a long time. If you don't
         want this prefix, use ~import companionObjectName._~ inside the
         /compation class/.
         #+BEGIN_SRC scala
           class Foo {
             // access the private object field 'obj'
             def printObj { println(s"I can see ${Foo.obj}") }
           }

           object Foo {
             private val obj = "Foo's object"
           }

           object Driver extends App {
             val f = new Foo
             f.printObj
           }
         #+END_SRC

** TODO 7.5. Using ~apply~ Methods in Objects as Constructors
** TODO 7.6. Implement a Static Factory with ~apply~
*** DONE Problem - 189
    CLOSED: [2018-05-23 Wed 15:16]
*** DONE Solution - 189
    CLOSED: [2018-05-23 Wed 15:16]
    #+BEGIN_SRC scala
      trait Animal {
        def speak
      }

      object Animal {
        private class Dog extends Animal {
          override def speak { println("woof") }
        }

        private class Cat extends Animal {
          override def speak { println("meow") }
        }

        // the factory method
        def apply(s: String): Animal = {
          if (s == "dog") new Dog
          else new Cat
        }
      }

      // val cat = Animal("cat")
      // val dog = Animal("dog")
    #+END_SRC

*** DONE Discussion - 190
    CLOSED: [2018-05-23 Wed 15:22]
    The example above centralize the management of the generation of ~Dog~ and
    ~Cat~, and avoid to expose their /constructors/ to outside.

    However, you may not like this way.
    If so, you can use a method name you as you which. The only change is that
    you need to call that /method/ explicitly. Nothing else is changed.
    For instance, replace the ~apply~ /method/ with
    #+BEGIN_SRC scala
      def getAnimal(s: String): Animal = {
        if (s == "dog") return new Dog
        else            return new Cat
      }

      // val cat = Animal.getAnimal("cat")
      // val dog = Animal.getAnimal("dog")
    #+END_SRC

*** TODO See Also - 190

   
** DONE 7.7. Reifying Traits as Objects
** DONE 7.8. Implementing Pattern Matching with ~unapply~
   
* DONE 8. Methods
  CLOSED: [2021-08-15 Sun 20:27]
** DONE 8.1. Controlling Method Scope (Access Modifiers) - 148 =re-read=
   CLOSED: [2018-02-28 Wed 00:57]
*** DONE Problem - 148
    CLOSED: [2018-02-28 Wed 00:55]
    Scala /methos/ are *public* _by default_. NO keyword for this.
    How about to set upt other visibility?

*** DONE Solution - 148
    CLOSED: [2018-02-28 Wed 00:55]
    - Scala provides *more* control to the /visibility/ than that of Java:

    - Scala provides these scope options:
      + Object-private scope
      + Private
      + Package
      + Package-specific
      + Public

**** DONE Object-private scope - 148
     CLOSED: [2018-02-28 Wed 00:46]
     - ~private[this]~ -- the most restrictive one.
       A /method/ marked with this is only visible to a /instance/ itself.

     - Non-compilable code
       #+BEGIN_SRC scala
         class Foo {
           private[this] def isFoo = true

           def doFoo(other: Foo) {
             is (other.isFoo) {  // This line WON'T compile
               // code
             }
           }
         }
       #+END_SRC

**** DONE Private scope - 149
     CLOSED: [2018-02-28 Wed 00:46]
     - ~private~ makes the /method/ available to
       + the /current class/
       + other /instances/ of the /current class/

     - There is only one meaning for ~private~ in both Scala and Java.

     - Compilable (which is non-compilable in the last section with
       ~private[this]~)
       #+BEGIN_SRC scala
         class Foo {
           private def isFoo = true

           def doFoo(other: Foo) {
             is (other.isFoo) {  // This line WON'T compile
               // code
             }
           }
         }
       #+END_SRC

     - By making a method private, it is not available to subclasses -- you can't
       call it.
       + Non-compilable example
       #+BEGIN_SRC scala
         class Animal {
           private def heartBeat {}
         }

         class Dog extends Animal {
           heartBeat  // WON'T compile
         }
       #+END_SRC

       However, you can create one with the same name with any visibility you
       like.
       + Compilable - the superclass ~hearBeat~ is NOT available, and the
         subclass create a same name but complete different one. This is NOT
         shadowing, no ~override~ required, and, actually, you *MUST'T* add
         ~override~
         #+BEGIN_SRC scala
           class Animal {
             private def heartBeat {}
           }

           class Dog extends Animal {
             def heartBeat {}
           }
         #+END_SRC

**** DONE Protected scope - 149
     CLOSED: [2018-02-28 Wed 00:49]
     - ~protected~ -- available to /subclasses/.
       + Compilable code (Non-compilable in the last section with ~private~):
         #+BEGIN_SRC scala
           class Animal {
             protected def heartBeat {}
           }

           class Dog extends Animal {
             heartBeat  // compilable
           }
         #+END_SRC

     - ~protected~ in Scala is different from that in Java.

**** DONE Package scope - 150
     CLOSED: [2018-02-28 Wed 00:48]
     - ~private[packageName]~ -- available to all members of the current package.
       This is called "package scope" in Java, and Java use its ~protected~ to
       mark this.

**** DONE More package-level control - 150
     CLOSED: [2018-02-28 Wed 00:55]
     - Use the ~private[packageName]~ pattern, but specify a package name of
       *different hierarchy* to make more control.

     - Example:
       #+BEGIN_SRC scala
         package com.acme.coolapp.model {
           class Foo {
             private[model] def doX {}
             private[coolapp] def doY {}
             private[acme] def doZ {}
           }
         }
         import com.acme.coolapp.model._
         package com.acme.coolapp.view {
           class Bar {
             val f = new Foo
             f.doX // won't compile
             f.doY
             f.doZ
           }
         }
         package com.acme.common {
           class Bar {
             val f = new Foo
             f.doX // won't compile
             f.doY // won't compile
             f.doZ
           }
         }
       #+END_SRC

**** DONE Public scope - 151
     No modifier means *public*.

*** DONE Discussion - 152
    CLOSED: [2018-02-28 Wed 00:57]
    *Summary* ...
    Table 5-1. Descriptions of Scala's access control modifiers

** DONE 8.2. Calling a Method on a Superclass or Trait - 152 =re-read=
   CLOSED: [2018-02-28 Wed 01:13]
*** DONE Problem - 152
    CLOSED: [2018-02-28 Wed 01:05]
*** DONE Solution - 153
    CLOSED: [2018-02-28 Wed 01:13]
    Use the ~super.methodName~ pattern.

**** DONE Controlling which trait you call a method from - 153
     CLOSED: [2018-02-28 Wed 01:13]
     - Use the ~super[traitName].methodName~ pattern to resolve confliction when
       a /class/ extends multiple /traits/ which have *same name* /methods/.
       #+BEGIN_SRC scala
         trait Human {
           def hello = "the Human trait"
         }

         trait Mother extends Human {
           override def hello = "Mother"
         }

         trait Father extends Human {
           override def hello = "Father"
         }

         class Child extends Human with Mother with Father {
           def printSuper = super.hello  // same as `super[Father].hello`
           // TODO: ?? By default, the last one (this is a guess for all triats, how about
           //       when one of them is a class????)

           def printMother = super[Mother].hello
           def printFather = super[Father].hello
           def printHuman = super[Human].hello
         }
       #+END_SRC

     - Note that when using this technique, _you *CANNOT* continue to REACH UP
       THROUGH the parent class hierarchy_ unless you directly /extend/ the
       target class or trait using the ~extends~ or ~with~ keywords.
       + Non-compilable
         #+BEGIN_SRC scala
           trait Animal {
             def walk { println("Animal is walking") }
           }

           class FourLeggedAnimal extends Animal {
             override def walk { println("I'm walking on all fours") }
           }

           class Dog extends FourLeggedAnimal {
             def walkThenRun {
               super.walk // works
               super[FourLeggedAnimal].walk // works
               super[Animal].walk // error: won't compile
             }
           }
         #+END_SRC

       + Make the code above compilable:
         Change the signature of ~Dog~ to
         ~class Dog extends FourLeggedAnimal with Animal~

** DONE 8.3. Using Parameter Names When Calling a Method
   CLOSED: [2018-05-20 Sun 23:21]
*** DONE Problem - 157
    CLOSED: [2018-05-20 Sun 23:21]
*** DONE Solution - 157
    CLOSED: [2018-05-20 Sun 23:21]
*** DONE Discussion - 158
    CLOSED: [2018-05-20 Sun 23:21]
    This method is more verbose but more readable.
    You'll never want to see an invocation like ~engage(true, true, true, false)~,
    and this one is more reasonable:
    #+BEGIN_SRC scala
      engage(speedIsSet = true,
             directionIsSet = true,
             picardSaidMakeItSo = true,
             turnedOffParkingBrake = false)
    #+END_SRC

** DONE 8.4. Setting Default Values for Method Parameters
   CLOSED: [2018-05-20 Sun 23:17]
*** DONE Problem - 154
    CLOSED: [2018-05-20 Sun 23:17]
*** DONE Solution - 155
    CLOSED: [2018-05-20 Sun 23:17]
    - =IMPORTANT=
      When you call a method with _all parameters have default values_,
      even if your /method/ is _side-effect free_,
      you _MUST_ call it with ~()~ when you use all its defaluts parameter values.

      *If you don't do this, you'll see an error in compile time.*
      =TODO= =Review= =!!!=
      The reason for this error is discussed in Recipe 9.6, "Using Partially
      Applied Functions".

*** DONE Discussion - 156
    CLOSED: [2018-05-20 Sun 23:17]
    - If your /method/ provides a mix of some fields that offer default values
      and others that don't,
      *list the fields that have default values last.* Then you don't need explicitly
      use parameter names to specify their values, which make your code concise.

** DONE 8.5. Creating Methods That Take Variable-Argument Fields
   CLOSED: [2018-05-20 Sun 23:50]
*** DONE Problem - 163
    CLOSED: [2018-05-20 Sun 23:50]
*** DONE Solution - 163
    CLOSED: [2018-05-20 Sun 23:50]
    - Example:
      #+BEGIN_SRC scala
        def stringRepr(strings: String*): String = {
          strings.toString
        }
      #+END_SRC

      + *CAUTION*
        You *CANNOT* call this /method/ without empty parentheses!
          Or else the compiler will be confused: this is a partial application or
        not?

    - You can use ~_*~ to *adapt* a sequence:
      #+BEGIN_SRC scala
        val fruits = List("apple", "banana", "cherry")
        printAll(fruits: _*)
      #+END_SRC

*** DONE Discussion - 163
    CLOSED: [2018-05-20 Sun 23:49]
    - Attempting to define a field in a /method/ signature _after a varargs
      field_ is an *ERROR*!!! =IMPORTANT=

      As an implication of this rule, a /method/ *can have ONLY ONE varargs field*.

    - The parameter sequence type:
      #+BEGIN_SRC scala
        def printAll(numbers: Int*) {
          println(numbers.getClass)
        }

        scala> printAll(1, 2, 3)
        // class scala.collection.mutable.WrappedArray$ofInt

        scala> printAll()
        // class scala.collection.immutable.Nil$
      #+END_SRC
      Treating the "no args" situation as a ~Nil$~ in the second situation
      _KEEPS your code FROM throwing_ a ~NullPointerException~.

      + =TODO= =???=
        Why ~scala.collection.mutable.WrappedArray$ofInt~ rather than ~Seq[Int]~???

** DONE 8.6. Forcing Callers to Leave Parentheses Off Accessor Methods - 161
   CLOSED: [2018-05-20 Sun 23:32]
*** DONE Problem - 161
    CLOSED: [2018-05-20 Sun 23:29]
*** DONE Solution - 161
    CLOSED: [2018-05-20 Sun 23:29]
*** DONE Discussion - 161
    CLOSED: [2018-05-20 Sun 23:30]
    - Define your accessor without empty parentheses, and the caller won't have
      the option to call it with empty parentheses.

    - There is NO WAY to do in the opposite direction!
      You CANNOT force an empty parentheses.

      Always use call with empty parentheses is ONLY a CONVENTION for Scala.
      However, the good news is if you forget the empty parentheses for calling a
      /method/ with side-effect, the IDE or your editor plugin may warn you, if
      you configure them well and switched them on.

    - *Side Effects*
      + Definition (from Wikipedia):
        A function is said to have a /side effect/
        #+BEGIN_QUOTE
        if, in addition to returning a value, it also modifies some state or has
        an observable interaction with calling functions or the outside world.
        #+END_QUOTE

      + Side effects include things like:
        * Writing or printing output.

        * Reading input.

        * Mutating the state of a variable that was given as input, changing data
          in a data structure, or modifying the value of a field in an object.

        * Throwing an exception, or stopping the application when an error occurs.

        * Calling other functions that have side effects.


*** TODO See Also - 162

** DONE 8.7. Declaring That a Method Can Throw an Exception - 165
   CLOSED: [2018-02-28 Wed 14:12]
*** DONE Problem - 165
    CLOSED: [2018-02-28 Wed 14:05]
*** DONE Solution - 165
    CLOSED: [2018-02-28 Wed 14:11]
    Use ~@throws(classOf[className])~

    - Example
      #+BEGIN_SRC scala
        @throws(classOf[Exception])
        override def play {
          // exception throwing code here ...
        }

        @throws(classOf[IOException])
        @throws(classOf[LineUnavailableException])
        @throws(classOf[UnsupportedAudioFileException])
        def playSoundFileWithJavaAudio {
          // exception throwing code here ...
        }
      #+END_SRC

*** TODO Discussion - 165
    - *Java Exception Types* =TODO=

*** TODO See Also - 166

** DONE 8.8. Supporting a Fluent Style of Programming - 167
   CLOSED: [2018-02-28 Wed 14:03]
*** DONE Problem - 167
    CLOSED: [2018-02-28 Wed 14:03]
*** DONE Solution - 167
    CLOSED: [2018-02-28 Wed 13:27]
    To support fluent (method chanining) style of programming:
    - If your class can be extended, specify ~this.type~ as the return type of
      fluent style methods.

      + =From Jian=
        Suppose you have ~A~ (trait or class) and ~B~ (traits or class), and B is
        a subclass/subtrait of A (B extends A). Then, with the help of
        ~this.type~, when ~A.method_1~ returns ~A.type~, ~B.method_1~ returns
        ~B.type~.

      + =From Jian=
        I think this is different from Java. In Java, if a superclass/supertrait
        ~A~ method returns an object of type ~A~, its subclass/subtrait will
        still returns an object of type ~A~, and you need to use cast which
        convert the returned ~A~ type object to a ~B~ type object at runtime.

      + =From Jian=
        Look the code below (*caution* this is Java code):
        #+BEGIN_SRC java
          // Person.java
          public class Person {
              public Person method_1() {
                  // some code
              }
          }

          // Employee.java
          public class Employee extends Person {
              @Override
              public Exployee method_1() {   // Wrong type! This is NOT an override!!!
                  // some code
              }
          }
        #+END_SRC
        * Java dosen't have ~this.type~. You have to use runtime cast when you
          use ~Employee~

      + Example:
        #+BEGIN_SRC scala
          class Person {
            protected var fname = ""
            protected var lname = ""

            def setFirstName(firstName: String): this.type = {
              fname = firstName
              this
            }

            def setLastName(lastName: String): this.type = {
              lname = lastName
              this
            }
          }

          class Employee extends Person {
            protected var role = ""

            def setRole(role: String): this.type = {
              this.role = role
              this
            }

            override def toString = {
              "%s, %s, %s".format(fname, lname, role)
            }
          }

          object Main extends App {
            val employee = new Employee

            // use the fluent methods
            employee.setFirstName("Al")
              .setLastName("Alexander")
              .setRole("Developer")
            println(employee)
          }
        #+END_SRC

        * If there is no ~this.type~ in Scala (like Java, even ~Employee~ methods
          return ~Person~), the last part will be
          #+BEGIN_SRC scala
            object Main extends App {
              val employee = new Employee

              // use the fluent methods
              employee.setFirstName("Al")
                .setLastName("Alexander")
                .asInstanceOf[Employee]
                .setRole("Developer")
              println(employee)
            }
          #+END_SRC

          Luckily, we don't need to do this.

    - If you're sure that your class won't be extended (use ~final~ in the
      declaration), you can optionally return ~this~ from your fluent style
      methods.

*** DONE Discussion - 168
    CLOSED: [2018-02-28 Wed 14:03]
    =TODO= More experiemnts!!!
    Explicitly use ~this.type~ as the return type can guarantee you won't get
    wrong type (superclass type or the type inference you don't want).

    - Interesting Example:
      Kamil Banaszczyk's answer for the question
      https://stackoverflow.com/questions/42062109/can-java-return-type-write-like-scala-this-type

*** TODO See Also - 170

** TODO 8.9. Adding New Methods to Closed Classes with Extension Methods
   
* DONE 9. Packaging and Imports
  CLOSED: [2021-08-15 Sun 20:27]
*** The ~Predef~ object
    
** DONE 9.1. Packaging with the Curly Braces Style Notation - 256
   CLOSED: [2019-07-23 Tue 17:42]
*** Problem - 256
*** Solution - 256
**** Benefits - 257
     
*** Discussion - 257
**** Chained package clauses - 258

** DONE 9.2. Importing One or More Members - 258
   CLOSED: [2019-07-23 Tue 17:49]
*** Problem - 258
*** Solution - 258
    - /import selector clause/, for instance,
      ~import java.io.{File, IOException, FileNotFoundException}~
      This is NOT supported by Java.
      
*** Discussion - 259

** DONE 9.3. Renaming Members on Import - 259
   CLOSED: [2019-07-23 Tue 18:02]
*** Problem - 259
*** Solution - 259
*** Discussion - 259
    - /renaming clause/, for instance,
      ~import java.util.{ArrayList => JavaList}~

    - You can even rename /object members/
      (=from Jian= The book use /class members/, which is not exact! Only
                   /package members/ and /object members/ can be imported):
      #+begin_src scala
        import System.out.{println => p}
      #+end_src

** DONE 9.4. Hiding a Class During the Import Process - 261
   CLOSED: [2019-07-23 Tue 18:12]
*** Problem - 261
*** Solution - 261
    For example,
    #+begin_src scala
      import java.util.{Random => _, _}
    #+end_src

    - Since you can hide multiple members during the import process,
      then you should put them first, and ~_~ can only show up at the end.
      For instance,
      #+begin_src scala
        // Legal
        import java.util.{Random => _, _}

        // Illegal
        import java.util.{_, Random => _}
        // From Jian:
        // The semantics of this line is not clear.
        // People can give it a clear meaning, but why should the designer of Scala do that?
        // This looks awkard, right? "Import all and then hide Random" is not very
        // meaningful in logic.
      #+end_src

** DONE 9.5. Importing Static Members - 263
   CLOSED: [2022-05-18 Wed 01:27]
*** Problem - 263
*** Solution - 263
*** Discussion - 263
    
** DONE 9.6. Using Import Statements Anywhere - 264
   CLOSED: [2019-07-23 Tue 18:26]
*** Problem - 264
*** Solution - 264
*** Discussion - 265

** DONE 9.7. Importing Givens - 267
   CLOSED: [2022-05-18 Wed 01:35]
*** Problem - 267
*** Solution - 267
*** Discussion - 268 - =REDO=
    - Per the Scala 3 documentation on _importing givens_, there are
      *TWO REASONS and benefits* for this NEW syntax:
      * It makes clearer where /givens/ in scope are coming from.
      * It enables importing all /givens/ _WITHOUT_ importing anything else.

*** See Also - 269

* DONE 10. Functional Programming
  CLOSED: [2021-08-15 Sun 20:32]
*** What Is Functional Programming?
*** Pure Functions
*** Side Effects
*** Thinking in FP
*** Referential Transparency and Substitution
*** FP Is a Superset of Expression-Oriented Programming
*** My Rules for Functional Programming in Scala
*** Yes, FP Code Uses I/O
    
** DONE 10.1. Using Function Literals (Anonymous Functions) - 218
   CLOSED: [2020-05-08 Fri 03:06]
*** Problem - 218
*** Solution - 218
*** Discussion - 218

** DONE 10.2. Passing Functions Around as Variables
   CLOSED: [2020-05-08 Fri 03:09]
*** Problem - 219
*** Solution - 219
*** Discussion - 220
**** Using a method like an anonymous function - 221
**** Assigning an existing function/method to a function variable - 222

*** See Also - 223

** DONE 10.3. Defining a Method That Accepts a Simple Function Parameter - 223
   CLOSED: [2020-05-08 Fri 03:10]
*** Problem - 223
*** Solution - 223
*** Discussion - 224
    - *Scala's Unit*

*** See Also - 225

** TODO 10.4. Declaring More Complex Higher-Order Functions - 226
*** Problem - 226
*** Solution - 226
*** Discussion - 226
**** Passing in a function with other parameters - 227

** TODO 10.5. Using Partially Applied Functions - 234
*** Problem - 234
*** Solution - 234
*** Discussion - 235

** TODO 10.6. Creating a Method That Returns a Function - 236
*** Problem - 236
*** Solution - 236
*** Discussion - 237
**** Another example - 237

*** See Also - 238

** TODO 10.7. Creating Partial Functions
** TODO 10.8. Implementing Functional Error Handling
** TODO 10.9. Real-World Example: Passing Functions Around in an Algorithm
*** Problem - 238
*** Solution - 238
**** The ~PartialFunction~ explained - 239
**** ~orElse~ and ~andThen~ - 240

*** Discussion - 241
*** See Also - 242

** TODO 10.10. Real-World Example: Functional Domain Modeling
   
* DONE 11. Collections: Introduction
  CLOSED: [2021-08-15 Sun 20:56]
**** Scala Is Not Java
**** The Scala 2.13 Collection Overhaul
**** The Scala 2.13 Collection Overhaul
*** Understanding the Collections Hierarchy
**** The Collections Are Deep and Wide
***** Sequences
***** Maps
***** Sets
     
** TODO 11.1. Choosing a Collection Class
** TODO 11.2. Understanding the Performance of Collections
** TODO 11.3. Understanding Mutable Variables with Immutable Collections
** TODO 11.4. Creating a Lazy View on a Collection
   
* DONE 12. Collections: Common Sequence Classes
  CLOSED: [2021-08-15 Sun 20:52]
*** ~Vector~
*** ~List~
*** ~ArrayBuffer~
*** ~Array~
    
** TODO 12.1. Making ~Vector~ Your Go-To Immutable Sequence
** TODO 12.2. Creating and Populating a ~List~
** TODO 12.3. Adding Elements to a ~List~
*** Problem - 325
*** Solution - 326
*** Discussion - 327
*** See Also - 328

** TODO 12.4. Deleting Elements from a ~List~ (or ~ListBuffer~)
*** Problem - 328
*** Solution - 328
**** ~ListBuffer~ - 328

*** Discussion - 329
*** See Also - 329

** TODO 12.5. Creating a Mutable ~List~ with ~ListBuffer~
*** Problem - 324
*** Solution - 324
*** Discussion - 325

** TODO 12.6. Using ~LazyList~, a Lazy Version of a ~List~
** TODO 12.7. Making ~ArrayBuffer~ Your Go-To Mutable Sequence
*** Problem - 335
*** Solution - 335
    
** TODO 12.8. Deleting ~Array~ and ~ArrayBuffer~ Elements
*** Problem - 335
*** Solution - 336
**** ~Array~ - 337

** TODO 12.9. Creating and Updating an ~Array~
*** Problem - 333
*** Solution - 333
*** Discussion - 334
*** See Also - 334

** TODO 12.10. Creating Multidimensional ~Array~'s
*** Problem - 338
*** Solution - 339
**** Using ~Array.ofDim~ - 339
**** Using an array of arrays - 340

*** Discussion - 340



** TODO 12.11. Sorting ~Array~'s
*** Problem - 337
*** Solution - 338
**** Other solutions - 338

*** See Also - 338

* DONE 13. Collections: Common Sequence Methods
  CLOSED: [2021-08-15 Sun 20:45]
*** Predicate
*** Anonymous Functions
*** Implied Loops
*** Recipes in This Chapter
    
** TODO 13.1. Choosing a Collection Method to Solve a Problem - 255
** TODO 13.2. Looping over a Collection with ~foreach~ - 270
** TODO 13.3. Using ~Iterator~'s - 278
** TODO 13.4. Using ~zipWithIndex~ or ~zip~ to Create Loop Counters - 276
** TODO 13.5. Transforming One Collection to Another with ~map~ - 282
** TODO 13.6. Flattening a List of Lists with ~flatten~ - 285
** TODO 13.7. Using ~filter~ to Filter a Collection - 289
** TODO 13.8. Extracting a Sequence of Elements from a Collection - 291
** TODO 13.9. Splitting Sequences into Subsets - 293
** TODO 13.10. Walking Through a Collection with the ~reduce~ and ~fold~ Methods - 295
** TODO 13.11. Finding the Unique Elements in a Sequence - 300
** TODO 13.12. Merging Sequential Collections - 302
** TODO 13.13. Randomizing a Sequence
** TODO 13.14. Sorting a Collection
** TODO 13.15. Converting a Collection to a ~String~ with ~mkString~ and ~addString~
  
* DONE 14. Collections: Using ~Map~'s
  CLOSED: [2021-08-15 Sun 20:39]
** 14.1. Creating and Using ~Map~'s
*** Problem - 341
*** Solution - 341
*** Discussion - 342
*** See Also - 342

** 14.2. Choosing a ~Map~ Implementation
*** Problem - 343
*** Solution - 343
*** Discussion - 344
*** See Also - 345

** 14.3. Adding, Updating, and Removing Immutable ~Map~ Elements
*** Problem - 345
*** Solution - 345
*** Discussion - 346
*** See Also - 347

** 14.4. Adding, Updating, and Removing Elements in Mutable ~Map~'s - 347
*** Problem - 347
*** Solution - 347
*** Discussion - 348
*** See Also - 349

** 14.5. Accessing ~Map~ Values (Without Exceptions) - 349
*** Problem - 349
*** Solution - 349
*** See Also - 350

** 14.6. Testing for the Existence of a Key or Value in a ~Map~ - 353
*** Problem - 353
*** Solution - 353
*** Discussion - 354
*** See Also - 354

** 14.7. Getting the Keys or Values from a ~Map~ - 352
*** Problem - 352
*** Solution - 352

** 14.8. Finding the Largest (or Smallest) Key or Value in a ~Map~ - 360
*** Problem - 360
*** Solution - 360
*** See Also - 361

** 14.9. Traversing a ~Map~ - 350
*** Problem - 350
*** Solution - 351
**** Operating on map values - 351

** 14.10. Sorting an Existing ~Map~ by Key or Value
*** Problem - 357
*** Solution - 357
*** Discussion - 358
**** About that _* - 359

*** See Also - 360

** 14.11. Filtering a ~Map~
*** Problem - 354
*** Solution - 354
**** Mutable maps - 355
**** Mutable and immutable maps - 355

* DONE 15. Collections: ~Tuple~, ~Range~, ~Set~, ~Stack~, And ~Queue~
  CLOSED: [2021-08-15 Sun 20:39]
** 15.1 Creating Heterogeneous Lists with Tuples
** 15.1 Creating Ranges
** 15.3 Creating a Set and Adding Elements to It
** 15.4 Deleting Elements from Sets
** 15.5 Storing Values in a Set in Sorted Order
** 15.6 Creating and Using a ~Stack~
** 15.7 Creating and Using a ~Queue~
   
* DONE 16. Files and Processes - 463
  CLOSED: [2021-08-15 Sun 20:33]
  - *Boundaries on What Is Possible*

** DONE 16.1. Reading Text Files - 464
   CLOSED: [2018-02-20 Tue 18:24]
*** DONE Problem - 464
    CLOSED: [2018-02-20 Tue 17:49]
    1. open a plain-text file

    2. process the lines in that file

*** DONE Solution - 465
    CLOSED: [2018-02-20 Tue 17:49]
    - _TWO_ primary ways:
      + A concise one-line syntax.
        * With side-effect of leaving the file open
        * Be useful in short-lived programs, like shell scripts.

      + A slightly longer approach that properly closes the file.

**** Using the concise syntax - 465
     #+BEGIN_SRC scala
       import scala.io.Source

       val filename = "fileopen.scala"
       for (line <- Source.fromFile(filename).getLines) {
         println(line)
       }
     #+END_SRC

     - Some variation:
       #+BEGIN_SRC scala
         val lines = Source.fromFile("/Users/Al/.bash_profile").getLines.toList
         val lines = Source.fromFile("/Users/Al/.bash_profile").getLines.toArray
       #+END_SRC

     - ~fromFile~ method returns a ~BufferedSource~, and its ~getLines~ method
       treats any =\r\n=, =\r=, or =\n= as a line separator.

**** Properly closing the file - 465
     #+BEGIN_SRC scala
       val bufferedSource = Source.fromFile("example.txt")

       for (line <- bufferedSource.getLines) {
         println(line.toUpperCase)
       }

       bufferedSource.close
     #+END_SRC

     - =TODO=
       For automated methods of closing the file, see the "Loan Pattern" examples
       in the *Discussion*.

*** DONE Discussion - 466
    - You can use ~lsof~ ("list open files") to see the list of open files.
      ~lsof -u <userName> | grep '<filename(s)Pattern>'~

**** DONE Automatically closing the resource - 467
     CLOSED: [2018-02-20 Tue 18:12]
     Use the /load pattern/ - properly close resources once they goes out of
     scope.

     =From Jian= Until Scala 2.12.4, there is no Java /try-with-resources/ syntax

     - The core part of a /load pattern/ implementation:
       #+BEGIN_SRC scala
         def using[A](r: Resource)(f: Resource => A): A =
           try {
             f(r)
           } finally {
             r.dispose()
           }
       #+END_SRC

     - One way to IMPLEMENT the /Loan Pattern/ when working with files is to use
       *Joshua Suereth’s ARM library*.
       =From Jian= Check if this is outdated or NOT.

       #+BEGIN_SRC scala
         // in build.sbt
         libraryDependencies += "com.jsuereth" %% "scala-arm" % "1.3"

         // in TestARM
         import resource._
         import scala.io.Source

         object TestARM extends App {

           for (source <- managed(Source.fromFile("example.txt"))) {
             for (line <- source.getLines) {
               println(line)
             }
           }

         }
       #+END_SRC

     - Another way (from the book Beginning Scala by David Pollak - modified)
       #+BEGIN_SRC scala
         object Control {

           def using[A <: { def close(): Unit }, B](resource: A)(f: A => B): B =
             try {
               f(resource)
             } finally {
               resource.close()
             }
         }
       #+END_SRC

       + Usage:
         #+BEGIN_SRC scala
           import Control._
           import scala.io.Source

           object TestUsing extends App {

             using(Source.fromFile("example.txt")) { source => {
                 for (line <- source.getLines) {
                   println(line)
                 }
               }
             }

           }
         #+END_SRC

     - =From Jian= =TODO= =RE-READ=
       When you use the /Load Pattern/, take care about the /laziness/ --
       make sure you really use the resource before its closing:

       Read the answer of Rex Kerr from
       https://stackoverflow.com/questions/20762240/loaner-pattern-in-scala

**** Many ~io.Source~ methods - 467
     - *Terrific Java Integration*

*** TODO See Also - 468

** DONE 16.2. Writing Text Files - 468
   CLOSED: [2018-02-21 Wed 14:29]
*** DONE Problem - 468
    CLOSED: [2018-02-21 Wed 14:16]
*** DONE Solution - 468
    CLOSED: [2018-02-21 Wed 14:29]
    Fall back and use Java's ~PrintWriter~ or ~FileWriter~.
    For example,
    #+BEGIN_SRC scala
      // PrintWriter
      import java.io._

      val pw = new PrintWriter(new File("hello.txt"))
      pw.write("Hello, world")
      pw.close()


      // FileWriter
      val file = new File(cannonicalFilename)
      val bw = new BufferedWriter(new FileWriter(file))
      bw.write(text)
      bw.close()
    #+END_SRC

    - *Exceptions*

*** DONE Discussion - 470
    CLOSED: [2018-02-21 Wed 14:29]
    From https://coderanch.com/t/418148/certification/Information-PrintWriter-FileWriter

    - ~FileWriter~ is the /character representation of IO/.
      That means it can be used to write characters.

    - *Internally* ~FileWriter~ would use
      1. the _default character set of the underlying OS_
      2. _convert the characters to bytes_
      3. _write it to the disk_.

    - ~PrintWriter~ & ~FileWriter~.
      + SIMILARITIES
        * Both extend from ~Writer~.

        * Both are /character representation/ classes, that means they work with
          *characters* and _convert them to bytes using default charset_.

      + DIFFERENCES
        * ~FileWriter~ throws ~IOException~ in case of any IO failure, this is a
          /checked exception/.

        * *None* of the ~PrintWriter~ methods throws ~IOException~,
          instead they _set a boolean flag_ which can be obtained using
          ~checkError()~.

        * ~PrintWriter~ invokes /flush/ *after every byte of data is written*,
          automatically.

          In case of ~FileWriter~,
          invoker as to take care of invoking /flush/.

    - Difference between ~PrintStream~ and ~OutputStream~: Similar to above
      explanation, just replace /character/ with /byte/.

*** TODO See Also - 470

** DONE 16.3. Reading and Writing Binary Files - 470
   CLOSED: [2018-02-21 Wed 14:56]
*** DONE Problem - 470
    CLOSED: [2018-02-21 Wed 14:56]
*** DONE Solution - 470
    CLOSED: [2018-02-21 Wed 14:56]
    - Use the Java ~FileInputStream~ and ~FileOutputStream~ classes.

    - To demonstrate this, the following code is a close Scala *translation* of
      the ~CopyBytes~ class on the _Oracle Byte Streams tutorial_:
      #+BEGIN_SRC scala
        import java.io._

        object CopyBytes extends App {
          var in = None: Option[FileInputStream]
          var out = None: Option[FileOutputStream]
          try {
            in = Some(new FileInputStream("/tmp/Test.class"))
            out = Some(new FileOutputStream("/tmp/Test.class.copy"))
            var c = 0
            while ({c = in.get.read; c != −1}) {
              out.get.write(c)
            }
          } catch {
            case e: IOException => e.printStackTrace
          } finally {
            println("entered finally ...")
            if (in.isDefined) in.get.close
            if (out.isDefined) out.get.close
          }
        }
      #+END_SRC
      + In the original Java version, the condition of ~while~ is like
        ~c = in.read() != -1~, which doesn't work in Scala:
        *assignment in Scala returns an ~Unit~ value, rather then the /assigned
        value/ in Java.*

**** Reading binary files - 471
**** Writing binary files - 471

*** DONE Discussion - 471
    - *A Caveat*

*** TODO See Also - 472

** DONE 16.4. Pretending That a String Is a File - 472
   CLOSED: [2018-02-21 Wed 13:48]
*** DONE Problem - 472
    CLOSED: [2018-02-21 Wed 13:45]
    For the purposes of testing, you may want to pretend that a ~String~ is a /file/.

*** DONE Solution - 472
    CLOSED: [2018-02-21 Wed 13:45]
    - Since both ~Source.fromFile~ and ~Source.fromString~ return a ~Source~
      (actually ~BufferedSource~) object, they are easily *interchangeable*.

    - Example:
      #+BEGIN_SRC scala
        import io.Source

        def printLines(source: Source) {
          for (line <- source.getLines) {
            println(line)
          }
        }

        val s = Source.fromString("foo\nbar\n")
        printLines(s)
      #+END_SRC

*** DONE Discussion - 473
    CLOSED: [2018-02-21 Wed 13:48]

** TODO 16.5. Serializing and Deserializing Objects to Files - 473
*** Problem - 473
*** Solution - 473
*** Discussion - 474
    - *Serialization Is Going Away (At Some Point)*

** DONE 16.6. Listing Files in a Directory - 475
   CLOSED: [2020-05-09 Sat 22:54]
*** Problem - 475
    - Q :: How to
      + get a list of files that are in a directory,
      + potentially limiting the list of files with a filter.

*** Solution - 475
    Use the Java ~File~:
    #+begin_src scala
      def getListOfFiles(dir: String):List[File] = {
        val d = new File(dir)

        if (d.exists && d.isDirectory) {
          d.listFiles.filter(_.isFile).toList
        } else {
          List.empty[File]
        }
      }
    #+end_src

*** Discussion - 476
    - If you want to *limit* the list of files that are returned based on their
      filename extension,
      + In Java, we'd implement a ~FileFilter~ with an ~accept~ /method/.
      + In Scala, we can simply use ~filter~ and a function literal as predicate.

    - Example:
      #+begin_src scala
        import java.io.File

        def getListOfFiles(dir: File, extensions: Iterable[String]): List[File] =
          dir.listFiles.filter(_.isFile).toList.filter { file =>
            extensions.exists(file.getName.endsWith(_))
          }
      #+end_src

*** See Also - 476

** DONE 16.7. Executing External Commands - 477
   CLOSED: [2020-05-11 Mon 00:34]
*** DONE Problem - 477
    CLOSED: [2018-02-20 Tue 18:39]
    - Q :: Execute an external (system) command from within a Scala application.
      + No concerned about the output from the command,
        but you are interested in its /exit code/.

*** DONE Solution - 477
    CLOSED: [2018-02-20 Tue 18:39]
    - There are *3* primary ways to execute external commands:
      + Use the ~!~ method to execute the command and _get its exit status_.
        (This recipie)

      + Use the ~!!~ method to execute the command and _get its output_.
        (NEXT recipie)

      + Use the ~lines~ method to execute the command in the background and get
        its result as a ~Stream~.
        (This recipie Discussion section)
        * =from Jian=
          Use ~lazyLines~ method that returns a value of ~LazyList~.

    - Example:
      #+BEGIN_SRC scala
        // scala>
        import sys.process._

        // scala>
        "ls -al".!
        // total 64
        // drwxr-xr-x 10 Al staff 340 May 18 18:00 .
        // drwxr-xr-x 3 Al staff 102 Apr 4 17:58 ..
        // -rw-r--r-- 1 Al staff 118 May 17 08:34 Foo.sh
        // -rw-r--r-- 1 Al staff 2727 May 17 08:34 Foo.sh.jar
        // res0: Int = 0


        // scala>
        val exitcode = "ls -al".!
        // total 64
        // drwxr-xr-x 10 Al staff 340 May 18 18:00 .
        // drwxr-xr-x 3 Al staff 102 Apr 4 17:58 ..
        // -rw-r--r-- 1 Al staff 118 May 17 08:34 Foo.sh
        // -rw-r--r-- 1 Al staff 2727 May 17 08:34 Foo.sh.jar
        // result: Int = 0
      #+END_SRC

      + It is obvious that there must an /implicit conversion/ (from
        ~sys.process._~) to add the ~!~ /method/ to a ~String~.

**** Using the ~!~ method - 477
**** Run an exernal command asynchronously - 478

*** DONE Discussion - 479
    CLOSED: [2018-02-20 Tue 18:58]
    - You can also use ~Seq~, where the first element is considered as a command,
      and the elements after the first one is considered arguments. For example,
      ~val exitCode = Seq("ls", "-al").!~

    - Use ~Process~ directly. For example,
      ~val exitCode = Process("ls").!~

    - =IMPORTANT=
      Remember to delete whitespaces around your command and arguments, or some
      /exceptions/ will be thrown out.
      #+BEGIN_SRC scala
        // beware leading whitespace

        // scala>
        " ls".!
        // java.io.IOException: Cannot run program "": error=2,
        //   No such file or directory
        //   at java.lang.ProcessBuilder.start(ProcessBuilder.java:460)

        // scala>
        val exitCode = Seq(" ls ", "-al").!
        //   java.io.IOException: Cannot run program " ls ": error=2,
        //     No such file or directory


        // beware trailing whitespace

        // scala>
        val exitCode = Seq("ls", " -al ").!
        // ls: -al : No such file or directory
        // exitCode: Int = 1
      #+END_SRC

    - =From Jian=
      + Q :: Why NOT the library automatically clean the input strings to make
             them runnable commands???????

      + A :: With leading or/and trailing spaces is not a good style!
             Why not fail it!

**** Using a Process - 479
**** Beware  whitespace - 480
**** External commands versus built-in commands - 480
     - This recipe can only help to run /external commands (excutable in the
       ~PATH~)/. You CANNOT use this recipe to run /shell built-in command/.

     - =TODO=
       See Recipe 12.13, “Building a Pipeline of Commands” for an example of how
       to execute a shell built-in command.

** DONE 16.8. Executing External Commands and Reading Their STDOUT - 480
   CLOSED: [2020-05-11 Mon 00:53]
*** Problem - 480
    - Q :: How to
      1. run an external command
      2. then _use the standard output (STDOUT)_ from that process in your Scala program.

*** Solution - 480
    - A :: ~!!~ and get the standard output from the resulting process as a
           ~String~ (multiple line string).
**** Synchronous solution with ~!!~ - 481
**** Asynchronous solution ~lazyLines~ - 482
**** Asynchronous solution ~lazyLines_!~ - 482
**** Seq and Process - 483

** TODO 16.9. Handling Both STDOUT and STDERR of Commands - 483
*** Problem - 483
*** Solution - 483
    -  *Make Sure You Understand the Exit Status Codes*

*** Discussion - 484
*** See Also - 485

** TODO 16.10. Building a Pipeline of External Commands - 485
*** Problem - 485
*** Solution - 485
*** Discussion - 486
**** Piping in a string won't work without a shell - 486

* DONE 17. Building Projects with sbt - 487
  CLOSED: [2021-08-15 Sun 20:33]
*** TODO sbt's features - 488
*** TODO Understanding the sbt Philosophy - 488
*** TODO Directory Structure - 488
*** TODO =build.sbt= - 489
*** TODO Other Notes - 490

** TODO 17.1. Creating a Project Directory Structure for sbt - 490
*** Problem - 490
*** Solution - 490
**** Option 1: Use a shell script - 490
**** Option 2: Use ~sbt new~ - 493

*** Discussion - 493
**** Files created by the template - 494
     - *Files and Directories in .gitignore*

** TODO 17.2. Building Projects with the sbt Command - 495
*** Problem - 495
*** Solution - 495
    - *Multiple ~@main~ Methods*

*** Discussion - 496
**** Batch and interactive modes - 496
     - *sbt Only Requires Java*
       =from Jian= *sbt Only Requires JDK* is better

** TODO 17.3. Understanding =build.sbt= Syntax Styles - 497
*** Problem - 497
*** Solution - 497
    - *These Styles Are Preferred*

*** Discussion - 498

** TODO 17.4. Compiling, Running, and Packaging a Scala Project - 499
*** Problem - 499
*** Solution - 499
*** Discussion - 500
**** Interactive mode - 500
**** Passing arguments to sbt at the command line - 500
     - *Running in a Different JVM*

** TODO 17.5. Understanding Other sbt Commands - 501
*** Problem - 501
*** Solution - 502
*** Discussion - 503
*** See Also - 503

** TODO 17.6. Continuous Compiling and Testing  - 504
*** Problem - 504
*** Solution - 504

** TODO 17.7. Managing Dependencies with sbt - 505
*** Problem - 505
*** Solution - 505
**** Unmanaged dependencies - 505
**** Managed dependencies - 505
**** Using Scala 2.13 dependencies in Scala 3 builds - 506

*** Discussion - 506
    - *Most Projects Use Managed Dependencies*

**** The ~libraryDependencies~ syntax - 507
**** Methods used to build libraryDependencies - 507
**** Dependencies for Scala.js and Scala Native - 508
**** The configuration field - 508
**** Where are the dependencies - 509
     - *Use Debug Mode When Curious*

**** Repositories - 510

** TODO 17.8. Co
*** Problem - 510
*** Solution - 510
**** Revision field options - 510

*** Discussion - 511
*** See Also - 512

** TODO 17.9. Generating Project API Documentation - 512
*** Problem - 512
*** Solution - 512
*** Discussion - 513
*** See Also - 513

** TODO 17.10. Specifying a Main Class to Run with sbt - 513
*** Problem - 513
*** Solution - 513
**** Specifying a main method for sbt run - 514
**** Specifying a main method for packaged JAR file - 514

*** Discussion - 514
*** See Also - 515

** TODO 17.11. Deploying a Single, Executable JAR File - 515
*** Problem - 515
*** Solution - 515
**** Using sbt-assembly - 515

*** Discussion - 516
*** See Also - 517

** TODO 17.12. Publishing Your Library - 517
*** Problem - 517
*** Solution - 517
*** Discussion - 518
*** See Also - 519

* DONE 18. Concurrency with Scala Futures and Akka Actors - 521
  CLOSED: [2021-08-15 Sun 20:33]
*** Futures
*** Akka and the Actor Model
**** The Actor model
**** Benefits of actors

*** One More Thing: Parallel Collections Classes

** TODO 18.1 Creating a ~Future~ - 525
*** Problem - 525
*** Solution - 525
*** Discussion - 526
*** See Also - 528

** TODO 18.2. Using Callback and Transformation Methods with ~Future~'s - 528
*** Problem - 528
*** Solution - 528
**** Common code - 528
**** Solution 1: Use ~onComplete~ - 528
**** Solution 2: Use ~andThen~ or ~foreach~ - 530

*** Discussion - 532

** TODO 18.3. Writing Methods That Return ~Future~'s - 532
*** Problem - 532
*** Solution - 533
*** Discussion - 533

** DONE 18.4. Running Multiple ~Future~'s in Parallel - 534 - =IMPORTANT=
CLOSED: [2023-07-23 Sun 16:56]
*** Problem - 534
*** Solution - 534
**** The correct approach (simplified) - 534
**** A thorough example for verification - 535

*** Discussion - 537

** _START_
** TODO 18.5. Creating OOP-Style Actors - 538
*** Problem - 538
*** Solution - 538
    - *A Note About Sealed Trait*s

*** Discussion - 541
**** Behaviors - 542
**** A repetitive pattern - 542
**** ~Behaviors.same~ - 542

** TODO 18.6. Creating FP-Style Actors - 543
*** Problem - 543
*** Solution - 543
    - *A Note About Sealed Traits*

*** Discussion - 545

** TODO 18.7. Sending Messages to Actors - 546
*** Problem - 546
*** Solution - 546
**** Import statements - 546
**** Modeling the messages - 546
**** Creating a supervisor - 548
**** A test application - 549

*** Discussion - 551
**** Sending ActorRefs - 551
**** Messages as being an actor's API - 551

*** See Also - 551

** TODO 18.8. Creating Actors That Have Multiple States (FSM) - 552
*** Problem - 552
*** Solution - 552
**** A test App - 554

*** Discussion - 555
**** Dead letters - 555

* TODO 19. Play Framework And Web Services - 557
** 19.1. Creating a Play Framework Project - 558
*** Problem
*** Solution
*** Discussion
**** The conf/routes file
**** The controller
**** The view templates
**** The sbt/Play console

*** See Also

** 19.2. Creating a New Play Framework Endpoint - 564
*** Problem
*** Solution
**** 1. Create a new route
**** 2. Create a new controller method
**** 3. Create a model
**** 4. Test your service

*** Discussion
**** Explaining the ~Ok~ method
**** This code responds to a simple ~GET~ request
**** Handling query parameters
***** 1. Create a new route.
***** 2. Create a new controller method.
***** 3. Create a model.
***** 4. Test your service.


*** See Also

** 19.3. Returning JSON from a GET Request with Play - 568
*** Problem
*** Solution
**** 1. Add an entry to the routes file
**** 2. Create a controller and method
**** 3. Create a model
**** 4. Access the endpoint with your browser or curl

*** Discussion
**** ~Json.toJson~
**** The ~Ok~ method
**** The Play JSON types
**** How to use Play/JSON in the Scala REPL

*** See Also


** 19.4. Serializing a Scala Object to a JSON String - 572
** 19.5. Deserializaing JSON into a Scala Object - 576
** 19.6. Using the Play JSON Library Outside of the Play Framework - 581
** 19.7. Using the sttp HTTP Client - 584

* 20. Apache Spark - 589
** 20.1. Getting Started With Spark - 591
** 20.2. Reading a File Into a Spark RDD - 595
** 20.3. Reading a CSV File Into a Spark RDD - 660
** 20.4. Using Spark Like a Database with DataFrames - 602
** 20.5. Reading Data Files into a Spark DataFrame - 608
** 20.6. Using Spark SQL Queries Against Multiple Files - 612
** 20.7. Creating a Spark Batch Application - 616

* DONE 21. Scala.js, GraalVM, And jpackage - 619
  CLOSED: [2021-08-15 Sun 20:33]
** 21.1 Getting Started with Scala.js - 620
*** Problem - 620
*** Solution - 621
**** 1. Prerequisites - 621
**** 2. Create a new sbt project - 621
**** 3. Create a Scala/Scala.js file - 622
**** 4. Compile and run the Scala code - 622

*** Discussion - 623
**** 5. Update =build.sbt= - 623
**** 6. Create =hello1.html= - 623
**** 7. Update =Hello1.scala= - 624
**** 8. Compile the code with ~fastLinkJS~ - 624
**** 9. Open =hello1.html= in a browser - 625
**** Have a little fun - 625

*** See Also - 625

** 21.2 Responding to Events with Scala.js - 625
*** Problem - 625
*** Solution - 625
**** 1. Create a new HTML page - 626
**** 2. Make sbt updates to use jQuery - 627
**** 3. Write thenew Scala/Scala.js code - 628
**** 4. Set the main class in sbt - 629
**** 5. Run the code - 630

*** Discussion - 631
**** Continuously compile with fastLinkJS - 631

*** See Also - 632

** 21.3 Building Single-Page Applications with Scala.js - 632
*** Problem - 632
*** Solution - 632
**** 1. Update =build.sbt= - 632
**** 2. Create a new HTML file - 633
**** 3. Create =Hello3.scala= - 634
**** 4. Run the code - 635
     - *Showing the Files Generated by fastLinkJS*

*** Discussion - 637
*** See Also - 637

** 21.4 Building Native Executables with GraalVM - 638
*** Problem - 638
*** Solution - 638
**** 1. Configure your sbt project - 638
**** 2. Create the native executable - 639

*** Discussion - 638
**** Running native-image separately - 638

*** See Also - 641

** 21.5 Building Your Application with Jpackage - 641
*** Problem - 641
*** Solution - 641
*** Discussion - 644
**** What jpackage creates - 645

*** See Also - 646

* DONE 22. Integrating Scala with Java - 647
CLOSED: [2022-01-10 Mon 03:14]
** 22.1. Using Java Collections in Scala - 648
*** Problem - 648
*** Solution - 648
*** Discussion - 650
**** Type conversions - 650
**** Conversions methods - 650

*** See Also - 651

** 22.2. Using Scala Collections in Java - 652
*** Problem - 652
*** Solution - 652
*** Discussion - 652
*** See Also - 653

** 22.3. Using Java ~Optional~ Values in Scala - 654
*** Problem - 654
*** Solution - 654
**** Numeric values - 655

*** Discussion - 655
**** Convert Optional to Option on the Java side - 655

*** See Also - 656

** 22.4. Using Scala ~Option~ Values in Java - 656
*** Problem - 656
*** Solution - 656
**** Options containing numeric values - 657

*** Discussion - 658
    - *Same Name, Different Package*

*** See Also - 659
** 22.5. Using Scala Traits in Java - 659
*** Problem - 659
*** Solution - 659
*** Discussion - 659
** 22.6. Using Java Interfaces in Scala - 660
*** Problem - 660
*** Solution - 660
*** Discussion - 660

** 22.7. Adding Exception Annotations to Scala Methods - 661
*** Problem - 661
*** Solution - 661
*** Discussion - 662
*** See Also - 662

** 22.8. Annotating varargs Methods to Work with Java - 662
*** Problem - 662
*** Solution - 662
*** Discussion - 663
**** Calling a Java varargs method - 663

** 22.9. Using ~@SerialVersionUID~ and Other Annotations - 664
*** Problem - 664
*** Solution - 664
    - ~@transient~

*** Discussion - 665
**** Other annotations - 665

*** See Also - 666

* DONE 23. Types - 667
CLOSED: [2022-01-10 Mon 03:14]
*** DONE Generic Type Parameters - 667
*** DONE Bounds - 669
    CLOSED: [2019-03-07 Thu 15:12]
    - Table 19-2. Descriptions of Scala’s bounds symbols
      |                       | Name                   | Description                      |
      |-----------------------+------------------------+----------------------------------|
      | ~A <: B~              | Upper Bound            | ~A~ must be a /suBtype/ of ~B~   |
      |-----------------------+------------------------+----------------------------------|
      | ~A >: B~              | Lower Bound            | ~A~ must be a /suPERtype/ of ~B~ |
      |-----------------------+------------------------+----------------------------------|
      | ~A <: Upper >: Lower~ | Lower and upper Bounds | Bounded by an upper              |
      |                       |                        | bound and an lower bound         |

    - Bounds that mentioned but _NOT_ included in this book:
      + ~T : B~ form: /context bound/ -- /type class/ pattern.

      + ~A <% B~ form: /view bound/, deprecated.

*** DONE Variance - 670
    CLOSED: [2019-03-07 Thu 16:01]
    ~T~, ~+T~, ~-T~
**** Two ways to simplify variance
***** 1. If everyting is immutable
      - *In an Immutable World, Invariance Isn't Needed*

***** 2. Variance is related to the type's "in" and "out" positions
      - *One Way to Remember the Variance Symbols*

**** Testing variance with an implicitly trick
**** Contravariance is rarely used
     - *Multiple Generic Type Parameters with Variance*

*** DONE Type Constraints - 676
    CLOSED: [2019-03-07 Thu 15:17]
    - Type constraints (NOT covered in this book):
      * ~A \equal{}:\equal{} B~: ~A~ must be equal to ~B~
      * ~A <:< B~: ~A~ must be a subtype of ~B~

    - *Several Other Type Examples*

** DONE 23.1. Creating a Method That Takes a Simple Generic Type - 677
   CLOSED: [2019-03-07 Thu 16:35]
*** DONE Problem - 677
    CLOSED: [2019-03-07 Thu 16:35]
*** DONE Solution - 677
    CLOSED: [2019-03-07 Thu 16:35]
*** DONE Discussion - 677
    CLOSED: [2019-03-07 Thu 16:35]

** DONE 23.2. Creating Classes That Use Simple Generic Types - 678
   CLOSED: [2019-03-07 Thu 16:33]
*** DONE Problem - 678
    CLOSED: [2019-03-07 Thu 16:05]
    Create a /class/ (and associated /methods/) that uses a /generic type/.

*** DONE Solution - 678
    CLOSED: [2019-03-07 Thu 16:07]
*** DONE Discussion - 679
    CLOSED: [2019-03-07 Thu 16:33]
    Later Scala compilers (for example, version 2.10) can give you a reminder
    that some place you may use different /variant/ to avoid some compile errors.

**** DONE The limits of this approach - 680
**** DONE Type parameter symbols - 680
     CLOSED: [2019-03-07 Thu 16:33]
     - *Java* has its /naming convention/ for /type parameters/.
       You can find it in
       *The Java™ Tutorials*
          -> *Trails Covering the Basics*
            -> *Learning the Java Language*
              -> *Generics*
                -> *Generics Types*
                  -> *Type Parameter Naming Conventions*

       + It is obvious that this naming convention attatch meanings to /type
         parameter/ names, and it use ~T~ instead of ~A~ if there is a single
         /type parameter/.

       + Nameing Convetion:
         * ~E~ - Element (used extensively by the Java Collections Framework)
         * ~K~ - Key
         * ~N~ - Number
         * ~T~ - Type
         * ~V~ - Value
         * ~S~, ~U~, ~V~ etc. - 2nd, 3rd, 4th types

     - Scala doesn't follow this naming convention, though its also prefer to use
       single capital letter as /type parameters/.

       =from Jian=
       + Rules from *Scala Style Guide*:
         * Use ~A~ instead of ~T~ as a SINGLE /type parameter/.

         * Use descriptive names for more specific meaning.
           The first letter of a name should be capitalized.
           Usually shouldn't use all-caps.

         * Use mnemonic name, rather than a full name,
           if the scope is very small.

       + For the last two points, for example,
         * use ~Key~ and ~Value~ as /type parameter names/ for a conprehensive
           implementation of ~Map~.

         * use ~K~ and ~V~ as /type parameter names/ for a structure defined and
           used in a small scope and needs /type parameters/ to represent key
           type and value type.

*** TODO See Also - 681

** DONE 23.3. Making Immutable Generic Parameters Covariant - 682
   CLOSED: [2019-03-07 Thu 16:57]
*** DONE Problem - 682
    CLOSED: [2019-03-07 Thu 16:57]
*** DONE Solution - 682
    CLOSED: [2019-03-07 Thu 16:57]
*** DONE Discussion - 683
    CLOSED: [2019-03-07 Thu 16:57]
    Defining an /immutable collection/ to take a /covariant generic type
    parameter/ makes the collection _more flexible and useful_ throughout your
    code.

    - ~+A~ Refers to the “Out” Position

** DONE 23.4. Creating a Class Whose Generic Elements Can Be Mutated - 684
*** Problem - 684
*** Solution - 684
*** Discussion - 684
**** Examples in the standard library - 686

*** See Also - 686

** DONE 23.5. Create a Class Whose Parameters Implement a Base Type - 687
   CLOSED: [2019-03-07 Thu 17:19]
*** Problem - 687
    Write generic /classes/ or /methods/ with limited /generic types/.

*** Solution - 687
    Use /upper bound/.

*** Discussion - 688
**** Extending multiple traits - 688

** TODO 23.6. Using Duck Typing (Structural Types) - 689
*** DONE Problem - 689
    CLOSED: [2019-03-07 Thu 16:39]
*** DONE Solution - 689
    CLOSED: [2019-03-07 Thu 16:39]
    Example:
    #+begin_src scala
      def callSpeak[A <: { def speak(): Unit }](obj: A) {
        // code here ...
        obj.speak()
      }
    #+end_src

*** DONE Discussion - 690
    CLOSED: [2019-03-07 Thu 16:39]

**** Understanding the solution - 690

** TODO 23.7. Creating Meaningful Type Names with Opaque Types - 691
*** Problem - 691
*** Solution - 691
*** Discussion - 692
**** Benefits of the three-step solution - 694
**** History - 694
**** Rules - 695

** TODO 23.8. Using Term Inference with ~given~ and ~using~ - 695
*** Problem - 695
*** Solution - 695
**** 1. Define your given instances - 696
**** 2. Declare the parameter your function will use with the using keyword - 696
     - *Context Parameters*

**** 3. Make sure everything is in the current context - 697
**** Anonymous givens and unnamed parameters - 697

*** Discussion - 697
**** Create your own API with extension methods - 698
**** Alias givens - 699
**** Importing givens - 700

*** See Also - 701

** TODO 23.9. Simulating Dynamic Typing with Union Types - 701
*** Problem - 701
*** Solution - 701
    - *An Improvement in Scala 3*

*** Discussion - 702
**** Combining union types with literal types - 703

*** See Also - 703

** TODO 23.10. Declaring That a Value Is a Combination of Types - 703
*** Problem - 703
*** Solution - 703
*** Discussion - 704
*** See Also - 705

** TODO 23.11. Controlling How Classes Can Be Compared with Multiversal Equality - 706
*** Problem - 706
*** Solution - 706
**** Import ~scala.language.strictEquality~ - 706
**** You must enable equality comparisons - 707

*** Discussion - 707

** TODO 23.12. Limiting Equality Comparisons with the ~CanEqual~ Typeclass - 707
*** Problem - 707
*** Solution - 708
**** Derive ~CanEqual~ - 708
**** The ~given~ + ~CanEqual~ approach - 708
     - *Reflexive and Symmetric Comparisons*

*** Discussion - 710

* DONE 24. Best Practices - 711
CLOSED: [2022-01-10 Mon 03:14]
  - This chapter talks about writing Scala in the Scala way.
    #+BEGIN_QUOTE
    I wanted to write code that “makes it look like the language was made for
    the problem.
                                              -- Ward Cunningham (Clean Code)
    #+END_QUOTE

  - Scala's best practices:
    * At the _application level_:
      + The 80/20 rule - try to write 80% of your appplication as pure
        functions, with a thin layer of other code on top of those functions for
        things like I/O.

      + Learn "Expression-Oriented Programming" (=TODO= Recipe 20.3).

      + Use the ~Actor~ classes to implement *concurrency* (=TODO= Chapter 13).

      + Move behavior from classes into more granular traits.
        This is best described in _the Scala Stackable Trait pattern_. =TODO=

    * At the _coding level_:
      + Learn how to write pure functions.

      + Learn how to pass functions around as variables (Recipes 9.2 to 9.4).

      + Learn how to use the _Scala collections API_. Know the most common classes
        and methods (10 and 11). =TODO=

      + Prefer immutable code.
        Use ~val~'s and /immutable collections/ first (Recipe 20.2).

      + Drop the ~null~ keyword from your vocabulary.
        Use the ~Option~ type (~Some~ and ~None~) and ~Try~ type (~Success~ and
        ~Failure~) classes instead (Recipe 20.6). =TODO= =TODO=

      + Use TDD and/or BDD testing tools like ScalaTest and specs2

    * Outside the code:
      + Learn how to use *SBT*.
        It’s the _de-facto_ /Scala build tool/ (Chapter 18).

      + Keep a /REPL/ session open while you’re coding (or use the /Scala
        Worksheet/), and constantly try small experiments (Recipes 14.1 to 14.4,
        and many examples throughout the book). =TODO= =TODO=

*** Other Resources - 713
    - Highly recommended:
      Twitter's *Effective Scala document* (free online).

    - Recommended:
      *Scala Style Guide*

** TODO 24.1. Writing Pure Functions - 713
*** Problem - 713
*** Solution - 713
**** The OOP approach - 713
**** Fixing the problems - 714
**** Behaviors - 715
     - *Other Approaches to Handle Impure Functions*
     - *get and set Aren't Necessary*

**** StockUtils or Stock object? - 717

*** Discussion - 718

** TODO 24.2. Using Immutable Variables and Collections - 719
*** Problem - 719
*** Solution - 719
*** Discussion - 720
**** Using ~val~ + mutable, and ~var~ + immutable - 721

** TODO 24.3. Writing Expressions (Instead of Statements) - 722
*** Problem - 722
*** Solution - 722
**** An example - 723

*** Discussion - 724
**** Benefits - 724

*** See Also - 725

** DONE 24.4. Using Match Expressions and Pattern Matching - 725
   CLOSED: [2018-02-21 Wed 14:00]
*** DONE Problem - 725
    CLOSED: [2018-02-21 Wed 13:49]
*** TODO Solution - 725
**** DONE Replacement for the Java switch statement and unwieldy if/then statements - 726
     CLOSED: [2018-02-21 Wed 13:52]
**** DONE As the body of a function or method - 726
     CLOSED: [2018-02-21 Wed 13:53]
     - In the case that the whole function body is a ~match~ expression.

     - In the case of the function is a /partial function/.
       #+BEGIN_SRC scala
         val divide: PartialFunction[Int, Int] = {
           case d: Int if d != 0 => 42 / d
         }
       #+END_SRC

**** DONE Use with ~Option~ variables - 726
**** DONE In ~try~ / ~catch~ expressions - 727
**** TODO In Akka actors - 727
     =From Jian= I think this an outdated example. Now people use Akka rather than Actor.
                 However, I'm not sure.

     #+BEGIN_SRC scala
       class SarahsBrain extends Actor {
         def receive = {
           case StartMessage => handleStartMessage
           case StopMessage => handleStopMessage
           case SetMaxWaitTime(time) => helper ! SetMaxWaitTime(time)
           case SetPhrasesToSpeak(phrases) => helper ! SetPhrasesToSpeak(phrases)
           case _ => log.info("Got something unexpected.")
         }

         // other code here ...
       }
     #+END_SRC
     
*** TODO See Also - 728

** DONE 24.5. Eliminate ~null~ Values from Your Code - 728
   CLOSED: [2018-02-18 Sun 22:02]
*** DONE Problem - 728
    CLOSED: [2018-02-18 Sun 22:02]
    - Tony Hoare invents the ~null~ reference way back in 1965.

    - Tony Hoare refers the creation of the ~null~ value as his "billion dollar
      mistake."

    - In the modern best practice of programming,
      you should eliminate ~null~.

*** DONE Solution - 728
    CLOSED: [2018-02-18 Sun 22:02]
    - Guide line:
      * When a ~var~ field in a /class/ or /method/ does _not have an initial
        default value_,
        initialize it with ~Option~ instead of ~null~.

      * When a /method/ does _not produce the intended result_, you may be
        tempted to return ~null~.
        Use an ~Option~ or ~Try~ instead.

      * If you're _working with a Java library that returns ~null~,_
        *convert* it to an ~Option~, or *something else* =TODO=.

**** DONE Initialize ~var~ fields with ~Option~, not ~null~ - 729
     CLOSED: [2018-02-18 Sun 21:54]
     Use an example to illustrate:
     #+BEGIN_SRC scala
       case class Address(city: String, state: String, zip: String)
     #+END_SRC

     - Bad:
       #+BEGIN_SRC scala
         case class Address (city: String, state: String, zip: String)
         class User(email: String, password: String) {
           var firstName: String = _
           var lastName: String = _
           var address: Address = _
         }
       #+END_SRC

     - Good:
       #+BEGIN_SRC scala
         class User(email: String, password: String) {
           var firstName = Option.empty[String]
           var lastName = Option.empty[String]
           var address = Option.empty[Address]
         }
       #+END_SRC
       + The author use ~None: Option[TypeName]~ rather than the
         ~Option.empty[TypeName]~ value.
         =TODO: read the source code of the ~empty~ method=

       + =From Jian=
         I'm not sure the reason of the author not do this.
         The reason might be
         * the author didn't know this at that time.
           OR
         * there was NO ~empty~ method in the old librar???
           =TODO: do some research about his!=

     - How to exploit the ~Option~ type representation:
       #+BEGIN_SRC scala
         val u = new User("al@example.com", "secret")

         u.firstName = Some("Al")
         u.lastName = Some("Alexander")
         u.address = Some(Address("Talkeetna", "AK", "99676"))

         println(firstName.getOrElse("<not assigned>"))

         u.address.foreach { a =>
           println(a.city)
           println(a.state)
           println(a.zip)
         }
       #+END_SRC

     - Use ~Option~ type parameters in constructors:
       #+BEGIN_SRC scala
         case class Stock(id: Long,
                          var symbol: String,
                          var company: Option[String])
       #+END_SRC

**** DONE Don't return ~null~ from methods - 730
     CLOSED: [2018-02-18 Sun 04:10]
     - Q: How to avoid returning ~null~?

       A: Return an ~Option~.
          Or, if you need to know about an error that may have occurred in the
          method, use ~Try~ instead of ~Option~.

     - Use ~Option~:
       #+BEGIN_SRC scala
         def readTextFile(filename: String): Option[List[String]] = {
           try {
             Some(io.Source.fromFile(filename).getLines.toList)
           } catch {
             case e: Exception => None
           }
         }
       #+END_SRC

     - With error info -- use ~Try~: =IMPORTANT=
       #+BEGIN_SRC scala
         import scala.util.{Try, Success, Failure}

         object Test extends App {

           def readTextFile(filename: String): Try[List[String]] = {
             Try(io.Source.fromFile(filename).getLines.toList)
           }

           val filename = "/etc/passwd"
           readTextFile(filename) match {
             case Success(lines) => lines.foreach(println)
             case Failure(f)     => println(f)
           }
       #+END_SRC

     - The Twitter /Effective Scala/ page recommends *not overusing* ~Option~,
       and using the /Null Object Pattern/ where it makes sense.
       =IMPORTANT=

       + Null Object Patter :: =IMPORTANT=
            #+BEGIN_SRC scala
              trait Animal {
                def makeSound()
              }

              class Dog extends Animal {
                def makeSound() { println("woof") }
              }

              class NullAnimal extends Animal {
                def makeSound() {}
              }
            #+END_SRC

**** DONE Converting a ~null~ into an ~Option~, or something else - 731
     CLOSED: [2018-02-18 Sun 21:53]
     - ~null~ from Java legacy code:
       #+BEGIN_SRC scala
         def getName: Option[String] =
           Option(javaPerson.getName)
       #+END_SRC

*** Discussion - 731
    - *Explicit nulls in Scala 3*

*** TODO See Also - 732

** DONE 24.6. Using Scala's Error-Handling Types (~Option~, ~Try~, and ~Either~) - 733
   CLOSED: [2018-02-19 Mon 05:15]
*** DONE Problem - 733
    CLOSED: [2018-02-18 Sun 22:37]
*** DONE Solution - 733
    CLOSED: [2018-02-19 Mon 05:15]
    - There is some overlap between this recipe and the previous recipe.
      The previous recipe gives the solutions to
      * Using ~Option~ in /method and constructor parameters/

      * Using ~Option~ to /initialize/ class ~var~ fields (instead of using
        ~null~)

      * Converting ~null~ results from other code (such as Java code) into an
        ~Option~

    - This recipe adds these additional solutions:
      * *Returning* an ~Option~ from a /method/

      * *Getting* the value from an ~Option~

      * Using ~Option~ with /collections/

      * Using ~Option~ with _frameworks_

      * Using ~Try/Success/Failure~ when you need the error message (Scala 2.10
        and newer)

      * Using ~Either/Left/Right~ when you need the error message (*pre-Scala
        2.10*)

**** Extracting the value from an ~Option~ - 733
**** DONE Using ~Option~ with Scala collections - 734
     CLOSED: [2018-02-18 Sun 23:09]
     Two ways:
     For example, get all the integers for a list below which includes (NOT only)
     number strings ~val bag = List("1", "2", "foo", "3", "bar")~. The result
     should be ~List(1, 2, 3)~

     - ~bag.flatMap(toInt)~

       + Redundant way:
         ~bag.map(toInt).flatten~

     - ~bag.map(toInt).collect { case Some(i) => i }~
       =From Jian=
       I don't think the ~collect~ /method/ is good for this use, if consider the
       solution with ~flatMap~. It can be a best practice to more complicated
       cases.

**** DONE Using ~Option~ with other frameworks - 735
     CLOSED: [2018-02-19 Mon 05:03]
     - Examples from the Play framework.
       =TODO=

       =From Jian= I don't understand Play, and I only understand the ~Option~
       inside the example. Explain the example in the paragraph above when I
       understand it.

     - *TIPS*
       The ~scala.util.control.Exception~ object gives you another way to use an
       ~Option~ -- which can replace the ~try ... catch~ block if you want.
       #+BEGIN_SRC scala
         import scala.util.control.Exception._

         def readTextFile(f: String): Option[List[String]] =
           allCatch.opt(Source.fromFile(f).getLines.toList)
       #+END_SRC
       + ~allCatch~ is described as a ~Catch~ object “that catches everything.”
         The ~opt~ /method/ returns
         * ~None~ if an exception is caught (such as a ~FileNotFoundException~)
           AND
         * ~Some(value)~ if the block of code succeeds.

       + ~allCatch~ methods support the ~Try~ and ~Either~ approaches.
         =TODO=

**** TODO Use ~Try~ or ~Either~ when you want access to the failure reason - 736

*** DONE Discussion - 738
    CLOSED: [2018-02-19 Mon 05:15]
**** Don't use the ~get~ method - 739
     - Only ~Some~ class has ~get~ /method/.
       Use ~get~ when you have ~None~, the result is NOT any better than a
       ~NullPointerException~.

       If you test and then use ~get~ when you are sure about the value is
       ~Some~ type, then you can successfully get the result. However, the
       redundant code is then looks like what you did when you have ~null~.

     - Conclusion:
       As with ~null~ values, when you work with ~Option~ values, PLEASE just
       imagine the ~get~ does NOT exist.

**** Other methods - 739

*** TODO See Also - 740

** TODO 24.7. Building Modular Systems - 740
*** Problem - 740
*** Solution - 740
**** An example - 741
     - *Don't Get Bogged Down*

**** About service - 743

*** Discussion - 744

** TODO 24.8. Handling ~Option~ Values with Higher-Order Functions - 744
*** Problem - 744
*** Solution - 744
**** Sample data - 744

*** Discussion - 747
*** See Also - 748

* Index - 749
