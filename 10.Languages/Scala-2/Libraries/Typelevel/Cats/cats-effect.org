#+TITLE: Cats Effect
#+SUBTITLE: The IO Monad for Scala
#+VERSION: 2.2.0 - available for Scala 2.12.x and 2.13.x, with Scala.js builds targeting 1.x
#+STARTUP: overview
#+STARTUP: entitiespretty

Additionally, cross-builds of 2.3.0-M1 are available for 2.12.x and 2.13.x (with
ScalaJS targeting the 1.x series), as well as Dotty 0.27.0-RC1 and Scala 3.0.0-M1
(without ScalaJS support).

cats-effect v3.0.0-M3 is available

* TODO Preface
** Usage
*** Laws

** Documentation
** Libraries
** Related Projects
** Development
*** Contributing documentation

** License

* TODO Data Types
** TODO IO
   - IO :: A data type for encoding side effects as pure values,
           capable of expressing *BOTH* _synchronous_ and _asynchronous_
           computations.

*** Introduction
**** On Referential Transparency and Lazy Evaluation
**** Stack Safety

*** Describing Effects
**** Pure Values -- ~IO.pure~ & ~IO.unit~
**** Synchronous Effects -- ~IO.apply~
**** Asynchronous Effects -- ~IO.async~ & ~IO.cancelable~
***** Cancelable Processes
***** ~IO.never~

**** Deferred Execution — ~IO.suspend~

*** Concurrency and Cancellation
**** Building cancelable IO tasks
***** Gotcha: Cancellation is a Concurrent Action!

**** Concurrent start + cancel
**** ~runCancelable~ & ~unsafeRunCancelable~
**** uncancelable marker
**** ~IO.cancelBoundary~
***** Comparison to ~IO.shift~

**** Race Conditions — race & racePair
**** Comparison with Haskell's "async interruption"

*** Safe Resource Acquisition and Release
**** status Quo
**** ~bracket~
**** ~bracketCase~

*** Conversions
**** ~fromFuture~
**** ~fromEither~

*** Error Handling
**** ~raiseError~
**** ~attempt~
**** Example: Retrying with Exponential Backoff

*** Thread Shifting
**** ~shift~

*** Parallelism
**** ~parMapN~
**** ~parSequence~
**** ~parTraverse~

*** "Unsafe" Operations
**** ~unsafeRunSync~
**** ~unsafeRunAsync~
**** ~unsafeRunCancelable~
**** ~unsafeRunTimed~
**** ~unsafeToFuture~

*** Best Practices
**** Keep Granularity
**** Use pure functions in ~map~ / ~flatMap~

** TODO SyncIO
*** Constructing ~SyncIO~ values
*** Interoperation with ~Eval~ and ~IO~

** TODO Fiber
** TODO Resource
*** Example
*** Examples
**** With ~scala.io.Source~
**** With ~java.io~ using IO
**** A ~java.io~ example agnostic of the effect type

** TODO Clock
** TODO ContextShift
*** ~shift~
*** ~evalOn~
*** ~Blocker~

** TODO Timer
*** Configuring the global Scheduler

** TODO IOApp
*** Status Quo
*** Pure Programs
**** Cancelation and Safe Resource Release

*** Why Is It Specialized for IO?
*** Final Works

* TODO Concurrency
** TODO Concurrency Basics
*** Introduction
*** Dictionary
**** Concurrency
**** CPU-bound task
**** IO-bound task
**** Non-terminating task

*** Threads
**** Threading (on JVM)
**** Thread Pools
**** Choosing Thread Pool
***** Bounded
***** Unbounded

**** Blocking Threads
**** Green Threads

*** Thread Scheduling
*** Asynchronous / Semantic blocking

** TODO Deferred
*** Only Once
*** Concellation

** TODO MVar
*** Introduction
**** Inspiration

*** Use-case: Synchronized Mutable Variables
*** Use-case: Asynchronous Lock (Binary Semaphore, Mutex)
*** Use-case: Producer/Consumer Channel

** TODO Ref
*** Concurrent Counter

** TODO Semaphore
*** Semantic Blocking and Cancellation
*** Shared Resource

* TODO Type Classes
** Cheat sheet
** Bracket
** LiftIO
** Sync
** Async
** Concurrent
** Effect
** ConcurrentEffect

* TODO Tutorial
** Introduction
** Setting things up
** Copying files - basic concepts, resource handling and cancellation
*** Acquiring and releasing ~Resource~'s
*** What about ~bracket~?
*** Copying data
*** Dealing with cancellation
*** ~IOApp~ for our final program
**** Copy program code

*** Polymorphic cats-effect code
**** Copy program code, polymorphic version

*** Exercises: improving our small ~IO~ program

** Producer-consumer problem - concurrency and fibers
*** Intro to fibers
*** First (and inefficient) implementation
*** Bringing in semaphores
*** Producer consumer with bounded queue
*** On cancellation of producer and consumers
*** Exercise: build a concurrent queue

** Conclusion
* TODO Tracing
** Introduction
** Asynchronous stack tracing
*** Configuration
**** DISABLED
**** CACHED
**** FULL
     
*** Requesting and printing traces

** Enhanced exceptions
*** Complete example
    
* TODO Testing with cats-effect
** Compatible libraries
** Property-based Testing
*** ScalaCheck
    
** Best practices
*** Testing concurrency
*** Managing shared resources
