#+TITLE: Programming in Scala
#+SUBTITLE: A comprehensive step-by-step guide - Updated for Scala 3.0
#+VERSION: 5th - PrePrint
#+AUTHOR: Martin Odersky, Lex Spoon, Bill Venners, Frank Sommers
#+STARTUP: overview
#+STARTUP: entitiespretty

* Contents - xii
* List of Figures - xx
* List of Tables - xxii
* List of Listings - xxiv
* Acknowledgments - xxx
* Introduction - xxxiii
* 1 A Scalable Language - 40
** 1.1 A language that grows on you - 41
** 1.2 What makes Scala scalable? - 44
** 1.3 Why Scala? - 48
** 1.4 Scala’s roots - 55
** 1.5 Conclusion - 56
   
* 2 First Steps in Scala - 58
** Step 1. Learn to use the Scala REPL - 58
** Step 2. Define some variables - 60
** Step 3. Define some functions - 62
** Step 4. Write some Scala scripts - 64
** Step 5. Loop with ~while~; decide with ~if~ - 65
** Step 6. Iterate with ~foreach~ and ~for-do~ - 68
** Conclusion - 70
   
* 3 Next Steps in Scala - 71
** Step 7. Parameterize arrays with types - 71
** Step 8. Use lists - 75
** Step 9. Use tuples - 80
** Step 10. Use sets and maps - 81
** Step 11. Learn to recognize the functional style - 85
** Step 12. Transform with ~map~ and ~for-yield~ - 88
** Conclusion - 91
   
* 4 Classes and Objects - 92
** 4.1 Classes, fields, and methods - 92
** 4.2 Semicolon inference - 96
** 4.3 Singleton objects - 97
** 4.4 Case classes - 100
** 4.5 A Scala application - 102
** 4.6 Conclusion - 104
   
* 5 Basic Types and Operations - 105
** 5.1 Some basic types - 105
** 5.2 Literals - 106
** 5.3 String interpolation - 111
** 5.4 Operators are methods - 113
** 5.5 Arithmetic operations - 116
** 5.6 Relational and logical operations - 117
** 5.7 Bitwise operations - 118
** 5.8 Object equality - 119
** 5.9 Operator precedence and associativity - 121
** 5.10 Rich operations - 124
** 5.11 Conclusion - 124
   
* 6 Functional Objects - 126
** 6.1 A specification for class ~Rational~ - 126
** 6.2 Constructing a ~Rational~ - 127
** 6.3 Reimplementing the ~toString~ method - 129
** 6.4 Checking preconditions - 130
** 6.5 Adding fields - 131
** 6.6 Self references - 133
** 6.7 Auxiliary constructors - 133
** 6.8 Private fields and methods - 135
** 6.9 Defining operators - 136
** 6.10 Identifiers in Scala - 138
** 6.11 Method overloading - 141
** 6.12 Extension methods - 143
** 6.13 A word of caution - 144
** 6.14 Conclusion - 144
   
* 7 Built-in Control Structures - 146
** 7.1 If expressions - 147
** 7.2 While loops - 148
** 7.3 For expressions - 151
** 7.4 Exception handling with ~try~ expressions - 156
** 7.5 Match expressions - 160
** 7.6 Living without ~break~ and ~continue~ - 161
** 7.7 Variable scope - 163
** 7.8 Refactoring imperative-style code - 166
** 7.9 Conclusion - 168
   
* 8 Functions and Closures - 169
** 8.1 Methods - 169
** 8.2 Local functions - 170
** 8.3 First-class functions - 172
** 8.4 Short forms of function literals - 173
** 8.5 Placeholder syntax - 174
** 8.6 Partially applied functions - 175
** 8.7 Closures - 178
** 8.8 Special function call forms - 180
** 8.9 “SAM” types - 183
** 8.10 Tail recursion - 185
** 8.11 Conclusion - 188
   
* 9 Control Abstraction - 189
** 9.1 Reducing code duplication - 189
** 9.2 Simplifying client code - 193
** 9.3 Currying - 195
** 9.4 Writing new control structures - 196
** 9.5 By-name parameters - 199
** 9.6 Conclusion - 201
   
* 10 Composition and Inheritance - 203
** 10.1 A two-dimensional layout library - 203
** 10.2 Abstract classes - 204
** 10.3 Defining parameterless methods - 205
** 10.4 Extending classes - 208
** 10.5 Overriding methods and fields - 210
** 10.6 Defining parametric fields - 211
** 10.7 Invoking superclass constructors - 213
** 10.8 Using ~override~ modifiers - 214
** 10.9 Polymorphism and dynamic binding - 216
** 10.10 Declaring final members - 218
** 10.11 Using composition and inheritance - 219
** 10.12 Implementing ~above~, ~beside~, and ~toString~ - 221
** 10.13 Defining a factory object - 223
** 10.14 Heighten and widen - 225
** 10.15 Putting it all together - 226
** 10.16 Conclusion - 230
   
* 11 Traits - 231
** 11.1 How traits work - 231
** 11.2 Thin versus rich interfaces - 234
** 11.3 Traits as stackable modifications - 236
** 11.4 Why not multiple inheritance? - 240
** 11.5 Trait parameters - 245
** 11.6 Conclusion - 247
   
* 12 Packages and Imports - 248
** 12.1 Putting code in packages - 248
** 12.2 Concise access to related code - 249
** 12.3 Imports - 253
** 12.4 Implicit imports - 256
** 12.5 Access modifiers - 257
** 12.6 Top-level definitions - 262
** 12.7 Exports - 263
** 12.8 Conclusion - 266
   
* 13 Pattern Matching - 267
** 13.1 A simple example - 267
** 13.2 Kinds of patterns - 271
** 13.3 Pattern guards - 280
** 13.4 Pattern overlaps - 282
** 13.5 Sealed classes - 283
** 13.6 Pattern matching ~Option~'s - 285
** 13.7 Patterns everywhere - 287
** 13.8 A larger example - 291
** 13.9 Conclusion - 299
    
* 14 Working with Lists - 300
** 14.1 List literals - 300
** 14.2 The ~List~ type - 301
** 14.3 Constructing lists - 301
** 14.4 Basic operations on lists - 302
** 14.5 List patterns - 303
** 14.6 First-order methods on class ~List~ - 305
** 14.7 Higher-order methods on class ~List~ - 316
** 14.8 Methods of the ~List~ object - 323
** 14.9 Processing multiple lists together - 325
** 14.10 Understanding Scala’s type inference algorithm - 327
** 14.11 Conclusion - 330
   
* 15 Working with Other Collections - 331
** 15.1 Sequences - 331
** 15.2 Sets and maps - 335
** 15.3 Selecting mutable versus immutable collections - 342
** 15.4 Initializing collections - 344
** 15.5 Tuples - 347
** 15.6 Conclusion - 349
   
* 16 Mutable Objects - 351
** 16.1 What makes an object mutable? - 351
** 16.2 Reassignable variables and properties - 353
** 16.3 Case study: Discrete event simulation - 357
** 16.4 A language for digital circuits - 357
** 16.5 The Simulation API - 361
** 16.6 Circuit Simulation - 365
** 16.7 Conclusion - 372
   
* 17 Scala’s Hierarchy - 374
** 17.1 Scala’s class hierarchy - 374
** 17.2 How primitives are implemented - 378
** 17.3 Bottom types - 380
** 17.4 Defining your own value classes - 381
** 17.5 Intersection types - 384
** 17.6 Union types - 385
** 17.7 Conclusion - 388
   
* 18 Type Parameterization - 389
** 18.1 Functional queues - 389
** 18.2 Information hiding - 392
** 18.3 Variance annotations - 395
** 18.4 Checking variance annotations - 400
** 18.5 Lower bounds - 403
** 18.6 Contravariance - 404
** 18.7 Upper bounds - 408
** 18.8 Conclusion - 410
   
* TODO 19 Enums - 411
  Scala 3 introduced the ~enum~ construct to make the definition of
  /sealed case class/ hierachies _more concise_.

  - /Enums/ can be used to define both /enums/ in Java, and /enums/ in Haskell.
  
** DONE 19.1 Enumerated data types - 411
   CLOSED: [2021-03-02 Tue 23:02]
   In this book, we call the  /enumerated data type/ *EDT*, to distinguish it
   from *ADT*'s.
   
   - Example:
     #+begin_src scala
       enum Direction:
         case North, East, South, West
     #+end_src

   - ~enum~'s build-in methods:
     * ~ordinal~: start at 0 and increases by one for each case, in the order the
       cases are defined in the /enum/.

     * ~values~: ~Array[YourEnumType]~
       
     * ~valueOf~: Convert a string, which is exactly the same as an enum case name,
       to that enum value.

   - Give an EDT value parameter(s):
     #+begin_src scala
       enum Direction(val degrees: Int):
         case North extends Direction(0)
         case East  extends Direction(90)
         case South extends Direction(180)
         case West  extends Direction(270)
     #+end_src

   - You can define a /method/ inside a /enum/:
     #+begin_src scala
       enum Direction(val degrees: Int):
         case North extends Direction(0)
         case East  extends Direction(90)
         case South extends Direction(180)
         case West  extends Direction(270)

         def invert: Direction =
           this match
             case North => South
             case East  => West
             case South => North
             case West  => East
     #+end_src
     * You can only define /methods/ for a whole /enum/, not for some SPECIFIC
       /enum case(s)/.

     * *footnote*:
       Of course, you COULD define /extension methods/ for the case types, but it
       might be better in that situation to just write out the /sealed case
       class hierarchy/ by hand.
     
   - *Integration with Java enums*
     #+begin_src scala
       enum Direction extends java.lang.Enum[Direction]:
         case North, East, South, West
     #+end_src
     
     Then you can all /Java enums/ /methods/ on these values. For instance,
     ~Direction.East.compareTo(Direction.South)  // -1~
     
** DONE 19.2 Algebraic data types - 415
   CLOSED: [2021-03-03 Wed 00:53]
   - Algebraic Data Type (ADT) :: a data type composed of a finite set of cases.
     
   - In Scala, a _sealed_ family of /case classes/ forms an /ADT/
     so long as *AT LEAST _ONE_ of the cases take parameters.*
     * footnote:
       By comparison,
       an EDT is a _sealed_ family of /case classes/ in which *NONE of the cases
       take parameters.*

   - When you create a case of an /ADT/ by using its /factory method/ (=from Jian=
     the ~apply~ /method/), the compiler will *widen* its type to the more general
     ~enum~ type.
     * If you want the more specific type, use the constructor (~new~ it).
     
   - /ADT/'s can be *recursive*.
     * =from Jian=
       /EDT/'s can never be recursive, because *NONE of the cases take parameters.*

   - Example:
     #+begin_src scala
       enum Seinfeld[+E]:
         def ::[E2 >: E](o: E2): Seinfeld[E2] = Yada(o, this)

         case Yada(head: E, tail: Seinfeld[E])
         case Nada

       val xs = 1 :: 2 :: 3 :: Nada
       // val xs = Yada(1, Yada(2, Yada(3, Nada)))
     #+end_src
     
** DONE 19.3 Generalized ADTs - 417
   CLOSED: [2021-03-03 Wed 01:44]
   - Generalized Algebraic Data Types (GADTs) :: ADTs in which the sealed trait
     takes a /type parameter/ that is filled in by the cases.
     
   - Example:
     #+begin_src scala
       enum Literal[T]:
         case IntLit(value: Int)         extends Literal[Int]
         case LongLit(value: Long)       extends Literal[Long]
         case CharLit(value: Char)       extends Literal[Char]
         case FloatLit(value: Float)     extends Literal[Float]
         case DoubleLit(value: Double)   extends Literal[Double]
         case BooleanLit(value: Boolean) extends Literal[Boolean]
         case StringLit(value: String)   extends Literal[String]
     #+end_src
     The ~Literal~ /enum/ represents a /GADT/ because it takes a /type parameter/
     ~T~, which is specified by EACH of its cases in their _extends clauses_.

   - =IMPORTANT=
     This kind of /sealed type heirarchy/ is given the special name "generalized ADT"
     because it presents *SPECIAL CHALLENGES to /type checking and inference/.*
     * Here's an illustrative example:
       #+begin_src scala
         import Literal.*

         def valueOfLiteral[T](lit: Literal[T]): T =
           lit match
             case IntLit(n)     => n
             case LongLit(m)    => m
             case CharLit(c)    => c
             case FloatLit(f)   => f
             case DoubleLit(d)  => d
             case BooleanLit(b) => b
             case StringLit(s)  => s
       #+end_src
       The ~valueOfLiteral~ /method/ passes the /type checker/, despite none of
       it match alternatives resulting in the required result type, ~T~.
       + For example,
         =FIXME= IntList => IntLit
         the ~case IntLit(n)~ alternative results in ~n~, which has type ~Int~.
         The challenge is that ~Int~ is not type ~T~, nor is ~Int~ a /subtype/ of ~T~.
           This /type checks/ only because the compiler notices that for the
         ~IntLit~ case, ~T~ can be none other than ~Int~.
           Moreover, this _MORE SPECIFIC_ /type/ is propagated back to the caller.
         #+begin_src scala
           valueOfLiteral(BooleanLit(true))  // true: Boolean
           valueOfLiteral(IntLit(42))        // 42: Int
         #+end_src
     
** 19.4 What makes ADTs algebraic - 418 - =RE-READ= =NOTE=
** 19.5 Conclusion - 422
   
* 20 Abstract Members - 423
** 20.1 A quick tour of abstract members - 423
** 20.2 Type members - 424
** 20.3 Abstract ~val~'s - 425
** 20.4 Abstract ~var~'s - 425
** 20.5 Initializing abstract ~val~'s - 427
** 20.6 Abstract types - 434
** 20.7 Path-dependent types - 436
** 20.8 Refinement types - 439
** 20.9 Case study: Currencies - 440
** 20.10 Conclusion - 448
   
* 21 Givens - 451
** 21.1 How it works - 451
** 21.2 Parameterized given types - 455
** 21.3 Anonymous givens - 460
** 21.4 Parameterized givens as typeclasses - 461
** 21.5 Given imports - 464
** 21.6 Rules for context parameters - 465
** 21.7 When multiple givens apply - 468
** 21.8 Debugging givens - 470
** 21.9 Conclusion - 472
   
* 22 Extension Methods - 473
** 22.1 The basics - 473
** 22.2 Generic extensions - 476
** 22.3 Collective extensions - 477
** 22.4 Using a typeclass - 480
** 22.5 Extension methods for givens - 482
** 22.6 Where Scala looks for extension methods - 486
** 22.7 Conclusion - 487
   
* 23 Typeclasses - 489
** 23.1 Why typeclasses? - 489
** 23.2 Context bounds - 494
** 23.3 Main methods - 497
** 23.4 Multiversal equality - 501
** 23.5 Implicit conversions - 507
** 23.6 Still to come... - 510
** 23.7 Conclusion - 510
  
* 24 Collections in Depth - 511
** 24.1 Mutable and immutable collections - 512
** 24.2 Collections consistency - 514
** 24.3 Trait ~Iterable~ - 516
** 24.4 The sequence traits ~Seq~, ~IndexedSeq~, and ~LinearSeq~ - 523
** 24.5 Sets - 529
** 24.6 Maps - 533
** 24.7 Concrete immutable collection classes - 538
** 24.8 Concrete mutable collection classes - 545
** 24.9 Arrays - 549
** 24.10 Strings - 554
** 24.11 Performance characteristics - 554
** 24.12 Equality - 557
** 24.13 Views - 558
** 24.14 Iterators - 562
** 24.15 Creating collections from scratch - 570
** 24.16 Conversions between Java and Scala collections - 572
** 24.17 Conclusion - 574
  
* 25 Assertions and Tests - 575
** 24.1 Assertions - 575
** 24.2 Testing in Scala - 577
** 24.3 Informative failure reports - 578
** 24.4 Tests as specifications - 580
** 24.5 Property-based testing - 583
** 24.6 Organizing and running tests - 585
** 24.7 Conclusion - 586
   
* Glossary - 587
* Bibliography - 603
* About the Authors - 606
* Index - 607
