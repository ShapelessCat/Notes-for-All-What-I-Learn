#+TITLE: Programming in Scala
#+SUBTITLE: A comprehensive step-by-step guide - Updated for Scala 3.0
#+VERSION: 5th
#+AUTHOR: Martin Odersky, Lex Spoon, Bill Venners, Frank Sommers
#+STARTUP: overview
#+STARTUP: entitiespretty

* Contents - xi
* List of Figures - xix
* List of Tables - xxi
* List of Listings - xxiii
* Foreword - xxix
* Acknowledgments - xxxiii
* Introduction - xxxvi
* 1 A Scalable Language - 43
** 1.1 A language that grows on you - 44
** 1.2 What makes Scala scalable? - 47
** 1.3 Why Scala? - 51
** 1.4 Scala’s roots - 58
** 1.5 Conclusion - 59
   
* 2 First Steps in Scala - 61
** Step 1. Learn to use the Scala REPL - 61
** Step 2. Define some variables - 63
** Step 3. Define some functions - 65
** Step 4. Write some Scala scripts - 67
** Step 5. Loop with ~while~; decide with ~if~ - 68
** Step 6. Iterate with ~foreach~ and ~for-do~ - 71
** Conclusion - 73
   
* 3 Next Steps in Scala - 74
** Step 7. Parameterize arrays with types - 74
** Step 8. Use lists - 78
** Step 9. Use tuples - 83
** Step 10. Use sets and maps - 84
** Step 11. Learn to recognize the functional style - 88
** Step 12. Transform with ~map~ and ~for-yield~ - 91
** Conclusion - 94
   
* 4 Classes and Objects - 95
** 4.1 Classes, fields, and methods - 95
** 4.2 Semicolon inference - 99
** 4.3 Singleton objects - 100
** 4.4 Case classes - 103
** 4.5 A Scala application - 105
** 4.6 Conclusion - 107
   
* 5 Basic Types and Operations - 108
** 5.1 Some basic types - 108
** 5.2 Literals - 109
** 5.3 String interpolation - 114
** 5.4 Operators are methods - 116
** 5.5 Arithmetic operations - 119
** 5.6 Relational and logical operations - 120
** 5.7 Bitwise operations - 121
** 5.8 Object equality - 122
** 5.9 Operator precedence and associativity - 124
** 5.10 Rich operations - 127
** 5.11 Conclusion - 127
   
* 6 Functional Objects - 129
** 6.1 A specification for class ~Rational~ - 129
** 6.2 Constructing a ~Rational~ - 130
** 6.3 Reimplementing the ~toString~ method - 132
** 6.4 Checking preconditions - 133
** 6.5 Adding fields - 134
** 6.6 Self references - 136
** 6.7 Auxiliary constructors - 136
** 6.8 Private fields and methods - 138
** 6.9 Defining operators - 139
** 6.10 Identifiers in Scala - 141
** 6.11 Method overloading - 144
** 6.12 Extension methods - 146
** 6.13 A word of caution - 147
** 6.14 Conclusion - 147
   
* 7 Built-in Control Structures - 149
** 7.1 If expressions - 150
** 7.2 While loops - 151
** 7.3 For expressions - 154
** 7.4 Exception handling with ~try~ expressions - 159
** 7.5 Match expressions - 163
** 7.6 Living without ~break~ and ~continue~ - 164
** 7.7 Variable scope - 166
** 7.8 Refactoring imperative-style code - 169
** 7.9 Conclusion - 171
   
* 8 Functions and Closures - 172
** 8.1 Methods - 172
** 8.2 Local functions - 173
** 8.3 First-class functions - 175
** 8.4 Short forms of function literals - 176
** 8.5 Placeholder syntax - 177
** 8.6 Partially applied functions - 178
** 8.7 Closures - 181
** 8.8 Special function call forms - 183
** 8.9 “SAM” types - 186
** 8.10 Tail recursion - 188
** 8.11 Conclusion - 191
   
* 9 Control Abstraction - 192
** 9.1 Reducing code duplication - 192
** 9.2 Simplifying client code - 196
** 9.3 Currying - 198
** 9.4 Writing new control structures - 199
** 9.5 By-name parameters - 202
** 9.6 Conclusion - 204
   
* 10 Composition and Inheritance - 206
** 10.1 A two-dimensional layout library - 206
** 10.2 Abstract classes - 207
** 10.3 Defining parameterless methods - 208
** 10.4 Extending classes - 211
** 10.5 Overriding methods and fields - 213
** 10.6 Defining parametric fields - 214
** 10.7 Invoking superclass constructors - 216
** 10.8 Using ~override~ modifiers - 217
** 10.9 Polymorphism and dynamic binding - 219
** 10.10 Declaring ~final~ members - 221
** 10.11 Using composition and inheritance - 222
** 10.12 Implementing ~above~, ~beside~, and ~toString~ - 224
** 10.13 Defining a factory object - 226
** 10.14 Heighten and widen - 228
** 10.15 Putting it all together - 230
** 10.16 Conclusion - 233
   
* 11 Traits - 234
** 11.1 How traits work - 234
** 11.2 Thin versus rich interfaces - 237
** 11.3 Traits as stackable modifications - 239
** 11.4 Why not multiple inheritance? - 243
** 11.5 Trait parameters - 248
** 11.6 Conclusion - 250
   
* 12 Packages and Imports - 251
** 12.1 Putting code in packages - 251
** 12.2 Concise access to related code - 252
** 12.3 Imports - 256
** 12.4 Implicit imports - 259
** 12.5 Access modifiers - 260
** 12.6 Top-level definitions - 265
** 12.7 Exports - 266
** 12.8 Conclusion - 269
   
* 13 Pattern Matching - 270
** 13.1 A simple example - 270
** 13.2 Kinds of patterns - 274
** 13.3 Pattern guards - 284
** 13.4 Pattern overlaps - 285
** 13.5 Sealed classes - 287
** 13.6 Pattern matching ~Option~'s - 289
** 13.7 Patterns everywhere - 291
** 13.8 A larger example - 295
** 13.9 Conclusion - 303
   
* 14 Working with Lists - 304
** 14.1 List literals - 304
** 14.2 The ~List~ type - 305
** 14.3 Constructing lists - 305
** 14.4 Basic operations on lists - 306
** 14.5 List patterns - 307
** 14.6 First-order methods on class ~List~ - 309
** 14.7 Higher-order methods on class ~List~ - 320
** 14.8 Methods of the ~List~ object - 327
** 14.9 Processing multiple lists together - 329
** 14.10 Understanding Scala’s type inference algorithm - 331
** 14.11 Conclusion - 334
   
* 15 Working with Other Collections - 335
** 15.1 Sequences - 335
** 15.2 Sets and maps - 339
** 15.3 Selecting mutable versus immutable collections - 346
** 15.4 Initializing collections - 348
** 15.5 Tuples - 351
** 15.6 Conclusion - 353
   
* 16 Mutable Objects - 355
** 16.1 What makes an object mutable? - 355
** 16.2 Reassignable variables and properties - 357
** 16.3 Case study: Discrete event simulation - 361
** 16.4 A language for digital circuits - 362
** 16.5 The ~Simulation~ API - 365
** 16.6 Circuit Simulation - 369
** 16.7 Conclusion - 376
   
* 17 Scala’s Hierarchy - 378
** 17.1 Scala’s class hierarchy - 378
** 17.2 How primitives are implemented - 382
** 17.3 Bottom types - 384
** 17.4 Defining your own value classes - 385
** 17.5 Intersection types - 388
** 17.6 Union types - 389
** 17.7 Transparent traits - 392
** 17.8 Conclusion - 393
   
* 18 Type Parameterization - 394
** 18.1 Functional queues - 394
** 18.2 Information hiding - 397
** 18.3 Variance annotations - 400
** 18.4 Checking variance annotations - 405
** 18.5 Lower bounds - 408
** 18.6 Contravariance - 409
** 18.7 Upper bounds - 413
** 18.8 Conclusion - 415
   
* TODO 19 Enums - 416
  Scala 3 introduced the ~enum~ construct to make the definition of
  /sealed case class/ hierachies _more concise_.

  - /Enums/ can be used to define both /enums/ in Java, and /enums/ in Haskell.
  
** DONE 19.1 Enumerated data types - 416
   CLOSED: [2021-03-02 Tue 23:02]
   In this book, we call the  /enumerated data type/ *EDT*, to distinguish it
   from *ADT*'s.
   
   - Example:
     #+begin_src scala
       enum Direction:
         case North, East, South, West
     #+end_src

   - ~enum~'s build-in methods:
     * ~ordinal~: start at 0 and increases by one for each case, in the order the
       cases are defined in the /enum/.

     * ~values~: ~Array[YourEnumType]~
       
     * ~valueOf~: Convert a string, which is exactly the same as an enum case name,
       to that enum value.

   - Give an EDT value parameter(s):
     #+begin_src scala
       enum Direction(val degrees: Int):
         case North extends Direction(0)
         case East  extends Direction(90)
         case South extends Direction(180)
         case West  extends Direction(270)
     #+end_src

   - You can define a /method/ inside a /enum/:
     #+begin_src scala
       enum Direction(val degrees: Int):
         case North extends Direction(0)
         case East  extends Direction(90)
         case South extends Direction(180)
         case West  extends Direction(270)

         def invert: Direction =
           this match
             case North => South
             case East  => West
             case South => North
             case West  => East
     #+end_src
     * You can only define /methods/ for a whole /enum/, not for some SPECIFIC
       /enum case(s)/.

     * *footnote*:
       Of course, you COULD define /extension methods/ for the case types, but it
       might be better in that situation to just write out the /sealed case
       class hierarchy/ by hand.
     
   - *Integration with Java enums*
     #+begin_src scala
       enum Direction extends java.lang.Enum[Direction]:
         case North, East, South, West
     #+end_src
     
     Then you can all /Java enums/ /methods/ on these values. For instance,
     ~Direction.East.compareTo(Direction.South)  // -1~
     
** DONE 19.2 Algebraic data types - 420
   CLOSED: [2021-03-03 Wed 00:53]
   - Algebraic Data Type (ADT) :: a data type composed of a finite set of cases.
     
   - In Scala, a _sealed_ family of /case classes/ forms an /ADT/
     so long as *AT LEAST _ONE_ of the cases take parameters.*
     * footnote:
       By comparison,
       an EDT is a _sealed_ family of /case classes/ in which *NONE of the cases
       take parameters.*

   - When you create a case of an /ADT/ by using its /factory method/ (=from Jian=
     the ~apply~ /method/), the compiler will *widen* its type to the more general
     ~enum~ type.
     * If you want the more specific type, use the constructor (~new~ it).
     
   - /ADT/'s can be *recursive*.
     * =from Jian=
       /EDT/'s can never be recursive, because *NONE of the cases take parameters.*

   - Example:
     #+begin_src scala
       enum Seinfeld[+E]:
         def ::[E2 >: E](o: E2): Seinfeld[E2] = Yada(o, this)

         case Yada(head: E, tail: Seinfeld[E])
         case Nada

       val xs = 1 :: 2 :: 3 :: Nada
       // val xs = Yada(1, Yada(2, Yada(3, Nada)))
     #+end_src
     
** DONE 19.3 Generalized ADTs - 422
   CLOSED: [2021-03-03 Wed 01:44]
   - Generalized Algebraic Data Types (GADTs) :: ADTs in which the sealed trait
     takes a /type parameter/ that is filled in by the cases.
     
   - Example:
     #+begin_src scala
       enum Literal[T]:
         case IntLit(value: Int)         extends Literal[Int]
         case LongLit(value: Long)       extends Literal[Long]
         case CharLit(value: Char)       extends Literal[Char]
         case FloatLit(value: Float)     extends Literal[Float]
         case DoubleLit(value: Double)   extends Literal[Double]
         case BooleanLit(value: Boolean) extends Literal[Boolean]
         case StringLit(value: String)   extends Literal[String]
     #+end_src
     The ~Literal~ /enum/ represents a /GADT/ because it takes a /type parameter/
     ~T~, which is specified by EACH of its cases in their _extends clauses_.

   - =IMPORTANT=
     This kind of /sealed type heirarchy/ is given the special name "generalized ADT"
     because it presents *SPECIAL CHALLENGES to /type checking and inference/.*
     * Here's an illustrative example:
       #+begin_src scala
         import Literal.*

         def valueOfLiteral[T](lit: Literal[T]): T =
           lit match
             case IntLit(n)     => n
             case LongLit(m)    => m
             case CharLit(c)    => c
             case FloatLit(f)   => f
             case DoubleLit(d)  => d
             case BooleanLit(b) => b
             case StringLit(s)  => s
       #+end_src
       The ~valueOfLiteral~ /method/ passes the /type checker/, despite none of
       it match alternatives resulting in the required result type, ~T~.
       + For example,
         =FIXME= IntList => IntLit
         the ~case IntLit(n)~ alternative results in ~n~, which has type ~Int~.
         The challenge is that ~Int~ is not type ~T~, nor is ~Int~ a /subtype/ of ~T~.
           This /type checks/ only because the compiler notices that for the
         ~IntLit~ case, ~T~ can be none other than ~Int~.
           Moreover, this _MORE SPECIFIC_ /type/ is propagated back to the caller.
         #+begin_src scala
           valueOfLiteral(BooleanLit(true))  // true: Boolean
           valueOfLiteral(IntLit(42))        // 42: Int
         #+end_src
     
** 19.4 What makes ADTs algebraic - 423 - =RE-READ= =NOTE=
** 19.5 Conclusion - 427
   
* 20 Abstract Members - 428
** 20.1 A quick tour of abstract members - 428
** 20.2 Type members - 429
** 20.3 Abstract ~val~'s - 430
** 20.4 Abstract ~var~'s - 430
** 20.5 Initializing abstract ~val~'s - 432
** 20.6 Abstract types - 439
** 20.7 Path-dependent types - 441
** 20.8 Refinement types - 444
** 20.9 Case study: Currencies - 445
** 20.10 Conclusion - 453
   
* 21 Givens - 455
** 21.1 How it works - 455
** 21.2 Parameterized given types - 459
** 21.3 Anonymous givens - 465
** 21.4 Parameterized givens as typeclasses - 465
** 21.5 Given imports - 468
** 21.6 Rules for context parameters - 469
** 21.7 When multiple givens apply - 472
** 21.8 Debugging givens - 474
** 21.9 Conclusion - 476
   
* 22 Extension Methods - 477
** 22.1 The basics - 477
** 22.2 Generic extensions - 480
** 22.3 Collective extensions - 481
** 22.4 Using a typeclass - 484
** 22.5 Extension methods for givens - 486
** 22.6 Where Scala looks for extension methods - 490
** 22.7 Conclusion - 491
   
* 23 Typeclasses - 493
** 23.1 Why typeclasses? - 493
** 23.2 Context bounds - 498
** 23.3 Main methods - 501
** 23.4 Multiversal equality - 505
** 23.5 Implicit conversions - 511
** 23.6 Typeclass case study: JSON serialization - 514
** 23.7 Conclusion - 523
   
* 24 Collections in Depth - 525
** 24.1 Mutable and immutable collections - 526
** 24.2 Collections consistency - 526
** 24.3 Trait ~Iterable~ - 530
** 24.4 The sequence traits ~Seq~, ~IndexedSeq~, and ~LinearSeq~ - 527
** 24.5 Sets - 544
** 24.6 Maps - 548
** 24.7 Concrete immutable collection classes - 552
** 24.8 Concrete mutable collection classes - 559
** 24.9 Arrays - 564
** 24.10 Strings - 568
** 24.11 Performance characteristics - 569
** 24.12 Equality - 571
** 24.13 Views - 572
** 24.14 Iterators - 576
** 24.15 Creating collections from scratch - 584
** 24.16 Conversions between Java and Scala collections - 586
** 24.17 Conclusion - 588
   
* 25 Assertions and Tests - 589
** 24.1 Assertions - 589
** 24.2 Testing in Scala - 591
** 24.3 Informative failure reports - 592
** 24.4 Tests as specifications - 594
** 24.5 Property-based testing - 597
** 24.6 Organizing and running tests - 599
** 24.7 Conclusion - 600
   
* Glossary - 601
* Bibliography - 617
* About the Authors - 621
* Index - 622
