#+TITLE: Scala with Cats
#+AUTHOR: Noel Welsh, Dave Gurnell
#+Date: July 2020
#+VERSION: from Me, try to rewrite with Scala 3
#+STARTUP: overview
#+STARTUP: entitiespretty

* DONE Preface - 1
  CLOSED: [2021-07-27 Tue 01:42]
  - The *AIMS* of this book are _TWO-FOLD_:
    * to *introduce* /monads/, /functors/, and OTHER /functional programming patterns/
      as a way to *structure program design*,

    * to *explain* HOW these concepts are *implemented in Cats*.

  - /Functional patterns/ differ from /OO patterns/ in *TWO* main ways:
    * thye are _formally_, and thus _precisely_, defined;
      + =from Jian=
        OO patterns also have formal theory, but not as the functional patterns,
        which are math itself. For OO, a bridge need to be built between it and
        math.

    * they are extremely (extremely) GENERAL.

** DONE Versions - 2
   CLOSED: [2021-07-27 Tue 01:42]
   This book use *Scala 2.13.1* and *Cats 2.1.0*.
   You can use this minimal =build.sbt=:
   #+BEGIN_SRC scala
     scalaVersion := "2.13.1"

     libraryDependencies +=
       "org.typelevel" %% "cats-core" % "2.1.0"

     scalacOptions ++= Seq(
       "-Xfatal-warnings"
       // "-Ypartial-unification"  /// No longer required, it is by default on in Scala 2.13
     )
   #+END_SRC

   - Footnote:
     Assume our SBT version is 1.0.0+

   - =from Jian=
     I'll try to use *Scala 3.0.1* and *Cats 2.6.1*
     
*** Template Projects - 2 - =TODO=
    - The minimal one:
      ~sbt new underscoreio/cats-seed.g8~

    - The more batteries-included one:
      ~sbt new typelevel/sbt-catalysts.g8~

    - =TODO= =LEARN MORE=
      =tut-enabled=, =catalysts=, =sbt-catalysts=.

** DONE Conventions Used in This Book - 3
   CLOSED: [2021-07-27 Tue 01:42]
*** Typographical Conventions - 3
*** Source Code - 3
*** Callout Boxes - 4

** DONE Acknowledgements - 4
   CLOSED: [2021-07-27 Tue 01:42]
*** Backers - 5

* Part I. Theory - 7
* DONE 1 Introduction - 9
  CLOSED: [2019-03-23 Sat 02:53]
  Cats contains a wide variety of functional programming tools
    The majority of the tools provided by Cats are delivered in the form of
  /type classes/.

  - In this chapter we will
    1. refresh our memory of type classes from Underscore's _Essential Scala_ book
    2. take a first look at the Cats codebase.
       * We will look at _two_ example /type classes/ -- ~Show~ and ~Eq~ -- using
         them to identify patterns that lay the foundations for the rest of the book.

  - =TODO= =TODO= =TODO= =???= =???= =???=
    We'll finish by _tying_ /type classes/ _back into_ /algebraic data types/,
    /pattern matching/, /value classes/, and /type aliases/, presenting a
    structured approach to functional programming in Scala.

** DONE 1.1 Anatomy of a Type Class - 10
   CLOSED: [2021-07-28 Wed 23:13]
   - There are *THREE* important _components_ to the /type class pattern/:
     1. the /type class/ ITSELF
     2. /instances/ for particular types
     3. the /interface methods/ that we expose to users

   - Scala language constructs correspond to the components of /type classes/ as
     follows:
     * /traits/: /type classes/;
     * /given instances/: /type classes instances/;
     * /using clauses/: /type classes/ USE;
        
*** DONE 1.1.1 The Type Class - 10
    CLOSED: [2021-07-27 Tue 02:14]
    A /type class/ is an /interface/ OR /API/
    that REPRESENTS some functionality we want to implement.

    - In Cats,
      a /type class/ is REPRESENTED by
      _a *trait* with AT LEAST *ONE* /type parameter/._

    - For example,
      represent generic "serialize to JSON" behaviour as follows:
      #+begin_src scala
        // Define a very simple JSON AST
        enum Json {
          case JsObject(get: Map[String, Json])
          case JsString(get: String)
          case JsNumber(get: Double)
          case JsNull
        }
        
        // The "serialize to JSON" behaviour is encoded in this trait
        trait JsonWriter[A] {
          def write(value: A): Json
        }
      #+end_src
      ~JsonWriter~ is our "type class", with ~Json~ and its /subtypes/ providing
      supporting code.

*** DONE 1.1.2 Type Class Instances - 10
    CLOSED: [2021-07-27 Tue 02:14]
    _The /instances/ of a /type class/ provide *implementations for the types* we
    care about._

    - In Scala,
      we define /instances/ by
      * creating *concrete implementations* of the /type class/
      * tagging them with the ~given~ keyword:

    - Example code:
      #+begin_src scala
        final case class Person(name: String, email: String)
        
        object JsonWriterInstances {
          given stringWriter: JsonWriter[String] =
            new JsonWriter[String] {
              def write(value: String): Json =
                JsString(value)
            }
        
          given personWriter: JsonWriter[Person] =
            new JsonWriter[Person] {
              def write(value: Person): Json = JsObject(
                Map("name"  -> JsString(value.name),
                    "email" -> JsString(value.email))
              )
            }
        
          // etc...
        }
      #+end_src

*** DONE 1.1.3 Type Class Interfaces - 11
    CLOSED: [2020-02-16 Sun 20:15]
    A /type class interface/ is any functionality we expose to users.

    - /Interfaces/ are /generic methods/ that _accept_ /instances/ of the /type
      class/ as /implicit parameters/.

    - There are _two_ common ways of specifying an /interface/:
      1. *Interface Objects*
      2. *Interface Syntax* -- =from Jian= more flexible and fluent

**** DONE Interface Objects - 11
     CLOSED: [2021-07-27 Tue 02:33]
     The SIMPLEST way of creating an /interface/ is to place /methods/ in a
     /singleton object/:
     #+begin_src scala
       object Json {
         def toJson[A](value: A)(using w: JsonWriter[A]): Json =
           w.write(value)
       }
     #+end_src

     - Use case:
       #+begin_src scala
         import JsonWriterInstances.given

         Json.toJson(Person("Dave", "dave@example.com"))
         // res4: Json = JsObject(Map(name -> JsString(Dave), email -> JsString(dave@example.com)))
       #+end_src

       The compiler inserts the required /context parameter/:
       ~Json.toJson(Person("Dave", "dave@example.com"))(personWriter)~

**** DONE Interface Syntax - 12
     CLOSED: [2021-07-27 Tue 02:41]
     We can _ALTERNATIVELY_ use /extension methods/ to *extend* _existing
     types_.

     - =from Jian=
       Add
       #+begin_src scala
         extension [A](j: A) def toJson(using w: JsonWriter[A]): Json =
           w.write(j)
       #+end_src
       to the ~JsonWriterInstances~

       * =from Jian= =???= =TODO=
         Should I write the ~def toJson(using w: JsonWriter[A]): Json~ part
         as ~def toJson: JsonWriter[A] ?=> Json~

       * Use case:
         #+begin_src scala
           import JsonWriterInstances.{given, *}
           
           Person("Dave", "dave@example.com").toJson
           // res6: Json = JsObject(Map(name  -> JsString(Dave),
           //                           email -> JsString(dave@example.com)))
         #+end_src
         The compiler _searches_ for candidates for the /implicit parameters/ and
         _fill_ them in for us:
         ~Person("Dave", "dave@example.com").toJson(personWriter)~

     - The Scala 2 way:
       Cats refers to this as *syntax* for the /type class/:
       #+begin_src scala
         object JsonSyntax {
           implicit class JsonWriterOps[A](value: A) {
             def toJson(implicit w: JsonWriter[A]): Json =
               w.write(value)
           }
         }
       #+end_src
       * Use case:
         #+begin_src scala
           import JsonWriterInstances._
           import JsonSyntax._

           Person("Dave", "dave@example.com").toJson
           // res6: Json = JsObject(Map(name  -> JsString(Dave),
           //                           email -> JsString(dave@example.com)))
         #+end_src
         The compiler _searches_ for candidates for the /implicit parameters/ and
         _fill_ them in for us:
         ~Person("Dave", "dave@example.com").toJson(personWriter)~
       
**** DONE The ~implicitly~ Method - 13
     CLOSED: [2021-07-27 Tue 02:47]
     =from Jian= In Scala 3, "The ~summon~ Method" is the right title.
     
     We can use ~implicitly~ to summon any value from an /implicit scope/.
     =from Jian=
     (In Scala 3, we can use ~summon~ to summon any value from a /context scope/).

     - Most /type classes/ in Cats provide *other means* to _summon_ /instances/.
       =???= =TODO=
       =???= =TODO=
       =???= =TODO=
       HOWEVER, ~summon~ is a *good fallback* _for debugging purposes_.
       =???= =TODO=
       =???= =TODO=
       =???= =TODO=
       * We can insert a call to ~summon~ within the general flow of our code to
         + _ensure_ the compiler CAN FIND an /instance/ of a /type class/
         + _ensure_ that there are *no* AMBIGUOUS implicit errors.

       * =from Jian=
         Of course, we don't need to insert it, but insert it some times can help
         us in debugging: then we know at one given specific point, if there is
         an expected /instance/ of a /type class/ or if there is *no* AMBIGUOUS!

** DONE 1.2 Working with Implicits - 13
   CLOSED: [2021-07-28 Wed 23:13]
   _Working with /type classes/ in Scala_ means working with /given instances/
   and /using clauses/.

   - =TODO=
     There are a few rules we need to know to do this effectively.

*** DONE 1.2.1 Packaging Implicits - 13
    CLOSED: [2021-07-27 Tue 14:10]
    *Placing* /instances/ in a /companion object/ to the /type class/ has
    special significance in Scala because it plays into something called
    /implicit scope/.

*** DONE 1.2.2 Implicit Scope - 14
    CLOSED: [2021-07-27 Tue 14:10]
    - The _compiler_ *searches* for CANDIDATE /type class instances/ *by type*.

    - For example,
      the compiler will search for ~JsonWriter[String]~ when it sees
      ~Json.toJson("A string!")~

    - The compiler searches for candidate instances in the /implicit scope/ at
      the call site, which _ROUGHLY_ consists of:
      1. *local* or *inherited* definitions;

      2. *imported* definitions;
         =from Jian=
         In the previous section example, compiler can find /given instances/ because
         they are imported.

      3. definitions in the /companion object/ of
         * the /type class/ or
         * the /parameter type/ (in the example ~JsonWriter~ or ~String~).

    - The precise rules of /implicit resolution/ are more complex then the ones
      listed above!
      =TODO= =READ= =IMPORTANT=
      * Footnote 3: =!!!=

    - For our puposes, we can *package* /type class instances/ in roughly _FOUR_
      ways:
      1. by placing them in an /object/ such as ~JsonWriterInstances~;

      2. by placing them in a ~trait~;

      3. by placing them in the /companion object/ of the /type class/;

      4. by placing them in the /companion object/ of the /parameter type/.

    - How to use /implicits/ when you package like above:
      * With option 1 we bring /given instances/ into scope by *importing* them.

      * With option 2 we bring /given instances/ into scope with *inheritance*.

      * With options 3 and 4, /given instances/ are *ALWAYS in* /implicit scope/,
        regardless of where we try to use them.

    - *Convention*:
      Put /type class instances/ in a /companion object/ (option 3 and 4 above)
      if there is *only one sensible implementation*, or at least one
      implementation that is *widely accepted* as the default.

      * This makes /type class instances/ easier to use
        AS *no import is required* to bring them into the /implicit scope/.

      * =from Jian=
        If use the previous section JSON serialization example,
        1. we can put both ~String~ and ~Person~ /given instances/ into the
           /companion object/ of ~JsonWriter~.
        2. However, we *SHOULDN'T* put ~Person~ /given instance/ there,
           because it is to specific.
           Put ~String~ /given instance/ there is good.

*** DONE 1.2.3 Recursive Implicit Resolution - 15
    CLOSED: [2021-07-27 Tue 16:47]
    The power of /type classes/ and ~given~'s and ~using~'s lies in the compiler's
    ability to *COMBINE* /given instances definitions/ when _SEARCHING for candidate
    instances._ -- this is sometimes known as /type class composition/.

    - We can actually define /given instances/ in _two_ ways:
      1. by defining *concrete* instances of the required type -- ~using~ clauses;

      2. by defining /given instances synchronization rules/, which include
         ~using~ clauses, to construct /given instances/ from other /type class
         instances/.

    - The first way above clearly *doesn't scale.*
      * For example,
        if we want to define /given instances/ to ~Option[A]~'s, any ~A~, use the
        first way:
        #+begin_src scala
          given optionIntWriter: JsonWriter[Option[Int]] =
            ???
          
          given optionPersonWriter: JsonWriter[Option[Person]] =
            ???
          
          // and so on (infinite many) ...
        #+end_src

    - Use the second way:
      #+begin_src scala
        given optionWriter[A](using writer: JsonWriter[A]): JsonWriter[Option[A]] =
          new JsonWriter[Option[A]] {
            def write(option: Option[A]): Json =
              option match {
                case Some(aValue) => writer.write(aValue)
                case None => JsNull
              }
          }

      #+end_src
      * The process of search /given instances/ and fill them in:
        + source code: 
          #+begin_src scala
            Option("A string").toJson
          #+end_src

        + Search for an ~given JsonWriter[Option[String]]~.
          It find the ~JsonWriter[Option[A]]~:
          #+begin_src scala
            Option("A string").toJson(using optionWriter[String])
          #+end_src

        + Recursively searches for a ~given JsonWriter[String]~ for
          ~optionWriter[String]~:
          #+begin_src scala
            Option("A string").toJson(using optionWriter(using stringWriter))
          #+end_src

    - A simplified version =from Jian= (use reflection --> slower):
      #+begin_src scala
        import scala.reflect.ClassTag

        implicit def optionWriter[A : ClassTag](implicit writer: JsonWriter[A]) = {
          case Some(v: A) => writer.write(v)
          case None       => JsNull
        }
      #+end_src
      TODO WHY type ~A~ is erased???

    - *Implicit Conversions*

** DONE 1.3 Exercise: ~Printable~ Library - 18
   CLOSED: [2021-07-28 Wed 23:09]
   - A few disadvantages of the native ~toString~ method of ANY /objects/ in Scala:
     * It is implemented for every type in the language, many implementations are
       of limited use, and we can't opt-in to specific implementations for specific
       types.

   - Let's *define* a ~Printable~ /type class/ to _work around_ these problems:
     1. *Define* a /type class/ ~Printable[A]~ containing a SINGLE /method/
        ~format(value: A): String~,
        #+begin_src scala
          trait Printable[A] {
            def format(value: A): String
          }
        #+end_src

     2. *Create* an object ~PrintableInstances~ containing /instances/ of
        ~Printable~ (for ~String~ and ~Int~ in our example).
        #+begin_src scala
          object PrintableInstances {
            given stringPrintable: Printable[String] =
              identity[String]

            given intPrintable: Printable[Int] =
              (_: Int).toString
          }
        #+end_src

     3. *Define* an object ~Printable~ with TWO /generic interface methods/:
        #+begin_src scala
          // The "interface object" way.
          object Printable {
            def format[A](input: A)(implicit p: Printable[A]): String =
              p.format(input)

            def print(input: A)(implicit p: Printable[A]): Unit =
              println(format(input))
          }
        #+end_src
        * ~format~ uses the relevant ~Printable~ to convert the ~A~ to a ~String~.
          + accepts a value of type ~A~
          + returns a ~Printable~ of the corresponding type.

        * ~print~ prints the ~A~ value to the console using ~println~.
          + accepts the same parameters as ~format~
          + returns ~Unit~.

*** DONE Using the Library - 19
    CLOSED: [2021-07-28 Wed 23:09]
    #+begin_src scala
      final case class Cat(name: String, age: Int, color: String)

      // Add to the `PrintableInstances`
      implicit val catPrintable = new Printable[Cat] {
        def format(cat: Cat): String = {
          val name: String  = Printable.format(cat.name)
          val age: String   = Printable.format(cat.age)
          val color: String = Printable.format(cat.color)
          s"$name is a $age year-old $color cat."
        }
      }
    #+end_src

*** DONE Better Syntax - 19
    CLOSED: [2021-07-28 Wed 23:09]
    #+begin_src scala
      object PrintableSyntax {
        implicit class PrintableOps[A](value: A) {
          def format(implicit p: Printable[A]): String =
            Printable.format(value)

          def print(implicit p: Printable[A]): Unit =
            Printable.print(value)
        }
      }
    #+end_src
    
    - Scala 3:
      #+begin_src scala
        object Printable {
          extension [A](value: A) {
            def format(using p: Printable[A]): String =
              Printable.format(value)
        
            def print(using p: Printable[A]): Unit =
              Printable.print(value)
          }
        }
      #+end_src

** DONE 1.4 Meet Cats - 20
   CLOSED: [2020-02-17 Mon 03:26]
   - Previous section:
     we saw *HOW* to *implement* /type classes/ _in Scala_.

     This section:
     we will look at *HOW* /type classes/ are *implemented* _in Cats_.

   - Cats is written using a /modular structure/ that allows us to choose which
     /type classes/, /instances/, and /interface methods/ we want to use.

   - Let's take a first look using ~cats.Show~ as an example.
     ~Show~ is Cats' equivalent of the ~Printable~ /type class/ we defined in
     the last section.

     An abbreviated definition:
     #+begin_src scala
       package cats

       trait Show[A] {
         def show(value: A): String
       }
     #+end_src

*** DONE 1.4.1 Importing Type Classes - 20
    CLOSED: [2020-02-17 Mon 02:51]
    /Type classes/ are defined in ~cats~ /package/.
    Use it with ~import cats.Show~

    - The /companion object/ of *every* /Cats type class/ has an ~apply~ /method/
      that *locates* an /instance/ for any type we specify.

      However, you need to bring related /implicits/ to scope first.
      ~Show.apply[Int]~ need an implicit!

*** DONE 1.4.2 Importing Default Instances - 21
    CLOSED: [2020-02-17 Mon 02:56]
    The ~cats.instances~ /package/ provides /DEFAULT instances/ for a wide
    variety of types. TODO Check what are in the ~cats.instances~ package.

    - EACH /import/ provides /instances/ of ALL Cats' /type classes/
      for a SPECIFIC /parameter type/:
      * ~cats.instances.int~ provides instances for ~Int~

      * ~cats.instances.string~ provides instances for ~String~

      * ~cats.instances.list~ provides instances for ~List~

      * ~cats.instances.option~ provides instances for ~Option~

      * ~cats.instances.all~ provides *ALL* /instances/ that are shipped out of
        the box with Cats

    - Usage:
      #+begin_src scala
        import cats.instances.int._     //  for Show
        import cats.instances.string._  //  for Show

        val showInt:    Show[Int]    = Show.apply[Int]
        val showString: Show[String] = Show.apply[String]

        // Usage examples:
        val intAsString: String =
          showInt.show(123)
        // intAsstring: String = 123

        val stringAsString: String =
          showString.show("abc")
        // StringAsstring: String = abc
      #+end_src

*** DONE 1.4.3 Importing Interface Syntax - 22
    CLOSED: [2020-02-17 Mon 02:57]
    Make ~Show~ easier to use by _importing the /interface syntax/ from
    ~cats.syntax.show~._

    - This adds an /extension method/ called ~show~ to ANY /type/ for which we
      have an /instance/ of ~Show~ in scope:
      #+begin_src scala
        import cats.syntax.show._  // for show

        val shownInt = 123.show
        // showInt: String = 123

        val shownString = "abc".show
        // shownString: String = abc
      #+end_src

    - Cats provides *SEPARATE* syntax imports for EACH /type class/.

*** DONE 1.4.4 Importing All The Things! - 22
    CLOSED: [2020-02-17 Mon 03:00]
    - You should feel free to take one of the following shortcuts to simplify your
      imports: =IMPORTANT=
      * ~import cats._~ imports *ALL* of Cats' /type classes/ in one go;

      * ~import cats.instances.all._~ imports *ALL* of the /type class instances/
        for the standard library in one go;

      * ~import cats.syntax.all._~ imports *ALL* of the /syntax/ in one go;

      * ~import cats.implicits._~ imports *ALL* of the /standard type class
        instances/ and *ALL* of the /syntax/ in one go.

    - Most people
      1. _start_ their files with the following imports:
         #+begin_src scala
           import cats._
           import cats.implicits._
         #+end_src

      2. _reverting_ to more specific imports _only if they encounter naming conflicts
         or problems with ambiguous implicits._

*** DONE 1.4.5 Defining Custom Instances - 23
    CLOSED: [2020-02-17 Mon 03:26]
    - Q :: *HOW to define* an /instance/ of ~Show~?

    - A :: implementing the /trait/ for a given type:
           #+begin_src scala
             import java.util.Date

             implicit val dateShow: Show[Date] =
               new Show[Date] {
                 def show(date: Date): String = s"${date.getTime}ms since the epoch."
               }
           #+end_src

      * Simplified code:
        #+begin_src scala
          import java.util.Date

          implicit val dateShow: Show[Date] =
              date => s"${date.getTime}ms since the epoch."
        #+end_src

    - =from Jian=
      Should avoid an old and not well designed class like ~java.util.Date~ as a
      illsutration example. I try to use ~java.time.LocalDate~ adn do a similar
      job:
      #+begin_src scala
        import java.time.LocalDateTime
        import java.time.ZoneOffset

        implicit val dateShow: Show[LocalDateTime] =
          new Show[LocalDateTime] {
            def show(dateTime: LocalDateTime): String =
              s"${LocalDateTime.now().toInstant(ZoneOffset.UTC).toEpochMilli}ms since the epoch."
          }
      #+end_src

    - =IMPORTANT=
      Cats also provides a couple of convenient methods to *simplify* the process
      of creating /instances/.

      For ~Show~, there are two _construction methods_ on the /companion object/.
      * ~def show[A](f: A => String): Show[A]~
        Create a ~Show~ /instance/ from a function

      * ~def fromToString[A]: Show[A]~
        Create a ~Show~ /instance/ from a ~toString~ /method/

    - Use the ~show~ _construction method_:
      #+begin_src scala
        implicit val dateShow: Show[Date] =
          Show.show(date => s"${date.getTime}ms since the epoch.")
      #+end_src
      =from Jian= This is still more code then my *Simplified code* above.
                  WHY do we need ~show~??? I _guess_ this is because before
                  Scala 2.11 the simplified syntax for an instance of SAM is not
                  allowed. Then, do we still want to keep this for the future Scala.

    - Many /type classes/ in Cats provide /helper methods/ like these for
      *constructing* /instances/,
      * _either_ *from scratch*
      * _or_ by *transforming existing* /instances/ for other types.
        TODO MORE examples!!!

*** DONE 1.4.6 Exercise: Cat ~Show~ - 24
    CLOSED: [2020-02-17 Mon 00:35]
    The implementation is trivial -- only the /implicit value/ ~catShow~ we need
    to define -- just provide the function that can convert ~Cat~ to a ~String~
    of the format we want. All other things can be imported from Cats.

    _The import thing is *knowing what to import*._

** DONE 1.5 Example: ~Eq~ - 24
   CLOSED: [2020-02-17 Mon 00:58]
   - ~Eq~ is designed to
     * _support_ *type-safe equality* -- compre values of the same type
       (=from Jian= a narrowed down type, not consider them as the root type ~Any~)
       and
     * _address_ annoyances using Scala's built-in ~==~ operator.

   - With the built-in ~==~ no type-safty equality check, we may make _mistake_
     like:
     #+BEGIN_SRC scala
       List(1, 2, 3).map(Option.apply).filter(_ == 1)
       // res0: List[Option[Int]] = List()
     #+END_SRC

     It will be perfect if this is a /type error/ rather than /runtime error/.
     ~cats.Eq~ is designed to do this!!!

*** DONE 1.5.1 Equality, Liberty, and Fraternity - 25
    CLOSED: [2020-02-17 Mon 00:51]
    We can use ~Eq~ to define /type-safe equality/ between /instances/ of ANY
    given /type/:
    #+BEGIN_SRC scala
      package cats

      trait Eq[A] {
        def eqv(a: A, b: A): Boolean
        // other concrete methods based on `eqv`...
      }
    #+END_SRC
    - =from Jian=
      Use ~eqv~ rather than ~eq~ is because ~eq~ (a function in Scala behaved
      like the ~==~ in Java) is already used by Scala.

    - The /interface syntax/ of ~Eq~ is defined in ~cats.syntax.eq~.
      It provides *two* /methods/ for performing equality checks provided there
      is an instance ~Eq[A]~ _in scope_:
      * ~===~ compares two objects for /equality/;

      * ~=!=~ compares two objects for /inequality/.

*** DONE 1.5.2 Comparing Ints - 25
    CLOSED: [2020-02-17 Mon 00:51]
    Examples:
    #+BEGIN_SRC scala
      import cats.Eq
      import cats.instances.int._  // for `Eq[Int]`

      val eqInt = Eq[Int]

      eqInt.eqv(123, 123)
      // res2: Boolean = true

      eqInt.eqv(123, 234)
      // res2: Boolean = false

      eqInt.eqv(123, "234")
      //// type mismatch error

      import cats.syntax.eq._  // for the infix operators `===` and `=!=`

      123 === 123
      // res5: Boolean = true

      123 =!= 234
      // res6: Boolean = true
    #+END_SRC

*** DONE 1.5.3 Comparing Options - 27
    CLOSED: [2020-02-17 Mon 00:54]
    #+BEGIN_SRC scala
      import cats.instances.int._     // for `Eq`
      import cats.instances.option._  // for `Eq`
      import cats.syntax.eq._

      Some(1) === None
      //// type mismatch

      (Some(1): Option[Int]) === (None: Option[Int])  // too verbose
      // res9: Boolean = false

      Option(1) === Option.empty[Int]
      // res10: Boolean = false
    #+END_SRC
    - =from Jian= Here it MUST be ~(Some(1): Option[Int])~ or ~Option(1)~.
      ~Some(1) === (None: Option[Int])~ have /type error/ -- here you can only
      compare ~Option[Int]~ with ~Option[Int]~, and compre its different subtypes
      will lead to /type error/ -- extremely strict type checking!!!

      =from Jian=
      Can Dotty make this more flexible???


    - OR use special syntax from ~cats.syntax.option~:
      #+BEGIN_SRC scala
        import cats.syntax.option._  // for some and none

        1.some === none[Int]
        // res11: Boolean = false

        1.some =!= none[Int]
        // res12: Boolean = true
      #+END_SRC

*** DONE 1.5.4 Comparing Custom Types - 28
    CLOSED: [2020-02-17 Mon 00:55]
    Define our own instances of ~Eq~ with ~Eq.instance~ /method/, which accepts
    a function of type ~(A, A) => Boolean~ and returns an ~Eq[A]~:
    #+BEGIN_SRC scala
      import java.util.Date
      import cats.instances.long._  // for `Eq`

      implicit val dateEq: Eq[Date] =
        Eq.instance[Date] { (date1, date2) =>
          date1.getTime === date2.getTime
        }

      val x = new Date  // now
      val y = new Date  // a bit later than `x`

      x === x  // true
      x === y  // false
    #+END_SRC

*** DONE 1.5.5 Exercise: Equality, Liberty, and Felinity - 28
    CLOSED: [2020-02-17 Mon 00:58]
    #+BEGIN_SRC scala
      import cats.Eq
      import cats.syntax.eq._
      import cats.instances.int._
      import cats.instances.string._

      final case class Cat(name: String, age: Int, color: String)

      implicit val catEq: Eq[Cat] =
        Eq.instance[Cat] { case (Cat(nm1, ag1, clr1), Cat(nm2, ag2, clr2)) =>
          nm1 == nm2 &&
            ag1 == ag2 &&
            clr1 == clr2
        }

      val cat1 = Cat("Garfield",   38, "orange and black")
      val cat2 = Cat("Heathcliff", 33, "orange and black")

      cat1 === cat2  //
      cat1 =!= cat2  //

      // `Option[Cat]`
      import cats.instances.option._

      val optionCat1 = Option(cat1)
      val optionCat2 = Option.empty[Cat]

      optionCat1 === optionCat2  //
      optionCat1 =!= optionCat2  //
    #+END_SRC

    =from Jian= I think, after considering the features of /case classes/, a
    better implementation of ~catEq~ (still *type safe equality check*):
    #+BEGIN_SRC scala
      implicit val catEq: Eq[Cat] =
        Eq.instance[Cat] { (c1, c2) => c1 == c2 }
    #+END_SRC
    We can't use ~==~ between ~c1~ and ~c2~, but for /case classes/, ~==~ is
    enough!!! This is NOT applicable for /non-case classes/.

** DONE 1.6 Controlling Instance Selection - 29
   CLOSED: [2020-02-17 Mon 22:32]
   Two issues that _CONTROL /instance/ selection_ must be considered:
   - What is the _relationship_ BETWEEN an instance defined on _a type and its
     subtypes_?

     Example: ~JsonWriter[Option[Int]]~ and ~Json.toJson(Some(1))~

   - How do we choose between /type class instances/ when there are many
     available?

     Example: TWO ~JsonWriter~ for ~Person~.

*** DONE 1.6.1 Variance - 29
    CLOSED: [2019-03-23 Sat 02:52]
**** DONE Covariance - 29
     CLOSED: [2020-02-17 Mon 22:00]
     - Covariance :: the type ~F[B]~ is a /subtype/ of the type ~F[A]~ if ~B~ is
                     a /subtype/ of ~A~.

     - /Covariance/ is useful for modelling many types, including collections.

     - Almost / ALL (_I'm NOT sure_)
       /immutable collections/ are /covariant/.

**** DONE Contravariance - 30
     CLOSED: [2020-02-17 Mon 22:00]
     - Contravariance :: the type ~F[B]~ is a /subtype/ of the type ~F[A]~ if ~A~
                         is a /subtype/ of ~B~.

     - /Covariance/ is useful for modeling types that represent processes, like
       our ~JsonWriter~ /type class/ above:
       #+begin_src scala
         trait JsonWriter[-A] {
           def write(value: A): Json
         }
       #+end_src

     - It's easy to find out why do we need /contravariance/:
       #+begin_src scala
         val shape: Shape = ???
         val circle: Circle = ???

         val shapeWriter: JsonWriter[Shape] = ???
         val circleWriter: JsonWriter[Circle] = ???

         def format[A](value: A, writer: JsonWriter[A]): Json =
           writer.write(value)
       #+end_src
       * Logically (even we don't know the /contravariance/ of ~JsonWriter[A]~,
         we still have some reasonable expectation), what kind of combinations
         are legal?
         + When ~value~ is a ~Circle~, ~writer~ can be ~JsonWriter[Circle]~ and
           ~JsonWriter[Shape]~.

         + When ~value~ is a ~Shape~, ~writer~ can ONLY be ~JsonWriter[Shape]~.

       * The expectation above is the expectation for /contravariance/:
         ~JsonWriter[Shape]~ is a subtype of ~JsonWriter[Circle]~ because ~Circle~
         is a subtype of ~Shape~.

**** DONE Invariance - 31
     CLOSED: [2019-03-22 Fri 15:11]
     - Invariance :: types ~F[A]~ and ~F[B]~ are *never* /subtypes/ of one
                     another, no matter waht the relationship between ~A~ and
                     ~B~.

     - /Invariance/ is *the default semantics for Scala type constructors.*

     - There are *TWO* issues that tend to arise.
       Let's imagine we have an /algebraic data type/ like:
       #+begin_src scala
         sealed trait A
         case object B extends A
         case object C extends A
       #+end_src
       1. Will an /supertype/ (in this example, it is ~A~) /instance/ be selected
          for /subtypes/ (in this example, they are ~B~ and ~C~)?

       2. Will an /instance/ for a /subtype/ (~B~) be selected in preference to
          that of a /supertype/ (~A~).

          For instance, if we define an /instance/ for ~A~ and ~B~, and we have
          a value of type ~B~, will the /instance/ for ~B~ be selected in
          preference to ~A~?

     - We can't have both at once. Here are the choices:
       | Type Class Variance           | Invariant | Covariant | Contravariant |
       |-------------------------------+-----------+-----------+---------------|
       | Supertype instance used?      | No        | No        | Yes           |
       | More specific type preferred? | No        | Yes       | No            |

     - There is no perfect system, and
       _Cats generally *prefers* to use /invariant type classes/._
       This allows us to *specify more specific* /instances/ for /subtypes/ if
       we want.
       * This also introduce some "issue" that we need to pay attention.
         For example,
         a value of /type/ ~Some[Int]~, our /type class instance/ for ~Option~
         will *NOT* be used.
           We can solve this problem with a /type annotation/ like
         ~Some(1): Option[Int]~ or by using /"smart constructors"/ like the
         ~Option.apply~, ~Option.empty~, ~some~, and ~none~ /methods/.

** DONE 1.7 Summary - 32
   CLOSED: [2020-02-17 Mon 23:50]
   - First, we use plain Scala to introduce the concept of /type classes/.
     We implementated our own ~Printable~ /type class/ using plain Scala before
     looking at two examples from /Cats/ -- ~Show~ and ~Eq~

   - The _general patterns_ in ~Cats~:
     * /Cats type classes/ are /generic traits/ _in the ~cats~ package_.

     * *EACH* /type class/ has a /companion object/ with,
       + an ~apply~ /method/ for materializing instances;
       + ONE or MORE /construction methods/ for creating /instances/;
       + a collection of other relevant /helper methods/.

     * /DEFAULT instances/ are provided via objects in the ~cats.instances~
       /package/, and are *organized BY* /parameter type/ _RATHER THAN_ BY /type
       class/.

     * MANY /type classes/ have /syntax/ provided via the ~cats.syntax~ /package/.

* DONE 2 Monoids and Semigroups - 35
  CLOSED: [2020-02-18 Tue 02:22]
  /Type classes/ /monoid/ and /semigroup/ allow us to combine values.
  - There are instances for ~Int~, ~String~, ~List~, ~Option~, and many more.

*** DONE Integer addition - 35
    CLOSED: [2018-10-26 Fri 21:35]
    - Operation: Closed under integer ~+~
    - Identity: ~0~
    - Associativity

*** DONE Integer multiplication - 36
    CLOSED: [2018-10-26 Fri 21:35]
    - Operation: Closed under integer ~*~
    - Identity: ~1~
    - Associativity

*** DONE String and sequence concatenation - 36
    CLOSED: [2018-10-26 Fri 21:35]
    - Operation: Closed under String concatenation ~++~
    - Identity: ~""~
    - Associativity

** DONE 2.1 Definition of a ~Monoid~ - 37
   CLOSED: [2020-02-18 Tue 00:20]
   - Formally, a /monoid/ for a type ~A~:
     * It has
       + an operation ~combine~ with type ~(A, A) => A~
       + an element ~empty~ of type ~A~
     * It obeys
       + association laws
       + identity laws

   - /Monoid/ in Cats:
     #+BEGIN_SRC scala
       trait Monoid[A] {
         def combine(x: A, y: A): A
         def empty: A
       }
     #+END_SRC

   - Only the ~combine~ and ~empty~ /methods/ of this ~trait~ *CANNOT* guarantee
     the _monoid in math_ -- /monoids/ *must formally obey* several /laws/, here
     are functions that can be used to _test_ the /laws/:
     #+BEGIN_SRC scala
       def associativeLaw[A : Monoid](x: A, y: A, z: A): Boolean = {
         val m = implicitly[A]
         m.combine(x, m.combine(y, z)) == m.combine(m.combine(x, y), z)
       }

       def identityLaw[A : Monoid](x: A): Boolean = {
         val m = implicitly[A]
         (m.combine(x, m.empty) == x) && (m.combine(m.empty, x) == x)
       }
     #+END_SRC
     * =from Jian=
       Scala does NOT contain a system that can prove a thing defined as monoid-like
       is really a /monoid/. We write down laws, and then prove it with some proof
       system (including a person with pen and paper :-)). In Scala, a more applicable
       way is write down the laws in code, and use tests to show some proof (of
       course, this is often not comprehensive). Even in Scala, we should do the
       paper and pen proof for complicated user-defined monoid.

   - /Integer subtraction/ does *NOT* obey the /associative law (for /monoid/)/,
     and there is NO /monoid/ under /integer subtraction/ operation.

   - AGAIN,
     *Unlawful instances are dangerous*!!!
     *Unlawful instances are dangerous*!!!
     *Unlawful instances are dangerous*!!!

     It will yield *unpredictable results*.

** DONE 2.2 Definition of a ~Semigroup~ - 38
   CLOSED: [2020-02-18 Tue 00:24]
   /Semigroups/ have only ~combine~ and NO ~empty~.

   - /Semigroups/ are often /monoids/.

   - We can add some _restriction_ to eliminate /identitis/ of /monoids/, and
     make them no longer /monids/, but /semigroups/ ONLY.
     For example, there is one we often see and use
     * positive numbers

     * none empty sequences.
       For example, the ~NonEmptyList~ in Cats.

   - A more accurate, but still simplified compared to the code in Cats,
     definition of Cat's ~Monoid~ is:
     #+begin_src scala
       trait Semigroup[A] {
         def combine(x: A, y: A): A
       }

       trait Monoid[A] extends Semigroup[A] {
         def empty: A
       }
     #+end_src

** DONE 2.3 Exercise: The Truth About Monoids - 39
   CLOSED: [2020-02-18 Tue 00:49]
   We first complete the ~Monoid~ related definitions in Cats:
   #+begin_src scala
     trait Semigroup[A] {
       def combine(x: A, y: A): A
     }

     trait Monoid[A] extends Semigroup[A] {
       def empty: A
     }

     object Monoid {
       def apply[A](implicit monoid: Monoid[A]) =
         monoid
     }
   #+end_src

   Then let's define the ~Boolean~ related ~Monoid~ (NOT only one):
   #+BEGIN_SRC scala
     implict val booleanAndMonoid = new Monoid[Boolean] {
       def combine(x: Boolean, y: Boolean): Boolean = x && y
       def empty: Boolean = true
     }

     implict val booleanOrMonoid = new Monoid[Boolean] {
       def combine(x: Boolean, y: Boolean): Boolean = x || y
       def empty: Boolean = false
     }

     implict val booleanXorMonoid = new Monoid[Boolean] {
       def combine(x: Boolean, y: Boolean): Boolean = (x && !y) || (!x && y)
       def empty: Boolean = false
     }

     implict val booleanXnorMonoid = new Monoid[Boolean] {
       def combine(x: Boolean, y: Boolean): Boolean = (!x || y) && (x || !y)
       def empty: Boolean = true
     }
   #+END_SRC
   The /identity law/ holds in each case is straightforward.
   The /associative law/ can be proved by enumerating the cases.

** DONE 2.4 Exercise: All ~Set~ for Monoids - 40
   CLOSED: [2020-02-18 Tue 00:52]
   - ~Monoid[Set[A]]~ exists UNDER /sets/ ~union~ operation with ~Set.empty[A]~ as
     /identity/:
     #+BEGIN_SRC scala
       implicit def setUnionMonoid[A] = new Monoid[Set[A]] {
         def combine(x: Set[A], y: Set[A]): Set[A] =
           x union y

         // Now you know why we use `def` for `empty` in the definition of `Monoid`!
         def empty: Set[A] = Set.empty
       }
     #+END_SRC
     * Use cases:
       #+begin_src scala
         val intSetMonoid = Monoid[Set[Int]]
         val strSetMonoid = Monoid[Set[String]]

         intSetMonoid.combine(Set(1, 2), Set(2, 3))
         // res2: Set[Int] = Set(1, 2, 3)

         strSetMonoid.combine(Set("A", "B"), Set("B", "C"))
         // res3: Set[String] = Set(A, B, C)
       #+end_src

   - ~Semigroup[Set[A]]~ exists UNDER /sets/ ~intersect~ opertion.
     There is *NO* ~Monoid[Set[A]]~ under this operation.

   - /Set complement/ and /set difference/ are *NOT* /associative/.
     They are not /monoid/ or /semigroup/.

   - ~Monoid[Set[A]]~ exists UNDER /sets/ /symmetric difference/ operation with
     ~Set.empty[A]~ as /identity/:
     #+BEGIN_SRC scala
       implicit def setSymDiffMonoid[A] = new Monoid[Set[A]] {
         def combine(x: Set[A], y: Set[A]): Set[A] =
           (x diff y) union (y diff x)

         def empty: Set[A] = Set.empty
       }
     #+END_SRC

** DONE 2.5 Monoids in Cats - 40
   CLOSED: [2020-02-18 Tue 01:09]
   We've seen what /monoids/ are.
   Now let's look at their *implementation in Cats*.

   - Once again we'll look at the *THREE* main aspects of the implementation:
     * the /type class/
     * the /instances/
     * the /interface/ (syntax)

*** DONE 2.5.1 The Monoid Type Class - 40
    CLOSED: [2020-02-18 Tue 00:58]
    ~cats.Monoid~ (an alias of ~cats.kernel.Monoid~) and ~cats.Semigroup~ (an
    alias of ~cats.kernel.Semigroup~).
    #+begin_src scala
      import cats.Monoid
      import cats.Semigroup
    #+end_src

    - *Cats Kernel?*
      /Cats Kernel/ is a _subproject_ of Cats providing _a small set_ of
      /typeclasses/ *for libraries that don't require the full Cats toolbox*.

      While these _CORE_ /type classes/ are technically defined in the ~cats.kernel~
      /package/, _they are ALL *aliased* to the ~cats~ package so we RARELY need
      to be aware of the distinction._

      + The /Cats Kernel/ /type classes/ covered in this book:
        * ~Eq~
        * ~Semigroup~
        * ~Monoid~

      + All the other /type classes/ we cover are part of the main Cats project
        and are defined _directly_ in the ~cats~ /package/.

*** DONE 2.5.2 Monoid Instances - 41
    CLOSED: [2020-02-18 Tue 00:59]
    - Example (usage):
      #+BEGIN_SRC scala
        import cats.Monoid
        import cats.instances.string._

        Monoid[String].combine("Hi ", "there")  // "Hi there"
        Monoid[String].empty                    // ""
      #+END_SRC
      + ~Monoid[String]~ is actually ~Monoid.apply[String]~

      + ~Semigroup~ usage is similar.

    - Aseemble a ~Monoid[Option[Int]]~:
      #+begin_src scala
        import cats.Monoid
        import cats.instances.int._     // for Monoid
        import cats.instances.option._  // for Monoid

        val a = Option(22)  // a: Option[Int] = Some(22)
        val b = Option(20)  // b: Option[Int] = Some(20)

        Monoid[Option[Int]].combine(a, b)
      #+end_src

*** DONE 2.5.3 Monoid Syntax - 42
    CLOSED: [2020-02-18 Tue 01:00]
    ~|+|~ is the /combine/ operator, which comes from ~cats.syntax.semigroup._~
    #+BEGIN_SRC scala
      import cats.instances.string._
      import cats.syntax.semigroup._  // for |+|

      val stringResult = "Hi " |+| "there" |+| Monoid[String].empty
      // stringResult: String = Hi there

      import cats.instances.int._ // for Monoid
      val intResult = 1 |+| 2 |+| Monoid[Int].empty
      // inResult: Int = 3
    #+END_SRC

*** DONE 2.5.4 Exercise: Adding All The Things - 43
    CLOSED: [2020-02-18 Tue 01:06]
    - Write ~add~ for ~Int~
      #+BEGIN_SRC scala
        def add(items: List[Int]): Int =
          items.foldLeft(0)(_ + _)
      #+END_SRC

    - Write generics that can work for ~Int~ and ~Option[Int]~
      #+BEGIN_SRC scala
        import cats.Monoid
        import cats.instances.int._
        import cats.instances.option._
        import cats.syntax.semigroup._

        def add[A](items: List[A])(implicit monoid: Monoid[A]): A =
          items.foldLeft(monoid.empty)(_ |+| _)
      #+END_SRC

      If there is NOT ~None~ in the list, we'll see:
      #+BEGIN_SRC scala
        add(List(Some(1), Some(2), Some(3)))
        // <console>:61: error: could not find implicit value for evidence parameter of type cats.Monoid[Some[Int]]
        //        add(List(Some(1), Some(2), Some(3)))
        //           ^
      #+END_SRC
      This is because /Cats/ will ONLY generate a ~Monoid~ for ~Option[Int]~.

    - Make ~Order~ addable.
      #+BEGIN_SRC scala
        import cats.Monoid

        case class Order(totalCost: Double, quantity: Double)

        implicit val orderMonoid = new Monoid[Order] {
          def combine(x: Order, y: Order): Order =
            Order(x.totalCost + y.totalCost,
                  x.quantity + y.quantity)

          def empty: Order =
            Order(0.0, 0.0)
        }
      #+END_SRC

** DONE 2.6 Applications of Monoids - 43
   CLOSED: [2020-02-18 Tue 02:12]
   Here are a few big ideas where /monoids/ play a major role.
   TODO More detail in case studies later in this book.

*** DONE 2.6.1 Big Data - 43
    CLOSED: [2020-02-18 Tue 02:11]
    - Use cases (Need process a huge amount of logs, NOT/CANNOT in ONLY one
      computer):
      * Calculate how many total visitors a web site has received.
        -- thanks for the reality non-negative ~Int~ under the operation of
           /addition/ and the /zero element/ of ~0~ is a /monoid/.

      * Calculate how many unique visitors a web site has received.
        -- thanks for the reality that ~Set(Int)~ under the operation of
           /union/ and the /zero element/ of ~Set.empty[Int]~ is a /monoid/.

      * If we want to calculate 99% and 95% response times from our server logs,
        we can use a data structure called a ~QTree~ for which there is a /monoid/.
        TODO _Learn how to design and implement this data structure._

    - Summary:
      Almost every analysis that we might want to do over a large data set is a
      /monoid/, and therefore we can build an expressive and powerful analytics
      system around this idea.

      This is exactly what Twitter's Algebird and Summingbird projects have
      done. We explore this idea further in the map-reduce case study.

*** DONE 2.6.2 Distributed Systems - 44
    CLOSED: [2020-02-18 Tue 02:11]
    TODO =Case-Study= We explore this idea further in *the CRDT case study*.

*** DONE 2.6.3 Monoids in the Small - 45
    CLOSED: [2020-02-18 Tue 02:11]
    There are also many cases where having a monoid around makes it easier to
    write a small code fragment.

    See *case studies* of this book

** DONE 2.7 Summary - 45
   CLOSED: [2020-02-18 Tue 02:21]

* DONE 3 Functors - 47 - =TODO= _contravariant and invariant functors_
  CLOSED: [2020-02-20 Thu 11:22]
  - /Functors/ allow us to represent sequences of operations within a /context/.

  - /Functor/ is the base of /applicative functor/ and /monad/, which are more
    useful.

** DONE 3.1 Examples of Functors - 47
   CLOSED: [2020-02-18 Tue 02:31]
   - Because ~map~ leaves the the /context/ unchanged, we can call it repeatedly
     to *sequence* multiple computations on the _contents_ of an initial data
     structure.
     #+begin_src scala
       // Of course, the first two map's can be merged to one,
       // Here is a illustration example, not best practice:
       List(1, 2, 3).
         map(_ + 1).
         map(_ * 2).
         map(_ + "!")
     #+end_src

   - We should think of ~map~
     + *NOT*
       as an /iteration pattern/,
       =from Jian=
       This point of view is not related to composition and is rules
       In the context of category, we don't inspect the object we use in this
       point of view.

     + BUT
       as a way of *sequencing* computations on values
       IGNORING SOME COMPLICATION dictated by the relevant data type.

** DONE 3.2 More Examples of Functors - 49
   CLOSED: [2020-02-18 Tue 13:43]
   1. Before:
      The ~map~ methods of ~List~, ~Option~, and ~Either~ apply functions eagerly.

   2. However, the idea of _sequencing computations_ is MORE GENERAL than this.

   3. This Section:
      Let's investigate the behaviour of some other functors that apply the
      pattern in different ways.

*** DONE ~Futures~ - 49
    CLOSED: [2020-02-18 Tue 13:16]
    #+begin_src scala
      import scala.concurrent.{Future, Await}
      import scala.concurrent.ExecutionContext.Implicits.global
      import scala.concurrent.duration._

      val future: Future[String] =
        Future(123).
          map(n => n + 1).
          map(n => n * 2).
          map(n => n + "!")

      Await.result(future, 1.second)
      // res3: String = 248!
    #+end_src

    - *Futures and Referential Transparency*
      + Scala's ~Future~'s are *NOT* a great EXAMPLE of _pure functional pro-
        gramming_ because they are *NOT* /referentially transparent/.

      + =from Jian=
        * Q :: Want to use ~Future~ as a /functor/?
        * A :: ONLY use it to do pure computations.

*** DONE Functions (?!) - 49
    CLOSED: [2020-02-20 Thu 09:53]
    - *It turns out that /single argument functions/ are also /functors/*

    - ~map~ for /single argument functions/ is, by concept, /function composition/
      (it works like ~andThen~) -- a kind of *sequencing*! It's queueing up
      operations.

      For example:
      #+begin_src scala
        import cats.instances.functor._  // for `Functor`
        import cats.syntax.functor._     // for `map`

        val func1: Int => Double =
          (x: Int) => x.toDouble

        val func2: Int => Double =
          (y: Double) => y * 2

        (func1 map func2)(1)      // composition using `map`
        // res7: Double = 2.0

        (func1 andThen func2)(1)  // composition using `andThen`
        // res8: Double = 2.0

        func2(func2(1))           // composition with manually encoding
        // res9: Double = 2.0
      #+end_src

    - Example:
      #+begin_src scala
        val func =
          ((x: Int) => x.toDouble).
            map(_ + 1).
            map(_ * 2).
            map(_ + "!")

        func(123)
        // res10: String = 248.0!
      #+end_src

    - *Partial Unification*
      _BEFORE Scala 2.13_, You need ~scalaOptions += "-Ypartial-unification"~

      Or you'll see some error like:
      #+BEGIN_SRC scala
        func1.map(func2)
        // <console>: error: value map is not a member of Int => Double
        //        func1.map(func2)
      #+END_SRC

      + TODO EXPLAIN in Seciton 3.8
        Use compiler option ~-Ypartial-unification~

** DONE 3.3 Definition of a Functor - 54
   CLOSED: [2020-02-18 Tue 17:07]
   #+BEGIN_SRC scala
     package cats

     import scala.language.higherKinds

     trait Functor[F[_]] {
       def map[A, B](fa: F[A])(f: A => B): F[B]
     }
   #+END_SRC
   - TODO Next SECTION will explain:
     + /type constructors/ and /higher kinded types/ -- be related to the ~F[_]~
       above.
     + The ~scala.language~ line.


   - *Functor Laws*
     + *Identity*:
       calling ~map~ with the /identity function/ is the same as doing nothing:
       _(fa map identity) \equiv{} fa_

     + *Composition*:
       mapping with two functions ~f~ and ~g~ is the same as mapping with ~f~
       and then mapping with ~g~:
       _fa.map(g(f(_))) \equiv{} fa.map(f).map(g)_
       =from Jian=
       The RHS can also be written as ~fa map f map g~
       Or a much more easier to understand version (ONLY when ~fa~ is a single
       parameter function):
       ~fa andThen g(f(_))~ \equiv{} ~fa andThen f andThen g~

** DONE 3.4 Aside: Higher Kinds and Type Constructors - 55
   CLOSED: [2020-02-19 Wed 16:01]
   =IMPORTANT=
   - kinds :: "types" for /types/ -- a concept used to category /types/.

   - Informally, a /kind/ of a /type/ is the "hole" in a type -- how many
     /types/ we need to feed in to get a *no ~=>~ /type/.*

   - If a /type/ has "hole" (a /type/ on the left hand side of ~=>~ is a "hole"),
     it is called a /higher kinded type/ or a /type constructor/.

     + For example,
       ~List~ is a /type constructor/ (/higher kinded type/), and ~List[Int]~ is a
       /type/ (/kind one type/).

     + A close analogy:
       In Scala, function is also a /value/ in general, but we can also call it
       "value constructor", and call the /value/ that cannot take any parameter
       "value".

   - In Scala
     #+BEGIN_SRC scala
       def myMethod[F[_]] = {            // Define
         val functor = Functor.apply[F]  // Reference
       }
     #+END_SRC
     1. we *declare* /type constructors/ with the help of _underscores_.
        Once we've declared them, however,
     2. we *refer to* them as SIMPLE /identifiers/ -- ~F~.

     This is *analogous to* specifying a function's parameters in its definition and
     ommiting them when refering to it:
     #+BEGIN_SRC scala
       val f = (x: Int) => x * 2  // Declare
       val f2 = f andThen f       // Reference
     #+END_SRC

   - *Language Feature Imports*
     /Higher kinded types/ are considered an _ADVANCED language feature_ in
     Scala, and you need to enable it in the compiler. There are two ways:
     + Explicit import:
       ~import scala.language.higherKinds~
       More explicit, use it in this book.

     + Set in =build.sbt=:
       ~scalacOptions += "-language:higherKinds~
       More concise, and you may prefer this in your projects.

** DONE 3.5 Functors in Cats - 57
   CLOSED: [2020-02-19 Wed 20:06]
   Examine the aspects we did for /monoids/:
   1. the /type class/
   2. the /instances/
   3. the /syntax/

*** DONE 3.5.1 The ~Functor~ Type Class - 57
    CLOSED: [2020-02-19 Wed 16:03]
    - We *obtain* /instances/ using the STANDARD ~Functor.apply~ /method/ on the
      /companion object/.

    - Basic usage:
      #+BEGIN_SRC scala
        import scala.language.higherKinds
        import cats.Functor

        //------------------------------------------
        // `List` functor
        //------------------------------------------
        import cats.instances.list._

        val list1 = List(1, 2, 3)
        // list1: List[Int] = List(1, 2, 3)

        val list2 = Functor[List].map(list1)(_ * 2)
        // list2: List[Int] = List(2, 4, 6)

        //------------------------------------------
        // `Option` functor
        //------------------------------------------
        import cats.instances.option._

        val option1 = Option(123)
        // option1: Option[Int] = Some(123)

        val option2 = Functor[Option].map(option1)(_.toString)
        // option2: Option[String] = Some(123)
      #+END_SRC

    - The ~lift~ /method/ of /functors/:
      ~A => B~ to ~F[A] => F[B]~

      #+BEGIN_SRC scala
        val func = (x: Int) => x + 1
        // func: Int => Int = <function1>

        val liftedFunc = Functor[Option].lift(func)
        // liftedFunc: Option[Int] => Option[Int] = cats.Functor$$Lambda$11699/1098992879@279f562e

        liftedFunc(Option(1))
        // res0: Option[Int] = Some(2)
      #+END_SRC

*** DONE 3.5.2 ~Functor~ Syntax - 58
    CLOSED: [2020-02-19 Wed 19:33]
    Use examples other than ~Option~ and ~List~ as illustration.
    (Rationale: Compiler _always prefer a built-in_ method _over_ an extension
    method).

    - ~Function1~ example:
      #+begin_src scala
        import cats.instances.function._ // for Functor
        import cats.syntax.functor._ // for map

        val func1 = (a: Int) => a + 1
        val func2 = (a: Int) => a * 2
        val func3 = (a: Int) => a + "!"
        val func4 = func1.map(func2).map(func3)

        func4(123)
        // res1: String = 248!
      #+end_src

    - A method for general /functors/:
      #+begin_src scala
        def doMath[F[_]](start: F[Int])
                  (implicit functor: Functor[F]): F[Int] =
          start.map(_ + 2)

        import cats.instances.option._
        import cats.instances.list._

        doMath(Option(20))
        // res3: Option[Int] = Some(22)

        doMath(List(1, 2, 3))
        // res4: List[Int] = List(3, 4, 5)
      #+end_src

    - To illustrate how this works, let's take a look at the definition of the
      ~map~ /method/ in ~cats.syntax.functor~. Here is a simplified version:
      #+begin_src scala
        implicit class FunctorOps[F[_], A](src: F[A]) {
          def map[B](func: A => B)
                    (implicit functor: Functor[F]): F[B] =
            functor.map(src)(func)
        }
      #+end_src

      #+begin_src scala
        foo.map(_ + 1)
        // `foo` should have type `F[Int]`

        // 1.
        new FunctorOps(foo).map(_ + 1)
        // There should be a `Functor[F]` implicit parameter.

        // 2.
        new FunctorOps(foo).map(_ + 1)(fooFunctor)

      #+end_src

      + Example: =from Jian= The procesure of /implicit search/.
        We have a expression ~foo.map(_ + 1)~.
        * Assuming ~foo~ has no built-in ~map~ /method/,
          the compiler detects the potential error and wraps the expression in a
          ~FunctorOps~ to fix the code:
          #+begin_src scala
            new FunctorOps(foo).map(_ + 1)
          #+end_src

        * The ~map~ /method/ of ~FunctorOps~ *requires* an ~implicit Functor~ as
          a parameter.
            This means this code will *ONLY compile* if we have a ~Functor~ for
          ~foo~ (type ~A~) in scope. If we don't, we get a compiler error.

*** DONE 3.5.3 Instances for Custom Types - 60
    CLOSED: [2020-02-19 Wed 19:53]
    - Simple and straightfoward example (already in ~cats.instances~):
      #+BEGIN_SRC scala
        implicit val optionFunctor: Functor[Option] =
          new Functor[Option] {
            def map[A, B](value: Option[A])(func: A => B): Option[B] =
              value.map(func)
          }
      #+END_SRC

    - Must *inject dependencies* into our /instances/,
      BUT we can't add parameter(s) to ~future.map~ -- obviously.

      Thus, we provide /dependencies/ when summon the required /instance/.
      #+BEGIN_SRC scala
        import scala.concurrent.{Future, ExecutionContext}

        implicit def futureFunctor(implicit ec: ExecutionContext): Functor[Future] =
          new Functor[Future] {
            def map[A, B](value: Future[A])(func: A => B): Future[B] =
              value.map(func)
          }
      #+END_SRC

    - Whenever we summon a ~Functor~ for ~Future~, either directly using
      ~Functor.apply~ or indirectly via the ~map~ /extension method/, the
      compiler will locate ~futureFunctor~ by /implicit resolution and recursively
      search/ for an ~ExecutionContext~ at the call site.

      This is what the expansion might look like:
      #+begin_src scala
        // We write this:
        Functor[Future]

        // Step 1.
        Functor.apply[Future]

        // Step 2.
        Functor.apply[Future](futureFunctor)

        // Step 3.
        Functor.apply[Future](futureFunctor(executionContext))
      #+end_src

*** DONE 3.5.4 Exercise: Branching out with Functors - 61
    CLOSED: [2020-02-19 Wed 20:05]
    #+BEGIN_SRC scala
      sealed trait Tree[+A]

      final case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]
      final case class Leaf[A](value: A)                        extends Tree[A]

      implicit treeFunctor = new Functor[Tree] {
        def map[A, B](tree: Tree[A])(func: A => B): Tree[B] =
          tree match {
            case Leaf(v)      => Leaf(func(v))
            case Branch(l, r) => Branch(map(l)(func), map(r)(func))
          }
      }
    #+END_SRC
    1. This is right, but not complete:
       #+begin_src scala
         Branch(Leaf(10), Leaf(20)).map(_ * 2)
         // <console>: 42: error: value map is not a member of wrapper.Branch[Int]
         //        Branch(Leaf(10), Leaf(20)).map(_ * 2)
       #+end_src
       =from Jian= Can dotty new /enum/ resolve this???

    2. Let's add some smart constructors to compensate:
       #+begin_src scala
         object Tree {
           def branch[A](left: Tree[A], right: Tree[A]): Tree[A] =
             Branch(left, right)

           def leaf[A](value: A): Tree[A] =
             Leaf(value)
         }

         Tree.leaf(100).map(_ * 2)
         Tree.branch(Tree.leaf(10), Tree.leaf(20)).map(_ * 2)
       #+end_src

** DONE 3.6 Contravariant and Invariant Functors - 61 - =TODO=
   CLOSED: [2019-03-31 Sun 01:56]
   - The ~Functor~ we explored is actually /covariant functor/, and its ~map~
     *appends* a transformation to a chain.

   - We're now going to look at _TWO_ other /type classes/:
     + contravariant functor :: one representing *prepending* operations to a chain,
     + invariant functor :: one representing building a *bidirectional* chain of operations.

   - *This Section is Optional!*
     You do _NOT NEED_ to know about /contravariant and invariant functors/ to
     understand /monads/, the most important pattern in this book.

       HOWEVER, /contravariant/ and /invariant/ do come in HANDY in our
     discussion of ~Semigroupal~ and ~Applicative~ in Chapter 6.
     =from Jian= WHY???

     _If you want to move on to monads now, feel free to skip straight to
     Chapter 4. Come back here before you read Chapter 6._

*** DONE 3.6.1 Contravariant Functors and the ~contramap~ Method - 62
    CLOSED: [2019-03-31 Sun 01:55]
    - /contravariant functor/:
      + ~contramap~ - "prepending" an operation to a chain.

    - The ~contramap~ /method/ *only makes sense* for
      _data types that represent transformations._
      =IMPORTANT=
      For example,
      + _Can't_
        There is *NO WAY* to feed a value in an ~Option[B]~ backwards through a
        function ~A => B~.

      + _Can_
        #+begin_src scala
          trait Printable[A] { self =>
            def format(value: A): String
            def contramap[B](func: B => A): Printable[B] = ???
          }
        #+end_src

**** DONE 3.6.1.1 Exercise: Showing off with Contramap - 63
     CLOSED: [2019-03-31 Sun 01:55]
     #+BEGIN_SRC scala
       trait Printable[A] { self =>
         def format(value: A): String

         def contramap[B](func: B => A): Printable[B] =
           new Printable[B] {
             def format(value: B): String = self.format(func(value))
           }

         //// More concise version:
         // def contramap[B](func: B => A): Printable[B] =
         //   value => self.format(func(value))
       }

       def format[A](value: A)(implicit p: Printable[A]): String =
         p.format(value)
     #+END_SRC

     - Exercise:
       ~final case class Box[A](value: A)~
       Define an /instance/ of ~Printable~ for ~Box~.
       #+begin_src scala
         implicit def boxPrintable[A](implicit p: Printable[A]): Printable[Box[A]] =
           p.contramap[Box[A]](_.value)
       #+end_src

*** DONE 3.6.2 Invariant functors and the ~imap~ method - 64
    CLOSED: [2019-03-31 Sun 01:47]
    /Invariant functors/ implement a method called ~imap~.

    - ~imap~ is _INFORMALLY equivalent to a combination of ~map~ and ~contramap~._

    - If ~map~ generates new /type class/ instances by *appending* a function to a chain,
         and
         ~contramap~ generates them by *prepending* an operation to a chain,

      ~imap~ generates them via _a PAIR of_ *BIDIRECTIONAL transformations*.

    - The most intuitive examples:
      A /type class/ that represents _encoding_ and _decoding_ as some data type,
      such as Play JSON's ~Format~ and scodec's ~Codec~.
      TODO I know the former, but I don't know the latter. TODO

    - Build our own ~Codec~ by enhancing ~Printable~ to support /encoding/ and
      /deconding/ to/from a ~String~:
      #+begin_src scala
        trait Codec[A] {
          def encode(value: A): String
          def decode(value: String): A
          def imap[B](dec: A => B, enc: B => A): Codec[B] = ???
        }

        def encode[A](value: A)(implicit c: Codec[A]): String =
          c.encode(value)

        def decode[A](value: String)(implicit c: Codec[A]): A =
          c.decode(value)
      #+end_src

    - The type chart for imap is shown in *Figure 3.6*. If we have a ~Codec[A]~
      and a pair of functions ~A => B~ and ~B => A~, the imap method creates a
      ~Codec[B]~.

    - As an example use case, imagine we have a basic ~Codec[String]~, whose
      ~encode~ and ~decode~ /methods/ are both a no-op:
      #+begin_src scala
        implicit val stringCodec: Codec[String] =
          new Codec[String] {
            def encode(value: String): String = value
            def decode(value: String): String = value
          }
      #+end_src
      We can construct many usefull ~Codec~'s for other types by building off of
      ~stringCodec~ using ~imap~:
      #+begin_src scala
        implicit val intCodec: Codec[Int] =
          stringCodec.imap(_.toInt, _.toString)

        implicit val booleanCodec: Codec[Boolean] =
          stringCodec.imap(_.toBoolean, _.toString)
      #+end_src

    - *Coping with Failure* TODO TODO TODO
      + Our ~Codec~ /type class/ does NOT account for failures.

      + If we want to model more sophisticated relationships we can move beyond
        /functors/ to look at /lenses/ and /optics/.

        _This beyond this book (See Julien Truffaut's /Monocle/)._

**** DONE 3.6.2.1 Transformative Thinking with ~imap~ - 66
     CLOSED: [2019-10-09 Wed 18:20]
     - Exercise:
       Implement ~Codec[A]~
       #+begin_src scala
         trait Codec[A] { self =>
           def encode(value: A): String
           def decode(value: String): A

           def imap[B](dec: A => B, enc: B => A): Codec[B] =
             new Codec[B] {
               override def encode(value: B): String =
                 self.encode(enc(value))

               override def decode(value: String): B =
                 dec(self.decode(value))
             }
         }
       #+end_src

     - Exercise:
       Implement ~Codec[Double]~
       #+begin_src scala
         implicit val doubleCodec =
           stringCodec.imap(_.toDouble, _.toString)
       #+end_src

     - Exercise:
       ~case class Box[A](value: A)~
       Implement ~Codec[Box]~
       #+begin_src scala
         implicit def boxCodec[A](implicit aCodec: Codec[A]): Codec[Box[A]] =
           c.imap[Box[A]](Box.apply, _.value)
       #+end_src

     - Usage:
       #+begin_src scala
         encode(123.4)
         // res0: String = 123.4

         decode[Double]("123.4")
         // res1: Double = 123.4

         encode(Box(123.4))
         // res2: String = 123.4

         decode[Box[Double]]("123.4")
         // res3: Box[Double] = Box(123.4)
       #+end_src

     - *What's With the Names?*
       =TODO=
       =RE-DO=

** DONE 3.7 Contravariant and Invariant in Cats - 68 - =TODO=
   CLOSED: [2019-03-31 Sun 02:12]
   Cats provide /contravariant and invariant functors/ through /type classes/
   ~cats.Contravariant~ and ~cats.Invariant~. Here is a SIMPLIFIED version:
   #+begin_src scala
     trait Contravariant[F[_]] {
       def contramap[A, B](fa: F[A])(f: B => A): F[B]
     }

     trait Invariant[F[_]] {
       def imap[A, B](fa: F[A])(f: A => B)(g: B => A): F[B]
     }
   #+end_src

*** TODO 3.7.1 Contravariant in Cats - 68
    #+begin_src scala
      // TODO: Example code
    #+end_src

*** TODO 3.7.2 Invariant in Cats - 68
    #+begin_src scala
      // TODO: Example code
    #+end_src

** TODO 3.8 Aside: Partial Unification - 70
   - =from Jian= A clear explanation from _djspiewak_ (GitHub name):
     https://gist.github.com/djspiewak/7a81a395c461fd3a09a6941d4cd040f2
     This article doesn't mention the walkaround for right-biased
     partial-unification, which is given in this section. See blow.

   - SI-2712, which is identified as a bug, is a type inference limitation. It is
     already fixed.
     + Before Scala 2.13,
       Use the compiler option =-Ypartial-unification=;

     + From Scala 2.13 on, _partial-unification_ is there by default, and no option
       for it.

   - Example:
     + With =-Ypartial-unification= set in =build.sbt=
       #+begin_src scala
         import cats.Functor
         import cats.instances.function._ // for Functor
         import cats.syntax.functor._     // for map

         val func1 = (x: Int) => x.toDouble
         val func2 = (y: Double) => y * 2

         val func3 = func1.map(func2)
         // func3: Int => Double = scala.runtime.AbstractFunction1$$Lambda$7404/290370740@246b5bc6
       #+end_src

     + Without =-Ypartial-unification=, you can see
       #+begin_src scala
         val func3 = func1.map(func2)
         // <console>: error: value map is not a member of Int => Double
         //        val func3 = func1.map(func2)
         //                          ^
       #+end_src

*** DONE 3.8.1 Unifying Type Constructors - 70
    CLOSED: [2020-02-20 Thu 10:42]
    In order to compile an expression like ~func1.map(func2)~ above, the compiler
    has to search for a ~Functor~ for ~Function1~.

    1. During the search, however, ~Functor~ accepts a /type constructor/ with *ONE*
       /type parameter/:
       #+begin_src scala
         trait Functor[F[_]] {
           def map[A, B](fa: F[A])(func: A => B): F[B]
         }
       #+end_src

       and ~Function1~ has *TWO* /type parameters/.

       #+begin_src scala
         trait Function1[-A, +B] {
           def apply(arg: A): B
         }
       #+end_src

    2. We know if one is fixed, this number of /type parameters/ mismatch can be
       resolved. And we know in this case it should be the /parameter type/ ~A~.
         However, the compiler by default doesn't know which should. The compiler
       option ~-Ypartial-unification~ can tell the compiler do left-to-right
       elimination, and fix the ~A~ of ~Function1[-A, +B]~ in this exmaple.

    3. =from Jian=
       The link from gist I provide a useful mnemonic:
       When use set the ~-Ypartial-unification~ option, we can consider all type
       constructors by default curried and can be partially applied.

*** TODO 3.8.2 Left-to-Right Elimination - 71
    - TODO NOTE

    - TODO NOTE

    - TODO NOTE

    - Walkaround:
      #+begin_src scala
        import cats.Functor
        import cats.instances.function._  // for Functor
        import cats.syntax.functor._      // for map

        type <=[B, A] = A => B
        type F[A] = Double <= A

        val func1 = (x: Int) => x.toDouble
        val func2 = (y: Double) => y * 2

        val func2b: Double <= Double = func2

        val func3c = func2b.contramap(func1)
      #+end_src

** DONE 3.9 Summary - 74
   CLOSED: [2019-10-10 Thu 14:16]
   Functors represent sequencing behaviours.

   - We covered three types of functor in this chapter:
     + /Covariant Functors/,
       represent the ability to _apply functions to a value in some context_
       with their ~map~ /method/,

       Successive calls to ~map~ apply these functions _in sequence_, each
       accepting the result of its PREdecessor as a parameter.

     + /Contravariant functors/,
       with their ~contramap~ /method/,
       represent the ability to *"prepend"* functions to a function-like context.

       Successive calls to ~contramap~ sequence these functions _in the opposite
       order to_ ~map~.

     + /Invariant functors/,
       represent _bidirectional transformations_. It has the ~imap~ method.

   - /Functors/ for collections are extremely important, as they transform each
     element independently of the rest. This allows us to parallelise or
     distribute transformations on large collections, a technique leveraged
     heavily in "mapreduce" frameworks like Hadoop.
     TODO
     We will investigate this approach in more detail in the Map-reduce case
     study later in the book.

   - The ~Contravariant~ and ~Invariant~ /type classes/ are less widely applicable
     but are still useful for building data types that _represent *transformations*._
     TODO
     We will revisit them to discuss the ~Semigroupal~ /type class/ later in Chapter 6.

* TODO 4 Monads - 75 - =TODO= =ReRead=
  - Informally,
    a /monad/ is anything with a /computational context/ and a ~flatMap~
    /method/ that obey the /monad laws/.

  - _Special syntax_ to SUPPORT /monads/: /for comprehensions/.

    However, despite the ubiquity of the concept,
    *the Scala standard library lacks a concrete type to encompass "things that
    can be flatMapped".*

    =from Jian=
    Programming languages like Scala and Rust don't want to scare their users
    with Monad concept support in their standard library.
      However, because of the good type system and their design, /monad/ is
    inevitable -- actually we should give a hug to it. I believe They will
    definitely support /monad/ in their standard libary in the future.
    =END Comment=

    *This type class is one of the benefits brought to us by Cats.*

** DONE 4.1 What is a Monad? - 75
   CLOSED: [2018-10-28 Sun 01:00]
   - *A /monad/ is a mechanism for _SEQUENCING computations_.*

**** DONE ~Option~'s - 76
     CLOSED: [2019-03-31 Sun 04:01]
     #+begin_src scala
       import scala.util.Try

       def parseInt(str: String): Option[Int] =
         Try(str.toInt).toOption

       def divide(a: Int, b: Int): Option[Int] =
         if (b == 0) None else Some(a / b)

       def strignDivideBy(aStr: String, bStr: String): Option[Int] =
         parseInt(aStr).flatMap { aNum =>
           parseInt(bStr).flatMap { bNum =>
             divide(aNum, bNum)
           }
         }

       def strignDivideBy(aStr: String, bStr: String): Option[Int] =
         for {
           aNum <- parseInt(aStr)
           bNum <- parseInt(bStr)
           ans <- divide(aNum, bNum)
         } yield ans
     #+end_src

**** DONE ~List~'s - 78
     CLOSED: [2019-03-31 Sun 03:55]
     The for-comprehension form with ~List~'s looks very like imperative for loops.
     #+begin_src scala
       for {
         x <- List(1, 2, 3)
         y <- List(4, 5)
       } yield (x, y)
     #+end_src

     _HOWEVER_, there is _ANOTHER_ *mental model* we can apply that highlights the
      /monadic behaviour/ of ~List~:
      if we think of ~List~'s as sets of /intermediate results/, ~flatMap~ becomes
      a construct that calculates _permutations and combinations_.

**** DONE ~Future~'s - 79
     CLOSED: [2019-03-31 Sun 03:51]
     This section we give example with for-comprehension, and ~Future~'s *are
     sequenced*.
       We *can* run /futures/ in _parallel_, but this is another story and shall
     be told another time. =TODO= =TODO= =TODO=

     *Monads are all about sequencing.*

*** DONE 4.1.1 Definition of a Monad - 80
    CLOSED: [2018-10-28 Sun 00:04]
    #+BEGIN_SRC scala
      import scala.language.higherKinds

      trait Monad[F[_]] {
        def pure[A](value: A): F[A]

        def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]
      }
    #+END_SRC

    - *Monad Laws*
      ~pure~ and ~flatMap~ must obey a set of /laws/ that allow us to sequence
      operations freely *WITHOUT* unintended glitches and side-effects:

      + Left identity:
        calling ~pure~ and transforming the result with ~func~ is the same as
        calling ~func~:
        ~pure(a).flatMap(func)~ \equiv{} ~func(a)~

      + Right identity:
        passing ~pure~ to ~flatMap~ is the same as doing nothing:
        ~m.flatMap(pure)~ \equiv{} ~m~

      + Associativity:
        flatMapping over two functions ~f~ and ~g~ is the same as flatMapping
        over ~f~ and then flatMapping over ~g~:
        ~m.flatMap(f).flatMap(g)~ \equiv{} ~m.flatMap(x => f(x).flatMap(g))~

*** DONE 4.1.2 Exercise: Getting Func-y - 81
    CLOSED: [2018-10-28 Sun 00:04]
    #+BEGIN_SRC scala
      import scala.language.higherKinds

      trait Monad[F[_]] {
        def pure[A](a: A): F[A]

        def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]

        def map[A, B](value: F[A])(func: A => B): F[B] =
          flatMap(value)(a => pure(func(a)))
          // from Jian:
          // can I write: flatMap(value)(func andThen pure)
      }
    #+END_SRC

** DONE 4.2 ~Monad~'s in Cats - 82
   CLOSED: [2018-10-28 Sun 01:00]
   Still
   - type class
   - instances
   - syntax

*** DONE 4.2.1 The ~Monad~ Type Class - 82
    CLOSED: [2019-04-01 Mon 13:32]
    - ~Monad~ extends _TWO_ other /type classes/:
      + ~FlatMap~, which provides ~flatMap~;
      + ~Applicative~, which provides ~pure~.

*** DONE 4.2.2 Default Instances - 83
    CLOSED: [2019-04-01 Mon 13:32]
    Still inside ~cats.instances~

    - There is a ~Monad~ for ~Future~.
      However, the ~ExecutionContext~ should be provided when summon it.
      #+begin_src scala
        import scala.concurrent.ExecutionContext.Implicits.global

        val fm = Monad[Future]
      #+end_src

*** DONE 4.2.3 ~Monad~ Syntax - 84
    CLOSED: [2019-04-01 Mon 13:44]
    - The syntax for /monads/ comes from _THREE_ places:
      + ~cats.syntax.flatMap~ provides syntax for ~flatMap~;
      + ~cats.syntax.functor~ provides syntax for ~map~;
      + ~cats.syntax.applicative~ provides syntax for ~pure~.

      In practice it's often easier to import everything in one go from
      ~cats.implicits~. For clarity here, we do individual imports.

    - We can use ~pure~ to construct /instances/ of a /monad/.
      Disambiguate with the /type parameter/.
      #+begin_src scala
        import cats.instances.option._       // for Monad
        import cats.instances.list._         // for Monad
        import cats.instances.applicative._  // for pure

        l.pure[Option]
        // res4: Option[Int] = Some(1)

        l.pure[List]
        // res5: List[Int] = List(1)
      #+end_src

    - Usage:
      #+begin_src scala
        import cats.Monad
        import cats.syntax.functor._ // for map
        import cats.syntax.flatMap._ // for flatMap
        import scala.language.higherKinds

        def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] =
          a.flatMap(x => b.map(y => x*x + y*y))

        import cats.instances.option._ // for Monad
        import cats.instances.list._ // for Monad

        sumSquare(Option(3), Option(4))
        // res8: Option[Int] = Some(25)

        sumSquare(List(1, 2, 3), List(4, 5))
        // res9: List[Int] = List(17, 26, 20, 29, 25, 34)
      #+end_src

      + The /comprehension/ version:
        #+begin_src scala
          def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] =
            for {
              x <- a
              y <- b
            } yield x*x + y*y

          sumSquare(Option(3), Option(4))
          // res10: Option[Int] = Some(25)

          sumSquare(List(1, 2, 3), List(4, 5))
          // res11: List[Int] = List(17, 26, 20, 29, 25, 34)
        #+end_src

** DONE 4.3 The ~Identity~ Monad - 86
   CLOSED: [2019-04-01 Mon 14:33]
   - TODO NOTE
   - TODO NOTE
   - TODO NOTE

*** 4.3.1 Exercise: Monadic Secret Identies - 88
    #+begin_src scala
      trait Id[A] extends Functor[A] with Applicative[A] with Monoad[A] {
        def pure[A]: Id[A] =
          this.value

        def map[B](f: A => B): Id[B] =
          f(this.value)

        def flaMap[B](f: A => Id[B]): Id[B] =
          f(this.value)
      }
    #+end_src
    - The Scala compiler is able to interpret values of type ~A~ as ~Id[A]~ and
      vice versa by the context in which they are used.

    - =IMPORATNAT=
      *The only restriction* we've seen to this:
      Scala *CANNOT* _unify types and type constructors_
      _when searching for /implicits/._
        Hence our need to re-type ~Int~ as ~Id[Int]~ in the call to ~sumSquare~
      at the opening of this section: ~sumSquare(3 : Id[Int], 4 : Id[Int])~

** DONE 4.4 ~Either~ - 88
   CLOSED: [2019-04-13 Sat 20:05]
   - In Scala 2.11 and earlier,
     many people didn't consider ~Either~ a /monad/ because it didn't have ~map~
     and ~flatMap~ /methods/.

   - Since Scala 2.12,
     ~Either~ becase right biased with added ~map~ and ~flatMap~.

*** DONE 4.4.1 ~Left~ and ~Right~ Bias - 88
    CLOSED: [2019-04-10 Wed 14:11]
    - Scala 2.11,
      It is inconvenient to use ~Either~ in for-comprehensions.
      #+begin_src scala
        val either1: Either[String, Int] = Right(10)
        val either2: Either[String, Int] = Right(32)

        for {
          a <- either1.right
          b <- either2.right
        } yield a + b
        // res0: scala.util.Either[String,Int] = Right(42)
      #+end_src

    - Scala 2.12, there is a redesigned ~Either~,
      #+begin_src scala
        for {
          a <- either1
          b <- either2
        } yield a + b
        // res1: scala.util.Either[String,Int] = Right(42)
      #+end_src

    - Cats *back-ports* this behaviour to Scala 2.11 via the ~cats.syntax.either~
      import, allowing us to use right-biased ~Either~ in all supported versions
      of Scala.
      #+begin_src scala
        import cats.syntax.either._  // (no need for Scala 2.12+) for map and flatMap

        for {
          a <- either1
          b <- either2
        } yield a + b
      #+end_src

*** DONE 4.4.2 Creating Instances - 89
    CLOSED: [2019-04-10 Wed 18:16]
    - Syntax from ~cats.syntax.either~
      #+begin_src scala
        import cats.syntax.either._  // for asRight

        val a = 3.asRight[String]
        // a: Either[String,Int] = Right(3)

        val b = 4.asRight[String]
        // b: Either[String,Int] = Right(4)

        for {
          x <- a
          y <- b
        } yield x*x + y*y
        // res4: scala.util.Either[String,Int] = Right(25)
      #+end_src

    - The syntax above has advantages over ~Left.apply~ and ~Right.apply~:
      *avoid over-narrowing types*.
      + Over-narrowing:
        #+begin_src scala
          def countPositive(nums: List[Int]) =
            nums.foldLeft(Right(0)) { (accumulator, num) =>
              if(num > 0) {
                accumulator.map(_ + 1)
              } else {
                Left("Negative. Stopping!")
              }
            }
          // <console>:21: error: type mismatch;
          // found   : scala.util.Either[Nothing,Int]
          // required: scala.util.Right[Nothing,Int]
          //             accumulator.map(_ + 1)
          //                            ^
          // <console>:23: error: type mismatch;
          // found   : scala.util.Left[String,Nothing]
          // required: scala.util.Right[Nothing,Int]
          //             Left("Negative. Stopping!")
          //                 ^
        #+end_src
        This code fails to compile for _TWO_ reasons:
        1. the compiler *infers* the type of the accumulator as ~Right~ instead
           of ~Either~;

        2. we didn't specify type parameters for ~Right.apply~ (=from Jian= two:
           one for result, one for error) so the compiler infers the left
           parameter as ~Nothing~.

      + NO over-narrowing:
        #+begin_src scala
          def countPositive(nums: List[Int]) =
            nums.foldLeft(0.asRight[String]) { (accumulator, num) =>
              if(num > 0) {
                accumulator.map(_ + 1)
              } else {
                Left("Negative. Stopping!")
              }
            }

          countPositive(List(1, 2, 3))
          // res5: Either[String,Int] = Right(3)

          countPositive(List(1, -2, 3))
          // res6: Either[String,Int] = Left(Negative. Stopping!)
        #+end_src

    - ~cats.syntax.either~ adds some extension methods to the ~Either~ /companion
      object/. The ~catchOnly~ and ~catchNonFatal~ /methods/ are great for
      capturing ~Exception~'s as instances of ~Either~:
      #+begin_src scala
        Either.catchOnly[NumberFormatException]("foo".toInt)
        // res7: Either[NumberFormatexception, Int] = Left(java.lang.NumberFormatException: For input string: "too")

        Either.catchNonFatal(sys.error("Badness"))
        // res8: Either[Throwable, Nothing] = Left(java.lang.RuntimeException: Badness)
      #+end_src

    - Create an ~Either~ from other data types:
      #+begin_src scala
        Either.fromTry(scala.util.Try("foo".toInt))
        // res9: Either[Throwable,Int] = Left(java.lang.NumberFormatException: For input string: "foo")

        Either.fromOption[String, Int](None, "Badness")
        // res10: Either[String,Int] = Left(Badness)
      #+end_src

*** DONE 4.4.3 Transforming ~Either~'s - 92
    CLOSED: [2019-04-13 Sat 17:48]
    - ~cats.syntax.either~ also _adds_ some useful /methods/ for /instances/ of
      ~Either~.

    - Use ~orElse~ and ~getOrElse~ to extract values _from the *right* side_.
      #+begin_src scala
        import cats.syntax.either._

        "Error".asLeft[Int].getOrElse(0)
        // res11: Int = 0

        "Error".asLeft[Int] orElse 2.asRight[String]
        // res11: Int = Right(2)

      #+end_src

    - ~ensure~ allows us to check whether the right-hand value satisfies a /predicate/:
      #+begin_src scala
        -1.asRight[String].ensure("Must be non-negative!")(_ > 0)
        // res13: Either[String,Int] = Left(Must be non-negative!)
      #+end_src

    - ~recover~ and ~recoverWith~ provide similar error handling to their namesakes
      on ~Future~:
      #+begin_src scala
        "error".asLeft[Int].recover {
          case str: String => -1
        }
        // res14: Either[String,Int] = Right(-1)

        "error".asLeft[Int].recover {
          case str: String => Right(-1)
        }
        // res15: Either[String,Int] = Right(-1)
      #+end_src

    - ~leftMap~ and ~bimap~:
      #+begin_src scala
        "foo".asLeft[Int].leftMap(_.reverse)
        // res16: Either[String,Int] = Left(oof)

        6.asRight[String].bimap(_.reverse, _ * 7)
        // res17: Either[String,Int] = Right(42)

        "bar".asLeft[Int].leftMap(_.reverse, _ * 7)
        // res18: Either[String,Int] = Left(rab)
      #+end_src

    - ~swap~ exchanges left for right:
      #+begin_src scala
        123.asRight[String]
        // res19: Either[String,Int] = Right(123)

        123.asRight[String].swap
        // res20: Either[String,Int] = Left(123)
      #+end_src

    - ~toOption~, ~toList~, ~toTry~, ~toValidated~, and so on.

*** DONE 4.4.4 Error Handling - 93
    CLOSED: [2019-04-13 Sat 18:10]
    ~Either~ is typically used to implement fail-fast error handling.

    - We *sequence* computations using ~flatMap~ as usual.
      #+begin_src scala
        for {
          a <- 1.asRight[String]
          b <- 0.asRight[String]
          c <- if (b == 0) "DIV0".asLeft[Int]
          else        (a / b).asRight[String]
        } yield c * 100
        // res21: Either[String, Int] = Left(DIV0)
      #+end_src

    - When using ~Either~ for error handling,
      we need to _determine what type we want to useto represent errors._
      1. We could use ~Throwable~ for this:
         ~type Result[A] = Either[Throwable, A]~
         This has similar semantics to ~scala.util.Try~.

      2. Mostly, we don't want such ~Throwable~, which is a extremely broad type.
         We can define an /algebraic data type/ to represent errors, for
         exmaple, that may occur in our program:
         #+begin_src scala
           sealed trait LoginError extends Product with Serializable

           final case class UserNotFound(username: String) extends LoginError
           final case class PasswordIncorrect(username: String) extends LoginError
           case object UnexpectedError extends LoginError

           type LoginResult = Either[LoginError, User]


           // Choose error-handling behaviour based on type:
           def handleError(error: LoginError): Unit =
             error match {
               case UserNotFound(u) =>
                 println(s"User not found: $u")

               case PasswordIncorrect(u) =>
                 println(s"Password incorrect: $u")

               case UnexpectedError =>
                 println(s"Unexpected error")
             }

           val result1: LoginResult = User("dave", "passw0rd").asRight
           // result1: LoginResult = Right(User(dave,passw0rd))

           val result2: LoginResult = UserNotFound("dave").asLeft
           // result2: LoginResult = Left(UserNotFound(dave))

           result1.fold(handleError, println)
           // User(dave,passw0rd)

           result2.fold(handleError, println)
           // User not found: dave
         #+end_src

*** DONE 4.4.5 Exercise: What is Best? - 95
    CLOSED: [2019-04-13 Sat 20:05]
    =RE-DO=

** DONE 4.5 Aside: Error Handling and ~MonadError~ - 95
   CLOSED: [2019-04-10 Wed 14:02]
   Cats provides an additional /type class/ called ~MonadError~ that abstracts
   over ~Either~-like data types that are used for *error handling*.

   - ~MonadError~ provides extra operations for
     + raising errors
     + handling errors

   - *This Section is Optional!*
     You won't need to use ~MonadError~ unless you need to *abstract over error
     handling monads* (If you don't need this kind of abstraction right now, feel free to skip
     onwards to Section 4.6).

     + For example, you can use ~MonadError~ to abstract TODO
       * over ~Future~ and ~Try~,
         OR
       * over ~Either~ and ~EitherT~ (which we will meet in Chapter 5).

*** DONE 4.5.1 The ~MonadError~ Type Class - 95
    CLOSED: [2019-04-10 Wed 13:35]
    - The simplified definition of ~MonadError~:
      #+begin_src scala
        package cats

        trait MonadError[F[_], E] extends Monad[F] {
          // Lift an error in to the `F` context:
          def raiseError[A](e: E): F[A]

          // Handle an error, potentially recovering from it:
          def handleError[A](fa: F[A])(f: E => A): F[A]

          // Test an instance of `F`,
          // failing if the predicate is not satisfied:
          def ensure[A](fa: F[A])(e: E)(f: A => Boolean): F[A]
        }
      #+end_src

    - ~MonadError~ is defined in terms of two type parameters:
      * ~F~
        the type of the /monad/;

      * ~E~
        the type of error contained within ~F~.

    - To demonstrate how these parameters fit together, here's an example where
      we instantiate the type class for ~Either~:
      #+begin_src scala
        import cats.MonadError
        import cats.instances.either._  // for MonadError

        type ErrorOr[A] = Either[String, A]
        val monadError = MonadError[ErrorOr, String]
      #+end_src

    - ~ApplicativeError~
      _In reality_,
      ~MonadError~ extends another /type class/ called ~ApplicativeError~.
      However, we won't encounter ~Applicative~'s until Chapter 6.
      _The /semantics/ are the SAME_ for each /type class/ so we can _ignore
      this detail for now_.

*** DONE 4.5.2 Raising and Handling Errors - 97
    CLOSED: [2019-04-10 Wed 13:52]
    - The _two_ most important /methods/ of ~MonadError~:
      + ~raiseError~
      + ~handleError~.

    - ~raiseError~ is like the ~pure~ /method/ for ~Monad~
      except that it creates an instance representing a _failure_:
      #+begin_src scala
        val success = monadError.pure(42)
        // success: ErrorOr[Int] = Right(42)

        val failure = monadError.raiseError("Badness")
        // failure: ErrorOr[Nothing] = Left(Badness)
      #+end_src

    - ~handleError~ is the complement of ~raiseError~.
      It is similar to the ~recover~ /method/ of ~Future~:
      #+begin_src scala
        monadError.handleError(failure) {
          case "Badness" => monadError.pure("It's ok")
          case other     => monadError.raiseError("It's not ok")
        }
        // res2: ErrorOr[ErrorOr[String]] = Right(Right(It's ok))
      #+end_src

    - ~ensure~ implements a filter-like behaviour:
      #+begin_src scala
        import cats.syntax.either._  // for asRight

        monadError.ensure(success)("Number too low!")(_ > 1000)
        // res3: ErrorOr[Int] = Left(Number too low!)
      #+end_src

    - Syntax:
      ~raiseError~ and ~handleError~ from ~cats.syntax.applicativeError~
      ~ensure~ from ~cats.syntax.monadError~
      #+begin_src scala
        import cats.syntax.applicative._       // for pure
        import cats.syntax.applicativeError._  // for raiseError etc
        import cats.syntax.monadError._        // for pure

        val success = 42.pure[ErrorOr]
        // success: ErrorOr[Int] = Right(42)

        val failure = "Badness".raiseError[ErrorOr, Int]
        // failure: ErrorOr[Int] = Left(Badness)

        success.ensure("Number to low!")(_ > 1000)
        // res4: Either[String,Int] = Left(Number to low!)
      #+end_src

    - There are other useful variants of these /methods/. TODO TODO TODO
      See the source of ~cats.MonadError~ and ~cats.ApplicativeError~ for more
      info.

*** DONE 4.5.3 Instances of ~MonadError~ - 98
    CLOSED: [2019-04-10 Wed 14:02]
    Cats provides instances of ~MonadError~ for numerous data types including
    ~Either~, ~Future~, and ~Try~.

    - The instance for ~Either~ is customisable to any error type,
      whereas the instances for ~Future~ and ~Try~ always represent errors as
      ~Throwables~:
      #+begin_src scala
        import scala.util.Try
        import cats.instances.try_._  // for MonadError


        val exn: Throwable =
          new RuntimeException("It's all gone wrong")

        exn.raiseError[Try, Int]
        // res6: scala.util.Try[Int] = Failure(java.lang.RuntimeException: It's all gone wrong)
      #+end_src

*** TODO 4.5.4 Exercise: Abstracting - 99 - =OPEN ISSUE=
    No exercise here -- there is an open issue for this in github

** DONE 4.6 The ~Eval~ Monad - 100
   CLOSED: [2019-04-02 Tue 17:57]
   ~cats.Eval~ is a /monad/ that allows us to _abstract over different models of
   evaluation._

   - We typically hear of _TWO_ such models: /eager/ and /lazy/.
       ~Eval~ throws in a _further distinction_ of whether or not a result is
     /memoized/.

*** DONE 4.6.1 Eager, Lazy, Memoized, Oh My! - 100
    CLOSED: [2019-04-02 Tue 15:33]
    - /Eager computations/ HAPPEN _immediately_
      whereas
      /Lazy computations/ HAPPEN _on access_.

      /Memoized computations/ are run *ONCE* _on first access_,
      after which the results are *cached*.

    - For example,
      in Scala (the _evaluation properties_ of the three ways below can be shown
      through a _visible side-effect_),
      + ~val~'s are /eager/ and /memoized/.
        #+begin_src scala
          val x = {
            println("Computing X")
            math.random
          }
          // Computing X
          // x: Double = 0.0657586956104027

          x  // first access
          // res0: Double = 0.0657586956104027

          x  // second access
          // res1: Double = 0.0657586956104027
        #+end_src

      + ~def~'s are /lazy/ and *NOT* /memoized/.
        #+begin_src scala
          def y = {
            println("Computing X")
            math.random
          }
          // y: Double

          y  // first access
          // Computing Y
          // res2: Double = 0.9184384488125138

          y  // second access
          // Computing Y
          // res3: Double = 0.20807113447602488
        #+end_src

      + ~lazy val~'s are /lazy/ and /memoized/.
        #+begin_src scala
          lazy val z = {
            println("Computing Z")
            math.random
          }
          // z: Double = <lazy>

          z  // first access
          // Computing Z
          // res4: Double = 0.1783014120350146

          z  // second access
          // res5: Double = 0.1783014120350146
        #+end_src

*** DONE 4.6.2 Eval's Models of Evaluation - 102
    CLOSED: [2019-04-02 Tue 16:19]
    - ~Eval~ has THREE /subtypes/: ~Now~, ~Later~, and ~Always~.

    - We construct these with _THREE /constructor methods/,_ which create
      instances of the THREE /classes/ and *return them typed as ~Eval~:*
      #+begin_src scala
        import cats.Eval

        val now = Eval.now(math.random + 1000)
        // now: cats.Eval[Double] = Now(1000.885603643474)

        val later = Eval.later(math.random + 2000)
        // later: cats.Eval[Double] = cats.Later@679671c

        val always = Eval.always(math.random + 3000)
        // always: cats.Eval[Double] = cats.Always@396fe27e
      #+end_src

      =From Jian= =START=
      It's critical that we should use these /constructor methods/, rather then
      the /constructors/ of EACH /subtypes/.

      *The return type is important!!!*

      The compiler needs ~Eval~, rather than its /subtypes/, too narrow types
      can make the compiler be confused. TODO =MORE DETAILS= =???=
      =From Jian= =END=

    - Extract the result of an ~Eval~ using its ~value~ /method/:
      #+begin_src scala
        now.value
        // res6: Double = 1000.885603643474

        later.value
        // res7: Double = 2000.1770874422618

        always.value
        // res8: Double = 3000.637554292833
      #+end_src

    - ~Eval.now~ captures a value _right now_.
      Its semantics are similar to a ~val~ -- /eager/ and /memoized/.

    - ~Eval.always~ captures a /lazy/ computation, similar to a ~def~ -- /lazy/
      and *NOT* /memoized/.

    - ~Eval.later~ captures a /lazy/, /memoized/ computation, similar to a
      ~lazy val~ -- /lazy/ and /memoized/.

    - The three behaviours are summarized below:
      | Scala      | Cats     | Properties         |
      |------------+----------+--------------------|
      | ~val~      | ~Now~    | eager, memoized    |
      | ~lazy val~ | ~Later~  | lazy, memoized     |
      | ~def~      | ~Always~ | lazy, not memoized |

    - =From Jian=
      We *DO NOT* have /eager/ and *NOT* /memoized/ evaluation model, which is
      not reasonable -- just like copy and paste a segment of code everywhere,
      Everytime see them evaluate them. Even though they are the same code
      segment, sometimes even same calculation (when no side effect), but no
      connections built between them.

*** DONE 4.6.3 ~Eval~ as a ~Monad~ - 104
    CLOSED: [2019-04-02 Tue 17:20]
    - Like all monads, Eval's ~map~ and ~flatMap~ /methods/ add computations to a
      _chain_.

    - In the case of ~Eval~, the _chain_ is stored explicitly as _a list of functions_.
      The functions are NOT run until we call ~Eval~'s ~value~ /method/ to request
      a result:
      #+begin_src scala
        val greeting = Eval.
          always { println("Step 1"); "Hello" }.
          map { str => println("Step 2"); s"$str world" }
        // greeting: cats.Eval[String] = cats.Eval$$anon$8@157f7b8c

        greeting.value
        // Step 1
        // Step 2
        // res15: String = Hello world
      #+end_src

    - =IMPORTANT=
      While the /semantics/ of the originating ~Eval~ /instances/ are maintained,
      _mapping functions are *always called lazily* on demand (~def~ /semantics/)._
      #+begin_src scala
        val ans = for {
          a <- Eval.now { println("Calculating A"); 40 }
          b <- Eval.always { println("Calculating B"); 2 }
        } yield {
          println("Adding A and B")
          a + b
        }
        // Calculating A
        // ans: cats.Eval[Int] = cats.Eval$$anon$8@37c1363d

        ans.value  // first access
        // Calculating B
        // Adding A and B
        // res16: Int = 42

        ans.value  // second access
        // Calculating B
        // Adding A and B
        // res17: Int = 42
      #+end_src

    - Some times we don't want the ~def~ /semantics/, and ~Eval~ has a ~memoize~
      /method/ that allows us to _memoize a chain of computations_
      + the result of the chain up to the call to ~memoize~ is _CACHED_,
        whereas
      + calculations after the call _RETAIN their ORIGINAL_ /semantics/:
      #+begin_src scala
        val saying = Eval.
          always { println("Step 1"); "The cat" }.
          map { str => println("Step 2"); s"$str sat on" }.
          memoize.
          map { str => println("Step 3"); s"$str the mat" }
        // saying: cats.Eval[String] = cats.Eval$$anon$8@2196a9a1

        saying.value  // first access
        // Step 1
        // Step 2
        // Step 3
        // res18: String = The cat sat on the mat

        saying.value  // second access
        // Step 3
        // res19: String = The cat sat on the mat
      #+end_src

*** DONE 4.6.4 Trampolining and ~Eval.defer~ - 105
    CLOSED: [2019-04-02 Tue 17:56]
    =from Jian= Try to learn more about /trampolining/.
    ~Eval~'s ~map~ and ~flatMap~ /methods/ are /trampolined/, which means we can
    nest calls to ~map~ and ~flatMap~ *ARBITRARILY without consuming stack
    frames.*

    _We call this property /stack safety/._

    - For example,
      #+begin_src scala
        def factorial(n: BigInt): BigInt =
          if (n == 1) n else n * factorial(n - 1)
      #+end_src
      will stack overflow when the input is large, for instance 50000.

      1. First try:
         #+begin_src scala
           def factorial(n: BigInt): Eval[BigInt] =
             if(n == 1) {
               Eval.now(n)
             } else {
               factorial(n - 1).map(_ * n)
             }
         #+end_src

         This still doesn't work, and we will see
         #+begin_src scala
           factorial(50000).value
           // java.lang.StackOverflowError
           // ...
         #+end_src

         The problem here is we didn't avoid the ~factorial~ call stack overflow
         -- only ~Eval.now(n)~ in the base case and make the return value of type
         ~Eval[BigInt]~ is NOT enough.

      2. Resolve the problem of the first try:
         #+begin_src scala
           def factorial(n: BigInt): Eval[BigInt] =
             if(n == 1) {
               Eval.now(n)
             } else {
               Eval.defer(factorial(n - 1).map(_ * n))
             }
         #+end_src
         This will work perfectly.

    - Everything has a cost!!!
      /Trampolining/ help us avoiding consuming /stack/ by creating a chain of
      function /objects/ on the /heap/ -- like some recursion to iterative
      method (iterative traverse of a tree).

    - There are still limits on how deeply we can nest computations,
      BUT they are *bounded by the size of the /heap/ rather than the /stack/.*

*** TODO 4.6.5 Exercise: Safer Folding using ~Eval~ - 107
    =from Jian= I made a mistake at my first try. Try to do it again later.

** DONE 4.7 The ~Writer~ Monad - 107
   CLOSED: [2019-04-14 Sun 02:04]
   ~cats.data.Writer~ is a /monad/ that lets us carry a log along with a
   computation.

   - We can use it to
     1. record messages, errors, or additional data about a computation
        AND
     2. extract the log alongside the final result.

   - One common use for ~Writer~'s is _recording sequences of steps in multi-threaded
     computations_ where
     + standard imperative logging techniques can result in *interleaved messages
       from different contexts*.

     + With ~Writer~ the log for the computation is _tied to the result_, so we can
       run concurrent computations *without mixing logs*.

   - *Cats Data Types*
     ~Writer~ is the FIRST /data type/ we've seen from the ~cats.data~ package.

     - This package provides instances of various /type classes/ that *produce
       useful semantics*.

     - Other examples from ~cats.data~ include the /monad transformers/ that we
       will see in the next chapter, and the ~Validated~ type we will encounter
       in Chapter 6. TODO TODO TODO

*** DONE 4.7.1 Creating and Unpacking Writers - 108
    CLOSED: [2019-04-13 Sat 23:55]
    - A ~Writer[W, A]~ carries two values:
      + a log of type ~W~
      + a result of type ~A~

    - We can create a ~Writer~ from values of each type as follows:
      #+begin_src scala
        import cats.data.Writer
        import cats.instances.vector._  // for Monoid

        Writer(Vector("It was the best of times",
                      "it was the wrost of times"),
               1859)
        // res0: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String], Int] =
        //       WriterT((Vector(It was the best of times, it was the wrost of times),1859))
      #+end_src
      Cats implements ~Writer~ in terms of another type, ~WriterT~:
      ~type Writer[W, A] = Writer[Id, W, A]~ (ignore this before Chapter 5).

    - When you only have a result (type ~A~), in scope there must be a ~Monoid[W]~
      which help Cats find proper empty log value.
      For instance,
      #+begin_src scala
        import cats.instances.vector._    // for Monoid
        import cats.syntax.applicative._  // for pure

        type Logged[A] = Writer[Vector[String], A]

        123.pure[Logged]
        // res2: Logged[Int] = WriterT((Vector(), 123))
      #+end_src

    - Similary, you may have a log and no result.
      You can create a ~Writer[Unit]~ using ~tell~ syntax from
      ~cats.syntax.writer~:
      #+begin_src scala
        import cats.syntax.writer._  // for tell

        Vector("msg1", "msg2", "msg3").tell
        // res3: cats.data.Writer[scala.collection.immutable.Vector[String],Unit] = WriterT((Vector(msg1, msg2, msg3),()))
      #+end_src

    - If we have both a log and a result,
      we can either use
      + ~Writer.apply~
        #+begin_src scala
          val a = Writer(Vector("msg1", "msg2", "msg3"), 123)
          // a: cats.data.WriterT[cats.Id.scala.collection.immutable.Vector[String],Int] =
          //    WriterT((Vector(msg1, msg2, msg3),123))
        #+end_src
        OR
      + the ~writer~ sytnax from ~cats.syntax.writer~:
        #+begin_src scala
          import cats.syntax.writer._  // for writer

          val b = 123.writer(Vector("msg1", "msg2", "msg3"))
          // b: cats.data.WriterT[cats.Id.scala.collection.immutable.Vector[String],Int] = WriterT((Vector(msg1, msg2, msg3),123))
        #+end_src

    - Extract result or log:
      #+begin_src scala
        val aResult: Int = a.value
        // aResult: Int = 123

        val aLog: Vector[String] = a.written
        // aLog: Vector[String] = Vector(msg1, msg2, msg3)
      #+end_src

    - We can extract both values at the same time:
      #+begin_src scala
        val (log, result) = b.run
        // log: scala.collection.immutable.Vector[String] = Vector(msg1, msg2, msg3)
        // result: Int = 123
      #+end_src

*** DONE 4.7.2 Composing and Transforming Writers - 110
    CLOSED: [2019-04-14 Sun 01:49]
    As a /moand/, ~Writer~ can be preserved when applying ~map~ or ~flatMap~
    over it.

    - ~flatMap~ *appends* the logs from the source ~Writer~ and the result of the
      user's sequencing function.
        For this reason, efficient *append* and *concatenate* operations are
      important! We usually use ~Vector~:
      #+begin_src scala
        val writer1 = for {
          a <- 10.pure[Logged]
          _ <- Vector("a", "b", "c").tell
          b <- 32.writer(Vector("x", "y", "z"))
        } yield a + b
        // writer1: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(a, b, c, x, y, z),42))

        writer1.run
        // res4: cats.Id[(Vector[String], Int)] = (Vector(a, b, c, x, y, z) ,42)
      #+end_src

    - Transform the log in a /writer/:
      #+begin_src scala
        val writer2 = writer1.mapWritten(_.map(_.toUpperCase))
        // writer2: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] = WriterT((Vector(A, B, C, X, Y, Z),42))

        writer2.run
        // res5: cats.Id[(scala.collection.immutable.Vector[String], Int)] = (Vector(A, B, C, X, Y, Z),42)
      #+end_src

    - Transform both log and result simultaneously using
      #+begin_src scala
        val writer3 = writer1.bimap(
          log => log.map(_.toUpperCase),
          res => res * 100
        )
        // writer3: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] =
        //   WriterT((Vector(A, B, C, X, Y, Z),4200))

        writer3.run
        // res6: cats.Id[(scala.collection.immutable.Vector[String], Int)] =
        //   (Vector(A, B, C, X, Y, Z),4200)

        val writer4 = writer1.mapBoth { (log, res) =>
          val log2 = log.map(_ + "!")
          val res2 = res * 1000
          (log2, res2)
        }
        // writer4: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] =
        //   WriterT((Vector(a!, b!, c!, x!, y!, z!),4200))

        writer4.run
        // res7: cats.Id[(scala.collection.immutable.Vector[String], Int)] =
        //   (Vector(A, B, C, X, Y, Z),4200)
      #+end_src
      + ~bimap~, which accept two function parameters for log and result respectively.
      + ~mapBoth~, which accept single function parameter that accept two parameters.

    - Clear log with ~reset~;
      Swap log and result with ~swap~.
      #+begin_src scala
        val writer5 = writer1.reset
        // writer5: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(),42))

        writer5.run
        // res8: cats.Id[(Vector[String], Int)] = (Vector(),42)

        val writer6 = writer1.swap
        // writer6: cats.data.WriterT[cats.Id,Int,Vector[String]] = WriterT((42,Vector(a, b, c, x, y, z)))

        writer6.run
        // res9: cats.Id[(Int, Vector[String])] = (42,Vector(a, b, c, x, y, z))
      #+end_src

*** DONE 4.7.3 Exercise: Show Your Working - 112
    CLOSED: [2019-04-14 Sun 02:04]
    =from Jian= Can we make it look better???
    #+begin_src scala
      def slowly[A](body: => A) =
        try body finally Thread.sleep(100)

      type IntWriter = Writer[Vector[String], Int]

      def factorial(n: Int): IntWriter =
        for {
          ans <- n match {
            case 0 => 1.pure[IntWriter]
            case _ => slowly(factorial(n - 1).map(_ * n))
          }

          _ <- Vector(s"fact $n $ans").tell
        } yield ans
    #+end_src

** DONE 4.8 The ~Reader~ Monad - 114
   CLOSED: [2019-04-17 Wed 15:23]
   ~cats.data.Reader~ is a /monad/ that allows us to *sequence operations that
   depend on some input*.

   - Instances of ~Reader~
     + *wrap up* functions of _ONE argument_,
     + providing us with useful methods for *composing* them.

   - *One common use for ~Reader~'s is /dependency injection/.*
     =IMPORTANT= =IMPORTANT= =IMPORTANT=
     + dependency injection ::
          If we have a number of operations that all _depend on some EXTERNAL
       configuration_, we can
       * _chain_ them together using a ~Reader~ to produce one large operation
         that
         accepts the configuration _as a parameter_
         and
         runs our program _in the order specified_.

*** DONE 4.8.1 Creating and Unpacking Readers - 114
    CLOSED: [2019-04-16 Tue 17:12]
    1. Create a ~Reader[A, B]~ from a function ~A => B~ using the ~Reader.apply~.
      #+begin_src scala
        import cats.data.Reader

        case class Cat(name: String, favoriteFood: String)

        val catName: Reader[Cat, String] =
          Reader(_.name)
        // catName: cats.data.Reader[Cat,String] = Kleisli(<function1>)
      #+end_src

    2. Extract the function again using the ~Reader~'s ~run~ /method/ and call it
       using ~apply~:
       #+begin_src scala
         catName.run(Cat("Garfield", "lasagne"))
         // res0: cats.Id[String] = Garfield
       #+end_src

    3. TODO What advantage do ~Reader~'s give us over the raw functions???

*** DONE 4.8.2 Composing Readers - 114
    CLOSED: [2019-04-16 Tue 17:12]
    The power of ~Reader~'s comes from their ~map~ and ~flatMap~ /methods/, which
    represent _DIFFERENT kinds of *function composition*._
      We typically create a set of ~Reader~'s that accept the *SAME type* of
    configuration, combine them with ~map~ and ~flatMap~, and then call ~run~ to
    /inject/ the config at the end.

    - ~map~ extends the computation in the ~Reader~ by passing its result through
      a function:
      #+begin_src scala
        val greetKitty: Reader[Cat, String] =
          catName.map(name => s"Hello $name")

        greetKitty.run(Cat("Heathcliff", "junk food"))
        // res1: cats.Id[String] = Hello Heathcliff
      #+end_src

    - ~flatMap~ combine /readers/ that depend on the _SAME input type_.
      #+begin_src scala
        val feedKitty: Reader[Cat, String] =
          Reader(cat => s"Have a nice bowl of ${cat.favoriteFood}")

        val greetAndFeed: Reader[Cat, String] =
          for {
            greet <- greetKitty
            feed <- feedKitty
          } yield s"$greet. $feed."

        greetAndFeed(Cat("Garfield", "lasagne"))
        // res3: cats.Id[String] = Hello Garfield. Have a nice bowl of lasagne.

        greetAndFeed(Cat("Heathcliff", "junk food"))
        // res4: cats.Id[String] = Hello Heathcliff. Have a nice bowl of junk food.
      #+end_src

*** DONE 4.8.3 Exercise: Hacking on Readers - 115
    CLOSED: [2019-04-17 Wed 15:06]
    The classic use of ~Reader~'s is to build programs that accept a configuration
    as a parameter.

    - Example: Simple login system
      + Our configuration will consist of _TWO_ databases:
        a list of valid users and a list of their password:
        #+begin_src scala
          case class Db(
            usernames: Map[Int, String],
            passwords: Map[String, String]
          )
        #+end_src
        * Create ~DbReader~:
          ~type DbReader[A] = Reader[Db, A]~

      + Create /methods/ that generate ~DbReader~'s to look up the username for
        an ~Int~ user ID, and look up the password for a ~String~ username. The
        type signatures should be as follows:
        #+begin_src scala
          def findUsername(userId: Int): DbReader[Option[String]] =
            Reader(_.usernames.get(userId))

          def checkPassword(username: String, password: String): DbReader[Boolean] =
            Reader(_.password.get(username).contains(password))
        #+end_src

      + Create ~checkLogin~ /method/ to check the password for a given user ID.
        =from Jian= This code does not have good look!!!!!
        #+begin_src scala
          def checkLogin(usedId: Int, password: String): DbReader[Boolean] =
            for {
              oUsername <- findUsername(userId)
              oPassword = username.map(un => checkPassword(un, passowrd))
              passwordOk <- oPassword.getOrElse(false.pure[DbReader])
            } yield passwordOk
        #+end_src

*** DONE 4.8.4 When to Use Readers? - 117
    CLOSED: [2019-04-17 Wed 15:22]
    - ~Reader~'s provide a tool for doing /dependency injection/.
      1. Write steps of our program as /instances/ of ~Reader~
      2. Chain them together with ~map~ and ~flatMap~
      3. Build a function that accepts the /dependency/ as input.

    - There are many ways of implementing /dependency injection/ in Scala, from
      _SIMPLE TECHNIQUES like /methods/ with multiple parameter lists_, through
      _/implicit parameters/ and /type classes/,_ to _COMPLEX TECHNIQUES like
      the /cake pattern/ and /DI frameworks/._

    - ~Reader~'s are most useful in situations where:
      + we are constructing a batch program that can EASILY be *represented by a
        function*;

      + we need to *defer* /injection/ of a known parameter or set of parameters;

      + we want to be able to *test* parts of the program _in isolation_.

    - By representing the steps of our program as ~Reader~'s
      + we can *test* them as easily as pure functions
      + we gain access to the ~map~ and ~flatMap~ /combinators/

    - DI and use other ways rather than ~Reader~ =???= =WHY=
      For more advanced problems
      where we have lots of /dependencies/, TODO =EXAMPLE???=
      or
      where a program _isn't easily represented as a pure function_, TODO =EXAMPLE???=
      _other /dependency injection/ techniques tend to be more appropriate_.

    - *Kleisli Arraows*
      You may have noticed from console output that ~Reader~ is implemented
      in terms of another type called ~Kleisli~.

      * /Kleisli arrows/ provide a _more general form_ of ~Reader~ that _generalise
        over the type constructor of the result type_.

      * TODO We will encounter ~Kleislis~ again in Chapter 5.

** DONE 4.9 The ~State~ Monad - 118
   CLOSED: [2020-02-20 Thu 14:20]
   ~cats.data.State~ allows us to
   pass additional /state/ around as part of a computation.
   =from Jian= /state/ as /computation context/.

   - We define ~State~ /instances/ representing /atomic state/ operations and
     thread them together using ~map~ and ~flatMap~.
       In this way *we can model /mutable state/ in a purely functional way,
     without using mutation.*

*** DONE 4.9.1 Creating and Unpacking State - 118
    CLOSED: [2020-02-20 Thu 11:52]
    The instance of /state monad/ ~State[S, A]~ represent functions of type
    ~S => (S, A)~, where ~S~ is the /type/ of the /state/ and ~A~ is the /type/
    of the result.

    - Example:
      #+begin_src scala
        import cats.data.State

        val a = State[Int, String] { state =>
          (state, s"The state is $state")
        }
        // a: cats.data.State[Int, String] = cats.data.IndexedStateT@12c18313
      #+end_src

    - In other words,
      an instance of ~State~ is a function that does _TWO_ things:
      + *transforms* an _input state_ to an _output state_;
      + *computes* a result.

    - ~State~ provides _THREE_ /methods/:
      + ~run~
      + ~runS~
      + ~runA~
      they return different combinations of /state/ and /result/.
      TODO ??? ??? ???
        _Each_ /method/ returns an /instance/ of ~Eval~, which ~State~ uses to
      maintain /stack safety/.

    - We call the ~value~ /method/ as usual to extract actual result:
      #+begin_src scala
        // Get the state and the result;
        val (state, result) = a.run(10).value
        // state: Int = 10
        // result: String = The state is 10

        // Get the state, ignore the result;
        val state = a.runS(10).value
        // state: Int = 10

        // Get the result, ignore the state;
        val state = a.runA(10).value
        // result: String = The state is 10
      #+end_src

*** DONE 4.9.2 Composing and Transforming State - 119
    CLOSED: [2020-02-20 Thu 12:59]
    As we've seen with ~Reader~ and ~Writer~, the power of the ~State~ /monad/
    comes from *combining* /instances/.

    - The ~map~ and ~flatMap~ /methods/ thread the /state/ from one /instance/ to
      another.

    - Each individual /instance/ represents an _atomic_ /state transformation/,
      and their combination represents a complete sequence of changes:
      #+begin_src scala
        val step1 = State[Int, String] { num =>
          val ans = num + 1
          (ans, s"Result of step1: $ans")
        }
        // step1: cats.data.State[Int,String] = cats.data.IndexedStateT@7c6e31c4

        val step2 = State[Int, String] { num =>
          val ans = num * 2
          (ans, s"Result of step2: $ans")
        }
        // step2: cats.data.State[Int,String] = cats.data.IndexedStateT@7428b330

        val both = for {
          a <- step1
          b <- step2
        } yield (a, b)
        // both: cats.data.IndexedStateT[cats.Eval,Int,Int,(String, String)] = cats.data.IndexedStateT@716401f3

        val (state, result) = both.run(20).value
        // state: Int = 42
        // result: (String, String) = (Result of step1: 21,Result of step2: 42)
      #+end_src

    - The general model for using the State monad is to represent each step of a
      computation as an instance and compose the steps using the _standard monad
      operators_.
        Cats provides several convenience constructors for creating primitive
      steps:
      + ~get~ extracts the state as the result;
        #+begin_src scala
          val getDemo = State.get[Int]
          // getDemo: cats.data.State[Int, Int] = cats.data.IndexedStateT@4df6ba6a

          getDemo.run(10).value
          // res3: (Int, Int) = (10, 10)
        #+end_src

      + ~set~ updates the state and returns unit as the result;
        #+begin_src scala
          val setDemo = State.get[Int](30)
          // setDemo: cats.data.State[Int, Unit] = cats.data.IndexedStateT@4620d0ef

          setDemo.run(10).value
          // res4: (Int, Unit) = (30, ())
        #+end_src

      + ~pure~ ignores the state and returns a supplied result;
        #+begin_src scala
          val pureDemo = State.pure[Int, String]("Result")
          // pureDemo: cats.data.State[Int,String] = cats.data.IndexedStateT@988d7b2

          pureDemo.run(10).value
          // res5: (Int, String) = (10,Result)
        #+end_src

      + ~inspect~ extracts the state via a transformation function;
        #+begin_src scala
          val inspectDemo = State.pure[Int, String](_ + "!")
          // inspectDemo: cats.data.State[Int,String] = cats.data.IndexedStateT@13734a20

          inspectDemo.run(10).value
          // res6: (Int, String) = (10,10!)
        #+end_src

      + ~modify~ updates the state using an update function.
        #+begin_src scala
          val modifyDemo = State.modify[Int, String](_ + 1)
          // modifyDemo: cats.data.State[Int,Unit] = cats.data.IndexedStateT@79493b6e

          modifyDemo.run(10).value
          // res7: (Int, Unit) = (10,())
        #+end_src

    - Use /comprehension/:
      #+begin_src scala
        import State._

        val program: State[Int, (Int, Int, Int)] = for {
          a <- get[Int]
          _ <- set[Int](a + 1)
          b <- get[Int]
          _ <- modify[Int](_ + 1)
          c <- inspect[Int, Int](_ * 1000)
        } yield (a, b, c)
        // program: cats.data.State[Int,(Int, Int, Int)] = cats.data.IndexedStateT@b8a0617

        val (state, result) = program.run(1).value
        // state: Int = 3
        // result: (Int, Int, Int) = (1,2,3000)
      #+end_src

*** DONE 4.9.3 Exercise: Post-Order Calculator - 121 - =TODO= =RE-READ=
    CLOSED: [2020-02-20 Thu 14:20]

** TODO 4.10 Defining Custom Monads - 125
   - TODO

*** TODO 4.10.1 Exercise: Branching out Further with Monads - 127
    #+begin_src scala
      enum Tree[+A] {
        case Branch(left: Tree[A], right: Tree[A])
        case Leaf(value: A)
      }
      
      import cats.Monad
      
      given treeMonad: Monad[Tree] = new Monad[Tree] {
        import Tree.*
          
        def pure[A](value: A): Tree[A] =
          Leaf(value)
      
        def flatMap[A, B](tree: Tree[A])
                         (fn: A => Tree[B]): Tree[B] =
          tree match {
            case Branch(l, r) => Branch(flatMap(l)(fn), flatMap(r)(fn))
            case Leaf(v)      => fn(v)
          }
      
        def tailRecM[A, B](a: A)(fn: A => Tree[Either[A, B]]): Tree[B] =
          flatMap(fn(a)) {
            case Left(v)  => tailRecM(v)(fn)
            case Right(v) => Leaf(v)
          }
      }
    #+end_src

** DONE 4.11 Summary - 128
   CLOSED: [2020-02-20 Thu 11:45]
   In this chapter we've seen monads up-close.
   - We saw that ~flatMap~ can be viewed as an operator for sequencing computations,
     dictating the order in which operations must happen. From this viewpoint,
     + ~Option~ represents a computation that can fail without an error message,

     + ~Either~ represents computation that can fail with a message,

     + ~List~ represents multiple POSSIBLE results,

     + ~Future~ represents a computation that may produce a value at some point
       in the future.

   - =from Jian=
     CAUTION: Use the data type mentioned above as monad only when the *monad
     laws* are satisfied!!! For instance, ~Future~'s are often used with side
     effects, and are actually _not always_ /monad/.

   - Learn some of the custom types and data structures that Cats provides, including
     + ~Id~
     + ~Reader~
     + ~Writer~
     + ~State~

   - Finally, in the unlikely event that we have to implement a custom monad,
     we've learned about defining our own instance using ~tailRecM~.
     + ~tailRecM~ is an odd wrinkle that is a concession to building a functional
       programming library that is stack-safe by default.

     + We
       * _don't need_ to understand ~tailRecM~ to understand /monads/,
       * _BUT_ having it around gives us benefits of which we can be grateful when
         writing monadic code.

* DONE 5 Monad Transformers - 129
  CLOSED: [2020-02-16 Sun 01:55]
  /Monads/ can potentially bloat the code base through nested
  for-comprehensions.

  - Example:
    #+begin_src scala
      def lookupUserName(id: Long): Either[Error, Option[String]] =
        for (optUser <- lookupUser(id))
        yield {
          for (user <- optUser)
          yield user.name
        }
    #+end_src

** DONE 5.1 Exercise: Composing Monads - 130
   CLOSED: [2020-02-15 Sat 20:23]
   - Q :: Do /monads/ compose???

   - A :: Generally speaking, No! It is easy to show this:
     #+begin_src scala
       import cats.Monad
       import cats.syntax.applicative._  // for `pure`
       import cats.syntax.flatMap._      // for `flatMap`
       import scala.language.higherKinds

       // Hypothetical example. This won't actually compile:
       def compose[M1[_]: Monad, M2[_]: Monad] = {
         type Composed[A] = M1[M2[A]]

         new Monad[Composed] {
           def pure[A](a: A): Composed[A] =
             a.pure[M2].pure[M1]

           def flatMap[A, B](fa: Composed[A])
                            (f: A => Composed[B]): Composed[B] = {
             // Problem! How do we write flatMap?
             ???
           }
         }
       }
     #+end_src
     + Without extra info, there is no way to implement ~flatMap~.

     + *We need some extra info!!!*
       For example, if ~M2~ is ~Option~, we can implement ~flatMap~ as:
       #+begin_src scala
         def flatMap[A, B](fa: Composed[A])
                          (f: A => Composed[B]): Composed[B] =
           fa.flatMap(_.fold(None.pure[M1])(f))
       #+end_src
       This is the idea behind /monad transformers/ -- =from Jian= extra info is
       given for one monad.

   - Cats defines transformers for a variety of monads, each providing the extra
     knowledge we need to compose that monad with others.

** DONE 5.2 A Transformative Example - 131
   CLOSED: [2020-02-15 Sat 22:28]
   - Cats /monad transformer/ naming convetion:
     Inner monad name suffixed with T. For example, ~OptionT~ and ~EitherT~.

   - We often alias a composed monad.
     For example, alias ~OptionT[List, A]~ to ~ListOption[A]~.
     Note how we build ~ListOption~ from the inside out.

   - Create instance of ~ListOption~:
     #+begin_src scala
       import cats.Monad
       import cats.instances.list._      // for Monad
       import cats.syntax.applicative._  // for pure

       val result1: ListOption[Int] = OptionT(List(Option(10)))
       // result1: ListOption[Int] = OptionT(List(Some(10)))

       val result2: ListOption[Int] = 32.pure[ListOption]
       // result2: ListOption[Int] = OptionT(List(Some(32)))

       result1.flatMap { (x: Int) =>
         result2.map { (y: Int) =>
           x + y
         }
       }

       // OR

       for {
         x <- result1
         y <- result2
       } yield x + y

       // res1: cats.data.OptionT[List, Int] = OptionT(List(Some(42)))
     #+end_src

   - *Complexity of Imports*
     The imports in the code samples above hint at how everything bolts
     together.

     1. We import ~cats.syntax.applicative~ to get the ~pure~ syntax.
        ~pure~ requires an implicit parameter of type ~Applicative[ListOption]~.
        _Learn ~Applicative~ in the next chapter. All /monads/ are also
        /applicatives/._

     2. In order to generate our ~Applicative[ListOption]~ we need _instances of
        ~Applicative~ for ~List~ and ~OptionT~._
        + ~OptionT~ is a Cats data type so its instance is provided by its
          /companion object/.

        + The instance for ~List~ comes from ~cats.instances.list~

     3. We're not importing ~cats.syntax.functor~ or ~cats.syntax.flatMap~.
        This is because ~OptionT~ is a _CONCRETE_ data type with its own explicit
        ~map~ and ~flatMap~ /methods/.

     We discuss imports in details is just because we refuse to use the
     universal Cats import, ~cats.implicits~.

** DONE 5.3 Monad Transformers in Cats - 132
   CLOSED: [2020-02-16 Sun 01:21]
   Each /monad transformer/ is a data type, defined in ~cats.data~, that allows
   us to _WRAP stacks of /monads/ TO produce NEW /monads/._

   - The main concepts we have to cover to understand /monad transformers/:
     + the available /transformer/ classes;
     + how to BUILD STACKS of /monads/ using /transformers/;
     + how to CONSTRUCT /instances/ of _a /monad/ stack_;
     + how to PULL APART a stack to ACCESS the wrapped /monads/.

*** DONE 5.3.1 The Monad Transformer Classes - 133
    CLOSED: [2020-02-15 Sat 23:48]
    - In fact, MANY /monads/ in Cats are defined by *combining*
      + a /monad transformer/
        with
      + the ~Id~ /monad/.

    - Concretely, some of the available instances are:
      + ~cats.data.OptionT~ for ~Option~;
      + ~cats.data.EitherT~ for ~Either~;
      + ~cats.data.ReaderT~ for ~Reader~;
      + ~cats.data.WriterT~ for ~Writer~;
      + ~cats.data.StateT~ for ~State~;
      + ~cats.data.IdT~ for ~Id~;

    - *Kleisli Arrows*
      + In Section 4.8 we mentioned that *the ~Reader~ /monad/ was a specialisation
        of a more general concept called a _"kleisli arrow"_,* represented in Cats as
        ~cats.data.Kleisli~.

      + In fact, ~Kleisli~ and ~ReaderT~ are the same thing!
        ~ReaderT~ is actually a /type alias/ for ~Kleisli~.
          This is why when we were creating ~Reader~'s last chapter and seeing
        ~Kleisli~'s on the console.

*** DONE 5.3.2 Building Monad Stacks - 133
    CLOSED: [2020-02-16 Sun 00:35]
    - Many /monads/ and all transformers have AT LEAST _two_ /type parameters/,
      so we often have to _define /type aliases/ for intermediate stages_.

    - Example:
      Suppose we want to create a NEW /monad/ by composing ~Option~ (inside) and
      ~Either~. We need to use ~Either~ as the FIRST /type parameter/ of ~OptionT~.
      _However, ~Either~ itself has *TWO* /type parameters/ and /monads/ ONLY have
      one._
        We *need* (=from Jian= and *must use*) a /type alias/ to convert the
      type constructor to the correct shape:
      #+begin_src scala
        // Alias `Either` to a type constructor with one parameter:
        type ErrorOf[A] = Either[String, A]

        // Build our final monad stack using `OptionT`:
        type ErrorOrOption[A] = OptionT[ErrorOr, A]
      #+end_src
      + =from Jian=
        We can't define the NEW /monad/ as ~OptionT[Either[String, _], A]~
        * Q :: Can Scala support syntax like this without any ambiguity???
        * A :: =Jian's Guess=:
               I'm not sure, even suppose the compiler understand the ~_~
               syntax, I guess the compiler won't allow this because it can't
               know ~String~ here is a part of the context -- for the compiler,
               it may thing both ~String~ and ~A~ are /type parameters/.

      + Usage:
        #+begin_src scala
          import cats.instances.either._  // for Monad

          val a = 10.pure[ErrorOrOption]
          // a: ErrorOrOption[Int] = OptionT(Right(Some(10)))

          val b = 32.pure[ErrorOrOption]
          // a: ErrorOrOption[Int] = OptionT(Right(Some(32)))

          // val c = a.flatMap(x => b.map(y => x)
          for {
            x <- a
            y <- b
          } yield x + y
          // c: cats.data.OptionT[ErrorOr,Int] = OptionT(Right(Some(42)))
        #+end_src

    - Things become even more confusing when we want to stack three or more /monads/.
      For example, let's create a ~Future~ of an ~Either~ of ~Option~.
      + Build inside out with an ~OptionT~ of an ~EitherT~ of ~Future~.
        HOWEVER, we CANNOT define this in one line because ~EitherT~ has _THREE_
        /type parameters/:
        #+begin_src scala
          case class EitherT[F[_], E, A](stack: F[Either[E, A]]) {
            // ...
          }
        #+end_src
        * The three type parameters are as follows:
          - ~F[_]~ is the _outer monad_ in the stack (~Either~ is the inner);
          - ~E~ is the _error type_ for the ~Either~.
          - ~A~ is the _result type_ for the ~Either~.
          -

      + Definition and usage:
        #+begin_src scala
          import scala.concurrent.Future
          import cats.data.{EitherT, OptionT}

          type FutureEither[A] = EitherT[Future, String, A]
          type FutureEitherOption[A] = OptionT[FutureEither, A]

          import cats.instances.future._  // for Monad
          import scala.concurrent.Await
          import scala.concurrent.ExecutionContext.Implicits.global
          import scala.concurrent.duration._

          val futureEitherOr: FutureEitherOption[Int] =
            for {
              a <- 10.pure[FutureEitherOption]
              b <- 32.pure[FutureEitherOption]
            } yield a + b
        #+end_src

    - *Kind Projector*
      /Kind projector/ is a compiler plugin that *enhances* Scala's type syntax
      to _make it EASIER to define_ /partially applied type constructors/.
      + For example,
        #+begin_src scala
          import cats.instances.option._  // for Monad
          // import cats.instances.option._

          123.pure[EitherT[Option, String, ?]]
          // res7: cats.data.EitherT[Option,String,Int] = EitherT(Some(Right(123)))
        #+end_src

      + CAUTION:
        The /kind projector/ *CANNOT simplify ALL* _type declarations_ down to a
        single line, but it can reduce the number of intermediate type
        definitions _needed to keep our code readable_.

*** DONE 5.3.3 Constructing and Unpacking Instances - 136
    CLOSED: [2020-02-16 Sun 00:52]
    - Use the ~apply~ method or ~pure~ method to create _transformed monad stacks
      instances_:
      + Use ~apply~
        #+begin_src scala
          val errorStack1 = OptionT[ErrorOr, Int](Right(Some(10)))
          // errorStack1: cats.data.OptionT[ErrorOr,Int] = OptionT(Right(Some(10)))
        #+end_src

      + Use ~pure~
        #+begin_src scala
          val errorStack2 = 32.pure[ErrorOrOption]
          // errorStack2: ErrorOrOption[Int] = OptionT(Right(Some(32)))
        #+end_src

    - Use the ~value~ /method/ to unpack, and
      each ~value~ can upack one level:
      #+begin_src scala
        // Extracting the untransformed monad stack:
        errorStack1.value
        // res11: ErrorOr[Option[Int]] = Right(Some(10))

        // Mapping over the `Either` in the stack:
        errorStack2.value.map(_.getOrElse(-1))
        // res13: scala.util.Either[String,Int] = Right(32)


        // Multiple levels unpack
        futureEitherOr
        // res14: FutureEitherOption[Int] = OptionT(EitherT(Future(Success(Right(Some(42))))))

        val intermediate = futureEitherOr.value
        // intermediate: FutureEither[Option[Int]] = EitherT(Future(Success(Right(Some(42)))))

        val future = intermediate.value
        // stack: scala.concurrent.Future[Either[String,Option[Int]]] = Future(Success(Right(Some(42))))

        Await.result(stack, 1.second)
        // res15: Either[String,Option[Int]] = Right(Some(42))
      #+end_src

*** DONE 5.3.4 Default Instances - 137
    CLOSED: [2020-02-16 Sun 00:57]
    - Some of the Cats monads defined by /monad transformers/:
      #+begin_src scala
        type Reader[E, A] = ReaderT[Id, E, A]  // = Kleisli[Id, E, A]
        type Writer[W, A] = WriterT[Id, W, A]
        type State[S, A] = StateT[Id, S, A]
      #+end_src

    - In other cases, /monad transformers/ are defined separately to their
      _corresponding_ /monads/, and the /methods/ of the transformer *tend to
      MIRROR the /methods/ on the /monad/.* For example,
      + ~OptionT~ defines ~getOrElse~
      + ~EitherT~ defines ~fold~, ~bimap~, ~swap~, and other useful /methods/.

*** DONE 5.3.5 Usage Patterns - 138
    CLOSED: [2020-02-16 Sun 01:21]
    The system with /monad transformers/ need to be well designed.
    _Without careful thought_, developers of code based on this system may
    end up having to unpack and repack /monads/ in different configurations to
    operate on them in differnt contexts.

    - Unfortunately, there aren't one-size-fits-all approaches to working with
      /monad transformers/. The two common approaches:
      1. For *small* OR/AND *homogenous* code bases,
         we can define a single "super stack", and stick ot it throughout our
         code base.
         =from Jian= Even in large and heterogeneous code base, we may find some
         "super stacks", though most of the stacks are not of this kind.

      2. For *large* AND/OR *heterogeneous* code bases,
         we often identify and make local /monad transformers/, use them in
         local, and untansform them before passing them on through _module
         boundaries_.

    - Example code: 138 and 139

    - The approache 2 is more universal, but it also need more consideration and
      trade off.
        Try to experiment more and gather feedback from colleagures to determine
      whether monad transformers are a good fit.

** DONE 5.4 Exercise: Monads: Transform and Roll Out - 140
   CLOSED: [2020-02-16 Sun 01:55]
** DONE 5.5 Summary - 141
   CLOSED: [2020-02-16 Sun 01:36]
   In this chapter we *introduced* /monad transformers/, which *eliminate* the
   need for /NESTED for comprehensions/ and /pattern matching/ when working with
   "stacks" of _NESTED monads_.

* DONE 6 ~Semigroupal~ and ~Applicative~ - 143
  CLOSED: [2020-02-21 Fri 10:42]
  - We'll explore certain types of program flow that they cannot represent.
    + For example, _form validation_:
      When we validate a form we want to return all the errors to the user, *not
      stop* on the first error we encounter.
        _If we model this with a /monad/ like ~Either~, we fail fast and lose
      errors. This is because one depends on the previous one._

  - We need a weaker construct -- one that does _NOT guarantee_ sequencing -- to
    achieve the result we want.
      In this chapter we will look at TWO /type classes/ that support this
    pattern:
    + ~Semigroupal~ encompasses the notion of *composing pairs of contexts*.

      Cats provides a ~cats.syntax.apply~ module that makes use of ~Semigroupal~
      and ~Functor~ to allow users to _sequence functions with multiple
      arguments_.

    + ~Applicative~ extends ~Semigroupal~ and ~Functor~.
      It provides a way of _applying functions to parameters within a context_.
      ~Applicative~ is the source of the ~pure~ /method/ we introduced in
      Chapter 4.

  - ~Applicative~'s are often formulated in terms of function application, instead
    of the /semigroupal/ formulation that is _emphasised in Cats_.
      This alternative formulation provides a link to other libraries and languages
    such as Scalaz and Haskell.
    TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
    We'll take a look at different formulations of ~Applicative~, as well as the
    relationships between ~Semigroupal~, ~Functor~, ~Applicative~, and ~Monad~,
    towards the end of the chapter.
    =IMPORTANT=

** DONE 6.1 ~Semigroupal~ - 145
   CLOSED: [2020-02-20 Thu 14:42]
   ~cat.Semigroupal~ is a /type class/ that allows us to *combine contexts*:
   If we have two objects of type ~F[A]~ and ~F[B]~, a ~Semigroupal[F]~ allows
   us to combine them to form an ~F[(A, B)]~.

   - Definition in Cats:
     #+begin_src scala
       trait Semigroupal[F[_]] {
         def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]
       }
     #+end_src
     + More freedom than ~Monad~:
       ~fa~ and ~fb~ are mutually independent, and we can compute them *in either
       order* before passing them to ~product~.

       This is in contrast to ~flatMap~, which *imposes a strict order* on its
       parameters.

*** DONE 6.1.1 Joining Two Contexts - 145
    CLOSED: [2020-02-20 Thu 14:40]
    While ~Semigroup~ allows us to *join* /values/,
    ~Semigroupal~ allows us to *join* /contexts/.
    - For example,
      #+begin_src scala
        import cats.Semigroupal
        import cats.instances.option._  // for Semigroupal

        Semigroupal[Option].product(Some(123), Some("abc"))
        // res0: Option[(Int, String)] = Some((123,abc))

        Semigroupal[Option].product(None, Some("abc"))
        // res1: Option[(Nothing, String)] = None

        Semigroupal[Option].product(Some(123), None)
        // res2: Option[(Int, Nothing)] = None
      #+end_src

*** DONE 6.1.2 Joining Three or More Contexts - 146
    CLOSED: [2020-02-20 Thu 14:42]
    The companion object for ~Semigroupal~ defines a set of methods on top of
    ~product~.

    - ~tuple2~ to ~tuple22~ generalise ~product~ to different arities:
      #+begin_src scala
        import cats.instances.option._ // for Semigroupal

        Semigroupal.tuple3(Option(1), Option(2), Option(3))
        // res3: Option[(Int, Int, Int)] = Some((1,2,3))

        Semigroupal.tuple3(Option(1), Option(2), Option.empty[Int])
        // res4: Option[(Int, Int, Int)] = None
      #+end_src

    - ~map2~ to ~map22~ apply a user-specified function to the values inside 2 to
      22 contexts:
      #+begin_src scala
        Semigroupal.map3(Option(1), Option(2), Option(3))(_ + _ + _)
        // res5: Option[Int] = Some(6)

        Semigroupal.map2(Option(1), Option.empty[Int])(_ + _)
        // res6: Option[Int] = None
      #+end_src

    - There are also:
      TODO NO detail in this book. Learn to use these methods!!!
      + ~contramap2~ to ~contramap22~ for ~Contravariant~;
      + ~impa2~ to ~imap22~ for ~Invariant~.

*** DONE 6.1.3 Semigroupal Laws - 146
    
** DONE 6.2 ~Apply~ Syntax - 147
   CLOSED: [2020-02-20 Thu 14:47]
   /Apply syntax/, ~cats.syntax.apply~, is a shorthand for the /methods/
   described above.

   - Import the syntax form ~cats.syntax.apply~.
     #+begin_src scala
       import cats.instances.option._  // for Semigroupal
       import cats.syntax.apply._      // for tupled and mapN
     #+end_src

   - The ~tupled~ /method/ is implicitly added to the tuple of ~Option~'s.
     It uses the ~Semigroupal~ for ~Option~ to zip the values inside the
     ~Option~'s, creating a single ~Option~ of a tuple:
     #+begin_src scala
       (Option(123), Option("abc")).tupled
       // res7: Option[(Int, String)] = Some((123,abc))

     #+end_src

     This can be up to 22 values.
     #+begin_src scala
       (Option(123), Option("abc"), Option(true)).tupled
       // res8: Option[(Int, String, Boolean)] = Some((123,abc,true))
     #+end_src

   - ~mapN~:
     #+begin_src scala
       case class Cat(name: String, born: Int, color: String)

       (Option("Garfield"),
        Option(1978),
        Option("Orange & black")).mapN(Cat.apply)
       // res9: Option[Cat] = Some(Cat(Garfield,1978,Orange & black))
     #+end_src
     + It's nice to see that this syntax is type checked!!!
       You must guarantee _RIGHT ARITY_, or there will be *compile time error*
       (_GOOOOOOD!!!_).

     + Internally ~mapN~ uses the ~Semigroupal~ to extract the values from the
       ~Option~ and the ~Functor~ to apply the values to the function.

*** DONE 6.2.1 Fancy Functors and Apply Syntax - 148 - =TODO= =???=
    CLOSED: [2020-02-20 Thu 14:50]
    /Apply syntax/ also has ~contramapN~ and ~imapN~ /methods/ that accept
    /Contravariant functors/ and /Invariant functors/.

    - WHY??????????????
      =TODO= =IMPORTANT= =TODO=
      Why do we combine ~Monoid~ with ~Invariant~, rather than others?

    - For example, we can combine ~Monoid~'s using ~Invariant~:
      #+begin_src scala
        import cats.Monoid
        import cats.instances.int._ // for Monoid
        import cats.instances.invariant._ // for Semigroupal
        import cats.instances.list._ // for Monoid
        import cats.instances.string._ // for Monoid
        import cats.syntax.apply._ // for imapN

        case class Cat(
          name: String,
          yearOfBirth: Int,
          favoriteFoods: List[String]
        )

        val tupleToCat: (String, Int, List[String]) => Cat =
          Cat.apply _

        val catToTuple: Cat => (String, Int, List[String]) =
          cat => (cat.name, cat.yearOfBirth, cat.favoriteFoods)

        implicit val catMonoid: Monoid[Cat] = (
          Monoid[String],
          Monoid[Int],
          Monoid[List[String]]
        ).imapN(tupleToCat)(catToTuple)
      #+end_src

      ~Monoid~ allows us to create "empty" ~Cat~'s, and add ~Cat~'s together
      using the /syntax/ from Chapter 2:
      #+begin_src scala
        import cats.syntax.semigroup._ // for |+|

        val garfield = Cat("Garfield", 1978, List("Lasagne"))
        val heathcliff = Cat("Heathcliff", 1988, List("Junk Food"))

        garfield |+| heathcliff
        // res17: Cat = Cat(GarfieldHeathcliff,3966,List(Lasagne, Junk Food))
      #+end_src

** DONE 6.3 ~Semigroupal~ Applied to Different Types - 149
   CLOSED: [2020-02-20 Thu 15:43]
   ~Semigroupal~ doesn't always provide the behaviour we expect, particularly
   for types that also have instances of ~Monad~.

   We have seen the behaviour of the ~Semigroupal~ for ~Option~.
   Let's look at some examples for other types.

**** DONE ~Future~ - 149
     CLOSED: [2020-02-20 Thu 15:34]
     #+begin_src scala
       import cats.Semigroupal
       import cats.instances.future._ // for Semigroupal
       import scala.concurrent._
       import scala.concurrent.duration._
       import scala.concurrent.ExecutionContext.Implicits.global
       import scala.language.higherKinds

       val futurePair = Semigroupal[Future].product(Future("Hello"), Future(123))
       Await.result(futurePair, 1.second)
       // res1: (String, Int) = (Hello,123)
     #+end_src
     The two ~Future~'s start executing the moment we create them, so they are
     already calculating results by the time we call product.

     Use _apply syntax_ to zip fixed numbers of ~Future~'s:
     #+begin_src scala
       import cats.syntax.apply._ // for mapN

       case class Cat(
         name: String,
         yearOfBirth: Int,
         favoriteFoods: List[String]
       )

       val futureCat = (
         Future("Garfield"),
         Future(1978),
         Future(List("Lasagne"))
       ).mapN(Cat.apply)

       Await.result(futureCat, 1.second)
       // res4: Cat = Cat(Garfield,1978,List(Lasagne))
     #+end_src

**** DONE ~List~ - 150
     CLOSED: [2020-02-20 Thu 15:37]
     #+begin_src scala
       import cats.Semigroupal
       import cats.instances.list._ // for Semigroupal

       Semigroupal[List].product(List(1, 2), List(3, 4))
       // res5: List[(Int, Int)] = List((1,3), (1,4), (2,3), (2,4))
     #+end_src
     TODO
     This unexpected behavior (cartesion product, rather than simple zip) will
     be explained later.

**** DONE ~Either~ - 151
     CLOSED: [2020-02-20 Thu 15:43]
     #+begin_src scala
       import cats.instances.either._ // for Semigroupal

       type ErrorOr[A] = Either[Vector[String], A]

       Semigroupal[ErrorOr].product(
         Left(Vector("Error 1")),
         Left(Vector("Error 2"))
       )
       // res7: ErrorOr[(Nothing, Nothing)] = Left(Vector(Error 1))
     #+end_src
     We see the unexpected fail fast behavior!
     Same reason as we see in the last section (~List~).
     TODO Explain later.

*** DONE 6.3.1 Semigroupal Applied to Monads - 151
    CLOSED: [2020-02-20 Thu 15:29]
    The reason for the surprising results for ~List~ and ~Either~ is that they are
    both /monads/.
    - _To ensure CONSISTENT semantics_,
      *Cats' ~Monad~ (which extends ~Semigroupal~) provides a standard definition
      of ~product~ in terms of ~map~ and ~flatMap~.*

      This gives what we might think of as unexpected and less useful behaviour
      for a number of data types. _The consistency of semantics is important for
      higher level abstractions_, but we don't know about those yet.

    - Even our results for ~Future~ are a trick of the light.
      Its ~product~ provides sequential ordering that origin from ~flatMap~:
        The _parallel execution_ we observe occurs because our constituent
      ~Future~'s start running before we call ~product~!!!
      =from Jian=
      this means the _parallel execution_ is still there, but nothing related
      to ~flatMap~ or ~product~, who only do the combination after _parallel
      execution_.

**** DONE 6.3.1.1 Exercise: The Product of Monads - 149
     CLOSED: [2020-02-20 Thu 15:07]
     #+begin_src scala
       import cats.Monad

       import cats.syntax.flatMap._  // for flatMap
       import cats.syntax.functor._  // for map

       def product[M[_]: Monad, A, B](x: M[A], y: M[B]): M[(A, B)] =
         for {
           xv <- x
           yv <- y
         } yield (xv, yv)
     #+end_src

** TODO 6.4 ~Parallel~ - 153
** DONE 6.5 ~Apply~ and ~Applicative~ - 156
   CLOSED: [2020-02-21 Fri 10:36]
   /Semigroupals/ are NOT mentioned FREQUENTLY in the wider functional
   programming literature.
     They provide a _subset_ of the functionality of a related /type class/
   called an /applicative functor/ ("applicative" for short).

   - ~Semigroupal~ and ~Applicative~ _effectively provide ALTERNATIVE *encodings*
     of the same notion of *joining contexts*._

   - Both ~Semigroupal~ and ~Applicative~ encodings are introduced in the same
     2008 paper by Conor McBride and Ross Paterson.
     + _footnote 2_: /Semigroupal/ is referred to as "monoidal" in the paper

   - Cats models /applicatives/ using _TWO_ /type classes/: =IMPORTANT=
     1. ~cats.Apply~, extends ~Semigroupal~ and ~Functor~ and adds an ~ap~ /method/
        that applies a parameter to a function within a context.

     2. ~cats.Applicative~, extends ~Apply~, adds the ~pure~ /method/ introduced
        in Chapter 4.

   - Here's a simplified definition in code:
     #+begin_src scala
       trait Apply[F[_]] extends Semigroupal[F] with Functor[F] {
         def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]

         def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
           ap(map(fa)(a => (b: B) => (a, b)))(fb)
       }

       trait Applicative[F[_]] extends Apply[F] {
         def pure[A](a: A): F[A]
     #+end_src

   - Don't worry too much about the implementation of /product/!
     It's difficult to read and the details aren't particuarly important.

     The main point is that there is a _tight relationship between_ ~product~,
     ~ap~, and ~map~
     that
     allows _any one of them to be defined in terms of the other two_.
     TODO TODO TODO _TRY!!!_

   - ~Applicative~ also introduces the ~pure~ method.
       This is the ~pure~ we saw in ~Monad~, who extends ~Applicative~.
     It constructs a new _applicative instance_ from an unwrapped value.

     In this sense,
     ~Applicative~ is related to ~Apply~ as ~Monoid~ is related to ~Semigroup~.

*** DONE 6.5.1 The Hierarchy of Sequencing Type Classes - 157
    CLOSED: [2020-02-21 Fri 10:36]
    There is a whole family of /type classes/ that concern themselves with
    *sequencing* computations _in DIFFERENT ways_.

    - Figure 6.1: ~Monad~ type class hierarchy
      ~Semigroupal~ (~product~)  ~Functor~ (~map~)
                     \            /
                      \          /
                      ~Apply~ (~ap~)
                       /        \
                      /          \
      ~Applicative~ (~pure~)   ~FlatMap~ (~map~)
                      \          /
                       \        /
                         ~Monad~

    - EACH /type class/ in the hierarchy represents a particular set of sequencing
      semantics, introduces a set of /characteristic methods/, and *defines the
      functionality of its supertypes in terms of them*:
      + every /apply/ is a /functor/;
        ~Apply~
        * _defines_
          - ~ap~
          - (override) ~product~ _in terms of_ and ~map~
        * _inherits_ ~map~ (from ~Functor~)

      + every /applicative/ is a /semigroupal/;
        ~Applicative~
        * _defines_
          - ~pure~
          - (_override_) ~ap~ TODO _???What's the diff between this and /apply/'s???_

        * _inherits_ standard definitions of
          - ~product~ (from ~Semigroupal~)
          - ~map~ (from ~Functor~).

      + every /monad/ is an /applicative/;
        ~Monad~
        * _defines_
          - ~flatMap~
          - (override) ~product~, ~ap~, and ~map~, _in terms of_ ~pure~ and ~flatMap~;
            =from Jian= The only one that ~Monad~ does _NOT override_ is ~pure~.
        * _inherits_ ~pure~ (from ~Applicative~)

    - Assume there is a /monad/ ~Foo~ and a /applicative functor/ ~Bar~.
      + Q :: What can we say about them without knowing more about their implementation?
      + A :: Since ~Monad~ is a subtype of ~Applicative~, we know more about ~Foo~.
             ~Foo~ can guarantee more properties, while ~Bar~, who has fewer
             laws, may have a wider range of behaviours.
               _This is a classic trade-off of power (in the mathematical sense)
             versus constraint._

    - If you want to _impose a strict sequencing_ on the computations, ~Monad~ is good.
      If you want to avoid this, ~Semigroupal~ and ~Applicative~ can be a good choice.

** DONE 6.6 Summary - 159
   CLOSED: [2020-02-21 Fri 10:42]

* DONE 7 ~Foldable~ and ~Traverse~ - 161
  CLOSED: [2020-02-22 Sat 00:56]
  _TWO_ /type classes/ that capture *iteration over collecons*:
  - ~Foldable~ abstracts the familiar ~foldLeft~ and ~foldRight~ operations;

  - ~Traverse~ is a higher-level abstraction that uses ~Applicative~'s to *iterate*
    _with LESS pain than folding_. TODO

  We'll start by looking at ~Foldable~, and then _examine cases where folding
  becomes complex and ~Traverse~ becomes convenient._ TODO =IMPORTANT=

** DONE 7.1 ~Foldable~ - 161
   CLOSED: [2020-02-21 Fri 15:08]
   - The ~Foldable~ /type class/ captures the ~foldLeft~ and ~foldRight~ /methods/
     we're used to in sequences like ~List~'s, ~Vector~'s, and ~Stream~'s.

   - Using ~Foldable~,
     + we can write /generic folds/ that work with a variety of /sequence types/.

     + We can also
       _invent_ new sequences
       and
       _plug_ them _into_ our code.

   - ~Foldable~ gives us greate use cases for ~Monoid~'s and the ~Eval~ /monad/.
     TODO =???=

*** DONE 7.1.1 Folds and Folding - 162
    CLOSED: [2020-02-21 Fri 10:52]
    - Depending on the operation we're performing, the order in which we fold may
      be important. Thus there are _TWO_ standard variants of /fold/:
      + ~foldLeft~ traverses from "left" to "right" (start to finish)
      + ~foldRight~ traverses from "right" to "left" (finish to start)

    - ~foldLeft~ and ~foldRight~ are equivalent if our binary operation is
      /associative/.

*** DONE 7.1.2 Exercise: Reflecting on Folds - 163
    CLOSED: [2020-02-21 Fri 10:52]
    Try using ~foldLeft~ and ~foldRight~ with _empty lists_ as accumulator and
    ~::~ as the binary operator. See the result.
    #+begin_src scala
      val list: List[Int] = List(1, 2, 3)

      list.foldLeft(List.empty[Int]) {
        (acc, e) => e :: acc
      }
      // List(3, 2, 1)

      list.foldRight(List.empty[Int]) {
        (e, acc) => e :: acc
      }
      // List(1, 2, 3)
    #+end_src

*** DONE 7.1.3 Exercise: Scaf-fold-ing Other Methods - 163
    CLOSED: [2020-02-21 Fri 10:57]
    Implement ~List~'s ~map~, ~flatMap~, ~filter~, and ~sum~ /methods/ in terms
    of ~foldRight~:
    #+begin_src scala
      def map[A, B](list: List[A])(f: A => B): List[B] =
        list.foldRight(List.empty[B]){ (e, acc) =>
          f(e) :: acc
        }

      def flatMap[A, B](list: List[A])(f: A => List[B]): List[B] =
        list.foldRight(List.empty[B]){ (e, acc) =>
          f(e) ::: acc
        }

      def filter[A](list: List[A])(p: A => Boolean): List[A] =
        list.foldRight(List.empty[A]){ (e, acc) =>
          if (p(e)) e :: acc else acc
        }

      def sum[A](list: List[A])(implicit m: Monoid[A]): A =
        list.foldRight(m.empty)(m.combine)
    #+end_src

*** DONE 7.1.4 Foldable in Cats - 163
    CLOSED: [2020-02-21 Fri 15:08]
    Cats' ~Foldable~ abstracts ~foldLeft~ and ~foldRight~ into a /type class/.
    - Instances of ~Foldable~
      1. _define_ these TWO /methods/

      2. _inherit_ a host of /derived methods/.

    - Cats provides out-of-the-box /instances/ of ~Foldable~ for a handful of
      Scala data types: ~List~, ~Vector~, ~Stream~, and ~Option~.

    - ~List~ with ~Foldable~:
      #+begin_src scala
        import cats.Foldable
        import cats.instance.list._  // for Foldable

        val ints = List(1, 2, 3)

        Foldable[List].foldLeft(ints, 0)(_ + _)
        // res1: Int = 6
      #+end_src

    - =from Jian=
      Suggestion to this book:
      Replace ~Stream~ (Deprecated) with ~LazyList~.

    - ~Option~ with ~Foldable~:
      #+begin_src scala
        import cats.Foldable
        import cats.instance.option._  // for Foldable

        val maybeInt = Option(123)

        Foldable[Option].foldLeft(maybeInt, 10)(_ * _)
        // res3: Int = 1230
      #+end_src

**** DONE 7.1.4.1 Folding Right - 168 - TODO =RE-READ=
     CLOSED: [2020-02-21 Fri 14:36]
     ~Foldable~ defines ~foldRight~ differently to ~foldLeft~, in terms of the
     ~Eval~ /monad/:
     #+begin_src scala
       def foldRight[A, B](fa: F[A], lb: Eval[B])
                    (f: (A, Eval[B]) => Eval[B]): Eval[B]
     #+end_src
     The ~Eval~ /monad/ can promise /stack safe/,

     - =from Jian= I think this sentence is *Misleading*!!!
       EVEN WHEN the collection's default definition of ~foldRight~ is NOT.

       =from Jian= Suggestion: delete!

     - Example:
       =from Jian= Replace ~Stream~ with other data types. Might not be
       ~LazyList~, I guess ~LazyList~ might have already done the right thing.
       =from Jian= =IMPORTANT= TODO TODO

       #+begin_src scala
         import cats.Eval
         import cats.Foldable
         import cats.instance.stream._  // for Foldable

         def bigData = (1 to 100000).toStream

         bigData.foldRight(0L)(_ + _)
         // java.lang.StackOverflowError ...


         val eval: Eval[Long] =
           Foldable[Stream].
             foldRight(bigData, Eval.now(0L)) { (num, eval) =>
               eval.map(_ + num)
             }

         eval.value
         // res7: Long = 5000050000
       #+end_src

     - *Stack Safety in the Standard Library*
       /Stack Safety/ is NOT typically an issue when using the standard library.

       The most commonly used collection types, such as ~List~ and ~Vector~,
       provide /stack safe/ implementations of ~foldRight~.

       We use ~Stream~ here is just because ~Stream~ is an exception.

**** DONE 7.1.4.2 Folding with Monoids - 170
     CLOSED: [2020-02-21 Fri 14:39]
     - ~Foldable~ provides us with a host of useful /methods/ defined on top of
       ~foldLeft~. Many of these are facsimilies of familiar methods from the
       standard library:
       + ~find~
       + ~exists~
       + ~forall~
       + ~toList~
       + ~isEmpty~
       + ~nonEmpty~, and so on.

     - In addition to these familiar methods, Cats provides two /methods/ that
       make use of ~Monoid~'s:
       + ~combineAll~ (and its alias ~fold~) combines all elements in the sequence
         using their ~Monoid~;
         #+begin_src scala
           import cats.instances.int._  // for Monoid

           Foldable[List].combineAll(List(1, 2, 3))
           // res12: Int = 6
         #+end_src

       + ~foldMap~ maps a user-supplied function over the sequence and combines
         the results using a ~Monoid~.
         #+begin_src scala
           import cats.instances.string._  // for Monoid

           Foldable[List].combineAll(List(1, 2, 3))(_.toString)
           // res12: Int = 123
         #+end_src

     - Finally, we can compose ~Foldable~'s to support deep traversal of nested
       sequences: TODO =IMPORTANT= details ??? TODO
       #+begin_src scala
         import cats.instance.vector._  // for Monoid

         val ints = List(Vector(1, 2, 3), Vector(4, 5, 6))

         (Foldable[List] compose Foldable[Vector]).combineAll(ints)
         // res15: Int = 21
       #+end_src

**** DONE 7.1.4.3 Syntax for Foldable - 171
     CLOSED: [2020-02-21 Fri 15:08]
     With syntax imported, the first argument to the /static method/ becomes
     the /receiver/ of the /method/ call:
     #+begin_src scala
       import cats.syntax.foldable._  // for combineAll and foldMap

       List(1, 2, 3).combineAll
       // res16: Int = 6

       List(1, 2, 3).foldMap(_.toString)
       // res17: String = 123
     #+end_src

     - *Explicits over Implicits*
       + Scala feature: Use the _explicit available_ on the /receiver/ if it exists.
         For example,
         * Use the ~foldLeft~ defined on ~List~:
           #+begin_src scala
             List(1, 2, 3).foldLeft(0)(_ + _)  // res18: Int = 6
           #+end_src

         * The following generic code will use ~Foldbale~:
           #+begin_src scala
             import scala.language.higherKinds

             def sum[F[_]: Foldable](values: F[Int]): Int =
               values.foldLeft(0)(_ + _)
             // sum: [F[_]](values: F[Int])(implicit evidence$1: cats.Foldable[F])Int
           #+end_src

       + If we need a *stack-safe implementation* of ~foldRight~, using ~Eval~ as
         the accumulator is enough to force the compiler to select the method
         from Cats.

** DONE 7.2 ~Traverse~ - 168 - =TODO= 7.2.2 =RE-READ=
   CLOSED: [2020-02-22 Sat 00:56]
   ~foldLeft~ and ~foldRight~ are flexible iteration methods but they require us
   to do a lot of work to *define _accumulators_ and _combinator functions_.*
     The ~Traverse~ /type class/ is a higher level tool that leverages
   ~Applicative~'s to provide a more convenient, more lawful, pattern for
   iteration.

*** DONE 7.2.1 Traversing with ~Future~'s - 168
    CLOSED: [2020-02-21 Fri 15:17]
    - Question:
      A list of server hostnames and method to poll a host for its uptime:
      #+begin_src scala
        import scala.concurrent._
        import scala.concurrent.duration._
        import scala.concurrent.ExecutionContext.Implicits.global

        val hostnames = List(
          "alpha.example.com",
          "beta.example.com",
          "gamma.demo.com"
        )

        def getUptime(hostname: String): Future[Int] =
          Future(hostname.length * 60)  // just for demonstration
      #+end_src

    - We can't simply map over ~hostnames~ because the result -- a ~List[Future[Int]]~
      -- would contain more than one ~Future~.
        We need to reduce the results to a single ~Future~ to get something we can
      block on. Let's start by doing this manually using a ~fold~:
      #+begin_src scala
        val allUptimes: Future[List[Int]] =
          hostnames.foldLeft(Future(List.empty[Int])) { (accum, host) =>
            val uptime = getUptime(host)
            for {
              acc <- accum
              ut  <- uptime
            } yield acc :+ ut
          }

        Await.result(allUptimes, 1.second)
        //res2: List[Int] = List(1020, 960, 840)
      #+end_src

    - Expected when simplified:
      #+begin_src scala
        val allUptimes: Future[List[Int]] =
          Future.traverse(hostname)(getUptime)

        Await.result(allUptimes, 1.second)
        // res3: List[Int] = List(1020, 960, 840)
      #+end_src
      + How does this implementated?
        If we ignore distractions like ~CanBuildFrom~ and ~ExecutionContext~,
        #+begin_src scala
          def traverse[A, B](values: List[A])
                            (func: A => Future[B]): Future[List[B]] =
            values.foldLeft(Future(List.empty[A])) { (accum, host) =>
              val item = func(host)
              for {
                acc <- accum
                e   <- item
              } yield acc :+ e
            }
        #+end_src

      + This is essentially the same as our example code above.
        It gives us a clean high-level interface to do what we want:
        * start with a ~List[A]~
        * provide a function ~A => Future[B]~
        * end up with a ~Future[List[B]]~

    - There is also a ~Future.sequence~ method defined as
      #+begin_src scala
        object Future {
          def sequence[B](futures: List[Future[B]]): Future[List[B]] =
            traverse(futures)(identity)

          // etc...
        }
      #+end_src
      + start with a ~List[Future[A]]~
      + end up with a ~Future[List[A]]~

    - The simplified examples above only work with ~List~'s, but the real
      ~Future.traverse~ and ~Future.sequence~ work with *any* standard Scala
      collection.

    - Cats' ~Traverse~ /type class/ generalises these patterns to work with any
      type of ~Applicative~: ~Future~, ~Option~, ~Validated~, and so on.

    - We'll approach ~Traverse~ in the next sections in two steps:
      1. We'll generalise over the ~Applicative~, then we'll generalise over the
         /sequence type/.

      2. We'll end up with an extremely valuable tool that trivialises many
         operations involving sequences and other data types.

*** DONE 7.2.2 Traversing with ~Applicative~'s - 171 - =TODO=
    CLOSED: [2020-02-21 Fri 15:51]
    - We'll see that we can _rewrite_ ~traverse~ in terms of an ~Applicative~.
      Our accumulator from the example above:
      ~Future(List.empty[Int])~ is equivalent to ~Applicative.pure~:
      #+begin_src scala
        import cats.Applicative
        import cats.instances.future._    // for Applicative
        import cats.syntax.applicative._  // for pure

        List.empty[Int].pure[Future]

        def oldCombine(
          accum: Future[List[Int]],
          host : String
        ): Future[List[Int]] = {
          val uptime = getUptime(host)
          for {
            acc <- accum
            ut  <- uptime
          } yield acc :+ ut
        }
      #+end_src
      is now equivalent to ~Semigroupal.combine~:
      #+begin_src scala
        import cats.syntax.apply._ // for mapN

        // Combining accumulator and hostname using an Applicative:
        def newCombine(accum: Future[List[Int]],
                       host: String): Future[List[Int]] =
          (accum, getUptime(host)).mapN(_ :+ _)
      #+end_src

    - By substituting these snippets back into the definition of ~traverse~ we can
      generalise it to to work with any ~Applicative~:
      #+begin_src scala
        import scala.language.higherKinds

        def listTraverse[F[_]: Applicative, A, B](list: List[A])
                                                 (func: A => F[B]): F[List[B]] =
          list.foldLeft(List.empty[B].pure[F]) { (accum, item) =>
            (accum, func(item)).mapN(_ :+ _)
          }

        def listSequence[F[_]: Applicative, B](list: List[F[B]]): F[List[B]] =
          listTraverse(list)(identity)
      #+end_src
      + Use ~listTraverse~ to re-implement our uptime example:
        #+begin_src scala
          val totalUptime = listTraverse(hostname)(getUptime)
          Await.result(totalUptime, 1.second)
          // res11: List[Int] = List(1020, 960, 840)
        #+end_src

**** DONE 7.2.2.1 Exercise: Traversing with ~Vector~'s - 177
     CLOSED: [2019-07-14 Sun 13:58]
     #+begin_src scala
       import cats.instances.vector._  // for Applicative

       listSequence(List(Vector(1, 2), Vector(3, 4)))
     #+end_src
     - Solution:
       ~Vector(List(1, 3), List(1, 4), List(2, 3), List(2, 4))~

**** DONE 7.2.2.2 Exercise: Traversing with ~Option~'s - 177
     CLOSED: [2020-02-21 Fri 15:48]
     #+begin_src scala
       import cats.instances.option._  // for Applicative

       def process(inputs: List[Int]) =
         listTraverse(inputs)(n => if (n % 2 == 0) Some(n) else None)
     #+end_src
     - What is the _return type_ of this method?
       ~Option[List[Int]]~

     - What does it produce for the following inputs?
       #+begin_src scala
         process(List(2, 4, 6))
         // Some(List(2, 4, 6))

         process(List(1, 2, 3))
         // None
       #+end_src

**** DONE 7.2.2.3 Exercise: Traversing with ~Validated~ - 177 - TODO -WHY
     CLOSED: [2020-02-21 Fri 15:51]
     #+begin_src scala
       import cats.data.Validated
       import cats.instances.list._ // for Monoid

       type ErrorsOr[A] = Validated[List[String], A]

       def process(inputs: List[Int]): ErrorsOr[List[Int]] =
         listTraverse(inputs) { n =>
           n % 2 match {
             case 0 => Validated.valid(n)
             case _ => Validated.invalid(List(s"$n is not even"))
           }
         }
     #+end_src

*** DONE 7.2.3 ~Traverse~ in Cats - 174
    CLOSED: [2020-02-22 Sat 00:56]
    Generalise over differnt sequence types using a /type class/, which brings us
    to Cats' ~Traverse~. Here's the abbreviated definition:
    #+begin_src scala
      package cats

      trait Traverse[F[_]] {
        def traverse[G[_]: Applicative, A, B]
                    (inputs: F[A])(func: A => G[B]): G[F[B]]

        def sequence[G[_]: Applicative, A]
                    (inputs: F[G[A]]): G[F[A]] =
          traverse(inputs)(identity)
      }
    #+end_src

    - Cats provides instances of ~Traverse~ for ~List~, ~Vector~, ~Stream~, ~Option~,
      ~Either~, and a variety of other types.
        We can _summon instances_ as usual using ~Traverse.apply~ and use ~traverse~
      and ~sequence~ /methods/ as described in the previous section. Or use the
      syntax ~cats.syntax.traverse~

** DONE 7.3 Summary - 175
   CLOSED: [2020-02-22 Sat 00:56]

* Part II. Case Studies - 177
* DONE 8 Case Study: Testing Asynchronous Code - 179
  CLOSED: [2020-02-24 Mon 09:56]
  Simplify unit tests for asynchronous code
  by making them synchronous.

  - XXX TODO
    #+begin_src scala
      import scala.concurrent.Future

      trait UptimeClient {
        def getUptime(hostname: String): Future[Int]
      }
    #+end_src

  - XXX TODO
    #+begin_src scala
      import cats.instances.future._  // for Applicative
      import cats.instances.list._    // for Traverse
      import cats.syntax.traverse._   // for traverse

      import scala.concurrent.ExecutionContext.Implicits.global

      class UptimeService(client: UptimeClient) {
        def getTotalUptime(hostname: List[String]): Future[Int] =
          hostname.traverse(client.getUptime).map(_.sum)
      }
    #+end_src

** TODO 8.1 Abstracting over Type Constructors - 181
** TODO 8.2 Abstracting over Monads - 182
** TODO 8.3 Summary - 183

* DONE 9 Case Study: Map-Reduce - 185
  CLOSED: [2020-02-24 Mon 09:56]
** TODO 9.1 Parallelizing ~map~ and ~fold~ - 185
** TODO 9.2 Implementing ~foldMap~ - 187
** TODO 9.3 Parallelising ~foldMap~ - 189
*** TODO 9.3.1 ~Future~'s, Thread Pools, and ~ExecutionContext~'s - 189
*** TODO 9.3.2 Dividing Work - 192
*** TODO 9.3.3 Implementing ~parallelFoldMap~ - 193
*** TODO 9.3.4 ~parallelFoldMap~ with more Cats - 193

** TODO 9.4 Summary - 194

* TODO 10 Case Study: Data Validation - 195
** TODO 10.1 Sketching the Library Structure - 196
*** TODO Providing error messages - 196
*** TODO Combine checks - 197
*** TODO Accumulating errors as we check - 198
*** TODO Transforming data as we check it - 198

** TODO 10.2 The Check Datatype - 199
** TODO 10.3 Basic Combinators - 200
** TODO 10.4 Transforming Data - 201
*** TODO 10.4.1 Predicates - 202
*** TODO 10.4.2 Checks - 204
*** TODO 10.4.3 Recap - 206

** TODO 10.5 Kleislis - 207
** TODO 10.6 Summary - 211

* TODO 11 Case Study: CRDTs - 213
** TODO 11.1 Eventual Consistency - 213
** TODO 11.2 The GCounter - 214
*** TODO 11.2.1 Simple Counters - 214
*** TODO 11.2.2 GCounters - 216
*** TODO 11.2.3 Exercise: GCounter Implementation - 217

** TODO 11.3 Generalisation - 218
*** TODO 11.3.1 Implementation - 220
*** TODO 11.3.2 Exercise: ~BoundedSemiLattice~ Instances - 221
*** TODO 11.3.3 Exercise: Generic GCounter - 221

** TODO 11.4 Abstracting GCounter to a Type Class - 221
** TODO 11.5 Abstracting a Key Value Store - 223
** TODO 11.6 Summary - 224

* Part III. Solutions to Exercises - 227
* TODO Appendix A Solutions for: Introduction - 229
** A.1 Printable Library - 229
** A.2 Printable Library Part 2 - 230
** A.3 Printable Library Part 3 - 231
** A.4 Cat ~Show~ - 232
** A.5 Equality, Liberty, and Felinity - 233

* TODO Appendix B Solutions for: ~Monoid~'s and ~Semigroup~'s - 235
** B.1 The Truth About Monoids - 235
** B.2 All Set for Monoids - 236
** B.3 Adding All The Things - 237
** B.4 Adding All The Things Part 2 - 238
** B.5 Adding All The Things Part 3 - 239

* TODO Appendix C Solutions for: ~Functor~'s - 241
** C.1 Branching out with Functors - 241
** C.2 Showing off with Contramap - 242
** C.3 Showing off with Contramap Part 2 - 243
** C.4 Transforma ve Thinking with imap - 244
** C.5 Transforma ve Thinking with imap Part 2 - 244
** C.6 Transforma ve Thinking with imap Part 3 - 244

* TODO Appendix D Solutions for: ~Monad~'s - 247
** D.1 Getting Func-y - 247
** D.2 Monadic Secret Identities - 248
** D.3 What is Best? - 249
** D.4 Abstracting - 250
** D.5 Safer Folding using Eval - 250
** D.6 Show Your Working - 251
** D.7 Hacking on Readers - 253
** D.8 Hacking on Readers Part 2 - 253
** D.9 Hacking on Readers Part 3 - 254
** D.10 Post-Order Calculator - 254
** D.11 Post-Order Calculator Part 2 - 255
** D.12 Post-Order Calculator Part 3 - 256
** D.13 Branching out Further with Monads - 256

* TODO Appendix E Solutions for: Monad Transformers - 261
** E.1 ~Monad~'s: Transform and Roll Out - 261
** E.2 ~Monad~'s: Transform and Roll Out Part 2 - 261
** E.3 ~Monad~'s: Transform and Roll Out Part 3 - 262
** E.4 ~Monad~'s: Transform and Roll Out Part 4 - 262

* TODO Appendix F Solutions for: ~Semigroupal~ and ~Applicative~ - 265
** F.1 The Product of Lists - 265
** F.2 Parallel List - 266

* TODO Appendix G Solutions for: ~Foldable~ and ~Traverse~ - 267
** G.1 Reflecting on Folds - 267
** G.2 Scaf-fold-ing Other Methods - 268
** G.3 Traversing with Vectors - 269
** G.4 Traversing with Vectors Part 2 - 270
** G.5 Traversing with Options - 270
** G.6 Traversing with Validated 271

* TODO Appendix H. Solutions for: Case Study: Testing Asynchronous Code - 273
** H.1 Abstracting over Type Constructors - 273
** H.2 Abstracting over Type Constructors Part 2 - 274
** H.3 Abstracting over Monads - 274
** H.4 Abstracting over Monads Part 2 - 275

* TODO Appendix I. Solutions for: Case Study: Map-Reduce - 277
** I.1 Implementing ~foldMap~ - 277
** I.2 Implementing ~foldMap~ Part 2 - 277
** I.3 Implementing ~parallelFoldMap~ - 278
** I.4 ~parallelFoldMap~ with more Cats - 280

* TODO Appendix J. Solutions for: Case Study: Data Validation - 283
** J.1 Basic Combinators - 283
** J.2 Basic Combinators Part 2 - 284
** J.3 Basic Combinators Part 3 - 284
** J.4 Basic Combinators Part 4 - 288
** J.5 Basic Combinators Part 5 - 289
** J.6 Checks - 290
** J.7 Checks Part 2 - 291
** J.8 Checks Part 3 - 292
** J.9 Recap - 292
** J.10 Recap Part 2 - 296
** J.11 Kleislis - 298
** J.12 Kleislis Part 2 - 298

* TODO Appendix K. Solutions for: Case Study: CRDTs - 303
** K.1 ~GCounter~ Implementation - 303
** K.2 ~BoundedSemiLattice~ Instances - 304
** K.3 Generic ~GCounter~ - 305
** K.4 Abstracting ~GCounter~ to a Type Class - 305
** K.5 Abstracting a Key Value Store - 306
