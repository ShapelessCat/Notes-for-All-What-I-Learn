#+TITLE: Haskell Programming from First Principles
#+SUBTITLE: Pure functional programming without fear or frustration
#+VERSION: 1.0RC4-screen
#+AUTHOR: Christopher Allen, Julie Moronuki
#+STARTUP: overview
#+STARTUP: entitiespretty

** Reader feedback - i
* DONE Contents - ii
  CLOSED: [2017-06-27 Tue 23:04]
** DONE Preface - xiv
   CLOSED: [2017-06-25 Sun 21:30]
*** DONE Chris's story - xiv
    CLOSED: [2017-06-25 Sun 21:20]
    - 15 years programming experience, 8 of them professionally.

    - Primarily work in /Common Lisp/, /Clojure/, and /Python/.

    - Start /Haskell/ 6 years ago. Notice the progress in programming language
      research from /Haskell/.

    - Show the author's experience in Clojure.
      Explain the advantage of the language of static typing -- /Haskll/, which
      has a good type system.

    - Using /Haskell/, the author is able to refactor without fear,
      BUT this does NOT come without learning new things.

    - As human, please save the limited thinking ability to get to reason about
      and write correct code, rather than being forced to think unnecessary
      things in your head, which is the things dynamic typing languages always
      let you do.

    - /Haskell/ is not a difficult language to use — quite the opposite.
      BUT /Haskell/ is difficult to teach effectively, and the ineffective
      pedagogy has made it hard for many people to learn.

    - I wrote this book because I had a hard time learning /Haskell/, and I don't
      want others to struggle the way I did.

** DONE Acknowledgements - xvi
   CLOSED: [2017-06-25 Sun 21:40]
** DONE Introduction - xix
   CLOSED: [2017-06-25 Sun 21:49]
** DONE Why This Book - xix
   CLOSED: [2017-06-25 Sun 21:58]
*** DONE OK, but I was just looking for a monad tutorial.. - xx
    CLOSED: [2017-06-25 Sun 21:58]
*** DONE But I've heard Haskell is hard.. - xxi
    CLOSED: [2017-06-25 Sun 21:58]
** DONE A few words to new programmers - xxii
   CLOSED: [2017-06-25 Sun 22:02]
   - The Freenode IRC channel =#haskell-beginners= has teachers who will be glad
     to help you, and they especially welcome questions regarding specific
     problems that you are trying to solve.

** DONE Haskevangelism - xxiii
   CLOSED: [2017-06-26 Mon 21:09]
** DONE What's in this book? - xxv
   CLOSED: [2017-06-27 Tue 23:04]
** DONE Best practices for examples and exercises - xxviii
   CLOSED: [2017-06-25 Sun 20:59]

* DONE 1 All You Need is Lambda - 1
  CLOSED: [2017-05-19 Fri 00:01]
** DONE 1.1 All You Need is Lambda - 2
   CLOSED: [2017-05-17 Wed 22:42]
   - /calculus/: a method of calculation or reasoning;

   - /lambda calculus/: one process for formalizing a method.

** DONE 1.2 What is functional programming? - 2
   CLOSED: [2017-05-17 Wed 22:51]
   - When we say the /purity/ of a functional programming language, we acutally
     say in which level its /referential transparency/ is.
       If we say a language is pure, we mean it has PERFECT
     /referential transparency/.

** DONE 1.3 What is a function? - 3
   CLOSED: [2017-05-18 Thu 14:50]
   - /domain/
   - /codomain/
   - /range/
** DONE 1.4 The structure of lambda expressions - 5
   CLOSED: [2017-05-18 Thu 15:17]
   - /lambda calculus/ has three basic components (/lambda terms/):
     + expressions :: refer to a superset of all those things:
       * a variable name
       * an abstraction
       * a combination of those things

     + variables :: here variables means those have no meaning or value;
                  they are just names for potential inputs to functions

     + abstractions :: functions
       * /head/
       * /body/

   - The variable named in the head is the /parameter/ and /binds/ all instances
     of that same variable in the body of the function.

*** Alpha equivalence - 6
    - /alpha equivalence/: a form of equivalence between lambda terms

** DONE 1.5 Beta reduction - 7
   CLOSED: [2017-05-17 Wed 22:36]
   - /beta reduction/: apply a function to an argument.
     =COMMENT= This reduction eliminates the head of the abstraction, since its
               only purpose was to bind a variable.

   - The process of /beta reduction/ _stops when_ there are either no more heads,
     or lambdas, left to apply or no more arguments to apply functions to.

*** Free varibales - 9
    - /free variables/: variables that are not named in the head.

    - /alpha equivalence/ does not apply to /free variables/.
      For example, ~\lambda{}x.xy~ and ~\lambda{}x.xz~ are not equivalent because ~z~ and ~y~
      might be different.

** DONE 1.6 Multiple arguments - 10
   CLOSED: [2017-05-18 Thu 16:04]
   - Each lambda can only bind one parameter and can only accept one argument.

   - Functions that require multiple arguments have multiple, nested heads.

   - /Curry/: discovered by Moses Schönfinkel in the 1920s. Re-discovered by
     Haskell Curry.

*** Intermission: Equivalence exercises - 13
** DONE 1.7 Evaluation is simplification - 14
   CLOSED: [2017-05-18 Thu 16:25]
   - There are multiple normal forms in lambda calculus.

   - We will concentrate /beta normal form/ here.

   - /beta reduction/: apply lambdas to arguments.

   - /beta normal form/: a form when you cannot /beta reduce/ (apply lambdas to
     arguments) the terms any further.

** DONE 1.8 Combinators - 14
   CLOSED: [2017-05-17 Wed 22:22]
   - /combinator/: a lambda term with no free variables.
     =comment= As the name suggests, serve only to combine the arguments they are given.
** DONE 1.9 Divergence - 15
   CLOSED: [2017-05-17 Wed 22:22]
   - NOT ALL reducible lambda terms reduce neatly to a /beta normal form/.

   - /divergence/: in this context it means that the reduction process never terminates or ends.

   - /omega divergence/: after some reduction steps, go back to the initial form.
** DONE 1.10 Summary - 16
   CLOSED: [2017-06-06 Tue 20:14]
** DONE 1.11 Chapter exercises - 17
   CLOSED: [2017-06-06 Tue 20:14]
** DONE 1.12 Answers - 19
   CLOSED: [2017-06-06 Tue 20:14]
** DONE 1.13 Definitions - 22
   CLOSED: [2017-06-06 Tue 20:15]
** TODO 1.14 Follow-up resources - 23
   1. 
   2. 
   3. 

* DONE 2 Hello, Haskell! - 24
  CLOSED: [2017-06-06 Tue 20:14]
** DONE 2.1 Hello, Haskell - 25
   CLOSED: [2017-05-19 Fri 20:46]
   INSTALLATION

   GHC version is between 7.8 and 8.0 is compatible with everything in this book
   (ver 0.12.0).
** DONE 2.2 Interacting with Haskell code - 25
   CLOSED: [2017-05-19 Fri 21:00]
*** Using the REPL - 25
    - ~:quit~ or ~:q~

    - ~Prelude~ is a library of standard functions.
      + It is loaded automatically by GHCi or Stack GHCi.

      + It can be turned off (=TODO= talk about this later).

      + There are alternative Preludes, which we won't use in this book. =TODO=

      + It is contained in Haskell's ~base~ package, which can be found
        https://www.stackage.org/package/base. When we mention "in base", we
        means in this ~base~ package.

*** GHCi commands - 27
    - ~:~ prefixed commands are GHCi features, and they are not Haskell code.

*** Working from source files - 27
    - Source files of Haskell use =.hs= as their file names extension.

    - ~::~ is a way to write down a /type signature/.

    - ~:load~

    - ~:module~ or ~:m~ can unload the file from GHCi, and help you go back to
      (switch to the ~Prelude~ scope) the ~Prelude>~ prompt.

** DONE 2.3 Understanding expressions - 29
   CLOSED: [2017-05-19 Fri 21:15]
   - Everything in Haskell is
     + an /expression/
       OR
     + a /declaration/

   - Expressions may be
     + values
     + combinations of values
     + functions applied to values

   - Expressions evaluate to a result (can be itself if a expression is a literal
     value).

   - We'll cover /declarations/ more later, =TODO=
     but it suffices to say for now that they are top-level bindings which
     allows us to name expressions.
     We can then use those names to refer to them multiple times without copying
     and pasting the expressions.

   - /Normal form/: the irreducible form (of a expression).

   - /redexes/: Reducible expressions =IMPORTANT=

   - Generally refer to the process of _FROM the initial form of a expression TO
     a /normal form/_ as /evaluation/ or /reduction/.

     People also often use some _IMPRECISE_ words like:
     "normalizing" or "executing" an expression.

** DONE 2.4 Functions - 30
   CLOSED: [2017-05-19 Fri 22:01]
   Haskell function is always /currying/.

*** Defining functions - 31
    - _Capitalization matters!_
      Variables must also begin with lowercase letters.

** DONE 2.5 Evaluation - 33
   CLOSED: [2017-05-19 Fri 22:31]
   - nonstrict evaluation or say "lazy evaluation".

   - /canonical form / normal form/

   - Haskell doesn't evaluate everything to /canonical or normal form/ by
     default.

     Instead, it only evaluates to /weak head normal form (WHNF)/ by default.

   - /weak head normal form (WHNF)/
     For example,
     ~(\f -> (1, 2 + f)) 2~ reduces to the following in /WHNF/ ~(1, 2 + 2)~.

*** Exercises: Comprehension Check - 35
    1. Use ~let~

    2. Write a function:
       #+BEGIN_SRC haskell
         areaCircle :: Fractional a => a -> a
         areaCircle r = 3.14 * (r * r)
       #+END_SRC

    3. Use ~pi~ in ~Prelude~:
       #+BEGIN_SRC haskell
         areaCircle :: Floating a => a -> a
         areaCircle r = pi * (r * r)
       #+END_SRC

** DONE 2.6 Infix operators - 35
   CLOSED: [2017-05-19 Fri 23:30]
   - ~id~

   - Operators are functions which can be used in infix style.
     _All_ operators are functions; _NOT all_ functions are operators.

   - Use functions in infix fashions:
     ~10 `div` 4~

   - Use infix operators in prefix fashions:
     ~(+) 100 100~

   - If the function name is alphanumeric, it is a prefix function by
     default, and not all prefix functions can be made infix.
     =TODO= =Which can which cannot???=

     _If the name is a symbol, it is infix by default_
     but can be made prefix by wrapping it in parentheses.

   - You cannot make a prefix function into an infix function using backticks,
     then wrap that in parentheses and make it into a prefix function.
     =WHY???=

*** Associativity and precedence - 37
    - ~:info~ or ~:i~ (this command can take more than one arguments):
      This command can tell you
      if what you test is 
      1. an infix operator
         OR
      2. a function that can be a infix operator when it is wrapped by backticks

      If it is, tell you its type info, associativity, precedence level (0 ~ 9).
      If it is not, tell you the type info only.

    - 
*** Exercises: Parentheses and Association - 39
    _EASY_
** DONE 2.7 Declaring values - 39
   CLOSED: [2017-06-06 Tue 20:14]
   - The order of declarations
     + In a source code file it doesn't matter
       because GHCi loads the entire file at once, so it knows all the values
       that have been defined.

     + When you enter them one by one into the REPL, the order does matter.

   - For example,
     #+BEGIN_SRC haskell
       -- This is legal
       x = 1
       y = 2
       k = x + y + z
       z = 3
     #+END_SRC
     In source file, binding order is not important.

     However, due to the property of closure, variables must be defined _before_
     the declaration of the closures include them.

   - _Module names are capitalized_,
     UNLIKE variable names, which mustn't be.

*** DONE Troubleshooting - 40
    CLOSED: [2017-05-20 Sat 17:10]
    - Indentation of Haskell code is significant.

    - _Reminder_: Use spaces, NOT tabs.

    - In source code files, indentation often replaces syntactic markers like
      curly brackets, semicolons, and parentheses.

      =FROM JIAN=: I'm curious how to do in the opposite way ,if it exists -- I
      don't think use the layout code as a part of syntax is good.

    - _Indentation can easily go wrong in a copy-and-paste job as well._

    - The basic rule of using indentation:
      + code that is part of an expression should be indented under the beginning
        of that expression, even when the beginning of the expression is not at
        the leftmost margin.

      + Furthermore, parts of the expression that are grouped should be indented
        to the same level.

    - Exapmles:
      + Example-1
        #+BEGIN_SRC haskell
          -- RIGHT
          let
            x = 3
            y = 4

          -- or

          let x = 3
              y = 4


          -- Wrong
          let x = 3
           y = 4

          -- or

          let
           x = 3
            y = 4
        #+END_SRC

      + Example-2
        #+BEGIN_SRC haskell
          -- RIGHT
          x = 10 * 5 + y

          x = 10
            * 5 + y

          x = 10
               * 5 + y

          -- WRONG
          x = 10
           * 5 + y

           x = 10 * 5 + y  -- NOT at the beginning column of the line
        #+END_SRC

      + Example-3
        + _WRONG_
          not starting a declaration at the beginning (left) column of the line.
          #+BEGIN_SRC haskell
            -- learn.hs
            module Learn where

             x = 10 * 5 + y
            myResult = x * 5
            y = 10
          #+END_SRC

        + _RIGHT_
          #+BEGIN_SRC haskell
            -- learn.hs
            module Learn where

            -- All indent in the same way
             x = 10 * 5 + y
             myResult = x * 5
             y = 10
          #+END_SRC

        + _BETTER_
          #+BEGIN_SRC haskell
             -- learn.hs
             module Learn where

             -- No indentation
             x = 10 * 5 + y
             myResult = x * 5
             y = 10
          
          #+END_SRC

*** DONE Exercises: Heal the sick - 46
    CLOSED: [2017-05-20 Sat 17:15]
    1. ~3 .14~ -> ~3.14~
    2. ~b~ -> ~x~
    3. Correct indentation
** DONE 2.8 Arithmetic functions in Haskell - 46
   CLOSED: [2017-05-20 Sat 20:36]
   - =TODO= ~div~, ~mod~, ~quot~, and ~rem~
     =TODO= =TODO=

   - Compare ~div~ and ~quot~
     #+BEGIN_SRC haskell
       -- -- rounds down
       -- Prelude> div 20 (-6)
       -- -4
       -- -- rounds toward zero
       -- Prelude> quot 20 (-6)
       -- -3
     #+END_SRC

   - =TODO=
     Also, rem and mod have slightly different use cases; we'll look at mod in a
     little more detail down below. We will cover (~/~) in more detail in a later
     chapter, as that will require some explanation of types and type classes.

*** TODO Laws for quotients and remainders - 47
    - footnote: =???=
*** TODO Using 'mod' - 49
    - x

*** DONE Negative numbers - 51
    CLOSED: [2017-05-20 Sat 20:37]
    Due to the interaction of parentheses, currying, and infix syntax,
    _negative numbers get SPECIAL TREATMENT in Haskell_.
    + Evaluate an isolated negative number in GHCi is simple:
      #+BEGIN_SRC haskell
        -- Prelude> -1000
        -- -1000
      #+END_SRC

    + Since ~+~ and ~-~ has the same precedence, ~1000 + -9~ can't work.
      Write it as ~1000 + (-9)~.

    + The negation of numbers in Haskell by the use of a _unary_ ~-~ is a form of
      /syntactic sugar/.
      ~-9~ is translated inside to ~negate 9~.

      _Fortunately, syntactic overloading like this isn't common in Haskell._

** DONE 2.9 Parenthesization - 53
   CLOSED: [2017-05-20 Sat 21:40]
   - ~(^) \colon{}\colon] (Num a, Integral b) => a -> b -> a~
     ~infixr 8 ^~

   - ~(*) \colon{}\colon{} Num a => a -> a -> a~
     ~infixl 7 *~

   - ~(+) \colon{}\colon{} Num a => a -> a -> a~
     ~infixl 6 +~

   - ~(-) \colon{}\colon{} Num a => a -> a -> a~
     ~infixl 6 -~

   - ~($) \colon\colon{} (a -> b) -> a -> b~
     ~infixr 0 $~

   - Since ~(*30) \colon\colon{} Num a => a -> a~,
     ~3 (*30)~ doesn't work and ~(*30) 3)~ works.

     You can't the pass the prefixed ~3~ in pattern 1 pass to the ~(*30)~
     operator after it.

*** Parenthesizing infix operators - 56
    - /sectioning/ allows you to pass around partially applied functions.
      For example, ~(+1)~

    - /sectioning/ generate a function after partially applied a function,
      which is always prefix _NEVER_ suffix.

    - If you use /sectioning/ with a function that is not commutative, the order
      matters.
      #+BEGIN_SRC haskell
        (1/) 2  -- 0.5
        (/1) 2  -- 2.0
      #+END_SRC

    - ~(-2) 1~ doesn't work, _which is different from the other operators_.
      This is because the ~-~ here function represents _negation_, not
      subtraction,
      when it's applied to a single argument, _GHCi does not know what to do_
      with that, and so it returns an error message.
      =TODO=
      #+BEGIN_SRC haskell
        (-2) 1
        -- <interactive>:26:1: error:
        --     • Non type-variable argument in the constraint: Num ((a -> a) -> t)
        --       (Use FlexibleContexts to permit this)
        --     • When checking the inferred type
        --         it :: forall t a. (Num ((a -> a) -> t), Num a) => t
      #+END_SRC

    - Use sectioning for subtraction, ~-~ must be the first argument (or use
      ~substract~):
      #+BEGIN_SRC haskell
        (1 -) 3  -- it works
        (- 1) 3  -- ERROR

        -- USE
        (substract 2) 3
      #+END_SRC

** DONE 2.10 ~let~ and ~where~ - 58
   CLOSED: [2017-05-20 Sat 22:21]
   - It takes some practice to get used to the appropriate times to use each
     (~let~ and ~where~),
     BUT _they are fundamentally different_:
     + ~let~ introduces an expression,
       so it can be used wherever you can have an expression,

     + BUT ~where~ is a declaration and is bound to a surrounding syntactic
       construct.
       =TODO=: What does "surrounding syntactic construct" mean???

   - When you use ~:load~ in GHCi, it will unload the previous loaded module
     (except ~Prelude~), and then load the new one that you want.

     This is a limitation from ~GHCi~.

*** Exercises: A head code - 59
    ~where~ is a declaration and is bound to a surrounding syntactic construct.

    =TODO=: it seems you can't put a declaration in the wrong example below,
            _BUT WHY???_

    - Worable Example
      #+BEGIN_SRC haskell
        -- This works in source file
        mult1 = x * y
          where x = 5
                y = 6
      #+END_SRC

    - Wrong Example
      #+BEGIN_SRC haskell
        -- This CANNOT work in source file
        x * y
          where x = 5
                y = 6
      #+END_SRC

** DONE 2.11 Chapter exercises - 61
   CLOSED: [2017-05-18 Thu 17:23]
*** DONE Parenthesization - 61
    CLOSED: [2017-05-18 Thu 17:23]
    1. ~2 + (2 * 3) - 1~
    2. ~(^) 10 $ (1 + 1)~ OR ~10 ^ (1 + 1)~
    3. ~(2 ^ 2) * (4 ^ 5) + 1~

*** DONE Equivalent expressions - 62
    CLOSED: [2017-05-18 Thu 17:23]
    1. \check
    2. \check
    3. ~363~ AND ~-363~
    4. Int AND Float
    5. ~28~ AND ~46~

*** DONE More fun with functions - 62
    CLOSED: [2017-05-18 Thu 17:23]

** DONE 2.12 Definitions - 64
   CLOSED: [2017-05-18 Thu 18:07]
   1. Terminology: /argument/ and /parameter/
      - They are often used interchangably, but they have distinction.

      - /parameter/ (or /formal parameter/): a value that will be passed to the
        function when the function is called.

        Thus, parameters are usually variables.

      - /argument/: an input value the function is applied to.
      =IMPORTANT= =TODO= =???=

   2. /expression/: a combination of symbols that conforms to syntactic rules and
      can be evaluated to some result.
      _In Haskell_, an expression is a _well-structured combination of_:
      - constants
      - variables
      - functions
      =IMPORTANT=

      We usually mean "reducible expression" when we use the term /expression/,
      though irreducible constants are technically expressions (we usually refer
      to those as /values/).

   3. /redex/: reducible expression

   4. /value/: an expression that cannot be reduced or evaluated any further.

   5. /function/:
      Functions can be DESCRIBED AS _a list of ordered pairs of their inputs and
      the resulting outputs_, like a mapping.

   6. /infix notation/

   7. /operators/: functions that are /infix/ _by default_.
      _In Haskell_, operators must use symbols and not alphanumeric characters.
      =IMPORTANT= =TODO= =???=

   8. /syntactic sugar/: a syntax that is not intrinsically necessary, but it
      often makes for more readable code than the alternatives.

** TODO 2.13 Follow-up resources - 65
*** TODO 1.Haskell wiki article on "Let vs. Where" - 65
    https://wiki.haskell.org/Let_vs._Where
    xxx
**** Advantages of ~let~
**** Advantages of ~where~
**** Lambda Lifting
**** Problems with where

*** TODO 2.How to desugar Haskell code by Gabriel Gonzalez - 65
**** ~if~
**** Multi-argument lambdas
**** Functions
**** Infix functions
**** Operators
**** Operator parameters
**** Operator sections
**** Pattern matching
**** Non-recursive ~let~ / ~where~
**** Top-level functions
**** Imports
**** Type-classes
**** Two-line ~do~ notation
**** One-line ~do~ notation
**** Multi-line ~do~ notation
**** ~let~ in ~do~ notation
**** ghci
**** List comprehensions
**** Numeric literals
**** IO
**** Conclusion

* DONE 3 Strings - 66
  CLOSED: [2017-05-19 Fri 20:12]
** DONE 3.1 [ =NEW= ] Printing strings - 67
** DONE 3.2 A first look at types - 67
   CLOSED: [2017-05-18 Thu 20:43]
   - ~:type~: A GHCi command used to check the type of a value, expression, or
     function.

   - The ~::~ symbol is read as "has the type".

   - /type signature/: a line of code that defines the types for a value,
     expression, or function.

   - ~String~ is a /type alias (type synonym)/ for _a list of_ ~Char~ (~[Char]~).

   - When we talk about lists in more detail later, we'll see why the square
     brackets are considered syntactic sugar; =TODO=

** DONE 3.3 Printing simple strings - 68
   CLOSED: [2017-05-19 Fri 00:52]
   - ~print~
     TYPE: ~print :: Show a => a -> IO ()~
     #+BEGIN_SRC haskell
       -- Prelude>
       print "hello world!"

       -- "hello world!"
       -- Prelude>
     #+END_SRC
     The qutation marks still around it.

   - ~putstrLn~ and ~putStr~
     TYPE: ~putStrLn :: String -> IO ()~
     TYPE: ~putStr :: String -> IO ()~
     #+BEGIN_SRC haskell
       -- Prelude>
       putStrLn "hello world!"

       -- hello world!
       -- Prelude>

       -- Prelude>
       putStr "hello world!"

       -- hello world!Prelude>
     #+END_SRC

   - In source file
     #+BEGIN_SRC haskell
       -- print1.hs
       module Print1 where

       main :: IO ()
       main = putStrLn "hello world!"
     #+END_SRC

     Run it:
     #+BEGIN_SRC haskell
       -- Prelude> :l print1.hs
       -- [1 of 1] Compiling Print1
       -- Ok, modules loaded: Print1.

       -- *Print1> main
       -- hello world!
       -- *Print1>
     #+END_SRC

   - GHCi prompt may have changed to reflect the name of the module loaded.
     Use ~:module~ or ~:m~ to _unload_ the module and return to ~Prelude~.

   - You can also set your prompt to something specific (fixed).
     #+BEGIN_SRC haskell
       -- Prelude> :set prompt "λ> "
       -- λ> :r
       -- O,, modules loaded: Print1.
       -- λ> main
       -- hello world!
       -- λ>
     #+END_SRC
     Set it permanently: change =/.ghci= file

   - ~main~ is the default action when you build an executable or run it in a REPL.

     It is _NOT_ a function but is often a series of instructions to execute,
     which can include applying functions and producing side-effects.

   - When building a project with /Stack/:
     + having a ~main~ executable in a ~Main.hs~ file is obligatory,

     + but you can have source files and load them in GHCi without necessarily
       having ~main~ block.

   - ~do~ notation: a special syntax that allows for sequencing actions.
     #+BEGIN_SRC haskell
       -- print2.hs
       module Print2 where

       main :: IO ()
       main = do
         putStrLn "Count to four for me:"
         putStr "one, two"
         putStr ", three, and"
         putStrLn " four!"
     #+END_SRC

     #+BEGIN_SRC haskell
       -- Prelude> :l print2.hs
       -- [1 of 1] Compiling Print2
       -- Ok, modules loaded: Print2.
       -- Prelude> main
       -- Count to four for me:
       -- one, two, three, and four!
       -- Prelude>
     #+END_SRC
     The ~do~ is actually a syntactic sugar. It often makes for more readable
     code than the de-sugared version.
     =TODO= Say more in Chapter 13 (Monad)

*** String concatenation - 71
    - ~++~:
      + Example: ~"hello" ++ " world!"~

    - ~concat~:
      + Example: ~concat [hello, " ", world]~

** DONE 3.4 Top-level versus local definitions - 73
   CLOSED: [2017-05-19 Fri 02:54]
   - Top-level declarations are
     _NOT nested_ within anything else (OUTERMOST), which means they are in scope
     throughout the whole module.

     It doesn't necessarily mean they are defined at the top of the file.

     When the compiler reads the file,
     it will see all the top-level declarations, no matter what order they
     come in the file
     (=TODO= _with some limitations_ which we'll see later).

   - Example:
     #+BEGIN_SRC haskell
       module TopOrLocal where

       topLevelFunction :: Integer -> Integer
       topLevelFunction x = x + woot + topLevelValue
         where woot :: Integer
               woot = 10

       topLevelValue :: Integer
       topLevelValue = 5
     #+END_SRC

     + The ~where~ and ~let~ clauses in Haskell _introduce_ /local bindings/ or
       declarations. The are definitely not visible outside.

   - /bind (or declare)/: give an expression a name.

     _This is not usually necessary for one-time use._

*** DONE Exercises: Scope - 74
    CLOSED: [2017-05-19 Fri 00:56]
    1. \check
    2. ~h~ is not in scope for function ~g~.
    3. ~r~ is not in scope for function ~area~.
    4. \check
** DONE 3.5 Types of concatenation functions - 75
   CLOSED: [2017-05-19 Fri 19:56]
   - When refer to an infix operator in a position that is not infix,
     _put parentheses around it_.

   - ~(++) :: [a] -> [a] -> [a]~

   - ~concat :: Foldable t => t [a] -> [a]~  
     + please understand ~Foldable t => t [a]~ as being ~[ [a] ]~.
       =TODO=: Explain later

*** DONE Exercises: Syntax errors - 77
    CLOSED: [2017-05-19 Fri 00:59]
    1. Error message: =<interactive>:1:1: error: parse error on input ‘++’=
    2. Error message: =<interactive>:2:2: error: parse error on input ‘<’=
    3. \check
** DONE 3.6 Concatenation and scoping - 77
   CLOSED: [2017-05-19 Fri 20:04]
   - ~:info~ or ~:i~
     #+BEGIN_SRC haskell
     -- Prelude> :i (++)
     -- (++) :: [a] -> [a] -> [a]  -- Defined in ‘GHC.Base’
     -- infixr 5 ++
     #+END_SRC

** DONE 3.7 More list functions - 80
   CLOSED: [2017-05-19 Fri 20:12]
   - ~:~ operator: called "cons," which is used to build a list.

   - ~head~, ~tail~, ~take~, ~drop~, and ~!!~

   - About these functions:
     + All these functions are standard ~Prelude~ functions

     + many of them are considered /unsafe/ -- they do not cover the case of an
       empty list as input.

       They just throw out an error message, or exception. This isn't ideal
       behavior, so the use of these functions is considered unwise for programs
       of any real size or complexity,
       =TODO= _talk out some better ways later_.

** DONE 3.8 Chapter exercises - 82
   CLOSED: [2017-05-19 Fri 18:42]
*** DONE Reading syntax - 82
    CLOSED: [2017-05-19 Fri 01:20]
    1. Decide if they are written correctly, and correct the wrong ones (easy).
       a) x
       b) x
       c) \check
       d) \check
       e) x
       f) \check
       g) x
       h) \check

    2. Pair the lines of code and their results
       a) -> d)
       b) -> c)
       c) -> e)
       d) -> a)
       e) -> b)

*** DONE Building functions - 83
    CLOSED: [2017-05-19 Fri 18:42]
    1. Write short codes to generate expected outputs from given inputs
       First, ~import Data.List.Split~
       a) ~"Curry is awesome" ++ "!"~
       b) ~drop 4 $ (head . splitOn " ") "Curry is awesome!"~
       c) ~last $ splitOn " " "Curry is awesome!"~

    2. Write 1 into a source file
       #+BEGIN_SRC haskell
         module OperateStrings where

         import Data.List.Split

         addSuffix :: String -> String -> String
         addSuffix str suffix = str ++ suffix

         firstWordLastCharString :: String -> String
         firstWordLastCharString str = drop lenForDrop firstWord
           where
             firstWord = head $ splitOn " " str
             lenForDrop = length firstWord - 1

         lastWord :: String -> String
         lastWord str = last $ splitOn " " str
       #+END_SRC

    3. Write a function to return the 
       #+BEGIN_SRC haskell
         thirdLetter :: String -> Char
         thirdLetter x = head $ drop 2 x
         -- Use `head :: [a] -> a` rather than `(take 1) :: [a] -> [a]`
       #+END_SRC

    4. Write a function to return the 
       #+BEGIN_SRC haskell
         letterIndex :: Int -> Char
         letterIndex x = "Curry is awesome!" !! x
       #+END_SRC

    5. Write a function to reverse ="Curry is awesome"=
       #+BEGIN_SRC haskell
         rvrs :: String -> String
         rvrs = (drop 9 str) ++ (take 4 $ drop 5 str) ++ (take 5 str)
           where str = "Curry is awesome"
       #+END_SRC

    6. Write 5 into a module
       #+BEGIN_SRC haskell
         module Reverse where

         rvrs :: String -> String
         rvrs x = thirdWd ++ middle ++ firstWd
           where
             firstWd = take 5 x
             middle = take 4 $ drop 5 x
             thirdWd = drop 9 x
       #+END_SRC

** DONE 3.9 Definitions - 85
   CLOSED: [2017-05-19 Fri 01:50]
   1. ~String~: a sequence of characters.
      In Haskell, a linked-list of ~Char~ values, aka ~[Char]~. 

   2. /type (datatype)/: a classification of values or data.

      _UNLIKE in other languages_,
      datatypes in Haskell _by default_ do NOT delimit the operations that can be
      performed on that data.
      =TODO= =???=

   3. /concatenation/: In Haskell,
      ~(++) :: [a] -> [a] -> [a]~.

   4. /scope/: _WHERE_ a variable referred to by name is _valid_.
      /visibility/: If a variable _isn't visible_ is _not in scope_.

   5. /local bindings/: bindings local to particular expressions.

      _The primary delineation_ here from /top level bindings/ is:
      that /local bindings/ _CANNOT be imported_ by other programs or modules.

   6. /top level bindings/: In Haskell, this means bindings that stand outside of
      any other declaration (outermost declarations).

      They can be made available to other modules
      + within this programms
      + to other programms

   7. /data structures/: a way of organizing data so that the data can be
      accessed
      + _conveniently_
      + _efficiently_

* DONE 4 Basic datatypes - 87
  CLOSED: [2017-06-14 Wed 03:53]
** DONE 4.1 Basic Datatypes - 88
   CLOSED: [2017-05-20 Sat 22:26]
   - Types play an important role in the _readability_, _safety_, and
     _maintainability_ of Haskell code.

   - In this chapter, we will
     + review types we have seen in previous chapters;

     + learn about datatypes, /type constructors/, and /data constructors/;

     + work with predefined datatypes;

     + learn more about /type signatures/ and a bit about /type classes/.

** DONE 4.2 What are types? - 88
   CLOSED: [2017-05-21 Sun 01:32]
** DONE 4.3 Anatomy of a data declaration - 88
   CLOSED: [2017-05-21 Sun 01:41]
   - /data declarations/: How datatypes are defined.

   - /type constructor/: The name of the type and is capitalized.

   - /data constructor/: the values that inhabit the type they are defined in.

   - Example of /data declaration/ to ~Bool~
     ~data Bool = False | True~
     1. Here /type constructor/ is ~Bool~

     2. Here /data constructors/ are ~False~ and ~True~

     3. Here ~|~ indicates a /sum type/ or /logical disjunction: "or"/.
        _Read_: ~Bool~ value is ~True~ or ~False~.

   - Try
     #+BEGIN_SRC haskell
       -- Prelude> :info Bool
       -- data Bool = False | True
     #+END_SRC

*** DONE Exercises: Mood Swing - 90
    CLOSED: [2017-05-21 Sun 01:41]
    - /pattern matching/

    - Given:
      #+BEGIN_SRC haskell
        data Mood = Blah | Woot deriving Show
      #+END_SRC

    - A: type constructors: ~Mood~
    - ~Blash~ / ~Woot~
    - ~changeMood :: Mood -> Mood~

** DONE 4.4 Numeric types - 91
   CLOSED: [2017-05-21 Sun 01:32]
   - /integral numbers/: Whole numbers. Two types:
     1. ~Int~: Has range.
     2. ~Integer~: support arbitrarily large/small numbers.

   - /Fractional/: Not integers. Four types:
     1. ~Float~: single-precision floating point number type.
        + floating point arithmetic violates some common assumptions and should
          only be used with great care.

        + Generally, floating point numbers should not be used at all in business
          applications.

     2. ~Double~: double-precision floating point number type.
        + It has twice as many bits with which to describe numbers as the ~Float~
          type.

     3. ~Rational~: A fractional number that represents a ratio of two integers.
        + Arbitrarily precise but no as efficient as ~Scientific~.

     4. ~Scientific~ (available in package =scientific=): A space-efficient and
        almost-arbitrary precision scientific number type.
        + They are represented using scientific notation. It stores
          * the coeffcient as an ~Integer~;
          * the exponent as an ~Int~.

        + It has limitation, but hitting that is quite unlikely.

   - These numeric datatypes all have instances of a /type class/ called ~Num~.

   - Type Classes are a way of adding functionality to types that is reusable
     across all the types that have instances of that type class.
     =TODO= =LATER=

   - The ~Num~ type class is what provides your standard ~(+)~, ~(-)~, and ~(*)~
     operators along with a few others.

   - Hypothetically we could represent Integer as a sum of three cases,
     + recursive constructors headed towards negative infinity,
     + zero, and
     + recursive constructors headed towards positive infinity.

     This representation would be _terribly inefficient_
    =TODO= =???= so there's some GHC magic sprinkled on it.

*** DONE Integral numbers - 93
    CLOSED: [2017-05-20 Sat 23:40]
*** DONE Integer - 93
    CLOSED: [2017-05-20 Sat 23:40]
*** DONE Why do we have ~Int~ - 94
    CLOSED: [2017-05-21 Sun 01:16]
    - The ~Int~ numeric type is an artifact of what computer hardware has
      supported natively over the years.

    - Most programs should use ~Integer~ and _NOT_ ~Int~,
      UNLESS the limitations of the type are understood and the additional
      performance makes a difference.

    - There are ~Int8~, ~Int16~, et al.

    - Example:
      #+BEGIN_SRC haskell
        -- Prelude> import GHC.Int
        -- Prelude> 127 :: Int8
        -- 127

        -- Prelude> 128 :: Int8
        -- <interactive>:11:1: Warning:
        --     Literal 128 is out of the Int8 range -128..127
        --     If you are trying to write a large negative literal,
        --     use NegativeLiterals
        -- -128

        -- Prelude> (127 + 1) :: Int8
        -- -128
      #+END_SRC

    - Here the 8 in ~Int8~ _represents how many bits_ the type uses to represent
      integral numbers.
        The representation used for the fixed-size ~Int~ types is
      /two's complement/.

    - Find out the min and max bounds of numeric types using ~maxBound~ and
      ~minBound~ from the ~Bounded~ type class.
      Here's an example using our ~Int8~ and ~Int16~ example:
      #+BEGIN_SRC haskell
        -- Prelude> import GHC.Int

        -- Prelude> :t minBound
        -- minBound :: Bounded a => a

        -- Prelude> :t maxBound
        -- maxBound :: Bounded a => a


        -- Prelude> minBound :: Int8
        -- -128

        -- Prelude> minBound :: Int16
        -- -32768

        -- Prelude> minBound :: Int32
        -- -2147483648

        -- Prelude> minBound :: Int64
        -- -9223372036854775808


        -- Prelude> maxBound :: Int8
        -- 127

        -- Prelude> maxBound :: Int16
        -- 32767

        -- Prelude> maxBound :: Int32
        -- 2147483647

        -- Prelude> maxBound :: Int64
        -- 9223372036854775807
      #+END_SRC

    - Find out if a type has an instance of ~Bounded~, or any other type class,
      by asking GHCi for the ~:info~ for that type.
      #+BEGIN_SRC haskell
        -- Prelude> :i Int
        -- data Int = GHC.Types.I# GHC.Prim.Int# 	-- Defined in ‘GHC.Types’
        -- instance Bounded Int -- Defined in ‘GHC.Enum’
        -- instance Enum Int -- Defined in ‘GHC.Enum’
        -- instance Eq Int -- Defined in ‘GHC.Classes’
        -- instance Integral Int -- Defined in ‘GHC.Real’
        -- instance Num Int -- Defined in ‘GHC.Num’
        -- instance Ord Int -- Defined in ‘GHC.Classes’
        -- instance Read Int -- Defined in ‘GHC.Read’
        -- instance Real Int -- Defined in ‘GHC.Real’
        -- instance Show Int -- Defined in ‘GHC.Show’
      #+END_SRC

*** TODO Word - 96
*** DONE Fractional numbers - 97
    CLOSED: [2017-05-21 Sun 01:32]
    - ~Float~, ~Double~, ~Rational~, and ~Scientific~.

    - ~(/) \colon{}\colon{} Fractional a => a -> a -> a~
      The notation ~Fractional a =>~ denotes a /type class constraint/.

      Read it as "the type variable ~a~ must implement the ~Fractional~
      type class."

    - ~Fractional~ is a type class that requires types to already have an instance
      of the ~Num~ type class.
        We describe this _relationship_ between type classes by saying that:
      ~Num~ is a /superclass/ of ~Fractional~.

** DONE 4.5 Comparing values - 98
   CLOSED: [2017-05-21 Sun 02:42]
   - ~==~ and ~/=~

   - Types
     #+BEGIN_SRC haskell
       Prelude> :t (==)
       (==) :: Eq a => a -> a -> Bool

       Prelude> :t (<)
       (<) :: Ord a => a -> a -> Bool
     #+END_SRC
     + ~Eq~ is a type class that includes everything that CAN BE _compared and
       determined to be equal in value_;

     + ~Ord~ is a type class that includes all things that CAN BE _ordered_.

   - /lexicographic ordering/

** DONE 4.6 Go on and Bool me - 101
   CLOSED: [2017-05-21 Sun 02:56]
   - ~&&~, ~||~, and ~not~
*** DONE Exercises: Find the mistakes - 103
    CLOSED: [2017-05-21 Sun 02:48]

*** DONE Conditionals with if-then-else - 104
    CLOSED: [2017-05-21 Sun 02:57]
    - ~if ... then ... else~

    - Example (look the ~where~ in the example):
      #+BEGIN_SRC haskell
        -- greetIfCool1.hs
        module GreetIfCool1 where

        greetIfCool :: String -> IO ()
        greetIfCool coolness =
          if cool
            then putStrLn "eyyyyy. What's shakin'?"
          else
            putStrLn "pshhhh."
          where cool = coolness == "downright frosty yo"
      #+END_SRC
** DONE 4.7 Tuples - 107
   CLOSED: [2017-06-14 Wed 03:53]
   - Use a tuple is actual use a single value of multiple values.

   - The two-tuple is expressed at both the /type level/ and /term level/ with
     the constructor ~(,)~. The datatype declaration looks like this:
     #+BEGIN_SRC haskell
     -- Prelude> :info (,)
     -- data (,) a b = (,) a b
     #+END_SRC
     + A /product type/ (a logical conjunction), not a /sum type/

     + ~fst \colon{}\colon{} (a, b) -> a~

     + ~snd \colon{}\colon{} (a, b) -> a~ 

     + Examples:
       #+BEGIN_SRC haskell
         (,) 8 10
         -- (8, 10)

         (,) 8 "Julie"
         -- (8, "Julie")

         (,) True 'c'
         -- (True, 'c')
       #+END_SRC

   - ~swap \colon{}\colon{} (a, b) -> (b, a)~ is from ~Data.Tuple~

   - It's generally _UNWISE_ to use tuples of an overly large size, both for
     + efficiency
     + sanity reasons.
     _Most tuples you see will be_ ~( , , , , )~ _(5-tuple) or smaller._

** DONE 4.8 Lists - 109
   CLOSED: [2017-05-23 Tue 02:35]
   - DONE

** DONE 4.9 Chapter Exercises - 111
   CLOSED: [2017-06-14 Wed 03:46]
   1. ~length :: Foldable t => t a -> Int~

   2. What are the results of the following expressions?
      a) 5
      b) 3
      c) 2
      d) 5

   3. ~6 / length [1, 2, 3]~ returns an error.
      REASON: _Here_ ~6~ is a ~Fractional a => a~, which is required by ~/~.
              However, the return type of ~length~ is ~Int~, which is NOT an
              instance of type class ~Fractional a~.
              (See =5.5 Polymorphism - Working around constraints=)

   4. Fix the broken code using a different division function/operator:
      replace ~/~ with ~`div`~ or ~`quot`~
      + ~div \colon{}\colon{} Integral a => a -> a -> a~.
      + ~div \colon{}\colon{} Integral a => a -> a -> a~.

   5. The type is ~Bool~, and the result is ~True~.

   6. The type is ~Bool~, and the result is ~False~.

   7. 1, 3, 4
      2 -- The elements in a list must have a consistent type.
      5 -- ~&&~ operates on ~Bool~ values, and ~9~ is NOT a ~Bool~ value.

   8. 
      #+BEGIN_SRC haskell
        isPalindrome :: (Eq a) => [a] -> Bool
        isPalindrome x =
          x == reverse x
      #+END_SRC

   9. 
      #+BEGIN_SRC haskell
      myAbs :: Integer -> Integer
      myAbs x = if x >= 0 then x else (-x)
      #+END_SRC

   10. 
       #+BEGIN_SRC haskell
       f :: (a, b) -> (c, d) -> ((b, d), (a, c))
       f (va, vb) (vc, vd) = ((vb, vd), (va, vc))
       #+END_SRC

*** TODO Correcting syntax - 113
    1. =???= =Query meaning?=
       #+BEGIN_SRC haskell
         plus1Length xs = length xs + 1
       #+END_SRC

    2. ~\x -> x~

    3. ~\(x:xs) -> x~

    4. ~f (a, b) = a~

*** DONE Match the function names to their types - 113
    CLOSED: [2017-05-23 Tue 03:19]
    1. c)
    2. b)
    3. a)
    4. d)

** DONE 4.10 Definitions - 114
   CLOSED: [2017-06-14 Wed 03:46]
   - /tuple/ :: an ordered grouping of values.

                It is used to express an
                _anonymous_ _product (a logical conjunction)_.
      
     _In Haskell_,
     + you _cannot_ have a tuple with only one element           =TOOD: WHY=
     + but here is a zero tuple called /unit/ or ~()~.

   - /type class/ :: A set of operations defined with respect to a polymorphic
                    type.
                      When a type is an instance of a type class, values of that
                    type can be used in the standard operations defined for that
                    type class.

   - /data constructors/ :: ...

   - /type constructors/ :: ...
        A guideline for differentiating the two kinds of constructors is that
        type constructors always
     + go to the left of the ~=~ in a data declaration.
     + show up after ~\colon{}\colon{}~

   - /data declarations/ :: ...

   - /type alias/ ::
                     For example,
     #+BEGIN_SRC haskell
       type Name = String
       -- creates a new type alias `Name` of the type `String`
       -- *not* a data delcration, just a type alias declaration
     #+END_SRC

   - /arity/ :: the number of arguments can be accepted.

                This notion is a little slippery in Haskell due to its functions
                have currying feature.

                =FROM JIAN= Choose a proper context to use this term as if Haskell
                function is not currying.

     This can be consider used to describe the property of a
     + function
     + (type / data) constructor

   - /polymorphism/ :: In Haskell it means being able to write code in terms of
                       values which may be one of several, or any, type.

                       Polymorphism in Haskell is either /parametric/ or
                       /constrained/.

** DONE 4.11 Names and variables - 116
   CLOSED: [2017-05-23 Tue 15:17]
*** DONE Names - 116
    CLOSED: [2017-05-23 Tue 15:17]
    - In Haskell there are seven categories of entities that have names:
      + functions
      + term-level variables
      + data constructors
      + type variables
      + type constructors
      + type classes
      + modules

    - /term-level/ :: where your values live and is the code that executes when
                      your program is running. It contains:
      + functions
      + term-level variables
      + data constructors

    - /type-level/ :: it is used during the static analysis & verification of
                      your program. It contains:
      + type variables
      + type constructors
      + type classes

    - For the purpose of organizing code into coherent groupings across different
      files, we have
      + modules.

*** DONE Conventions for variables - 117
    CLOSED: [2017-05-23 Tue 15:17]
    - type variable names:
      + ~a~, ~b~, ~c~, ...
      + ~a1~, ...

    - functions used as arguments: ~f~, ~g~, ~f'~, ~f1~, ...
      Name like ~f'~ indicates that it is

      + closely related to
        or
      + a helper function to

      function ~f~.

    - Arguments to funcitons are most often given names starting at ~x~ (and then
      ~y~, ~z~), again occasionally seen numbered as in ~x1~.

    - list: ~(x:xs)~

* DONE 5 Types - 119
  CLOSED: [2017-06-19 Mon 18:26]
** DONE 5.1 Types - 120
   CLOSED: [2017-05-23 Tue 17:46]
   - A dataytpe declaration defines
     + a type constructor
       and
     + data constructors.

   - Data constructors _are the values of a particular type_;
     they _are also functions_ that let us create data, or values, of a
     particular type, although it will take some time before the full import of
     this becomes clear.

** DONE 5.2 What are types for? - 120
   CLOSED: [2017-05-23 Tue 17:46]
   - Haskell is an implementation of a /pure lambda calculus/, in the sense that
     it isn't much more than syntactic sugar over a /typed lambda calculus/.

   - A typed lambda calculus called /System F/ is discovered in the 1970s.

     Haskell has improved on /System F/ in some key ways, such as:
     + by allowing general recursion
     + the Hindley-Milner system to permit type inference

   - In Haskell, where typing is /static/, typechecking occurs at compile time.

   - Good type systems can _also_
     + enable compiler optimizations
     + serve as documentation (that's why explicitly declare types is
       encouraged).

** DONE 5.3 How to read type signatures - 122
   CLOSED: [2017-05-23 Tue 16:59]
   - The compiler doesn't know which specific numeric type a value is
     until
     + the type is either declared
       or
     + the compiler is forced to infer a specific type based on the function.

   - For example, ~13~ can be a ~Integer~, but a ~Integer~ only allow us to use
     it in computations that take integers (and _NOT_, say, in fractional
     division).
     #+BEGIN_SRC haskell
     (13 :: Integer) / 4

     -- ERROR:
     -- No instance for (Fractional Integer) arising from a use of '/'
     #+END_SRC

   - For that reason, the compiler gives it the type with the broadest
     applicability (most polymorphic) and says it's a /constrained polymorphic/.

     For example, ~13~ with no given type info, its type will be derived
     (by the compiler) as ~Num a => a~.

*** DONE Understanding the function type - 123
    CLOSED: [2017-05-23 Tue 16:59]
    - ~(->)~: the type constructor for functions.
      It takes arguments and has _NO_ data constructors.
      #+BEGIN_SRC haskell
        -- Prelude> :inf (->)
        -- data (->) t1 t2 	-- Defined in ‘GHC.Prim’
        -- infixr 0 `(->)`
        -- instance Monad ((->) r) -- Defined in ‘GHC.Base’
        -- instance Functor ((->) r) -- Defined in ‘GHC.Base’
        -- instance Applicative ((->) a) -- Defined in ‘GHC.Base’
        -- instance Monoid b => Monoid (a -> b) -- Defined in ‘GHC.Base’
      #+END_SRC

*** DONE Type class-constrained type variables - 125
    CLOSED: [2017-05-23 Tue 16:59]
    - The compiler gives
      + the least specific and most general type
      it can.

    - Instead of limiting this function to a concrete type,
      we get a /type class-constrained polymorphic type variable/.

    - What we need to know here is that each type class offers a standard set of
      functions that can be used across several concrete types.

    - Type error messages constrast the /actual type/ with the /expected type/.

    - /actual type/: what we /provide / expect/

    - /expected type/: what the compiler expected.

*** DONE Exercises: Type matching - 127
    CLOSED: [2017-05-23 Tue 16:59]
    a) ~not \colon\colon{} Bool -> Bool~   c)
    b) ~length \colon\colon{} Foldable t => t a -> Int~   d)
    c) ~concat :: Foldable t => t [a] -> [a]~   b)
    d) ~head :: [a] -> a~   a)
    e) ~(<) :: Ord a => a -> a -> Bool~   e)

** DONE 5.4 Currying - 128
   CLOSED: [2017-06-19 Mon 18:26]
   - About /currying/:
     + /Named functions/ are /curried/ _by default_.

     + /Anonymous functions/ are /uncurried/ _by default_.

       =COMMENT=:
       Since this, it is obvious that multi-parameter anonymous functions can't
       be use with curry feature.

   - The way the type constructor for functions, ~(->)~, is defined makes
     currying the default in Haskell.
       This is guaranteed by its property:
     + an _infix_ operator
     + _right associative_.

   - Function application is /left associative/.

   - =TODO=: but the implicit associativity of the function type does not ...
     =From Jian=: DON'T understand!!!

   - Application is evaluation -- _the only way to evaluate (due to lazyness)_
     anything is by applying functions, and function application is
     _left associative_. 

*** DONE Partial application - 131
    CLOSED: [2017-05-23 Tue 19:28]
    - /partial application/

*** DONE Manual currying and uncurrying - 132
    CLOSED: [2017-05-23 Tue 23:19]

*** DONE Currying and uncurrying existing functions - 134
    CLOSED: [2017-05-23 Tue 23:19]

*** DONE Sectioning - 135
    CLOSED: [2017-05-24 Wed 00:07]
    - /sectioning/: partial application of infix operators.

    - The order is important for non-commutative functions.

    - With the help of _backticks_ you can convert a function to an infix
      operator, and then do a /sectioning/.
      #+BEGIN_SRC haskell
        -- Prelude> elem 9 [1..10]
        -- True

        -- Prelude> 9 `elem` [1..10]
        -- True

        -- Prelude> (`elem` [1..10])
        -- Prelude> c 9
        -- True
        -- Prelude> c 25
        -- False

        -- Prelude> (9 `elem`)  [1..10]
        -- True
      #+END_SRC

      With this technique create partial applied functions to the first and
      second argument _is equally convenient_:
      + ~(fstArg `fun`)~ 
      + ~(`fun` sndArg)~

      If you don't use this technique, no neat way to create a partial applied
      function with the second argument:
      ~(\fstArg -> fun fstArg sndArg)~

    - _Conclusion_: The /sectioning/ syntax exists to allow some freedom in which
      argument of a binary operator you apply the function to.

*** DONE Exercises: Type Arguments - 136
    CLOSED: [2017-05-24 Wed 10:39]
    Check the types of a partial applied function, which you haven't defined:
    #+BEGIN_SRC haskell
      -- Prelude> let f :: a -> a -> a -> a; f = undefined
      -- Prelude> let x :: Char; x = undefined
      -- Prelude> :t f x
      -- f x :: Char -> Char -> Char
    #+END_SRC

    1. a)

    2. d)

    3. d)

    4. c)

    5. a)

    6. e)

    7. d) =TODO= =???=
       ONE more exercise should be added BEFORE here:
       #+BEGIN_SRC haskell
         -- Prelude> :t kessel 1
         -- kessel 1 :: (Ord a, Num b, Num a) => b -> a
       #+END_SRC

    8. a) =TODO= =???=
    9. c)

** DONE 5.5 Polymorphism - 139
   CLOSED: [2017-05-24 Wed 17:28]
   - /polymorphic/: 
     + In programming, this is understood to be in contrast with /monomorphic/,
       "made of one form."

     + Etymology:
       * TIME :: This is a word of relatively recent provenance. It was invented in
               the early 19th century.

       * ROOT ::
         1. from the Greek words poly for "many" and morph for "form".
         2. The -ic suffix in polymorphic means “made of.”

         So, "polymorphic" means "made of many forms."

   - /polymorphic function/: its type signature has variables that can represent
     more than one type.

   - /Type signatures/ may have three kinds of types:
     + /concrete/
     + /constrained polymorphic (ad-hoc polymorphism)/
     + /parametrically polymorphic/

   - In Haskell, polymorphism divides into two categories:
     + /parametric polymorphism/ :: unconstrained by a type class, their final,
          concrete type could be anything.
            However,
       * To the compiler: unconstrained also means no attached information.
         No pre-knowledge, and less we can do.

       * To the programmer: the information about the types also can't help the
         programmers much.

     + /constrained polymorphism/ :: in Haskell this implemented with
          type classes.
            This increases constraints (applied type classes), but constraints
          also a kind of information, which increases what you can actually do
          with it by defining and bringing into scope a set of operations (comes
          from the type classes)
          ---- More constraints, More helper facilities.
          (=From Jian=: Edited by Jian)

   - By default,
     type variables are resolved at the left-most part of the type signature
     and
     are fixed once sufficient information to bind them to a concrete type is
     available.

   - A variable represents a set of possible values
     A type variable represents a set of possible types.

   - /Concrete types/ have even more flexibility in terms of computation.

     This is benified by the /additive nature/ of type classes.
       For example, an ~Int~ is only an ~Int~, but it can make use of the
     methods of the ~Num~ and ~Integral~ type classes because it has instances of
     both.

   - In sum,
     + if a variable could be anything, then there's little that can be done to
       it because it has no methods.

     + If it can be some types (say, a type that is an instance of Num), then it
       has some methods.

     + If it is a concrete type, you lose the type flexibility but, due to the
       additive nature of type class inheritance, gain more potential methods.

   - /Parametric polymorphism/ refers to _fully polymorphic (unconstrained by a
     type class) parameters_.

   - /Parametricity/: it implies that the behavior of a function with respect to
     the types of its (parametrically polymorphic) arguments is _uniform_. The
     behavior can not change just because it was applied to an argument of a
     different type.

*** DONE Exercises: Parametricity
    CLOSED: [2017-05-24 Wed 16:57]
    1. ...

    2. Solutions to ~a -> a -> a~:
       #+BEGIN_SRC haskell
         ifTrue :: a -> a -> a
         ifTrue x y = x

         ifFalse :: a -> a -> a
         ifFalse x y = y
       #+END_SRC

    3. Solutions to ~a -> b -> b~: =TODO= =RIGHT?=
       Same as the solutions of 2

*** DONE Polymorphic constants
    CLOSED: [2017-05-24 Wed 17:01]
*** DONE Working around constraints
    CLOSED: [2017-05-24 Wed 17:28]
    - ~fromIntegral \colon{}\colon{} (Num b, Integral a) => a -> b~
** DONE 5.6 Type inference - 144
   CLOSED: [2017-05-24 Wed 18:46]
   - The /type inference/ of Haskell is built on an extended version of the
     Damas-Hindley-Milner type system.

   - Haskell will infer the _most generally_ applicable (polymorphic) type that
     is still correct.

   - _Type variables have no meaning outside of the type signatures where they are
     bound._

*** DONE Exercises: Apply Yourself
    CLOSED: [2017-05-24 Wed 18:46]
** DONE 5.7 Asserting types for declarations - 147
   CLOSED: [2017-05-24 Wed 18:56]
   - Type can be assigned within a ~where~ clause:
     #+BEGIN_SRC haskell
       triple x = tripleItYo x
         where tripleItYo :: Integer -> Integer
               tripleItYo y = y * 3
     #+END_SRC
** DONE 5.8 Chapter Exercises - 149
   CLOSED: [2017-05-25 Thu 03:37]
*** DONE Multiple choice
    CLOSED: [2017-05-24 Wed 19:07]
    (Though answers of 3. and 4. seems not complete, they are acutally right:
     No constraints (type classes), we don't know what kind of operations can be
     applied to them! Thus, b) and c) are not only a choice of solution, but the
     only solutions, respectively.

    1. c)
    2. a)
    3. b)
    4. c)

*** DONE Determine the type
    CLOSED: [2017-05-25 Thu 02:27]
    /monomorphism restriction/ =TODO= =IMPORTANT= =LATER=
    + _For Now_ it means that top-level declarations by default will have a
      concrete type

    + Use the ~NoMonomorphismRestriction~ pragma to avoid
      /monomorphism restriction/. For example, =TODO=
      #+BEGIN_SRC haskell
        {-# LANGUAGE NoMonomorphismRestriction #-}

        module DetermineTheType where

        -- simple example
        example = 1

        -- With the `NoMonomorphismRestriction` pragma
        -- `example :: Num a => a`

        -- Without the `NoMonomorphismRestriction` pragma
        -- `example :: Integer`
      #+END_SRC
    
    1. Determin the return type.
       a) ~Num a => a~
       b) ~(Num a) => (a, [Char])~
       c) ~(Integer, [Char])~
       d) ~Bool~
       e) ~Int~
       f) ~Bool~

    2. ~Num a => a~

    3. ~Num a => a -> a~

    4. ~Fractional a => a~

    5. ~[Char]~

*** DONE Does it compile?
    CLOSED: [2017-05-24 Wed 19:16]
    1. ~bigNum~ is not a function, and it can't be applied to an argument
       (=10= here).

    2. RIGHT. The type of ~z~ is ~IO ()~, and its return value looks like a
       string in display.

    3. ~a~ is not used,
       ~b~ isn't a function that can be applied on an argument =10=,
       Since ~b 10~ is wrong, ~c~ line and the line after it are wrong.

    4. ~c~ is not declared (not in scope).

*** DONE Type variable or specific type constructor?
    CLOSED: [2017-05-25 Thu 02:37]
    =TODO= ANSWER KEY

    1. EXAMPLE

    2. 
       ~f :: zed -> Zed -> Blah~
       + constrained polymorphic: NONE
       + fully polymorphic: ~zed~
       + concrete: ~Zed~ and ~Blah~

    3. 
       ~f :: Enum b => a -> b -> C~
       + constrained polymorphic: ~b~ which is an ~Enum~ instance
       + fully polymorphic: ~a~
       + concrete: ~C~

    4. 
       ~f :: f -> g -> C~
       + constrained polymorphic: NONE
       + fully polymorphic: ~f~ and ~g~
       + concrete: ~C~

*** DONE Write a type signature
    CLOSED: [2017-05-25 Thu 02:42]
    #+BEGIN_SRC haskell
      -- 1
      functionH :: [a] -> a
      functionH (x:_) = x

      -- 2
      functionC :: (Ord a) => a -> a -> Bool
      functionC x y = if (x > y) then True else False

      -- 3
      functionS :: (a, b) -> b
      functionS (x, y) = y
    #+END_SRC
*** DONE Given a type, write the function
    CLOSED: [2017-05-25 Thu 02:58]
    #+BEGIN_SRC haskell
      -- 1
      i :: a -> a
      i = id

      -- 2
      c :: a -> b -> a
      c x y = x

      -- 3
      -- YES, with alpha equivalence they are the same thing.
      c'' :: b -> a -> b
      c'' x y = x

      -- 4
      c' :: a -> b -> b
      c' x y = y

      -- 5
      r :: [a] -> [a]
      r = tail
      -- r = reverse

      -- 6
      co :: (b -> c) -> (a -> b) -> a -> c
      co b2c a2b a = b2c $ a2b a

      -- 7
      a :: (a -> c) -> a -> a
      a _ x = x

      -- 8
      a' :: (a -> b) -> a -> b
      a' a2b a = a2b a
    #+END_SRC

*** DONE Fix it
    CLOSED: [2017-05-25 Thu 03:13]
    1. 
       #+BEGIN_SRC haskell
         module Sing where

         fstString :: [Char] -> [Char]
         fstString x = x ++ " in the rain"

         sndString :: [Char] -> [Char]
         sndString x = x ++ " over the rainbow"

         sing = if (x > y) then fstString x else sndString y
           where x = "Singin"
                 y = "Somewhere"
       #+END_SRC

    2. Change expression ~(x > y)~  to ~(x <= y)~

    3. 
       #+BEGIN_SRC haskell
         -- arith3broken.hs
         module Arith3Broken where

         main :: IO ()
         main = do
           print 1 + 2
           putStrLn "10"
           print (negate (-1))
           print 0 + blah
             where blah = negate 1
       #+END_SRC

*** DONE Type-Know-Do
    CLOSED: [2017-05-25 Thu 03:37]
    /Bottom/ and /undefined/ will be explained in more detail later.
    The contents of the terms are irrelevant here.
    =TODO= =LATER=

    1. ~h = g . f~

    2. ~e = w . q~

    3. ~xform (x, y) = (xz x, yz y)~

    4. ~munge x2y y2wz x = fst $ y2wz $ x2y x~

** DONE 5.9 Definitions - 159
   CLOSED: [2017-06-19 Mon 23:19]
   1. /polymorphism/: type variables which may refer to _more than one_ concrete
      type.
      - In Haskell, this will usually manifest as
        + /parametric/
          or
        + /ad-hoc/

      - By having a larger set of types, we intersect the commonalities of them
        all to produce a smaller set of correct terms.
        =MORE GENERAL, also MORE CONSTRAINTS=
          This makes it less likely we'll write an incorrect program and lets
        us reuse the code with other types. 

   2. /type inference/
      - There are, _in some cases_ (=TODO= what cases???), terms in Haskell which
        can be well-typed but which have no principal type. In those cases, an
        explicit type annotation must be added.

      - /principal type/ is the most generic type which still typechecks.
        Examples:
        #+BEGIN_SRC haskell
          -- Suppose all the given types below can work in a function in each case.

          -- #1
          a
          Num a => a
          Int
          -- The principal type here is the parametrically polymorphic `a`


          -- #2
          (Ord a, Num a) => a
          Integer
          -- The principal type is `(Ord a, Num a) => a`
        #+END_SRC

   3. /type variable/:
      - Type variables ordinarily will be equal to themselves throughout a type
        signature -- in one type signature, all the same name type variables must
        be equal.

   4. /type class/: A means of expressing faculties or interfaces that multiple
      datatypes may have in common.

   5. /parametricity/:
      Compare to the /ad-hoc polymorphism/, /parametric polymorphism/ apply
      _more constraints_ the function of a given type -- type variables, like
      ~a~ and ~b~, without any concrete information can tell the implementer how
      to _process_ a value of a given type (variable).

      For example,
      - _One choice_ case -- if you have a type siganture like ~id \colon{}\colon{} a -> a~ or
        ~const \colon{}\colon{} a -> b -> a~, and since you know you can't _process_ the passed
        in value you know you can only return the value of right type:
        * for ~id~, it's trival
        * for ~const~, the first argument (always ignore the second).

      - Now you have _two choices_: ~f \colon{}\colon{} a -> a -> a~

      - _Ignore_ the input and always return a fixed string:
        ~blahFunc \colon{}\colon{} b -> String~

      - _Fixed length_ list, and all of it elements have the same value:
        ~convList \colon{}\colon{} a -> [a]~

   6. /Ad-hoc polymorphism (sometimes called "constrained polymorphism")/
      Polymorphism with the help of type class.

   7. /module/: the unit of organization that the Haskell programming language
      uses to collect together _declarations of_
      - values
      - functions
      - data types
      - type classes and type class instances.

** TODO 5.10 Follow-up resources - 163
   =DOWNLOADED=
   1. 
   2. 




* DONE 6 Type classes - 164
  CLOSED: [2019-04-20 Sat 22:36]
** DONE 6.1 Type classes - 165
   CLOSED: [2017-05-25 Thu 22:25]
  Key points:
  - examine the type classes ~Eq~, ~Num~, ~Ord~, ~Enum~, and ~Show~;

  - learn about type-defaulting type classes and type class inheritance;

  - look at some common but often implicit functions that create side effects.
    TODO

** DONE 6.2 What are type classes?? - 165
   CLOSED: [2017-05-25 Thu 22:46]
   - /Type Classes/ and /types/, in a sense, opposites:
     + A declaration of a type defines how that type in particular is _created_.

     + A declaration of a type class defines how a set of types are _consumed_ or
       _used_ in computations.

   - As Philip Wadler put it,
     "The goal is to define a datatype by cases, where one can add new cases to
      the datatype and new functions over the datatype, without recompiling
      existing code, and while retaining static type safety (e.g., no casts)."
      =WHAT IS /static type safety/???=

   - Type Classes is like /interfaces/ to data that can work across multiple
     datatypes.

   - TODO 164

** DONE 6.3 Back to ~Bool~ - 166
   CLOSED: [2017-05-26 Fri 00:29]
   - When we ~:info Bool~ in GHCi, we get:
     #+BEGIN_SRC haskell
       data Bool = False | True
       instance Bounded Bool
       instance Enum Bool
       instance Eq Bool
       instance Ord Bool
       instance Read Bool
       instance Show Bool
     #+END_SRC
     1. instance ~Bounded Bool~ – ~Bounded~ for types that have
        * an upper bound
          and
        * a lower bound

     2. instance ~Enum Bool~ – ~Enum~ for things that can be enumerated

     3. instance ~Eq Bool~ – ~Eq~ for things that can be tested for equality

     4. instance ~Ord Bool~ – ~Ord~ for things that can be put into a sequential
        order

     5. instance ~Read Bool~ – _Read_ parses strings into things.
        _Don’t use it. No seriously, don’t._     =TODO= =???=

     6. instance ~Show Bool~ – ~Show~ renders things into strings.

   - Type Classes have a hierarchy of sorts. For instance,
     + All ~Fractional~ numbers implement ~Num~ type classes, NOT the reverse
       direction.

     + All members of ~Ord~ must be members of ~Eq~, and all the members of
       ~Enum~ must be members of ~Ord~.
       _Rationale_:
       * To be able to put something in an enumerated list, they must be able to
         be ordered;

       * to be able to order something, they must be able to be compared for
         equality.

** DONE 6.4 ~Eq~ - 167
   CLOSED: [2017-05-26 Fri 01:29]
   - Haskell does NOT encode equality into every type (like many other languages do).

   - footnote 3: the function type does not have an ~Eq~ instance for reasons we
                 will not get into here. =TODO=

   - ~Eq~ is defined this way:
     #+BEGIN_SRC haskell
       -- Prelude> :info Eq
       class Eq a where
         (==) :: a -> a -> Bool
         (/=) :: a -> a -> Bool
     #+END_SRC

     The instances of ~Eq~ followed the above output:
     #+BEGIN_SRC haskell
       -- partial list
       instance Eq a => Eq [a] -- Defined in 'GHC.Classes'
       instance Eq Word -- Defined in 'GHC.Classes'
       instance Eq Ordering -- Defined in 'GHC.Classes'
     #+END_SRC

   - *Type Class deriving*
     Though there are some constraints on deriving type classes like ~Eq~, ~Ord~,
     ~Enum~, ~Bounded~, ~Read~, and ~Show~,
     you can magically derive them.

     /deriving/: No need to manually write instances of some type classes for each
     new datatype you create.

     =TODO=: Chapter _Algebraic Datatypes_

** DONE 6.5 Writing type class instances - 171
   CLOSED: [2017-05-26 Fri 23:02]
*** DONE ~Eq~ instances - 172
    CLOSED: [2017-05-26 Fri 21:50]
    - Type Classes like ~Eq~ come with the core base library that is located at
      http://hackage.haskell.org/package/base

      ~Eq~ specifically is located at
      http://hackage.haskell.org/package/base/docs/Data-Eq.html

    - We see the ~Eq~ definition in section 6.4. It has two functions.
      However, in the documentation, you'll see:
      ~Minimal complete definition: either == or /=.~
      + Q: Why can be ONE.
        A: This is reasonable: one can be defined as the negation of the other

      + Q: Since the answer of the last question, why not ONLY one?
        A: Although it's rare, you may have something clever to do for each case
           that could make equality checking faster for a particular datatype, so
           you're allowed to specify both if you want to.
        * =TODO= =???= =EXAMPLE???=
        * =COMMENT=: In this book we won't be working with any clever
                     datatypes mentioned as rare cases above.
                     Just consider the negation relation.

    - Example-1:
      Define a trivial datatype, and make it an instance of ~Eq~:
      #+BEGIN_SRC haskell
        -- keep your type class instances for a type
        -- in the same file as that type
        -- we'll explain why later

        data Trivial =
          Trival'

        instance Eq Trivial where
          Trivial' == Trivial' = True
      #+END_SRC

    - In Haskell, /data constructors/ and /type constructors/ often have the same
      name.
        To avoid gettiing confusing, you can use a single quote suffixed name
      like the example above.

    - Example-2:
      #+BEGIN_SRC haskell
        data DayOfWeek =
          Mon | Tue | Weds | Thu | Fri | Sat | Sun

        instance Eq DayOfWeek where
          (==) Mon Mon = True
          (==) Tue Tue = True
          (==) Weds Weds = True
          (==) Thu Thu = True
          (==) Fri Fri = True
          (==) Sat Sat = True
          (==) Sun Sun = True
          (==) _ _ = False

        -- day of week and numerical day of month
        data Date =
          Date DayOfWeek Int

        instance Eq Date where
          (==) (Date weekday dayOfWeek)
               (Date weekday' dayOfWeek') =
            weekday == weekday' && dayOfMonth == dayOfMonth'
      #+END_SRC
      One thing must be mention here:
        Since we didn't provide ~Show~ distance, values like ~Date Tue 10~ can be
      evaluated, but they can't be print out -- REPL will complain!
      #+BEGIN_SRC haskell
        -- *Main> Date Thu 10

        -- <interactive>:26:1:
        --     No instance for (Show Date) arising from a use of ‘print’
        --     In a stmt of an interactive GHCi command: print it
      #+END_SRC
      + Q: How to fix this?
        A: Stick a ~deriving Show~ clause on the end of each of the datatypes
           above.

*** DONE Partial functions -- not so strange danger - 176
    CLOSED: [2017-05-26 Fri 22:14]
    - /partial function/: a function that does NOT cover all the possible cases.

    - Turn all warnings on in GHCi: ~:set -Wall~
      Do this in the configuration file =TODO=

*** DONE Sometimes we need to ask for more - 179
    CLOSED: [2017-05-26 Fri 22:19]
    #+BEGIN_SRC haskell
      data Identity a =
        Identity a

      instance Eq a => Eq (Identity a) where
        (==) (Identity v) (Identity v') = v == v'
    #+END_SRC
    - The ~Eq a~ above is important, or else we can't do ~v == v'~ in the body
      of this instance.

    - Don't to too much! You shouldn't to things like replace the above ~Eq a~
      with ~Ord a~. If you do that, the code still can be compiled, but it's not
      clear why you use ~Ord~? You never need to know the order in this code.

*** DONE Exercises: ~Eq~ Instances - 181
    CLOSED: [2017-05-26 Fri 23:02]
    - If you have more than one data constructor, you need the ~_ _~
      unconditional case.
        For example: q7 - ~data Either a b = Hello a | Goodbye b~.

    - If you type constructor have more than one type variable,
      remember you don't need to consider case of corresponding types are
      different -- why? because they are different types, and you can't
      build equality or inequality between different types with the help of ~Eq~
      type class.
        For example: q5 - ~data Tuple a b = Tuple a b~.
                     ~Tuple 3 4 == Tuple 3 "a"~ can't pass the type check.

** DONE 6.6 ~Num~ - 182
   CLOSED: [2017-05-26 Fri 23:28]
   #+BEGIN_SRC haskell
     class Num a where
       (+) :: a -> a -> a
       (*) :: a -> a -> a
       (-) :: a -> a -> a
       negate :: a -> a
       abs :: a -> a
       signum :: a -> a
       fromInteger :: Integer -> a
   #+END_SRC
   And its list of instances (not quite complete):
   #+BEGIN_SRC haskell
     instance Num Integer
     instance Num Int
     instance Num Float
     instance Num Double
   #+END_SRC

   - ~fromInteger~ is similar to ~fromIntegral~, but restricted to ~Integer~
     rahter than all integral numbers.

*** DONE ~Integral~ - 182
    CLOSED: [2017-05-26 Fri 23:22]
    - ~Integral~ definition:
      #+BEGIN_SRC haskell
        class (Real a, Enum a) => Integral a where
          quot :: a -> a -> a
          rem :: a -> a -> a
          div :: a -> a -> a
          mod :: a -> a -> a
          quotRem :: a -> a -> (a, a)
          divMod :: a -> a -> (a, a)
          toInteger :: a -> Integer
      #+END_SRC
      + The tuple syntax ~(Real a, Enum a)~ here denotes the
        _conjunction of type class constraints_ on your type variable(s).

      + The tuple syntax here requires that ~a~ employ the methods each of those
        type classes.

      + In turn, the ~Real~ type class itself requires an instance of ~Num~.
          Since ~Real~ CANNOT override the methods of ~Num~,
        this type class inheritance is ONLY additive and the ambiguity problems
        caused by multiple inheritance in some programming languages -- the
        so-called "deadly diamond of death" -- are avoided.
        =IMPORTANT=

    - *Exercises: Tuple Experiment*

*** DONE ~Fractional~ - 183
    CLOSED: [2017-05-26 Fri 23:27]
    - ~Fractional~ definition:
      #+BEGIN_SRC haskell
        class (Num a) => Fractional a where
          (/) :: a -> a -> a
          recip :: a -> a
          fromRational :: Rational -> a
      #+END_SRC

    - *Put on your thinking cap*
      =DONE=

** DONE 6.7 Type-defaulting type classes? - 185
   CLOSED: [2017-05-27 Sat 00:59]
   - When you have a type class-constrained (ad hoc) polymorphic value
     and need to evaluate it, the polymorphism must be resolved to a specific
     _concrete type_.

     + The _concrete type_ must have an instance for all the required type class
       instances.

     + Ordinarily the _concrete type_ would come
       * from the type signature you've _specified_
         or
       * from _type inference_, such as when a Num a => a is used in an
         expression that expects an ~Integer~ which forces the polymorphic
         number value to concretize as an ~Integer~.

     + But in some cases =???=, particularly when you're working in the GHCi
       REPL you will not have specified a concrete type for a polymorphic value.
         In those situations, _the type class will default to a concrete type_,
       and the default types are already set in the libraries.

   - The Haskell Report (https://www.haskell.org/onlinereport/haskell2010/)
     specifies the following defaults relevant to numerical computations:
     #+BEGIN_SRC haskell
       default Num Integer
       default Real Integer
       default Enum Integer
       default Integral Integer
       default Fractional Double
       default RealFrac Double
       default Floating Double
       default RealFloat Double
     #+END_SRC

   - The use of polymorphic values
     + without the ability to infer a specific type
       and
     + no default rule
     will cause GHC to complain about an ambiguous type.

   - We can declare more specific (monomorphic) functions from more general
     (polymorphic) functions:
     ~let add = (+) :: Integer -> Integer -> Integer~

** DONE 6.8 ~Ord~ - 188
   CLOSED: [2017-05-27 Sat 04:04]
   #+BEGIN_SRC haskell
     class Eq a => Ord a where
       compare :: a -> a -> Ordering
       (<) :: a -> a -> Bool
       (>=) :: a -> a -> Bool
       (>) :: a -> a -> Bool
       (<=) :: a -> a -> Bool
       max :: a -> a -> a
       min :: a -> a -> a

     -- This list is incomplete!

     -- instance Ord a => Ord (Maybe a)
     -- instance (Ord a, Ord b) => Ord (Either a b)
     -- instance Ord Integer
     -- instance Ord a => Ord [a]
     -- instance Ord Ordering
     -- instance Ord Int
     -- instance Ord Float
     -- instance Ord Double
     -- instance Ord Char
     -- instance Ord Bool
   #+END_SRC

   - ~compare~: The type of return values is ~Ordering~
     #+BEGIN_SRC haskell
       -- Prelude> compare 7 8
       -- LT

       -- Prelude> compare 4 (-4)
       -- GT

       -- Prelude> compare 4 4
       -- EQ

       -- Prelude> compare "Julie" "Chris"
       -- GT

       -- Prelude> compare True False
       -- GT

       -- Prelude> compare True True
       -- EQ
     #+END_SRC

   - In Haskell, ~True~ is greater than ~False~.
     _Proximally_ this is due to how the ~Bool~ datatype is defined:
     ~False | True~.
     + TODO What is the real reason???
     + TODO IS the right of ~|~ is greater the left of ~|~ is a rule?
     + TODO Even if the above is a rule. It's can't be a reason, because you
            can also define the ~Bool~ datatype as ~True | False~.

   - Any time we ask GHCi to print a return value in our terminal, we are
     indirectly invoking ~print :: Show a => a -> IO ()~.

   - Usually, you can't evaluate a partial applied function result in GHCi.

     Rationale: What you really CANNOT do is to print it, not to evaluate it --
                after evaluation, GHCi, on behalf of you, will always try to
                print the result value out (the 'P' in the word "REPL").

*** DONE ~Ord~ instances - 192
    CLOSED: [2017-05-27 Sat 01:50]
    - One of the most necessary skills in Haskell:
      type classes instance-writing skills

    - When you /derive/ ~Ord~ instances for a datatype,
      they rely on the way the datatype is defined,

      but if you write your own instance, you can define the behavior you want.

      We'll use the days of the week again to demonstrate:
      #+BEGIN_SRC haskell
        data DayOfWeek =
          Mon | Tue | Weds | Thu | Fri | Sat | Sun
          deriving (Ord, Show)
      #+END_SRC
      + _Q_: Why do we not derive ~Eq~?

        _A_: Actually we did before.

      + _Q_: How about if not derive ~Eq~ before?

        _A_: Two solutions/options:
        1. bring it back into scope by putting it into the file you're currently
           using,
        2. derive an ~Eq~ instance for the datatype now by adding it inside the
           parentheses. For this example, we are lucky, the result of ~deriving~
           is what we want (like the instance we implement before).

        You can't have an ~Ord~ instance _unless_ you _ALSO_ have an ~Eq~ instance,

        so the compiler will complain
        if you don't do one (NOT both) of those two things.

      + Write our own ~Ord~ instance of the above datatype, and express the
        _Friday_ is always the best day -- greater than the other days in
        comparison (and set all the other days are equal -- in the same order).
        #+BEGIN_SRC haskell
          data DayOfWeek =
            Mon | Tue | Weds | Thu | Fri | Sat | Sun
            deriving (Eq, Show)

          instance Ord DayOfWeek where
            compare Fri Fri = EQ
            compare Fri _ = GT
            compare _ Fri = LT
            compare _ _ = EQ
        #+END_SRC

    - A few things should be kept in mind:
      + Make sure for one datatype, the ~Ord~ instance is _consistent_ with your
        ~Eq~ instance -- for example, if ~x == y~ is ~True~, ~compare x y~ should
        be ~EQ~.

      + ~Ord~ instances should define a sensible /total order/ -- all cases
        should be covered. You don't want ~compare x y~ is _inconsistent_ with
        your ~compare y x~.

      + =Question from Jian= How to write a /partial order/ instance??? Sometimes
        I may need to simulate some partial order objects in math.
        =TODO=

*** DONE ~Ord~ implies ~Eq~ - 194
    CLOSED: [2017-05-27 Sat 04:00]
    Always keep the idea /minimally sufficient/ in mind.

*** DONE Exercises: Will they work? - 195
    CLOSED: [2017-05-27 Sat 04:04]
    ONLY 3 can't work. ~compare~ can ONLY accept two arguments of the same type.
    ~String~ and ~Bool~ are not the same type.

** DONE 6.9 ~Enum~ - 195
   CLOSED: [2017-05-27 Sat 04:15]
   - ~Enum~ type class definition: 
     #+BEGIN_SRC haskell
       class Enum a where
         succ :: a -> a
         pred :: a -> a
         toEnum :: Int -> a
         fromEnum :: a -> Int
         enumFrom :: a -> [a]
         enumFromThen :: a -> a -> [a]
         enumFromTo :: a -> a -> [a]
         enumFromThenTo :: a -> a -> a -> [a]

       -- instance Enum Ordering
       -- instance Enum Integer
       -- instance Enum Int
       -- instance Enum Char
       -- instance Enum Bool
       -- instance Enum ()
       -- instance Enum Float
       -- instance Enum Double
     #+END_SRC

   - ~succ~ and ~pred~
     #+BEGIN_SRC haskell
       -- Prelude> succ 4
       -- 5

       -- Prelude> pred 'd'
       -- 'c'

       -- Prelude> succ 4.5
       -- 5.5
     #+END_SRC

   - ~enumFromTo~
     #+BEGIN_SRC haskell
       -- Prelude> enumFromTo 3 8
       -- [3, 4, 5, 6, 7, 8]

       -- Prelude> enumFromTo 'a' 'f'
       -- "abcdef"
     #+END_SRC

   - ~enumFromThenTo~
     #+BEGIN_SRC haskell
       -- Prelude> enumFromThenTo 1 10 100
       -- [1, 10, 19, 28, 37, 46, 55, 64, 73, 82, 91, 100]
     #+END_SRC

** DONE 6.10 ~Show~ - 197
   CLOSED: [2017-06-25 Sun 22:34]
   - ~Show~ :: a type class that provides for the creating of human-readable string
               representations of structured data.

   - GHCi uses ~Show~ (in the background, indirectly) to create ~String~ values
     it can print in the terminal.

   - /serialization/ :: how data is rendered to texual or binary format for
       persistence or communicating with other computers over a network.

       EXAMPLE: Save data to a file on disk.

   - ~Show~ is NOT suitable to be used as a /serialization/ format.
     It's expressly for human readability.

   - The type class information looks like this (_truncated_):
     #+BEGIN_SRC haskell
       -- Prelude> :info Show
       class Show a where
         showsPrec :: Int -> a -> ShowS
         show :: a -> String
         showList :: [a] -> ShowS

       instance Show a => Show [a]
       instance Show Ordering
       instance Show a => Show (Maybe a)
       instance Show Integer
       instance Show Int
       instance Show Char
       instance Show Bool
       instance Show ()
       instance Show Float
       instance Show Double
     #+END_SRC

   - ~show~: a function which
     + takes a polymorphic ~a~
       and
     + returns it as a ~String~

*** DONE Printing and side effects - 198 =RE-READ=
    CLOSED: [2017-06-25 Sun 22:33]
    - GHCi is a REPL, the "P" in "REPL" implies a implicit and indirect call to
      ~print~.
        ~print~ is important to ~Show~, and here we digress a bit and talk about
      it in more detail.

    - Haskell is a /pure/ /functional/ programming language.
      + /functional/: programs are written as functions, similar to mathematical
        equations, in which an operation is applied to some arguments to produce
        a result.

      + /pure/: expressions in Haskell can be expressed _exclusively_ in terms
        of a lambda calculus (=From Jian= use lambda (anonymous) functions).

    - /side effect/: a potentially observable result apart from the value the
      expression evaluates to.

    - Haskell manages effects by
      _separating_ effectful computations _from_ pure computations

      in ways that

      _preserve_ the _predictability_ and _safety_ of function evaluation.

    - =TODO= =???= =HOW=
      Importantly, effect-bearing computations themselves become
      + more composable
        and
      + easier to reason about.

    - ~print~ is defined in the ~Prelude~ standard as a function to
      _output_
      "a value of any printable type to the standard output device.

       Printable types are those that are instances of class ~Show~;

       ~print~ converts values to strings for output using the ~show~ operation
       and adds a newline."

    - ~print \colon{}\colon{} Show a => a -> IO ()~
      The result is an ~IO~ action that returns a value of the type ~()~
      =TODO=

    - ~IO ()~ is the obligatory type of ~main~ in a source code file.
      This is because running ~main~ only produces side effects.
      (=From Jian= IF it is NOT, we won't know anything after running a program)

    - Stated as _simply_ as possible:
      An ~IO~ action is an action that, when performed,
      _has side effects_, including
      + _reading from input_
        and
      + _printing to the screen_
      and will _contain a return value_. The ~()~ denotes an empty tuple, which
      we refer to as /unit/.

      /Unit/ is
      + a value,
        and
      + also a type that has only this one inhabitant, that _essentially
        represents nothing_.

    - _Printing a string to the terminal does NOT have a meaningful return value._

      BUT an ~IO~ action, like any expression in Haskell,
      _CANNOT_ return nothing; it _MUST_ return something.

      So we use this empty tuple to represent the return value at the end of our
      ~IO~ action.

      That is, the print function will
      + first do the ~IO~ action of printing the string to the terminal
        and
      + then complete the ~IO~ action,
        * marking an end to the execution of the function
          and
        * a delimitation of the side effects, by returning this empty nothing
          tuple.

      It does NOT print the empty tuple to the screen,
      but _it is implicitly there_.

      The simplest way to think about the difference between a value with
      a typical type like String and the same type but from ~IO~ such as with
      ~IO String~ is that IO actions are formulas.

      When you have a value of type ~IO String~ it's more of a means of
      producing a ~String~, which may require performing side effects along the
      way before you get your ~String~ value.

*** DONE Working with Show - 200
    CLOSED: [2017-05-27 Sat 23:02]
    - A minimal implementation of an instance of ~Show~ only requires that
      ~show~ OR ~showPrec~ be implemented, as in the following example:
      #+BEGIN_SRC haskell
        data Mood = Blah

        instance Show Mood where
          show _ = "Blah"

        -- *Main> Blah
        -- Blah
      #+END_SRC

    - Another solution is to derive the ~Show~ instance for ~Mood~
      because it's one of the type classes GHC supports deriving instances for by
      default.

** DONE 6.11 ~Read~ - 201
   CLOSED: [2017-05-28 Sun 00:01]
   - The ~Read~ type class, like ~Show~, a lot of types have instances of ~Read~.

   - ~Read~ is essentially the _opposite_ of ~Show~.
     Where ~Show~ takes things and turns them into human-readable strings,
     ~Read~ takes strings and turns them into things.

   - Like ~Show~, ~Read~ is _NOT_ a /serialization/ format.

   - We gave that dire warning against using ~Read~ earlier in the chapter. 
     + Q :: WHY?

     + A :: The problem is in the ~String~ type -- A ~String~ is a list, which
            could be empty in some cases, or stretch on to infinity in other
            cases.

            For example,
            #+BEGIN_SRC haskell
              -- Prelude> :t read
              -- read :: Read a => String -> a
            #+END_SRC
            No promise to a function of type ~Read a => String -> a~ that it can
            always work.
              One example is that we want to read a ~Integer~, however, we are in
            no way guaranteed that ~String~ will be a valid representation of an
            ~Integer~ value -- that's way too big of a type for things we want to
            parse into numbers!
            #+BEGIN_SRC haskell
              -- Prelude> read "123456" :: Integer
              -- 1234567

              -- Prelude> read "BLAH" :: Integer
              -- *** Exception: Prelude.read: no parse
            #+END_SRC
            That exception is a runtime error and means that read is a partial
            function, a function that doesn't return a proper value as a result for
            all possible inputs.

   - We have ways of cleaning this up we'll explain and demonstrate later. =TODO=

   - We should strive to avoid writing or using such functions in Haskell

     _BECAUSE_ Haskell gives us the tools necessary to avoid senseless sources of
     errors in our code. =TODO= 

** DONE 6.12 Instances are dispatched by type - 202
   CLOSED: [2017-05-28 Sun 16:31]
   - The components of a type class:
     + a type class defines a set of functions and/or values;

     + types have instances of that type class;

     + the instances specify the ways that type uses the functions of the
       type class.

   - Here is a example of vacuous and silly -- this is only to make a point:
     #+BEGIN_SRC haskell
       class Numberish a where
         fromNumber :: Integer -> a
         toNumber :: a -> Integer

       -- pretend newtype is data for now
       newtype Age =
         Age Integer
         deriving (Eq, Show)

       instance Numberish Age where
         fromNumber n = Age n
         toNumber (Age n) = n

       --
       newtype Year =
         Year Integer
         deriving (Eq, Show)

       instance Numberish Year where
         fromNumber n = Year n
         toNumber (Year n) = n

       -- Write a function using this type class and the two types and instances:
       sumNumberish :: Numberish a => a -> a -> a
       sumNumberish a a' = fromNumber summed
         where integerOfA = toNumber a
               integerOfAPrime = toNumber a'
               summed = integerOfA + integerOfAPrime

       -- Prelude> sumNumberish (Age 10) (Age 10)
       -- Age 20
     #+END_SRC

   - *Why not write a type class like this?*
     + Reasons will be given when we talk about ~Monoid~ TODO
       TODO =CANNOT UNDERSTAND=
       , it's important that your type classes have laws and rules about how they
       work.

     + ~Numberish~ is a bit... arbitrary.
       There are better ways to express what it does in Haskell than a type class.
       Functions and values alone suffice here.
       TODO

** DONE 6.13 Gimme more operations - 205
   CLOSED: [2017-05-28 Sun 16:51]
   - Haveing no constraint on our term-level values
     means
     they could be any type, but there isn't much we can do with them.

   - If you use an operation, and no type class(es) given to provide this
     operation, GHC/GHCi will issue an error message to tell you what
     type class(es) you should provide -- a prerequisite: the operand of this
     operator is proper, which means it/they can't be type(s) of no that
     operation.

*** DONE Concrete types imply all the type classes they provide - 207
    CLOSED: [2017-05-28 Sun 16:51]
    - Concrete types imply all the type classes they provide.
      + This is good in many cases.

      + This is not good in some cases: a lot of type classes (operations) are
        provided -- it could be easy to make a function that does something
        unintended. Thus, sometimes, even if you think you know what concrete
        type you will operate, you only provide proper type class(es), rather than
        the concrete type(s).
        =TODO= =NEED EXAMPLE=
** DONE 6.14 Chapter exercises - 208
   CLOSED: [2017-05-28 Sun 18:10]
*** DONE Multiple choice - 208
    CLOSED: [2017-05-28 Sun 16:54]
    1. c)
    2. a) b)
    3. a)
    4. c)
    5. a)

*** DONE Does it type check? - 209
    CLOSED: [2017-05-28 Sun 17:12]
    Nothing with the function type constructor (~->~) has an instance of Show by
    default in Haskell.
    =TODO= footnote-6
    1. Not typecheck. Add ~deriving Show~ to the datatype declaration.

    2. Not typecheck. Add ~deriving Eq~ to the datatype declaration.

    3. 
       a) Only ~Woot~ and ~Blah~
       b) Type error
       b) Type error. ~Mood~ is not an instance of ~Ord~

    4. Not typecheck. In ~s1~, no enough values are feeded to data constructor
       ~Sentence~.

*** DONE Given a datatype declaration, what can we do? - 211
    CLOSED: [2017-05-28 Sun 17:17]
    1. No typecheck.
       Should be ~phew = Papu (Rocks "chases") (Yeah True)~

    2. Typecheck.

    3. Typecheck.

    4. No typecheck.
       All ~deriving~ part should incude ~Ord~

       =TODO=
       WHY only ~deriving (Eq, Ord, Show)~ is OK and
       ~deriving (Ord, Show)~ doesn't work, even if ~Ord~ is the subclass of
       ~Eq~.

*** DONE Match the types - 212
    CLOSED: [2017-05-28 Sun 17:51]
    1. 
    2. 
    3. 
    4. 
    5. 
    6. 
    7. 
    8. 
    9. 
    10. 
    11. 
*** DONE Type-Kwon-Do Two: Electric typealoo
    CLOSED: [2017-05-28 Sun 18:10]
    1. ~chk aTob x y = (aTob x) == y~

    2. ~arith aTob int x = aTob x~
       TODO =BETTER ONE???=

** DONE 6.15 Definitions - 214
   CLOSED: [2017-05-29 Mon 00:20]
   1. /type class inheritance/: a type class can have a /superclass/, and a
      type class can have a /subclass/.

      #+BEGIN_SRC haskell
        -- class Num a => Fractional a where
        --   (/) :: a -> a -> a
        --   recip :: a -> a
        --   fromRational :: Rational -> a

        newtype Nada = Nada Double deriving (Eq, Show)

        instance Fractional Nada where
          (Nada x) / (Nada y)= Nada (x / y)
          recip (Nada n) = Nada (recip n)
          fromRational r = Nada (fromRational r)
      #+END_SRC
      When we load a source file with these code, we will receive some error
      messages -- the error surce is the ~deriving~ part of the ~newtype~ line.
      ~Nada~ is not an instance of ~Num~, thus it can't be an instance of
      ~Fractional~.

   2. /side effects/: observable actions programs may take other than compute a
      value.

   3. /IO/: =TODO= Read the IO chapter.

   4. /instance/: the definition of how a type class should work for a given type.

   5. /derived instances/: can be used to instance obvious or common type classes,
      which saves programmers' time, and auto-generates instance type classes for
      a given type.

** DONE 6.16 Type class inheritance, partial - 217
   CLOSED: [2017-05-28 Sun 18:18]
   Eq
    |
   \|/
   Ord    Num
    |    /   \
   \|/ |/_   _\|
   Real       Fractional  Enum
      \                    /
       ----           -----
          \under{}\|       |/\under{}
             Integral

** TODO 6.17 Follow-up resources - 217
   1. 
   2. 

* TODO 7 More Functional Patterns - 218
** DONE 7.1 Make it func-y - 219
   CLOSED: [2017-05-29 Mon 00:22]
** DONE 7.2 Arguments and parameters - 219
   CLOSED: [2017-05-29 Mon 01:07]
*** DONE Setting parameters - 219
    CLOSED: [2017-05-29 Mon 01:07]
    - /bound/, /unified/

*** DONE Binding variables to values - 222
    CLOSED: [2017-05-29 Mon 01:07]
    - Applying a function binds its parameters to values.

    - Type parameters become bound to a type, and
      function variables are bound to a value.

    - The binding of variables concerns not only the application of function
      arguments, but also things like ~let~ expressions and ~where~ clauses.

    - /Lexical scoping/: resolve the value for a named entity depends on the
      location in the code and the lexical context, for example in ~let~ and
      ~where~ clauses.

    - The seeming-sequentiality of defining things in GHCi is, under the hood,
      actually a never-ending series of nested lambda expressions.

** DONE 7.3 Anonymous functions - 226
   CLOSED: [2017-05-29 Mon 01:28]
   - In GHCi error messages, =it= refers to the last expression you entered.
     
*** DONE Exercises: Grab bag - 227
    CLOSED: [2017-05-29 Mon 01:20]
    1. a), b), c), d)

    2. d)

    3. Re-write:
       #+BEGIN_SRC haskell
         -- a)
         f = \n -> n + 1
         -- though `f = (+1)` is better

         -- b)
         addFive = \x -> \y -> (if x > y then y else x) + 5

         -- c)
         mflip f x y = f y x
       #+END_SRC

*** DONE The utility of lambda syntax - 228
    CLOSED: [2017-05-29 Mon 01:28]

** DONE 7.4 Pattern matching - 228
   CLOSED: [2017-05-29 Mon 03:03]
   - Pattern matching allows you to
     _expose_ data
     and
     _dispatch_ different behaviors _based on_ that data in your function
     definitions by _deconstructing_ values to expose their inner workings.

   - Enter a block of code in GHCi with the help of ~:{~ and ~:}~
     #+BEGIN_SRC haskell
       -- Prelude> :{
       -- *Main| let isItTwo :: Integer -> Bool
       -- *Main|     isItTwo 2 = True
       -- *Main|     isItTwo _ = False
       -- *Main| :}
     #+END_SRC

*** DONE Handling all the cases - 229
    CLOSED: [2017-05-29 Mon 02:25]
    - The _order_ of pattern matches _matters_!

    - /bottom/: a non-value used to denote that the program cannot return a value
      or result.
 
    - Incomplete pattern matches applied to data they don't handle will return
      /bottom/.
      For example:
      #+BEGIN_SRC haskell
      isItTwo :: Integer -> Bool
      isItTwo 2 = True

      -- Prelude> isItTwo 2
      -- True
      -- Prelude> isItTwo 3
      -- *** Exception: :50:33-48:
      --   Non-exhaustive patterns
      --       in function isItTwo
      #+END_SRC

    - =TODO= We're going to get well acquainted with the idea of /bottom/ in
      upcoming chapters.

    - ~:set -Wall~ can also (of course, we have ~all~ in the ~-Wall~ option) help
      to make a warnning about non-exhaustive pattern match(es) without
      triggering the /bottom/.

*** DONE Pattern matching against data constructors - 231
    CLOSED: [2017-05-29 Mon 02:55]
    - The purposes of /pattern matching/:
      + It enables us to vary what our functions do given different inputs.
      + It also allows us to _unpack_ and _expose_ the contents of our data.

    - The next example uses ~newtype~ which is a special case of ~data~
      declarations.
        ~newtype~ is different in that it permits
      + _only one_ constructor
        and 
      + _only one_ field.

      =TODO= We will talk about ~newtype~ more later.

    - /sum type/ and /product type/
      #+BEGIN_SRC haskell
        -- sum type
        data WherePenguinsLive =
            Galapagos
          | Antarctica
          | Australia
          | SouthAfrica
          | SouthAmerica
          deriving (Eq, Show)

        -- product type
        data Penguin =
          Peng WherePenguinsLive
          deriving (Eq, Show)
      #+END_SRC

*** DONE Pattern matching tuples - 236
    CLOSED: [2017-05-29 Mon 03:03]
    - One nice thing about tuples patten matching is that
      the tuple syntax allows the function to look a great deal like its type.

      =From Jian=
      The property of "_look like_ a thing it wants to represent" is important
      than it seems. This similarity can help you to avoid a lot of mistakes when
      doing operation.

    - ~:browse ModuleName~ can show you a list of the type signatures of
      functions we loaded from the module =ModuleName=.

*** DONE Exercises: Variety pack - 237
    CLOSED: [2017-05-29 Mon 01:51]
    1. 
        a) ~(a, b) -> b~
        b) ~[Char]~. Not same.
        a) ~k1~, ~k3~

    2. ~f (va, vb, vc) (vd, ve, vf) = ((va, vd), (vc, vf))~

** DONE 7.5 Case expressions - 238
   CLOSED: [2017-05-29 Mon 23:23]
*** TODO Exercises: Case Practice - 240
    #+BEGIN_SRC haskell
      -- 1
      functionC x y =
        case compare x y of
          LT -> x
          _ -> y

      -- 2
      ifEvenAdd2 n =
        case (even n) == True of
          True -> n + 2
          False -> n

      -- 3
      TODO: ???
    #+END_SRC

** DONE 7.6 Higher-order functions - 241
   CLOSED: [2017-05-30 Tue 01:07]
   - /higher-order functions (HOFs)/

   - ~flip \colon{}\colon{} (a -> b -> c) -> b -> a -> c~
     #+BEGIN_SRC haskell
       -- Prelude> (-) 10 1
       -- 9

       -- Prelude> let fSub = flip (-)
       -- Prelude> fSub 10 1
       -- -9

       -- Prelude> fSub 5 10
       -- 5
     #+END_SRC

   - When we want to express a function argument within a function type, we must
     use parentheses to nest it.

   - One reason we want /HOFs/ is to manipulate how functions are applied to
     arguments.

   - If a type ~deriving (Eq, Ord)~, the latter is greater than the former. For
     example:
     #+BEGIN_SRC haskell
       data Employee = Coder
                     | Manager
                     | Veep
                     | CEO
                     deriving (Eq, Ord, Show)
     #+END_SRC

*** DONE Exercises: Artful dodgy - 248
    CLOSED: [2017-05-30 Tue 01:10]
    1. 
    2. 
    3. 
    4. 
    5. 
    6. 
    7. 
    8. 
    9. 
    10. 
    11. 

** DONE 7.7 Guards - 249
   CLOSED: [2017-06-19 Mon 23:55]
*** DONE if-then-else - 249
    CLOSED: [2017-05-30 Tue 01:22]

*** DONE Writing guard blocks - 251
    CLOSED: [2017-05-30 Tue 01:31]
    #+BEGIN_SRC haskell
      myAbs :: Integer -> Integer
      myAbs x
         | x < 0 = (-x)
         | otherwise = x
    #+END_SRC
    + The guard case expression between the ~|~ and ~=~ must evaluate to ~Bool~.

    + It is important to note that GHCi _cannot always_ tell you when you haven't
      accounted for all possible cases, and it can be difficult to reason about
      it, so _it is wise to use ~otherwise~ in your final guard_, though it also
      cannot help you to check the coverity -- it just cover all else.

*** DONE Exercises: Guard duty - 254
    CLOSED: [2017-06-19 Mon 23:55]
    1. ...

    2. ...

    3. b)

    4. ~(Eq a) => [a]~

    5. ~(Eq a) => [a] -> Bool~

    6. c)

    7. ~(Num a, Ord a) => a~

    8. ~(Ord a, Num a, Num t) => a -> t~
       _IMPORTANT_

** DONE 7.8 Function composition - 255
   CLOSED: [2017-05-30 Tue 01:46]
   ~(.) :: (b -> c) -> (a -> b) -> a -> c~

   - Function composition can make code easier to read than nested parentheses.
     For example,
     NOT ~(f (g (h x)))~ , BUT ~(f . g . h) x~ or ~f . g . h $ x~ are prefered.

   - ~(f . g) x~ is always the same as ~f (g x)~ if
     + ~f \colon{}\colon{} b -> c~
     + ~g \colon{}\colon{} a -> b~
     + ~x \colon{}\colon{} a~
     Since function application has precedence of 10, the parentheses above is
     always required (or use ~$~).
       If no parentheses ~f . g x~ is the same as ~f . (g x)~, which is generally
     wrong, though it can be right, if
     + ~f \colon{}\colon{} b -> c~
     + ~g \colon{}\colon{} k -> a -> b~
     + ~x \colon{}\colon{} k~

** DONE 7.9 Point-free style - 259
   CLOSED: [2017-05-30 Tue 01:52]
   - ~foldr~

   - ~filter~ 

** DONE 7.10 Demonstrating composition - 261
   CLOSED: [2017-05-30 Tue 02:08]
   How to create your version of ~print~ with the helper of function composition
   ~(.)~: ~putStrLn . show~

** DONE 7.11 Chapter Exercises - 264
   CLOSED: [2017-06-27 Tue 23:56]
*** DONE Multiple choice - 264
    CLOSED: [2017-05-30 Tue 02:14]
    1. d)
    2. b)
    3. d)
    4. b)
    5. a)

*** DONE Let's write code - 265
    CLOSED: [2017-06-27 Tue 23:56]
    #+BEGIN_SRC haskell
      -- 1
      -- -- a)
      -- -- I think this is a contrived exercise, and it is designed to help the reader
      -- -- getting used to the pattern matching below.
      tensDigit x = d
        where (xLast, _) = x `divMod` 10
              d = xLast `mod` 10

      -- -- I prefer the non-`divMod` pointless version:
      tensDigit' = (`mod` 10) . (`div` 10)

      -- -- b) Yes

      -- -- c)
      hunsD = (`mod` 10) . (`div` 100)
      -- OR
      nthDigit n = (`mod` 10) . (`div` n)
      hunsD' = nthDigit 100


      -- 2
      foldBool3Case :: a -> a -> Bool -> a
      foldBool3Case x y bool =
        case bool of
          True -> x
          False -> y

      foldBool3Guard :: a -> a -> Bool -> a
      foldBool3Guard x y isTrue
        | isTrue = x
        | otherwise = y


      -- 3
      g :: (a -> b) -> (a, c) -> (b, c)
      g f (va, vc) = (f va, vc)


      -- 4
      roundTrip :: (Show a, Read a) => a -> a
      roundTrip a = read $ show a
      --
      -- main = do
      --   print (roundTrip 4)
      --   print (id 4)


      -- 5
      roundTrip' :: (Show a, Read a) => a -> a
      roundTrip' = read . show
      --
      -- main = do
      --   print (roundTrip 4)
      --   print (id 4)


      -- 6
      roundTrip'' :: (Show a, Read b) => a -> b
      roundTrip'' = read . show
      --
      -- main = do
      --   print (roundTrip 4 :: Int)
      --   print (id 4)
    #+END_SRC



    3. 
       #+BEGIN_SRC haskell
         g :: (a -> b) -> (a, c) -> (b, c)
         g aTob (va, vc) = ((aTob va), vc)
       #+END_SRC

    4. =TODO=

    5. =TODO=

    6. =TODO=

** DONE 7.12 Definitions - 268
   CLOSED: [2017-05-30 Tue 03:03]
   1. /binding/ or /bound/

   2. /anonymous function/

   3. /currying/
      ~curry~ and ~uncurry~ already exist in =Prelude=

   4. /pattern matching/: a syntactic way of deconstructing product and sum types
      to get at their inhabitants.
        It's best to explain pattern matching in terms of how datatypes work, so
      we're going to use terminology that you may not fully understand yet.
      =TODO= We'll cover this more deeply soon.

   5. /bottom/

   6. /higer-order functions/

   7. /composition/

   8. /pointfree/
      #+BEGIN_SRC haskell
        -- not pointfree
        blah x = x
        addAndDrop x y = x + 1
        reverseMkTuple a b = (b, a)
        reverseTuple (a, b) = (b, a)

        -- pointfree versions of the above
        blah = id
        addAndDrop = const . (1 +)
        reverseMkTuple = flip (,)
        reverseTuple = uncurry (flip (,))
      #+END_SRC
      + ~const~

** TODO 7.13 Follow-up resources - 274
   1. 
   2. 
   3. 
   4. 
   5. 

* TODO 8 Recursion - 275
** DONE 8.1 Recursion - 276
   CLOSED: [2017-05-30 Tue 15:27]
   - /recursion/ gives us a means of expressing /indefinite/ or incremental
     computation without forcing us to explicitly repeat ourselves and allowing
     the data we processing to decide when we are doen computing.

   - Being able to write recursive functions is essential to Turing completeness.

   - /Y combinator (fixed-point combinator)/
     Haskell has native recursion ability based on the same principle as the Y
     combinator.

   - In this chapter, we will
     + explore _what_ recursion is
       and
       _how_ recursive functions _evaluate_;

     + go step-by-step through the process of writing recursive functions;

     + have fun with /bottom/.

** DONE 8.2 Factorial! - 277
   CLOSED: [2017-05-30 Tue 16:19]
*** DONE Another way to look at recursion - 279
    CLOSED: [2017-05-30 Tue 16:08]
    - ~enumFrom \colon{}\colon{} Enum a => a -> [a]~

    - /recursion/ is like a self function composition with a stopping point:
      #+BEGIN_SRC haskell
        inc :: Num a => a -> a
        inc = （+1）

        three = inc . inc . inc $ 0

        -- Use a parameter "times" to control how many times of 'inc' need to be applied
        incTimes :: (Eq a, Num a) => a -> a -> a
        incTimes 0 n = n
        incTimes times n = 1 + (incTimes (times -1) n)

        -- Abstract pattern from 'incTimes'
        applyTimes :: (Eq a, Num a) => a -> (b -> b) -> b -> b
        applyTimes 0 f b = b
        applyTimes n f b = f (applyTimes (n - 1) f b)

        incTimes' :: (Eq a, Num a) => a -> a -> a
      #+END_SRC

*** DONE Intermission: Exercise - 282
    CLOSED: [2017-05-30 Tue 16:08]

** DONE 8.3 Bottom - 282
   CLOSED: [2017-05-30 Tue 16:42]
   - ⊥ or /bottom/: computations that do not successfully result in a value.

   - Two main varieties of bottom:
     + computations that failed with an error;
       #+BEGIN_SRC haskell
         -- "f False" results in a bottom
         f :: Bool -> Int
         f True = error "blah"
         f False = 0
         -- Prelude> f True
         -- *** Exception: blah



         -- The error is still there, but our language implementation is making
         -- it the fallback case because we didn't write a "total function".
         g :: Bool -> Int
         g False = 0
         -- Prelude> g True
         -- *** Exception: 6:23-33:
         --       Non-exhaustive patterns in function g

         -- The previous function was really:
         g' :: Bool -> Int
         g' False = 0
         g' _ = error $ "*** Exception: "
                     ++ "Non-exhaustive"
                     ++ "patterns in function g'"
       #+END_SRC

     + computations that failed to terminate.
       #+BEGIN_SRC haskell
         -- Prelude> let x = x in x
         -- *** Exception: <<loop>>
       #+END_SRC

   - In logic, ⊥ corresponds to _false_.

   - You can easily use the datatype ~Maybe~ to re-write a /partial function/,
     and get a /total function/. The definition of ~Maybe~ is:
     ~data Maybe a = Nothing | Just a~

   - ~Nothing~ is a way to say no result without hitting /bottom/.

   - ~Maybe~ makes all uses of ~nil~ values and most uses of /bottom/
     unnecessary.

** DONE 8.4 Fibonacci numbers - 286
   CLOSED: [2017-05-30 Tue 21:49]
*** Consider the types - 286
*** Consider the base case - 286
*** Consider the arguments - 287
*** Consider the recursion - 287

** DONE 8.5 Integral division from scratch - 289
   CLOSED: [2017-05-30 Tue 21:56]

** DONE 8.6 Chapter exercises - 293
   CLOSED: [2017-05-31 Wed 00:27]
*** DONE Review of types - 293
    CLOSED: [2017-05-30 Tue 03:10]
   1. d) 
   2. b)
   3. a) c)
   4. b)

*** DONE Reviewing currying - 294
    CLOSED: [2017-05-30 Tue 03:19]
   1. "woops mrow woohoo!"

   2. "1 mrow haha"

   3. "woops mrow 2 mrow haha"

   4. "woops mrow blue mrow haha"

   5. "pink mrow haha mrow green mrow woops mrow blue"

   6. "are mrow Pugs mrow awesome"

*** DONE Recursion - 295
    CLOSED: [2017-05-30 Tue 23:20]
    1. 
        #+BEGIN_SRC haskell
          -- divideby 15 2 =
          -- go 15 2 0
          -- go 13 2 1
          -- go 11 2 2
          -- go 9 2 3
          -- go 7 2 4
          -- go 5 2 5
          -- go 3 2 6
          -- go 1 2 7
          -- (7, 1)
        #+END_SRC

    2. 
       #+BEGIN_SRC haskell
         sum :: (Eq a, Num a) => a -> a
         sum n = go n 0
           where
             go 0 acc = acc
             go m acc = go (m - 1) acc + m
       #+END_SRC

    3.
       #+BEGIN_SRC haskell
         mult' :: (Integral a) => a -> a -> a
         mult' x y
           | (x == 0) || (y == 0) = 0
           | otherwise = go (min xAbs yAbs) (sign * max xAbs yAbs) 0
           where
             sign = (signum x) * (signum y)
             xAbs = abs x
             yAbs = abs y
             go 0 _ acc = acc
             go n' m acc = go (n'-1) m (acc+m)
       #+END_SRC

*** DONE Fixing dividedBy - 296
    CLOSED: [2017-05-30 Tue 23:54]
    #+BEGIN_SRC haskell
      data DividedResult =
        Result Integer
        | DividedByZero
        deriving Show

      dividedBy :: Integer -> Integer -> (DividedResult, Integer)
      dividedBy num demon
        | demon == 0 = (DividedByZero, num)
        | otherwise = go (abs num) (abs demon) 0
        where
          sign = (signum num) * (signum demon)
          go n d count
            | n < d = (Result $ count * sign, n)
            | otherwise = go (n - d) d (count + 1)
    #+END_SRC

*** DONE McCarthy 91 function - 296
    CLOSED: [2017-05-30 Tue 23:58]
    #+BEGIN_SRC haskell
      mc91 x
        | x > 100 = x - 10
        | otherwise = mc91 $ mc91 (x + 11)
    #+END_SRC
*** DONE Numbers into words - 297
    CLOSED: [2017-05-31 Wed 00:27]
    #+BEGIN_SRC haskell
      module WordNumber where

      import Data.List (intersperse)

      digitToWord :: Int -> String
      digitToWord 0 = "zero"
      digitToWord 1 = "one"
      digitToWord 2 = "two"
      digitToWord 3 = "three"
      digitToWord 4 = "four"
      digitToWord 5 = "five"
      digitToWord 6 = "six"
      digitToWord 7 = "seven"
      digitToWord 8 = "eight"
      digitToWord 9 = "nine"
      digitToWord _ = error "digit other than 0 ~ 9"

      digits :: Int -> [Int]
      digits n = go n []
        where
          go num digitList
            | num < 10 = num:digitList
            | otherwise = let (d, m) = num `divMod` 10
                          in go d (m:digitList)

      wordNumber :: Int -> String
      wordNumber n = concat $ intersperse "-" wordList
        where
          wordList = map digitToWord (digits n)
    #+END_SRC
** DONE 8.7 Definitions - 298
   CLOSED: [2017-05-30 Tue 03:20]
   /recursion/

* TODO 9 Lists - 299
** DONE 9.1 Lists - 300
   CLOSED: [2017-05-31 Wed 01:13]
   - Two purpose:
     1. a collection or plurality of values.
     2. infinite series of values, usually generated by a function, which allows
        them to act as a stream datatype.

   - In this chapter, we will:
     + explain list's datatype and how to pattern match on lists;
     + practice many standard library functions for operating on lists;
     + learn about the underlying representations of lists;
     + see what that representation means for their evaluation;
     + and do a whole bunch of exercises!

** DONE 9.2 The list datatype - 300
   CLOSED: [2017-05-31 Wed 01:22]
   - ~data [] a = [] | a : [a]~
     + Here ~[]~ is
       the type constructor for lists
       as well as
       the data constructor for the empty list.

     + ~[]~ data constructor is a nullary constructor (no arguments).

     + ~(:)~ is an infix operator usually called "cons".

   - list datatype as a whole is a sum type,
     but the second data constructor is a /product/.

     A /sum type/ can be read as an "or", and a /product/ is like an "and".

   - In English, one can read this as:
     ~data []   a   =  []  |  a : [a]~
       --  [1] [2] [3] [4] [5] [6]
     1. The datatype with the type constructor ~[]~
     2. takes a single type constructor argument ~a~
     3. at the term level can be constructed via
     4. nullary constructor ~[]~
     5. or it can be constructed by
     6. data constructor ~(:)~ which is a product of a value of the type ~a~ we
        mentioned in the type constructor and a value of type ~[a]~, that is,
        “more list.”

** DONE 9.3 Pattern matching on lists - 301
   CLOSED: [2017-05-31 Wed 02:00]
   - *Using Maybe*
     + Later in the book, we’ll also cover a datatype called ~NonEmpty~ which
       always has at least one value and avoids the empty list problem.

** DONE 9.4 List's syntactic sugar - 303
   CLOSED: [2017-05-31 Wed 02:06]
   - /cons cell/
   - =TODO= =???= The cons cell is a /conceptual/ space that values may inhabit.

** DONE 9.5 Using ranges to construct lists - 304
   CLOSED: [2017-05-31 Wed 02:34]
   - ~enumFrom \colon{}\colon{} Enum a => a -> [a]~
     ~enumFromThen \colon{}\colon{} Enum a => a -> a -> [a]~

     They can generate lists of indefinite, _possibly infinite_, length.

     If the type ~a~ which instances the type class ~Enum~ has upper bound, then
     the generated lists are NOT infinite.

   - ~enumFromTo \colon{}\colon{} Enum a => a -> a -> [a]~
     #+BEGIN_SRC haskell
       [1..10]
       -- OR
       enumFromTo 1 10

       -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


       enumFromTo 3 1
       -- []
     #+END_SRC

   - ~enumFromThenTo \colon{}\colon{} Enum a => a -> a -> a -> [a]~
     #+BEGIN_SRC haskell
       [1, 2..10]
       -- OR
       enumFromThenTo 1 2 10

       -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     #+END_SRC

*** DONE Exercise: EnumFromTo - 306
    CLOSED: [2017-05-31 Wed 02:34]
    The definition of ~Enum~ type class:
    #+BEGIN_SRC haskell
      -- Prelude> :info Enum
      class Enum a where
        succ :: a -> a
        pred :: a -> a
        toEnum :: Int -> a
        fromEnum :: a -> Int
        enumFrom :: a -> [a]
        enumFromThen :: a -> a -> [a]
        enumFromTo :: a -> a -> [a]
        enumFromThenTo :: a -> a -> a -> [a]
    #+END_SRC

    #+BEGIN_SRC haskell
      eftBool :: Bool -> Bool -> [Bool]
      eftBool False True = [False, True]
      eftBool _ _ = []

      eftOrd :: Ordering -> Ordering -> [Ordering]
      eftOrd LT EQ = [LT, EQ]
      eftOrd LT GT = [LT, EQ, GT]
      eftOrd EQ GT = [EQ, GT]
      eftOrd o1 o2 = if o1 == o2
                     then [o1]
                     else []

      eftInt :: Int -> Int -> [Int]
      eftInt x y
        | x <= y = x : (eftInt (succ x) y)
        | otherwise = []

      eftChar :: Char -> Char -> [Char]
      eftChar c1 c2
        | c1 <= c2 = c1 : (eftChar (succ c1) c2)
        | otherwise = []
    #+END_SRC

** DONE 9.6 Extracting portions of lists - 307
   CLOSED: [2017-05-31 Wed 03:48]
   - ~take \colon{}\colon{} Int -> [a] -> [a]~
     ~take~ n elements from an empty list will result in an empty list.

   - ~drop \colon{}\colon{} Int -> [a] -> [a]~
     ~drop~ n elements from an empty list will result in an empty list.

   - ~splitAt \colon{}\colon{} Int -> [a] -> ([a], [a])~
     split after the nth element.
     ~splitAt~ an empty list will result in an empty list.

   - ~takeWhile \colon{}\colon{} (a -> Bool) -> [a] -> [a]~
     ~dropWhile \colon{}\colon{} (a -> Bool) -> [a] -> [a]~
     Take or drop items out of a list that meet some condition.

*** DONE Exercises: Thy fearful symmetry - 310
    CLOSED: [2017-05-31 Wed 03:48]
    1. 
       #+BEGIN_SRC haskell
         myWords :: String -> [String]
         myWords "" = []
         myWords (' ':subSentence) = myWords subSentence
         myWords sentence = word : (myWords subSent)
           where
             subSent = dropWhile (/= ' ') sentence
             word = takeWhile (/= ' ') sentence
       #+END_SRC

    2. 
       #+BEGIN_SRC haskell
         myLines :: String -> [String]
         myLines "" = []
         myLines ('\n':subString) = myLines subString
         myLines string = oneSent : (myLines leftSents)
           where
             oneSent = takeWhile (/= '\n') string
             leftSents = dropWhile (/= '\n') string
       #+END_SRC

    3. 
       #+BEGIN_SRC haskell
         myUnits :: Char -> String -> [String]
         myUnits _ "" = ""
         myUnits sep string@(sep':substring)
           | sep == sep' = myUnits sep subString
           | otherwise = oneSent : (myUnits sep leftSents)
           where
             oneSent = takeWhile (/= sep) string
             leftSents = dropWhile (/= sep) string

         myWords = myUnits ' '
         myLines = myUnits '\n'
       #+END_SRC

** DONE 9.7 List comprehensions - 311
   CLOSED: [2017-05-31 Wed 15:17]
   - /list comprehension/: generate a new list from a list or lists.

   - Example:
     #+BEGIN_SRC haskell
       [x^2 | x <- [1..10]]
     #+END_SRC
     ~<-~ is read as "take"

*** DONE Adding predicates - 312
    CLOSED: [2017-05-31 Wed 15:04]
    - Example:
      #+BEGIN_SRC haskell
        [x^2 | x <- [1..10], rem x 2 == 0]
      #+END_SRC

    - For list comprehensions with multiple generators, one thing to note is that
      the rightmost generator will be exhausted first, then the second rightmost,
      and so on.
        For example,
      #+BEGIN_SRC haskell
        -- Without condition:
        [x^y | x <- [1..5], y <- [2, 3]]
        -- [1, 1, 4, 8, 9, 27, 16, 64, 25, 125]

        -- With condition:
        [x^y | x <- [1..10], y <- [2, 3], x^y < 200]
        -- [1, 1, 4, 8, 9, 27, 16, 64, 25, 125, 36, 49, 64, 81, 100]
      #+END_SRC

*** DONE Exercises: Comprehend thy lists - 314
    CLOSED: [2017-05-31 Wed 15:09]
    #+BEGIN_SRC haskell
      mySqr = [x^2 | x <- [1..5]]
      -- [1, 4, 9, 16, 25]

      [x | x <- mySqr, rem x 2 == 0]
      -- [4, 16]

      [(x, y) | x <- mySqr, y <- mySqr, x < 50, y > 50]
      -- []

      take 5 [(x, y) | x <- mySqr,
              y <- mySqr, x < 50, y > 50]
      -- []
    #+END_SRC

*** DONE List comprehensions with strings - 315
    CLOSED: [2017-05-31 Wed 15:13]
    - ~elem :: Eq a => a -> [a] -> Bool~

*** DONE Exercises: Square cube - 316
    CLOSED: [2017-05-31 Wed 15:17]
    #+BEGIN_SRC haskell
      -- 1
      tuples = [(x, y) | x <- mySqr, y <- myCube]

      -- 2
      smallTuples = [(x, y) | x <- mySqr, y <- myCube, x < 50, y < 50]

      -- 3
      length tuples
      length SmallTuples
    #+END_SRC

** DONE 9.8 Spines and non-strict evaluation - 317
   CLOSED: [2017-07-03 Mon 00:42]
   - /spine/: the connective structure that ties the collection of values
     togehter.
       lists, sequences, and trees have /spines/.

   - Values in cons (~:~) cell _do NOT exist "before"_ the cons cell that
     contains it.
     Because of _this_ and _the way nonstrict evaluation works_,
     =IMPORTANT=
     _you can evaluate cons cells independently of what they contain_.
     This means
     It is possible to evaluate just the /spine/ (or part of the /spine/) of the
     list _WITHOUT_ evaluating individual values.

   - _Evaluation_ of the list in this representation proceeds _DOWN_ the /spine/.

     _Constructing_ the list when that is necessary, however, proceeds _UP_ the
     /spine/.

   - _SETTINGS_ for the next subsections:
     Bring the /bottom (⊥)/ back in the form of ~undefined~
     in order to
     demostrate some of the effects of nonstrict evaluation.

     Use =_= to syntactically signify values we are ignoring and not evaluating.

*** DONE Using GHCi's ~:sprint~ command - 318
    CLOSED: [2017-05-31 Wed 16:02]
    - ~:sprint~ (in GHCi): print variables and see what has been evaluated
      already, with the underscore (~_~) representing expressions that haven't
      been evaluated yet.

    - _Warning_: ~:sprint~ has some behavioral quirks that can be a bit
      frustrating when you experiment and explore yourself.
      =TODO= =???=
      + GHC Haskell has some _opportunistic optimizations_ =TODO= =???= which
        introduce strictness to make code faster when it won't change how your
        code evaluates.

      + Additionally polymorphism means values like ~Num a => a~ are really
        waiting for a sort of argument which will make it concrete (this will be
        covered in more detail in a later chapter).
          To avoid this, you have to assign a more concrete type such as ~Int~ or
        ~Double~, otherwise it stays unevaluated, ~_~, in :sprint's output.
        =TODO= =EXAMPLE=

      If you can keep these _caveats_ to :sprint's behavior in mind, it can be
      useful.
        Otherwise if you find it confusing, don't sweat it and wait for us to
      elaborate more deeply in the chapter on nonstrictness.

    - Example:
      #+BEGIN_SRC haskell
        -- Prelude> let blah = enumFromTo 'a' 'z'
        -- Prelude> :sprint blah
        -- blah = _

        -- Prelude> take 1 blah
        -- "a"
        -- Prelude> :sprint blah
        -- blah = 'a' : _

        -- Prelude> take 2 blah
        -- "ab"
        -- Prelude> :sprint blah
        -- blah = 'a' : 'b' : _
      #+END_SRC

    - The ~length~ function is _ONLY_ /strict/ in the /spine/, meaning it only
      forces evaluation of the /spine/ of a list, _NOT the values_, something we
      can see if we try to find the length of a list of undefined values.
        But when we use ~length~ on =blah=, ~:sprint~ will behave _as though_
      (not real) we had forced evaluation of the values as well:
      #+BEGIN_SRC haskell
        -- Prelude> length blah
        -- 26

        -- Prelude> :sprint blah
        -- blah = "abcdefghijklmnopqrstuvwxyz"

        -- COMMENT: the printed out of blah is not real, its cons cells have not been
        --          evaluated.
      #+END_SRC
      That the individual characters were shown as evaluated and not exclusively
      the /spine/ after getting the ~length~ of =blah= is one of the
      _unfortunate aforementioned quirks of how GHCi evaluates code_.

*** DONE Spines are evaluated independently of values - 320
    CLOSED: [2017-07-03 Mon 00:34]
    - /normal form/: the expression is fully evaluated.

    - /weak head normal form (WHNF)/: the expression is only evaluated as far as
      is necessary to reach a data constructor.

    - /WHNF/ is a larger set and contains the possibility that:
      + the expression is fully evaluated (/normal form/);
      + the expression has been evaluated to the point of arriving at a data
        constructor;
      + lambda awaiting an argument.

    - For an expression in WHNF, further evaluation may be possible once another
      argument is provided.
        If no further inputs are possible, then it is still in WHNF but also in
      normal form (NF).
      =TODO= Chapter non-strictness

    - For example:
      + ~(1, 2) -- WHNF & NF~
        This first example is in /normal form/ and is fully evaluated.
        _Anything in /normal form/ is by definition also in
        /weak head normal form/_,
        because /weak head/ is an expression which is evaluated up to _at least_
        the first data constructor. /Normal form/ exceeds that by requiring
        that all sub-expressions be fully evaluated.

          Here the components of the value are:
        * the tuple data constructor
          and
        * the values 1 and 2.

      + ~(1, 1 + 1) -- WHNF~
        ~1 + 1~ hasn't been evaluated.

      + ~\x -> x * 10 -- WHNF & NF~
        This anonymous function can't reduced further.
        With nothing further to reduce, it is in /normal form/.

      + ~"Papu" ++ "chon"~
        Neither /WHNF/ nor /NF/.
        The "outermost" component of the expression is a function, ~(++)~, whose
        arguments are fully applied but it hasn't been evaluated.

      + ~(1, "Papu" ++ "chon") -- WHNF~

    - When we _define_ a list and define all its values, it is in /NF/ and all
      its values are known.

    - When we _construct_ a list through /ranges/ or /functions/ the list is in
      /WHNF/ but not /NF/.

    - The compiler _ONLY_ evaluates the head or first node of the graph,
      BUT _JUST_ the cons constructor,
          _NOT_ the value or rest of the list it contains.

    - Evaluating a list to /normal form/ would've meant recursing through the
      entire list,
      forcing
      + _not only_ the entire spine
      + _but also_ the values each cons cell contained.

    - =TODO=
      #+BEGIN_SRC haskell
        -- Prelude> let x = [1, undefined, 3]
        -- Prelude> length x
        -- 3
      #+END_SRC

    - We can define our own ~length~ function. Pay attention that the ~_~ is
      important, it's _NOT only a convention_ for a variable that will never be
      used, it also tells the compiler NOT to evaluate this value.

      _IF_ you DO _NOT_ use ~_~ below,
      the length we will define is _different from_ the built-in's
      behavior -- evaluate values inside cons cell when only evaluate the /spine/
      (the cons cells structure) is enough.
      #+BEGIN_SRC haskell
        -- *Not* identical to the length function in Prelude
        length :: [a] -> Integer
        length [] = 0
        length (_:xs) = 1 + length xs
      #+END_SRC

    - Currently, if you try using ~_~ on the right-hand side in the definition,
      it'll think you're trying to refer to a _hole_.
      =TODO= important feature, explained later or NOT? I don't know.

    - ~length~ will throw an error on a /bottom/ value if part of the /spine/
      itself is /bottom/:
      #+BEGIN_SRC haskell
        -- Prelude> let x = [1] ++ undefined ++ [3]
        -- -- This is different from [1, undefined, 3]

        -- Prelude> length x
        -- *** Exception: Prelude.undefined

        -- Prelude> x
        -- [1*** Exception: Prelude.undefined
      #+END_SRC
      + Printing the list fails, although it gets as far as printing the first
        ~[~ and the first value,
        and
      + attempting to get the length also fails because it can't count undefined
        spine values.

    - =TODO= Return to this topic later.
      Developing intuition for Haskell's evaluation strategies takes time and
      practice.

*** DONE Exercises: Bottom madness - 325
    CLOSED: [2017-07-03 Mon 00:42]
**** DONE Will it blow up? - 325
     CLOSED: [2017-07-03 Mon 00:36]
     1. ⊥
     2. [1]
     3. ⊥
     4. 3
     5. ⊥
     6. [2]
     7. ⊥
     8. [1]
     9. [1, 3]
     10. ⊥

**** DONE Intermission: Is it in normal form? - 326
     CLOSED: [2017-07-03 Mon 00:41]
     TODO
     The author does NOT mentioned that if these result are the result
     of ~:sprint~:

     1. WHNF & NF
     2. WHNF TODO
     3. Neither
     4. Neither
     5. Neither
     6. Neither
     7. WHNF TODO

** DONE 9.9 Transforming lists of values - 326
   CLOSED: [2017-05-31 Wed 22:14]
   - In truth, in part because Haskell uses nonstrict evaluation,

     we _tend to_ use higher-order functions for transforming data
        _rather than_ manually recursing over and over.

   - ~map \colon{}\colon{} (a -> b) -> [a] -> [b]~
     ~map~ can only be used with ~[]~.

   - ~fmap \colon{}\colon{} Functor f => (a -> b) -> f a -> f b~
     ~fmap~ can be applied to data
     other than lists.
     =TODO= See ~Functor~ later.

   - How ~map~ is defined in Base:
     #+BEGIN_SRC haskell
       map :: (a -> b) -> [a] -> [b]
       map _ [] = []
       map f (x:xs) = fx : map f xs
     #+END_SRC

   - A common mantra for performance sensitive code in Haskell is:
     _"lazy in the spine, strict in the leaves."_

     =TODO= We'll cover this properly later
     _when we talk about nonstrictness and data structures_, although many
     Haskell users rarely worry about this.

*** DONE Exercises: More Bottoms - 332
    CLOSED: [2017-05-31 Wed 22:14]
    1. ⊥
    2. [1]
    3. ⊥
    4. ~[Char] -> [Bool]~
    5.
       a) ~[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]~
       b) ~[1, 10, 20]~
       c) ~[15, 15, 15]~
    6. 
       #+BEGIN_SRC haskell
         import Data.Bool

         negateX x :: Num a => [a] -> [a]
         negateX x= map (\y -> bool y (-y) (y==x))
       #+END_SRC

** DONE 9.10 Filtering lists of values - 333
   CLOSED: [2017-05-31 Wed 22:28]
   - The definition of ~filter~
     #+BEGIN_SRC haskell
       filter :: (a -> Bool) -> [a] -> [a]
       filter _ [] = []
       filter pred (x:xs)
         | pred x = x : filter pred xs
         | otherwise = filter pred xs
     #+END_SRC

*** DONE Exercises: Filtering - 335
    CLOSED: [2017-05-31 Wed 22:28]
    #+BEGIN_SRC haskell
      -- 1
      filter (\x -> x `mod` 3 == 0) [1..30]

      -- 2
      length . filter (\x -> x `mod` 3 == 0) $ [1..30]

      -- 3
      myFilter :: String -> [String]
      myFilter = filter f . words
        where
          f = \x -> (x /= "a") && (x /= "an") && (x /= "the")
    #+END_SRC

** DONE 9.11 Zipping lists - 335
   CLOSED: [2017-05-31 Wed 23:16]
   - ~zip \colon{}\colon{} [a] -> [b] -> [(a, b)]~
     #+BEGIN_SRC haskell
       zip [1, 2, 3] [4, 5, 6]
       -- [(1, 4), (2, 5), (3, 6)]

       zip [1, 2] [4, 5, 6]
       -- [(1, 4), (2, 5)]

       zip [] [1..1000000]
       -- []
     #+END_SRC

   - ~unzip \colon{}\colon{} [(a, b)] -> ([a], [b])~
     #+BEGIN_SRC haskell
       unzip $ zip [1, 2, 3] [4, 5, 6]
       -- ([1, 2, 3], [4, 5, 6])
     #+END_SRC

   - ~zipWith \colon{}\colon{} (a -> b -> c) -> [a] -> [b] -> [c]~
     #+BEGIN_SRC haskell
       zipWith (+) [1, 2, 3] [10, 11, 12]
       -- [11, 13, 15]

       zipWith (==) ['a'..'f'] ['a'..'m']
       -- [True, True, True, True, True, True]
     #+END_SRC

*** DONE Zipping exercises - 337
    CLOSED: [2017-05-31 Wed 23:16]
    #+BEGIN_SRC haskell
      -- 1
      myZip :: [a] -> [b] -> [(a, b)]
      myZip [] _ = []
      myZip _ [] = []
      myZip (x:xs) (y:ys) = (x, y) : myZip xs ys

      -- 2
      myZipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
      myZipWith f [] _ = []
      myZipWith f _ [] = []
      myZipWith f (x:xs) (y:ys) = (f x y) : (myZipWith f xs ys)

      -- 3
      myZip' = myZipWith (,)
    #+END_SRC

** DONE 9.12 Chapter Exercises - 338
   CLOSED: [2017-06-03 Sat 02:36]
*** DONE ~Data.Char~ - 338
    CLOSED: [2017-06-01 Thu 22:33]
    #+BEGIN_SRC haskell
      import Data.Char
      -- 1
      -- Prelude> :t isUpper
      -- isUpper :: Char -> Bool

      -- Prelude> :t toUpper
      -- toUpper :: Char -> Char


      -- 2
      filter isUpper "HbEfLrLxO"


      -- 3
      capitalize :: String -> String
      capitalize "" = ""
      capitalize (c:cs) = toUpper c : cs


      -- 4
      capitalizeAll :: String -> String
      capitalizeAll "" = ""
      capitalizeAll (c:cs) = toUpper c : capitalizeAll cs


      -- 5
      capitalHead :: String -> Char
      capitalHead "" = error "Empty string has no head"
      capitalHead (c:_) = toUpper c

      -- 6
      capitalHead' :: String -> Char
      capitalHead' str = head . capitalize $ str

      capitalHead'' :: String -> Char
      capitalHead'' = head . capitalize
    #+END_SRC

*** TODO Ciphers - 339
    #+BEGIN_SRC haskell
      import Data.Char

      -- A - Z 65 ~ 90
      -- a - z 97 ~ 122
      isNotLatin :: Char -> Bool
      isNotLatin char = not $ (codePoint `elem` [65..90]) || (codePoint `elem` [97..122])
        where
          codePoint = ord char

      generatorOfCaesarCodePoint :: Int -> Char -> Int
      generatorOfCaesarCodePoint shift c
        | isLower c && shiftedCodePoint > 122 =  shiftedCodePoint - 122 + (97 - 1)
        | isUpper c || shiftedCodePoint > 90 = shiftedCodePoint - 90 + (65 - 1)
        | otherwise = shiftedCodePoint
        where
          shiftedCodePoint = ord c + shift


      enCaesar :: Int -> String -> String
      enCaesar shift info = map enCaesarOneChar info
        where
          properShift = shift `mod` 26
          enCaesarOneChar char
            | isNotLatin char = char
            | otherwise = chr $ generatorOfCaesarCodePoint properShift char


      unCaesar :: Int -> String -> String
      unCaesar shift info = enCaesar (-shift) info
    #+END_SRC
*** DONE Writing your own standard functions - 340
    CLOSED: [2017-06-03 Sat 02:36]
    #+BEGIN_SRC haskell
      -- #1
      myOr :: [Bool] -> Bool
      myOr [] = False
      myOr (x:xs) = x || myOr xs

      -- #2
      myAny :: (a -> Bool) -> [a] -> Bool
      myAny f [] = False
      myAny f (x:xs) = f x || myAny f xs

      -- #3
      myElem :: Eq a => a -> [a] -> Bool
      myElem _ [] = False
      myElem e (x:xs) = e == x || (myElem e xs)

      myElem' :: Eq a => a -> [a] -> Bool
      myElem' e xs = any (e==) xs

      -- #4
      myReverse :: [a] -> [a]
      myReverse xs = go xs []
        where
          go [] ys = ys
          go (y:ys) zs = go ys (y:zs)

      -- #5
      squish :: [[a]] -> [a]
      squish [] = []
      squish (x:xs) = x ++ squish xs

      -- #6
      squishMap :: (a -> [b]) -> [a] -> [b]
      squishMap _ [] = []
      squishMap f (x:xs) = f x ++ squishMap f xs

      -- #7
      squishAgain :: [[a]] -> [a]
      squishAgain = squishMap id

      -- #8
      myMaximumBy :: (a -> a -> Ordering) -> [a] -> a
      myMaximumBy f [x] = x
      myMaximumBy f (x:x':xs) = case f x x' of
        GT -> myMaximumBy f (x:xs)
        _ -> myMaximumBy f (x':xs)

      -- #9
      myMinimumBy :: (a -> a -> Ordering) -> [a] -> a
      myMinimumBy f [x] = x
      myMinimumBy f (x:x':xs) = case f x x' of
        LT -> myMaximumBy f (x:xs)
        _ -> myMaximumBy f (x':xs)

      myMaximum :: (Ord a) => [a] -> a
      myMaximum = myMaximumBy compare

      myMinimum :: (Ord a) => [a] -> a
      myMinimum = myMinimumBy compare

    #+END_SRC
 
** DONE 9.13 Definitions - 344
   CLOSED: [2017-05-31 Wed 23:31]
   1. /Product type/: a type made of a set of types _compounded_ over each other.

      In Haskell _represnet products_ using:
      + tuples
        or
      + data constructors with more than one argument.

      Product of types represents a conjunction, "and", of those types.

   2. /Sum type/: a type whose terms are terms in other types, but
      _NOT simultaneously_.

      In Haskell sume types are represented using the pipe, ~|~, in a datatype
      definition.

      Sums of types represents a disjunction, "or", of those types.

   3. /Cons/

   4. /Cons cell/: a data constructor and a product of the types ~a~ and ~[a]~
      as defined in the list datatype.

   5. /spine/: a way to refer to the structure that glues a collection of values
      together.

      In the list datatype it is formed by the recursive nesting of cons cells.

      It applies with tree data structures as well

** TODO 9.14 Follow-up resources - 346
   1. 
   2. 

* TODO 10 Folding lists - 347 - =Re-Read * N= TODO: NOTE
** DONE 10.1 Folds - 348
   CLOSED: [2017-06-01 Thu 18:46]
   - /Folding/ is a concept that extends in _usefulness_ and _importance_ BEYOUND
     /lists/.

     /Lists/ are just the data structure being _used to INTRODUCE_ this concpet
     in this chapter.

   - /Folds/ as a GENERAL concept are called /catamorphisms/.

   - The roots of the word /catamorphisms/:
     + *morphism* from _polymorphism_.
     + *cata-* means _"down"_ or _"against"_, as in "catacombs."

   - =EN=
     catacombs - 地下墓穴

   - Catamorphisms :: deconstructing data
     + Comment:
       It does *NOT* say the _structural reconstruction_ will *NOT* happen,
       though it is usually not

   - This chapter is a THOROUGH LOOK at the topic of _folding lists_ in Haskell.
     We will:
     + _what_ /folds/ are and _how_ /folds/ work;

     + the _evaluation processes_ of /folds/;

     + WALK THROUGH _the PROCESS of writing /folding/ functions_;

     + INTRODUCE ~scans~, functions that are _related to_ /folds/.

** DONE 10.2 Bringing you into the fold - 348
   CLOSED: [2017-06-01 Thu 18:59]
   - ~foldr~, rather than ~foldl~, is the /fold/ you'll MOST OFTEN want to use with
     /lists/.

   - The type of ~foldr~:
     + GHC 7.8 and older
       ~foldr \colon{}\colon{} (a -> b -> b) -> b -> [a] -> b~
       OR, the equivalent form,
       ~foldr \colon{}\colon{} (a -> b -> b) -> b -> [] a -> b~

     + GHC 7.10 and newer
       ~foldr \colon{}\colon{} Foldable t => (a -> b -> b) -> b -> t a -> b~:
       * GHC 7.10 and newer version *abstracted OUT* the _list-specific part_ of
         /folding/ *into* a /type class/
         that lets you reuse the same folding functions for *ANY /datatype/ that
         CAN BE FOLDED* — *not just lists.*

   - We can even recover the more concrete type
     because *we can _ALWAYS_ make a type more concrete, but _NEVER_ more generic:*
     #+BEGIN_SRC haskell
       listFoldr :: (a -> b -> b)
                 -> b
                 -> [] a
                 -> b
       listFoldr = foldr
     #+END_SRC
     + For _older verion_ of ghci, you need to add ~let~ to the front of the type
       line (the first line here).

   - Compare ~map~ and /fold/:
     + ~map   \colon{}\colon{} (a -> b) -> [a] -> [b]~ applies a function of type ~a -> b~ to
       each member, of type ~a~, of a /list/ and returns a /list/ of type ~[b]~.
       #+BEGIN_SRC haskell
         -- Remember how `map` worked?
         map (+1) 1  :       2  :      3  : []
             (+1) 1  :  (+1) 2  : (+1) 3  : []
       #+END_SRC
       1. *Apply* the _mapping function_ to _EACH_ element of the list;

       2. *Keep* the /cons/ operator, and use it to *combine* the calculated values;

       3. Get a list with modified inside values.
          The /type/ of those values _depends on_
          * The _mapping function_

          * the /type/ of the _ORIGINAL values_ in the passed in list

     + /fold/ _replaces_ the *cons constructors* (~:~) _with_ the *function*
       ~(a -> b -> b)~ and _reduces_ the /list/:
       #+BEGIN_SRC haskell
         -- Given the list
         foldr (+) 0 (1 : 2 : 3 : [])
                      1 + (2 + (3 + 0))
       #+END_SRC
       1. *Replace* the _constructor_ of the /foldable data structure/ *with* the
          _folding function_;

       2. Use _folding function_ to *reduce* the /foldable structure/ argument;

       3. get a *SINGLE value*, whose /type/ _depends on_
          * the type of the original value in the passed in foldable structure

          * the passed in initial value

          * the operator used to replace the constructor

** DONE 10.3 Recursive patterns - 350
   CLOSED: [2017-06-01 Thu 19:19]
   - Let's see some recursion functions we wrote:
     #+BEGIN_SRC haskell
       sum :: [Integer] -> Integer
       sum []     = 0
       sum (x:xs) = x + sum xs

       length :: [a] -> Integer
       length []     = 0
       length (_:xs) = 1 + length xs


       product :: [Integer] -> Integer
       product []     = 1
       product (x:xs) = x * product xs

       concat :: [[a]] -> [a]
       concat []     = []
       concat (x:xs) = x ++ concat xs
     #+END_SRC

     + The _base case_ is _the identity_.

     + Also, each of them has a main function with a /recursive pattern/
       that *associates to the right*:
       The /head/ of the list gets evaluated, set aside, and then the function
       moves to the right, evaluates the next /head/, and so on.

** DONE 10.4 Fold right - 351
   CLOSED: [2017-06-01 Thu 22:02]
   ~foldr~ is called _fold right_ because THIS /fold/ is _right associative_.

   This is syntactically reflected in a straightforward definition of ~foldr~ as
   well:
   #+BEGIN_SRC haskell
     foldr :: (a -> b -> c) -> b -> [a] -> b
     foldr f z [] = z
     foldr f z (x:xs) = f x (foldr f z xs)
   #+END_SRC

   + The "rest of the fold," ~(foldr f z xs)~ is an argument to the function ~f~
     we're folding with.

   + The ~z~ is the /zero value/ of our /fold/, and it is often the /identity/ for
     the _folding function_, such as 0 for ~(+)~ and 1 for ~(*)~.

     It provides a /fallback value/ for the empty list case, or more general,
     the base case.
     
*** DONE How ~foldr~ evaluates - 351
    CLOSED: [2017-07-08 Sat 01:29]
    - Re-write our simple ~foldr~ definition (only works for lists) with
      ~case ... of~, pass concrete arguments to it, evaluate it step by step, and
      then you can see some indented code, which is clearer for you to understand
      the evaluation processes of the ~foldr~.
      #+BEGIN_SRC haskell
        foldr :: (a -> b -> b) -> b -> [a] -> b
        foldr f z xs =
          case xs of
            [] -> z
            (x:xs) -> f x (foldr f z xs)
      #+END_SRC

      + Evaluation Steps:
        #+BEGIN_SRC haskell
          ------------------
          -- The First Step
          foldr (+) 0 [1, 2, 3] =
            case [1, 2, 3] of
              []           -> 0
              (1 : [2, 3]) ->
                (+) 1 (foldr (+) 0 [2, 3])

          ------------------
          -- The Second Step
          foldr (+) 0 [2, 3] =
            case [2, 3] of
              []           -> 0
              (2 : [3]) ->
                (+) 2 (foldr (+) 0 [3])

          ------------------
          -- The Third Step
          foldr (+) 0 [3] =
            case [3] of
            []     ->
              0 -- this didn't match again
            (3 : []) -> (+) 3 (foldr (+) 0 [])

          ------------------
          -- The Last Step
          foldr (+) 0 [] =
            case [] of
            []     ->
              0 --<-- This one finally matches
            -- ignore the other case, didn't happen
        #+END_SRC
        =IMPORATN=
        =IMPORATN=
        =IMPORATN=
        =Re-Write Notes=
        * There is ~(+) 1~ IMPLICITLY wrapped around this /continuation/ of the
          recursive /fold/.

        * *SUBTLTY* =IMPORTANT=
          (This subtlty comes from the /laziness/ of Haskell!)

          This /fold/ can continuously do the reduction to consume the whole
          list because of
          1. ~(\plus{})~ is /strict/ to its two parameters.
             If NOT, ~1~ will be returned.

          2. ~(\plus{})~ is /unconditional/ to its second parameter.
             If NOT, ~1~ may or may not be returned. It depends on the condition.

          The second condition is NOT always the case, but it is the case for this
          example. One such function, that has conditional operation, is ~const~
          which always returns the first argument (this is also special).

    - =IMPORTANT=
      A trick popularized by some helpful users in the Haskell IRC community (see
      footnote https://wiki.haskell.org/Fold#Examples):

      A method used to *show the process of ~foldr~:*
      #+BEGIN_SRC haskell
        xs = map show [1..5]
        y = foldr (\x y -> concat ["(",x,"+",y,")"])
                  "0"
                  xs

        ---- Evaluate `y`, and you'll get
        -- "(1+(2+(3+(4+(5+0)))))"
      #+END_SRC

    - One initially non-obvious aspect of folding is that it happens in _TWO_
      stages:
      + /traversal/: *recurse* over the /spine/.
        and

      + /folding/: *evaluation* or *reduction* of the /folding function/ applied
        to the values.

    - ALL folds *recurse* over the /spine/ _in the same direction_; =IMPORTANT=

      the _DIFFERENCE_ between /left folds/ and /right folds/ is
      in _the association of the folding function_ and, thus, which direction the
      folding or reduction proceeds.

    - Look at part of the definition of ~foldr~:
      ~foldr f z (x:xs) = f x (foldr f z xs)~
      If ~f~ doesn't evaluate its second argument (rest of the /fold/),
      *no more of the /spine/ will be forced*.

      _Since Haskell is /lazy/ by default, non-immediate evaluation can happen
      often._ One of the CONSEQUENCES of this is that ~foldr~ can *avoid*
      evaluating
      + NOT ONLY some or all of the /values/ in the list,

        which means ~foldr~ can be used with foldable data that are potentially
        infinite (though sometimes it can only reach the /bottom/). For example:
        #+BEGIN_SRC haskell
          myAny :: (a -> Bool) -> [a] -> Bool
          myAny f xs =
            foldr (\x b -> f x || b) False xs

          myAny even [1..]
          -- True

          myAny even (repeat 1)
          -- -- NEVER-ENDING
          -- -- reach the bottom
        #+END_SRC

      + BUT ALSO some or all of the list's /spine/ as well!
        =IMPORTANT=
        More examples:
        #+BEGIN_SRC haskell
          u = undefined

          -- #1
          foldr (+) 0 [1, 2, 3, 4, u]
          -- -- *** Exception: Prelude.undefined

          -- #2
          foldr (+) 0 (take 4 [1, 2, 3, 4, u])
          -- 10

          -- #3
          -- Here, the `undefined` is part of the spine
          foldr (+) 0 ([1, 2, 3, 4] ++ u)
          -- -- *** Exception: Prelude.undefined

          -- #4
          foldr (+) 0 (take 4 ([1, 2, 3, 4] ++ u))
          -- 10
        #+END_SRC
        * For #1, this expression _requires_ the evaluation of ~u~, which is
          ~undefined~.
        * This run into /bottom/.

        * For #2, this expression _DOESN'T require_ the evaluation of ~u~.

        * For #3, here ~u~ is a part of the spine.

          Here the evaluation of ~u~ is required. _However_, even if the inside
          values evaluation DOESN'T required, since ~u~ is part of the /spine/,
          the _Exception_ will be thrown out.

        * For #4, even if ~u~ is a part of the /spine/, with ~take~, this part of
          /spine/ won't be visited, and no _Exception_.

    - Sometimes, the /spines/ will be evaluated _unconditionally_, but not the
      values:
      #+BEGIN_SRC haskell
        length [1, 2, 3, 4, undefined]
        -- 5

        length ([1, 2, 3, 4] ++ undefined)
        -- *** Exception: Prelude.undefined
      #+END_SRC

      However, we can still drop this part of /spine/ (as in #4 the last example):
      #+BEGIN_SRC haskell
        length (take 4 ([1, 2, 3, 4] ++ undefined))
        -- 4
      #+END_SRC

    - ~take~ is non-strict like everything else you've seen so far.
      #+BEGIN_SRC haskell
        xs = [1, 2] ++ undefined
        length $ take 2 $ take 4 xs
        -- 2
      #+END_SRC
      It doesn't matter that if there only ~take 4~ it could've hit the /bottom/!
      Nothing forced it to because of the ~take 2~ between it and length.

    - Focus on one part of the definition of ~foldr~
      ~foldr f z (x:xs) = f x (foldr f z xs)~,
      and you can see the /pattern matching/ of ~x~. We know
      /pattern matching/ is _strict by default_.

      This means ~foldr~ must force the initial /cons cell/ in order to
      discriminate between the ~[]~ (the base case) and the ~(x : xs)~,
      _so the *first* /cons cell/ *CANNOT* be ~undefined~._

      For example,
      Here, ~foldr~ will *never force* evaluation of any of its arguments, so we
      can have a /bottom/
      + as a value
        or
      + as part of the /spine/,
      and it will not force an evaluation:
      #+BEGIN_SRC haskell
        -- Prelude> foldr (\_ _ -> 9001) 0 [1..5]
        -- 9001

        -- Prelude> foldr (\_ _ -> 9001) 0 [1, 2, 3, undefined]
        -- 9001

        -- Prelude> foldr (\_ _ -> 9001) 0 ([1, 2, 3] ++ undefined)
        -- 9001
      #+END_SRC

      Everyting is fine unless the first piece of the /spine/ in /bottom/:
      #+BEGIN_SRC haskell
        -- #1
        -- Prelude> foldr (\_ _ -> 9001) 0 undefined
        -- *** Exception: Prelude.undefined

        -- #2
        -- Prelude> foldr (\_ _ -> 9001) 0 [1, undefined]
        -- 9001

        -- #3
        -- Prelude> foldr (\_ _ -> 9001) 0 [undefined, undefined]
        -- 9001
      #+END_SRC
      #2 and #3 work well because the cons cells contain /bottom/ values
      but are _not themselves /bottom/._
      =IMPORTANT=

      #1 throws _Exception_ because ~undefined~ of it is the /cons cell/ itself.

    - =TODO= We will experiment later with /nonstrictness/ and /strictness/ to
      see how it affects the way our programs evaluate.

    - Traversing the rest of the /spine/ _doesn't_ occur
      unless the function asks for the results of having folded the rest of the
      list.

      In the following examples, we do _NOT force traversal_ of the /spine/ because
      ~const~ just throws away its second argument,
      _which is the rest of the fold_:
      #+BEGIN_SRC haskell
        -- reminder:
        -- const :: a -> b -> a
        -- const x _ = x

        -- Prelude> const 1 2
        -- 1

        -- Prelude> const 2 1
        -- 2

        -- Prelude> foldr const 0 [1..5]
        -- 1

        -- Prelude> foldr const 0 [1, undefined]
        -- 1

        -- Prelude> foldr const 0 ([1, 2] ++ undefined)
        -- 1

        -- Prelude> foldr const 0 [undefined, 2]
        -- *** Exception: Prelude.undefined
      #+END_SRC

** DONE 10.5 Fold left - 359
   CLOSED: [2019-04-21 Sun 18:12]
   The definition of ~foldl~ (simplified for ~List~ only):
   #+BEGIN_SRC haskell
     foldl :: (b -> a -> b) -> b -> [a] -> b
     foldl f acc [] = acc
     foldl f acc (x:xs) = foldl f (f acc x) xs

     -- Given the list
     foldl (+) 0 (1 : 2 : 3 : [])

     -- foldl associates like so
     ((0 + 1) + 2) + 3
   #+END_SRC

   - Because of the way /lists/ work,
     /folds/ MUST
     1. recurse over the /spine/ of the /list/ from the beginning to the end
        (consider the way /list/ is implemented in Haskell, this is left to
        right).

     2. /Left folds/ traverse the /spine/ *in the _SAME direction_ as /right folds/,*
        BUT their folding process is
        + *left associative*
          and
        + proceeds in the opposite direction as that of ~foldr~.

   - Check the /associativity/ of ~foldl~ with the trick we metioned in the last
     section:
     #+BEGIN_SRC haskell
       let f = (\x y -> concat ["(", x, "+", y, ")"])
       foldl f "0" (map show [1..5])
       -- "(((((0+1)+2)+3)+4)+5)"
     #+END_SRC

   - /scan/'s are similar to /fold/'s
     but return a list of *all the itermediate stages* of the /fold/.
     #+BEGIN_SRC haskell
     -- Prelude> scanr (+) 0 [1..5]
     -- [15, 14, 12, 9, 5, 0]

     -- Prelude> scanl (+) 0 [1..5]
     -- [0, 1, 3, 6, 10, 15]
     #+END_SRC

   - The relationship between the /scan/'s and /fold/'s are as follows:
     + ~head (scanr f z xs)~ \equiv ~foldr f z xs~
     + ~last (scanl f z xs)~ \equiv ~foldl f z xs~

*** DONE Associativity and folding - 360
    CLOSED: [2017-06-03 Sat 22:47]
    - The fundamental way to think about evaluation in Haskell is as
      substitution:
      + _right fold_ on a list with the function ~f~ and start value ~z~
        * replacing the cons constructors with our folding function
          and
        * the empty list constructor with our start value ~z~:

      + _left fold_ on a list with the function ~f~ and start value ~z~
        =FROM JIAN= =TODO= =NOT FINISHED=
        * replacing the cons constructors with our folding function
          and
        * the first list constructor with our start value ~z~:

    - /Lazy evaluation/ lets our functions, rather than the ambient semantics of
      the language, dictate what order things get evaluated in.
      #+BEGIN_SRC haskell
        foldr f z [1, 2, 3]
        -- 1 `f` (foldr f z [2, 3])
        -- 1 `f` (2 `f` (foldr f z [3]))
        -- 1 `f` (2 `f` (3 `f` (foldr f z [])))
        -- 1 `f` (2 `f` (3 `f` z))
      #+END_SRC

      ~3 `f` z~ pairing gets evaluated first because it’s in the innermost
      parentheses.

        Right folds have to traverse the list outside-in, but the folding itself
      starts from the end of the list.

    - Due to the /associativity/, if a /right associative operator/ is used,
      ~flip~ is required.
      For example,
      #+BEGIN_SRC haskell
        myReverse :: [a] -> [a]
        myReverse = foldl (flip (:)) []
      #+END_SRC


    - The effect of associativity on argument order by folding the list into a
      new list.
      #+BEGIN_SRC haskell
        foldr (:) [] [1..3]
        -- [1,2,3]

        foldl (flip (:)) [] [1..3]
        -- [3,2,1]
      #+END_SRC

    - Even when we've satisfied the types by flipping things around,
      the *left-associating nature* of ~foldl~ leads to a different result from
      that of ~foldr~.

    - Compare the types of ~foldr~ and ~foldl~:
      + ~foldr \colon\colon Foldable t => (a -> b -> b) -> b -> t a -> b~
      + ~foldl \colon\colon Foldable t => (b -> a -> b) -> b -> t a -> b~
      Then from the type of right associative operators, such as
      ~(:) :: a -> [a] -> [a]~ which can also be written as ~a -> b -> b~, we
      know why, when the first argument of ~foldl~ is operators like ~(:)~, we
      need ~flip~.

    - The spine traversal happens in the same order in both the left and right
      folds for a list, because of the way lists are defined.

    - If your folding function is _NOT commutative_,
      a left fold can lead to a different result than a right fold of the same.

*** DONE Exercises: Understanding folds - 364
    CLOSED: [2017-06-04 Sun 00:33]
    1. b) and c)

    2. =(3 * (2 * (1 * 1))=

    3. b) c) =TODO=  See next section =TODO=

    4. a)

    5. Fix them:
       #+BEGIN_SRC haskell
         -- a)
         foldr (++) "" ["woot", "WOOT", "woot"]

         -- b)
         foldr max 'f' "fear is the little death"

         -- c)
         foldr (&&) True [False, True]

         -- d)
         -- It always returns `True`

         -- e)
         foldl (\x y -> x ++ show y) "" [1..5]

         -- for `foldr const`, the return type should be the element of the
         -- foldable structre.
         --
         -- f) the second parameter should be of type class `Num` and `Enum`
         -- g) the second parameter should be `Char`
         -- h) the second parameter should be `Char`
         -- h) the second parameter should be of type class `Num` and `Enum`

         -- f)
         foldr const 0 [1..5]

         -- g)
         foldr const 'a' "tacos"

         -- h)
         foldl (flip const) '0' "burritos"

         -- i)
         foldl (flip const) 0 [1..5]
       #+END_SRC

*** DONE Unconditional spine recursion - 366
    CLOSED: [2019-04-21 Sun 18:11]
    - An important difference between ~foldr~ and ~foldl~:

      ~foldl~: has the successive steps of the fold as its first argument.
      The next recursion of the spine isn't intermediated by the folding function
      as it is in ~foldr~, which also means recursion of the spine is
      _unconditional_.
        This can be seen from the non-empty pattern matching part
      their definition:
      #+BEGIN_SRC haskell
        foldr f z (x:xs) = f x (foldr f z xs)

        foldl f z (x:xs) = foldl f (f z x) xs
      #+END_SRC
      It is clear that for ~foldr~, that
      =TODO= 

      #+BEGIN_SRC haskell
        -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        -- foldr
        -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

        foldr const 0 ([1..5] ++ undefined)
        -- 1

        foldr (flip const) 0 ([1..5] ++ undefined)
        -- *** Exception: Prelude.undefined

        foldl const 0 ([1..5] ++ undefined)
        -- *** Exception: Prelude.undefined

        foldl (flip const) 0 ([1..5] ++ undefined)
        -- *** Exception: Prelude.undefined


        -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        -- foldl
        -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        foldl (\_ _ -> 5) 0 ([1..5] ++ undefined)
        -- *** Exception: Prelude.undefined

        -- COMMENT:
        -- -- error because bottom is part of the spine
        -- -- and foldl must evaluate the spine


        foldl (\_ _ -> 5) 0 ([1..5] ++ [undefined])
        -- 5

        -- COMMENT:
        -- this is OK because here bottom is a value
      #+END_SRC

    - *In most cases*, when you need a left fold,
      _you should use ~foldl'~ instead of ~fold~!_
        It works the same as ~foldl~ except it is _strict_!!! 
      In other words, it forces evaluation of the values inside /cons cells/ as
      it traverses the /spine/, rather than accumulating unevaluated expressions
      for each element of the list.
        The *strict evaluation* here means it has less negative effect on
      perfromance over long lists.

    - =from Jian=
      This section discusses the effect of /laziness/ to ~foldl~ a lot.
      Without /laziness/ (in other languages), /fold left/ is mostly prefered
      (if there is TCO).

** TODO 10.6 How to write fold functions - 367
   - x

*** TODO Exercises: Database processing - 370

** TODO 10.7 Folding and evaluation - 372
   - x

** DONE 10.8 Summary - 375 - =RE-READ=
   CLOSED: [2019-04-22 Mon 01:28]
   The executive summary:
   =from Jian=
   Because of /laziness/, this summary is *complete different* in other
   strict/eager languages.

   - ~foldr~ ::
     1. =???= =???= =???=
        =TODO= TODO =TODO=

     2. Associates to the right.

     3. Works with infinite lists (=from Jian= for "proper" first parameter).
        For instance, the result of ~foldr const 0 [1..]~ is ~1~.

     4. Is a good default choice _WHENEVER you want to *transform* data structures_,
        _be they finite or infinite_.

   - ~foldl~ ::
    1. Self-calls (tail-call) through the list,
       ONLY beginning to produce values after reaching the end of the list.

    2. Associates to the left.

    3. _CANNOT be used with infinite lists._

    4. Is nearly useless and should almost always be replaced with ~foldl'~ for
       reasons =TODO= we'll explain later when we talk about writing efficient
       Haskell programs.

** TODO 10.9 Scans - 375
   - x

*** TODO Getting the Fibonacci number we want - 377
*** TODO Scans Exercises - 378

** DONE 10.10 Chapter Exercises - 374
   CLOSED: [2017-06-06 Tue 01:46]
*** DONE Warm-up and review - 378
    CLOSED: [2017-06-06 Tue 01:44]
    #+BEGIN_SRC haskell
      -- 1
      stops = "pbtdkg"
      vowels = "aeiou"

      -- a)
      threeTuples :: String -> String -> [(Char, Char, Char)]
      threeTuples stops' vowels' =
        [(s, v, s') | s <- stops', v <- vowels', s' <- stops']

      -- b)
      threeTuplesWithStartP :: String -> String -> [(Char, Char, Char)]
      threeTuplesWithStartP stops' vowels' =
        [(s, v, s') | s <- stops', v <- vowels', s' <- stops', s == 'p']

      -- c)
      -- easy


      -- 2
      -- The average number of letters per word
      seekritFunc :: String -> Int
      seekritFunc x =
        div (sum $ map length wordList)
            (length wordList)
        where
          wordList = words x


      -- 3
      -- Can't rewrite with fractional division (/) directly,
      -- because 'length' returns a 'Int' value, and 'Int' isn't an instance of
      -- the type class 'Fractional', which is required by (/)
    #+END_SRC

*** TODO Rewriting functions using folds - 379
    #+BEGIN_SRC haskell
      -- 1
      myOr :: [Bool] -> Bool
      myOr = foldr (||) False


      -- 2 -- avoid using 'map'
      myAny :: (a -> Bool) -> [a] -> Bool
      myAny f = foldr g False
        where
          g x y = f x || y


      -- 3 -- avoid using 'map'
      myElem :: Eq a => a -> [a] -> Bool
      myElem e = foldr g False
        where
          g x y = (e==x) || y

      myElem' :: Eq a => a -> [a] -> Bool
      myElem' e = any (e==)


      -- 4
      myReverse :: [a] -> [a]
      myReverse = foldl (flip (:)) []


      -- 5
      myMap :: (a -> b) -> [a] -> [b]
      myMap f = foldr (\x y -> f x : y) []


      -- 6
      myFilter :: (a -> Bool) -> [a] -> [a]
      myFilter f = foldr g []
        where
          g x y
            | f x = x : y
            | otherwise = y


      -- 7
      squish :: [[a]] -> [a]
      squish = foldr (++) []


      -- 8
      squishMap :: (a -> [b]) -> [a] -> [b]
      squishMap f = foldr (\x y -> f x ++ y) []


      -- 9
      squishAgain :: [[a]] -> [a]
      squishAgain = squishMap id


      -- 10
      -- TODO: can't be point-free.
      myMaximumBy :: (a -> a -> Ordering) -> [a] -> a
      myMaximumBy comp xs = foldr g (head xs) xs
        where
          g x y = case comp x y of
            GT -> x
            otherwise -> y


      -- 11
      -- TODO: can't be point-free.
      myMinimumBy :: (a -> a -> Ordering) -> [a] -> a
      myMinimumBy comp xs = foldr g (head xs) xs
        where
          g x y = case comp x y of
            LT -> x
            otherwise -> y
    #+END_SRC

** DONE 10.11 Definitions - 383
   CLOSED: [2017-06-06 Tue 12:36]
   1. /Fold/: a group of higher-order functions which, given
      + a function to accumulate the results
        and
      + a recursive data structure,
      returns the built up value.

      The term /fold/ is typically used with reference to collections of values
      referenced by a recursive datatype.
        /catamorphism/ is a generalization of "breaking down structure".

   2. /Catamorphism/: a generalization of folds to arbitrary datatypes.

      Where a /fold/ allows you to break down a foldable data structure into an
      arbitrary datatype,
      a /catamorphism/ is a means of breaking down the structure of any datatype.

      For example,
      + ~bool \colon{}\colon{} a -> a -> Bool -> a~ from ~Data.Bool~ is an example of a simple
        catamorphism for simple, non-collection datatype.

      + ~maybe \colon{}\colon{} b -> (a -> b) -> Maybe a -> b~ is the catamorphism for ~Maybe~.

   3. /tail call/: the final result of a function.
      For example,
      #+BEGIN_SRC haskell
        f x y z = h (subFunction x y z)
          where subFunction x y z = g x y z

        -- the /tail call/ is ``h (subFunction x y z)''
        -- or more precisely, ``h''.
      #+END_SRC

   4. /Tail recursion/: a function whose tail calls are recursive invocations of
      itself.

** TODO 10.12 Follow-up resources - 384
   1. 
   2. 
   3. 
   4. 

* DONE 11 Algebraic Datatypes - 385
  CLOSED: [2017-07-21 Fri 22:41]
** DONE 11.1 Algebraic datatypes - 386
   CLOSED: [2017-06-05 Mon 13:40]
   - A type can be thought of as an enumeration of constructors that have zero or
     more arguments.

   - Haskell offers:
     + sum types
     + product types
     + product types with record syntax =TODO=
     + type alias
     + a special datatype called a ~newtype~ that offers a different set of
       options and constraints from either type synonyms or data declarations.

   - This chapter will:
     + explain the "algebra" of algebraic datatypes;
     + analyze the construction of data constructors;
     + spell out when and how to write your own datatypes;
     + clarify usage of type synonyms and ~newtype~;
     + introduce kinds.

** DONE 11.2 Data declarations review - 386
   CLOSED: [2017-06-05 Mon 13:56]
   - Q: Why we always want to create custom datatypes?
     A: For structuring and describing the data we are processing.

     Doing so can
     + help you analyze your problem by allowing you to
       focus first on how you _model_ the domain
       _before_
       you begin thinking about how you write computations that solve your
       problem.

     + make your code easier to read and use
       because it lays the domain model out clearly.

   - Synonyms: /data declartion/ and /a declaration of a datatype/.

   - /nullary/ constructor: a no arguments constructor

   - /sum type/

   - /product type/

** DONE 11.3 Data and type constructors - 388
   CLOSED: [2017-06-06 Tue 18:48]
   - There are two kinds of constructors in Haskell:
     + type constructors, which is used only
       * at the type level
       * in type signatures
       * type class declarations and instances.

       Types are static and resolve at compile time.

     + data constructors, which constructs the values at term level, values you
       can interact with at runtime.

   - /constants/: Type and data constructors that take no arguments.
     /constructurs/: ... the other constructors.

   - When a constructor (in general meaning) takes an argument, then it's _like a
     function_ in at least one sense – it must be applied to become a concrete
     type or value.

   - /nullary/: The Haskell Report calls /nullary/ as /type constants/ to
     distinguish them from type constructors that take arguments.

   - synonyms: /value space/, /term space/, and /runtime space/.

   - =TODO= type-level functions exist but are not covered in this book.
     See the foot note of this page 385!

   - Again, (in narrow sense) /constructor/ doesn't behave like a term level
     function in the sense of performing an operation on data.
     It's more like a box to put values into.

     The former means to process data and generate new data.
     The latter means to wrap something.
     In general sense, 

   - =TODO= Be careful with the box/container analogy as it will betray you later
     – not all type arguments to constructors have value-level witnesses!
     Some are /phantom/. We will cover this in a later chapter.

** DONE 11.4 Type constructors and kinds - 390
   CLOSED: [2017-06-06 Tue 18:53]
   - /kind/

   - ~:kind~ or ~:k~: query the kind signature of a type constructor (NOT a data
     constructor) in GHCi.

   - A /kind/ signature ~*~ means the tested type constructor is a /type constant/;

     A /kind/ signature arrow(s) (like ~* -> *~) means the tested type
     constructor is a /type constructor/.

** DONE 11.5 Data constructors and values - 391
   CLOSED: [2017-06-06 Tue 19:24]
   - As metioned the Haskell Report draws a distinction between
     /(type) constants/ and /(type) constructors/.
       We can draw a similar distinction between
     + data constructors
       and
     + constant values.

   - /phanton/: =TODO= later
     For example, here the type argument ~a~ is /phantom/.
     #+BEGIN_SRC haskell
       data HuskyType a = HuskyData
     #+END_SRC

   - /Data constructor/ can have the same name as its /type constructor/.

   - A simple but comprehensive example:
     #+BEGIN_SRC haskell
       data Doggies a =
           Husky a
         | Mastiff a
         deriving (Eq, Show)

       -- Prelude> :k Doggies
       -- Doggies :: * -> *
       -- this needs to be applied to become a
       -- concrete type

       -- Prelude> :t Husky
       -- Husky :: a -> Doggies a
       -- this needs to be applied to become a
       -- concrete value
     #+END_SRC

*** DONE Exercises: Dog types - 394
    CLOSED: [2017-06-06 Tue 19:24]
    1. A: a type constructor
    2. A: ~* -> *~
    3. A: ~*~
    4. A: ~Num a => Doggies a~
    5. A: ~Doggies Integer~
    6. A: ~Doggies String~
    7. A: It depends where it is: it's a type constructor in type-level, and it's
       a data constructor in term-level.
    8. A: ~a -> DogueDeBordeaux a~
    9. A: ~DogueDeBordeaux String~

** DONE 11.6 What's a type and what's data? - 395
   CLOSED: [2017-06-08 Thu 23:03]
   - Types are static and resolve at compile time.
     Types are known before runtime.
     That's why we call them _static_ types.

   - Types circumscribe values and in that way, they describe which values are
     flowing through what parts of your program.

     type constructors -- compile-time

     -------------------- phase separation

     data constructors -- runtime

   - _Both_ data constructors and type constructors begin with capital
     letters,
     _but_
     + a constructor _before_ the ~=~ in a datatype definition is a
       /type constructor/,
     + while constructors after the ~=~ are _data constructors_.

     Data constructors are usually generated by the declaration.

     _One tricky bit_ here is:
     when data constructors take arguments, those arguments refer to other
     types.
       Because of this, not everything referred to in a datatype declaration is
     necessarily generated by that datatype itself. For example,
     #+BEGIN_SRC haskell
       data Price = Price Integer deriving (Eq, Show)
     #+END_SRC
     The value ~Price~
     + does NOT depend solely on this datatype definition.
     + also depends on the type ~Integer~ as well.

     If ~Integer~ wasn't in scope, we'd be unable to generate ~Price~ values.

   - A type that is solely generated by its declaration:
     #+BEGIN_SRC haskell
       data Manufacturer =
           Mini
         | Mazda
         | Tata
         deriving (Eq, Show)
     #+END_SRC

   - A type that are not solely generated  by its declaration (also by some types
     outside the declaration).

   - In standard Haskell, you _CAN'T_ choose specific values of types as type
     arguments.

*** DONE Exercises: Vehicles - 397
    CLOSED: [2017-06-08 Thu 23:03]
    1. 
    2. 
    3. 
    4. 
    5. 

** DONE 11.7 Data constructor arities - 398
   CLOSED: [2017-06-08 Thu 23:35]
   - /arity/: the number of arguments a function or constructor takes.

   - A function/constructor that takes no arguments is called /nullary/.
     (the "-ary" suffix means "of or pertaining to")

   - /unary/

   - /products/: data constructors that take _more than one_ argument.

   - Tuples are considered the _cononical product type_;
     They are /anonymous products/ because they have no name.

** DONE 11.8 What makes these datatypes algebraic? - 401
   CLOSED: [2017-06-09 Fri 00:01]
   - /Algebraic datatypes/ in Haskell are algebraic
     because we can describe the patterns of argument structures using _TWO_
     basic operations:
     + sum
     + product.

   - The /cardinality/ of a datatype is _the number of possible values_ it
     defines.

   - ~Int8~, ~Int16~, and ~Int32~ are integer types that are NOT in ~Prelude~,
     Use ~import Data.Int~ to get them.

*** DONE Exercises: Cardinality - 402
    CLOSED: [2017-06-08 Thu 23:48]
    1. 
    2. 
    3. 
    4. 
    5. 

*** DONE Simple datatypes with nullary data constructors - 403
    CLOSED: [2017-06-08 Thu 23:53]

*** DONE Exercises: For Example - 403
    CLOSED: [2017-06-08 Thu 23:58]
    1. (a) ~Example~
       (b) =<interactive>:1:1: error: Data constructor not in scope: Example=

    2. =TODO= [safe] below
       #+BEGIN_SRC haskell
         -- Prelude> :info Example
         -- data Example = MakeExample 	-- Defined at <interactive>:5:1
         -- instance [safe] Show Example -- Defined at <interactive>:5:37
       #+END_SRC

    3. ~Int -> Example~
       #+BEGIN_SRC haskell
         data Example = MakeExample Int
       #+END_SRC

*** DONE Unary constructors - 404
    CLOSED: [2017-06-09 Fri 00:01]
    - Datatypes that ONLY contain a /unary constructor/ ALWAYS have the
      _SAME cardinality_ as the type they contain.

      For cardinality this means unary constructors are the identity function.

** DONE 11.9 [ =Re-READ= ] ~newtype~ - 404
   CLOSED: [2017-07-05 Wed 21:37]
   - A way to define a type that can _ONLY ever have a single_ unary data
     constructor -- ~newtype~.

   - It is obvious that a ~newtype~ declared type _CANNOT_:
     + be a product type
     + be a sum type
     + contain nullary constructors.

     but it has _a few advantages_ over a vanilla ~data~ declaration:
     =IMPORTANT=
     _NO runtime overhead_,
     as it reuses the represnetation of the type it contains.

     It can do this because it's _NOT_ allowed to be
     + a record (product type)
       or
     + tagged union (sum type).

   - The difference between ~newtype~ and the type it contains is gone by the
     time the compiler generates the code.

   - An example:
     We want to write a function to test if there are too many goats, but we
     don't want to mix the count of goats with the conut of cows (or other
     animals).
     #+BEGIN_SRC haskell
       -- A version that has a potential problem of
       --   mixing the count of goats with the count of cows (or later animals).
       tooManyGoats' :: Int -> Bool
       tooManyGoats' n = n > 42

       -- A `newtype` version that can help to get rid of the mix-up problem.
       newtype Goats = Goats Int deriving (Eq, Show)
       newtype Cows = Cows Int deriving (Eq, Show)

       tooManyGoats :: Goats -> Bool
       tooManyGoats (Goats n) = n > 42
     #+END_SRC

   - ~newtype~ can create a new type, this is like ~data~;

     ~newtype~ creates a 0-cost wrapped type -- consider the sematics, it's more
     like ~type~.

     Compare ~type~ with ~newtype~:
     + With the help of ~type~, an alias can be created.
       * ~type~ _helps people_:
         Alias a type to two (or more) names that have distinct semantics.

       * ~type~ _does NOT help the compiler_:
         These alias have NO distinction for the compiler.

     + With the help of ~newtype~, a new datatype created, which, however, can be
       considered an special type of alias.
       * ~newtype~ _helps compiler_:
         Compiler can distinct the ~newtype~ created one and the underlying type
         of a ~newtype~.

       * ~type~ also _helps people_:
         Literally (or semantically) it also create a new name which is distinct
         from the underlying type.

     + One KEY contrast:
       * One _CAN_ define type class instances for a ~newtype~ that differ from
         the instances for their underlying type.

       * One _CANNOT_ define type class for the ~type~ alias.

       An example:
       #+BEGIN_SRC haskell
         module TooMany where

         class TooMany a where
           tooMany :: a -> Bool

         instance TooMany Int where
           tooMany n = n > 42

         -- tooMany (42 :: Int)

         newtype Goats = Goats Int deriving Show

         instance TooMany Goats where
           tooMany (Goats n) = n > 43
       #+END_SRC

       A better example (=From Jian=):
       #+BEGIN_SRC haskell
         {-# LANGUAGE FlexibleInstances #-}
         {-# LANGUAGE UndecidableInstances #-}
         module TooMany where

         class TooMany a where
           tooMany :: a -> Bool

         instance Integral a => TooMany a where
           tooMany n = n > 42


         -- I CANNOT make this "ad-hoc polymorphism"
         -- Is there a way to do this?

         -- pragma `DatatypeContexts` is DEPRECATED, and it seems with its help
         --  "ad-hoc polymorphism" can be reached. =WHY=

         -- pragma `ExistentialQuantification` can help to make
         -- "ad-hoc polymorphism", BUT it only works with `data`!
         newtype Goats =
           Goats Int deriving Show

         instance TooMany Goats where
           tooMany (Goats n) = n > 43
       #+END_SRC

   - ~newtype~'s can use the common type classes built into GHC like ~Eq~, ~Ord~,
     ~Enum~, and ~Show~ of their _underlying types_ for free, as you've seen with
     the ~deriving~ clauses in most datatypes.

   - /language pragmas/: also called /extensions/, which are special instructions
     to the compiler. They tell the compiler to process input in ways beyond what
     the standard provides for.

   - A language pragma: ~GeneralizedNewtypeDeriving~
     Allow our ~newtype~ to rely on a type class instance for the type it contains.
     #+BEGIN_SRC haskell
       {-# LANGUAGE GeneralizedNewtypeDeriving #-}

       class TooMany a where
         tooMany :: a -> Bool

       instance TooMany Int where
         tooMany n = n > 42

       newtype Goats =
         Goats int deriving (Eq, Show, TooMany)
     #+END_SRC
     Here ~Goats~ derives an instance of ~Int~, which is its underlying type.

     You don't have to define an instance of ~TooMany~ for ~Goats~ that's
     merely identical to the ~Int~ instance.

     This is NOT allowed without the /pragma/.

     This is also nice for times when we want every type class instance to be the
     same _except_ for the one we want to change.

*** TODO Exercises: Logic goats - 408
    1. 
       #+BEGIN_SRC haskell
         {-# LANGUAGE FlexibleInstances #-}

         class TooMany a where
           tooMany :: a -> Bool

         instance TooMany (Int, String) where
           tooMany (i, _) = i > 42

         -- -- Test
         -- tooMany (3::Int, "Goats")
         -- False


         -- -- A more general implementation
         -- --
         -- instance Integral a => TooMany (a, String) where
         --   tooMany (i, _) = i > 42

         -- -- Test
         -- tooMany (3, "Goats")
         -- False


       #+END_SRC

    2. 
       #+BEGIN_SRC haskell
         {-# LANGUAGE FlexibleInstances #-}

         class TooMany a where
           tooMany :: a -> Bool

         instance TooMany (Int, Int) where
           tooMany (i, j) = i + j > 42

         -- -- Test
         -- tooMany (3 :: Int, 4 :: Int)
         -- False

         -- -- A more general implementation
         -- --
         -- instance Integral a => TooMany (a, a) where
         --   tooMany (i, j) = i + j > 42

         -- -- Test
         -- tooMany (3, 4)
         -- False
       #+END_SRC

    3. =TODO=
       #+BEGIN_SRC haskell
         {-# LANGUAGE FlexibleInstances #-}
         {-# LANGUAGE UndecidableInstances #-}

         class TooMany a where
           tooMany :: a -> Bool

         instance (Num a) => TooMany a where
           tooMany i = i > 42

         instance (Num a, TooMany a) => TooMany (a, a) where
           tooMany (i, j) = tooMany (i + j)
       #+END_SRC

** DONE 11.10 Sum types - 408
   CLOSED: [2017-06-09 Fri 01:21]
   - the ~|~ represents _logical disjunction_ -- that is, "or."
     This is the /sum/ in algebraic datatypes.

   - Add the cardinalities of their data constructors to get the cardinality of a
     sum type.

*** DONE Exercises: Pity the Bool - 410
    CLOSED: [2017-06-09 Fri 01:21]
    - 1 and 2 are easy

    - A wierd warning and the solution:
      #+BEGIN_SRC haskell
        import Data.Int

        data NumberOrBool =
            Numba Int8
          | BoolyBool Bool
          deriving (Eq, Show)

        myNumba = Numba (-128)

        -- Literal 128 is out of the Int8 range -128..127
        -- If you are trying to write a large negative
        --   literal, use NegativeLiterals
      #+END_SRC
      The above code should be perfectly legal, but you will receive a warning!

      + Reason: ~(-128)~ will be desugars into ~(negate 128)~. Since the compiler
                sees that you expect the type ~Int8~, but ~Int8~ has max boundary
                ~127~. Even though you're negating 128, it hasn't done that step
                yet.

      + Solution:
        #+BEGIN_SRC haskell
          n = (-128)
          x = Numba n

          -- OR

          -- Prelude> :set -XNegativeLiterals
          -- Prelude> let n = Numba (-128)
        #+END_SRC

    - 

** DONE 11.11 Product types - 411
   CLOSED: [2017-06-09 Fri 01:43]
   - A product type's /cardinality/ is the product of the cardinalities of its
     inhabitants.
*** DONE Record syntax - 412
    CLOSED: [2017-06-09 Fri 01:43]
    - /Records (in Haskell)/: product types with additional syntax to provide
      convenient accessors to fields within the record.

    - Define a product type with record syntax:
      #+BEGIN_SRC haskell
        data Person =
          Person { name :: String
                 , age :: Int }
          deriving (Eq, Show)
      #+END_SRC
      The above declaration is similar to a product type,
      but defining it as a record means there are now named record field
      accessors. They are just functions go from the product type to a member of
      product:
      #+BEGIN_SRC haskell
        -- Prelude> :t name
        -- name :: Person -> String

        -- Prelude> :t age
        -- name :: Person -> Int

        -- Prelude> Person "Papu" 5
        -- Person {name = "Papu", age = 5}


        -- Prelude> let papu = Person "Papu" 5

        -- Prelude> age papu
        -- 5

        -- Prelude> name papu
        -- "Papu"
      #+END_SRC

** DONE 11.12 [ =Re-Note= ] Normal form - 414
   CLOSED: [2017-07-08 Sat 03:01]
   - TODO Re-take Notes and send some suggestions to the author.

   - The /algebra/ behind Haskell's algebraic datatypes is NOT only related the
     to the /sum types/ and /product types/ to be used to calculate cardinality.

     All the existing algebraic rules for /products/ and /sums/ apply in type
     systems, and that includes the /distributive property/.

   - In normal arithmetic, the expression is in /normal form/ when it's been
     reduced to a final result.
     2 * (3 + 4)
     2 * 3 + 2 * 4
     6 + 8
     14
     The 14 here is the /normal form/.

     HOWEVER, if you think of the numerals in the above expression as
     representations of set cardinality, then the _sum of products expression_
     _2 * 3 + 2 * 4_ is in /normal form/, as there is no computation to perform.
     TODO =???=
     TODO =???=
     TODO =???=
     TODO =???=
     TODO =???=

     The distributive property can be generalized:
     a * (b + c)  ->  (a * b) + (a * c)

   - =TODO= PAGE 411  We define two types with only single, ...........
     It seems this paragraph is used to explain the example below, but I don't
     understand:

     Example:
     #+BEGIN_SRC haskell
       data Fiction = Fiction deriving Show
       data Nonfiction = Nonfiction deriving Show

       data BookType = FictionBook Fiction
                     | NonfictionBook Nonfiction
                     deriving Show

       type AuthorName = String

       -- This `Author` datatype is not in NORMAL FORM
       data Author = Author (AuthorName, BookType)
     #+END_SRC

     Below is the /normal form/. Since this definition is imcompatible with the
     datatype definitions ~Fiction~ and ~Nonfiction~ above, we write it in this
     separate code section.
     #+BEGIN_SRC haskell
       data Author =
           Fiction AuthorName
         | Nonfiction AuthorName
       deriving (Eq, Show)
     #+END_SRC

     + Q :: Why NOT use ~data BookType = Fiction | Nonfiction~ and DO NOT define
            the ~Fiction~ type and the ~Nonfiction~ type.

     + A :: You CAN use this way to get a same result, BUT it's actually some
            confusion in your mind. Let's re-write the above example to show you
            the confusion in your mind (here suffix ~'~ is used to indicate data
            constructor, or say non-type):
            #+BEGIN_SRC haskell
              data Fiction = Fiction' deriving Show
              data Nonfiction = Nonfiction' deriving Show

              data BookType = FictionBook Fiction
                            | NonfictionBook Nonfiction
                            deriving Show
            #+END_SRC
            Then we try to write out the defintion of ~Author~ step by step:

       * Step 0
         #+BEGIN_SRC haskell
           type AuthorName = String

           -- STEP 0
           data Author = Author' (AuthorName, BookType)
         #+END_SRC

         For factoring out the ~BookType~, we should replace it with the other
         datatypes. If we use ~BookType = Fiction' | Nonfiction'~ before, we CANNOT
         do this replacement here -- in this definition ~Fiction'~ and
         ~Nonfiction'~ are _NOT datatypes_, they are _data constructors_.
         We CANNOT replace a type with data constructors.

       * Step 1
         Use the logically reasonable definition of ~BookType~, and then we have
         #+BEGIN_SRC haskell
           -- Since we can't re-use data constructor `Author'`, make a tiny
           -- adjustment
           data Author =
               Author' (AuthorName, Fiction)
             | Author'' (AuthorName, Nonfiction)
         #+END_SRC

       * Step 2
         In Step 1, ~Author'~ and ~Author''~ are redundant -- we can distinguish
         those two cases through the information only inside parentheses.
         However,
         ~data Author = (AuthorName, Fiction) | (AuthorName, Nonfiction)~ is
         illegal. We can choose a equivalent but syntactically legal way to
         correct this.
         #+BEGIN_SRC haskell
           data Author =
               Fiction' AuthorName
             | Nonfiction' AuthorName
           deriving (Eq, Show)
         #+END_SRC
         One thing should be noticed is that in this step, datatypes ~Fiction~
         and ~Nonfiction~ is no longer there, data constructors ~Fiction'~ and
         ~Nonfiction'~ show up.

*** DONE Exercises: How does your garden grow? - 417
    CLOSED: [2017-06-09 Fri 02:02]
    #+BEGIN_SRC haskell
      data FlowerType = Gardenia'
                      | Daisy'
                      | Rose'
                      | Lilac'
                      deriving Show

      -- This is the final result. This result should be in a separate file, as it
      -- actually re-defined the data constructors show up in the definition of the
      -- datatype `FlowerType`.
      data Garden =
          Gardenia' Gardener
        | Daisy' Gardener
        | Rose' Gardener
        | Lilac' Gardener
        deriving Show

      -- ILLEGAL,
      -- 1. `Gardener` is a type, NOT a data constructor.
      -- 2. A data constructor CANNOT be re-used.
      data Garden =
          Gardener Gardenia
        | Gardener Daisy
        | Gardener Rose
        | Gardener Lilac
        deriving Show
    #+END_SRC

** DONE 11.13 Constructing and deconstructing values - 417
   CLOSED: [2017-06-11 Sun 03:11]
   #+BEGIN_SRC haskell
     data GuessWhat =
       Chickenbutt deriving (Eq, Show)

     data Id a =
       MkId a deriving (Eq, Show)

     data Product a b =
       Product a b deriving (Eq, Show)

     data Sum a b =
         First a
       | Second b
       deriving (Eq, Show)

     data RecordProduct a b =
       RecordProduct { pfirst :: a
                     , psecond :: b }
                     deriving (Eq, Show)
   #+END_SRC

*** DONE Sum and Product - 418
    CLOSED: [2017-06-11 Sun 03:11]
    _In ordinary Haskell code, it's unlikely you'd need or want nestable sums_
    _and products unless you were doing something fairly advanced, but here we_
    _use them as a means of demonstration._

    - Use nested ~Product~ and ~Sum~ types to develop an intuition about this
      structure to sum and product types.
      + ~Product~
      #+BEGIN_SRC haskell
        newtype NumCow =
          NumCow Int
          deriving (Eq, Show)

        newtype NumPig =
          NumPig Int
          deriving (Eq, Show)

        data Farmhouse =
          Farmhouse NumCow NumPig
          deriving (Eq, Show)

        type Farmhouse' = Product NumCow NumPig
        -- Farmhouse and Framhouse' are equivalent

        newtype NumSheep =
          NumSheep Int
          deriving (Eq, Show)

        data BigFarmhouse =
          BigFarmhouse NumCow NumPig NumSheep
          deriving (Eq, Show)

        type BigFarmhouse' =
          Product NumCow (Product NumPig NumSheep)
      #+END_SRC

      + ~Sum~
        #+BEGIN_SRC haskell
          type Name = String
          type Age = Int
          type LovesMud = Bool

          type PoundsOfWool = Int

          data CowInfo =
            CowInfo Name Age
            deriving (Eq, Show)

          data PigInfo =
            PigInfo Name Age LovesMud
            deriving (Eq, Show)

          data SheepInfo =
            SheepInfo Name Age PoundsOfWool
            deriving (Eq, Show)

          data Animal =
              Cow CowInfo
            | Pig PigInfo
            | Sheep SheepInfo
            deriving (Eq, Show)

          -- Alternately
          type Animal' =
            Sum CowInfo (Sum PigInfo SheepInfo)
        #+END_SRC

        We use ~First~ and ~Second~ to pattern match on the data constructors of
        ~Sum~

        #+BEGIN_SRC haskell
          -- Getting it right
          bess = First (CowInfo "Bess" 4) :: Animal'
          elmer' = Second (SheepInfo "Elmer" 5 5)
          elmer = Second elmer' :: Animal'

          -- Making a mistake
          elmo' = Second (SheepInfo "Elmo" 5 5)
          elmo = First elmo' :: Animal'
          --
          -- Couldn't match expected type ‘CowInfo’
          --             with actual type ‘Sum a0 SheepInfo’
          -- In the first argument of ‘First’, namely
          --   ‘(Second (SheepInfo "Elmo" 5 5))’
          -- In the expression:
          --   First (Second (SheepInfo "Elmo" 5 5)) :: Animal'
        #+END_SRC

        We can see why there is a mistake above:
        #+BEGIN_SRC haskell
          -- Prelude> :t First (Second (SheepInfo "Baaaaa" 5 5))
          -- First (Second (SheepInfo "Baaaaa" 5 5))
          --   :: Sum (Sum a SheepInfo) b 

          -- Prelude> :info Animal'
          -- type Animal' = Sum CowInfo (Sum PigInfo SheepInfo)
          --    -- Defined at code/animalFarm1.hs:61:1
        #+END_SRC

*** DONE Constructing values - 421
    CLOSED: [2017-06-11 Sun 02:15]
    - Nullery types:
      Sometimes we define a datatype has a singleton nullery data constructor.

      Types like this are sometimes used to signal discrete concepts that you
      don't want to flatten into the unit type.

      =TODO= Elaborate on how this can make code easier to understand or better
      abstracted later.

    - Unary types:
      #+BEGIN_SRC haskell
        data Id a =
          MkId a deriving (Eq, Show)

        -- note:
        -- MkId :: a -> Id a

        idInt :: Id Integer
        idInt = MkId 10
      #+END_SRC

    - _Try to avoid using type synonyms with unstructured data like text or
      binary._
      #+BEGIN_SRC haskell
        type Twitter = String
        type AskFm = String

        -- GHC can't distinguish the two alias of `String`

        twitter :: Sum Twitter AskFm
        twitter = First "Twitter"

        -- Uh oh
        askfm :: Sum Twitter AskFm
        askfm = First "AskFm"
      #+END_SRC

      Type synonyms are best used when you want something lighter weight than
      ~newtype~ but also want your type signatures to be more explicit.

    - Products that use record syntax:
      #+BEGIN_SRC haskell
        data RecordProduct a b =
          RecordProduct { pfirst :: a
                        , psecond :: b }
                        deriving (Eq, Show)

        -- Prelude> :t RecordProduct
        -- RecordProduct :: a -> b -> RecordProduct a b

        -- Prelude> :t Product
        -- Product :: a -> b -> Product a b
      #+END_SRC
      + The first thing to notice:
        you can construct values of products that use record syntax in a manner
        identical to that of non-record products (though you can't change the
        names of fields).

      + _Records are just syntax to create field references._ They don't do much
        heavy lifting in Haskell, but they are convenient.

      + Usage:
        #+BEGIN_SRC haskell
          myRecord :: RecordProduct Integer Float
          myRecord = RecordProduct 42 0.00001

          -- Or make things more obvious
          myRecord' :: RecordProduct Integer Float
          myRecord' = RecordProduct { pfirst = 42
                                    , psecond = 0.00001}
        #+END_SRC
    
*** DONE Exercise: Programmers - 426
    CLOSED: [2017-06-11 Sun 02:14]
    #+BEGIN_SRC haskell
      allProgrammers :: [Programmer]
      allProgrammers = [Programmer o l | o <- allOperatingSystems, l <- allLanguages]
    #+END_SRC

    - ~nub~ from ~Data.List~ is used to remove duplicate values.

*** DONE Accidental bottoms from records - 427
    CLOSED: [2017-06-11 Sun 02:24]
    #+BEGIN_SRC haskell
      -- Prelude> let partialAf = Programmer {os = GnuPlusLinux}
      --
      --     Fields of ‘Programmer’ not initialised: lang
      --     In the expression: Programmer {os = GnuPlusLinux}
      --     In an equation for ‘partialAf’:
      --         partialAf = Programmer {os = GnuPlusLinux}
      --
      -- and if we don't heed this warning...

      -- Prelude> partialAf
      -- Programmer {os = GnuPlusLinux, lang =
      -- *** Exception:
      --       Missing field in record construction lang
    #+END_SRC
    =FROM JIAN= Book didn't mention, and I find _NO_ way to make ~partialAf~
    complete.

*** DONE Deconstructing values - 429
    CLOSED: [2017-06-11 Sun 02:28]
    Pattern matching

*** DONE Accidental bottoms from records - 430
    CLOSED: [2017-06-11 Sun 03:10]
    - You can easily propagate bottoms through record types.
      DON'T do that.

    - An example (bad definitions lead to the case of reaching /bottom/): 
      #+BEGIN_SRC haskell
        data Automobile = Null
                        | Car { make :: String
                              , model :: String
                              , year :: Integer }
                        deriving (Eq, Show)


        -- Prelude> make Null
        -- "*** Exception: No match in record selector make
      #+END_SRC
      ~Null~ is NOT a record, and it definitely has no field name ~make~.
      Since ~Null~ is Automobile, typechecker can't discover this Exception,
      and when run something like this /bottom/ will be reached.

      Q: How do we fix this?
      A: Whenever we have a product that uses record accessors, keep it
         separate of any sum type that is wrapping it.
         To do this,
           _split out the product into an independent type with its own type
         constructor instead of only as an inline data constructor product_:
         #+BEGIN_SRC haskell
           data Car = Car { make :: String
                          , model :: String
                          , year :: Integer }
                      deriving (Eq, Show)

           -- The `Null` is still not great, but
           -- we're leaving it in to make a point
           data Automobile = Null
                           | Automobile Car
                           deriving (Eq, Show)
         #+END_SRC

         If we do something silly, the type system catches us (before problems
         multiply and things go wrong at runtime):
         #+BEGIN_SRC haskell
           -- Prelude> make Null
           --
           --     Couldn't match expected type ‘Car’
           --     with actual type ‘Automobile’
           --     In the first argument of ‘make’, namely ‘Null’
           --     In the expression: make Null
         #+END_SRC

** DONE 11.14 Function type is exponential - 431
   CLOSED: [2017-06-11 Sun 03:59]
   - In the arithmetic of calculating inhabitants of types, function type is the
     exponent operator.

*** DONE Exponentiation in what order? - 434
    CLOSED: [2017-06-11 Sun 03:57]
    #+BEGIN_SRC haskell
      data Quantum =
          Yes
        | No
        | Both
        deriving (Eq, Show)

      -- Keep the order of pattern matching (lhs), and use list comprehension to
      -- calculate the combinations of three boolean values.
      convert :: Quantum -> Bool
      convert Yes = True
      convert No = True
      convert Both = True
      
      convert1 :: Quantum -> Bool
      convert1 Yes = True
      convert1 No = True
      convert1 Both = False

      convert2:: Quantum -> Bool
      convert2 Yes = True
      convert2 No = False
      convert2 Both = True

      convert3:: Quantum -> Bool
      convert3 Yes = True
      convert3 No = False
      convert3 Both = False
      
      convert4:: Quantum -> Bool
      convert4 Yes = False
      convert4 No = True
      convert4 Both = True

      convert5:: Quantum -> Bool
      convert5 Yes = False
      convert5 No = True
      convert5 Both = False

      convert6:: Quantum -> Bool
      convert6 Yes = False
      convert6 No = False
      convert6 Both = True

      convert7:: Quantum -> Bool
      convert7 Yes = False
      convert7 No = False
      convert7 Both = False
    #+END_SRC

*** DONE Exercises: The Quad - 434
    CLOSED: [2017-06-11 Sun 03:51]
    1. 16
       (4 * 4)

    2. 16
       (4 * 4)

    3. 256
       (4 ^ 4)

    4. 8
       (2 * 2 * 2)

    5. 16
       (2 ^ 2) ^ 2

    6. 65536
       (4 ^ 4) ^ 2
** DONE 11.15 Higher-kinded datatypes - 435
   CLOSED: [2017-07-20 Thu 18:35]
   - /kinds/ :: the types of type constructors, primarily encoding the number of
                arguments they take.

   - /kind signatures/ work like /type signatures/, using the same ~::~ and ~->~
     syntax, but there are only a few kinds and you'll most often see ~*~.

   - /kinds/ are NOT types UNTIL they are fully applied.
     ONLY types have inhabitants at the term level.

   - ONLY types have inhabitants at the term level.

   - /higher-kinded types/: kinds with ~->~'s
     For example, Lists.

** DONE 11.16 Lists are polymorphic - 437
   CLOSED: [2017-06-11 Sun 23:06]
   - TODO ...

   - *Infix type and data constructors* =IMPORTANT=
     + An operator with a non-alphanumeric name is infix by default.
       The same rule applies to them.

     + All infix type or data constructors must start with a colon.

       The type constructor of functions, (~->~), is the _ONLY_ infix type
       constructor does _NOT_ start with a colon.

       Another exception is that they CANNOT be ~::~ as this syntax is reserved
       for type assertions.
     + 

   - Whether or not you choose to use infix data constructors, type constructors,
     or type class names is down to aesthetic preference.

   - Example:
     The argument of ~not~ is any value of type ~Bool~,
     and
     the argument of ~[]~ is any type of kind ~*~.

** DONE 11.17 Binary tree - 440
   CLOSED: [2017-06-12 Mon 00:32]
   #+BEGIN_SRC haskell
     data BinaryTree a =
         Leaf
       | Node (BinaryTree a) a (BinaryTree a)
       deriving (Eq, Ord, Show)
   #+END_SRC
   We are going to write some functions for processing ~BinaryTree~ values.

*** DONE Inserting into trees - 440
    CLOSED: [2017-06-12 Mon 00:31]
    - Left lesser, right greater is a _common convention_ for arranging binary
      trees.

    - It's important to remember that data is _immutable_ in Haskell.
      Each time we want to insert a value into the data structure, we build a
      whole new tree:
      #+BEGIN_SRC haskell
        insert' :: Ord a => a -> BinaryTree a -> BinaryTree a
        insert' b Leaf = Node Leaf b Leaf
        insert' b (Node left a right)
          | b == a = Node left a right
          | b < a = Node (insert' b left) a right
          | b > a = Node left a (insert' b right)
      #+END_SRC

*** DONE Write ~map~ for ~BinaryTree~ - 442
    CLOSED: [2017-06-11 Sun 23:30]
    #+BEGIN_SRC haskell
      mapTree :: (a -> b) -> BinaryTree a -> BinaryTree b
      mapTree _ Leaf = Leaf
      mapTree f (Node left a right) =
        Node (mapTree f left) (f a) (mapTree f right)
    #+END_SRC
    The base case is trival.

    If you check the type of ~Node~
    (~Node :: BinaryTree a -> a -> BinaryTree a -> BinaryTree a~),
    it is easy to write out the non-base case.

*** DONE Convert binary trees to lists - 444
    CLOSED: [2017-06-12 Mon 00:31]

*** DONE Write foldr for ~BinaryTree~ - 445
    CLOSED: [2017-06-12 Mon 00:32]
    #+BEGIN_SRC haskell
      foldTree :: (a -> b -> b) -> b -> BinaryTree a -> b
      foldTree _ vb Leaf = vb
      foldTree f vb (Node left va right) = foldTree f (f va $ foldTree f vb left) right

      -- testTree' = Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf)
      -- testTree'' = Node (Node Leaf 9 Leaf) 8 (Node Leaf 13 Leaf)
      --
      -- testTree = Node (Node testTree' 100 testTree'') 4 (Node testTree'' 10 testTree'')
      --
      -- main = do
      --   print $ foldTree (+) 0 testTree

      -- -- 210
    #+END_SRC

** DONE 11.18 Chapter Exercises - 445
   CLOSED: [2017-07-21 Fri 22:41]
*** DONE Multiple choice - 445
    CLOSED: [2017-06-12 Mon 00:38]
    1. a)
    2. c)
    3. b)
    4. c)

*** DONE [TODO: NOT Perfect] Ciphers - 447
    CLOSED: [2017-07-20 Thu 21:15]
    #+BEGIN_SRC haskell
      -- vigenère
      -- MEET AT DAWN
      -- ALLY AL LYAL

      -- Only available to capital letters

      vigenere :: String -> String -> String
      vigenere encodingWord info =
        concat . (intersperse " ") $ go repeatedEncodingWord wordList
        where
          repeatedEncodingWord = encodingWord ++ repeatedEncodingWord
          wordList = words info

          f' isInside newCodePoint
            | isInside = newCodePoint
            | otherwise = newCodePoint + (65 - 1) - 90

          f char encodingChar =
            let newCodePoint = ord char + ord encodingChar - 65
                isInside = newCodePoint `elem` [65..90]
            in chr $ f' isInside newCodePoint

          go _ [] = []
          go rpw (w:ws) =
            let (hd, tl) = splitAt (length w) rpw
            in (zipWith f w hd) : go tl ws

    #+END_SRC

*** DONE As-patterns - 447
    CLOSED: [2017-06-12 Mon 01:19]
    #+BEGIN_SRC haskell
      import Data.Char

      -- 1
      isSubsequenceOf' :: (Eq a) => [a] -> [a] -> Bool
      isSubsequenceOf' [] _ = True
      isSubsequenceOf' _ [] = False
      isSubsequenceOf' xs'@(x:xs) (y:ys)
        | x == y = isSubsequenceOf' xs ys
        | otherwise = isSubsequenceOf' xs' ys

      -- 2
      capitalizeWords :: String -> [(String, String)]
      capitalizeWords = (map withCapitalized) . words
        where withCapitalized :: String -> (String, String)
              withCapitalized "" = ("", "")
              withCapitalized xs'@(x:xs) = (xs', toUpper x : xs)
    #+END_SRC

*** DONE Language exercises - 449
    CLOSED: [2017-07-21 Fri 22:35]
    #+BEGIN_SRC haskell
      import Data.Char
      -- Non-official
      import Data.List.Split
      import Data.List.Extra hiding (split)

      -- Language exercises
      -- 1
      capitalizeWord :: String -> String
      capitalizeWord "" = ""
      capitalizeWord (x:xs) = toUpper x : xs

      -- 2
      capitalizeParagraph :: String -> String
      capitalizeParagraph = concat . (intersperse " ") . (map (capitalizeWord . trimStart)) . (split (endsWith "."))


    #+END_SRC
*** DONE Phone exercise - 450
    CLOSED: [2017-07-21 Fri 22:35]
    1. 
    2. 
    3. 
    4. 
    5. 
*** DONE Hutton's Razor - 452
    CLOSED: [2017-07-21 Fri 22:41]
    #+BEGIN_SRC haskell
      -- 1.
      data Expr
        = Lit Integer
        | Add Expr Expr

      eval :: Expr -> Integrer
      eval (Lit i) = i
      eval (Add e1 e2) = (eval e1) + (eval e2)


      -- 2.
      printExpr :: Expr -> Integer
      printExpr (Lit i) = show i
      printExpr (Add e1 e2) = printExpr e1 ++ " + " ++  printExpr e2
    #+END_SRC

** DONE 11.19 Definitions - 453
   CLOSED: [2017-05-26 Fri 01:51]
   1. /datatype/: A (Haskell) datatype is made up of
      + a type constructor
        and

      + zero or more data constructors
        which each have zero or more arguments.

* DONE 12 Signaling Adversity - 454
  CLOSED: [2017-06-15 Thu 02:31]
** DONE 12.1 Signaling adversity - 455
   CLOSED: [2017-06-12 Mon 03:24]
   - Later, we'll see how to defend against those adverse inputs at the time we
     construct our datatypes, =TODO=
     but the ~Maybe~ and ~Either~ datatypes we will demonstrate here are used in
     a lot of Haskell programs.

   - This chapter will include:
     + ~Nothing~, or Just ~Maybe~;
     + ~Either~ left or right, but not both;
     + higher-kindedness;
     + /anamorphisms/, but NOT /animorphs/. =TODO=

** DONE 12.2 How to stop worrying and love Nothing - 455
   CLOSED: [2017-06-12 Mon 03:24]
   ~data Maybe a = Nothing | Just a~

   - ~Just n + 2~ means ~(Just n) + 2~, which is definitely wrong.
     You should always use ~Just parenthesizedValue~

     Function application binds the most tightly in Haskell (has the highest
     precedence).

*** DONE Smart constructors for datatypes - 456
    CLOSED: [2017-06-12 Mon 03:23]
    - Example:
      ~Maybe~ helps us to deal with the acutal invalid value, rather than create
      a plan ~Person~ data with invalid field(s) (empty name or negative age).
      #+BEGIN_SRC haskell
        type Name = String
        type Age = Integer

        data Person = Person Name Age deriving Show

        mkPerson :: Name -> Age -> Maybe Person
        mkPerson name age
          | name /= "" && age >= 0 = Just $ Person name age
          | otherwise = Nothing
      #+END_SRC

    - =TODO= =NEXT SECTION=
      This is much better than our original, but what if we want to know if it
      was the name, age, or both that was bad? We may want to tell our user
      something was wrong with their input. Fortunately, we have a datatype for
      that!

** DONE 12.3 Bleating either - 458
   CLOSED: [2017-06-12 Mon 04:25]
   ~data Either a b = Left a | Right b~

   - /Case expressions/ and /pattern matching/ _will work WITHOUT ~Eq~ instance_.
     BUT /guards/ using ~(==)~ will _NOT_.

   - TODO =PAGE 458=
     It's worth considering that if you needed to have an ~Eq~
     instance to pattern match, how would you write the ~Eq~ instances?
     =IMPORTANT=

     #+BEGIN_SRC haskell
       module EqCaseGuard where

       data PersonInvalid = NameEmpty
                          | AgeTooLow
                          deriving (Eq, Show)

       -- Compiles fine without Eq
       toString :: PersonInvalid -> String
       toString NameEmpty = "NameEmpty"
       toString AgeTooLow = "AgeTooLow"

       instance Show PersonInvalid where
         show = toString

       -- This does not work without an Eq instance
       blah :: PersonInvalid -> String
       blah pi
         | pi == NameEmpty = "NameEmpty"
         | pi == AgeTooLow = "AgeTooLow"
         | otherwise = "???"
     #+END_SRC

   - _IMPORTANT CONVENTION_:
     The ~Left~ of ~Either~ is used for whatever case is going to cause the work
     to stop (in the example above we put invalid data in ~Left~, because, of
     course, invalid data will cause the work to stop).

     TODO
     _This convetion is important, because it is related to the ~fmap~ function
     of ~Functor~, and it will be explained later!!!_

   - =From Jian= Another reason:
     The ~Right~ constructor of ~Either~ is used for _right_

   - Solve the question metioned at the end of the last section.
     #+BEGIN_SRC haskell
       type Name = String
       type Age = Integer

       data Person = Person Name Age deriving Show

       data PersonInvalid = NameEmpty
                          | AgeTooLow
                          deriving (Eq, Show)

       mkPerson :: Name -> Age -> Either PersonInvalid Person
       mkPerson name age
         | name /= "" && age >= 0 = Right $ Person name age
         | name == "" = Left NameEmpty
         | otherwise = Left AgeTooLow
     #+END_SRC

   - The ~otherwise~ part above is not good. Let's solve this:
     #+BEGIN_SRC haskell
       type Name = String
       type Age = Integer
       type ValidatePerson a = Either [PersonInvalid] a
       -- this type alias wasn't in our previous version
       -- otherwise, these types are the same as above

       data Person = Person Name Age deriving Show

       data PersonInvalid = NameEmpty
                          | AgeTooLow
                          deriving (Eq, Show)

       -- ageOkay :: Age -> Either [PersonInvalid] Age
       ageOkay :: Age -> ValidatePerson Age
       ageOkay age = case age >= 0 of
         True -> Right age
         False -> Left [AgeTooLow]

       nameOkay :: Name -> ValidatePerson Name
       nameOkay name = case name /= "" of
         True -> Right name
         False -> Left [NameEmpty]

       mkPerson :: Name -> Age -> ValidatePerson Person
       mkPerson name age =
         mkPerson' (nameOkay name) (ageOkay age)

       mkPerson' :: ValidatePerson Name -> ValidatePerson Age -> ValidatePerson Person
       mkPerson' (Right nameOk) (Right ageOk) = Right (Person nameOk ageOk)
       mkPerson' (Left badName) (Left badAge) = Left (badName ++ badAge)
       mkPerson' (Left badName) _ = Left badName
       mkPerson' _ (Left badAge) = Left badAge
     #+END_SRC

   - =TODO=
     A more concise solution:
     #+BEGIN_SRC haskell
       mkPerson :: Name -> Age -> Validation [PersonInvalid] Person
       mkPerson name age =
         liftA2 Person (nameOkay name) (ageOkay age)
     #+END_SRC

** DONE 12.4 Kinds, a thousand stars in your types - 464
   CLOSED: [2017-06-13 Tue 23:33]
   - /Kinds/ are types one level up.
     They are used to describe the types of type constructors.

   - /higher-kinded types/: Type constructors are types that take more types as
     arguments.
     
   - The Haskell Report
     + /type constant/ is used to refer to types that take no arguments and are
       already types.

     + /type constructor/ is used to refer to types which must have arguments
       applied to become a type. 

   - *Lifted and unlifted types*      =TODO=
     + kind ~*~ is the kind of all standard /lifted types/

     + kind ~#~ is the kind of all standard /unlifted types/

     + /lifted type/: any type can be inhabited by /bottom/.
       * any type that includes any datatype you could define yourself,

     + /unlifted type/: any type which CANNOT be inhabited by /bottom/.

     + Types of kind ~#~ are often native machine types and raw pointers.

     + Newtypes (declared by ~newtype~) are a special case in that they are kind
       ~*~,
       BUT are unlifted because their representation is identical to that of the
       type they contain, so the _newtype_ itself is not creating any new pointer
       beyond that of the type it contains.

       That fact means that the _newtype_ itself cannot be inhabited by /bottom/,
       only the thing it contains can be, so newtypes are unlifted. The default
       kind of concrete, fully-applied datatypes in GHC is kind *.

   - Unlifted types are any type which cannot be inhabited by /bottom/.

   - =TODO= The implications of higher-kindedness will be clearer in a later
     chapter.
6
*** DONE Data constructors are functions - 470
    CLOSED: [2017-06-13 Tue 23:33]
    - You CANNOT ordinarily hide polymorphic types from your type constructor
      #+BEGIN_SRC haskell
        data Unary = Unary a deriving Show

        -- Not in scope type variable 'a'
      #+END_SRC

    - In order for the type variable a to be in scope, we usually need to
      introduce it with our type constructor.
      =TODO=
      _There are ways around this_, but they’re rarely necessary or a good idea and
      not relevant to the beginning Haskeller.

** DONE 12.5 Chapter Exercises - 472
   CLOSED: [2017-06-15 Thu 02:31]
*** DONE Determine the kinds - 472
    CLOSED: [2017-06-14 Wed 02:28]
    1. ~*~
    2. ~* -> *~

*** DONE String processing - 473
    CLOSED: [2017-06-14 Wed 02:39]
    #+BEGIN_SRC haskell
      import Data.List
      -- String processing
      -- 1
      notThe :: String -> Maybe String
      notThe "the" = Nothing
      notThe s = Just s

      replaceThe :: String -> String
      replaceThe = intercalate " "  . map (replace . notThe) . words
        where replace (Just v) = v
              replace Nothing = "a"


      -- 2
      isVowel :: Char -> Bool
      isVowel x =
        x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u' ||
        x == 'A' || x == 'E' || x == 'I' || x == 'O' || x == 'U'

      countTheBeforeVowel :: String -> Integer
      countTheBeforeVowel = go . words
        where go [] = 0
              go [x] = 0
              go ("the" : wd@(x:xs) : wds)
                | isVowel x = 1 + go wds
                | otherwise = go wds
              go (_:wds) = go wds


      -- 3
      countVowels :: String -> Integer
      countVowels = genericLength . filter id . map isVowel

      -- Validate the word
      newtype Word' =
        Word' String
        deriving (Eq, Show)

      vowels = "aeiou"

      isConsonant :: Char -> Bool
      isConsonant = not . isVowel

      mkWord :: String -> Maybe Word'
      mkWord word =
        let
          nVowels = countVowels word
          nConsonants = genericLength word - nVowels
        in
          if nConsonants > nVowels
          then Just (Word' word)
          else Nothing
    #+END_SRC

*** DONE Validate the word - 474
    CLOSED: [2017-06-15 Thu 02:18]
    #+BEGIN_SRC haskell
      newtype Word' =
        Word' String
        deriving (Eq, Show)

      vowels = "aeiou"

      isConsonant :: Char -> Bool
      isConsonant = not . isVowel

      mkWord :: String -> Maybe Word'
      mkWord word
        | nConsonants > nVowels = Just (Word' word)
        | otherwise = Nothing
        where
          nVowels = countVowels word
          nConsonants = genericLength word - nVowels
    #+END_SRC

*** DONE It's only natural - 475
    CLOSED: [2017-06-15 Thu 02:19]
    #+BEGIN_SRC haskell
      -- It's only Natural
      data Nat =
          Zero
        | Succ Nat
        deriving (Eq, Show)

      natToInteger :: Nat -> Integer
      natToInteger Zero = 0
      natToInteger (Succ nat) = 1 + natToInteger nat


      integerToNat :: Integer -> Maybe Nat
      integerToNat int
        | int < 0 = Nothing
        | otherwise = Just (go int Zero)
        where
          -- TODO: I first write a wrong type signature:
          -- go :: Num a => a -> Nat -> Nat
          go :: (Eq a, Num a) => a -> Nat -> Nat
          go 0 acc = acc
          go i acc = go (i - 1) (Succ acc)

    #+END_SRC
*** DONE Small library for ~Maybe~ - 476
    CLOSED: [2017-06-15 Thu 02:24]
    #+BEGIN_SRC haskell
      -- 1
      isJust :: Maybe a -> Bool
      isJust Nothing = False
      isJust _ = True

      isNothing :: Maybe a -> Bool
      isNothing Nothing = True
      isNothing _ = False

      -- 2
      mayybee :: b -> (a -> b) -> Maybe a -> b
      mayybee fallback _ Nothing = fallback
      mayybee _ f (Just va) = f va

      -- 3
      fromMaybe :: a -> Maybe a -> a
      fromMaybe fallback Nothing = fallback
      fromMaybe _ (Just v) = v

      -- 4
      listToMaybe :: [a] -> Maybe a
      listToMaybe [] = Nothing
      listToMaybe (x:_) = Just x

      maybeToList :: Maybe a -> [a]
      maybeToList (Just v) = [v]
      maybeToList _ = []

      -- 5
      catMaybes' :: [Maybe a] -> [a]
      catMaybes' [] = []
      catMaybes' (Just v : xs) = v : catMaybes' xs
      catMaybes' (_ : xs) = catMaybes' xs

      -- 6
      -- This should be an equivalent function to the `sequence` in Data.Traversable
      -- What is the result of a base case? According to the given hint, the result
      -- should be the same as

      -- `sequence ([] :: [Maybe a])
      -- -- Notice: this is not a legal expression as we cannot give a concrete type to
      -- -- it.`
      flipMaybe :: [Maybe a] -> Maybe [a]
      flipMaybe [] = Just []
      flipMaybe (Nothing:_) = Nothing
      flipMaybe (_ : xs) = flipMaybe xs
    #+END_SRC

*** DONE Small library for ~Either~ - 477
    CLOSED: [2017-06-15 Thu 02:27]
    #+BEGIN_SRC haskell
      -- 1
      lefts' :: [Either a b] -> [a]
      lefts' [] = []
      lefts' (Left l : xs) = l : lefts' xs
      lefts' (_ : xs) = lefts' xs

      -- 2
      rights' :: [Either a b] -> [b]
      rights' = foldr f []
        where f (Right r) rs = r : rs
              f _ rs = rs
      -- 3
      partitionEithers' :: [Either a b] -> ([a], [b])
      partitionEithers' = foldr f ([], [])
        where f (Left l) (ls, rs) = (l:ls, rs)
              f (Right r) (ls, rs) = (ls, r:rs)

      -- 4
      eitherMaybe' :: (b -> c) -> Either a b -> Maybe c
      eitherMaybe' f (Right r) = Just (f r)
      eitherMaybe' _ _ = Nothing

      -- 5
      either' :: (a -> c) -> (b -> c) -> Either a b -> c
      either' fl _ (Left l) = fl l
      either' _ fr (Right r) = fr r

      -- 6
      eitherMaybe'' :: (b -> c) -> Either a b -> Maybe c
      eitherMaybe'' f et = either' (\_ -> Nothing) (\r -> Just (f r)) et
    #+END_SRC
    1. 
    2. 
    3. 
    4. 
    5. 
    6.

*** DONE Unfolds - 478
    CLOSED: [2017-06-15 Thu 02:27]

*** TODO Why bother? - 479
    TODO Don't understand the description
         NO need to implement things here!

*** DONE Write your own iterate and unfoldr - 480
    CLOSED: [2017-06-15 Thu 02:29]
    #+BEGIN_SRC haskell
      -- 1
      myIterate :: (a -> a) -> a -> [a]
      myIterate f va = va : myIterate f (f va)

      -- 2
      myUnfoldr :: (b -> Maybe (a, b)) -> b -> [a]
      myUnfoldr fb2m b =
        case fb2m b of
          Nothing -> []
          Just (this, next) -> this : myUnfoldr fb2m next

      -- 3
      betterIterate :: (a -> a) -> a -> [a]
      betterIterate f = myUnfoldr (\x -> Just (x, f x))
    #+END_SRC
    1. 
    2. 
    3.

*** DONE Finally something other than a list! - 481
    CLOSED: [2017-06-15 Thu 02:29]
    #+BEGIN_SRC haskell
      data BinaryTree a =
          Leaf
        | Node (BinaryTree a) a (BinaryTree a)
        deriving Show

      -- 1
      unfold :: (a -> Maybe (a, b, a)) -> a -> BinaryTree b
      unfold f va =
        case f va of
          Nothing -> Leaf
          Just (l, v, l') -> Node (unfold f l) v (unfold f l')

      -- 2
      treeBuild :: Integer -> BinaryTree Integer
      treeBuild n = unfold f 0
        where f x
                | x == n = Nothing
                | otherwise = Just (x + 1, x, x + 1)
    #+END_SRC
** DONE 12.6 Definitions - 483
   CLOSED: [2017-06-12 Mon 04:40]
   1. /higher kinded type/: A /higher kinded type/ is a type
      + whose /kind/ has a function arrow in it
      + which can be described as a type constructor rather than a type constant.

      TODO
      This is not to be confused with /higher kinded polymorphism/, which we'll
      discuss later.


* DONE 13 Building projects - 482
  CLOSED: [2017-07-28 Fri 20:37]
** DONE 13.1 Modules - 483
   CLOSED: [2017-06-15 Thu 14:49]
   - /Modules/ contain the
     + /datatypes/
     + /type synonyms/
     + /type classes/
     + /type class instances/
     + /values/ you've defined at the top level.

   - /Modules/ _OFFER_ a means to *import* other /modules/ into the scope of your program.

   - /Modules/ also _CONTAIN_ /values/ that can be *exported* to OTHER /modules/.

   - If you've ever used a language with /namespaces/, /modules/ are the same.

   - This chapter's primary focus is
     + NOT so much on code
     + but on how to set up a project in Haskell,
       * use the /package manager/ _Cabal_,
       * build the project with _Stack_, and work with modules as they are in Haskell.

   - In this chapter, we'll cover:
     + writing Haskell programs with /modules/;
     + using the /Cabal package manager/;
     + building our project with /Stack/;
     + *conventions* around Haskell project organization; =TODO=
     + building a small interactive game.

   - In this chapter, we need Stack, Cabal, and Git.

** DONE 13.2 Making packages with Stack - 484
   CLOSED: [2017-07-22 Sat 23:34]
   - /Cabal/ :: A package manager for Haskell.

   - Cabal === *C* ommon *A* rchitecture for *B* uilding *A* pplications and *L* ibraries
     
   - /package/ :: a program you are building, including all of its modules and
                  dependencies.

   - /package dependencies/ :: it includes
     + the interlinked elements of that program
     + the other /packages/ (libraries) it may depend on
     + any _test_ and _documentation_ associated with the project

   - /Stack/ :: A project manager program.
                It helps you manage both projects made up of
     + _MULTIPLE_ /packages/
        as well as
     + _INDIVIDUAL_ /package/

   - /Cabal/ exists primarily to describe a *single package* with a =.cabal= file.

   - /Stack/ is built on top of /Cabal/ in some important senses, so we will
     _still_ be working with =.cabal= files.
     HOWEVER, /Stack/ _simplifies_ the process somewhat, especially in large
     projects with multiple dependencies, by allowing you to build those large
     libraries only once and use the across projects. =TODO= =???=

   - /Stackage/ :: An *online* /Haskell packages source/, which maintains many
                   /LTS snapshots/.

                   With in ONE /LTS snapshots/, /packages/ are *guaranteed to
                   work together*.

   - Stack guarantees the /packages/ it help you to download are _from *one*
     specified LTS snapshot_.

   - /Packages/ from /Hackage/ may have conflicting dependencies.

   - The Haskell community does _NOT_ have a prescribed project layout,

     _Recommendation_ of this book:
     *the basic structure embodied in the Stack templates*.

** DONE 13.3 Working with a basic project - 485
   CLOSED: [2017-06-24 Sat 22:47]
   Use /Cabal/ and /Stack/ to build a sample project called =hello=.
   https://github.com/haskellbook/hello

*** DONE Building the project - 485
    CLOSED: [2017-06-24 Sat 21:53]
    1. ~git clone https://github.com/haskellbook/hello~

    1. ~cd hello~ 

    2. ~stack setup~:
       + Install the version of GHC LTS snapshot specified in the =stack.yaml=.
           If there is a cached version which satisfies the requirement, it will
         be used.

       + Set up the other requirement of this project. =TODO= =???=

    3. ~stack build~

*** DONE Loading and running code from the REPL - 486
    CLOSED: [2017-06-24 Sat 22:09]
    - You can start a REPL in the project folder with ~stack ghci~, run
      the project:
      #+BEGIN_SRC haskell
        -- bash$ stack ghci
        -- -- // not command output -- These two lines will show up if not run `stack build` first.
        -- Configuring hello-0.1.0.0...
        -- hello-0.1.0.0: initial-build-steps (exe)
        -- -- // not command output
        -- Configuring GHCi with the following packages: hello
        -- Using main module: 1. Package `hello' component exe:hello with main-is file: /home/lanjian/Documents/HaskellBook/hello/src/Main.hs
        -- GHCi, version 8.0.1: http://www.haskell.org/ghc/  :? for help
        -- [1 of 1] Compiling Main             ( /home/lanjian/Documents/HaskellBook/hello/src/Main.hs, interpreted )
        -- Ok, modules loaded: Main
        -- Loaded GHCi configuration from /tmp/ghci21481/ghci-script

        -- Main> main
        -- hello world
      #+END_SRC

    - Using Stack's GHCi integration to fire up a REPL _doesn't just_ let us load
      and run code in our project, but also enables us to make use of our
      project's dependencies. =TODO= We'll demonstrate this later.

*** DONE =stack exec= - 486
    CLOSED: [2017-06-24 Sat 22:19]
    - When you ran ~build~ earlier, you may have seen something like:
      #+BEGIN_SRC haskell
        -- hello-0.1.0.0: build (exe)
        -- Preprocessing executable 'hello' for hello-0.1.0.0...
        -- [1 of 1] Compiling Main             ( src/Main.hs, .stack-work/dist/x86_64-linux-ncurses6/Cabal-1.24.0.0/build/hello/hello-tmp/Main.o )
        -- Linking .stack-work/dist/x86_64-linux-ncurses6/Cabal-1.24.0.0/build/hello/hello ...
        -- hello-0.1.0.0: copy/register
        -- Installing executable(s) in
        -- /home/lanjian/Documents/HaskellBook/hello/.stack-work/install/x86_64-linux-ncurses6/lts-7.24/8.0.1/bin
      #+END_SRC

    - This is the message to tell you /Stack/ compiles an executable binary and
      linking to it.

    - You can type the full path to run the executable in the message above:
      =.stack-work/dist/x86_64-linux-ncurses6/Cabal-1.24.0.0/build/hello/hello=

    - There is a simple way -- use the command below in the project folder:
      #+BEGIN_SRC bash
        # $ stack exec -- hello
        # hello world
      #+END_SRC

*** DONE Executable stanzas in Cabal files - 487
    CLOSED: [2017-06-24 Sat 22:47]
    - /Stack/ created an executable earlier because of the following stanza in
      the ~hello.cabal~ file:
      #+BEGIN_SRC text
        executable hello
        --          [1] 
          hs-source-dirs:       src
        --    [2] 
          main-is:              Main.hs
        --    [3] 
          default-language:     Haskell2010
        --    [4] 
          build-depends:        base >= 4.7 && < 5
        --    [5] 
      #+END_SRC
      1. This name following the declaration of an =executable= stanza tells
         /Stack/ or /Cabal/ what to name the binary or executble it creates.

         This name must match the name of the =.cabal= file.

      2. The folder where the source code resides.

      3. Execution of this binary should begin by looking for a ~main~ function
         inside a file named =Main.hs= with the /module name/ ~Main~.

         _NOTE_ that /modules name/ *HAVE TO MATCH* =IMPORTANT= /filenames/.

         =IMPORTANT=
         Your compiler (NOT just Stack) will *reject* using a file that isn't a
         ~Main~ /module/ as the entry point to executing the program.

         It'll look for the ~Main.hs~ file under _all_ directories you specified
         in =hs-source-dirs=.

      4. Defines _the version of the Haskell standard to expect._ 

      5. =TODO= We'll show you how to add and install dependencies later.

         Here the ~base~ is really the bare minimum or baseline dependency in almost
         ANY Haskell project as _you *CANNOT* really get anything done *WITHOUT*
         the ~base~ library_.

    - *A sidebar about executables and libraries*
      + The =.cabal= file above only has an ~executable~ stanza.

      + If you write a library, you need a ~library~ stanza
        and
        to choose which modules we want to expose.

** DONE 13.4 Making our project a library - 488
   CLOSED: [2017-06-24 Sat 23:06]
   - First, add a library stanza to =hello.cabal=:
     #+BEGIN_SRC yaml
       -- (part of a cabal file)

       library
         hs-source-dirs:     src
         exposed-modules:    Hello
         build-depends:      base >= 4.7 && < 5
         default-language:   Haskell2010
     #+END_SRC
     
   - Create a file located at =src/Hello.hs= (according to the above library
     stanza of =hello.cabal=): 
     #+BEGIN_SRC haskell
       module Hello where

       sayHello :: IO ()
       sayHello = do
         putStrLn "hello world"
     #+END_SRC

   - Change our ~Main~ module to use this library function:
     #+BEGIN_SRC haskell
       module Main where

       import Hello

       main :: IO ()
       main = do
         sayHello
     #+END_SRC

   - =From Jian=
     You also need to add ~other-modules: Hello~ to the ~executable hello~
     section. Or, even though Cabal can find it, two warnings will be issued.

     _THIS IS NOT MENTIONED IN THE BOOK!_

   - =hello.cabal=
     #+BEGIN_SRC yaml
       name:                hello
       version:             0.1.0.0
       synopsis:            Simple project template from stack
       description:         Please see README.mdhomepage:            https://github.com/bitemyapp/hello#readme
       license:             BSD3
       license-file:        LICENSE
       author:              Jian Lan
       maintainer:          example@email.com
       copyright:           2018, Jian Lan
       category:            Web
       build-type:          Simple
       cabal-version:       >=1.10executable hello
         hs-source-dirs:      exe
         main-is:             Main.hs
         default-language:    Haskell2010
         build-depends:       base >= 4.7 && < 5
                            , hello

       library
         hs-source-dirs:    src
         exposed-modules:   Hello
         build-depends:     base >= 4.7 && < 5
         default-language:  Haskell2010%
     #+END_SRC

   - After the steps above you can execute it with the command:
     #+BEGIN_SRC bash
       stack build
       stack exec hello
       # hello world 
     #+END_SRC

   - If you want to move the ~Main.hs~ to a separate folder =exe=:
     1. Edit the ~executable hello~ stanza in =hello.cabal=, the ~hs-source-dirs~
        should point to the =exe= directory.
          If now you try to build this project, you will fail and receive some
        error an message:
        #+BEGIN_SRC text
          hello/exe/Main.hs:3:8:
          Could not find module ‘Hello’
          It is a member of the hidden package
          ‘hello-0.1.0.0@hello_IJIUuynUbgsHAquBKsAsb5’.
          Perhaps you need to add ‘hello’ to the
          build-depends in your .cabal file.
          Use -v to see a list of the files searched for.
        #+END_SRC

     2. There are two ways to fix this, one of them is better:
        + Add ~src~ to the source directories the executable is permitted to
          search.

        + (BETTER) Respect the boundaries of the library and executable
          and
          Add your won library as a dependency:
          #+BEGIN_SRC yaml
            executable hello
              hs-source-dirs:   exe
              main-is:          Main.hs
              default-language: Haskell2010
              build-depends:    base >= 4.7 && < 5
                              , hello
          #+END_SRC

** DONE 13.5 Module exports - 490
   CLOSED: [2017-06-16 Fri 23:15]
   - _By default_,
     when you don't specify any exports in a module,
     *every* top-level binding is exported and can be imported by another module.
     =IMPORTANT=

   - How to specify what can be exported:
     #+BEGIN_SRC haskell
       -- Hello.hs
       module Hello
         ( sayHello )
         where

       sayHello :: IO ()
       sayHello = do
         putStrLn "hello world"
     #+END_SRC

     + If the parenthesis in ~module ModuleName (...) where~ is _empty_,
       *nothing* will be exported.

*** DONE Exposing modules - 491
    CLOSED: [2017-06-16 Fri 23:15]
    If you add a module, don't forget to add the module to the =exposed-modules=
    of the =library= stanza.

    #+BEGIN_SRC yaml
      name:          hello
      version:       0.1.0.0
      synopsis:      Simple project template from stack
      description:   Please see README.md
      homepage:      https://github.com/bitemyapp/hello#readme
      license:       BSD3
      license-file:  LICENSE
      author:        Jian Lan
      maintainer:    example@email.com
      copyright:     2018, Jian Lan
      category:      Web
      build-type:    Simple
      cabal-version: >=1.10

      executable hello
        hs-source-dirs:    exe
        main-is:           Main.hs
        default-language:  Haskell2010
        build-depends:     base >= 4.7 && < 5
                         , hello

      library
        hs-source-dirs:    src
        exposed-modules:   DogsRule
                         , Hello
        default-language:  Haskell2010 
        build-depends:     base >= 4.7 && < 5
    #+END_SRC

    - =TODO=
      WHY NOT add ~DogsRule~ as a =build-depends=???

** DONE 13.6 More on importing modules - 492
   CLOSED: [2017-06-16 Fri 23:34]
   - The ~:browse~ command allows us to see what functions are included in the
     named /module/.
     #+BEGIN_SRC haskell
       -------------
       -- in GHCi --
       -------------

       -- Prelude>
       :browse Data.Bool
       -- bool :: a -> a -> Bool -> a
       -- (&&) :: Bool -> Bool -> Bool
       -- data Bool = False | True
       -- not :: Bool -> Bool
       -- otherwise :: Bool
       -- (||) :: Bool -> Bool -> Bool
     #+END_SRC

   - Use a ~pragma~ (or /language extension/) when start GHCi to turn ~Prelude~
     off. Run ~stack ghci --ghci-options -XNoImplicitPrelude~ in the shell, and
     you'll see a ~>~ REPL prompt.

     + =From Jian=
       Here Chris make a typo: ~Prelude>~ should be ~>~

   - A /selective import/ example:
     ~import Data.Bool (bool)~

   - /Import declarations/ have to be at the beginning of a /module/.
     =IMPORTANT=

*** DONE Qualified imports - 494
    CLOSED: [2017-06-16 Fri 23:24]
    Examples:
    - Use ~import qualified Data.Bool~, and then use ~Data.Bool.bool~ rather than
      ~bool~.

    - Use ~import qualified Data.Bool as B~, and then use ~B.bool~ rather than
      ~bool~ or ~Data.Bool.bool~.

    - *Setting the Prelude prompt*
      + As you import modules, the prompt could keep growing:
          By default, after importing ~Data.Bool~ (as ~B~) and ~Data.Char~, we
        have a prompt of =Prelude B Data.Char>=

      + Set prompt:
        ~:set prompt "Lambda> "~ (ATTENSION to the space after ~>~)

*** DONE Intermission: Check your understanding - 495
    CLOSED: [2017-06-16 Fri 23:34]
    1. ~forever~ and ~when~
    2. The ~import Data.Bits~ line, and the ~import Database.Blacktip.Types~ line
    3. The ~import Database.Blacktip.Types~ line
    4. Answer to sub-questions:
       a) ~MV~ : ~Control.Concurrent.MVar~,
          ~FPC~: ~Filesystem.Path.CurrentOS~,
          ~CC~ : ~Control.Concurrent~

       b) The ~import qualified Filesystem as FS~ line

       c) The ~import Control.Monad (forever, when)~ line

** DONE 13.7 Making our program interactive - 497
   CLOSED: [2017-06-17 Sat 00:03]
   #+BEGIN_SRC haskell
     -- Re-write "Hello" module
     -- Hello.hs
     module Hello
       (sayHello)
       where
     sayHello :: String -> IO ()
     sayHello name = putStrLn ("Hi" ++ name ++ "!")  -- NEW ADDED argument.
   #+END_SRC

   #+BEGIN_SRC haskell
     -- Re-write "Main" module
     -- Main.hs
     module Main where

     import DogsRule
     import Hello

     main :: IO ()
     main = do
       name <- getLine -- NEW ADDED
       sayHello name
       dogs
   #+END_SRC

   - The ~do~ syntax, which is /syntactic sugar/.
     Use ~do~ inside functions that return ~IO~ in order to sequence side
     effects in a convenient syntax.

   - ~<-~ in ~do~ notation above is pronounced /bind/.
     Explain later.

   - The result of binding (~<-~ in ~do~) over the ~IO String~ is ~String~.

   - *What if we tried to pass ~getLine~ to ~sayHello~?*
     Type error -- More details in the chapters of Monad and IO.

*** DONE Adding a prompt - 499
    CLOSED: [2017-06-17 Sat 00:02]
    #+BEGIN_SRC haskell
      module Main where

      import DogsRule
      import Hello
      import System.IO

      main :: IO ()
      main = do
        hSetBuffering stdout NoBuffering
        putStr "Please input your name: "
        name <- getLine
        sayHello name
        dogs
    #+END_SRC
    ~hSetBuffering stdout NoBuffering~ guarantees ~putStr~ isn't buffered and
    prints immediately.

** DONE 13.8 ~do~ syntax and ~IO~ - 500
   CLOSED: [2017-06-17 Sat 00:17]
   - The ~main~ executable in a Haskell program *MUST ALWAYS* have the type
     ~IO ()~.

     =TODO= =toAuthor=
     According to this, code example in page 511 is wrong -- ~return (x1 ++ x2)~
     shouldn't be the last expression of the do block of ~main~.

   - The ~do~ syntax specifically allows us to *sequence* /monadic actions/.

   - Here, the /instance/ of /type class/ ~Monad~ we care about is ~IO~.

   - ~<-~ is used to bind a variable, and it is part of the ~do~ sugar.

*** DONE ~return~ - 502
    CLOSED: [2017-07-25 Tue 19:17]
    - ~return :: Monad m => a -> m a~ doesn't do much but return a value.
      However, it returns a value inside /monadic structure/.

    - /do notation/ considered harmful!
      _Just kidding._ But sometimes enthusiastic programmers _overuse_ ~do~ blocks.

      + Functions like ~putStrLn~ already have right types.

      + Sometimes, you can use ~>>=~ to combine some expressions into a
        single-line expression, and avoid to use ~do~ syntax.

** DONE 13.9 Hangman game - 503
   CLOSED: [2017-06-17 Sat 00:27]
   - ~stack new hangman simple~
     + Create a project named =hangman= using the =simple= template

     + =from Jian=
       The output message reminds that some _parameter_ value should be set
       * by editing the =$HOME/.stack/config.yaml=
         This method is good to the values of =author-email=, =author-name=, and
         =github-username=.

       * by manually passing parameter values with the command line:
         ~stack new hangman simple -p "category:<value>" -p "copyright:<value>"~

         You can find the usually used categories in Hackage:
         https://hackage.haskell.org/packages/

         Copyright is usually written in the format of
         =Copyright: (c) 2016-2017 Jian Lan=

   - The other setups for this Hangman game:
     + Use the words list located at a directory like the following:
       #+BEGIN_SRC bash
         # $ ls /usr/share/dict/

         # american-english  british-english
         # cracklib-small  README.select-wordlist
         # words  wrods.pre-dictionaries-common
       #+END_SRC

     + The files and directories structure before next section should be:
       #+BEGIN_SRC bash
         # $ tree .
         .
         ├── LICENSE
         ├── Setup.hs
         ├── data
         │ └── dict.txt   # a file from the location described in the last section.
         ├── hangman.cabal
         ├── src
         │ └── Main.hs
         └── stack.yaml
       #+END_SRC

     + Edit the =.cabal= file as follows:
       #+BEGIN_SRC yaml
         name:               hangman
         version:            0.1.0.0
         synopsis:           Playing Hangman
         homepage:           Chris N Julie
         license:            BSD3
         license-file:       LICENSE
         author:             Chris Allen and Julie Moronuki
         maintainer:         haskellbook.com
         category:           Game
         build-type:         Simple
         extra-source-files: data/dict.txt
         cabal-version:      >=1.10
         executable hangman
           main-is:          Main.hs
           hs-source-dirs:   src
           build-depends:    base >=4.7 && <5
                           , random
                           , split
           default-language: Haskell2010
       #+END_SRC

** DONE 13.10 Step One: Importing modules - 506
   CLOSED: [2017-06-17 Sat 01:42]
   - We need to import some packages in the ~Main~ module:
     #+BEGIN_SRC haskell
       module Main where

       import Control.Monad (forever)
       import Data.Char (toLower)
       import Data.Maybe (isJust)
       import Data.List (intersperse)
       import System.Exit (exitSuccess)
       import System.Random (randomRIO)
     #+END_SRC
     1. We ~forever~, but this is just our preference.
        It makes an _infinite loop_.

     2. ~toLower \colon{}\colon{} Char -> Char~ won't change the non-letter characters.

     3. ~isJust \colon{}\colon{} Maybe a -> Bool~.

        * We will combine this with
          ~all :: Foldable t => (a -> Bool) -> t a -> Bool~ (a standard function
          in the ~Prelude~).

          We can make the type more specific by asserting a /type signature/ like
          so. Of course, there is a restriction -- ~Foldable~ structure bound.
          #+BEGIN_SRC haskell
            -- Prelude> :t all :: (a -> Bool) -> [a] -> Bool
            all :: (a -> Bool) -> [a] -> Bool

            -- Prelude> :t all :: (a -> Bool) -> Maybe a -> Bool
            all :: (a -> Bool) -> Maybe a -> Bool

            -- Prelude> :t all :: (a -> Bool) -> Either b a -> Bool
            all :: (a -> Bool) -> Either b a -> Bool
          #+END_SRC

     4. ~intersperse \colon{}\colon{} a -> [a] -> [a]~
        Example: ~intersperse ' ' "Blah"~ returns ="B l a h"=

     5. Use ~exitSuccess~ from ~System.Exit~ to *exit successfully* -- no errors.
        Mostly, it is used in source file code.

        Evaluate ~exitSuccess~ in the REPL, it'll just report that an exception
        occurred.

     6. Use ~randomRIO \colon{}\colon{} Random a => (a, a) -> IO a~ (from ~System.Random~) to
        generate a random index in range, and then with the index select a word
        from our dictionary at random.
          For example, ~randomRIO (0, 5)~ returns ~IO 4~

** DONE 13.11 Step Two: Generating a word list - 510
   CLOSED: [2017-06-17 Sat 01:59]
   1. 
     #+BEGIN_SRC haskell
       type WordList = [String]

       allWords :: IO WordList
       allWords = do
         dict <- readFile "data/dict.txt"
         return (lines dict)
     #+END_SRC

      + ~readFile \colon{}\colon{} FilePath -> IO String~

      + ~lines \colon{}\colon{} String -> [String]~
        The result of ~lines "aardvark\naaron"~ is ~["aardvark","aaron"]~.

        This does something similar but different from ~words~, which splits by
        _spaces_ and _newlines_.

   2. 
      #+BEGIN_SRC haskell
        minWordLength = 5 :: Int
        maxWordLength = 9 :: Int

        gameWords :: IO WordList
        gameWords = do
          aw <- allWords
          return (filter gameLength aw)
          where gameLength w =
                  let l = length (w :: String)
                  in  l >= minWordLength && l < maxWordLength
      #+END_SRC

   3.
      #+BEGIN_SRC haskell
        -- #1
        randomWord :: WordList -> IO String
        randomWord wl = do
          randomIndex <- randomRIO (0, length wl - 1)
          return $ wl !! randomIndex

        -- #2
        randomWord' :: IO String
        randomWord' = gameWords >>= randomWord
      #+END_SRC

** DONE 13.12 Step Three: Making a puzzle - 513
   CLOSED: [2017-06-25 Sun 22:34]
   - A ~Puzzle~ type:
     #+BEGIN_SRC haskell
       data Puzzle = Puzzle String [Maybe Char] [Char]
       --                     [1]       [2]       [3]

       -- 1. the word we're trying to guess
       -- 2. the characters we've filled in so far
       -- 3. the letters we've guessed so far
     #+END_SRC

   - An instance of the type class ~Show~ for our datatype ~Puzzle~ (Since we want
     a customized look of a ~Puzzle~, no ~deriving~ in datatype declaration above):
     #+BEGIN_SRC haskell
       instance Show Puzzle where
         show (Puzzle _ discovered gueesed) =
           (intersperse ' ' $ fmap renderPuzzleChar discovered)
           ++ " Guessed so far: " ++ guessed
     #+END_SRC

   - Generate a fresh puzzle: with answer string, but no discovered and guessed.
     #+BEGIN_SRC haskell
       freshPuzzle :: String -> Puzzle
       freshPuzzle answer = Puzzle answer currentAnswer ""
         where currentAnswer = map (const Noting) answer
     #+END_SRC
     + Here is a typical usage of ~const~.  =IMPORTANT=
       ~const~ is used to write a concise version of ~_ -> somthing~

   - Some simple helper functions:
     #+BEGIN_SRC haskell
       charInWord :: Puzzle -> Char -> Bool
       charInWord (Puzzle answer _ _) char = char `elem` answer

       alreadyGuessed :: Puzzle -> Char -> Bool
       alreadyGuessed (Puzzle _ _ guessed) char = char `elem` guessed

       renderPuzzleChar :: Maybe Char -> Char
       renderPuzzleChar Nothing = '_'
       renderPuzzleChar (Just c)  = c
     #+END_SRC

   - Other helper functions:
     #+BEGIN_SRC haskell
       fillInCharacter :: Puzzle -> Char -> Puzzle
       fillInCharacter (Puzzle word filledInSoFar s) c =
         Puzzle word newFilledInSoFar (c : s)
         where zipper gueesed wordChar guessChar =
                 if wordChar == guessed
                 then Just wordChar
                 else guessChar

               newFilledInSoFar =
                 zipWith (zipper c) word filledInSoFar

       handleguess :: Puzzle -> Char -> IO Puzzle
       handleguess puzzle guess = do
         putStrLn $ "Your guess was: " ++ [guess]
         case (charInWord puzzle guess,
               alreadyGuessed puzzle guess) of
           (_, True) -> do
             putStrLn "You already guessed that\
                       \ character, pick something else!"
             return puzzle
           (True, _) -> do
             putStrLn "This character was in the word,\
                       \ filling in the word accordingly"
             return (fillInCharacter puzzle guess)
           (False, _) -> do
             putStrLn "This character was in the word,\
                       \ filling in the word accordingly"
             return (fillInCharacter puzzle guess)
     #+END_SRC

   - Is game over?
     #+BEGIN_SRC haskell
       gameOver :: Puzzle -> IO ()
       gameOver (Puzzle wordToGuess _ guessed) =
         if (length guessed) > 7 then
           do putStrLn "You lose!"
              putStrLn $ "The word was: " ++ wordToGuess
              exitSuccess
         else return ()
     #+END_SRC
     Notice the WAY it's written says YOU LOSE and exits the game once you've
     guessed seven characters, 
     even if the final (seventh) guess is the final letter to fill into the word.
     (This isn't quite reasonable, we encourage you to play with that.)

   - Does the player win the game?
     #+BEGIN_SRC haskell
       gameWin :: Puzzle -> IO ()
       gameWin (Puzzle _ filledInSoFar _) =
         if all isJust filledInSoFar then
           do putStrLn "You win!"
              exitSuccess
           else return ()
     #+END_SRC

   - The instruction for running a game (here use ~forever~).
     #+BEGIN_SRC haskell
       runGame :: Puzzle -> IO ()
       runGame puzzle = forever $ do
         gameOver puzzle
         gameWin puzzle
         putStrLn $ "Current puzzle is: " ++ show puzzle
         PutStr "Guess a letter: "
         guess <- getLine
         case guess of
           [c] -> handleGuess puzzle c >>= runGame
           _ -> putStrLn "Your guess must\
                        \ be a single character"
     #+END_SRC

   - The ~main~:
     #+BEGIN_SRC haskell
       main :: IO ()
       main = do
         word <- randomWord'
         let puzzle = freshPuzzle (fmap toLower word)
         runGame puzzle
     #+END_SRC
     No explanation to the ~let~ in ~do~ block.
     I think you need the ~let~ because of that ~freshPuzzle~ doesn't return an/
     IO monad/, it's just a ~Puzzle~ value.

     =TODO= =???=
     Can't be without ~let~, Right?  =WHY=

** DONE 13.13 Adding a ~newtype~ - 520
   CLOSED: [2017-06-17 Sat 04:19]
   Modify the code above and gain, perhaps, more clarity in places is with the
   use of ~newtype~ (only the modified functions):
   #+BEGIN_SRC haskell
     newtype WordList =
       WordList [String]
       deriving (Eq, Show)

     allWords :: IO WordList
     allWords = do
       dict <- readFile "data/dict.txt"
       return $ WordList (lines dict)

     gameWords :: IO WordList
     gameWords = do
       (WordList aw) <- allWords
       return $ WordList (filter gameLength aw)
       where gameLength w =
               let l = length (w :: String)
               in l > minWordLength && l < maxWordLength

     randomWord :: WordList -> IO String
     randomWord (WordList wl) = do
       randomIndex <- randomRIO (0, length wl - 1)
       return $ wl !! randomIndex
   #+END_SRC
   
** DONE 13.14 Chapter exercises - 521 - TODO
   CLOSED: [2017-07-28 Fri 20:35]
*** DONE Hangman game logic - 521
    CLOSED: [2017-07-28 Fri 20:34]
*** DONE Modifying code - 522 TODO
    CLOSED: [2017-06-25 Sun 22:36]
    1. =TODO=
       #+BEGIN_SRC haskell
         import System.IO (hSetBuffering, stdout, BufferMode(NoBuffering))

         interactiveCaesar = do
           hSetBuffering stdout NoBuffering  -- For the interactive program, this line is IMPORTANT
           putStr "Please input a number: "
           nStr <- getLine
           putStr "Please input a piece of message which requires encryption: "
           info <- getLine
           return $ caesar (read nStr) info
       #+END_SRC

    2. 
       #+BEGIN_SRC haskell
         import Control.Monad (forever)
         import System.Exit (exitSuccess)

         palindrome :: IO ()
         palindrome = forever $ do
           line1 <- getLine
           case (line1 == reverse line1) of
             True -> putStrLn "It's a palindrome!"
             False -> do
               putStrLn "Nope!"
               exitSuccess
       #+END_SRC

    3. 
       #+BEGIN_SRC haskell
                  import Control.Monad (forever)
                  import System.Exit (exitSuccess)
                  import Data.Char (toLower, isLetter)

                  palindrome :: IO ()
                  palindrome = forever $ do
                    line1 <- getLine
                    let onlyLowerLetters = map toLower $ filter isLetter line1
                    case (onlyLowerLetters == reverse onlyLowerLetters) of
                      True -> putStrLn "It's a palindrome!"
                      False -> do
                        putStrLn "Nope!"
                        exitSuccess
       #+END_SRC

    4. 
       #+BEGIN_SRC haskell
         import System.IO (hSetBuffering, stdout, BufferMode(NoBuffering))

         type Name = String
         type Age = Integer

         data Person = Person Name Age deriving Show
         data PersonInvalid = NameEmpty
                            | AgeTooLow
                            | PersonInvalidUnknown String
                            deriving (Eq, Show)

         mkPerson :: Name
                  -> Age
                  -> Either PersonInvalid Person
         mkPerson name age
           | name /= "" && age > 0 = Right $ Person name age
           | name == "" = Left NameEmpty
           | not (age > 0) = Left AgeTooLow
           | otherwise = Left $ PersonInvalidUnknown $
                                "Name was: " ++ show name ++
                                " Age was: " ++ show age

         gimmePerson :: IO ()
         gimmePerson = do
           hSetBuffering stdout NoBuffering -- For the interactive program, this line is IMPORTANT
           putStr "Please input your name: "
           name <- getLine
           putStr "Please input your age: "
           ageString <- getLine

           case mkPerson name (read ageString) of
             Right p -> do
               putStr "Yay! Successfully got a person: "
               putStrLn $ show p
             Left invalidP -> do
               putStr "Error: "
               putStrLn $ show invalidP
       #+END_SRC

** TODO 13.15 Follow-up resources - 524

* TODO 14 Testing - 525 - [ _Reading_ ] 
** DONE 14.1 Testing - 526
   CLOSED: [2017-06-17 Sat 04:46]
   This chapter, like the one before it, is more *focused on practical matters*
   _rather than_ writing Haskell code per se.

   - We will
     be covering _TWO_ testing libraries for Haskell (_there are others_)
     and
     _HOW_ and _WHEN_ to use them

   - As ALWAYS, if you type rather than copy and paste, you can learn more!!!

   - Well-specified types can enable programmers to avoid many obvious and
     tedious tests that might otherwise be necessary to maintain in untyped
     programming languages,

     *However, there still can be wrong values!!!*
     AND

     =from JIAN=
     Don't forget! Haskell by default is NOT a dependent typed language, and
     sometimes you need to prove by hand on paper the instances of that some
     algebraic structure corresponding /type classes/ can really satisfy the laws
     enforced on them. Usually you need to do two things:

     + proof by hand on paper is required!

     + write tests for the enforced laws:
       1. you proof might be wrong!

       2. even if your proof is right for your current implementation, it might
          become wrong in your future implementations. You need the tests as
          your guards.

   - This chapter will cover:
     + the *what's* and *why's* of /testing/;
     + using the _testing libraries_ *Hspec* and *QuickCheck*;
     + a bit of fun with Morse code.

** DONE 14.2 A quick tour of testing for the uninitated - 526
   CLOSED: [2017-06-17 Sat 05:21]
   - Haskell compiler cannot prevent all bugs.
     Runtime errors can still occur. That's where testing comes in.

   - For the sake of simplicity, we'll say there are _TWO_ broad categories of
     testing:
     + unit testing
     + property testing =???=

   - /unit testing/: test the smallest atomic units of software independently of
     one another.
     =FROM JIAN= It seems this kind of tests prefer /referential transparency/.

   - /spec testing/: a somewhat =???= newer version of /unit testing/.
     =TODO= =???=
     + Like /unit testing/, it tests specific functions independently

     + Ask you to assert when given the declared input, the result of the
       operation will be equal to the desired result.

   - Some people prefer /spec testing/ to /unit testing/

     because /spec testing/ is more often written in terms of assertions that
     are in human-readable language.

   - *Hspec* for /spec testing/
     *HUnit* for /unit testing/

   - One Limitation of both /spec testing/ and /unit testing/:
     They do NOT verify all the pieces work _TOGETHER_ properly.

   - /property testing/: test the formal properties of programs
     _WITHOUT_ requiring formal proofs
     by allowing you to express a truth-valued, universally qualified (that is,
     will apply to all cases) function -- usually equality -- which will then be
     checked _against RANDOMLY generated input_.

   - /property testing/ was *pioneered in Haskell*

     because
     + the type system (=from JIAN= well-designed, powerful)
       and 
     + straightforward logic (=from JIAN= Purely functional, no mutable value)

     of the language lend themselves to /property test/,

     but it has since been adopted by other languages (for example, Scala) as
     well.

   - *QuickCheck* (for Haskell /property testing/)

   - The inputs of /property testing/ of Haskell are generated randomly by the
     standard functions inside the _QuickCheck_ library -- *this relies on the
     type system to know what kinds of data to generate.*

     + The default setting is for 100 inputs.

     + *QuickCheck* is cleverly written to be
       _as thorough as possile_ and will _usually check the *most common edge
       cases*,_ for example,
       * empty lists
       * maxBound and minBound of the types in question.

   - /Property testing/ is fantastic for ensuring that you’ve met the minimum
     requirements to satisfy laws,
     such as
     + the laws of monads;  =TODO= =Concrete Exmples?= =TODO=
     + basic associativity. =TODO= =Concrete Exmples?= =TODO=
     
** DONE 14.3 Conventional testing - 528
   CLOSED: [2017-06-27 Tue 02:24]
   - Use ~Hspec~ here

   - No deep exlanation for ~Hspec~ in this section.

   - ~hs-source-dirs: .~: Make the ~Addition~ module (exposed-modules) in the
     same directory as our Cabal file.

   - Create a small /Cabal/ project (still use /Stack/):
     + Step 1: create a =.cabal= file.
       #+BEGIN_SRC yaml
         -- Addition.cabal
         name:            addition
         version:         0.1.0.0
         license-file:    LICENSE
         author:          Chicken Little
         maintainer:      sky@isfalling.org
         category:        Text
         build-type:      Simple
         cabal-version:   >=1.10

         library
           exposed-modules:  Addition
           ghc-options:      -Wall -fwarn-tabs
           build-depends:    base >=4.7 && <5
                           , hspec
           hs-source-dirs:   .
           default-language: Haskell2010
       #+END_SRC

     + Step 2: create a placeholder function.
       #+BEGIN_SRC haskell
         -- Addition.hs
         module Addition where

         sayHello :: IO ()
         sayHello = putStrLn "hello!"
       #+END_SRC

     + Step 3:  create a =LICENSE= file to avoid the complain when build

       Now your project directory structure is:
       #+BEGIN_SRC bash
         # $ tree
         # .
         # |-- Addition.hs
         # |__ additon.cabal
         # |__ LICENSE
       #+END_SRC

     + Run ~stack init~ and ~stack build~

     Then, you can use ~stack ghci~ load and run the function ~sayHello~ (See
     step 2).

*** DONE Truth according to ~Hspec~
    CLOSED: [2017-06-17 Sat 17:51]
    - (Step 4: add ~Test.Hspec~)
      #+BEGIN_SRC haskell
        module Addition where

        import Test.Hspec

        sayHello :: IO ()
        sayHello = putStrLn "hello!"
      #+END_SRC

      =Note=:
      _All_ of your _imports_ must occur
      + _after_ the module has been declared
        and
      + _before_ any expressions have been defined in your module.

    - ~:r~ or ~:reload~

    - ~:browse~ is useful when you _already_ have some familiarity with the
      library and how it works.

      Use documentation when you are _NOT_ familiar with a library.

*** DONE Our first ~Hspec~ test
    CLOSED: [2017-06-17 Sat 18:18]
    - Now add a test assertion to our module:
      #+BEGIN_SRC haskell
        module Addition where

        import Test.Hspec

        main :: IO ()
        main = hspec $ do
          describe "Addition" $ do
            it "1 + 1 is greater than 1" $ do
              (1 + 1) > 1 `shouldBe` True
            it "22 divided by 5 is 4 remainder 2" $ do
              dividedBy 22 5 `shouldBe` (4, 2)

        dividedBy :: Integral a => a -> a -> (a, a)
        dividedBy num denom = go num denom 0
          where go n d count
                 | n < d = (count, n)
                 | otherwise = go (n - d) d (count + 1)
      #+END_SRC

    - Types:
      #+BEGIN_SRC haskell
        hspec :: Spec -> IO ()

        describe :: String -> SpecWith a -> SpecWith a

        Test.Hspec.it :: Example a => String -> a -> SpecWith (Arg a)
        -- Don't use `:t it` in GHCi, this `it` is created and used by GHCi to save the
        -- latest calculated value. Its type keep changing accroding to the type of the
        -- last value.
      #+END_SRC

    - Compare the types of ~shouldBe~ and ~(==)~:
      #+BEGIN_SRC haskell
        shouldBe :: (Eq a, Show a) => a -> a -> Expectation

        -- contrast with

        (==) :: Eq a => a -> a -> Bool
      #+END_SRC
      In a sense, ~shouldBe~ is an augmented ~(==)~ embedded in Hspec's model of
      the universe. It needs the ~Show~ instance in order to render a value.

*** DONE Intermission: Short Exercise
    CLOSED: [2017-07-06 Thu 19:39]
    A LOT of warnings from the test part (~main~).
    =TODO= HOW can I get rid of these warnings.
    #+BEGIN_SRC haskell
      main :: IO ()
      main = hspec $ do
        describe "Multiply Two Integral Numbers" $ do
          it "3 * 4 is 12" $ do
            (3 `recMult` 4) `shouldBe` 12
          it "7 * 0 is 0" $ do
            (7 `recMult` 0) `shouldBe` 0

      recMult Integer -> Integer -> Integer
      recMult x y
        | (x == 0) || (y == 0) = 0
        | otherwise = go (min xAbs yAbs) 0
        where
          xAbs = abs x
          yAbs = abs y
          sign = (signum x) * (signum y)
          m = sign * max xAbs yAbs
          go n acc
            | n == 0 = acc
            | n >= 1 = go (n - 1) (acc + m)
            | otherwise = acc + n * m
    #+END_SRC

** DONE 14.4 Enter ~QuickCheck~ - 535
   CLOSED: [2017-07-06 Thu 21:24]
   - ~Hspec~ can ONLY prove something about particular values.

     Use ~QuickCheck~ to get assurances that are
     + stronger,
     + something closer to proofs.

   - ~QuickCheck~ was the first library to offer what is today called
     "property testing".

   - First, add =QuickCheck= to our ~build-depends~ in =.cabal=.
     It should already be installed, as ~Hspec~ has ~QuickCheck~ as a dependency.
     You might need to reinstall it (~stack build~). Then open a new ~stack ghci~
     session.

   - ~Hspec~ has ~QuickCheck~ integration out of the box, so one that is done,
     add the following to your module:
     #+BEGIN_SRC haskell
       import Test.QuickCheck

       -- to the same describe block as the others
           it "x + 1 is always greater than x" $ do
             property $ \x -> x + 1 > (x :: Int)
     #+END_SRC
     The type assertion here is important. Complier can't work without it.
     _DO THIS IN the ~property~  expression_.

     Now you can run the tests.

   - The number of tests ~QuickCheck~ runs defaults to _100_.
     Most of the inputs are generated randomly, while some of the inputs of
     common corner cases will always be tested (For example, if the input should
     be ~Num a~, ~0~ is always be tested).

*** DONE Arbitrary instances - 537
    CLOSED: [2017-07-06 Thu 21:23]
    - ~QuickCheck~ relies on
      + a type class called ~Arbitrary~
        and
      + a ~newtype~ called ~Gen~ for generating its random data.

    - ~arbitrary~ is a value of type ~Gen~:
      #+BEGIN_SRC haskell
        -- Prelude> :t arbitrary
        arbitrary :: Arbitrary a => Gen a
      #+END_SRC
      This is merely a way to set a default generator for a type.

    - How do we see a list of values of the correct type for ~QuickCheck~ tests?
      Use
      + ~sample \colon{}\colon{} Show a => Gen a -> IO ()~
        or
      + ~sample' \colon{}\colon{} Gen a -> IO [a]~
      #+BEGIN_SRC haskell
        -- Prelude> sample (arbitrary :: Gen Int)
        -- 0
        -- -2
        -- -1
        -- 4
        -- -3
        -- 4
        -- 2
        -- 4
        -- -3
        -- 2
        -- -4

        -- Prelude> sample (arbitrary :: Gen Double)
        -- 0.0
        -- 0.13712502861905426
        -- 2.9801894108743605
        -- -8.960645064542609
        -- 4.494161946149201
        -- 7.903662448338119
        -- -5.221729489254451
        -- 31.64874305324701
        -- 77.43118278366954
        -- -539.7148886375935
        -- 26.87468214215407
      #+END_SRC

      If you didn't specify the type of ~arbirary~, a list of unit value ~()~
      would be returned (with a warning message).

    - Use the ~Arbitrary~ type class in order to provide a generator for ~sample~.
      It isn't a terribly principled type class, but it is poplular and useful for
      this usage.

      We say it is unprincipled because it has no laws and nothing specific it's
      supposed to do. It's just a convenient way of plucking a canonical
      generator for ~Gen~ a out of thin air without having to know where it comes
      from.

    - Run ~sample arbitrary~ in /GHCi/ you will get a list of empty tuples.

      Write ~sample arbitrary~ into a source file, and load it in /GHCi/. Then
      you will get some error messages from /GHC/ about having an ambiguous type.

      /GHCi/ has somewhat different rules for default types than /GHC/ does.

    - Specify our own data for generating ~Gen~ values.
      A trivial function that always returns a ~1~ of type ~Int~:
      #+BEGIN_SRC haskell
        trivialInt :: Gen Int
        trivialInt = return 1
      #+END_SRC

      #+BEGIN_SRC haskell
        -- Prelude> sample' trivialInt
        -- [1,1,1,1,1,1,1,1,1,1]
      #+END_SRC

    - ~elements \colon{}\colon{} [a] -> Gen a~

    - Another (not that trivial) example:
      #+BEGIN_SRC haskell
        -- #1  Equal chance
        oneThroughThree :: Gen Int
        oneThroughThree = elements [1, 2, 3]

        sample' oneThroughThree
        -- [2,3,3,2,2,1,2,1,1,3,3]
        -- Only from [1, 2, 3], equal chance, random number

        -- #2  Non-equal chance
        oneThroughThree' :: Gen Int
        oneThroughThree' = elements [1, 2, 2, 2, 2, 3]
        -- You can adjust the chance by repeating some elements.
        sample' oneThroughThree'
      #+END_SRC

    - ~choose \colon{}\colon{} System.Random.Random a => (a, a) -> Gen a~

    - Examples:
      + Simple ones:
        #+BEGIN_SRC haskell
          genBool :: Gen Bool
          genBool = choose (False, True)

          genBool' :: Gen Bool
          genBool' = elements [False, True]

          genOrdering :: Gen Ordering
          genOrdering = elements [LT, EQ, GT]

          genChar :: Gen Char
          genChar = elements ['a'..'z']

          -- sample genBool
          -- sample genBool'
          -- sample genOrdering
          -- sample genChar
        #+END_SRC

      + Not that simple ones:
        #+BEGIN_SRC haskell
          genTuple :: (Arbitrary a, Arbitrary b) => Gen (a, b)
          genTuple = do
            a <- arbitrary
            b <- arbitrary
            return (a, b)

          genThreeple :: (Arbitrary a, Arbitrary b, Arbitrary c) => Gen (a, b, c)
          genThreeple = do
            a <- arbitrary
            b <- arbitrary
            c <- arbitrary
            return (a, b, c)

          -- Prelude> sample genTuple
          -- ((),())
          -- ((),())
          -- ((),())
          -- ...

          -- Prelude> sample (genTuple :: Gen (Int, Float))
          -- (0, 0.0)
          -- (-1, 0.2516606)
          -- (3, 0.7800742)
          -- (5, -61.62875)
          -- ...

          -- Prelude> sample (genTuple :: Gen ([()], Char))
          -- ([],'\STX')
          -- ([()],'X')
          -- ([],'?')
          -- ([],'\137')
          -- ([(),()],'\DC1')
          -- ([(),()],'z')
          -- ...
        #+END_SRC

      + Generate arbitrary ~Maybe~ or ~Either~ values:
        #+BEGIN_SRC haskell
          genEither :: (Arbitrary a, Arbitrary b) => Gen (Either a b)
          genEither = do
            a <- arbitrary
            b <- arbitrary
            elements [Left a, Right b]


          -- equal probability
          genMaybe :: Arbitrary a => Gen (Maybe a)
          genMaybe = do
            a <- arbitrary
            elements [Nothing, Just a]


          -- What QuickCheck actually does
          -- so you get more Just values
          genMaybe' :: Arbitrary a => Gen (Maybe a)
          genMaybe' = do
            a <- arbitrary
            frequency [ (1, return Nothing)
                      , (3, return (Just a))]

          -- frequency :: [(Int, Gen a)] -> Gen a
        #+END_SRC

        * ~frequency~

*** DONE Using ~QuickCheck~ without ~Hspec~ - 543
    CLOSED: [2017-06-27 Tue 03:56]
    - Use ~QuickCheck~ without ~Hspec~.
      Re-write our previous example as follows
      (In this version, since not as a part of the parameter of ~hspec~, the type
       is given in the type level, and there is no need to write it in term
       level):
      #+BEGIN_SRC haskell
        prop_additionGreater :: Int -> Bool
        prop_additionGreater x = x + 1 > x

        runQc :: IO ()
        runQc = quickCheck prop_additionGreater
      #+END_SRC
      =TODO= For now, we DON'T need to worry about how ~runQc~ does its work. 

      #+BEGIN_SRC haskell
        -- Prelude> runQc
        -- +++ OK, passed 100 tests.

        -- -- If we assert something untrue:
        prop_additionGreater x = x + 0 > x
        -- Prelude> :r
        -- [1 of 1] Compiling Addition
        -- Ok, modules loaded: Addition.
        --
        -- Prelude> runQc
        -- *** Failed! Falsifiable (after 1 test):
        -- 0
      #+END_SRC

    - Conveniently,
      ~QuickCheck~ _doesn't just_ tell us that our test failed,
      BUT it tells us the _first input_ it encountered that it failed on.

    - Actually, look at the last line of the FAILED example, the value that it
      fails on is always ~0~.

      As we mentioned before
      + ~QuickCheck~ has some _builtin cleverness_
        and
      + It tries to ensure that _common error boundaries_ will always get tested.

      The input ~0~ is a frequent point of failure, so ~QuickCheck~ tries to
      ensure that it is always tested (_when appropriate, given the types_, etc
      etc).

** DONE 14.5 Morse code - 544
   CLOSED: [2017-07-06 Thu 23:15]
   - ~stack new project-name~ create a new project and use the latest lts.
     ~stack new project-name --resolver lts-7.24~ use a specific lts.

   - ~Setup.hs~ is there. Its content is:
     #+BEGIN_SRC haskell
       import Distribution.Simple
       main = defaultMain
     #+END_SRC
     You _rarely_ need to modify or do anything at all with it.
     Usually you shouldn't touch it at all.

     However, you should know it's there, and, occasionally, you many need to
     edit it.

   - Next, get our =.cabal= file configured properly.
     =See the book (v0.12): page 544=

   - Next, create our source file ~Morse.hs~:
     This is just the basic setups.
     #+BEGIN_SRC haskell
       -- src/Morse.hs

       module Morse
              ( Morse
              , charToMorse
              , morseToChar
              , stringToMorse
              , letterToMorse
              , morseToLetter
              ) where

       import qualified Data.Map as M

       type Morse = String
     #+END_SRC

   - *Nota bene*
     The export setting above is unnecessary if you want to exports all.

     This is good habit that put allow all the things to be exported FIRST, and
     then remove the some of them when we realize that it's unnecessary to export
     them as we proceed in development.
     =For this project, we do in this way.=

*** DONE Turning words into code - 546
    CLOSED: [2017-07-06 Thu 22:36]
    - We import ~Data.Map~.
      The keys of a /Map/ should be orderable (this is, must have an ~Ord~
      instance).

    - =TODO=
      #+BEGIN_SRC haskell
        letterToMorse :: (M.Map Char Morse)
        letterToMorse = M.fromList [
              ('a', ".-")
            , ('b', "-...")
            , ('c', "-.-.")
            , ('d', "-..")
            , ('e', ".")

            , ('f', "..-.")
            , ('g', "--.")
            , ('h', "....")
            , ('i', "..")
            , ('j', ".---")
            , ('k', "-.-")

            , ('l', ".-..")
            , ('m', "--")
            , ('n', "-.")
            , ('o', "---")
            , ('p', ".--.")
            , ('q', "--.-")

            , ('r', ".-.")
            , ('s', "...")
            , ('t', "-")
            , ('u', "..-")
            , ('v', "...-")
            , ('w', ".--")

            , ('x', "-..-")
            , ('y', "-.--")
            , ('z', "--..")
            , ('1', ".----")
            , ('2', "..---")
            , ('3', "...--")
            , ('4', "....-")
            , ('5', ".....")
            , ('6', "-....")
            , ('7', "--...")
            , ('8', "---..")
            , ('9', "----.")
            , ('0', "-----")
            ]

        morseToLetter :: M.Map Morse Char
        morseToLetter =
          M.foldWithKey (flip M.insert) M.empty
                        letterToMorse

        charToMorse :: Char -> Maybe Morse
        charToMorse c =
          M.lookup c letterToMorse

        stringToMorse :: String -> Maybe [Morse]
        stringToMorse s =
          sequence $ fmap charToMorse s

        morseToChar :: Morse -> Maybe Char
        morseToChar m =
          M.lookup m morseToLetter
      #+END_SRC

*** DONE The ~Main~ event - 549
    CLOSED: [2017-07-06 Thu 22:36]
    - Next,
      set up a ~Main~ module that will actually handle our Morse code conversions.
      #+BEGIN_SRC haskell
        -- src/Main.hs
        module Main where

        import Control.Monad (forever, when)
        import Data.List (intercalate)
        import Data.Traversable (traverse)
        import Morse (stringToMorse, morseToChar)
        import System.Environment (getArgs)
        import System.Exit (exitFailure,
                            exitSuccess)
        import System.IO (hGetLine, hIsEOF, stdin)
      #+END_SRC

    - =TODO= _CODE_

*** DONE [ =SOME-WARNING= ] Make sure it's all working - 551
    CLOSED: [2017-07-06 Thu 23:01]
    #+BEGIN_SRC bash
    echo "hi" | stack exec morse to
    # .... ..

    echo ".... .." | stack exec morse from
    # hi
    #+END_SRC

    - Use ~stack exec which morse~ to find the =morse= excutable.

    - You can use ~stack install~ to copy the binaries from your project into a
      common directory (=.local/bin= on Mac and Linux).

*** DONE Time to test! - 552
    CLOSED: [2017-07-06 Thu 23:15]
    #+BEGIN_SRC haskell
      -- tests/tests.hs

      module Main where

      import qualified Data.Map as M
      import Morse
      import Test.QuickCheck

      allowedChars :: [Char]
      allowedChars = M.keys letterToMorse

      allowedMorse :: [Morse]
      allowedMorse = M.elems letterToMorse

      charGen :: Gen Char
      charGen = elements allowedChars

      morseGen :: Gen Morse
      morseGen = elements allowedMorse

      prop_thereAndBackAgain :: Property
      prop_thereAndBackAgain =
        forAll charGen
        (\c -> ((charToMorse c)
          >>= morseToChar) == Just c)

      main :: IO ()
      main = quickCheck prop_thereAndBackAgain
    #+END_SRC

*** DONE Testing the Morse code - 554
    CLOSED: [2017-07-06 Thu 23:15]
    - Step 1. ~stack build~
      =Not mentioned in the bookv0.12=
      Especially you build it before -- you should re-build it now

    - Step 2. ~stack ghci morse:tests~

    - Step 3. When see prompt =*Main>= run ~main~.

** DONE 14.6 Arbitrary instances - 554
   CLOSED: [2017-07-29 Sat 06:03]
   One of the more important parts of ~QuickCheck~ is learning to write instances
   of the ~Arbitrary~ type class for your datatypes.

   It's a somewhat unfortunate but still necessary convenience for your code to
   integrate cleanly with QuickCheck code. =TODO= =what does this mean?=

   It's initially a bit confusing for beginners because it compacts a few
   different concepts and solutions to problems into a single type class.
   =TODO=

*** DONE Babby's First ~Arbitrary~ - 555
    CLOSED: [2017-07-07 Fri 23:31]
    First, a maximally simple ~Arbitrary~ instance for the ~Trival~ datatype.
    #+BEGIN_SRC haskell
      module Main where

      import Test.QuickCheck

      data Trival =
        Trival
        deriving (Eq, Show)

      trivalGen :: Gen Trivial
      trivalGen =
        return Trival

      instance Arbitrary Trivial where
        arbitrary = trivalGen


      main :: IO
      main = do
        sample trivalGen

      -- Prelude> sample trivialGen
      -- Trivial
      -- Trivial
      -- Trivial
      -- Trivial
      -- Trivial
      -- Trivial
      -- Trivial
      -- Trivial
      -- Trivial
      -- Trivial
    #+END_SRC

*** DONE ~Identity~ Crisis - 556
    CLOSED: [2017-07-07 Fri 23:38]
    #+BEGIN_SRC haskell
      data Identity a =
        Identity a
        deriving (Eq, Show)

      identityGen :: Arbitrary a => Gen (Identity a)
      identityGen = do
        a <- arbitrary
        return (Identity a)

      instance Arbitrary a => Arbitrary (Identity a) where
        arbitrary = identityGen

      identityGenInt :: Gen (Identity Int)
      identityGenInt = identityGen

      -- Prelude> sample identityGenInt
      -- Identity 0
      -- Identity (-1)
      -- Identity 2
      -- Identity 4
      -- Identity (-3)
      -- Identity 5
      -- Identity 3
      -- Identity (-1)
      -- Identity 12
      -- Identity 16
      -- Identity 0
    #+END_SRC

*** DONE ~Arbitrary~ Products - 557
    CLOSED: [2017-07-07 Fri 23:46]
    #+BEGIN_SRC haskell
      data Pair a b =
        Pair a b
        deriving (Eq, Show)

      pairGen :: (Arbitrary a,
                  Arbitrary b) => Gen (Pair a b)
      pairGen = do
        a <- arbitrary
        b <- arbitrary
        return (Pair a b)

      instance (Arbitrary a,
                Arbitrary b) => Arbitrary (Pair a b) where
        arbitrary = pairGen

      pairGenIntString :: Gen (Pair Int String)
      pairGenIntString = pairGen

      -- Prelude> sample pairGenIntString
      -- Pair 0 ""
      -- Pair (-2) ""
      -- Pair (-3) "26"
      -- Pair (-5) "B\NUL\143:\254\S0"
      -- Pair (-6) "\184*\239\DC4"
      -- Pair 5 "\238\213=J\NAK!"
      -- Pair 6 "Pv$y"
      -- Pair (-10) "G|J^"
      -- Pair 16 "R"
      -- Pair (-7) "("
      -- Pair 19 "i\ETX]\182\ENQ"
    #+END_SRC

*** DONE Greater than the sum of its parts - 558
    CLOSED: [2017-07-07 Fri 23:52]
    #+BEGIN_SRC haskell
      import Test.QuickCheck.Gen (oneof)

      data Sum a b =
          First a
        | Second b
        deriving (Eq, Show)

      -- equal odds for each
      sumGenEqual :: (Arbitrary a,
                      Arbitrary b) => Gen (Sum a b)
      sumGenEqual = do
        a <- arbitrary
        b <- arbitrary
        -- `oneof` creates a `Gen a` from a list of `Gen a` by giving each value an
        -- equal probability.
        oneof [return $ First a,
               return $ Second b]

      sumGenCharInt :: Gen (Sum Char Int)
      sumGenCharInt = sumGenEqual

      -- Prelude> sample sumGenCharInt
      -- First 'p'
      -- First '\227'
      -- First '\238'
      -- First '.'
      -- Second (-3)
      -- First '\132'
      -- Second (-12)
      -- Second (-12)
      -- First '\186'
      -- Second (-11)
      -- First '\v'


      -- Adjust the weight
      sumGenFirstPls :: (Arbitrary a,
                         Arbitrary b) => Gen (Sum a b)
      sumGenFirstPls  = do
        a <- arbitrary
        b <- arbitrary
        frequency [(10, return $ First a),
                   (1, return $ Second b)]

      sumGenCharIntFirst :: Gen (Sum Char Int)
      sumGenCharIntFirst = sumGenFirstPls

      -- Prelude> sample sumGenCharIntFirst
      -- First '\208'
      -- First '\242'
      -- First '\159'
      -- First 'v'
      -- First '\159'
      -- First '\232'
      -- First '3'
      -- First 'l'
      -- Second (-16)
      -- First 'x'
      -- First 'Y'
    #+END_SRC

*** DONE [ =Re-Read= ] ~CoArbitrary~ - =DELETED from RC4=
    CLOSED: [2017-07-29 Sat 06:02]
    ~CoArbitrary~ is a counterpart to ~Arbitrary~ that enables the generation of
    functions fitting a particular type.

    Rather than talking about random values you can get via ~Gen~, it lets you
    provide functions with a value of type ~a~ as an argument in order to _vary_
    a ~Gen~.
    #+BEGIN_SRC haskell
      arbitrary :: Arbitrary a => Gen a

      coarbitrary :: CoArbitrary a =>
                     a -> Gen b -> Gen b
    #+END_SRC

    #+BEGIN_SRC haskell
      {-# LANGUAGE DeriveGeneric #-}

      module CoArbitrary where

      import GHC.Generics
      import Test.QuickCheck

      data Bool' =
          True'
        | False'
        deriving (Generic)

      instance CoArbitrary Bool'

      -- plus the above

      trueGen :: Gen Int
      trueGen = coarbitrary True' arbitrary

      falseGen :: Gen Int
      falseGen = coarbitrary False' arbitrary
    #+END_SRC

** TODO 14.7 Chapter Exercises - 561
*** DONE Validating numbers into words - 561
    CLOSED: [2017-07-29 Sat 06:24]
    1. ~digitToWord 1 `shouldBe` "one"~
    2. ~digits 100 `shouldBe` [1, 0, 0]~
    3. ~wordNumber 9001 `shouldBe` "nine-zero-zero-one"~

*** TODO Using ~QuickCheck~ - 562
*** DONE Failure - 564
    CLOSED: [2017-07-31 Mon 00:19]
*** DONE Idempotence - 564
    CLOSED: [2017-07-31 Mon 00:50]
*** TODO Make a ~Gen~ random generator for the datatype - 565
*** TODO Hangman testing - 565
*** TODO Validating ciphers - 567

** DONE 14.8 Definitions - 567
   CLOSED: [2017-07-06 Thu 23:22]
   1. /Unit testing/: Test the smallest parts of an application possible.

   2. /Property testing/: a subset of a large input space is validated, usually
      against a property or law some code should abide by.

      In Haskell, this is usually done with ~QuickCheck~.

      Common properties that are checked using property testing are things like
      (=From Jian= You will see later that these properties are often possesed
       by some type class. Thus, property testing is very useful for testing
       instances of some type classes):
      + identity
      + associativity
      + isomorphism
      + idempotence

   3. /idempotence/: We call an operation _, if apply it multiple times doesn't
      produce a different result from the first time.

** TODO 14.9 Follow-up resources - 567
   1. 
   2. 
   3. 

* TODO 15 ~Monoid~, ~Semigroup~ - 569
** DONE 15.1 Monoids and semigroups - 570
   CLOSED: [2018-05-06 Sun 18:42]
   - One of the finer points of the Haskell community has been its propensity
     for _recognizing abstract patterns in code which have well-defined, lawful
     representations in mathematics_.

   - This chapter will include:
     + Algebras!
     + Laws!
     + Monoids!
     + Semigroups!

** DONE 15.2 What we talk about when we talk about algebras - 570
   CLOSED: [2017-06-20 Tue 00:03]
   - /Algebra (a simple definition)/:
     + the rules of how to manipulate variables without reference to its
       particular value.
       or saying in another way
     + some operations and the set they operate over.

   - In Haskell,
     _these /algebras/ can be implemented with /type classes/._

** DONE 15.3 Monoid - 571
   CLOSED: [2017-06-20 Tue 00:08]
   /monoid/: a /monoid/ is a _binary_ _associative operation_ with an _identity_.

** DONE 15.4 How ~Monoid~ is defined in Haskell - 572
   CLOSED: [2017-06-20 Tue 00:18]
   - =IMPORTANT=
     Type Classes give us a way to recognize, organize, and use common
     functionalities and patterns across types that differ in some ways but also
     have things in common.

   - _Definition_ 
     #+BEGIN_SRC haskell
     class Monoid m where
       -- The identity value for that mappend operation
       mempty :: m
       -- How any two values that inhabit your type can be joined together
       mappend :: m -> m -> m   
       mconcat :: [m] -> m
       mconcat = foldr mappend mempty
     
     #+END_SRC

   - =TODO= =in later section= Laws to ~Monoid~

** DONE 15.5 Examples of using Monoid - 574
   CLOSED: [2017-06-20 Tue 00:32]
*** DONE ~List~ - 573
    CLOSED: [2017-06-20 Tue 00:32]
    List type instantiates ~Monoid~.

    - Examples
      #+BEGIN_SRC haskell
        mappend [1, 2, 3] [4, 5, 6]
        -- [1,2,3,4,5,6]
        -- -- mappend equivalent operation:
        -- -- Equivalence: (++)

        mconcat [[1..3], [4..6]]
        -- [1,2,3,4,5,6]
        -- -- mconcat equivalence operations:
        -- -- 1. concat
        -- -- 2. foldr (++) []

        mappend "Trout" " goes well with garlic"
        "Trout goes well with garlic"
      #+END_SRC

    - The definition of ~Monoid~ for lists:
      #+BEGIN_SRC haskell
        instance Monoid [a] where
          mempty = []
          mappend = (++)
      #+END_SRC

    -
** DONE 15.6 Why ~Integer~ doesn't have a Monoid - 574
   CLOSED: [2017-06-20 Tue 01:36]
   - Numeric types do NOT have ~Monoid~ instance.

     It seems all numberic types under two widely known operations can satisfy
     the requirement of ~Monoid~.

     Actually, this is the problem. It's not clear which one should be used as
     the specification to make the instance.

   - There is one way to resolve the conflict:
       Use ~Sum~ and ~Product~ _newtypes_ (they are built into the ~Monoid~
     library.) to wrap numberic values and signal which Monoid instance we want.
     #+BEGIN_SRC haskell
       import Data.Monoid

       mappend (Sum 1) (Sum 5)
       -- Sum {getSum = 6}

       mappend (Product 5) (Product 5)
       -- Product {getProduct = 25}

       mappend (Sum 4.5) (Sum 3.4)
       -- Sum {getSum = 7.9}
     #+END_SRC

   - We can use these _Monoid newtypes_ (~Sum~ and ~Product~) for _ALL_ the types
     that have instances of ~Num~.

   - Integers form a monoid under _summation_ and _multiplication_
     (either one at a time, but NOT BOTH simutaneously --
      A Monoid _ONLY_ requires one basice operation, and MUSTN'T be more than
      one).

   - Lists form a monoid under _concatenation_.

   - Several other types have more than one possible monoid
     (include List, though we didn't mention).

   - We usually _enforce_ the unique instance rule by

     using ~newtype~ _to separate the different monoidal behaviors_.  

*** DONE Why ~newtype~? - 576
    CLOSED: [2017-06-20 Tue 01:08]
    - Use of a ~newtype~ can be hard to justify or explain to people that don't
      yet have good intuitions for how Haskell code gets compiled and the
      representations of data used by your computer in the course of executing
      your programs.
      =TODO= =EXPLAIN LATER in details=

    - There is NOT much semantic difference (=TODO= =???= EXCEPT for
      circumstances involving /bottom/, explained later) between using ~newtype~
      and ~data~ in a legal way (~newtype~ supports less patterns).

    - The main differences:
      + ~newtype~ constrains the datatype to having a single unary data
        constructor.
      + ~newtype~ guarantees _NO additional runtime overhead_ in "wrapping" the
        original type.

    - *For veteran programmers that understand pointers*
      =TODO= =REVIEW C=
      ~newtype~ is like a single-member C union that avoids creating an extra
      pointer, but still gives you a new type constructor and data constructor
      so you don’t mix up the many many many things that share a single
      representation

    - *In summary, why you might use newtype*
      1. Signal intent: make it clear that you only intend for it to be a wrapper
         for the underlying type.

         The ~newtype~ cannot eventually grow into a more complicated sum or
         product type, while a normal datatype can.

      2. Improve type safety: avoid mixing up many values of the same
         representation, such as ~Text~ or ~Integer~.

      3. Add different type class instances to a type that is otherwise unchanged
         representationally, such as with ~Sum~ and ~Product~.
         =FROM JIAN= _This is the point of this section._

*** DONE More on ~Sum~ and ~Product~ - 577
    CLOSED: [2017-06-20 Tue 01:36]
   - There's _MORE THAN ONE_ valid ~Monoid~ instance one can write for numbers,
     so we use ~newtype~ wrappers to distinguish witch we want.

   - Use the infix operator for ~mappend~ in these examples:
     #+BEGIN_SRC haskell
       import Control.Applicative
       import Data.Monoid

       -- Prelude Control.Applicative Data.Monoid> :t (<>)
       -- (<>) :: Monoid m => m -> m -> m

       (Sum 1) `mappend` (Sum 1)  `mappend` (Sum 1)
       -- or
       (Sum 1) <> (Sum 1) <> (Sum 1)
       -- or
       Sum 1 <> Sum 1 <> Sum 1

       -- Sum {getSum = 3}
     #+END_SRC

   - We have notice ~Sum~ and ~Product~ have record field accessors:
     #+BEGIN_SRC haskell
       getSum $ mappend (Sum 1) (Sum 1)
       -- 2

       getProduct $ mappend (Product 5) (Product 5)
       -- 25

       getSum $ mconcat [(Sum 5), (Sum 6), (Sum 7)]
       -- 18
     #+END_SRC

** DONE 15.7 Why bother? - 579
   CLOSED: [2017-06-21 Wed 01:43]
   - A common use of monoids is to structure and describe common modes of
     processing data.

   - Sometimes this is to describe an API for incrementally processing a large
     dataset, sometimes to describe guarantees needed to roll up aggregations
     (think summation) in a parallel, concurrent, or distributed processing
     framework.

   - =TODO= =DON'T UNDERSTAND= Page 577 One example of ...

   - A variant of monoid that provides more guarantees is the
     /Abelian or commutative monoid/.

     + This /commutativity/ can be particularly helpful
       when doing _concurrent_ or _distributed processing of data_
       because it means the intermediate results being computed in a different
       order won't change the eventual answer.

   - /Monoid/ are even _strongly associated with_ the concept of
     /folding or catamorphism/. Here is an example:
     #+BEGIN_SRC haskell
       foldr mappend mempty ([2, 4, 6] :: [Product Int])
       -- Product {getProduct = 48}

       foldr mappend mempty ([2, 4, 6] :: [Sum Int])
       -- Sum {getSum = 12}

       foldr mappend mempty ["blah", "woot"]
       "blahwoot"
     #+END_SRC

   - =TODO= More about monoidal structure will come up when we explain
     Applicative and Monad as well.

** DONE 15.8 Laws - 580
   CLOSED: [2017-06-21 Wed 01:42]
   - ~Monoid~ instances must abie by the following laws:
     #+BEGIN_SRC haskell
       -- left identity
       mappend mempty x = x

       -- right identity
       mappend x mempty = x

       -- associativity
       mappend x (mappend y z) = mappend (mappend x y) z
       mconcat = foldr mappend mempty
     #+END_SRC

** DONE 15.9 Different instance, same representation - 583
   CLOSED: [2017-06-21 Wed 02:13]
   - /Monoid/ is somewhat _different_ from other type classes in Haskell, in that
     many datatypes have _more than one_ valid /monoid/.

     When this happen, use ~newtype~ to gell them apart, as we did with ~Sum~ and
     ~Product~.

   - The ~mappend~ of /Monoid/ is
     perhaps best thought of
     + _NOT_ as a way of combining values (like addition or list concatenation
       does),
     + _BUT_ as a way to condense any set of values to a summary value.

   - /Boolean/ values have _TWO_ possible monoids:
     + conjunction
     + disjunction
     Use newtypes ~All~ and ~Any~ to distinguish the two instances.
     #+BEGIN_SRC haskell
       import Data.Monoid

       All True <> All True
       -- All {getAll = True}

       All True <> All False
       -- All {getAll = False}


       Any True <> Any False
       -- Any {getAny = True}

       Any False <> Any False
       -- Any {getAny = False}
     #+END_SRC
     This is a good example that consider the ~<>~ as _condensing or reducing_,
     rather than _combining_.

   - The ~Maybe~ type actually has _more than two_ possible /Monoids/.
     Two most obvious:
     + ~First~
     + ~Last~

     Becuase ~Maybe~ is not like ~Bool~, if not choose one of ~First~ or ~Last~
     monoids we don't know what to return if both sides are ~Just~.
     #+BEGIN_SRC haskell
       First (Just 1) <> First (Just 2)
       -- First {getFirst = Just 1}

       Last (Just 1) <> Last (Just 2)
       -- Last {getLast = Just 2}
     #+END_SRC

     However, for ~Nothing~, no matter ~First~ or ~Last~, ~Just~ will be
     returned.
     #+BEGIN_SRC haskell
       First Nothing <> First (Just 2)
       -- First {getFirst = Just 2}

       Last Nothing <> Last (Just 2)
       -- Last {getLast = Just 2}
     #+END_SRC

** TODO 15.10 Reusing algebras by asking for algebras - 585
   - We mentioned there are more possible /monoids/ for ~Maybe~ than just ~First~
     and ~Last~.
       We'll now write that other ~Monoid~ instance:
     + NOT with choosing one value out of a set of values
     + BUT of _combining_ the ~a~ values contained within the ~Maybe a~ type.

   - If you do have a datatype that has ~a~ type argument that does _NOT_ appear
     anywhere in the terms,
     the typechecker does _NOT_ demand that you have a ~Monoid~ instance for that
     argument (NO need for the constraint ~Monoid a~).
     #+BEGIN_SRC haskell
       data Booly a =
           False'
         | True'
         deriving (Eq, Show)

       -- conjunction; just cause
       instance Monoid (Booly a) where
         mappend False' _ = False'
         mappend _ False' = False'
         mappend True' True' = True'
     #+END_SRC
     We didn't need a /monoid/ constraint for ~a~ because
     + we're never mappending ~a~ values (we can't; none exist)
     + we're never asking for a ~mempty~ of type ~a~.

   - The above case is clear.

     =TODO=
     However, it can happen that
     we do _NOT_ do this (constrain ~a~ with ~Monoid a~)
     _even when_ the type _does occur_ in the datatype.

*** DONE Exercise: Optional Monoid - 586
    CLOSED: [2017-06-22 Thu 00:20]
    #+BEGIN_SRC haskell
      data Optional a =
          Nada
        | Only a
        deriving (Eq, Show)

      instance Monoid a => Monoid (Optional a) where
        mempty = Nada
        mappend Nada els = els
        mappend els Nada = els
        mappend (Only v) (Only u) = Only (v mappend u)
    #+END_SRC

*** DONE Associativity - 587
    CLOSED: [2017-06-22 Thu 00:24]
    =FROM JIAN= =TODO=
    I can't by my self find out any evidence, in the _definition_ of
    ~Monoid~ type class, of the /associativity/ required in mathematics.
    =TODO=

*** DONE Identity - 589
    CLOSED: [2017-06-22 Thu 00:30]
    An identity is a value with a special relationship with an operation:
    it turns the operation into the identity function.

*** TODO The problem of orphan instances - 590
    - /orphan instance/: it is when an instance is defined for a datatype and
      type class, but _NOT in the same module_ as
      + either the declaration of the type class
        or
      + the datatype.

    - If you don't "own" the type class or the datatype, /newtype/ it!

** DONE 15.11 Madness - 593
   CLOSED: [2017-06-22 Thu 00:59]
   #+BEGIN_SRC haskell
     module Madness where

     import Data.Monoid

     type Verb = String
     type Adjective = String
     type Adverb = String
     type Noun = String
     type Exclamation = String

     madlibbin' :: Exclamation
                -> Adverb
                -> Noun
                -> Adjective
                -> String
     madlibbin' e adv noun adj = mconcat [e, "! he said ",
                                          adv, " as he jumped into his car ",
                                          noun, " and drove off with his ",
                                          adj, " wife."]
   #+END_SRC

** TODO 15.12 Better living through ~QuickCheck~ - 594
   - x

*** TODO Validating associativity with ~QuickCheck~ - 594
*** TODO Testing left and right identity - 596
*** TODO Testing ~QuickCheck~'s patience - 597
*** TODO Exercise: Maybe Another ~Monoid~ - 599

** DONE 15.13 ~Semigroup~ - 601
   CLOSED: [2017-06-22 Thu 02:32]
   #+BEGIN_SRC haskell
     class Semigroup a where
       (<>) :: a -> a -> a
   #+END_SRC
   - NO identity,
     only associativity left: ~(a <> b) <> c = a <> (b <> c)~.

   - *Not yet part of base* =OUTDATED=

   - From the release of GHC 8.0 on, ~Semigroup~ is
     + a part of base
       and

     + a superclass of ~Monoid~

     + ~Semigroup~ has its own more general version of ~(<>)~.
       * You should pay attention on the difference between the ~(<>)~ in
         ~Semigroup~ and the ~(<>)~ in ~Monoid~.
       * You may need to solve the confliction between them when you need to
         import them all.

*** DONE ~NonEmpty~, a useful datatype - 601
    CLOSED: [2017-06-22 Thu 02:09]
    #+BEGIN_SRC haskell
      data NonEmpty a = a :| [a]
        deriving (Eq, Ord, Show)
    #+END_SRC

    - ~NonEmpty~ is one really useful datatype, which
      + have a ~Semigroup~ and

      + don't have a ~Monoid~ instance

    - ~:|~ is an infix data constructor that takes two (type) arguments.
      + It's a product of ~a~ and ~[a]~.

      + It guarantees that we always have _at least one value_ of type ~a~, which
        ~[a]~ does not guarantee as any list might be empty.
        =TODO=

    - Data constructors
      + with _only non-alphanumeric symbols_ and that _begin with a colon_ are
        _infix by default_;

      + those with alphanumeric names are _prefix by default_.

    - Examples:
      #+BEGIN_SRC haskell
        import Data.List.NonEmpty as N
        import Data.Semigroup as S

        1 :| [2, 3]
        -- 1 :| [2, 3]

        -- Prelude N S> :t 1 :| [2, 3]
        -- 1 :| [2, 3] :: Num a => NonEmpty a

        -- Prelude N S> :t (<>)
        -- (<>) :: Semigroup a => a -> a -> a

        xs = 1 :| [2, 3]
        ys = 4 :| [5, 6]
        xs <> ys
        -- 1 :| [2, 3, 4, 5, 6]

        N.head xs
        -- 1

        N.length (xs <> ys)
        -- 6
      #+END_SRC

    - From the examples above, you know
      + you can _use ~NonEmpty~ just like a list._
      + BUT no valid identity value (no "empty" thing for ~NonEmpty~ list like
        datatype).
          This helps you enforce a constraint by not letting you construct a
        ~NonEmpty~ _unless you have at least one value_.

** DONE 15.14 Strength can be weakness - 604  =RE-READ=
   CLOSED: [2017-06-22 Thu 02:24]
   - Less type constraints (applicable to more types),
     less known operations (easy to guess possible implementations, which number
     is relatively less), 
     Example: ~id :: a -> a~

   - More type constraints (less applicable types),
     more known operations (hard to guess possible implementations, which number
     is relatively greater), 
     Example: ~freelyProcessInt :: Int -> Int~

   - /magma/ is an algebra object which is weaker than /semigroup/.
     /magma/ has no /associativity/.

** TODO 15.15 Chapter exercises - 606
*** TODO Semigroup exercises - 606
    - *Note*: We expect you to know what you need to derive instances by this
      point.

    - Questions:
      #+BEGIN_SRC haskell
      -- 1
      -- ...
      -- 13
      #+END_SRC

*** TODO Monoid exercises - 609
    #+BEGIN_SRC haskell
      -- 1
      -- ...
      -- 8
    #+END_SRC

** DONE 15.16 Definitions - 613
   CLOSED: [2017-06-22 Thu 02:48]
   1. /monoid/: a /monoid/ is a set that
      + is _closed_ under an _associative_ _binary_ operation
        and
      + has an _identity element_.
      
      /closed/ is the posh mathematical way of saying it's type is:
      ~mappend :: m -> m -> m~

   2. /semigroup/: A /semigroup/ is a set that
      + is _closed_ under an _associative_ _binary_ operation
        and
      + nothing else.

   3. /Laws/ are rules about how an algebra or structure should behave.

      If you detect /laws/ among different objects,
      they are acutally different instantiations of the same sort of algebra.
      You can exploit them all with this algebra.

   4. An /algebra/ is variously: a)... b)... c)...

      We are more care about the /algebra/ in Haskell:
      When Haskellers refer to /algebras/, they're usually talking about
      + _a somewhat informal notion of operations over a type_
        and
      + _its laws_,
        such as with /semigroups/, /monoids/, /groups/, /semirings/, and /rings/.

** TODO 15.17 Follow-up resources - 614

* TODO 16 ~Functor~ - 615
** DONE 16.1 ~Functor~ - 616
   CLOSED: [2017-06-25 Sun 22:54]
   - ~Functor~ is all about a pattern of _mapping over structure_.

     We metioned ~fmap~ before.
     For lists _ONLY_, ~fmap~ looks the same as ~map~.

   - The great logician Rudolf Carnap appears to have been the _first_ person to
     use the word 'functor' in the 1930s.
       He invented the word to describe certain types of grammatical function
     words and logical operations over sentences or phrases.

   - /Functors/ are /combinators/:
     they take a sentence or phrase as input and produce a sentence
     or phrase as an output, with some logical operation applied to the
     whole.

     For example, _negation is a functor_ in this sense because
     when negation is applied to a sentence, A, it produces the negated
     version, ¬A, as an output.
       It lifts the concept of negation over the entire sentence or phrase
     structure _without_ changing the internal structure.
     (NOT from the English language point of view, a negation word is always
      inside a sentence or phrase;
      From a logician's point of view)

   - This chapter will include:
     + the return of the higher-kinded types;
     + fmaps galore, and not just on lists;
     + no more digressions about dusty logicians;
     + words about type classes and constructor classes;
     + puns based on George Clinton music, probably. =???=

** DONE 16.2 What's a /functor/? - 617
   CLOSED: [2017-06-27 Tue 04:07]
   #+BEGIN_SRC haskell
     class Functor f where
       fmap :: (a -> b) -> f a -> f b
   #+END_SRC

   - /functor/ :: A _ is a way to apply a function over or around some structure
                  that we don’t want to alter.
                    That is, apply the function to the value that is "inside"
                  some structure and leave the structure alone.
     =IMPORTANT=

   - From the definition above, you know why we introduce /functor/ by way of
     /fmapping/ over lists befre.
     (NO elements are added or removed, ONLY transformed)

   - Explanation of the details of the ~Functor~ type class:

** DONE 16.3 There's a whole lot of ~fmap~ going round - 618
   CLOSED: [2017-06-27 Tue 04:18]
   #+BEGIN_SRC haskell
     --
     -- List
     fmap (x -> x > 3) [1..6]
     -- [False, False, False, True, True, True]


     --
     -- `Maybe`
     fmap (+1) (Just 1)
     -- Just 2

     fmap (+1) Nothing
     -- Nothing


     --
     -- Tuple
     fmap (10/) (4, 5)
     -- (4, 2.0)


     --
     -- `Either`
     fmap (++ ", Esq.") (Right "Chris Allen")
     -- Right "Chris Allen, Esq."

     fmap (++ ", Esq.") (Left "Chris Allen")
     -- Left "Chris Allen"
   #+END_SRC

   - Functor f
     #+BEGIN_SRC haskell
       fmap :: (a -> b) -> f a          -> f b
            :: (a -> b) -> [ ] a        -> [ ] b
            :: (a -> b) -> Maybe a      -> Maybe b
            :: (a -> b) -> Either e a   -> Either e b
            :: (a -> b) -> (e,) a       -> (e,) b
            :: (a -> b) -> Identity a   -> Identity b
            :: (a -> b) -> Constant e a -> Constant e b
     #+END_SRC

   - _Pay attention to the ignored arguments above_.

** TODO 16.4 Let's talk about ~f~ baby - 620
   The ~f~ in the /type class/ definition for ~Functor~ *must be the same ~f~
   throughout the entire definition*,
   and
   it must refer to a /type/ that implements the /type class/.

   This section details the practical ramifications of those facts.

   - ~f~ has the kind ~* -> *~.
     This is true and it is also required by the /type signature/:
     + Each argument (and result) in the /type signature/ for a function must be a
       fully applied (and inhabitable, /modulo/ Void =TODO= =???=, etc.) type.
       Each argument must have the kind ~*~.
       =IMPORANT= =???=

     + The type ~f~ was applied to a single argument in two different places:
       ~f a~ and ~f b~. Since ~f a~ and ~f b~ must each have the kind ~*~, ~f~ by
       itself must be kind ~* -> *~.

   - Use ~fmap \colon{}\colon{} (a -> b) -> f a -> f b~ as the example to explain the words
     above:
     ~fmap~ has the kind ~* -> * -> *~, which means ~(a -> b)~ has a kind ~*~.

   - It's easier to see what these mean in practice by demonstrating with lots of
     code. =TODO=

*** TODO Shining star come into view - 621
    - x

*** DONE Exercises: Be Kind - 623
    CLOSED: [2017-06-28 Wed 00:17]
    Easy

*** TODO A shining star for you to see - 624
    - x

*** DONE Functor is function application - 625
    CLOSED: [2017-06-28 Wed 01:31]
    - In the last section we were trying to make a Functor instance for a type
      constant. This CANNOT be done -- along this way we only get the function
      application ~$~.

      Even though ~fmap~ isn't the function application, it can be considered a
      special sort of function application.

    - ~fmap~ has an equivalent infix operator: ~<$>~ (in old GHC, you need to
      ~import Data.Functor~).

      Notice something? A sort of "special" application:
      + Normal application is ~($) \colon{}\colon{} (a -> b) -> a -> b~.
      + "Special" application is ~<$> \colon{}\colon{} Functor f => (a -> b) -> f a -> f b~.
      The operator representation is chosen on purpose.

    - /Functor/ is a type class for function application "through" some structure
      ~f~ that we want to ignore and _leave untouched_.

    - =TODO= Explain _leave untouched_ in the later sub-sections.

*** DONE A shining star for you to see what your ~f~ can truly be - 626
    CLOSED: [2017-06-28 Wed 01:31]
    Let's resume our exploration of _WHY_ we need a higher-kinded ~f~ /Functor/.

    An example (fix the not-work example in Section "A shining star for you to
    see"):
    #+BEGIN_SRC haskell
      data FixMePls a =
          FixMe
        | Pls a
        deriving (Eq, Show)

      instance Functor FixMePls where
        fmap _ FixMe = FixMe
        fmap g (Pls a) = Pls (g a)

      -- fmap :: Functor f => (a -> b) -> f a -> f b
      -- fmap                    g      (Pls a) = Pls (g a)
      -- -- Type Information  (a -> b)    f  a     f    b
    #+END_SRC
    
    Let's make another mistake for the sake of explicit-ness:
    #+BEGIN_SRC haskell
      data FixMePls a =
          FixMe
        | Pls a
        deriving (Eq, Show)

      instance Functor (FixMePls a) where   -- This line is changed. ERROR!
        fmap _ FixMe = FixMe
        fmap g (Pls a) = Pls (g a)
    #+END_SRC
    The error message is:
    #+BEGIN_SRC text
      functors4.hs:8:19:
      The first argument of ‘Functor’ should have kind ‘* -> *’,
      but ‘FixMePls a’ has kind ‘*’
      In the instance declaration for ‘Functor (FixMePls a)’
      Failed, modules loaded: none.
    #+END_SRC

*** DONE Type Classes and constructor classes - 628
    CLOSED: [2017-06-28 Wed 01:44]
    _Earlier versions of Haskell_ DIDN'T have a facility for expressing
    type classes in terms of higher-kinded types AT ALL.
      This was developed by Mark P. Jones. This happend when he work on an
    implementation of Haskell called /Gofer/.

** DONE 16.5 Functor Laws - 629
   CLOSED: [2017-06-28 Wed 02:21]
   Two Basic Laws: _Identity_ and _Composition_.

*** DONE Identity - 629
    CLOSED: [2017-06-28 Wed 02:19]
     ~fmap id~ is the same as ~id~

     + ~fmap~ shouldn't change the structure (the outside, or say the frame).
     + ~fmap id~ never change the inner value (the insdie) due to the property
       of ~id~.
     
     These two points above means neither the outside nor the inside would be
     changed. This is clearly an ~id~.

*** DONE Composition - 630
    CLOSED: [2017-06-28 Wed 02:19]
     ~fmap (f . g)~ is the same as ~fmap f . fmap g~
     If an implementation of fmap doesn’t do that, it’s a broken functor.

*** DONE Structure preservation - 630
    CLOSED: [2017-06-28 Wed 02:21]

** DONE 16.6 The Good, the Bad, and the Ugly - 630
   CLOSED: [2017-06-28 Wed 02:42]
   Show what it means for /Functor/ instances to be law-abiding or law-breaking
   by walking through some examples.

   - Example 1:
     #+BEGIN_SRC haskell
       data WhoCares a =
           ItDoesnt
         | Matter a
         | WhatThisIsCalled
         deriving (Eq, Show)

       -- The law-abiding instance:
       instance Functor WhoCares where
         fmap _ ItDoesnt = ItDoesnt
         fmap _ WhatThisIsCalled = WhatThisIsCalled
         famp f (Matter a) = Matter (f a)

       -- The law-BREAKING instance (ILLEGAL in Theory, but works! Sigh!!!):
       -- TODO: Any Warning that can be issued by GHC????
       instance Functor WhoCares where
         fmap _ ItDoesnt = WhatThisIsCalled  -- Change the structure
         fmap _ WhatThisIsCalled = ItDoesnt  -- Change the structure
         famp f (Matter a) = Matter (f a)
     #+END_SRC

   - *The law won*

*** DONE Composition should just work - 632
    CLOSED: [2017-06-28 Wed 02:42]
    Make a (pseudo- or mal-implemented) Functor instance _violate_ the /identity
    law/ and the /composition law/:
    #+BEGIN_SRC haskell
      -- INVALID Functor
      data CountingBad a =
        Heisenberg Int a
        deriving (Eq, Show)

      -- SUPER NOT okay
      instance Functor CountingBad where
        fmap f (Heisenberg n a) = Heisenberg (n+1) (f a)

      -- Totes cool
      instance Functor CountingBad where
        fmap f (Heisenberg n a) = Heisenberg n (f a)
    #+END_SRC

    From this example it is clear that:
    If we have a ~TYPECONSTRUCTOR a~ and if we try to make is an instance of
    ~Functor~, to maintain the _composition law_ we can ONLY change the value
    that is correspond to the type variable ~a~.

      For the ~CountingBad a~ above, the "structure" is ~Heisenberg Int~, not
    ~Heisenberg~ itself.

** DONE 16.7 Commonly used functors - 634
   CLOSED: [2017-06-29 Thu 01:08]
   Some simple examples and ONE NOT that simple example:
   #+BEGIN_SRC haskell
     replaceWithP = const 'p'

     -- data (,) a b = (,) a b
     fmap replaceWithP (10, 20)
     -- (10, 'p')

     fmap replaceWithP (10, "woo")
     -- (10, 'p')
   #+END_SRC

   Q: Why only the second arguments?
   A: If you remember the in the last Section, we must remember we should use
      ~fmap~ to change the value of type ~a~ and never touch the value of type
      ~Int~. Then you know why!
      #+BEGIN_SRC haskell
        data CountingBad a =
          Heisenberg Int a
          deriving (Eq, Show)
      #+END_SRC

   =TODO= =TODO= =???=
   =TODO= The functor of functions won't be discussed in great detail until we
   get to the chapter on ~Reader~.
   #+BEGIN_SRC haskell
     tossEmOne = fmap (+1) negate

     tossEmOne 10
     -- -9

     tossEmOne (-10)
     -- 11


     tossEmOne' = (+1) . negate

     tossEmOne' 10
     -- -9

     tossEmOne' (-10)
     -- 11
   #+END_SRC

*** DONE The functors are stacked and that's a fact - 636
    CLOSED: [2017-06-28 Wed 20:48]
    Easy to understand:
    #+BEGIN_SRC haskell
      lms = [Just "Ave", Nothing, Just "woohoo"]

      replaceWithP = const 'p'

      replaceWithP lms
      -- 'p'

      fmap replaceWithP lms
      -- "ppp"

    #+END_SRC

     These will be explained in the next section:
    #+BEGIN_SRC haskell
    
      (fmap . fmap) replaceWithP lms
      -- [Just 'p',Nothing,Just 'p']

      (fmap . fmap . fmap) replaceWithP lms
      -- [Just "ppp",Nothing,Just "pppppp"]
    #+END_SRC

*** DONE What if we lift twice? - 638
    CLOSED: [2017-06-28 Wed 20:48]
    - *Wait, how does that even typecheck?*
      + ~fmap \colon{}\colon{} Functor f => (m -> n) -> (f m -> f n)~
                                 b             c

      + ~fmap \colon{}\colon{} Functor g => (x -> y) -> (g x -> g y)~
                                 a             b

      ~fmap . fmap :: (Functor f, Functor g) => x -> y -> f (g x) -> f (g y)~

      To explann type above, we need to consider how to map them to the type
      ~(.) :: (b -> c) -> (a -> b) -> a -> c~ 

      ~a~ is ~x -> y~
      ~b~ is ~(g x -> g y)~, which is the same as ~(m -> n)~
      ~c~ is ~f (g x) -> f (g y)~

*** DONE Lift me baby one more time - 640
    CLOSED: [2017-06-28 Wed 20:50]
    One more ~fmap~, one level deeper!

*** DONE The real type of thing going down - 640
    CLOSED: [2017-06-28 Wed 21:31]
    - ~[Maybe [Char]] -> Char~
      Change all

    - ~[Maybe [Char]] -> [Char]~
      Change the elements inside the _outmost_ layer -- the ~[]~

    - ~[Maybe [Char]] -> [Maybe Char]~
      Change the elements inside the _second_ layer -- the ~Maybe~

    - ~[Maybe [Char]] -> [Maybe [Char]]~
      Change the elements inside the _third_ layer -- the value of ~Maybe~,
      the ~[]~ of ~[Char]~.

*** DONE Get on up and get down - 641
    CLOSED: [2017-06-28 Wed 22:42]
    #+BEGIN_SRC haskell
      -- lmls ~ List (Maybe (List String))

      ha = Just ["Ha", "Ha"]
      lmls = [ha, Nothing, Just []]

      (fmap . fmap) replaceWithP lmls
      -- [Just 'p', Nothing, Just 'p']

      (fmap . fmap . fmap) replaceWithP lmls
      -- [Just ["pp", "pp"], Nothing, Just []]
    #+END_SRC

*** DONE One more round for the P-Funkshun - 642
    CLOSED: [2017-06-28 Wed 22:48]

    _TOPIC un-related, but useful_

    #+BEGIN_SRC haskell
      replaceWithP :: b -> Char
      replaceWithP = const 'p'

      lms :: [Maybe [Char]]
      lms = [Just "Ave", Nothing, Just "woohoo"]

      -- We want a more specific function to operate on `lms`,
      -- though `replaceWithP` works.
      --
      -- Here is a way to do this:
      replaceWithP' :: [Maybe [Char]] -> Char
      replaceWithP' = replaceWithP
    #+END_SRC

    =SUMMARY=: we can define a generic function, and assign it to a function,
    of more specific type.
      Then we create a more specific function.

*** DONE Stay on the scene like an ~fmap~ machine - 643
    CLOSED: [2017-06-28 Wed 22:54]

*** DONE Exercises: Heavy Lifting - 645
    CLOSED: [2017-06-28 Wed 23:38]
    #+BEGIN_SRC haskell
      module HeavyLifting where

      -- 1 - Add `fmap`
      a = fmap (+1) $ read "[1]" :: [Int]


      -- 2 - Add `(fmap . fmap)`
      b = (fmap . fmap) (++ "lol") (Just ["Hi,", "Hello"])


      -- 3 - Add `.`
      c = (*2) . (\x -> x - 2)


      -- 4 - Add `$`
      -- TODO: Interesting points are
      --       a) `return`
      --       b) `[x, 1..3]`
      d = ((return '1' ++) . show) . (\x -> [x, 1..3])


      -- 5 - Add two `fmap`'s, two `.`'s, and one pair of parentheses
      e :: IO Integer
      e = let ioi = readIO "1" :: IO Integer
              changed = fmap (read . ("123"++) . show) ioi
          in fmap (*3) changed
    #+END_SRC

** DONE 16.8 Transforming the unapplied type argument - 646
   CLOSED: [2017-06-29 Thu 02:30]
   =From Jian= My guess in a section (=todo= which one?) before is right!

** TODO 16.9 QuickChecking ~Functor~ instances - 649
** TODO 16.10 Exercises: Instances of Func - 650 - (Partially DONE)

   =TODO=
   =TODO= Use ~QuickCheck~ properties to validate them.
   =TODO=

   #+BEGIN_SRC haskell
     -- 1
     newtype Identity a = Identity a

     instance Functor Identity where
       fmap f (Identity av) = Identity (f av)


     -- 2
     data Pair a = Pair a a

     instance Functor Pair where
       fmap f (Pair av av') = Pair (f av) (f av')


     -- 3
     data Two a b = Two a b

     instance Functor (Two a) where
       fmap f (Two av bv) = Two av (f bv)


     -- 4
     data Three a b c = Three a b c

     instance Functor (Three a b) where
       fmap f (Three av bv cv) = Three av bv (f cv)


     -- 5
     data Three' a b = Three' a b b

     instance Functor (Three' a) where
       fmap f (Three' av bv bv') = Three' av (f bv) (f bv')


     -- 6
     data Four a b c d = Four a b c d

     instance Functor (Four a b c) where
       fmap f (Four av bv cv dv) = Four av bv cv (f dv)


     -- 7
     data Four' a b = Four' a a a b

     instance Functor (Four' a) where
       fmap f (Four' av av' av'' bv) = Four av av' av'' (f bv)

     -- 8
     ~data Trival = Trivial~
     -- NO Functor instance
     -- Wrong "kind" (not * -> *)!
   #+END_SRC

** DONE 16.11 Ignoring possibilities - 651
   CLOSED: [2017-06-29 Thu 03:08]
*** DONE ~Maybe~ - 651
    CLOSED: [2017-06-29 Thu 02:43]

*** DONE Exercise: Possibly - 654
    CLOSED: [2017-06-29 Thu 02:43]
    #+BEGIN_SRC haskell
      data Possibly a =
          LolNope
        | Yeppers a
        deriving (Eq, Show)

      instance Functor Possibly where
        fmap _ LolNope = LolNope
        fmap f (Yeppers av) = Yeppers (f av)

      applyIfYeppers :: (a -> b) -> Possibly a -> Possibly b
      applyIfYeppers = fmap
    #+END_SRC

*** DONE ~Either~ - 654
    CLOSED: [2017-06-29 Thu 03:07]

*** DONE Short Exercise - 656
    CLOSED: [2017-06-29 Thu 03:08]
    #+BEGIN_SRC haskell
      data Sum a b =
          First a
        | Second b
        deriving (Eq, Show)

      instance Functor (Sum a) where
        fmap _ (First av) = First av
        fmap f (Second bv) = Second (f bv)

      applyIfSecond :: (a -> b) -> (Sum e) a -> (Sum e) b
      applyIfSecond = fmap
    #+END_SRC

    - x

** DONE 16.12 A somewhat surprising functor - 657
   CLOSED: [2017-06-29 Thu 03:07]
   #+BEGIN_SRC haskell
     import Data.Functor (Constant)

     -- newtype Constant a b =
     --   Constant { getConstant :: a }
     --   deriving (Eq, Show)

     -- instance Functor (Constant m) where
     --     fmap _ (Constant v) = Constant v

     -- b is a phantom type.
   #+END_SRC

** DONE 16.13 More structure, more functors - 660
   CLOSED: [2017-06-29 Thu 03:52]
   #+BEGIN_SRC haskell
     data Wrap f a =
       Wrap (f a)
       deriving (Eq, Show)

     -----------------------------------------------------------------------
     -- Write a functor instance for the type above is a little complicated:
     -----------------------------------------------------------------------
     -- The 1st version:
     instance Functor (Wrap f) where
       fmap g (Wrap fa) = Wrap (g fa)
       -- Unfinished version. It can work,
       -- but write in this way can't guarantee an "real" Functor instance.
       -- Some key constraint(s) is/are absent.

     -- Before adding more constraint(s) to correct the definition above, we first
     -- present what the problem is -- what we want (the TODO list):
     -- 1. We DO NOT want to apply `g` on `fa` (which is indeed `f a`),
     -- 2. We DO want to apply `g` on `a`.
     --
     -- The TODO implies that
     -- `f` is like a container structure, the values of type `a` is like items
     -- inside it, we want to apply a function `g` on `a` without touching the
     -- container `f`.

     -- SEE! This is just like to say
     -- we should `fmap` `g` on `fs`,

     instance Functor (Wrap f) where
       fmap g (Wrap fa) = Wrap (fmap g fa)

     -- and `f` is a functor!
     instance Functor f => Functor (Wrap f) where   -- The final version
       fmap g (Wrap fa) = Wrap (fmap g fa)


     -- The resaoning above acutally indicates that ~fa~ can't be any type!

     fmap (+1) (Wrap (Just 1))
     -- Wrap (Just 2)

     fmap (+1) (Wrap [1, 2, 3])
     -- Wrap [2,3,4]

     n = 1 :: Integer
     fmap (+1) (Wrap n)
     -- Couldn't match expected type ‘f b’ with actual type ‘Integer’
     -- Relevant bindings include
     --       it :: Wrap f b (bound at <interactive>:8:1)
     -- In the first argument of ‘Wrap’, namely ‘n’
     -- In the second argument of ‘fmap’, namely ‘(Wrap n)’
   #+END_SRC

** DONE 16.14 ~IO Functor~ - 661
   CLOSED: [2017-06-30 Fri 00:06]
   - =TODO= The ~IO~ type will get a full chapter of its own later in the book.
   - Some facts about the ~IO~ type:
     + It is an _ABSTRACT_ datatype;
     + there are _NO_ data constructors that you're permitted to pattern match on,
       so the type classes ~IO~ provides are the _ONLY_ way you can work with values
       of type ~IO a~.
         One of the simplest provided is /Functor/. For example,
       #+BEGIN_SRC haskell
         -- getLine :: IO String
         -- read :: Read a => String -> a

         getInt :: IO Int
         getInt = fmap read getLine
       #+END_SRC
       ~Int~ has a ~Read~ instance, and ~fmap~ lifts ~read~ over the ~IO~ type.

   - A Way you can read ~getLine~ is
     + It's _NOT_ a ~String~
     + BUT rather _a way to obtain_ a ~String~.

   - ~IO~ _DOESN'T guarantee_ that effects will be performed,
     BUT it DOES mean that they _could be performed_.

   - GHCi never pint ~IO ()~ -- the ~Unit~ value is meaningless.

   - GHCi as a matter of convenience and design,
     will NOT print any value of type ~IO ()~

     _on the assumption that_

     the ~IO~ action you evaluated was evaluated for effects
     and
     because the /unit/ value cannot communicate anything.

   - Expressions that have same result:
     The ~fmap~ version is more concise.
     #+BEGIN_SRC haskell
       -- # 1
       fmap (+1) getInt

       bumpIt :: IO Int
       bumpIt = do
         intVal <- getInt
         return (intVal + 1)

       -- # 2
       fmap (++ " and me too!") getLine
       meTooIsm :: IO String
       meTooIsm = do
         input <- getLine
         return (input ++ "and me too!")
     #+END_SRC

** DONE 16.15 What if we want to do something different? - 663
   CLOSED: [2017-06-30 Fri 01:11]
   - /natural transformations/
     ~nat :: (f -> g) -> f a -> g a~
     This type is impossible because we can't have higher-kinded types as
     argument types to the function type.

     So we make a modest change to fix it.
     #+BEGIN_SRC haskell
       {-# LANGUAGE RankNTypes #-}
       -- Rank2Types also works
       type Nat f g = forall a. f a -> g a
     #+END_SRC
     Here we're doing the _opposite_ of what a ~Functor~ does.

   - Use ~:set -XRank2Types~ or ~:set -XRank2Types~
     to turn on ~Rank2Types~ or ~RankNTypes~ in GHCi.

   - Example:
     #+BEGIN_SRC haskell
       -- This'll work.
       maybeToList :: Nat Maybe []
       maybeToList Nothing = []
       maybeToList (Just a) = [a]

       -- This won't work, not allowed -- remember the `forall a`.
       degenerateMtl :: Nat Maybe []
       degenerateMtl Nothing = []
       degenerateMtl (Just a) = [a + 1]
     #+END_SRC
     To make the ~degenerateMtl~ above work,
     we need to define ~Nat~ as ~type Nat f g a = f a -> g a~.
     However, do you still remember our
     _original intention_:
     CHANGE the structure without touching the value(s) inside.

     ~degenerateMtl~ is not our original intention,
     There is NO need to do what ~degenerateMtl~ do in this way (bad style),
     just write an plain old /fold/.

   - =TODO= We're going to return to the topic of natural transformations in the
     next chapter.

** DONE 16.16 Functors are unique to a datatype - 666
   CLOSED: [2017-06-30 Fri 01:22]
   - In Haskell,
     ~Functor~ instances will be _UNIQUE_ for a given datatype.
     From the last chapter we know that
     this is _NOT true_ for ~Monoid~; however, we use ~newtype~'s to avoid
     confusing different ~Monoid~ instances for a given type.
     
   - The /uniqueness/ of a ~Functor~ for a datatype,
     + in part because of /parametricity/,
     + in part because arguments to type constructors are
       _applied in order of definition_.

   - In a hypothetical not-Haskell language, the following might be possible:
     #+BEGIN_SRC haskell
       data Tuple a b =
         Tuple a b
         deriving (Eq, Show)

       -- this is impossible in Haskell
       instance Functor (Tuple ? b) where
         fmap f (Tuple a b) = Tuple (f a) b
     #+END_SRC

     There are essentially _TWO_ ways to address this:
     + Flip the arguments, and create a new datatype:
       #+BEGIN_SRC haskell
         data Tuple' a b =
           Tuple' b a
           deriving (Eq, Show)
       #+END_SRC

     + make a new datatype using a ~Flip~ newtype
       =IMPORTANT=: Remember this!!! A typical pattern!
       #+BEGIN_SRC haskell
         {-# LANGUAGE FlexibleInstances #-}
         module FlipFunctor where

         data Tuple a b =
           Tuple a b
           deriving (Eq, Show)

         newtype Flip f a b =
           Flip (f b a)
           deriving (Eq, Show)

         -- this actually works, goofy as it looks.
         instance Functor (Flip Tuple a) where
           fmap f (Flip (Tuple a b)) = Flip $ Tuple (f a) b

         fmap (+1) (Flip (Tuple 1 "blah"))
         -- Flip (Tuple 2 "blah")
       #+END_SRC
       However, ~Flip Tuple a b~ is a _DISTINCT_ type from ~Tuple a b~ even if
       it's only there to provide for different ~Functor~ instance behavior.

       _WE NEVER CREATE MORE THAN ONE FUNCTOR FOR A TYPE_

** DONE 16.17 Chapter exercises - 667
   CLOSED: [2017-06-30 Fri 01:26]
   #+BEGIN_SRC haskell
     {-# LANGUAGE FlexibleInstances #-}
     module Ch16FunctorChapterExercises where

     -- Determin if a valid Functor can be written for the datatype provided.
     -- 1 - NO
     -- 2 - YES
     -- 3 - YES
     -- 4 - YES
     -- 5 - NO
     --
     -- Rearrange the arguments to the type constructor of the datatype so the Functor
     -- instance works.
     -- 1 - fmap _ (First a) = First a
     --
     -- 2 - fmap _ (Something b) = Something b
     --     fmap f (DeepBlue a c) = DeepBlue a (f c)
     --
     -- 3 - fmap f (L a b a) = L a (f b) a
     --     fmap f (R b a b) = R (f b) a (f b)
     --
     -- Write Functor instances for the following datatypes
     -- 1
     data Quant a b =
         Finance
       | Desk a
       | Bloor b

     instance Functor (Quant a) where
       fmap _ Finance = Finance
       fmap _ (Desk av) = Desk av
       fmap f (Bloor bv) = Bloor (f bv)

     -- 2
     data K a b =
       K a

     instance Functor (K a) where
       fmap _ (K av) = K av

     -- 3
     newtype Flip f a b =
       Flip (f b a)
       deriving (Eq, Show)

     -- TODO: RE-FRESH LATER
     -- This is the place requires the `FlexibleInstances` pragma
     instance Functor (Flip K a) where
      fmap g (Flip (K a)) = Flip (K $ g a)

     -- TODO: Cannot work
     -- instance Functor (f a) => Functor (Flip f a) where
     --  fmap g (Flip fba) = Flip (fmap g fba)

     -- 4
     data EvilGoateeConst a b =
       GoatyConst b

     instance Functor (EvilGoateeConst a) where
       fmap f (GoatyConst bv) = GoatyConst (f bv)


     -- 5
     data LiftItOut f a =
       LiftItOut (f a)

     instance Functor f => Functor (LiftItOut f) where
       fmap f' (LiftItOut fa) = LiftItOut (fmap f' fa)


     -- 6
     data Parappa f g a =
       DaWrappa (f a) (g a)

     instance (Functor f, Functor g) => Functor (Parappa f g) where
       fmap f' (DaWrappa fa ga) = DaWrappa (fmap f' fa) (fmap f' ga)

     -- 8
     data Notorious g o a t =
       Notorious (g o) (g a) (g t)

     instance Functor g => Functor (Notorious g o a) where
       fmap f (Notorious go ga gt) = Notorious go ga (fmap f gt)

     -- 9
     data List a =
         Nil
       | Cons a (List a)

     instance Functor List where
       fmap _ Nil = Nil
       fmap f (Cons hd tl) = Cons (f hd) (fmap f tl)


     -- 10
     data GoatLord a =
         NoGoat
       | OneGoat a
       | MoreGoats (GoatLord a) (GoatLord a) (GoatLord a)

     instance Functor GoatLord where
       fmap _ NoGoat = NoGoat
       fmap f (OneGoat a) = OneGoat (f a)
       fmap f (MoreGoats g1 g2 g3) = MoreGoats (fmap f g1) (fmap f g2) (fmap f g3)

     -- 11
     data TalkToMe a =
         Halt
       | Print String a
       | Read (String -> a)

     instance Functor TalkToMe where
       fmap _ Halt = Halt
       fmap f (Print str a) = Print str (f a)
       fmap f (Read g) = Read (f . g)
   #+END_SRC

** DONE 16.18 Definitions - 671
   CLOSED: [2017-06-30 Fri 01:53]
   1. /Higher-kinded polymorphism/: polymorphism which has a type variable
      abstracting over types of a higher kind.
      Examples:
      + /Functor/

      + Any datatype having a parameter to the type constructor which is of a
        higher kind, such as the following:
        ~data Weird f a = Weird (f a)~
        Since ~f~ is higher kinded, we say ~Weird~ is of higher kinded
        polymorphism.
        IF ~f~ is NOT higher kinded, ~(f a)~ would be invalid.
        Here is the kinds of the types involved:
        ~a :: *~
        ~f :: * -> *~
        ~Weird :: (* -> *) -> * -> *~

   2. /Functor/: A mapping between categories.
      In Haskell, this manifests as a type class which lifts a function between
      two types over two new types.

      There's a /Functor/ of functions and many exotic types will have a lawful
      /Functor/ instance.
        You SHOULDN'T ONLY consider containers or data structures (when we say a
      /Functor/ lifts a "structure" and apply a function to the inner value, the
      "structure" here is _more general_ than data structures.).

   3. /lifting/: =TODO=
      In this book, we most commonly use the phrase /lift over/.
      (=TODO= later, in ~Monad~, /bind over/ for reasons that will hopefully
       become clear in time).

   4. /George Clinton/: =???=

** TODO 16.19 Follow-up resources - 673

* TODO 17 ~Applicative~ - 674
** DONE 17.1 ~Applicative~ - 675
   CLOSED: [2017-06-30 Fri 02:11]
   - In this chapter, we will:
     + define and explore the ~Applicative~ type class and its core operations;
     + demonstrate why /applicatives/ are /monoidal functors/;
     + make the usual chitchat about laws and instances;
     + do a lot of lifting;
     + give you some Validation.

** DONE 17.2 Defining ~Applicative~ - 675
   CLOSED: [2017-06-30 Fri 02:23]
   - Definition
     #+BEGIN_SRC haskell
       class Functor f => Applicative f where
         pure :: a -> f a
         (<*>) :: f (a -> b) -> f a -> f b
     #+END_SRC
     + ~pure~ TODO

     + ~<*>~ is called "apply" or sometimes "ap",
       or sometimes "tie-fighter" when we're feeling particularly zippy.

   - If compare ~<*>~ with ~fmap~ (~<$>~), we see the similarity:
     #+BEGIN_SRC haskell
       (<$>) :: Functor f =>       (a -> b) -> f a -> f b
       (<*>) :: Applicative f => f (a -> b) -> f a -> f b
     #+END_SRC

   - Along with the above core functions, the ~Control.Applicative~ library
     provides some other convenient functions: ~liftA~, ~liftA2~, and ~liftA3~:
     #+BEGIN_SRC haskell
       -- Similar to `fmap`,
       -- and the only difference is the `Applicative` type class constraint.
       liftA :: Applicative f =>
               (a -> b)
             -> f a
             -> f b


       liftA2 :: Applicative f =>
                (a -> b -> c)
              -> f a
              -> f b
              -> f c


       liftA3 :: Applicative f =>
                (a -> b -> c -> d)
              -> f a
              -> f b
              -> f c
              -> f d
     #+END_SRC
     
** DONE 17.3 ~Functor~ vs. ~Applicative~ - 677
   CLOSED: [2017-06-30 Fri 02:42]
   We've already said that /applicatives/ are /monoidal functors/.
   We want to develop a stronger intuition for the relationship.

   ~fmap f x~ is the same as ~pure f <*> x~
   It's easy to demonstrate this, but if you're using GHC 7.8 or older you need
   ~import Control.Applicative~
   #+BEGIN_SRC haskell
     fmap (+1) [1, 2, 3]
     -- [2,3,4]

     pure (+1) <*> [1..3]
     -- [2,3,4]

     pure 1 :: [Int]
     -- [1]

     pure 1 :: Maybe Int
     -- Just 1

     pure 1 :: Either a Int
     -- Right 1

     pure 1 :: ([a], Int)
     -- ([],1)
   #+END_SRC

** TODO 17.4 Applicative functors are monoidal functors - 678
   - First let us notice something:
     #+BEGIN_SRC haskell
        ($)  ::   (a -> b) ->   a ->   b
       (<$>) ::   (a -> b) -> f a -> f b
       (<*>) :: f (a -> b) -> f a -> f b
     #+END_SRC

   - =TODO= (=From jian=)
     The way to get this conclusion is interesting, add some nontes. =page 674=

     With ~Applicative~, we have a ~Monoid~ for our structure and function
     application for our values!

     =TODO= XXX

     #+BEGIN_SRC haskell
       mappend :: f             f      f
       $       ::   (a -> b)      a      b
       (<*>)   :: f (a -> b) -> f a -> f b
     #+END_SRC

   - Examples:
     #+BEGIN_SRC haskell
       ---------------
       -- List
       ---------------
       [(*2), (*3)] <*> [4, 5]

       -- [2 * 4,2 * 5,3 * 4,3 * 5] -- (intermediate step)
       -- [8,10,12,15]  -- finall result


       ---------------
       -- Maybe
       ---------------
       Just (*2) <*> Just 2
       -- Just 4

       Just (*2) <*> Nothing
       -- Nothing

       Nothing <*> Just (*2)
       -- Nothing

       Nothing <*> Nothing
       -- Nothing
     #+END_SRC

*** TODO Show me the monoids - 681
    - Recall that the /Functor/ instance for the _two-tuple_ ignores the first
      value inside the tuple.
      BUT the /Applicative/ for the _two-tuple_ demonstrates the /monoid/ in
      /Applicative/ nicely for us. Try ~:info (,)~ in GHCi, and we can see two
      lines:
      + ~instance Monoid a => Applicative ((,) a) -- Defined in 'GHC.Base'~
      + ~instance (Monoid a, Monoid b) => Monoid (a, b)~

*** TODO Tuple Monoid and Applicative side by side - 683
    #+BEGIN_SRC haskell
      instance (Monoid a, Monoid b) => Monoid (a,b) where
        mempty = (mempty, mempty)
        (a, b) `mappend` (a',b') =
          (a `mappend` a', b `mappend` b')

      instance Monoid a => Applicative ((,) a) where
        pure x = (mempty, x)
        (u, f) <*> (v, x) =
          (u `mappend` v, f x)
          -- TODO: I don't quite understand the second term
    #+END_SRC

*** TODO ~Maybe~ Monoid and Applicative - 683
    #+BEGIN_SRC haskell
      instance Monoid a => Monoid (Maybe a) where
        mempty = Nothing
        mappend m Nothing = m
        mappend Nothing m = m
        mappend (Just a) (Just a') = Just (mappend a a')

      instance Applicative Maybe where
        pure = Just
        Nothing <*> _ = Nothing
        _ <*> Nothing = Nothing
        Just f <*> Just a = Just (f a)
    #+END_SRC

** DONE 17.5 ~Applicative~ in use - 684
   CLOSED: [2017-07-02 Sun 17:47]
*** DONE List ~Applicative~ - 684
    CLOSED: [2017-07-01 Sat 23:08]
    #+BEGIN_SRC haskell
      (<*>) :: f (a -> b) -> f a -> f b

      -- f ~ []
      -- (<*>) :: [ ] (a -> b) -> [ ] a -> [ ] b

      -- more syntactically typical
      -- (<*>) :: [(a -> b)] -> [a] -> [b]

      pure :: a -> f a
      -- pure :: a -> [a]
    #+END_SRC

**** DONE What's the List applicative do? - 685
     CLOSED: [2017-07-01 Sat 23:08]
     - Equivalent forms:
       #+BEGIN_SRC haskell
         (,) <$> [1, 2] <*> [3, 4]
         liftA2 (,) [1, 2] [3, 4]
         -- [(1,3),(1,4),(2,3),(2,4)]

         -- This is like a Cartesian product, but with functions
       #+END_SRC

     - ~lookup \colon{}\colon{} Eq a => a -> [(a, b)] -> Maybe b~

     - BTW, if you want the use Map data structures:
       #+BEGIN_SRC haskell
         -- An associative List
         lookup 3 [(3, "hello")]

         -- A Map
         Data.Map.lookup 3 (fromList [(3, "hello")])
         -- Just "hello"
       #+END_SRC

**** DONE Exercises: Lookups - 689
     CLOSED: [2017-07-01 Sat 23:58]
     #+BEGIN_SRC haskell
       -- Exercises: Lookups
       import Data.List (elemIndex)

       --
       -- 1
       added :: Maybe Integer
       added = (+3) <$> (lookup 3 $ zip [1, 2, 3] [4, 5, 6])


       -- 2
       y :: Maybe Integer
       y = lookup 3 $ zip [1, 2, 3] [4, 5, 6]

       z :: Maybe Integer
       z = lookup 2 $ zip [1, 2, 3] [4, 5, 6]

       tupled :: Maybe (Integer, Integer)
       tupled = (,) <$> y <*> z


       -- 3
       x' :: Maybe Int
       x' = elemIndex 3 [1, 2, 3, 4, 5]

       y' :: Maybe Int
       y' = elemIndex 4 [1, 2, 3, 4, 5]

       max' :: Int -> Int -> Int
       max' = max

       maxed :: Maybe Int
       maxed = max' <$> x' <*> y'


       -- 4
       xs = [1, 2, 3]
       ys = [4, 5, 6]

       x'' :: Maybe Integer
       x'' = lookup 3 $ zip xs ys

       y'' :: Maybe Integer
       y'' = lookup 2 $ zip xs ys

       summed :: Maybe Integer
       summed = (sum <$>) $ (,) <$> x'' <*> y''
     #+END_SRC
*** DONE Identity - 691
    CLOSED: [2017-07-02 Sun 00:11]
    The ~Identity~ type here is a way to introduce structure without changing
    the semantics of what you're doing.
**** DONE Specializing the types - 691
     CLOSED: [2017-07-02 Sun 00:11]
     #+BEGIN_SRC haskell
       (<*>) ::        f (a -> b) ->        f a ->        f b
       -- (<*>) :: Identity (a -> b) -> Identity a -> Identity b

       pure :: a ->        f a
       pure :: a -> Identity a
     #+END_SRC

     Why do we need this?
     #+BEGIN_SRC haskell
       const <$> [1, 2, 3] <*> [9, 9, 9]
       -- [1,1,1,2,2,2,3,3,3]

       const <$> Identity [1, 2, 3] <*> Identity [9, 9, 9]
       -- [1,2,3]
     #+END_SRC

**** DONE Exercise: Identity Instance - 692
     CLOSED: [2017-07-02 Sun 00:16]
     #+BEGIN_SRC haskell
       newtype Identity a =
         Identity a
         deriving (Eq, Ord, Show)

       instance Functor Identity where
         fmap f (Identity x)= Identity (f x)

       instance Identity a where
         pure x = Identity x
         (<*>) (Identity f) (Identity x) = Identity (f x)
     #+END_SRC
*** DONE Constant - 692
    CLOSED: [2017-07-02 Sun 02:39]
    ~Constant~ is _NOT_ so different from the ~Identity~ type,
    _EXCEPT_ this _not only_ provides structure it _also_ acts like the const
    function.

    This datatype is like the ~const~ function in that
    it takes two arguments _but_ one of them just gets discarded.
    In the case of the datatype, we have to map our function over the argument
    that gets discarded. So there is no value to map over, and the function
    application just doesn't happen.

**** DONE Specializing the types - 692
     CLOSED: [2017-07-02 Sun 02:39]
     #+BEGIN_SRC haskell
       -- f ~ Constant e
       (<*>) ::             f (a -> b) ->          f a ->          f b
       -- (<*>) :: Constant e (a -> b) -> Constant e a -> Constant e b

       pure :: a ->          f a
       -- pure :: a -> Constant e a
     #+END_SRC

**** DONE Exercise: Constant Instance - 693
     CLOSED: [2017-07-02 Sun 02:39]
     #+BEGIN_SRC haskell
       -- Exercises: Constant Instance

       newtype Constant a b =
         Constant { getConstant :: a }
         deriving (Eq, Ord, Show)

       instance Functor (Constant a) where
         fmap _ (Constant av) = Constant av

       instance Monoid a => Applicative (Constant a) where
         pure _ = Constant mempty
         Constant m1 <*> Constant m2 = Constant (m1 <> m2)
     #+END_SRC

*** DONE ~Maybe~ ~Applicative~ - 794
    CLOSED: [2017-07-02 Sun 17:47]
**** DONE Specializing the types - 694
     CLOSED: [2017-07-02 Sun 03:08]
     #+BEGIN_SRC haskell
       -- f ~ Maybe
       (<*>) ::     f (a -> b) ->     f a ->     f b
       -- (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b

       pure :: a ->     f a
       -- pure :: a -> Maybe a
     #+END_SRC

**** DONE Using the ~Maybe~ Applicative - 694
     CLOSED: [2017-07-02 Sun 03:08]
     #+BEGIN_SRC haskell
       validateLength :: Int -> String -> Maybe String
       validateLength maxLen s =
         if (length s) > maxLen
         then Nothing
         else Just s

       newtype Name = Name String deriving (Eq, Show)
       newtype Address = Address String deriving (Eq, Show)

       mkName :: String -> Maybe Name
       mkName s = fmap Name $ validateLength 25 s

       mkAddress :: String -> Maybe Address
       mkAddress a = fmap Address $ validateLength 100 a

       data Person =
         Person Name Address
         deriving (Eq, Show)

       mkPerson :: String -> String -> Maybe Person
       mkPerson n a =
         case (mkName n, mkAddress a) of
           (_, Nothing) -> Nothing
           (Nothing, _) -> Nothing
           (Just n', Just a') -> Just $ Person n' a'
     #+END_SRC

     The functions ~mkName~ and ~mkAddress~ successfully leveraged ~fmap~.
     However, the ~mkPerson~ above didn't really make it work with a concise
     implementation. Let's investigate this:
     #+BEGIN_SRC haskell
     fmap Person (mkName "Babe")  -- this one works

     name = mkName "Babe"
     address = mkAddress "old macdonald's"

     fmap (fmap Person name) address  -- this doesn't work
     -- (Person <$> name) <$> address

     Person <$> name <*> address
     #+END_SRC

**** DONE Breaking down the example - 697
     CLOSED: [2017-07-02 Sun 03:09]

**** DONE ~Maybe~ Functor and the Name constructor - 697
     CLOSED: [2017-07-02 Sun 17:26]
     #+BEGIN_SRC haskell
       instance Functor Maybe where
         fmap _ Nothing = Nothing
         fmap f (Just a) = Just (f a)

       instance Applicative Maybe where
         pure = Just
         Nothing <*> _ = Nothing
         _ <*> Nothing = Nothing
         Just f <*> Just a = Just (f a)
     #+END_SRC
     The ~Applicative~ instance is _NOT exactly_ the same as the instance in base,
     but that's for _simplification_.

**** DONE ~Maybe~ Applicative and Person - 700
     CLOSED: [2017-07-02 Sun 17:36]

**** DONE Before we moooove on - 703
     CLOSED: [2017-07-02 Sun 17:46]
     - If you do things like
       ~DataConstructor <$> p1 <*> p2 <*> p3~
       You can use a conciser way: ~liftA3 DataConstructor p1 p2 p3~

**** DONE Exercise: Fixer Upper - 707
     CLOSED: [2017-07-02 Sun 03:16]
     #+BEGIN_SRC haskell
       -- 1
       const <$> Just "Hello" <*> pure "World"

       -- 2
       (,,,) <$> Just 90 <*> Just 10 <*> Just "Tierness" <*> pure [1, 2, 3]
     #+END_SRC

** DONE 17.6 ~Applicative~ laws - 707
   CLOSED: [2017-07-02 Sun 18:27]
   1. /Identity/: ~pure id <*> v = v~

   2. /Composition/: ~pure (.) <*> u <*> v <*> w = u <*> (v <*> w)~
      The parentheses here are important.

   3. /Homomorphism/: A homomorphism is a structure-preserving map between two
      algebraic structures.
      ~pure f <*> pure x = pure (f x)~
      For example:
      #+BEGIN_SRC haskell
        pure (+1) <*> pure 1
        -- 2
        -- This result looks indistinguishable from the result `(+1) 1`
        -- It acutally is if considered isolatedly.
        -- However, you CANNOT do `(pure (+1) <*> pure 1) + 1`, for the reason that
        -- `pure (+1) <*> pure 1  :: (Num a, Applicative f) => f a`
        -- Though the `f` here is kinda of meaningless.

        pure (+1) <*> pure 1 :: Maybe Int
        -- Just 2

        pure (+1) <*> pure 1 :: [Int]
        -- [2]

        pure (+1) <*> pure 1 :: Either a Int
        -- Right 2
      #+END_SRC

   4. /Interchange/:
      ~u <*> pure y = pure ($ y) <*> u~
      Pay attension that it is ~$~, not ~($)~.

** TODO 17.7 You knew this was coming - 713
   - =TODO= ~QuickChecking~

** TODO 17.8 ZipList ~Monoid~ - 716
   - There is another Monoid for lists: ~ZipList~.
     ~ZipList~ is provided in ~Control.Applicative~, but NO /Monoid/ instance is
     provided. Define ourselves:
     #+BEGIN_SRC haskell
       instance Monoid a => Monoid (ZipList a) where
         mempty = ZipList []
         mappend = liftA2 mappend
     #+END_SRC
     
*** TODO Zero vs. Identity - 718
*** TODO List Applicative Exercise - 718
*** TODO ZipList Applicative Exercise - 720
    - *Explaining and justifying the weird EqProp*

*** TODO ~Either~ and ~Validation~ Applicative - 722
**** TODO Specializing the types - 722
**** TODO ~Either~ versus Validation - 722
**** TODO Exercise: Variations on ~Either~ - 725

** DONE 17.9 Chapter Exercises - 725
   CLOSED: [2017-07-02 Sun 21:26]
   #+BEGIN_SRC haskell
     {#- LANGUAGE NoMonomorphismRestriction #-}
     module ChapterExercises where

     import Control.Applicative (liftA3)

     -- PART 1
     --
     -- 1.
     -- []   is the type
     pure' = pure :: a -> [a]
     ap' = (<*>) :: [(a -> b)] -> [a] -> [b]
     -- TODO: CANNOT define <*>', WHY???
     -- instance Applicative [ ] where
     --   pure x = [x]
     --   (<*>) (f:fs) list = (map f list) <> (fs <*> list)

     -- 2. -- Type
     -- IO   is the type
     pure'' = pure :: a -> IO a
     ap'' = (<*>) :: IO (a -> b) -> IO a -> IO b

     -- 3. -- Type
     -- (,) a   is the type
     pure''' = pure :: Monoid c => a -> (c, a)
     ap''' = (<*>) :: Monoid c => (c, (a -> b)) -> (c, a) -> (c, b)

     -- Since there is an arbitrary `Monoid c`,
     -- when use `pure'''` and `ap'''`, it is better to suffix a type signature with
     -- a specific datatype `c`.

     -- 4. -- Type
     -- (->) e   is the type
     pure'''' = pure :: Monoid e => a -> (e -> a)
     ap'''' = (<*>) :: Monoid e => (e -> (a -> b)) -> (e -> a) -> (e -> b)

     --
     -- PART 2
     --
     -- 1
     data Pair a = Pair a a deriving Show

     instance Applicative Pair where
       pure x = Pair x x
       (Pair f g) <*> (Pair x y) = Pair (f x) (g y)

     -- 2
     data Two a b = Two a b

     instance Monoid a => Applicative (Two a) where
       pure = Two mempty
       (Two a f) <*> (Two a' b) = Two (a <> a') (f b)

     -- 3
     data Three a b c = Three a b c

     instance (Monoid a, Monoid b) => Applicative (Three a b) where
       pure = Three mempty mempty
       (Three a b f) <*> (Three a' b' c) = Three (a <> a') (b <> b') (f c)

     -- 4
     data Three' a b = Three' a b b

     instance Monoid a => Applicative (Three' a) where
       pure x = Three' mempty x x
       (Three' a f g) <*> (Three' a' b c) = Three' (a <> a') (f b) (g c)

     -- 5
     data Four a b c d = Four a b c d

     instance (Monoid a, Monoid b, Monoid c) => Applicative (Four a b c) where
       pure = Four mempty mempty mempty
       (Four a b c f) <*> (Four a' b' c' d) = Four (a <> a') (b <> b') (c <> c') (f d)

     -- 6
     data Four' a b = Four' a a a b
     instance Monoid a => Applicative (Four' a) where
       pure = Four' mempty mempty mempty
       (Four' a a' a'' f) <*> (Four' b b' b'' c) = Four' (a <> b) (a' <> b') (a'' <> b'') (f c)
   #+END_SRC

*** DONE Combinations - 727
    CLOSED: [2017-07-02 Sun 21:25]
    #+BEGIN_SRC haskell
      stops :: String
      stops = "pbtdkg"

      vowels :: String
      vwwels = "aeiou"

      combos :: [a] -> [b] -> [c]-> [(a, b, c)]
      combos = liftA3 (,,) stops vowels stops
    #+END_SRC

** DONE 17.10 Definitions - 727
   CLOSED: [2017-07-02 Sun 03:22]
   1. ~Applicative~: ...

** TODO 17.11 Follow-up resources - 727

* TODO 18 [ =Reading= ] ~Monad~ - 729
** DONE 18.1 ~Monad~ - 730
   CLOSED: [2017-07-03 Mon 22:35]
   - /Monads/ are NOT, strictly speaking, necessary to Haskell.
     Older implementations of Haskell do NOT have /Monads/.

   - /Monads/ are /applicative functors/.

   - In this chapter, we
     - define Monad, its operations and laws;
     - look at several examples of monads in practice;
     - write the Monad instances for various types;
     - _address some misinformation about monads_

** DONE 18.2 Sorry -- ~Monad~ is not a burrito - 730
   CLOSED: [2017-07-04 Tue 03:07]
   #+BEGIN_SRC haskell
     -- The `Applicative m` appears in GHC 7.10 or newer
     class Applicative m => Monad m where
       (>>=) :: m a -> (a -> m b) -> m b
       (>>) :: m a -> m b -> m b
       return :: a -> m a
   #+END_SRC

   Let's explore this in some detail, and start with the type class constraint on
   ~m~.

*** DONE ~Applicative m~ - 731
    CLOSED: [2017-07-04 Tue 00:47]
    - Older versions of GHC did NOT have ~Applicative~ as a superclass of ~Monad~.
      However,
      given that ~Monad~ is stronger than ~Applicative~, and ~Applicative~ is
      stronger than ~Functor~, you can derive ~Applicative~ and ~Functor~ in terms
      of ~Monad~, just as you can derive ~Functor~ in terms of ~Applicative~:
      #+BEGIN_SRC haskell
        fmap f xs = xs >>= return . f
        
        fmap (+1) [1..3]
        [1..3] >>= return . (+1)
      #+END_SRC
      This happens to be a law, NOT just a convenience.
      =TODO=
      Explore the relationship between ~Functor~, ~Applicative~, and ~Monad~ more
      LATER.

    - The chain of dependency: ~Functor -> Applicative -> Monad~

      Whenever you've implemented an instance of ~Monad~ for a type you
      _NECESSARILY_ have an ~Applicative~ and a ~Functor~ as well.

*** DONE Core operations - 732
    CLOSED: [2017-07-04 Tue 01:00]
    - A minimally complete ~Monad~ instance only need to define ~>>=~.

    - All the four core operations:
      #+BEGIN_SRC haskell
        (>>=) :: m a -> (a -> m b) -> m b
        (>>) :: m a -> m b -> m b
        return :: a -> m a
        fail :: String -> m a   -- This one isn't mentioned in Chris's book version 0.12
      #+END_SRC

    - ~return~ is like ~pure~, and we used it in the Modules chapter. No more to
      say about it.

    - ~>>~ has no official English-language name, but we like to call it _Mr. Pointy_.
      A more informative name used by people is /sequencing operator/.
      Basically _Mr. Pointy_
      _sequences two actions while discarding any resulting value of the first action_.

      Applicative has a similar operator as well,
      although we _didn't_ talk about it in that chapter. We will see examples of
      this operator in the upcoming section on ~do~ syntax.

    - Finally, the big bind! The ~>>=~ operator is called /bind/ and is -- or, at
      least, contains -- the things that are special about ~Monad~.

*** DONE The novel part of ~Monad~ - 732
    CLOSED: [2017-07-04 Tue 02:02]
    - Conventionally when we use /monads/, we use the bind function, ~>>=~.
      Sometimes we use it directly, sometimes indirectly via ~do~ syntax.

    - Compare the types between ~fmap~, ~<*>~, and ~>>=~:
      #+BEGIN_SRC haskell
        fmap  :: Functor f     =>   (a -> b) -> f a        -> f b
        (<*>) :: Applicative f => f (a -> b) -> f a        -> f b
        (>>=) :: Monad f       => f a        -> (a -> f b) -> f b

        -- If we change some types in `fmap` to make it more like (if flip the
        -- first two parameters) `(>>=)`.

        -- If b == f b
        fmap :: Functor f => (a -> f b) -> f a -> f (f b)
        -- This `fmap` (with a specific type of its first parameter) generate a
        -- result which has one more layer of structure.
      #+END_SRC

    - The ability to _flatten those TWO layers of structure into one_ is what
      truly makes ~Monad~ special.
        By putting the ~join~ function together with the mapping function that we
      get ~bind~, as known as ~>>=~.

    - *The answer is the exercise*
      #+BEGIN_SRC haskell
        -- Write `bind` in terms of `fmap` and `join`.
        bind :: Monad m => (a -> m b) -> m a -> m b
        bind f xs = join $ fmap f xs
      #+END_SRC

*** DONE What ~Monad~ is not - 735
    CLOSED: [2017-07-04 Tue 02:19]
    - ~Monad~ is _NOT_:
      1. Impure. ~IO~ is an abstract datatype that allows for impure, or
         effectful, actions, and it has a ~Monad~ instance.
         BUT there's NOTHING impure about /Monads/.

      2. An embedded language for imperative programming.
         WHILE monads are often used for _sequencing actions_ in a way that
         looks like imperative programming, there are /commutative monads/ that
         do NOT order actions. We'll see one a few chapters down the line when we
         talk about ~Reader~.

      3. A value. A type class describes a specific relationship between elements
         in a domain and defines some operations over them.
         "a monad", "a monoid", or "a functor", NONE of them are values.

      4. About strictness.
         + ~bind~ and ~return~ are nonstrict.
         + Some operations can be made strict within a specific instance.
           =TODO= =Talk more later!=

    - DON'T try to learn math first and use ~Monad~. It is NOT necessary.

*** DONE ~Monad~ also lifts! - 736
    CLOSED: [2017-07-04 Tue 03:07]
    - ~Monad~ type class also includes a set of /lift/ functions that are the same
      as the ones we already saw in ~Applicative~.
        They don't do anything different, but they are still around
      BECAUSE some libraries used them _before applicatives were discovered_.

    - Compare the types of /lifts/ from ~Applicative~ and ~Monad~:
      #+BEGIN_SRC haskell
        liftA :: Applicative f => (a -> b)  -> f a  -> f b
        liftM :: Monad m =>       (a -> b) -> m a -> m b
      #+END_SRC
      As you may recall, from the point of view of types, they are just
      _fmap-like_ with a different type class constraint.

    - The above /lifts/ are not all we have:
      + ~liftA2~ and ~liftM2~:
        #+BEGIN_SRC haskell
          liftA2 :: Applicative f =>
                    (a -> b -> c)
                    -> f a
                    -> f b
                    -> f c

          liftM2 :: Monad m =>
                    (a1 -> a2 -> r)
                    -> m a1
                    -> m a2
                    -> m r

          -- Try them:
          liftA2 (,) (Just 3) (Just 5)
          liftM2 (,) (Just 3) (Just 5)
          -- Just (3,5)

          -- `zipWith` is `liftA2` or `liftM2` specialized to lists --
          -- same type signature, different behaviors.
          zipWith (+) [3, 4] [5, 6]
          -- [8,10]

          liftA2 (+) [3, 4] [5, 6]
          -- [8,10]
        #+END_SRC

      + ~liftA2~ and ~liftM2~:
        #+BEGIN_SRC haskell
          liftA3 :: Applicative f =>
                    (a -> b -> c -> d)
                    -> f a -> f b
                    -> f c -> f d

          liftM3 :: Monad m =>
                    (a1 -> a2 -> a3 -> r)
                    -> m a1 -> m a2
                    -> m a3 -> m r

          zipWith3 (,,) [1, 2] [3] [5, 6]
          -- [(1,3,5)]

          liftM3 (,,) [1, 2] [3] [5, 6]
          -- [(1,3,5),(1,3,6),(2,3,5),(2,3,6)]
        #+END_SRC

** DONE 18.3 ~do~ syntax and Monads - 738
   CLOSED: [2017-07-04 Tue 05:43]
   - ~do~ syntax is a syntactic sugar that allowed us to easily _sequence_
     actions
     by feeding the result of one action as the input value to the next.

   - Use the ~IO Monad~ to explain the ~do~ syntax in this section, though
     ~do~ syntax works with any /Monad/.

   - Let's look at some correspondences:
     #+BEGIN_SRC haskell
       -- Same thing ,different constraints
       (*>) :: Applicative f => f a -> f b -> f b
       (>>) :: Monad m =>       m a -> m b -> m b

       putStrLn "Hello, " >> putStrLn "World!"
       putStrLn "Hello, " *> putStrLn "World!"
       -- Hello,
       -- World!
     #+END_SRC
     Not observably different.

   - Manually desugar ~do~ syntax to say what compiler helps us do:
     #+BEGIN_SRC haskell
       import Control.Applicative ((*>))

       -- The functions below have the same result.
       sequencing :: IO ()
       sequencing = do
         putStrLn "blah"
         putStrLn "another thing"

       sequencing' :: IO ()
       sequencing' =
         putStrLn "blah" >>
         putStrLn "another thing"

       sequencing'' :: IO ()
       sequencing'' =
         putStrLn "blah" *>
         putStrLn "another thing"
     #+END_SRC

   - Do the same with the variable binding that ~do~ syntax includes:
     #+BEGIN_SRC haskell
       binding :: IO ()
       binding = do
         name <- getLine
         putStrLn name

       binding' :: IO ()
       binding' =
         getLine >>= putStrLn
     #+END_SRC

*** DONE =RE-READ= When ~fmap~ alone isn't enough - 739
    CLOSED: [2017-07-04 Tue 05:43]
    - ~putStrLn <$> getLine~ won't do anything -- it didn't print anything out.

    - Q :: What happened?

    - A :: 
      + Let's check the type first:
         #+BEGIN_SRC haskell
           --   [1]  [2]  [3]
           h :: IO  (IO   ())
           h = putStrLn <$> getLine

           -- 1. This outermost `IO` structure represents the effects `getLine`
           --    must perform to get you a `String` that the user typed in.

           -- 2. This inner `IO` structure represents the effects that would be
           --    performed if `putStrLn` was evaluated.
           --    TODO: AM I RIGHT? I'M STILL NOT CLEAR
           --    From Jian: since `putStrLn` was not performed, we know
           --               `putStrLn` isn't  evaluated.

           -- 3. The unit, `()`, here is the unit that `putStrLn` returns.
         #+END_SRC

      + Conclusion: 
        * For GHCi:
          https://stackoverflow.com/questions/24549610/fmap-print-value-doesnt-print-anything
          Also, GHCi has the following rules about interactive evaluation:
          #+BEGIN_SRC text
          2.4. Interactive evaluation at the prompt

          When you type an expression at the prompt, GHCi immediately evaluates and
          prints the result:
          


          2.4.1. I/O actions at the prompt
          
          GHCi does more than simple expression evaluation at the prompt. If you
          type something of type  IO a for some a, then GHCi executes it as an
          IO-computation.
          
          Furthermore, GHCi will print the result of the I/O action if (and only
          if):
          
          + The result type is an instance of Show.
          + The result type is not ().
          #+END_SRC
          _Since ~IO~ a is NOT an instance of ~Show~, it won't print the result of
          the ~IO~ action._

        * For the code in source file:
          There will be an error!!!
          TYPE MISS MATCH -- ~main~ must be a type of ~IO ()~,
          and ~putStrLn <$> getLine~ has a type ~IO (IO ())~

    - One of the strengths  of Haskell is that we can
      + refer to,
      + compose,
      + map over
      effectful computations without performing them or bending over backwards
      to make the pattern work. For a simpler example of how we can wait to
      evaluate ~IO~ actions (or any computation in general really), consider
      the following:
      #+BEGIN_SRC haskell
        printOne = putStrLn "1"
        printTwo = putStrLn "2"

        twoActions = (printOne, printTwo)
        -- Prelude> :t twoActions
        -- twoActions :: (IO (), IO ())

        fst twoActions
        -- 1

        snd twoActions
        -- 2

        fst twoActions
        -- 1
      #+END_SRC
      Note that we are able to evaluate ~IO~ actions multiple times.
      =TODO= This will be significant later.

    - From the type we know, we can make it work with the help of ~join~:
      #+BEGIN_SRC haskell
        import Control.Monad (join)
        join $ putStrLn <$> getLine
      #+END_SRC
      ~join~ megers the effects of ~putStrLn~ and ~getLine~ into a _single_
      ~IO~ action.
        The "order" is determined by the nesting of the ~IO~ actions.
        As it happens, the cleanest way to express “ordering” in a lambda
      calculus without bolting on something unpleasant is through nesting of
      expressions or lambdas.


    - Some examples with our now-enriched understanding of what monads do for us:
      #+BEGIN_SRC haskell
        bindingAndSequencing :: IO ()
        bindingAndSequencing = do
          putStrLn "name pls:"
          name <- getLine
          putStrLn ("y helo thar: " ++ name)

        bindingAndSequencing' :: IO ()
        bindingAndSequencing' =
          putStrLn "name pls:" >>
          getLine >>=
          \name -> putStrLn ("y helo thar: " ++ name)



        -- As the nesting intensifies, you can see how do syntax can make
        -- things a bit cleaner and easier to read:

        twoBinds :: IO ()
        twoBinds = do
          putStrLn "name pls:"
          name <- getLine
          putStrLn "age pls:"
          age <- getLine
          putStrLn ("y helo thar: "
                    ++ name ++ " who is: "
                    ++ age ++ " years old.")

        twoBinds' :: IO ()
        twoBinds' =
          putStrLn "name pls:" >>
          getLine >>=
          \name ->
            putStrLn "age pls:" >>
            getLine >>=
            \age ->
              putStrLn ("y helo thar: "
                        ++ name ++ " who is: "
                        ++ age ++ " years old.")
      #+END_SRC

** TODO 18.4 Examples of ~Monad~ use - 744
*** DONE List - 744
    CLOSED: [2017-07-04 Tue 06:57]
**** DONE Specializing the types - 744
     CLOSED: [2017-07-04 Tue 06:57]

**** DONE Example of the List ~Monad~ in use - 744
     CLOSED: [2017-07-04 Tue 06:57]
     #+BEGIN_SRC haskell
       twiceWhenEven :: [Integer] -> [Integer]
       twiceWhenEven xs = do
         x <- xs
         if even x
           then [x*x, x*x]
           else [x*x]

       twiceWhenEven [1..3]
       -- [1,4,4,9]
     #+END_SRC

*** DONE ~Maybe~ ~Monad~ - 745
    CLOSED: [2017-07-04 Tue 20:01]
**** DONE Specializing the types - 746
     CLOSED: [2017-07-04 Tue 06:59]

**** DONE Using the ~Maybe~ ~Monad~ - 746
     CLOSED: [2017-07-04 Tue 20:01]
     #+BEGIN_SRC haskell
       data Cow = Cow {
             name :: String
             , age :: Int
             , weight :: Int
          } deriving (Eq, Show)

       noEmpty :: String -> Maybe String
       noEmpty "" = Nothing
       noEmpty str = Just str

       noNegative :: Int -> Maybe Int
       noNegative n | n >= 0 = Just n
                    | otherwise = Nothing

       weightCheck :: Cow -> Maybe Cow
       weightCheck c =
         let w = weight c
             n = name c
         in
           if n == "Bess" && w > 499
           then Nothing
           else Just c

       mkSphericalCow :: String -> Int -> Int -> Maybe Cow
       mkSphericalCow name' age' weight' =
         case noEmpty name' of
           Nothing -> Nothing
           Just nammy ->
             case noNegative age' of
               Nothing -> Nothing
               Just agey ->
                 case noNegative weight' of
                   Nothing -> Nothing
                   Just weighty ->
                     weightCheck (Cow nammy agey weighty)

       mkSphericalCow "Bess" 5 499
       -- Just (Cow {name = "Bess", age = 5, weight = 499})

       mkSphericalCow "Bess" 5 500
       -- Nothing
     #+END_SRC

**** DONE Exploding a spherical cow - 750
     CLOSED: [2017-07-04 Tue 20:01]
     Walk through an example.

**** DONE Fail fast, like an overfunded startup - 753
     CLOSED: [2017-07-04 Tue 20:01]
     Since one branch of ~noEmpty~ is ~Nothing >>= _ = Nothing~ (~noNegative~ has
     a similary branch), function ~mkSphericalcow~ is good at "Fail fast".NO
     useless calculation.

*** TODO ~Either~ - 755
**** DONE Specializing the types - 755
     CLOSED: [2017-07-04 Tue 20:38]
     #+BEGIN_SRC haskell
       -- m ~ Either e
       (>>=) :: Monad m => m a -> (a ->        m b) ->        m b
       (>>=) ::     Either e a -> (a -> Either e b) -> Either e b

       -- same as pure
       return :: Monad m => a ->        m a
       return ::            a -> Either e a
     #+END_SRC
**** TODO Using the ~Either~ ~Monad~ - 755
     #+BEGIN_SRC haskell
       -- years ago
       type Founded = Int
       -- number of programmers
       type Coders = Int

       data SoftwareShop =
         Shop {
             founded :: Founded
           , programmers :: Coders
         } deriving (Eq, Show)

       data FoundedError =
           NegativeYears Founded
         | TooManyYears Founded
         | NegativeCoders Coders
         | TooManyCoders Coders
         | TooManyCodersForYears Founded Coders
         deriving (Eq, Show)

       validateFounded :: Int -> Either FoundedError Founded
       validateFounded n
         | n < 0 = Left $ NegativeYears n
         | n > 500 = Left $ TooManyYears n
         | otherwise = Right n

       -- Tho, many programmers *are* negative.
       validateCoders :: Int -> Either FoundedError Coders
       validateCoders n
         | n < 0 = Left $ NegativeCoders n
         | n > 5000 = Left $ TooManyCoders n
         | otherwise = Right n

       mkSoftware :: Int -> Int -> Either FoundedError SoftwareShop
       mkSoftware years coders = do
         founded <- validateFounded years
         programmers <- validateCoders coders
         if programmers > div founded 10
           then Left $ TooManyCodersForYears founded programmers
           else Right $ Shop founded programmers
     #+END_SRC

     Note that ~Either~ always short-circuits on the _first_ thing to have
     failed. It _MUST_ becuase in the ~Monad~, later values can depend on
     previous ones:
     #+BEGIN_SRC haskell
       -- Test
       mkSoftware 0 0
       -- Right (Shop {founded = 0, programmers = 0})

       mkSoftware (-1) 0
       -- Left (NegativeYears (-1))

       mkSoftware (-1) (-1)
       -- Left (NegativeYears (-1))

       mkSoftware 0 (-1)
       -- Left (NegativeCoders (-1))

       mkSoftware 500 0
       -- Right (Shop {founded = 500, programmers = 0})

       mkSoftware 501 0
       -- Left (TooManyYears 501)

       mkSoftware 501 501
       -- Left (TooManyYears 501)

       mkSoftware 100 5001
       -- Left (TooManyCoders 5001)

       mkSoftware 0 500
       -- Left (TooManyCodersForYears 0 500)
     #+END_SRC

     - =TODO= So, there is no Monad for ~Validation~.

       ~Applicative~ and ~Monad~ instances must have the same behavior.
       This is usually expressed in the form:
       #+BEGIN_SRC haskell
         import Control.Monad (ap)

         (<*>) == ap
       #+END_SRC
       This is a way of saying the ~Applicative~ apply for a type must NOT change
       behavior if derived from the ~Monad~ instance's bind operation.
       #+BEGIN_SRC haskell
         -- Keeping in mind
         (<*>) :: Applicative f => f (a -> b) -> f a -> f b
         ap ::          Monad m => m (a -> b) -> m a -> m b

         -- Then deriving ~Applicative~ (<*>) from the stronger instance:
         ap :: (Monad m) => m (a -> b) -> m a -> m b
         ap m m' = do
           x  <- m
           x' <- m'
           return (x x')
       #+END_SRC

       =TODO=
       The _PROBLEM_ is 
       you CANNOT make a ~Monad~ for ~Validation~ that accumulates the errors
       like the ~Applicative~ does. Instead, any ~Monad~ instance for
       ~Validation~ would be identical to the ~Either~'s monad instance.

**** TODO Short Exercise: ~Either~ ~Monad~ - 758
     Implement the ~Either Monad~ 
     #+BEGIN_SRC haskell
       data Sum a b =
           First a
         | Second b
         deriving (Eq, Show)

       instance Functor (Sum a) where
         fmap _ (First av) = First av
         fmap f (Second bv) = Second (f bv)

       instance Applicative (Sum a) where
         pure = Second
         (First av) <*> _ = First av
         _ <*> (First av) = First av
         (Second g) <*> (Second bv) = Second (g bv)

       instance Monad (Sum a) where
         return = pure
         (First av) >>= _ = First av
         (Second bv) >>= f = f bv
     #+END_SRC

** TODO 18.5 ~Monad~ laws - 759
*** DONE Identity laws - 759
    CLOSED: [2017-07-04 Tue 22:17]
    Two /Identity laws/:
    + Right identity
      ~m >>= return~ is equivalent to ~m~

    + Left identity
      ~return x >>= f~ is equivalent to ~f x~

    Basically both of these laws are saying that ~return~ should be
    NEUTRAL and NOT perfrom any computation.

    We'll line them up with the type of ~>>=~ to clarify what's happening:
    #+BEGIN_SRC haskell
      (>>=) :: Monad m => m a -> (a -> m b) -> m b
      --                  [1]       [2]        [3]

      -- First, right identity
      return :: a -> m a
          m >>= return    ==   m
      -- [1]      [2]         [3]

      -- Second, left identity
      return x >>= f      ==  f x
      -- [1]      [2]         [3]
    #+END_SRC

*** TODO Associativity - 760
    The /associativity/ of ~Monad~ is _NOT so different_ from other laws of
    /associativity/ we have seen. It DOES look a little bit  different because of
    the nature of ~>>=~:
    ~(m >>= f) >>= g~ is equivalent to ~m >>= (\x -> f x >>= g)~

*** TODO We're doing that thing again - 761
*** TODO Bad ~Monad~'s and their denizens - 761

** TODO 18.6 ~Application~ and composition - 766
** TODO 18.7 Chapter Exercises - 770
   - =TODO=
     1. 
     2. 
     3. 
     4. 

   - =TODO=
     1. 
     2. 
     3. 
     4. 
     5. 
     6. 

** TODO 18.8 Definition - 772
   1. 
   2. 
   3. 

** TODO 18.9 Follow-up resources - 773

* TODO 19 Applying structure - 775
** TODO 19.1 Applied structure - 776
** TODO 19.2 Monoid - 776
*** TODO Templating content in Scotty - 776
*** TODO Concatenating connection parameters - 777
*** TODO Concatenating key configurations - 778

** TODO 19.3 Functor - 781
*** TODO Lifting over ~IO~ - 781
*** TODO Lifting over web app monads - 783

** TODO 19.4 Applicative - 784
*** TODO hgrev - 784
*** TODO More parsing - 785
*** TODO And now for something different - 787

** TODO 19.5 Monad - 788
*** TODO Opening a network socket - 789
*** TODO Binding over failure in initialization - 789

** TODO 19.6 An end-to-end example: URL shortener - 790
*** TODO Brief aside about polymorphic literals - 792
*** TODO Back to the show - 794
*** TODO Exercise - 803

** TODO 19.7 That's a wrap! - 803
** TODO 19.8 Follow-up resources - 804
   1. TODO

* TODO 20 ~Foldable~ - 805
** DONE 20.1 ~Foldable~ - 806
   CLOSED: [2018-09-06 Thu 03:27]
   This ~Foldable~ /type class/ has been appearing in type signatures at least since
   Chapter 3, but we just consider it like a foldable thing as a list.

   This chapter, we will explain what ~Foldable~ is in general.
   We will expand on the idea of /catamorphisms/ and generalize it to many /datatypes/.

   - The folding function is always dependent on some ~Monoid~ /instance/.

     The folds we wrote previously mostly relied on *implicit* _monoidal operations_.
     As we'll see in this chapter, generalizing /catamorphisms/ to other datatypes
     depends on understanding the /monoids/ for those structures and, *in some
     cases, making them explicit*.

   - This chapter will cover:
     + the ~Foldable~ /type class/ and its core operations;
     + the *monoidal nature* of /folding/;
     + standard operations _derived from_ /folding/.

** DONE 20.2 The ~Foldable~ class - 806
   CLOSED: [2018-09-06 Thu 03:27]
   The ~Foldable~ includes many operations.
   We're going to go through the full definition a little at a time.

   - The defintion in the librar begins:
     #+BEGIN_SRC haskell
       class Foldable t where
         {-# MINIMAL foldMap | foldr #-}
     #+END_SRC
     + The ~MINIMAL~ /annotation/ on the /type class/ tells you that
       *a minimally complete definition* of the /type class/ will define ~foldMap~
       *OR* ~foldr~ for a /datatype/.

       * You may notice the *OR* (~|~ in code) above:
         ~foldMap~ and ~foldr~ can each be implemented in terms of the other.

   - Run ~:i Foldable~ in your GHCi, and you'll see:
     ~class Foldable (t :: * -> *) where~

     =TODO=
     =TODO=
     =TODO= Review /higher-kinded type/ part!!!

     That ~t~ should be a /higher-kinded type/ is not surprising:
     /lists/ are /higher-kinded types/.

     We need ~t~ to be a /type constructor/ for the same reasons we did with
     ~Functor~, and we will see that the effects are very similar.

     Types that take more than one type argument, such as /tuples/ and ~Either~,
     will necessarily have their *first type argument* _included as part of their
     structure_.

   - Preparation for the example code in this chapter:
     + Use GHC 7.10 or later versions.

     + Also, while the ~Prelude~ as of GHCi 7.10 includes many changes related to
       the ~Foldable~ /type class/, *not all* of ~Foldable~ is in the ~Prelude~.

       To follow along with the examples in the chapter, you will need to *import*
       ~Data.Foldable~ and ~Data.Monoid~ (for some of the ~Monoid~ /newtypes/).

** TODO 20.3 Revenge of the monoids - 807
   #+BEGIN_SRC haskell
     class Foldable (t :: * -> *) where
       fold :: Data.Monoid.Monoid m => t m -> m
       foldMap :: Data.Monoid.Monoid m => (a -> m) -> t a -> m
   #+END_SRC

*** And now for something different - 809

** TODO 20.4 Demonstrating ~Foldable~ instances - 811
*** ~Identity~ - 811
*** ~Maybe~ - 812

** TODO 20.5 Some basic derived operations - 814
*** Exercises: Library functions - 818

** TODO 20.6 Chapter exercises - 819
   1. 
   2. 
   3. 
   4. 
   5. 

** TODO 20.7 Follow-up resources - 820

* TODO 21 ~Traversable~ - 821
** TODO 21.1 ~Traversable~ - 822
** TODO 21.2 The ~Traversable~ type class definition - 822
   #+BEGIN_SRC haskell
     class (Functor t, Foldable t) => Traversable t where
       {-# MINIMAL traverse | sequenceA #-}

       -- | Map each element of a structure to an action,
       -- evaluate these actions from left to right, and
       -- collect the results. For a version that ignores
       -- the results see 'Data.Foldable.traverse_'.
       traverse :: Applicative f =>
                   (a -> f b)
                -> t a
                -> f (t b)
       traverse f = sequenceA . fmap f
       -- | Evaluate each action in the structure from
       -- left to right, and collect the results.
       -- For a version that ignores the results see
       -- 'Data.Foldable.sequenceA_'.
       sequenceA :: Applicative f => t (f a) -> f (t a)
       sequenceA = traverse id
   #+END_SRC

** TODO 21.3 ~sequenceA~ - 824
** TODO 21.4 ~traverse~ - 825
*** ~mapM~ is ~traverse~ - 827

** TODO 21.5 So, what's ~Traversable~ for? - 828
** TODO 21.6 Morse code revisited - 828
** TODO 21.7 Axing tedious code - 831
** TODO 21.8 Do all the things - 833
*** Strength for understanding - 834

** TODO 21.9 ~Traversable~ instances - 835
*** ~Either~ - 836
*** ~Tuple~ - 836

** TODO 21.10 Traversable laws - 837
** TODO 21.11 Quality control - 838
** TODO 21.12 Chapter exercises - 839
*** TODO ~Traversable~ instances - 839
*** TODO ~Identity~ - 839
*** Constant
*** Maybe
*** List
*** Three
*** Pair
*** Big
*** Bigger
*** S
*** TODO Instances for ~Tree~ - 841

** TODO 21.13 Follow-up resources - 842

* TODO 22 ~Reader~ - 843
** TODO 22.1 ~Reader~ - 844
   - _Requirement_:
     When writing applications, programmers often need to pass around some
     information that may be needed intermittently or universally throughout an
     entire application.
     + _Extra consideration_:
       We don't want to simply pass this information as arguments because it
       would be present in the type of almost every function. This can make the
       code harder to read and harder to maintain.
       =from Jian= /Dependency Injection/

   - _Solution_: ~Reader~.

   - In this chapter, we will:
     + examine the ~Functor~, ~Applicative~, and ~Monad~ instances for functions;
     + learn about the ~Reader~ newtype;
     + see some examples of using ~Reader~.

** TODO 22.2 A new beginning - 844
   #+begin_src haskell
     import Control.Applicative

     boop = (*2)
     doop = (+10)

     bip :: Integer -> Integer
     bip = boop . doop
   #+end_src

   - We can also write the /function composition/ this way:
     #+begin_src haskell
       bloop :: Integer -> Integer
       bloop = fmap boop doop
     #+end_src
     _The ~Functor~ of functions_.

   - Put functions below in the same file of ~boop~ and ~doop~:
     #+begin_src haskell
       bbop :: Integer -> Integer
       bbop = (+) <$> boop <*> doop

       duwop :: Integer -> Integer
       duwop = liftA2 (+) boop doop
     #+end_src

*** TODO Short Exercise: Warming Up - 849

** TODO 22.3 This is Reader - 851
** TODO 22.4 Breaking down the ~Functor~ of functions - 851
** TODO 22.5 But uh, ~Reader~? - 854
*** TODO Exercise: Ask - 855

** TODO 22.6 Functions have an ~Applicative~ too - 856
*** TODO Demonstrating the function ~Applicative~ - 856
*** TODO Exercise: Reading comprehension - 859

** TODO 22.7 The ~Monad~ of functions - 861
*** TODO The ~Monad~ instance - 863
*** TODO Example uses of the ~Reader~ type - 864
*** TODO Exercise: ~Reader~ ~Monad~ - 864

** TODO 22.8 Reader ~Monad~ by itself is boring - 864
** TODO 22.9 You can change what comes below - 866
** TODO 22.10 You tend to see ~ReaderT~, not ~Reader~ - 866
** TODO 22.11 Chapter exercises - 867
*** TODO A warm-up stretch - 867
*** TODO Rewriting Shawty - 871

** TODO 22.12 Definition - 871
** TODO 22.13 Follow-up resources - 871

* TODO 23 ~State~ - 873
** TODO 23.1 State - 874
** TODO 23.2 What is state? - 874
** TODO 23.3 Random numbers - 875
** TODO 23.4 The ~State~ ~newtype~ - 878
** TODO 23.5 Throw down - 880
*** TODO Keep on rolling - 884
*** TODO Exercises: Roll Your Own - 885

** TODO 23.6 Write State for yourself - 885
*** TODO State ~Functor~ - 886
*** TODO State ~Applicative~ - 886
*** TODO State ~Monad~ - 886

** TODO 23.7 Get a coding job with one weird trick - 887
*** TODO Fizzbuzz differently - 890

** TODO 23.8 Chapter exercises - 891
   1. 
   2. 
   3. 
   4. 
   5. 

** TODO 23.9 Follow-up resources - 892

* TODO 24 Parser Combinators - 893
** TODO 24.1 Parser combinators - 894
** TODO 24.2 A few more words of introduction - 895
** TODO 24.3 Understanding the parsing process - 895
*** TODO Since we didn't use an analogy for ~Monad~ - 896
*** TODO What demonstration purposes? - 897
*** TODO Back to the code - 897
*** TODO A bit like.. - 898
*** TODO Back to our regularly scheduled coding - 901
*** TODO Exercises: Parsing practice - 904
*** TODO Intermission: Parsing free jazz - 904

** TODO 24.4 Parsing fractions - 906
*** TODO Exercise: Unit of success - 912

** TODO 24.5 Haskell's parsing ecosystem - 912
*** TODO Type classes of parsers - 913

** TODO 24.6 Alternative - 915
*** TODO ~QuasiQuotes~ - 918
*** TODO Return to Alternative - 920
*** TODO Exercise: Try try - 924

** TODO 24.7 Parsing configuration files - 925
** TODO 24.8 Character and token parsers - 934
*** TODO Insert tokens to play - 935

** TODO 24.9 Polymorphic parsers - 938
*** TODO It's not perfect and could bite you - 940
*** TODO Failure and backtracking - 940

** TODO 24.10 Marshalling from an AST to a datatype - 943
*** TODO Marshalling and unmarshalling JSON data - 944
*** TODO Back to the JSON - 947

** TODO 24.11 Chapter exercises - 954
   1. 
   2. 
   3. 
   4. 
   5. 
   6. 
   7. 
   8. 
   9. 
   10.

** TODO 24.12 Definitions - 960
   1. 
   2. 
   3. 
   4. 
   5. 

** TODO 24.13 Follow-up resources - 961

* TODO 25 Composing types - 962
** DONE 25.1 Composing types - 963
   CLOSED: [2019-10-09 Wed 22:00]
   This chapter and the next are about /monad transformers/, both the
   principles behind them and the practicalities of using them.

   - /Functors/ and /applicatives/ are both closed under composition:
     Compose two /functors/ (or two /applicatives/) and return another /functor/
     (or /applicative/, as the case may be).
       _However, compose /monads/ is not that simple, and the result is *not
     necessarily* another /monad/._

   - There are times when *composing monads* is desirable:
     1. Different /monads/ allow us to work with different _effects_.

     2. Composing monads allows you to build up computations with *MULTIPLE* /effects/.
        For example,
        By stacking, for example, a ~Maybe~ /monad/ with an ~IO~, you can
        + be performing /IO actions/
          _WHILE also_
        + building up computations that have a possibility of failure, handled by
          the ~Maybe~ /monad/.

   - A /monad transformer/ is _a VARIANT of an ORDINARY TYPE that takes an *additional
     type argument* which is assumed to have a ~Monad~ /instance/._
     + Example:
       ~MaybeT~ is the transformer variant of the ~Maybe~ type.

     + The transformer variant of a type gives us /a ~Monad~ instance/ that binds
       over both bits of structure. This allows us to *COMPOSE* /monads/ and
       *COMBINE* their /effects/.

   - In this chapter, we will
     + DEMONSTRATE
       why composing _TWO_ /monads/ *does not* give you another /monad/;

     + EXAMINE
       the ~Identity~ and ~Compose~ types;

     + MANIPULATE types UNTIL
       we can *make monads compose*;

     + MEET
       some _common monad transformers_;

     + WORK THROUGH
       an ~Identity~ crisis.

** TODO 25.2 Common functions as types - 964
*** TODO ~Identity~ is boring - 964
    #+BEGIN_SRC haskell
      new Identity a =
        Identity { runIdentity :: a }
    #+END_SRC
    - *A note about* ~newtypes~

*** TODO ~Compose~ - 965

** TODO 25.3 Two functors sittin' in a tree, L-I-F-T-I-N-G - 966
** TODO 25.4 Twinplicative - 968
*** TODO GOTCHA! Exercise time - 969

** TODO 25.5 Twonad? - 969
*** TODO No free burrito lunches - 970

** TODO 25.6 Exercises: Compose Instances - 971
*** TODO And now for something completely different - 971

** TODO 25.7 Monad transformers - 972
*** TODO Monadic stacking - 973
*** TODO Doing it badly - 973

** TODO 25.8 ~IdentityT~ - 974
*** TODO The bind breakdown - 976
*** TODO Implementing the bind, step by step - 978
*** TODO Refactoring - 983
*** TODO The essential extra of Monad transformers - 984

** TODO 25.9 Finding a pattern - 985

* TODO 26 Monad transformers - 988
** TODO 26.1 Monad transformers - 989
** TODO 26.2 ~MaybeT~ - 989
*** TODO Spoiler alert! - 990
*** TODO ~MaybeT~ Monad instance - 992

** TODO 26.3 ~EitherT~ - 994
*** TODO Exercises: ~EitherT~ - 994
    1. 
    2. 
    3. 
    4. 
    5. 

** TODO 26.4 ~ReaderT~ - 995
** TODO 26.5 ~StateT~ - 997
*** TODO Exercises: ~StateT~ - 997
    1. 
    2. 
    3. 

*** TODO ~ReaderT~, ~WriterT~, ~StateT~ - 998
*** TODO Correspondence between ~StateT~ and Parser - 999

** TODO 26.6 Types you probably don't want to use - 1000
*** TODO Why not use ~Writer~ or ~WriterT~? - 1000
*** TODO The ~ListT~ you want isn't made from the ~List~ type - 1000

** TODO 26.7 An ordinary type from a transformer - 1001
** TODO 26.8 Lexically inner is structurally outer - 1003
*** TODO Exercise: Wrap it up - 1005

** TODO 26.9 ~MonadTrans~ - 1005
*** TODO The type class that lifts - 1006
*** TODO Motivating ~MonadTrans~ - 1006
*** TODO ~MonadTrans~ instances - 1014
*** TODO Exercises: Lift More - 1016
    1. 
    2. 

*** TODO Prolific lifting is the failure mode - 1016
*** TODO Wrap it, smack it, pre-lift it - 1017

** TODO 26.10 ~MonadIO~ aka zoom-zoom - 1019
*** TODO Example ~MonadIO~ instances - 1021
*** TODO Exercises: Some Instances - 1021

** TODO 26.11 ~Monad~ transformers in use - 1022
*** TODO ~MaybeT~ in use - 1022
*** TODO Temporary extension of structure - 1024
*** TODO ~ExceptT~ aka ~EitherT~ in use - 1026
**** TODO Scotty, again - 1026
**** TODO Slightly more advanced code - 1029

** TODO 26.12 Monads do not commute - 1031
*** TODO Hypothetical Exercise - 1031

** TODO 26.13 Transform if you want to - 1031
** TODO 26.14 Chapter Exercises - 1032
*** TODO Write the code - 1032
    1. 
    2. 
    3. 
    4. 
    5. 
    6.

*** TODO Fix the code - 1034
*** TODO Hit counter - 1034
*** TODO Morra - 1037
    1. 
    2. 
    3. 
    4. 

** TODO 26.15 Definition - 1038
** TODO 26.16 Follow-up resources - 1038

* TODO 27 Non-strictness - 1039
** TODO 27.1 Laziness - 1040
** TODO 27.2 Observational bottom theory - 1041
*** TODO Standards and obligations - 1041

** TODO 27.3 Outside in, inside out - 1042
** TODO 27.4 What does the other way look like? - 1044
** TODO 27.5 Can we make Haskell strict? - 1045
*** TODO ~seq~ and ye shall find - 1046
*** TODO ~seq~ and weak head normal form - 1048
*** TODO Case matching also chains evaluation - 1049
*** TODO Core Dump - 1051
*** TODO A little bit stricter now - 1056
*** TODO Exercises: Evaluate - 1057
    1. 
    2. 
    3. 
    4. 
    5. 
    6. 
    7. 

** TODO 27.6 Call by name, call by need - 1057
** TODO 27.7 Non-strict evaluation changes what we can do - 1058
** TODO 27.8 Thunk Life - 1059
*** TODO Not all values get thunked - 1059

** TODO 27.9 Sharing is caring - 1062
*** TODO Using ~trace~ to observe sharing - 1062
*** TODO What promotes sharing - 1063
*** TODO What subverts or prevents sharing - 1065
*** TODO Why polymorphic values never seem to get forced - 1069
*** TODO Preventing sharing on purpose - 1074
*** TODO Forcing sharing - 1075

** TODO 27.10 Refutable and irrefutable patterns - 1076
*** TODO Lazy patterns - 1077

** TODO 27.11 Bang patterns - 1077
*** TODO Bang patterns in data - 1079

** TODO 27.12 Strict and StrictData - 1080
** TODO 27.13 Adding strictness - 1082
** TODO 27.14 Chapter Exercises - 1085
*** TODO Strict List - 1085
*** TODO What will ~sprint~ output? - 1086
*** TODO Will printing this expression result in bottom? - 1087
*** TODO Make the expression bottom - 1087

** TODO 27.15 Follow-up resources - 1087

* TODO 28 Basic Libraries - 1089
** TODO 28.1 Basic libraries and data structures - 1090
** TODO 28.2 Benchmarking with Criterion - 1090
*** TODO More on ~whnf~ and ~nf~ - 1096
*** TODO Making the case for ~nf~ - 1098

** TODO 28.3 Profiling your programs - 1101
*** TODO Profiling time usage - 1101
*** TODO Profiling heap usage - 1103

** TODO 28.4 Constant applicative forms - 1104
** TODO 28.5 ~Map~ - 1107
*** TODO What's something that's faster with ~Map~? - 1108
*** TODO What's slower with ~Map~? - 1109

** TODO 28.6 ~Set~ - 1109
*** TODO Exercise: Benchmark Practice - 1111

** TODO 28.7 Sequence - 1111
*** TODO What's faster with Sequence? - 1112
*** TODO What's slower with Sequence? - 1113

** TODO 28.8 Vector - 1113
*** TODO When does one want a ~Vector~ in Haskell? - 1114
*** TODO What's this about slicing? - 1115
*** TODO Updating vectors - 1116
*** TODO Mutable Vectors - 1118
*** TODO A sidebar on the ST Monad - 1120
*** TODO Exercises: ~Vector~ - 1122

** TODO 28.9 String types - 1122
*** TODO String - 1123
*** TODO Text - 1123
*** TODO Don't trust your gut, measure - 1123
*** TODO ~ByteString~ - 1125
**** TODO ~ByteString~ examples - 1125
**** TODO ~ByteString~ traps - 1126

*** TODO When would I use ~ByteString~ instead of ~Text~ for textual data? - 1130

** TODO 28.10 Chapter exercises - 1130
*** TODO Difference list - 1130
    1. 
    2. 
    3. 
    4. 
    5. 
    6. 

*** TODO A simple queue - 1132

** TODO 28.11 Follow-up resources - 1133

* TODO 29 ~IO~ - 1135
** TODO 29.1 ~IO~ - 1136
** TODO 29.2 Where ~IO~ explanations go astray - 1137
*** TODO Burn the State to the ground! - 1137

** TODO 29.3 The reason we need this type - 1138
*** TODO What? - 1139
*** TODO Order and chaos - 1139

** TODO 29.4 Sharing - 1139
*** TODO The time has come - 1140
*** TODO Another example - 1141
*** TODO The code! It doesn't work! - 1142

** TODO 29.5 ~IO~ doesn't disable sharing for everything - 1144
** TODO 29.6 Purity is losing meaning - 1145
*** TODO Semantically, pedantically accurate - 1145
*** TODO Referential transparency - 1146

** TODO 29.7 IO's Functor, Applicative, and Monad - 1147
*** TODO The ~IO~ Functor - 1147
*** TODO Applicative and ~IO~ - 1148
*** TODO Monad and ~IO~ - 1148
*** TODO Monadic associativity - 1150

** TODO 29.8 Well, then, how do we ~MVar~? - 1151
** TODO 29.9 Chapter Exercises - 1152
*** TODO File I/O with Vigenère - 1152
*** TODO Add timeouts to your utility - 1153
*** TODO Config directories - 1153

** TODO 29.10 Follow-up resources - 1153

* TODO 30 When Things Go Wrong - 1155
** DONE 30.1 Exceptions - 1156 - =PARTIAL=
   CLOSED: [2018-09-06 Thu 03:37]
   - TODO NOTE

   - In this chapter, we will:
     + examine the ~Exception~ /type class/ and /methods/;
     + dip our toes into /existential quantification/; =TODO= =???=
     + discuss _WAYS of handling exceptions_.

** TODO 30.2 The ~Exception~ class and methods - 1156
   - Background =TODO= =TODO=

   - The ~Exception~ /type class/ definition looks like this:
     #+BEGIN_SRC haskell
       class (Typeable e, Show e) =>
           Exception e where
         toException :: e -> SomeException
         fromException :: e -> SomeException -> Maybe e
         displayException :: e -> String
         -- Defined in 'GHC.Exception'
     #+END_SRC
     + ~Typeable~ is a /type class/ that defines /methods/ of *identifying types
       at runtime*.

       =TODO=
       We will talk about this more and explain why these constraints are
       necessary to our ~Exception~ /type class/ _soon_.

   - The list of types that have an ~Exception~ /instance/ is long:
     #+BEGIN_SRC haskell
       -- some instances elided
       instance Exception IOException
       instance Exception Deadlock
       instance Exception BlockedIndefinitelyOnSTM
       instance Exception BlockedIndefinitelyOnMVar
       instance Exception AsyncException
       instance Exception AssertionFailed
       instance Exception AllocationLimitExceeded
       instance Exception SomeException
       instance Exception ErrorCall
       instance Exception ArithException
     #+END_SRC

   - Two types that have ~Exception~ /instances/:
     #+BEGIN_SRC haskell
       -- 1 --
       data BlockedIndefinitelyOnMVar =
         BlockedIndefinitelyOnMVar
         -- Defined in ‘GHC.IO.Exception’

       -- 2 --
       data ArithException
         = Overflow
         | Underflow
         | LossOfPrecision
         | DivideByZero
         | Denormal
         | RatioZeroDenominator

       instance Exception ArithException
     #+END_SRC

*** DONE But there is something different going on here - 1158
    CLOSED: [2018-09-06 Thu 04:05]
    - We don't have much occasion to use the ~toException~ and ~fromException~
      function themselves. Instead, we use other functions that call them for
      us.

    - You may have noticed that the ~toException~ /method/ is quite similar to
      the /data constructor/ for ~SomeException~.

      ~SomeException~ (listed in a above entry) is also a type that is listed as
      having an /instance/ of the ~Exception~ /type class/, and now here it is in
      the ~Exception~ /methods/.

      =TODO= =TODO= =IMPORTANT=
      It seems a bit circular,
      but it turns out that ~SomeException~ is *ultimately the key to the way we
      _handle exceptions_.*

*** TODO A brief introduction to existential quantification - 1159
*** TODO So, wait, what? - 1160
*** TODO ~Typeable~ - 1162

** TODO 30.3 This machine kills programs - 1163
*** TODO Catch me if you can - 1165

** TODO 30.4 Want either? Try! - 1168
** TODO 30.5 The unbearable imprecision of trying - 1171
** TODO 30.6 Why ~throwIO~? - 1173
** TODO 30.7 Making our own exception types - 1175
*** TODO Adding context - 1176
*** TODO Catch one, catch all - 1177

** TODO 30.8 Surprising interaction with bottom - 1179
** TODO 30.9 Asynchronous exceptions - 1181
*** TODO Don't panic! - 1183

** TODO 30.10 Follow-up resources - 1183

* TODO 31 Final Project - 1185
** TODO 31.1 Final project - 1186
** TODO 31.2 fingerd - 1186
*** TODO Caveat for Windows users - 1186

** TODO 31.3 Exploring finger - 1187
*** TODO Project overview - 1188
*** TODO =fingerd.cabal= - 1188
*** TODO =src/Debug.hs= - 1189

** TODO 31.4 Slightly modernized fingerd - 1193
*** TODO Let your fingers do the walking - 1199

** TODO 31.5 Chapter Exercises - 1203
   1. 
   2. 
   3. 
   4. 
   5. 

* Tips
  - =Note=:
      _All_ of your _imports_ must occur
    + _after_ the module has been declared
      and
    + _before_ any expressions have been defined in your module.
  - /monomorphism/ =TODO= ??? chapter 5

  - How to read GHC(i) error messages???

  - Page 73 (v0.12.0) 
    1. Define values at the top level of a module.
       If they are declared at the top level so that they are available
       throughout the module.

    2. We specify explicit types for top-level definitions.
       =GOOD HABIT=

  - Page 86 (v0.12.0)
    _UNLIKE in other languages_,
    datatypes in Haskell _by default_ do NOT delimit the operations that can be
    performed on that data.
    =FROM JIAN= Type Classes DO delimit the operations that can be performed on
    that data.

  - Check the types of a partial function, which you haven't defined:
    #+BEGIN_SRC haskell
      -- Prelude> let f :: a -> a -> a -> a; f = undefined
      -- Prelude> let x :: Char; x = undefined
      -- Prelude> :t f x
      -- f x :: Char -> Char -> Char
    #+END_SRC

  - Since ~Real~ CANNOT override the methods of ~Num~,
      this type class inheritance is ONLY additive and the ambiguity problems
    caused by multiple inheritance in some programming languages -- the
    so-called "deadly diamond of death" -- are avoided.

  - ~:browse ModuleName~ can show you a list of the type signatures of
    functions we loaded from the module =ModuleName=.

  - Define a product type with record syntax:
    #+BEGIN_SRC haskell
      data Person =
        Person { name :: String
               , age :: Int }
        deriving (Eq, Show)
    #+END_SRC

