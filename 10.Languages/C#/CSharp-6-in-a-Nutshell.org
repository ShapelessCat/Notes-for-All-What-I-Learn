#+TITLE: C# 6.0 in a Nutshell
#+SUBTITLE: The Definitive Reference
#+VERSION: 6th - Covers .NET 4.6 & the Roslyn Compiler
#+AUTHOR: Joseph Albahari & Ben Albahari
#+STARTUP: overview
#+STARTUP: entitiespretty

* Preface - xi
* DONE 1. Introducing C# and the .NET Framework - 1
  CLOSED: [2017-10-27 Fri 02:31]
  - C# is a /general-purpose/, /type-safe/, /object-oriented/ programming language.

  - The chief architect of the language since its first version is
    *Anders Hejlsberg* (creator of Turbo Pascal and architect of Delphi).

  - The C# language is platform-neutral,
    but it was written to work well with the Microsoft .NET Framework.

** DONE Object Orientation - 1
   CLOSED: [2017-10-26 Thu 20:05]
   - C#'s OO paradigm includes:
     + /encapsulation/
     + /inheritance/
     + /polymorphism/

   - The distinctive features of C# from an object-oriented perspective are:
     + Unified type system :: all types ultimately share a common base type.
          =From Jian= I don't think so.

     + Classes and interfaces :: ...

     + Properties, methods, and events ::
          In the pure oo paradigm, all functions are /methods/ (Smalltalk).

          In C#, /methods/ are ONLY one kind of /function member/, which also
          includes /properties/ and /events/.

       * properties :: function member/ that encapsulate a piece of an object's
                       state, such as a button's color or a label's text.

       * events :: /function members/ that simplify acting on object state
                   changes.

   - C# also borrows from the /functional programming paradigm/. Specifically:
     + Functions can be treated as values :: Use /delegates/

     + C# supports patterns for purity :: C# has key features to help with
          functional programming patterns:
       * anonymous function
       * closure
       * the ability to perform list or reactive programming via /query
         expressions/. =TODO=
       * (C# 6.0) readonly auto-properties to help with writing immutable types.
         =TODO=

** DONE Type Safety - 2
   CLOSED: [2017-10-26 Thu 19:51]
   - C# is primarily a /type-safe/ language.

   - type-safe :: instances of types can interact ONLY through protocols they
                  define, thereby ensuring each type's internal consistency.
                  =TODO= =???=

   - More specifically,
     + C# supports /static typing/, meaning that the language enforces /type
       safety/ at _compile time_.

     + This is in addition to /type safety/ being enforced at _runtime_.

   - _NOTE_:
     C# also allows parts of your code to be dynamically typed via the ~dynamic~
     keyword (introduced in C# 4.0).

     However, C# remains a PREDOMINANTLY /statically typed language/.

   - C# is also a /strongly typed language/.

   - 

** DONE Memory Management - 3
   CLOSED: [2017-10-26 Thu 19:22]
   - C# use CLR's garbage collector.

   - C# does NOT eliminate pointers, but they are only permited in the ~unsafe~
     block.

** DONE Platform Support - 3
   CLOSED: [2017-10-26 Thu 20:06]
** DONE C#'s Relationship with the CLR - 3
   CLOSED: [2017-10-26 Thu 20:09]
   C# is technically independent of the CLR.

   C# depends on a /runtime/ equipped with a host of features such as automatic
   memory management and exception handling. CLR can be this runtime.

   - The design of C# CLOSELY maps to the design of Microsoft's Common Language
     Runtime (CLR), which provides these _runtime features_ .

   - Furthermore, the C# type system maps closely to the CLR type system (e.g.,
     both share the same definitions for predefined types).

** DONE The CLR and .NET Framework - 3
   CLOSED: [2017-10-26 Thu 20:26]
   - Figure 1-1. Topics covered in this book and the chapters in which they are
     found. Topics not covered are shown outside the large circle.

   - The CLR is the runtime for executing /managed code/.

   - C# is one of several /managed languages/ that get compiled into /managed
     code/.

   - /Managed code/ is packaged into an /assembly/, in the form of
     + either an executable file (an .exe)
       or
     + a library (a .dll),

     along with type information, or metadata.

   - /Managed code/ is represented in /intermediate language (IL)/.

   - When the CLR loads an /assembly/, it converts the /IL/ into the /native
     code/ of the machine, such as x86.

     This conversion is done by the CLR's JIT (just-in-time) compiler.

   - An /assembly/ retains almost all of the original source language constructs,
     which makes it easy to inspect and even generate code dynamically.
     =TODO=

   - _NOTE_:
     You can examine and decompile the contents of an IL assembly with tools
     such as ILSpy, dotPeek (JetBrains) or Reflector (Red Gate).

   - When writing Windows Store apps, you also now have the option of generating
     native code directly (*.NET Native*). This improves
     + startup performance
     + memory usage (which is particularly beneficial on mobile devices)
     + runtime performance through /static linking/ and _other optimizations_.
     =TODO= =DETAILS=

   - .NET Framework :: =TODO=

** TODO C# and Windows Runtime - 5
   - C# also interoperates with /Windows Runtime (WinRT)/ libraries.

   - WinRT :: an execution interface and runtime environment for accessing
              libraries in a language-neutral and object-oriented fashion.

              It ships with Windows 8 and newer and is (in part) an enhanced
              version of /Microsoft's Component Object Model/ or /COM/ (see
              Chapter 25). =TODO=

   - !! =TODO=

   - 

** DONE What's New in C# 6.0
   CLOSED: [2017-10-14 Sat 13:56]
   - New compiler "Roslyn" that is completely rewritten in C# itself.
     =TODO= =???= =Details=
     the new compiler exposes the entire compilation pipeline via libraries,
     allowing you to perform code analysis on arbitrary source code (see Chapter
     27).

   - /null-conditional ("Elvis")/ operator ::
        =TODO= (see “Null Operators” on page 55, Chapter 2)
        #+BEGIN_SRC csharp
          System.Text.StringBuilder sb = null;
          string result = sb?.ToString();  // result is null
        #+END_SRC

   - Expression-bodied functions :: allow methods, properties, operators, and
        indexers that comprise a single expression to be written more tersely, in
        the style of a lambda expression:
        #+BEGIN_SRC csharp
          public int TimesTwo (int x) => x * 2;
          public string SomeProperty => "Property value";
        #+END_SRC

        =TODO= (see “Methods” on page 74, Chapter 3)

   - Property initializers :: assign an initial value to an automatic property.
     =TODO=
     ~public DateTime Created { get; set; } = DateTime.Now;~
     Initialized properties can also be _read-only_:
     ~public DateTime Created { get; } = DateTime.Now;~

     =TODO= =???=
     Read-only properties can also be set in the constructor, making it easier to
     create immutable (read-only) types.

   - Index initializers :: allow single-step initialization of any type that
        exposes an indexer.

        =TODO= Chapter 4

        #+BEGIN_SRC csharp
          new Dictionary<int, string>()
          {
              [3] = "three",
              [10] = "ten"
          }
        #+END_SRC

   - String interpolation ::
     =DONE= (see “String Type” on page 36, Chapter 2)
     ~string s = $"It is {DateTime.Now.DayOfWeek} today";~

   - Exception filters :: apply a condition to a /catch block/.
        =TODO=
        (see “try Statements and Exceptions” on page 148, Chapter 4) let you apply a condition to a catch block:

        #+BEGIN_SRC csharp
          try
          {
              new WebClient().DownloadString("http://asef");
          }
          catch (WebException ex) when (ex.Status == WebExceptionStatus.Timeout)
          {
              // ...
          }
        #+END_SRC

   - ~using static~ :: import all the static members of a type.

     =TODO= (see “Namespaces” on page 65, Chapter 2) 

   - ~nameof~ :: returns the name of
     + a variable
     + a type
     + other symbols

     as a string. =???= This avoids breaking code when you rename a symbol in
     Visual Studio.

     =TODO= Chapter 3

     #+BEGIN_SRC csharp
       int capacity = 123;
       string x = nameof (capacity); // x is "capacity"
       string y = nameof (Uri.Host); // y is "Host"
     #+END_SRC

   - Be allowed to ~await~ inside ~catch~ and ~finally~ blocks.

** DONE What Was New in C# 5.0
   CLOSED: [2017-10-14 Sat 13:36]
   - A big new feature was support for /asynchronous functions/ via _TWO_ new
     /keywords/, ~async~ and ~await~.

   - /Asynchronous functions/ enable /asynchronous continuations/, which make it
     easier to write /responsive/ and /thread-safe/, /rich-client applications/.

     They also make it easy to write highly /concurrent/ and
     /efficient I/O-bound/ applications that do _NOT_ tie up a thread resource
     per operation.

   - =TODO= We cover /asynchronous functions/ in detail in Chapter 14.

** DONE What Was New in C# 4.0
   CLOSED: [2017-10-26 Thu 20:30]
   - The features new to C# 4.0 were:
     + Dynamic binding =TODO= Chapter 4 and 20

     + Optional parameters and named arguments

     + Type variance with generic interfaces and delegates:
       relaxed in C# 4.0 (Chapter 3 and 4) and /convariant/ or /contravariant/
       can be marked.

     + COM interoperability improvements
       =TODO=

** DONE What Was New in C# 3.0
   CLOSED: [2017-10-26 Thu 20:30]
   - LINQ (Language INtegrated Query) =???=

   - Implicitly typed local variables
     =TODO= (var keyword, Chapter 2)

   - Object initializers
     =TODO= (Chapter 3)

   - Lambda expressions
     =TODO= (Chapter 4)

   - Extension methods
     =TODO= (Chapter 4)

   - Query expressions
     =TODO= (Chapter 8)

   - Expression trees
     =TODO= (Chapter 8)

   - C# 3.0 also added automatic properties and partial methods.

   - Automatic properties
     =TODO= (Chapter 3)

* DONE 2. C# Language Basics - 11
  CLOSED: [2017-10-16 Mon 03:52]
** DONE A First C# Program - 11
   CLOSED: [2017-10-12 Thu 20:41]
   #+BEGIN_SRC csharp
     using System;

     class Test
     {
         static void Main()
         {
             Console.WriteLine(FeetToInches(30));  // 360
             Console.WriteLine(FeetToInches(100));  // 1200
         }

         static int FeetToInches(int feet)
         {
             int inches = feet * 12;
             return inches;
         }
     }
   #+END_SRC

   - The ~Main~ method signal the default entry point of execution.

   - The ~Main~ method may _optionally_ return an integer (rather than ~void~)
     in order to return a value to the execution environment (where a nonzero
     value typically indicates an error).

   - The ~Main~ method can also _optionally_ accept _an array of strings_ as a
     parameter (that will be populated with any arguments passed to the
     executable). For example: ~static int Main(string[] args) {...}~

   - /Methods/ are one of several kinds of functions in C#.

     Another kind of function we used in our example program was the ~*~
     operator, which performs multiplication.

     There are also
     + /constructors/
     + /properties/
     + /events/
     + /indexers/
     + /finalizers/

   - A /class/ groups function members and data members to form an object-oriented
     building block.

   - At the outermost level of a program, types are organized into /namespaces/.

   - The ~using~ directive was used to make the ~System~ /namespace/ available to
     our application, to use the ~Console~ class.

   - We could define all our classes within the ~TestPro~ grams namespace, as
     follows:
     #+BEGIN_SRC csharp
       using System;

       namespace TestPrograms
       {
           class Test {...}
           class Test2 {...}
       }
     #+END_SRC

   - The .NET Framework is organized into nested namespaces.

*** DONE Compilation - 13
    CLOSED: [2017-10-12 Thu 20:40]
    - C# source code files use the ~.cs~ extension.

    - An assembly can be either an /application/ or a /library/.

      + A normal console or Windows application has a ~Main~ method and is an
        =.exe= file.

      + A library is a =.dll= and is equivalent to an ~.exe~ without an entry
        point.

    - The purpose is to be called upon (referenced) by an application or by other
      libraries.
        _The .NET Framework is a set of libraries._

    - The name of the C# compiler is =csc.exe=.

    - To produce an application named =MyFirstProgram.exe=.
      Manually compile ~csc MyFirstProgram.cs~

    - To produce a library (=.dll=):
      ~csc /target:library MyFirstProgram.cs~

    - =TODO= We explain assemblies in detail in Chapter 18.

** DONE Syntax - 14
   CLOSED: [2017-10-12 Thu 20:40]
*** DONE Identifiers and Keywords - 14
    CLOSED: [2017-10-12 Thu 20:32]
    - An identifier must be a whole word =???=, essentially made up of Unicode
      characters _starting with a letter or underscore_.
      =TODO=

    - Convention:
      + camel case: parameters, local variables, and private fields
      + Pascal case: all other identifiers

    - Here is the full list of C# reserved keywords:
      *Page 15* =TO LONG=

**** DONE Avoiding conflicts - 15
     CLOSED: [2017-10-12 Thu 20:32]
     If you really want to use an identifier that clashes with a reserved
     keyword, you can do so by qualifying it with the ~@~ prefix.
     #+BEGIN_SRC csharp
       class class {...}  // Illegal
       class @class {...}  // Legal
     #+END_SRC
     ~@~ is NOT a part of this identifier itself.

**** DONE Contextual keywords - 15
     CLOSED: [2017-10-12 Thu 20:32]
     Some keywords are /contextual/, meaning they can also be used as
     identifiers -- without an ~@~ symbol. These are:

     | ~add~        | ~dynamic~ | ~in~     | ~orderby~ | ~var~   |
     | ~ascending~  | ~equals~  | ~into~   | ~partial~ | ~when~  |
     | ~async~      | ~from~    | ~join~   | ~remove~  | ~where~ |
     | ~await~      | ~get~     | ~let~    | ~select~  | ~yield~ |
     | ~by~         | ~global~  | ~nameof~ | ~set~     |         |
     | ~descending~ | ~group~   | ~on~     | ~value~   |         |

     With /contextual keywords/, ambiguity CANNOT arise within the context in
     which they are used.










*** DONE Literals, Punctuators, and Operators - 16
    CLOSED: [2017-10-12 Thu 20:38]
    - literals :: primitive pieces of data lexically embedded into the program.

    - punctuators :: symbols that help demarcate the structure of the program.
                     For example: ~{ }~ and ~;~

    - statement block :: statements grouped by braces.
         Exceptions exists.

    - _MOST_ operators in C# are denoted with a symbol.

*** DONE Comments - 16
    CLOSED: [2017-10-12 Thu 20:40]
    - Line commenter: ~//~

    - Block commenter: the ~/*~ and ~*/~ pair

    - =TODO=
      Comments may embed XML documentation tags, explained in "XML Documentation"
      on page 193 in Chapter 4.

** DONE Type Basics - 17
   CLOSED: [2017-10-14 Sat 04:43]
*** DONE Predefined Type Examples - 17
    CLOSED: [2017-10-12 Thu 23:04]
    ~int~, ~string~, ~bool~, etc.

*** DONE Custom Type Examples - 18
    CLOSED: [2017-10-14 Sat 03:13]
    #+BEGIN_SRC csharp
      using System;

      public class UnitConverter
      {
          int ratio;                                                    // Field
          public UnitConverter (int unitRatio) { ratio = unitRatio; }   // Constructor
          public int Convert (int unit) { return unit * ratio; }        // Method
      }

      class Test
      {
          static void Main()
          {
              UnitConverter feetToInchesConverter = new UnitConverter (12);
              UnitConverter feetToInchesConverter = new UnitConverter (5280);

              Console.WriteLine (feetToInchesConverter.Convert(30));   // 360
              Console.WriteLine (feetToInchesConverter.Convert(100));  // 1200
              Console.WriteLine (feetToInchesConverter.Convert(milesToFeetConverter.Convert(1)));  // 63360
          }
      }
    #+END_SRC

**** DONE Members of a type - 18
     CLOSED: [2017-10-12 Thu 23:35]
     A /type/ contains
     - /data members/ -- the =Field=.
     - /function members/ -- the =Constructor= and the =Method=.

**** DONE Symmetry of predefined types and custom types - 18
     CLOSED: [2017-10-12 Thu 23:43]
     A beautiful aspect of C# is that predefined types and custom types have few
     differences.

     =TODO= =???= Still detectable or NOT???

**** DONE Constructors and instantiation - 19
     CLOSED: [2017-10-14 Sat 02:03]
     - Data is created by /instantiating/ a type.

     - /Predefined types/ can be instantiated simply by using a literal such as
       ~12~ or ~"Hello world"~.

**** DONE Instance versus static members - 19
     CLOSED: [2017-10-14 Sat 03:11]
     - ~static~ :: /data members/ and /function members/ that don't operate on
                   the instance of the type, but rather on the type itself.

     - static class :: all its members are /static/.
                       
     - For example, the ~Console~ class is actually a /static class/, and you
       _NEVER_ actually create instances of a ~Console~ -- one console is shared
       across the whole application.

**** DONE The ~public~ keyword - 20
     CLOSED: [2017-10-14 Sat 03:13]
     If a /member/ is not makred as ~public~, but it is ~private~.

*** DONE Conventions - 20
    CLOSED: [2017-10-14 Sat 03:31]
    - Conversions between compitable types can be either /implicit/ or
      /explicit/:
      + /implicit conversions/ happen automatically
        * Rules must be fully satisfied when /implicit conversions/ can happen:
          - The compiler can guarantee they will always succeed.
          - No information is lost in conversion. 1

          footnote 1: A minor caveat is that very LARGE ~long~ values lose some
          precision when converted to ~double~.

      + /explicit conversions/ require a /cast/.
        * Rules that one of them must be satisfied when /explicit conversions/
          can happen:
          - The compiler cannot guarantee they will always succeed.
          - Information may be lost during conversion.

      + If the compiler can determine that a conversion will always fail, both
        kinds of conversion are prohibited.

        =TODO=
        Conversions that involve generics can also fail in certain conditions --
        see “Type Parameters and Conversions” on page 121 in Chapter 3.

    - The /numeric conversions/ that we just saw are built into the language.

      =TODO=
      + C# also supports /reference conversions/ and /boxing conversions/ (see
        Chapter 3) as well as /custom conversions/ (see “Operator Overloading” on
        page 168 in Chapter 4).

      + The compiler doesn't enforce the aforementioned rules with /custom
        conversions/, so it's possible for badly designed types to behave
        otherwise.

*** DONE Value Types Versus Reference Types - 21
    CLOSED: [2017-10-14 Sat 04:29]
    - All C# types fall into the following categories:
      + Value types ::
        * Most /built-in types/
          (specifically, all /numeric types/, the /char type/, and the /bool type/)
        * custom ~struct~
        * ~enum~ types

      + Reference types ::
        * all classes
        * array
        * delegate =TODO=
        * interface types (include the predefined ~string~ type) =???=

      + Generic type parameters :: =TODO= =???=

      + Pointer types :: =TODO= =???=

    - Small topics:
      + In this section, we'll describe /value types/ and /reference types/.

      + We'll cover /generic type/ parameters in “Generics” on page 114 in Chapter 3.
        =TODO=

      + /pointer types/ in “Unsafe Code and Pointers” on page 187 in Chapter 4.
        =TODO=

    - The _fundamental difference_ between /value types/ and /reference types/ is
      _how they are handled in memory_.

**** DONE Value types - 22
     CLOSED: [2017-10-14 Sat 03:57]
     - The assignment of a /value type instance/ _ALWAYS copies_ the instance.

     - Figure 2-1. A value-type instance in memory

     - Figure 2-2. Assignment copies a value-type instance

**** DONE Reference types - 22
     CLOSED: [2017-10-14 Sat 04:04]
     - A /reference type/ has two parts:
       + /object/
       + /reference/ to this /object/

     - Figure 2-3. A reference-type instance in memory

     - Assigning a reference-type variable _copies_ the /reference/, _NOT_ the
       /object instance/.

     - This allows multiple variables to refer to the same object.

       This is not ordinarily possible with /value types/.

     - Figure 2-4. Assignment copies a reference

**** DONE ~Null~ - 24
     CLOSED: [2017-10-14 Sat 04:12]
     =TODO=
     C# also has a construct called /nullable types/ for representing /value-type
     nulls/ (see “Nullable Types” on page 162 in Chapter 4).

**** DONE Storage overhead - 24
     CLOSED: [2017-10-14 Sat 04:19]
     - Value-type instances occupy precisely the memory required to store
       their fields. In this example, Point takes _eight bytes_ of memory:
       #+BEGIN_SRC csharp
         struct Point
         {
             int x;  // 4 bytes
             int y;  // 4 bytes
         }
       #+END_SRC

     - GENERAL NOTE:
       Technically, the CLR positions fields within the type at an address that's
       a _multiple of the fields' size_ (_UP TO a maximum of eight bytes_).
         Thus, the following actually consumes 16 bytes of memory (with the seven
       bytes following the first field "wasted"): ~struct A { byte b; long l; }~

       You can override this behavior with the ~StructLayout~ attribute (
       =TODO= see “Mapping a Struct to Unmanaged Memory” on page 1011 in
       Chapter 25).

     - /Reference types/ require separate allocations of memory for their
       + /reference/
       + /object/

     - The object consumes
       + as many bytes as its fields
       + additional administrative overhead -- the precise overhead is intrinsi-
         cally private to the implementation of the .NET runtime,
         _but at minimum, the overhead is EIGHT bytes_, used to store
         * a key to the object's type
         * temporary information such as its lock state for multithreading and a
           flag to indicate whether it has been fixed from movement by the
           garbage collector. =TODO= =???=

     - Each /reference/ to an object requires an extra four or eight bytes (the
       width of the addresses), depending on whether the .NET runtime is running
       on a 32- or 64-bit platform.

*** DONE Predefined Type Taxonomy - 25
    CLOSED: [2017-10-14 Sat 04:43]
    - The predefined types in C# are:
      + /Value types/
        * Numeric
          - Signed integer (~sbyte~, ~short~, ~int~, ~long~) =TODO=
          - Unsigned integer (~byte~, ~ushort~, ~uint~, ~ulong~) =TODO=
          - Real number (~float~, ~double~, ~decimal~) =TODO=
        * Logical (~bool~)
        * Character (~char~)

      + /Reference types/
        * String (~string~)
        * Object (~object~)

    - Predefined types in C# alias Framework types in the ~System~ namespace.
      There is _only a syntactic difference_ between these two statements:
      #+BEGIN_SRC csharp
        int i = 5;
        System.Int32 i = 5;
      #+END_SRC

    - The set of predefined value types, _excluding_ ~decimal~, are known as
      /primitive types/ in the CLR.

      /Primitive types/ are so called because they are supported directly via
      instructions in compiled code, and this usually translates to direct
      support on the underlying processor. For example:
      #+BEGIN_SRC csharp
        // Underlying hexadecimal representation
        int i = 7; // 0x7
        bool b = true; // 0x1
        char c = 'A'; // 0x41
        float f = 0.5f; // uses IEEE floating-point encoding
      #+END_SRC

      =TODO=
      The ~System.IntPtr~ and ~System.UIntPtr~ types are also primitive (see Chapter 25).

** DONE Numeric Types - 26
   CLOSED: [2017-10-14 Sat 07:47]
   - Table 2-1. Predefined numeric types in C#
     =IMPORTANT= =IMPORTANT= =IMPORTANT= 
     Suffix:
     + ~L~ for ~long~
     + ~U~ for ~uint~
     + ~UL~ for ~ulong~
     + ~F~ for ~float~
     + ~D~ for ~double~
     + ~M~ for ~decimal~

   - ~decimal~ is used for _financial calculations_.

*** DONE Numeric Literals - 26
    CLOSED: [2017-10-14 Sat 05:05]
    - /Integral literals/ can use decimal or hexadecimal (with ~0x~ prefix)
      notation.

    - /Real literals/ can use decimal and/or exponential notation.

**** DONE Numeric literals type inference - 27
     CLOSED: [2017-10-14 Sat 04:59]
     Rules:
     + if a literal contains a decimal point or the exponential symbol (~E~),
       it's a ~double~.

     + Otherwise, fit the first type in the list:
       * ~int~
       * ~unit~
       * ~long~
       * ~ulong~

     + Try ~GetType()~ method.

**** DONE Numeric suffixes - 27
     CLOSED: [2017-10-14 Sat 05:05]
     - /Numeric suffixes/ can be lowercase or uppercase.
       =From the book Java Puzzles= NEVER use lowercase suffixes.

     - You CANNOT do ~float f = 4.5~ in C#. You must use ~F~ suffixes.
       ~double~ has no implicit conversion to ~float~ according to the rules
       mentioned.

*** DONE Numeric Conversion - 28
    CLOSED: [2017-10-14 Sat 06:52]
**** DONE Integral to integral conversions - 28
     CLOSED: [2017-10-14 Sat 06:50]
     - implicit conversion: shorter integral types -> longer integral types

     - explicit conversion: shorter integral types <- longer integral types

**** DONE Floating-point to floating-point conversions - 28
     CLOSED: [2017-10-14 Sat 06:48]
     - implicit conversion: ~float~ -> ~double~

     - explicit conversion: ~float~ <- ~double~

**** DONE Floating-point to Integral conversions - 28
     CLOSED: [2017-10-14 Sat 06:46]
     - implicit conversion: All integral types -> floating-point types
     - explicit conversion: All integral types <- floating-point types

**** DONE Decimal conversions - 29
     CLOSED: [2017-10-14 Sat 06:52]
     - implicit: all integral types -> the decimal types,
       since a decimal can represent every possible C# integral value.

     - explicit: all other numeric conversions to and from a decimal type.
       =TODO= =???=

*** DONE Arithmetic Operators - 29
    CLOSED: [2017-10-14 Sat 06:54]
    - ~+~ :: Addition
    - ~-~ :: Subtraction
    - ~*~ :: Multiplication
    - ~/~ :: Division
    - ~%~ :: Remainder after division

*** DONE Increment and Decrement Operators - 29
    CLOSED: [2017-10-14 Sat 06:54]
    ~++~ and ~--~ like in C.

*** DONE Specialized Integral Operations - 29
    CLOSED: [2017-10-14 Sat 07:25]
**** DONE Integral division - 29
     CLOSED: [2017-10-14 Sat 06:58]
     Can have a runtime error (a ~DivideByZeroException~).

**** DONE Integral overflow - 29
     CLOSED: [2017-10-14 Sat 06:59]
     Check bound values like ~int.MinValue~ or ~int.MaxValue~
     #+BEGIN_SRC csharp
       int a = int.MinValue;
       a--;
       Console.WriteLine (a == int.MaxValue); // True
     #+END_SRC
     
**** DONE Integral arithmetic overflow check operators - 30
     CLOSED: [2017-10-14 Sat 07:22]
     - The ~checked~ operator can take
       + a single integral expression
       + a single integral statement
       + an /integral expression block/
       + a /integral statement block/

       and issue an ~OverflowException~ at runtime if overflow happen.

     - The ~checked~ operator affects expressions with the
       + ~++~
       + ~−−~
       + ~+~
       + ~−~ (binary and unary)
       + ~*~
       + ~/~
       + /explicit conversion/ operators

       between /integral types/.

     - Note:
       The ~checked~ operator has
       + _NO_ effect on the ~double~ and ~float~ types
         (which overflow to special "infinite" values, as we'll see soon)

       + _NO_ effect on the ~decimal~ type (which is ALWAYS checked).

     - ~checked~ can be used around either an /expression block/ or a /statement
       block/.
       #+BEGIN_SRC csharp
         int a = 1000000;
         int b = 1000000;

         int c = checked (a * b);

         checked
         {
             // ...
             c = a * b;
             // ...
         }
       #+END_SRC

     - You can make _arithmetic overflow checking_ the default for all
       expressions in a program by
       + compiling with the ~/checked+~ command-line switch.

       + in Visual Studio, go to *Advanced Build Settings* to find the
         ~/checked+~ option.

     - You can disable the ~/checked+~ locally for some specific expressions or
       statements by using the ~unchecked~ operator.
       #+BEGIN_SRC csharp
         int x = int.MaxValue;
         int y = unchecked (x + 1);
         unchecked { int z = x + 1; }
       #+END_SRC

**** DONE Overflow checking for constant expressions - 30
     CLOSED: [2017-10-14 Sat 07:23]
     Regardless of the ~/checked~ compiler switch, expressions evaluated _at
     compile time_ are _ALWAYS_ overflow-checked -- unless you apply the
     ~unchecked~ operator:
     #+BEGIN_SRC csharp
       int x = int.MaxValue + 1;               // Compile-time error
       int y = unchecked (int.MaxValue + 1);   // No errors
     #+END_SRC

**** DONE Bitwise operators - 30
     CLOSED: [2017-10-14 Sat 07:25]
     Like C/C++, NOT like Java
     - ~~~
     - ~&~
     - ~|~
     - ~^~
     - ~<<~
     - ~>>~

*** DONE 8-and 16-Bit Integrals - 31
    CLOSED: [2017-10-14 Sat 07:29]
    ~byte~, ~sbyte~, ~short~, and ~ushort~ _LACK_ their own arithmetic operators,
    so C# implicitly converts them to larger types as required.
      Assign the calculation result back to a small integral type may cause a
    compile-time error:
    #+BEGIN_SRC csharp
      short x = 1, y = 1;
      short z = x + y;     // Compile-time error

      short z = (short)(x + y);  // OK
    #+END_SRC

*** DONE Special Float and Double Values - 31
    CLOSED: [2017-10-14 Sat 07:42]
    | Special value | Double constant           | Float constant           |
    |---------------+---------------------------+--------------------------|
    | NaN           | ~double.NaN~              | ~float.NaN~              |
    | +∞            | ~double.PositiveInfinity~ | ~float.PositiveInfinity~ |
    | −∞            | ~double.NegativeInfinity~ | ~float.NegativeInfinity~ |
    | −0            | ~−0.0~                    | ~−0.0f~                  |

    =From Jian=
    Usage of -0 =TODO= =???=

    #+BEGIN_SRC csharp
      Console.WriteLine ( 1.0 / 0.0); // Infinity
      Console.WriteLine (−1.0 / 0.0); // -Infinity
      Console.WriteLine ( 1.0 / −0.0); // -Infinity
      Console.WriteLine (−1.0 / −0.0); // Infinity

      Console.WriteLine ( 0.0 / 0.0); // NaN
      Console.WriteLine ((1.0 / 0.0) − (1.0 / 0.0)); // NaN

      // NaN check
      Console.WriteLine (0.0 / 0.0 == double.NaN); // False
      Console.WriteLine (double.IsNaN (0.0 / 0.0)); // True
      Console.WriteLine (object.Equals (0.0 / 0.0, double.NaN)); // True
    #+END_SRC

    - _Note_: =TODO= =???=
      ~NaN~'s are sometimes useful in representing special values:
      + In WPF, ~double.NaN~ represents a measurement whose value is “Automatic”. =???=
      + Another way to represent such a value is with a /nullable type/ (Chapter 4); =???=
      + another is with a custom struct that wraps a numeric type and adds an additional field (Chapter 3). =???=

    - ~float~ and ~double~ follow the specification of the IEEE 754 format types,
      supported natively by almost all processors. You can find detailed
      information on the behavior of these types at http://www.ieee.org.

*** DONE ~double~ Versus ~decimal~ - 32 =Re-Read=
    CLOSED: [2017-10-14 Sat 07:44]
    =TODO= a TABLE

*** DONE Real-Number Rounding Errors - 32 =Re-Read=
    CLOSED: [2017-10-14 Sat 07:46]

** DONE Boolean Type and Operators - 33
   CLOSED: [2017-10-14 Sat 09:38]
   - The ~bool~ type or its alias the ~System.Boolean~ type.

   - Their values: ~true~ and ~false~
     Only one bit is required for each of thse values, but one byte (the
     minimum chuck that the runtime and processor can efficiently work with) is
     used.

   - To _avoid space inefficiency_ in the case of arrays, the Framework provides
     a ~BitArray~ class in the ~System.Collections~ namespace that is designed to
     use just one bit per Boolean value.
     =TODO= =???= =Use=

*** DONE Bool Conversions - 33
    CLOSED: [2017-10-14 Sat 09:21]
    NO casting on either direction to either numeric types.

*** DONE Equality and Comparison Operators - 33
    CLOSED: [2017-10-14 Sat 09:29]
    - footnote 3: It's possible to overload operators ~==~ and ~!=~ (Chapter 4)
      such that they return a non-bool type, but this is almost never done in
      practice.

    - /Value types/ typically have a very simple notion of _equality_.

    - For /reference types/, _equality_, by default, is based on _reference_, as
      opposed to the _actual value of the underlying object_ (more on this in
      Chapter 6):

    - You should always caution with real numbers comparison.

    - The comparison operators also work on ~enum~ type members, _by comparing
      their underlying integral values_.
      =TODO= We describe this in “Enums” on page 109 in Chapter 3.

    - =TODO=
      We explain the equality and comparison operators in greater detail in
      “Operator Overloading” on page 168 in Chapter 4, and in “Equality
      Comparison” on page 267 and “Order Comparison” on page 278 in Chapter 6.

*** DONE Conditional Operators - 34
    CLOSED: [2017-10-14 Sat 09:38]
    - Conditional operators:
      + ~!~
      + short-circuit: ~&&~, ~||~
      + non-short-circuit: ~&~, ~|~

    - _Note_:
      Unlike in C and C++, the ~&~ and ~|~ operators perform (nonshort-
      circuiting) Boolean comparisons when applied to bool expressions.

      The ~&~ and ~|~ operators perform bitwise operations ONLY when applied to
      numbers.

**** DONE Conditional Operator (ternary operator) - 35
     CLOSED: [2017-10-14 Sat 09:38]
     - ~?:~

     - =TODO=
       The conditional operator is particularly useful in LINQ queries (Chapter
       8).

** DONE Strings and Characters - 35
   CLOSED: [2017-10-14 Sat 10:16]
   - ~char~ type and its alias ~System.Char~ type.
     It represents a Unicode character and occupies 2 bytes.

   - Table 2-2. Escape sequence characters

   - The ~\u~ (or ~\x~) escape sequence lets you specify any Unicode character
     via its four-digit hexadecimal code.
     #+BEGIN_SRC csharp
       char copyrightSymbol = '\u00A9';
       char omegaSymbol     = '\u03A9';
       char newLine         = '\u000A';
     #+END_SRC

*** DONE Char Conversions - 36
    CLOSED: [2017-10-14 Sat 09:46]
    - implicit conversion:
      ~char~ -> numeric type (that can accomodate an unsigned short).

    - explicit conversion:
      ~char~ -> other numeric types.

*** DONE String Type - 37
    CLOSED: [2017-10-14 Sat 10:02]
    - C#'s ~string~ type (aliasing the ~System.String~ type,
      =TODO=
      covered in depth in Chapter 6)

    - It represents an _immutable_ sequence of /Unicode characters/.

    - ~string~ is a /reference type/.
      Its equality operators, however, follow value-type semantics.
      #+BEGIN_SRC csharp
        string a = "test";
        string b = "test";
        Console.Write (a == b);  // True
      #+END_SRC

    - verbatim string liters :: ~@~ prefixed string literals, it does NOT support
         escape sequences. It can span multiple lines.
         #+BEGIN_SRC csharp
           string a2 = @ "\\server\fileshare\helloworld.cs";

           string escaped = "First Line\r\nSecond Line";
           string verbatim = @"First Line
           Second Line";

           // True if your IDE uses CR-LF line separators:
           Console.WriteLien (escaped == verbatim);
         #+END_SRC

    - You can include the double-quote character in a /verbatim literal/ by writing
      it _TWICE_:
      ~string xml = @"<customer id=""123""></customer>";~

**** DONE String concatenation - 37
     CLOSED: [2017-10-14 Sat 10:06]
     - Use ~+~

     - When use ~+~ to concatenate strings with non-string values, ~ToString~ is
       called automatically.

     - Repeatedly use ~+~ is inefficient, and a better solution is to use the
       ~System.Text.StringBuilder~ type (described in Chapter 6). 
       =TODO=

**** DONE String interpolation (C# 6) - 37
     CLOSED: [2017-10-14 Sat 10:16]
     - A string preceded with the ~$~ character is called an /interpolated
       string/. /Interpolated strings/ can include expressions _inside braces_:
       #+BEGIN_SRC csharp
         int x = 4;
         Console.Write($"A square has {x} sides");  // Prints: A square has 4 sides
       #+END_SRC

     - =TODO= /format string/
       (format strings are described in “Formatting and parsing” on page 233 in
       Chapter 6):
       #+BEGIN_SRC csharp
         string s = $"255 in hex is {byte.MaxValue:X2}";  // X2 = 2-digit Hexadecimal
         // Evaluates to "255 in hex is FF"
       #+END_SRC

     - /Interpolated strings/
       _MUST_ complete on a SINGLE line, unless you also specify the /verbatim
       string operator/.

       Note that the ~$~ operator _MUST_ come _before_ ~@~:
       #+BEGIN_SRC csharp
         int x = 2;
         string s = $@"this spans {
         x} lines";
       #+END_SRC

     - To include a /brace literal/ in an /interpolated string/, repeat the
       desired brace character.

**** DONE String comparisons - 37
     CLOSED: [2017-10-14 Sat 10:06]
     ~string~ does NOT support ~<~ and ~>~.

     Must use the ~CompareTo~ method.
     =TODO= Chapter 6

** DONE Arrays - 38
   CLOSED: [2017-10-14 Sat 11:40]
   - The /elements/ in an array are always stored in a _contiguous block of
     memory_, providing highly efficient access.

   - The ~System.Collection~ namespace and subnamespaces provide higher-level
     data structures, such as /dynamically sized arrays/ and /dictionaries/.
     =TODO=

   - /array initialization/ syntax:
     ~char[] vowels = new char[] {'a', 'e', 'i', 'o', 'u'};~
     or
     ~char[] vowels = {'a', 'e', 'i', 'o', 'u'};~

   - All arrays inherit from the ~System.Array~ class, providing common services
     for all arrays.

   - =TODO= “The Array Class” on page 297 in Chapter 7.

*** DONE Default Element Initialization - 38
    CLOSED: [2017-10-14 Sat 10:33]
    Creating an array always preinitializes the elements with /default values/.

    The /default value/ for a type is the result of a _bitwise zeroing of
    memory_.

**** Value types versus reference types - 39

*** DONE Multidimensional Arrays - 39
    CLOSED: [2017-10-14 Sat 11:21]
    - /rectangular arrays/ represent an n-dimensional block of memory.

    - /jagged arrays/ are arrays of arrays.

**** DONE Rectangular arrays - 39
     CLOSED: [2017-10-14 Sat 11:14]
     - /Rectangular arrays/ are declared using commas to separate each dimension.
       ~int[,] matrix = new int[3,3];~

     - Use the ~GetLength(nthDimension)~ method to get the length of a given
       dimension.

     - Initialize a rectangular array:
       #+BEGIN_SRC csharp
         int[,] matrix = new int[,]
             {
                 {0,1,2},
                 {3,4,5},
                 {6,7,8}
             };
       #+END_SRC

**** DONE Jagged arrays - 40
     CLOSED: [2017-10-14 Sat 11:21]
     - /Jagged arrays/ are declared using successive square brackets to represent
       each dimension.
       ~int[][] matrix = new int[3][];~

     - _Note_:
       Interestingly, this is ~new int[3][]~ and not ~new int[][3]~.
       Eric Lippert has written an excellent article on why this is so:
       see http://albahari.com/jagged.

     - Each inner array of a /jagged arrays/ can be an _arbitrary length_.
       Each inner array is implicitly initialized to ~null~ rather than an empty
       array.
       Each inner array must be created manually:
       #+BEGIN_SRC csharp
         for (int i = 0; i < matrix.Length; i++)
         {
             matrix[i] = new int[3];
             for (int j = 0; j < matrix[i].Length; j++)
                 matrix[i][j] = i * 3 + j;
         }

         // OR

         int[][] matrix = new int[][]
             {
                 new int[] {0, 1, 2},
                 new int[] {3, 4, 5},
                 new int[] {6, 7, 8, 9}
             };
       #+END_SRC

*** DONE Simplified Array Initialization Expressions - 40
    CLOSED: [2017-10-14 Sat 11:35]
    There are _TWO_ ways to shorten array initialization expressions.
    - The first is to omit the new operator and type qualifications:
      #+BEGIN_SRC csharp
        char [] vowels = {'a', 'e', 'i', 'o', 'u'};

        int[,] rectangularMatrix =
            {
                {0, 1, 2},
                {3, 4, 5},
                [6, 7, 8]
            };

        int[][] jaggedMatrix =
            {
                new int[] {0, 1, 2},
                new int[] {3, 4, 5},
                new int[] {6, 7, 8}
            };
      #+END_SRC

    - The second approach is to use the ~var~ keyword, which tells the compiler
      to implicitly type a local variable:
      #+BEGIN_SRC csharp
        var i = 3; // i is implicitly of type int
        var s = "sausage"; // s is implicitly of type string

        // Therefore:
        var rectMatrix = new int[,] // rectMatrix is implicitly of type int[,]
            {
                {0,1,2},
                {3,4,5},
                {6,7,8}
            };

        var jaggedMat = new int[][] // jaggedMat is implicitly of type int[][]
            {
                new int[] {0,1,2},
                new int[] {3,4,5},
                new int[] {6,7,8}
            };
      #+END_SRC

      + Implicit typing can be taken one stage further with arrays: omit the type
        qualifier after the ~new~ keyword and have the compiler infter the array
        type: ~var vowels = new[] {'a', 'e', 'i', 'o', 'u'};~

        For this to work, the elements must all be _implicitly convertible_ to a
        single type (and at least one of the elements must be of that type, and
        there must be exactly one best type). For example:
        ~var x = new[] {1,10000000000};  // all convertible to long~

*** DONE Bounds Checking - 41
    CLOSED: [2017-10-14 Sat 11:38]
    - ~IndexOutOfRangeException~

    - _Note_:
      + the performance hit from bounds checking is minor
        JIT can optimize it.

      + In addition, C# provides “unsafe” code that can explicitly _bypass bounds
        checking_ (see “Unsafe Code and Pointers” on page 187 in Chapter 4).
        =TODO=

** DONE Variables and Parameters - 42
   CLOSED: [2017-10-14 Sat 13:28]
*** DONE The Stack and the Heap - 42
    CLOSED: [2017-10-14 Sat 12:01]
    Each has very DIFFERENT /lifetime semantics/.

**** DONE Stack - 42
     CLOSED: [2017-10-14 Sat 11:50]
     - /stack/ :: a block of memory for storing /local variables/ and
                  /parameters/. It logically grows and shrinks as a function is
                  entered and exited.

**** TODO Head - 42
     - heap :: a block of memory in which objects (i.e., reference-type
               instances) reside.

     - You CANNOT explicitly delete objects in C#, as you can in C++.

*** DONE Definite Assignment - 43
    CLOSED: [2017-10-14 Sat 12:10]
    C# enforces a /definite assignment policy/ -- it is impossible to access
    uninitialized memory when outside a ~unsafe~ context.

    - /Definite assignment/ has three implications:
      + /Local variables/ must be assigned a value before they can be read.

      + Function arguments must be supplied when a method is called (unless
        marked as optional—see “Optional parameters” on page 48 =TODO=).

      + All other variables (such as /fields/ and /array/ elements) are
        AUTOMATICALLY initialized _by the runtime_.

    - Examples:
      #+BEGIN_SRC csharp
        // RULE #1
        static void Main()
        {
            int x;
            Console.WriteLine (x);  // Compile-time error
        }


        // RULE #3
        static void Main()
        {
            int[] ints = new int[2];
            Console.WriteLine (ints[0]);  // 0
        }


        // RULE #3
        class Test
        {
            static int x;
            static void Main() { Console.WriteLine (x); }  // 0
        }
      #+END_SRC

*** DONE Default Values - 44
    CLOSED: [2017-10-14 Sat 12:01]
    _All type instances have a default value. The default value for the
    predefined types is the result of a bitwise zeroing of memory_:

    | Type                       | Default value |
    |----------------------------+---------------|
    | All reference types        | ~null~        |
    | All numeric and enum types | ~0~           |
    | ~char~ type                | ~'\0'~        |
    | ~bool~ type                | ~false~       |

    You can obtain the /default value/ for any type with the ~default~ keyword
    (in practice, this is useful with generics which we'll cover in Chapter 3): =TODO=
    #+BEGIN_SRC csharp
    decimal d = default (decimal);
    #+END_SRC
    =IMPORTANT=
    The default value in a custom value type (i.e., struct) is the same as the
    default value for each field defined by the custom type.

*** DONE Parameters - 44
    CLOSED: [2017-10-14 Sat 13:28]
    You can control how parameters are passed with the ~ref~ and ~out~ modifiers:

    =TODO= =???=

    | Parameter modifier | Passed by | Variable must be definitely assigned |
    |--------------------+-----------+--------------------------------------|
    | (None)             | Value     | Going in                             |
    | ~ref~              | Reference | Going in                             |
    | ~out~              | Reference | Going out                            |

**** DONE Passing arguments by value - 45
     CLOSED: [2017-10-14 Sat 12:31]
     - /passed by value/ is the default in C#.

     - Passing a reference-type argument by value _copies_ the /reference/, BUT
       NOT the /object/.

**** DONE The ~ref~ modifier - 46
     CLOSED: [2017-10-14 Sat 12:31]
     #+BEGIN_SRC csharp
       class Test
       {
           static void Foo (ref int p)
           {
               p = p + 1;               // Increment p by 1
               Console.WriteLine (p);   // Write p to screen
           }

           static void Main()
           {
               int x = 8;
               Foo (ref x);            // Ask Foo to deal directly with x
               Console.WriteLine (x);  // x is now 9
           }
       }
     #+END_SRC

     - Now assigning ~p~ a new value _CHANGES_ the contents of ~x~.

     - Notice how the ~ref~ modifier is required BOTH when _defining_ and when
       _calling_ the method.4

       footnote 4: =TODO= An exception to this rule is when calling COM methods.
       We discuss this in Chapter 25.

     - The ~ref~ modifier is essential in implementing a /swap method/ (later, in
       “Generics” on page 114 in Chapter 3, we will show how to write a swap
       method that works with any type): =TODO= =???=
       #+BEGIN_SRC csharp
         class Test
         {
             static void Swap (ref string a, ref string b)
             {
                 string temp = a;
                 a = b;
                 b = temp;
             }

             static void Main()
             {
                 string x = "Penn";
                 string y = "Teller";
                 Swap (ref x, ref y);
                 Console.WriteLine (x);  // Teller
                 Console.WriteLine (y);  // Penn
             }
         }
       #+END_SRC

     - Note:
       A parameter can be passed by reference or by value, _REGARDLESS_ of
       whether the parameter type is a reference type or a value type.

**** DONE The ~out~ modifier - 47
     CLOSED: [2017-10-14 Sat 12:40]
     - An ~out~ argument is like a ~ref~ argument, except it:
       + Need not be assigned before going into the function
       + Must be assigned before it comes out of the function

     - The ~out~ modifier is most commonly used to get multiple return values
       back from a method. For example:
       #+BEGIN_SRC csharp
         class Test
         {
             static void Split (string name, out string firstNames,
                                out string lastName)
             {
                 int i = name.LastIndexOf (' ');
                 firstNames = name.Substring (0, i);
                 lastName = name.Substring (i + 1);
             }

             static void Main()
             {
                 string a, b;
                 Split ("Stevie Ray Vaughan", out a, out b);
                 Console.WriteLine (a); // Stevie Ray
                 Console.WriteLine (b); // Vaughan
             }
         }
       #+END_SRC

     - Like a ~ref~ parameter, an ~out~ parameter is passed by reference.

**** DONE Implications of passing by reference - 47
     CLOSED: [2017-10-14 Sat 12:43]
     #+BEGIN_SRC csharp
       class Test
       {
           static int x;

           static void Main() { Foo (out x); }

           static void Foo (out int y)
           {
               Console.WriteLine (x);  // x is 0
               y = 1;                  // Mutate y
               Console.WriteLine (x);  // x is 1
           }
       }
     #+END_SRC

**** DONE The ~params~ modifier - 48
     CLOSED: [2017-10-14 Sat 12:50]
     - ~params~ may be specified on the last parameter of a method to accept any
       number of arguments of a particular type. This parameter must be an array.
       #+BEGIN_SRC csharp
         class Test
         {
             static int Sum (params int[] ints)
             {
                 int sum = 0;
                 for (int i = 0; i < ints.Length; i++)
                     sum += ints[i];                      // Increase sum by ints[i]
                 return sum;
             }

             static void Main()
             {
                 int total = Sum (1, 2, 3, 4);
                 Console.WriteLine (total);              // 10
             }
         }
       #+END_SRC

     - You can also supply a ~params~ argument as an ordinary array.

       The first line in ~Main~ is semantically equivalent to this:
       ~int total = Sum (new int[] { 1, 2, 3, 4 } );~

**** DONE Optional parameters - 48
     CLOSED: [2017-10-14 Sat 13:06]
     - From C# 4.0, methods, constructors, and indexers (Chapter 3) can declare
       /optional parameters/.

     - optional parameters :: a parameter is /optional/ if it specifies a default
          value in its declaration.

       ~void Foo (int x = 23) { Console.WriteLine (x); }~

     - =???= =TODO= =IMPORTANT=
       Adding an /optional parameter/ to a public method that's called
       from another assembly requires recompilation of both assemblies -- 
       just as though the parameter were mandatory.

     - The default value of an optional parameter _MUST_ be specified by
       + a /constant expression/
       + a /parameterless constructor of a value type/.

       /Optional parameters/ _CANNOT_ be marked with ~ref~ or ~out~.

     - /Mandatory parameters/ _must occur before_ /optional parameters/ in both
       the method declaration and the method call (the exception is with ~params~
       arguments, which still always come last).

       In the following example, the explicit value of ~1~ is passed to ~x~, and
       the default value of ~0~ is passed to ~y~:
       #+BEGIN_SRC csharp
         void Foo (int x = 0, int y = 0) { Console.WriteLine (x + ", " + y); }

         void Test()
         {
             Foo(1); // 1, 0
         }
       #+END_SRC

       =TODO=
       To do the converse (pass a default value to x and an explicit value to
       y), you must combine /optional parameters/ with /named arguments/.

**** DONE Named arguments - 49
     CLOSED: [2017-10-14 Sat 13:23]
     - For example:
       #+BEGIN_SRC csharp
         void Foo (int x, int y) { Console.WriteLine (x + ", " + y); }

         void Test()
         {
             Foo (x:1, y:2);  // 1, 2
         }
       #+END_SRC

     - _NOTE_:
       A subtle difference is that argument expressions are evaluated in the
       _ORDER_ in which they appear at the /calling site/.

       For example,
       ~Foo (y: ++a, x: --a)~ is different from ~Foo (x: --a, y: ++a)~.

       Of course, you should avoid writing this kind of code.

     - You can mix named and positional arguments.

     - ONE restriction:
       /positional arguments/ MUST come BEFORE /named arguments/.

     - =TODO= 
       Combine /named arguments/ and /optional parameters/ is particularly useful
       when calling COM APIs, and is discussed in detail in Chapter 25.

*** DONE var—Implicitly Typed Local Variables - 50
    CLOSED: [2017-10-14 Sat 13:28]
    ~var~ is introduced in C# 3.0

    - =TODO=
      In “Anonymous Types” on page 174 in Chapter 4, we will describe a scenario
      where the use of var is mandatory.

** DONE Expressions and Operators - 51
   CLOSED: [2017-10-14 Sat 23:03]
   An expression essentially denotes a value.

*** DONE Primary Expressions - 51
    CLOSED: [2017-10-14 Sat 22:46]
    - Primary expressions :: include expressions composed of operators that are
         intrinsic to the basic plumbing of the language.

    - Here is an example: ~Math.Log (1)~
      It is composed of _TWO_ /primary expressions/:
      1. member-lookup (with the ~.~ operator) 
      2. method call (with the ~()~ operator) 

*** DONE Void Expressions - 51
    CLOSED: [2017-10-14 Sat 22:47]
*** DONE Assignment Expressions - 51
    CLOSED: [2017-10-14 Sat 22:52]
    - An assignment expression is not a void expression -- it has a value of
      whatever was assigned.
      =BAD FEATURE=

    - The /compound assignment operators/ are syntactic shortcuts that combine
      assignment with another operator. For example:
      #+BEGIN_SRC csharp
        x *= 2;    // equaivalent to x = x * 2
        x <<= 1;    // equaivalent to x = x << 1
      #+END_SRC

      =TODO=
      (A subtle exception to this rule is with /events/, which we describe in
      Chapter 4: the ~+=~ and ~-=~ operators here are treated specially and map
      to the event’s ~add~ and ~remove~ accessors.)

      =OPERATOR OVERLOADING IS BAD=

*** DONE Operator Precedence and Associativity - 52
    CLOSED: [2017-10-14 Sat 22:53]
**** Precedence - 52
**** Left-associative operators - 52
**** Right-associative operators - 53

*** DONE Operator Table - 53
    CLOSED: [2017-10-14 Sat 23:03]
    - Table 2-3. C# operators (categories in order of precedence)
      =IMPORTANT=

    - =TODO= We explain user-overloadable operators in “Operator Overloading” on
      page 168 in Chapter 4.

** DONE Null Operators - 55
   CLOSED: [2017-10-14 Sat 23:22]
   - /null-coalescing operator/
   - /null-conditional operator/

*** DONE Null-Coalescing Operators - 55
    CLOSED: [2017-10-14 Sat 23:08]
   - null-coalescing operator :: If the operand is non-null, give it to me;
        otherwise, give me a default value. It is short-circuit.

   - Example:
     #+BEGIN_SRC csharp
       string s1 = null;
       string s2 = s1 ?? "nothing";  // s2 evaluates to "nothing"
     #+END_SRC

   - =TODO= The null-coalescing operator also works with /nullable value types/
     (see “Nullable Types” on page 162 in Chapter 4). =???=
     =TODO=

*** DONE Null-conditional operator (C# 6) - 55
    CLOSED: [2017-10-14 Sat 23:22]
    - It is short-circuit.

    - Example:
      #+BEGIN_SRC csharp
        // #1
        System.Text.StringBuilder sb = null;
        string s = sb?.ToString();  // No error, and No NullReferenceException;
                                    // s instead evaludates to null

        // #2
        System.Text.StringBuilder sb = null;
        string s = sb?.toString().ToUpper();  // No error
      #+END_SRC

      It is equivalent to: ~string s = (sb == null ? null : sb.ToString());~

    - Example:
      #+BEGIN_SRC csharp
        System.Text.StringBuilder sb = null;
        int length = sb?.ToString().Length;  // Illegal: int cannot be null

        int? length = sb?.ToString().Length;  // OK: int? can be null
      #+END_SRC
      =TODO=
      Use of /nullable value types/ (see “Nullable Types” on page 162 in Chapter 4):
      If you’re already familiar with nullable types.

    - You can also use the /null-conditional operator/ to call a /void method/:
      ~someObject?.SomeVoidMethod();~
      If ~someObject~ is ~null~, this becomes a "no-operation" rather than throwing
      a ~NullReferenceException~.

** DONE Statements - 56
   CLOSED: [2017-10-15 Sun 22:18]
   - statement block :: statements appearing between braces (the ~{}~ tokens).

*** DONE Declaration Statements - 56
    CLOSED: [2017-10-14 Sat 23:34]
    ~const~

**** Local variables - 57
     - Declare another /local variable/ with the _same name_ in the
       /current block/ or in any /nested blocks/.

     - _Note_:
       A variable's scope extends in both directions throughout its code block.
       #+BEGIN_SRC csharp
         // #1
         {
             int x;
             {
                 int x;
             }
         }


         // #2
         {
             {
                 int x;
             }
             int x;
         }
       #+END_SRC

       Both #1 and #2 are illegal. This is different from Language like C++ --
       the scope is NOT start from the declaration site.
       =TODO= =double-check=

*** DONE Expression Statements - 57
    CLOSED: [2017-10-14 Sat 23:42]
    - expression statements :: the expressions that are also valid statements.

    - An /expression statement/ must either change state or call something that
      might change state.

    - The _possible_ /expression statements/ are:
      + Assignment expressions (including increment and decrement expressions)
      + Method call expressions (both void and nonvoid)
      + Object instantiation expressions

*** DONE Selection Statements - 58
    CLOSED: [2017-10-15 Sun 01:40]
    C# has the following mechanisms to conditionally control the flow of program
    execution:
    - Selection statements (~if~, ~switch~)
    - Conditional operator (~?:~)
    - Loop statements (~while~, ~do..while~, ~for~, ~foreach~)

    This section covers the simplest two constructs: the if-else statement and
    the switch statement.

**** The ~if~ statement - 58
**** The ~else~ clause - 59
**** Changing the flow of execution with braces - 59
**** The ~switch~ statement - 60
     ~switch~ statements is restricted to
     - the built-in integral types
     - ~bool~
     - ~enum~ (and nullable versions of these -- see Chapter 4 =TODO=)
     - ~string~ type

     #+BEGIN_SRC csharp
       static void ShowCard(int cardNumber)
       {
           switch (cardNumber)
           {
               case 13:
                   Console.WriteLine ("King");
                   break;
               case 12:
                   Console.WriteLine ("Queen");
                   break;
               case 11:
                   Console.WriteLine ("Jack");
                   break;
               case -1: // Joker is -1
                   goto case 12; // In this game joker counts as queen
               default: // Executes for any other cardNumber
                   Console.WriteLine (cardNumber);
                   break;
           }
       }
     #+END_SRC

     - At the end of each ~case~ clause, you have some options:
       + ~break~
       + ~goto case~
       + ~goto default~
       + Any other jump statement -- namely, ~return~, ~throw~, ~continue~, or ~goto label~

*** DONE Iteration Statements - 61
    CLOSED: [2017-10-15 Sun 01:50]
**** ~while~ and ~do-while~ loops - 61
**** ~for~ loops - 61
**** ~foreach~ loops - 62
     #+BEGIN_SRC csharp
       foreach (char c in "beer")
           Console.WriteLine (c);

       // OUTPUT:
       // b
       // e
       // e
       // r
     #+END_SRC

     - =TODO= 
       We define enumerable objects in “Enumeration and Iterators” on page 156 in
       Chapter 4.

*** DONE Jump Statements - 63
    CLOSED: [2017-10-15 Sun 02:32]
    - ~break~
    - ~continue~
    - ~goto~
    - ~return~
    - ~throw~

    - _NOTE_:
      Jump statements obey the reliability rules of ~try~ statements
      =TODO= (see “try Statements and Exceptions” on page 148 in Chapter 4).
      This means that:
      + A jump out of a ~try~ block always executes the ~try~'s ~finally~ block
        before reaching the target of the jump.

      + A jump cannot be made from the inside to the outside of a ~finally~ block
        (except via ~throw~).

**** The ~break~ statement - 63
     The ~break~ statement ends the execution of the body of
     + an iteration
       or
     + ~switch~ statement.

**** The ~continue~ statement - 63
**** The ~goto~ statement - 63
     - ~goto label~
       #+BEGIN_SRC csharp
         int i = 1;
         startLoop:
         if (i <= 5)
         {
             Console.Write (i + " ");
             i++;
             goto startLoop;
         }

         // OUTPUT: 1 2 3 4 5
       #+END_SRC

     - =TODO=
       The ~goto case case-constant~ transfers execution to another case in a
       ~switch~ block (see “The switch statement” on page 60).

**** The ~return~ statement - 64
     A ~return~ statement can appear anywhere in a method
     (_EXCEPT in a ~finally~ block_).

**** The ~throw~ statement - 64
     - =TODO= (see “try Statements and Exceptions” on page 148 in Chapter 4)

*** DONE Miscellaneous Statements - 64 =RE-READ=
    CLOSED: [2017-10-15 Sun 22:18]
    - The ~using~ statement provides an elegant syntax for calling ~Dispose~ on
      objects that implement ~IDisposable~, within a ~finally~ block (see “try
      Statements and Exceptions” on page 148 in Chapter 4 and “IDisposable,
      Dispose, and Close” on page 499 in Chapter 12).
      =TODO= =???=

    - _NOTE_:
      C# overloads the ~using~ keyword to have independent meanings in different
      _contexts_.

      Specifically, the ~using~ /directive/ is different from the using
      /statement/.

    - The ~lock~ statement is a shortcut for calling the ~Enter~ and ~Exit~
      methods of the ~Monitor~ class (see Chapter 14 and Chapter 23).
      =TODO= =???=

** DONE Namespaces - 65
   CLOSED: [2017-10-15 Sun 22:27]
   - namespace :: a domain for type names.

   - /Types/ are typically _organized_ into hierarchical namespaces, making them
     + easier to find
     + avoiding conflicts

   - _NOTE_:
     + Namespaces are independent of assemblies (described in Chapter 18 =TODO=).
     + Namespaces also have no impact on member visibility -- ~public~,
       ~internal~, ~private~, and so on.

   - The namespace keyword defines a namespace for types within that block. For example:
     #+BEGIN_SRC csharp
       namespace Outer.Middle.Inner
       {
           class Class1 {}
           class Class2 {}
       }
     #+END_SRC

     Code Be semantically identical to the preceding example:
     #+BEGIN_SRC csharp
       namespace Outer
       {
           namespace Middle
           {
               namespace Inner
               {
                   class Class1 {}
                   class Class2 {}
               }
           }
       }
     #+END_SRC

   - fully qualified name ::

   - Types not defined in any namespace are said to reside in the
     /global namespace/.

   - The /global namespace/ also includes top-level namespaces, such as ~Outer~
     in our example.

*** DONE The ~using~ Directive - 66
    CLOSED: [2017-10-15 Sun 22:36]
    The ~using~ directive /imports/ a namespace.
    For example,
    #+BEGIN_SRC csharp
      using Outer.Middle.Inner;

      class Test
      {
          static void Main()
          {
              Class1 c;  // Don't need fully qualified name
          }
      }
    #+END_SRC

*** DONE using static (C# 6) - 66
    CLOSED: [2017-10-15 Sun 22:53]
    - From C# 6, you can import NOT just a namespace, but a specific type, with
      the ~using static~ directive.

    - Example:
      #+BEGIN_SRC csharp
        using static System.Console;

        class Test
        {
            static void Main() { WriteLine ("Hello"); }
        }
      #+END_SRC

    - The ~using static~ directive imports _all accessible /static members/_ of
      the type, including /fields/, /properties/ and /nested types/ (Chapter 3).
      =TODO=

    - You can also apply this directive to /enum types/ (Chapter 3), in which
      case their members are imported.
      #+BEGIN_SRC csharp
        using static System.Windows.Visibility;

        // `Visibility.Hidden` now can be used without being fully quanlified
        var textBox = new TextBox { Visibility = Hidden };  // XAML-style
      #+END_SRC

    - An ambiguity arise between MULTIPLE /static imports/.
      =TODO= =???= =IMPORTANT=

*** DONE Rules Within a Namespace - 67
    CLOSED: [2017-10-15 Sun 23:08]
**** Name scoping - 67
**** Name hiding - 67
     Inner name wins when there are same names in both inner and outer namespace.

     =TODO= =HOW???=
     To refer to the type in the outer namespace, you must qualify its name.
     #+BEGIN_SRC csharp
       namespace Outer
       {
           class Foo { }

           namespace Inner
           {
               class Foo { }

               class Test
               {
                   Foo f1; // = Outer.Inner.Foo
                   Outer.Foo f2; // = Outer.Foo
               }
           }
       }
     #+END_SRC

     =TODO= =???=

     _NOTE_:
     _All type names are converted to fully qualified names at compile time._

     /Intermediate language (IL)/ code contains
     - no unqualified
     - partially qualified names.

**** Repeated namespaces - 68
     You can repeat a namespace declaration, as long as the type names within
     the namespaces don’t conflict:
     #+BEGIN_SRC csharp
       namespace Outer.Middle.Inner
       {
           class Class1 {}
       }

       namespace Outer.Middle.Inner
       {
           class Class2 {}
       }
     #+END_SRC

**** Nested using directive - 68
     #+BEGIN_SRC csharp
       namespace N1
       {
           class Class1 {}
       }


       namespace N2
       {
           using N1;
           class Class2 : Class1 {}
       }


       namespace N2
       {
           class Class3 : Class1 {} // Compile-time error
       }
     #+END_SRC

     The ~:~ syntax ????????????

*** DONE Aliasing Types and Namespaces - 69
    CLOSED: [2017-10-15 Sun 23:11]
    #+BEGIN_SRC csharp
      using PropertyInfo2 = System.Reflection.PropertyInfo;
      class Program { PropertyInfo2 p; }
    #+END_SRC

    #+BEGIN_SRC csharp
      using R = System.Reflection;
      class Program { R.PropertyInfo p; }
    #+END_SRC

*** DONE Advanced Namespace Features - 69
    CLOSED: [2017-10-16 Mon 03:49]
**** Extern - 69
     Library 1:
     #+BEGIN_SRC csharp
       // csc target:library /out:Widgets1.dll widgetsv1.cs
       namespace Widgets
       {
           public class Widget {}
       }
     #+END_SRC

     Library 2:
     #+BEGIN_SRC csharp
       // csc target:library /out:Widgets2.dll widgetsv2.cs
       namespace Widgets
       {
           public class Widget {}
       }
     #+END_SRC

     Application:
     #+BEGIN_SRC csharp
       // csc /r:Widgets1.dll /r:Widgets2.dll application.cs
       using Widgets;
       class Test
       {
           static void Main()
           {
               Widget w = new Widget();
           }
       }
     #+END_SRC


     The above code CANNOT compile. /Extern aliases/ can resolve the ambiguity in
     our application:
     #+BEGIN_SRC csharp
       // csc /r:W1=Widgets1.dll /r:W2=Widgets2.dll application.cs
       extern alias W1;
       extern alias W2;

       class Test
       {
           static void Main()
           {
               W1.Widgets.Widget w1 = new W1.Widgets.Widget();
               W2.Widgets.Widget w2 = new W2.Widgets.Widget();
           }
       }
     #+END_SRC

**** Namespace alias qualifiers - 70
     - The compiler always gives higher precedence to identifiers in the current
       namespace.
       #+BEGIN_SRC csharp
         namespace N
         {
             class A
             {
                 public class B {} // Nested type
                 static void Main() { new A.B(); } // Instantiate class B
             }
         }

         namespace A
         {
             class B {}
         }
       #+END_SRC

     - To resolve such conflicts, a /namespace/ name can be _qualified_, relative
       to one of the following (The ~::~ token is used for /namespace alias
       qualification/):
       + The global namespace -- the root of all namespaces (identified with the
         /contextual keyword/ ~global~)
         #+BEGIN_SRC csharp
           namespace N
           {
               class A
               {
                   static void Main()
                   {
                       System.Console.WriteLine (new A.B());
                       System.Console.WriteLine (new global::A.B());
                   }

                   public class B {}
               }
           }

           namespace A
           {
               class B {}
           }
         #+END_SRC

       + The set of ~extern~ aliases
         #+BEGIN_SRC csharp
           extern alias W1;
           extern alias W2;

           class Test
           {
               static void Main()
               {
                   W1::Widgets.Widget w1 = new W1::Widgets.Widget();
                   W2::Widgets.Widget w2 = new W2::Widgets.Widget();
               }
           }
         #+END_SRC

* DONE 3. Creating Types in C# - 73
  CLOSED: [2017-10-27 Fri 00:56]
** DONE Classes - 73
   CLOSED: [2017-10-18 Wed 15:28]
   - Basic Syntax:
     #+BEGIN_SRC csharp
       class YourClassName
       {
       }
     #+END_SRC

   - A more complex class optionally has the following:
     + Preceding the keyword ~class~:
       Attributes and class modifiers. The non-nested class modifiers are
       ~public~, ~internal~, ~abstract~, ~sealed~, ~static~, ~unsafe~, and ~partial~

     + Following ~YourClassName~:
       Generic type parameters, a base class, and interfaces

     + Within the curly braces:
       Class members (these are
       * methods
       * properties
       * indexers
       * events
       * fields
       * constructors
       * overloaded operators
       * nested types
       * a finalizer =TODO=)

   - This chapter covers all of these constructs _EXCEPT_ /attributes/, /operator
     functions/, and the ~unsafe~ keyword, which are covered in Chapter 4.
     =TODO=

     The following sections enumerate each of the class members.

*** DONE Fields - 74
    CLOSED: [2017-10-16 Mon 04:35]
    - Fields allow the following modifiers:
      + Static modifier ~static~
      + Access modifiers ~public~, ~internal~, ~private~, ~protected~
      + Inheritance modifier ~new~
      + Unsafe code modifier ~unsafe~
      + Read-only modifier ~readonly~
      + Threading modifier ~volatile~

**** The ~readonly~ modifier - 74
     - The ~readonly~ modifier _prevents_ a /field/ from being modified _after_
       /construction/.

     - A read-only field can be assigned _ONLY_
       + in its declaration
         OR
       + within the enclosing type's constructor.

**** Field initialization - 74
     An uninitialized /field/ has a /default value/
     - ~0~
     - ~\0~
     - ~null~
     - ~false~

**** Declaring multiple fields together - 74
     #+BEGIN_SRC csharp
       static readonly int legs = 8,
                           eyes = 2;
     #+END_SRC

*** DONE Methods - 74
    CLOSED: [2017-10-16 Mon 04:35]
    - A method's signature comprises its
      + name
      + parameter types
      and it must be unique within the type.

    - Method allow the follwing modifiers:
      + Static modifier ~static~
      + Access modifiers ~public~, ~internal~, ~private~, ~protected~
      + Inheritance modifiers ~new~, ~virtual~, ~abstract~, ~override~, ~sealed~
      + Partial method modifier ~partial~
      + Unmanaged code modifiers ~unsafe~ ~extern~
      + Asynchronous code modifier ~async~

**** Expression-bodied methods (C# 6) - 75
     Write a single expression function body in a more terse syntax:
     - Old:
       ~int Foo (int x) { return x * 2; }~

     - New:
       ~int Foo (int x) => x * 2;~
       ~void Foo (int x) => Console.WriteLine(x);~

**** Overloading methods - 75
     - The syntax is like Java.

     - Compile-time error cases:
       #+BEGIN_SRC csharp
         void Foo (int x) { /* ... */ }
         float Foo (int x) { /* ... */ }  // Compile-time error

         void Goo (int[] x) { /* ... */ }
         void Foo (params int[] x) { /* ... */ }  // Compile-time error
       #+END_SRC

       ~params~ is NOT part of a /method's signature/.

**** Pass-by-value versus pass-by-reference - 76 
     Whether a parameter is /pass-by-value/ or /pass-by-reference/ is also part
     of the /signature/.

     For example,
     ~Foo(int)~ can coexist with either ~Foo(ref int)~ or ~Foo(out int)~;
     ~Foo(ref int)~ _CANNOT_ coexist with either ~Foo(out int)~.

*** DONE Instance Constructors - 76
    CLOSED: [2017-10-16 Mon 04:56]
    - Constructors run initialization code on a /class/ or /struct/.
      For example,
      #+BEGIN_SRC csharp
        public class Panda
        {
            string name;  // Define field
            public Panda (string n)  // Define constructor
            {
                name = n;            // Initialization code (set up field)
            }
        }

        // ...

        Panda p = new Panda ("Petey");  // Call constructor
      #+END_SRC

    - Instance constructors allow the following modifiers:
      + Access modifiers ~public~, ~internal~, ~private~, ~protected~
      + Unmanaged code modifiers ~unsafe~, ~extern~

**** Overloading constructors - 76
     - Often call a constructor from another overloaded constructor.
       Use ~this~.

     - CANNOT use ~this~ as reference to call /non-static methods/ -- ~this~
       instance has NOT been constructed.

**** Implicit parameterless constructors - 77
     /implicit parameterless constructors/ will be automatically generated by the
     C# compiler _if none constructor was manually defined_.

**** Constructor and field initialization order - 77
     /Fields/ can be initialized with /default values/ in their declaration,
     /field initializations/ occur:
     - _before_ the /constructor/ is executed
     - _in the declaration order_ of the /fields/.

**** Nonpublic constructors - 77
     Constructors do not need to be public.
     #+BEGIN_SRC csharp
       public class Class1
       {
           Class1() {}  // Private constructor
           public static Class1 Create (...)
           {
               // Perform custom logic here to return an instance of Class1
               // ...
           }
       }
     #+END_SRC

     A common reason to have a /nonpublic constructor/ is to control _instance
     creation_ via a _/static method/ call_.
       The /static method/ could be used to return an object _from a pool_
     _RATHER THAN_
     + necessarily creating a new object
       OR
     + return various subclasses based on input arguments:

*** DONE Object Initializers - 77 =RE-READ=
    CLOSED: [2017-10-16 Mon 05:04]
    Introduced in C# 3.0
    - Examples:
      #+BEGIN_SRC csharp
        // Note parameterless constructors can omit empty parentheses
        Bunny b1 = new Bunny { Name="Bo", LikesCarrots=true, LikesHumans=false };

        // Equivalent as `b1`
        Bunny temp1 = new Bunny(); // temp1 is a compiler-generated name
        temp1.Name = "Bo";
        temp1.LikesCarrots = true;
        temp1.LikesHumans = false;
        Bunny b1 = temp1;


        Bunny b2 = new Bunny ("Bo") { LikesCarrots=true, LikesHumans=false };

        // Equivalent as `b2`
        Bunny temp2 = new Bunny ("Bo");
        temp2.LikesCarrots = true;
        temp2.LikesHumans = false;
        Bunny b2 = temp2;
      #+END_SRC

    - *Object Initializers Versus Optional Parameters* =RE-READ=
      + =TODO=

      + Hence, you should exercise caution with optional parameters in public
        functions if you want to offer /binary compatibility/ between assembly
        versions.

*** DONE The ~this~ Reference - 79
    CLOSED: [2017-10-16 Mon 05:06]
    #+BEGIN_SRC csharp
      public class Panda
      {
          public Panda Mate;

          public void Marry (Panda partner)
          {
              Mate = partner;
              partner.Mate = this;
          }
      }
    #+END_SRC

*** DONE Properties - 79
    CLOSED: [2017-10-18 Wed 14:29]
    - You CANNOT distinguish /fields/ and /properties/ when using them (if there
      is NO specific access permission settings).

      For example,
      #+BEGIN_SRC csharp
        Stock msft = new Stock();
        msft.CurrentPrice = 30;
        msft.CurrentPrice -= 3;
        Console.WriteLine (msft.CurrentPrice);
      #+END_SRC

    - A /property/ is declared like a /field/, but with a ~get/set~ block added.
      Here’s how to implement ~CurrentPrice~ as a /property/:
      #+BEGIN_SRC csharp
        public class Stock
        {
            decimal currentPrice;          // The private "backing" field

            public decimal CurrentPrice    // The public property
            {
                get { return currentPrice; }
                set { currentPrice = value; }
            }
        }
      #+END_SRC

      Here ~get~ and ~set~ denote /property accessors/.
      + The ~get~ accessor runs when the /property/ is _read_.
        It MUST return a value of the _property's type_.

      + The ~set~ accessor runs when the /property/ is assigned.
        It has an /implicit parameter/ named ~value~ of the /property's type/
        that you typically assign to a private field (in this case,
        ~currentPrice~).

    - Properties allow the following modifiers: 
      + Static modifier         ~static~
      + Access modifiers        ~public~, ~internal~, ~private~, ~protected~
      + Inheritance modifiers   ~new~, ~virtual~, ~abstract~, ~override~, ~sealed~
      + Unmanaged code modifiers ~unsafe~, ~extern~

**** Read-only and calculated properties - 80
     - read-only property :: only ~get~

     - write-only property :: only ~set~. This is rarely used.

**** Expression-bodied properties (C# 6) - 81
     Example
     ~public decimal Worth => currentPrice * sharesOwned;~

**** Automatic properties - 81
     If a property doesn't include logic, and only for providing a public API,
     apply the /automatic property/, and the compiler will help to fill in code.
     #+BEGIN_SRC csharp
       public class Stock
       {
           // ...
           public decimal CurrentPrice { get; set; }
       }
     #+END_SRC

     - The ~set~ accessor can be marked ~private~ or ~protected~

**** Property initializers (C# 6) - 81
     - ~public decimal CurrentPrice { get; set; } = 123;~

     - Immutable (Read-only) ~public int Maximum { get; } = 999;~

**** ~get~ and ~set~ accessibility - 82
     The ~get~ and ~set~ accessors can have different access levels.

     The typical use case for this is to have a /public property/ with an
     ~internal~ or ~private~ access modifier on the /setter/:
     #+BEGIN_SRC csharp
       public class Foo
       {
           private decimal x;
           public decimal X
           {
               get         { return x; }
               private set { x = Math.Round (value, 2); }
           }
       }
     #+END_SRC

**** CLR property implementation - 82
     - C# property accessors internally compile to methods called ~get_XXX~ and
       ~set_XXX~:
       #+BEGIN_SRC csharp
         // From Jian - Not sure this might be a typo ??? Not () for parameters ???
         public decimal get_CurrentPrice {...}
         public void set_CurrentPrice(decimal value) {...}
       #+END_SRC

     - Simple /nonvirtual/ =TODO= =???= property accessors are inlined by the JIT
       compiler, eliminating any performance difference between accessing a
       property and a field.

     - With /WinRT properties/, the compiler assumes the ~put_XXX~ naming
       convention rather than ~set_XXX~.

*** DONE Indexers - 82
    CLOSED: [2017-10-18 Wed 14:45]
    - indexers :: a natural syntax for accessing elements in a class or struct
                  that encapsulate a list or dictionary of values.

    - /Indexers/ are similar to properties but are accessed _via an index
      argument_ rather than a /property name/.

    - The syntax for using /indexers/ is like that for using arrays, _except_
      that the index argument(s) can _be of any type(s)_.

    - Example: the ~string~ type values.

    - Indexers have the same modifiers as properties.

    - Indexers can be called null-conditionally by inserting a question mark
      before the square bracket.
      #+BEGIN_SRC csharp
        string s = null;
        Console.WriteLine (s?[0]);  // Write nothing; no error.
      #+END_SRC

**** Implementing an indexer - 83
     #+BEGIN_SRC csharp
       class Sentence
       {
           string[] words = "The quick brown fox".Split();

           public string this [int wordNum]  // indexer
           {
               get { return words [wordNum]; }
               set { words [wordNum] = value; }
           }
       }


       Sentence s = new Sentence();
       Console.WriteLine (s[3]);    // fox
       s[3] = "kangaroo";
       Console.WriteLine (s[3]);    // kangaroo
     #+END_SRC

     - There can be multiple indexers:
       ~public string this [int arg1, string arg2]~

**** CLR indexer implementation - 83
     Indexers internally compile to methods called ~get_Item~ and ~set_Item~, as
     follows:
     #+BEGIN_SRC csharp
       public string get_Item (int wordNum) {...}
       public void set_Item (int wordNum, string value) {...} 
     #+END_SRC

*** DONE Constants - 83
    CLOSED: [2017-10-16 Mon 05:20]
    - constant :: a /static field/ whose value can never change.

                  It is evaluated statically at compile time, and the compiler
                  literally substitutes its value whenever used (rather like a
                  macro in C++).

    - A /constant/ can be any of the _built-in_ numeric types:
      + ~bool~
      + ~char~
      + ~string~
      + an ~enum~ type

    - A /constant/ is declared with the ~const~ keyword and _must be initialized_
      with a value.

    - A /constant/ is much more _restrictive_ than a ~static readonly~ field --
      both in the types you can use and in field initialization semantics.

    - A /constant/ also differs from a ~static readonly~ field in that the
      evaluation of the /constant/ occurs _at compile time_.

      ~static readonly~ can have a different value per application.

    - _NOTE_:
      A ~static readonly~ field is also _advantageous_ when exposing to other
      assemblies a value that might change in a later version.

      For instance, suppose assembly X exposes a constant as follows:
      ~public const decimal ProgramVersion = 2.3;~
      If assembly Y references X and uses this constant, the value 2.3 will be
      baked into assembly Y when compiled. This means that if X is later
      recompiled with the constant set to 2.4, Y will still use the old value of
      2.3 until Y is recompiled.

      _A ~static readonly~ field avoids this problem._

      Another way of looking at this is that any that value that might change in
      the future is NOT constant by definition, and so should NOT be represented
      as one.

      =From Jian=
      + PI should be ~const~

      + how many time you want to repeat an action is NOT a ~const~ --
        you may change you decision or the requirement of this part might be
        changed by your customer.

*** DONE Static Constructors - 85
    CLOSED: [2017-10-18 Wed 15:07]
    - A /static constructor/ executes _once per type_, rather than once per
      instance.

    - It must be:
      + parameterless
      + have the same name as the type

    - Example:
      #+BEGIN_SRC csharp
        class Test
        {
            static Test() { Console.WriteLine ("Type Initialized"); }
        }
      #+END_SRC

    - The runtime automatically invokes a /static constructor/ just prior to the
      type being used. _TWO_ things trigger this:
      + Instantiating the type
      + Accessing a static member in the type

    - The _ONLY_ /modifier/ allowed by /static constructors/ are ~unsafe~ and
      ~extern~.

    - =IMPORTANT=
      If a /static constructor/ throws an /unhandled exception/ =TODO= CHAPTER 4,
      the type becomes _unusable_ for the life of the application.

**** DONE Static Constructors and field initialization order - 85 =RE-READ=
     CLOSED: [2017-10-18 Wed 15:17]
     - /Static field initializers/ run just _before_ the /static constructor/ is
       called.

     - If a type has _NO_ /static constructor/, /field initializers/ will execute
       just prior to the type being used -- or anytime _earlier_ at the whim of
       the runtime.
       #+BEGIN_SRC csharp
         class Foo
         {
             public static int X = Y;  // 0
             public static int Y = 3;  // 3
         }
       #+END_SRC

     - Example
       #+BEGIN_SRC csharp
         class Program
         {
             static void Main() { Console.WriteLine (Foo.X); }  // 3
         }

         class Foo
         {
             public static Foo Instance = new Foo();
             public static int X = 3;

             Foo() { Console.WriteLine (X); }  // 0
         }
       #+END_SRC

*** DONE Static Classes - 86
    CLOSED: [2017-10-18 Wed 15:19]
    - ~static classes~ :: classes that
      + composed solely of /static members/
      + CANNOT be subclassed.

*** DONE Finalizers - 86
    CLOSED: [2017-10-18 Wed 15:24]
    - finalizers :: class-only methods that excute _before_ the garbage collector
                    reclaims the memory for an unreferenced object.

    - The syntax for a /finalizer/:
      #+BEGIN_SRC csharp
        class Class1
        {
            ~Class1()
            {
                // ...
            }
        }
      #+END_SRC
      This is actually C# syntax for overriding ~Object~'s ~Finalize~ method, and
      the compiler expands it into the following method declaration:
      #+BEGIN_SRC csharp
        protected override void Finalize()
        {
            // ...
            base.Finalize();
        }
      #+END_SRC

    - The allowed /modifier/: ~unsafe~

*** DONE Partial Types and Methods - 86 =RE-READ=
    CLOSED: [2017-10-18 Wed 15:27]
**** Partial methods - 87

*** DONE The ~nameof~ operator (C# 6) - 88
    CLOSED: [2017-10-16 Mon 05:27]
    - ~nameof~ :: it returns the name of any symbol (/type/, /member/,
                  /variable/, and _so on_) as a _string_.
    - Example:
      #+BEGIN_SRC csharp
        int count = 123;
        string name = nameof (count);  // name is "count"
      #+END_SRC
      The advantageous of this code is: even if the name of ~count~ changes in
      the feature, the variable ~name~ will save the right name.

    - Details:
      #+BEGIN_SRC csharp
        nameof (StringBuilder.Length);
        // Length

        nameof (StringBuilder) + "." + nameof (StringBuilder.Length);
        // StringBuilder.Length
      #+END_SRC

** DONE Inheritance - 88
   CLOSED: [2017-10-22 Sun 14:18]
   #+BEGIN_SRC csharp
     public class Asset
     {
         public string Name;
     }


     public class Stock : Asset
     {
         public long SharesOwned;
     }


     public class House : Asset
     {
         public decimal Mortgage;
     }


     Stock msft = new Stock { Name="MSFT",
                              SharesOwned=1000 };
   #+END_SRC

   - Terminology: /inherit/, /base class/, /derived classes/

*** DONE Polymorphism - 89
    CLOSED: [2017-10-19 Thu 17:10]
    - _References are /polymorphic/._
      This means a variable of type ~x~ can refer to an object that subclasses ~x~.

*** DONE Casting and Reference Conversions - 89
    CLOSED: [2017-10-19 Thu 17:25]
    - An object reference can be:
      + _Implicitly_ /upcast/ to a base class reference
      + _Explicitly_ /downcast/ to a subclass reference

    - /Upcasting/ and /downcasting/ between compatible reference types performs
      /reference conversions/: a new reference is (logically) created that points
      to the _same_ object.
      + _an /upcast/ ALWAYS SUCCEEDS_
      + a /downcast/ succeeds ONLY if the object is suitably typed.

**** DONE Upcasting - 90
     CLOSED: [2017-10-19 Thu 17:09]
     #+BEGIN_SRC csharp
       Stock msft = new Stock();
       Asset a = msft;    // Upcast

       // The object doesn't change
       a == msft;  // True


       // only reference change, such that the usage then is restricted:
       Console.WriteLine (a.Name);  // OK
       Console.WriteLine (a.SharesOwned);  // Error: SharesOwned undefined
     #+END_SRC

**** DONE Downcasting - 90
     CLOSED: [2017-10-19 Thu 17:09]
     ~InvalidCastException~ is thrown, when there is a /downcast/ failure.

**** DONE The ~as~ operator - 90
     CLOSED: [2017-10-19 Thu 17:21]
     #+BEGIN_SRC csharp
       Asset a = new Asset();
       Stock s = a as Stock;   // `s` is `null`; no exception thrown

       if (s != null) Console.WriteLine (s.SharesOwned);
     #+END_SRC

     - _Note_:
       _Without such a test, a cast is advantageous_, because if it fails, a more
       helpful exception is thrown. We can illustrate by comparing the following
       two lines of code:
       #+BEGIN_SRC csharp
       int shares = ((Stock)a).SharesOwned;   // Approach #1
       int shares = (a as Stock).SharesOwned; // Approach #2
       #+END_SRC

         If ~a~ is not a ~Stock~, the first line throws an ~InvalidCastException~,
       which is an accurate description of what went wrong.

         The second line throws a ~NullReferenceException~, which is ambiguous.

       Another way of looking at it is that

       + with the cast operator, you're saying to the compiler:
        "I'm _certain_ of a value's type; if I'm wrong, there's a bug in my
         code, so throw an exception!"

       + Whereas with the ~as~ operator, you're _uncertain_ of its type and want to
         branch according to the outcome at runtime.
     
**** DONE The ~is~ operator - 91
     CLOSED: [2017-10-19 Thu 17:25]
     - ~is~ :: test whether a /reference conversion/ would succeed.

     - Example:
       #+BEGIN_SRC csharp
         if (a is Stock)
             Console.WriteLine (((Stock) a).SharesOwned);
       #+END_SRC

     - =TODO=
       The ~is~ operator also evaluates to ~true~ if an /unboxing conversion/
       =???= would succeed (see “The object Type” on page 97) =TODO=.

       However, it does _NOT consider_ /custom or numeric conversions/. 

*** DONE Virtual Function Members - 91
    CLOSED: [2017-10-19 Thu 19:46]
    - A function marked as ~virtual~ can be overridden by subclasses wanting to
      provide a specialized implementation.

      /Methods/, /properties/, /indexers/, and /events/ can all be declared
      ~virtual~:

    - Example:
      #+BEGIN_SRC csharp
        public class Asset
        {
            public string Name;
            public virtual decimal Liability => 0;  // Expression-bodied property

            // Equivalent form:
            // public virtual decimal Liability { get { return 0; } }
        }

        public class Stock : Asset
        {
            public long SharesOwned;
        }

        public class House : Asset
        {
            public decimal Mortgage;
            public override decimal Liability => Mortgage;
        }
      #+END_SRC

    - CAUTION: =TODO= =RE-READ= =!!!=

*** DONE Abstract Classes and Abstract Members - 92
    CLOSED: [2017-10-19 Thu 19:49]
*** DONE Hiding Inherited Members - 93
    CLOSED: [2017-10-22 Sun 11:17]
    - The ~Counter~ field in class ~B~ is said to /hide/ the ~Counter~ field in
      class ~A~. Usually, this is by accident, and a warning will be issued.
      #+BEGIN_SRC csharp
        public class A { public int Counter = 1; }
        public class B : A { public int Counter = 2; }
      #+END_SRC

    - If you really want to do this use the ~new~ modifier. It does nothing more
      than suppress the compiler warning that would otherwise result:
      #+BEGIN_SRC csharp
        public class A { public int Counter = 1; }
        public class B : A { public new int Counter = 2; }
      #+END_SRC

    - _NOTE_:
      C# _overloads_ the ~new~ keyword to have independent meanings in different
      _contexts_.

      _Specifically, the ~new~ operator is different from the ~new~ member
      modifier._
**** ~new~ versus ~override~
*** DONE Sealing Functions and Classes - 94
    CLOSED: [2017-10-22 Sun 14:06]
    - ~sealed~ ::
      + seal a method: prevent a method from being overridden by further subclasses.
      + seal a class: implicitly seal all the /virtual functions/.

    - Sealing a class is more common than sealing a function member.

    - You can /seal/ against /overriding/.  (/methods/)
      You CANNOT seal a member against being hidden.  (/fields/)

*** DONE The ~base~ Keyword - 94
    CLOSED: [2017-10-22 Sun 14:16]
    - The ~base~ keyword serves two essential purposes:
      + Accessing an overridden function member from the subclass
      + Calling a base-class constructor (=TODO= see the next section)

    - The ~base~ keyword guarantees a /nonvirtually/ access.

    - The same approach works if ~Liability~ is /hidden/ rather than overridden.
      (You can also access /hidden members/ by .
      invoking the function.)

    - The same approach works if ~Liability~ is /hidden/ rather than
      /overridden/.
      =IMPORTANT=
      (You can also access hidden members by casting to the base class before
      invoking the function.)

*** DONE Constructors and Inheritance - 95
    CLOSED: [2017-10-19 Thu 20:40]
    - A subclass _MUST_ declare its own constructors.
      The base class's constructors are _accessible_ to the derived class but are
      _NEVER automatically inherited_.

    - Example:
      #+BEGIN_SRC csharp
        public class Baseclass
        {
            public int X;
            public Baseclass () {}
            public Baseclass (int x) { this.X = x; }
        }

        //// Do NOT do this
        // public class Subclass : Baseclass {}

        // Do this
        public class Subclass : Baseclass
        {
            public Subclass (int x) : base (x) {}
        }
      #+END_SRC

    - The ~base~ keyword works rather like the ~this~ keyword, except that it
      calls a constructor in the /base class/.

    - Base-class constructors always execute first;
      this ensures that base initialization occurs _before_ specialized
      initialization. =From Jian= If NOT ~public Subclass (int x) : base (x) {}~
      can be wrong.


**** DONE Implicit calling of the parameterless base-class constructor - 95
     CLOSED: [2017-10-19 Thu 20:35]
     - If a constructor in a subclass omits the ~base~ keyword, the ~base~
       type's parameterless constructor is implicitly called.

     - If the /base class/ has NO accessible parameterless constructor,
       subclasses are _forced to use_ the ~base~ keyword in their constructors.

**** DONE Constructor and field initialization order - 96
     CLOSED: [2017-10-19 Thu 20:40]
     When an object is instantiated, initialization takes place in the following
     _order_:
     1. From subclass to base class:
        a. Fields are initialized.
        b. Arguments to base-class constructor calls are evaluated.

     2. From base class to subclass:
        a. Constructor bodies execute.

     The following code demonstrates:
     #+BEGIN_SRC csharp
       public class B
       {
           int x = 1; // Executes 3rd

           public B (int x)
           {
               ... // Executes 4th
           }
       }


       public class D : B
       {
           int y = 1;                      // Executes 1st

           public D (int x)
               : base (x + 1)              // Executes 2nd
           {
               ...                         // Executes 5th
           }
       }
     #+END_SRC

*** DONE Overloading and Resolution - 96
    CLOSED: [2017-10-19 Thu 20:55]

    - Inheritance has an interesting impact on /method overloading/.
      Consider the following two overloads:
      #+BEGIN_SRC csharp
        static void Foo (Asset a) { }
        static void Foo (House h) { }
      #+END_SRC

      When an overload is called, the most specific type has precedence.

    - The particular overload to call is determined statically (at compile time)
      rather than at runtime.

      For example,
      #+BEGIN_SRC csharp
        Asset a = new House (...);
        Foo(a);
      #+END_SRC
      This calls ~Foo(Asset)~, even though the runtime type is ~House~.

    - =TODO= Chapter 4
      If cast ~Asset~ to ~dynamic~, overload to call is diferred until runtime
      and is then based on the object's actual type:
      #+BEGIN_SRC csharp
        Asset a = new House (...);
        Foo ((dynamic)a);              // Calls `Foo(House)`
      #+END_SRC

** DONE The ~object~ Type - 97
   CLOSED: [2017-10-22 Sun 15:06]
   - ~object~ (~System.Object~) is the /ultimate base class/ for ALL types.
     Any type can be _upcast_ to ~object~.

   - /type unification/ :: =TODO=
        value types can be cast to and rom ~object~

   - boxing, unboxing :: processes that CLR performs to bridge the difference in
        semantics between /value/ and /reference/ types

*** DONE Boxing and Unboxing - 98
    CLOSED: [2017-10-22 Sun 14:46]
    #+BEGIN_SRC csharp
      int x = 9;

      object obj = x;    // Box the `int`
      int y = (int)obj;  // Unbox the `int`

    #+END_SRC

    - Unboxing requires an /explicit cast/.
      An ~InvalidCastException~ will be thrown if it fails.

**** Copying semantics of boxing and unboxing - 99
     /Boxing/ copies the /value-type instance/ into the /new object/;

     /unboxing/ copies the contents of the /object/ back into a /value-type
     instance/.

*** DONE Static and Runtime Type Checking - 99
    CLOSED: [2017-10-22 Sun 14:49]
    - C# programs are type-checked both
      + statically (at compile time)
      + at runtime (by the CLR).

    - Runtime type checking is possible because each /object/ on the heap
      internally stores a little /type token/. This token can be retrieved by
      calling the ~GetType~ method of ~object~.

*** DONE The ~GetType~ Method and ~typeof~ Operator - 99 =Re-READ=
    CLOSED: [2017-10-22 Sun 14:53]
    #+BEGIN_SRC csharp
      using System;

      public class Point { public int X, Y; }

      class Test
      {
          static void Main()
          {
              Point p = new Point();
              Console.WriteLine (p.GetType().Name); // Point
              Console.WriteLine (typeof (Point).Name); // Point
              Console.WriteLine (p.GetType() == typeof(Point)); // True
              Console.WriteLine (p.X.GetType().Name); // Int32
              Console.WriteLine (p.Y.GetType().FullName); // System.Int32
          }
      }
    #+END_SRC
*** DONE The ~ToString~ Method - 100
    CLOSED: [2017-10-22 Sun 14:59]
    - If you don't _override_ ~ToString~, the method returns the _type name_.

    - _Note_:
      #+BEGIN_SRC csharp
        int x = 1;
        string s1 = x.ToString();    // Calling on nonboxed value
        object box = x;
        string s2 = box.ToString();  // Calling on boxed value
      #+END_SRC
      + Call a method of a value type won't trigger /boxing/, and you can get
        what you want.

      + /boxing/ only occurs when you /cast/.


*** DONE Object Member Listing - 100
    CLOSED: [2017-10-22 Sun 15:06]
    =IMPORTANT=
    #+BEGIN_SRC csharp
      public class Object
      {
          public Object();

          public extern Type GetType();
          public virtual bool Equals (object obj);
          public static bool Equals (object objA, object objB);
          public static bool ReferenceEquals (object objA, object objB);
          public virtual int GetHashCode();
          public virtual string ToString();
          protected virtual void Finalize();
          protected extern object MemberwiseClone();
      }
    #+END_SRC
    =TODO=
    We describe the ~Equals~, ~ReferenceEquals~, and ~GetHashCode~ methods in
    “Equality Comparison” on page 267 in Chapter 6.

** DONE Structs - 101
   CLOSED: [2017-10-18 Wed 15:55]
   - A /struct/ is similar to a /class/, with the following key _differences_:
     + A /struct/ is a /value type/, whereas a /class/ is a /reference type/.
     + A /struct/ does NOT support /inheritance/ (other than implicitly deriving
       from object, or more precisely, ~System.ValueType~).

   - A /struct/ can have all the members a /class/ can, except the following:
     + A parameterless constructor
     + Field initializers
     + A finalizer
     + Virtual or protected members

   - A struct is appropriate when /value-type semantics/ are desirable.

   - One example of the advantages of using /value-type/:
     Creating an array of value type requires only a SINGLE heap allocation.

*** Struct Construction Semantics - 101
    - The /construction semantics/ of a /struct/ are as follows:
      + A parameterless constructor that you CANNOT override implicitly exists.
        This performs a bitwise-zeroing of its fields.

      + When you define a /struct constructor/, you must explicitly assign every
        field.

    - Example
      #+BEGIN_SRC csharp
        public struct Point
        {
            int x, y;
            public Point (int x, int y) { this.x = x; this.y = y; }
        }

        Point p1 = new Point ();          // p1.x and p1.y will be 0
        Point p2 = new Point (1, 1);     // p1.x and p1.y will be 1
      #+END_SRC

** DONE Access Modifiers - 102
   CLOSED: [2017-10-26 Thu 18:51]
   - To promote encapsulation, a type or type member may limit its accessibility
     to other types and other assemblies by adding one of _FIVE_ /access
     modifiers/ to the declaration:

     + ~public~ :: Fully accessible.

                   It's the default accessibility of the members of /enums/ and
                   /interfaces/.

     + ~internal~ :: Accessible only within the containing assembly or friend
                     assemblies.

                     It's the default accessibility for /non-nested types/.

     + ~private~ :: Accessible only within the containing type.

                    It's the default accessibility for members of a /class/ or
                    /struct/.

     + ~protected~ :: Accessible only within the containing type or subclasses.

     + ~protected internal~ :: The union of ~protected~ and ~internal~
          accessibility.

   - About the ~protected internal~:
     Eric Lippert explains it as follows: Everything is as private as possible
     by default, and _each modifier makes the thing more accessible_. So
     something that is ~protected internal~ is made MORE ACCESSIBLE in two
     ways.

   - _NOTE_:
     The CLR has the concept of the _intersection_ of ~protected~ and ~internal~
     accessibility, but C# does NOT support this.

*** DONE Examples - 103
    CLOSED: [2017-10-26 Thu 18:38]
*** TODO Friend Assemblies - 103
*** DONE Accessibility Capping - 103
    CLOSED: [2017-10-26 Thu 18:46]
    A type caps the accessibility of its declared members.

    - Example (an ~interanl~ class's public member)
      #+BEGIN_SRC csharp
        class C { public void Foo() {} }
      #+END_SRC

      ~Foo~ is effectively made ~internal~.

    - =TODO=
      A common reason ~Foo~ would be marked ~public~ is to make for easier
      refactoring, should ~C~ later be changed to ~public~.

      =From Jian=:
      if no this reason, ~public~ will be dropped, and the /access modifier/ of
      ~Foo~ is by default ~internal~, which is capped another ~internal~ from
      ~C~ and it has no real effect (~internal~ + ~internal~ = ~internal~).

*** DONE Restrictions on Access Modifiers - 104
    CLOSED: [2017-10-26 Thu 18:51]
    - When overriding a /base class function/, accessibility MUST be identical on
      the overridden function. For example:
    #+BEGIN_SRC csharp
      class BaseClass             { protected virtual void Foo() {} }
      class Subclass1 : BaseClass { protected override void Foo() {} }  // OK
      class Subclass2 : BaseClass { public override void Foo() {} }     // Error
    #+END_SRC

    - ONE _Exception_:
      When overriding a ~protected internal~ method in another assembly, in which
      case the override must simply be ~protected~.
      =From Jian= this is reasonable.

    - A /subclass/ can be _less accessible_ than a /base class/, but NOT more.

** DONE Interfaces - 104
   CLOSED: [2017-10-27 Fri 00:56]
   - An /interface/ is similar to a /class/, but it provides a specification
     _rather than_ an implementation for its members. An /interface/ is special
     in the following ways:
     + /Interface members/ are ALL _implicitly abstract_.

       In contrast,
       a /class/ can provide BOTH /abstract members/ and /concrete members/ with
       implementations.

     + A /class/ (or /struct/) can _implement_ MULTIPLE /interfaces/.

       In contrast,
       a /class/ can inherit from only a SINGLE /class/,
       and a /struct/ _CANNOT_ inherit at all (aside from deriving from
       ~System.ValueType~).

   - An /interface/ can contain ONLY
     + /methods/
     + /properties/
     + /events/ =TODO=
     + /indexers/

     , which non-coincidentally are precisely the members of a class that can be
     /abstract/.

   - /Interface members/ are _ALWAYS_
     + /implicitly public/
     + CANNOT declare an /access modifier/.

   - Example (~interface~):
     #+BEGIN_SRC csharp
       public interface IEnumerator
       {
           bool MoveNext();
           object Current { get; }
           void Reset();
       }
     #+END_SRC

   - You can /IMPLICITLY cast/ an /object/ to any /interface/ that it implements.
     #+BEGIN_SRC csharp
       internal class Countdown: IEnumerator
       {
           int count = 11;
           public bool MoveNext() => count-- > 0;
           public object Current => count;
           public void Reset() { throw new NotSupportedException(); }
       }

       IEnumerator e = new Countdown();
       while (e.MoveNext())
           Console.Write (e.Current);    // 10987653210
     #+END_SRC

   - =TODO= ???

*** DONE Extending an Interface - 105
    CLOSED: [2017-10-23 Mon 00:25]
   /Interfaces/ may derive from other interfaces.
   For instance:
   #+BEGIN_SRC csharp
     public interface IUndoable { void Undo(); }
     public interface IRndoable : IUndoable { void Undo(); }
   #+END_SRC

*** DONE Explicit Interface Implementation - 105
    CLOSED: [2017-10-26 Thu 21:05]
    - When there is a collision between member signatures of different interface,
      resolve it by /explicitly implementing/.

    - Example:
      #+BEGIN_SRC csharp
        interface I1 { void Foo(); }
        interface I2 { int Foo(); }

        public class Widget : I1, I2
        {
            public void Foo()
            {
                Console.WriteLine ("Widget's implementation of I1.Foo");
            }

            int I2.Foo()
            {
                Console.WriteLine ("Widget's implementation of I2.Foo");
                return 42;
            }
        }
      #+END_SRC

    - The _ONLY way_ to call an /explicitly implemented member/ is to _cast to
      its interface_:
      #+BEGIN_SRC csharp
        Widget w = new Widget();
        w.Foo(); // Widget's implementation of I1.Foo
        ((I1)w).Foo(); // Widget's implementation of I1.Foo
        ((I2)w).Foo(); // Widget's implementation of I2.Foo
      #+END_SRC

    - =IMPORTANT=
      Another reason to /explicitly implement interface members/ is to _hide
      members that are highly specialized and distracting_ to a type's _normal
      use case_.

      For example, a type that implement ~ISerializable~ would typically want to
      avoid flaunting its ~ISerializable~ members _unless_ explicitly cast to
      that interface.

*** DONE Implementing Interface Members Virtually - 106
    CLOSED: [2017-10-26 Thu 21:11]
    - An /implicitly implemented interface member/ is, by default, /sealed/.

    - Use ~virtual~ or ~abstract~ in the base class in order to _overridden_.
      #+BEGIN_SRC csharp
        public interface IUndoable { void Undo(); }

        public class TextBox : IUndoable
        {
            public virtual void Undo() => Console.WriteLine ("TextBox.Undo");
        }

        public class RichTextBox : TextBox
        {
            public override void Undo() => Console.WriteLine ("RichTextBox.Undo");
        }

        // Use
        RichTextBox r = new RichTextBox();
        r.Undo();               // RichTextBox.Undo
        ((IUndoable)r).Undo();  // RichTextBox.Undo
        ((TextBox)r).Undo();    // RichTextBox.Undo
      #+END_SRC

    - An /explicitly implemented interface member/ _CANNOT_ be marked ~virtual~.
      However, it can be /reimplemented/. =TODO= =???=

*** TODO Reimplementing an Interface is a Subclass - 107 =Avoid=
    - A subclass can /reimplement/ any /interface member/ already implemented by
      a /base class/.

    - /Reimplementation/ hijacks a member implementation (when called through the
      interface) and works _whether or not_ the member is ~virtual~ in the /base
      class/.

    - It also works whether a member is implemented implicitly or explicitly --
      although it works best in the latter case, as we will demonstrate

**** TODO Alternatives to interface reimplementation - 108
     - _EVEN_ with /explicit member implementation/, /interface reimplementation/
       is *problematic* for a couple of reasons:
       + The subclass has _no way_ to call the base class method.

       + The base class author may not anticipate that a method be reimplemented
         and may not allow for the potential consequences.

     - =TODO=

*** DONE Interfaces and Boxing - 108
    CLOSED: [2017-10-26 Thu 22:05]
    - Converting a /struct/ to an /interface/ causes /boxing/.

    - CALLING an /implicitly implemented member/ on a /struct/ does NOT cause
      /boxing/:

    - Example:
      #+BEGIN_SRC csharp
        interface I  { void Foo(); }
        struct S : I { public void Foo() {} }

        // ...

        S s = new S();
        s.Foo();         // No boxing

        I i = s;         // Box occurs when casting to interface.
        i.Foo();
      #+END_SRC

    - *Writing a Class Versus an Interface*
      + As a guideline:
        * Use /classes/ and /subclasses/ for types that _naturally share_ an
          implementation.

        * Use /interfaces/ for types that have _independent_ implementations.

** DONE Enums - 109
   CLOSED: [2017-10-24 Tue 21:19]
   - enum :: a special value type that lets you specify a group of named numeric
             constants.

   - Each /enum member/ has an _underlying integral value_. *By default*:
     + Underlying values are of type ~int~.
     + The constants 0, 1, 2... are automatically assigned, _in the declaration
       order_.

   - You may specify
     + an alternative integral type:
       ~public enum BorderSide : byte { Left, Right, Top, Bottom }~

     + alternative values:
       ~public enum BorderSide : byte { Left=1, Right=2, Top=10, Bottom=11 }~

   - _NOTE_:
     The compiler also lets you explicitly assign some of the enum members.
     The unassigned enum members keep incrementing from the last explicit value:
     the ~BorderSide~ example above can also be written as
     ~public enum BorderSide : byte { Left=1, Right, Top=10, Bottom }~

*** DONE Enum Conversions - 110
    CLOSED: [2017-10-24 Tue 20:52]
    - Convert an enum instance _to_ and _from_ its underlying integral value with
      an /explicit cast/.

    - Convert one enum type to another.

    - The numeric literal ~0~ is treated specially by the compiler in an ~enum~
      expression and does NOT require an /explict cast/.

      There are two reasons:
      + The first member of an enum is often used as the "default" value.
      + For /combined enum/ types, ~0~ means "no flags."
        =TODO= =???=

*** DONE Flags Enums - 111
    CLOSED: [2017-10-24 Tue 21:05]
    - You can _combine enum members_.
      To prevent ambiguities, _members of a combinable enum require explicitly
      assigned values_, typically in powers of two. For example:
      #+BEGIN_SRC csharp
        [Flags]
        public enum BorderSides { None=0, Left=1, Right=2, Top=4, Bottom=8 }

        BorderSides leftRight = BorderSides.Left | BorderSides.Right;

        if ((leftRight & BorderSides.Left) != 0)
            Console.WriteLine ("Includes Left"); // Includes Left

        string formatted = leftRight.ToString(); // "Left, Right"

        BorderSides s = BorderSides.Left;
        s |= BorderSides.Right;
        Console.WriteLine (s == leftRight); // True

        s ^= BorderSides.Right;             // Toggles BorderSides.Right
        Console.WriteLine (s);              // Left
      #+END_SRC

      If you don't apply the ~[Flags]~, you still can combine enum members, but
      when you call ~ToString~ method, you get the underlying integral value,
      rather than the names as above.

    - Convention:
      a combinable enum type is given a plural rather than singular name.

    - For convenience, you can include combination members within an enum
      declaration itself:
      #+BEGIN_SRC csharp
        [Flags]
        public enum BorderSides
        {
            None=0,
            Left=1, Right=2, Top=4, Bottom=8,
            LeftRight = Left | Right,
            TopBottom = Top | Bottom,
            All       = LeftRight | TopBottom
            // Jian doesn't like the form of `All`
        }
      #+END_SRC

*** DONE Enum Operators - 112
    CLOSED: [2017-10-24 Tue 20:55]
    - The operators that work with enums are:
      + ~=~
      + ~==~
      + ~!=~
      + ~<~
      + ~>~
      + ~<=~
      + ~>=~
      + ~+~
      + ~-~
      + ~^~
      + ~&~
      + ~|~
      + ~~~
      + ~+=~
      + ~-=~
      + ~++~
      + ~--~
      + ~sizeof~

    - The /bitwise/, /arithmetic/, and /comparison/ operators return the result
      of processing the underlying integral values.

    - /Addition/ is permitted between an enum and an integral type,
      but _NOT between two enums_.

*** DONE Type-Safety Issues - 112
    CLOSED: [2017-10-24 Tue 21:19]
    - Solutions (for non-flagged enums):
      + check its value -- in the last branch do
        ~else throw new ArgumentException ("Invalid BorderSide: " + side, "side");~

      + ~Enum.IsDefined (typeof (BorderSide), beTested)~

    - However, the concise ~Enum.IsDefined~ doesn't work for /flagged enums/.

      A helper function (use a trick dependent on the behavior of
      ~Enum.ToString()~.
      #+BEGIN_SRC csharp
        static bool IsFlagDefined (Enum e)
        {
            decimal d;
            return !decimal.TryParse(e.ToString(), out d);
        }

        [Flags]
        public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }

        static void Main()
        {
            for (int i = 0; i <= 16; i++)
            {
                BorderSides side = (BorderSides) i;
                Console.WriteLine (IsFlagDefined (side) + " " + side);
            }
        }
      #+END_SRC

** DONE Nested Types - 113
   CLOSED: [2017-10-26 Thu 01:19]
   - nested types :: types that declared within the scope of another type.

   - For example:
     #+BEGIN_SRC csharp
       public class TopLevel
       {
           public class Nested { }               // Nested class
           public enum Color { Red, Blue, Tan }  // Nested enum
       }
     #+END_SRC

   - A /nested type/ has the following features:
     + It can access everything the enclosing type can access, including its
       /private members/.

     + It can be declared with the full range of access modifiers, rather than
       just ~public~ and ~internal~. =TODO= =???=

     + The default accessibility for a /nested type/ is ~private~.

     + Qualification is required from the outside of the enclosing type.
       For example: ~TopLevel.Color color = TopLevel.Color.Red;~

   - The /nested types/ enclosing types:
     + ~class~
     + ~struct~

   - The /nested types/ can be:
     + ~classes~
     + ~structs~
     + ~interfaces~
     + ~delegates~
     + ~enums~

   - _NOTE_:
     + If the sole reason for using a /nested type/ is to avoid cluttering a
       namespace with too many types, consider using a nested namespace instead.

     + A /nested type/ should be used because of
       * its stronger access control restrictions
         or
       * when the nested class must access private members of the containing class.

** DONE Generics - 114
   CLOSED: [2017-10-24 Tue 20:33]
   - C# has TWO separate mechanisms for writing code that is reusable across
     different types:
     + inheritance
     + generics.

   - /inheritance/ expresses _reusability_ with a /base type/.

     /generics/ express _reusability_ with a "template" that contains "placeholder"
     types.

     /Generics/, when compared to /inheritance/, can
     + INCREASE /type safety/
     + REDUCE /casting/ and /boxing/.

*** DONE Generic Types - 114
    CLOSED: [2017-10-24 Tue 19:07]
    - /type parameters/ (placeholder types) and /type arguments/

    - Example:
      #+BEGIN_SRC csharp
        public class Stack<T>
        {
            int position;
            T[] data = new T[100];
            public void Push (T obj) => data[position++] = obj;
            public T Pop () => data[--position];
        }

        // Use `Stack`
        var stack = new Stack<int>();
        stack.Push (5);
        stack.Push (10);
        int x = stack.Pop();  // x is 10
        int y = stack.Pop();  // y is 5
      #+END_SRC

    - Generic type systhesis (take /type argument(s)/) occurs at runtime.

    - Technically, we way the ~Stack<T>~ is an /open type/,
      whereas ~Stack<int>~ is a /closed type/.

      At runtime, all /generic type/ instances are closed.

*** DONE Why Generics Exist - 115
    CLOSED: [2017-10-24 Tue 19:13]
    Use the ~Stack~ example:
    If we create a ~ObjectStack~, the object inside it is NOT homogeneous if in
    a fine-grained point of view.

    The compiler cannot do a fine-grained type check.


    Use it is also painful: do a lot of /boxing/ and /downcasting/.

*** DONE Generic Methods - 116
    CLOSED: [2017-10-24 Tue 19:23]
    - generic method :: a method that _declares_ (NOT ONLY use) type parameters
                        within the signature.

    - Example: 
      #+BEGIN_SRC csharp
        static void Swap<T> (ref T a, ref T b)
        {
            T temp = a;
            a = b;
            b = temp;
        }
      #+END_SRC

    - A method is a /generic method/ ONLY when it _introduces_ type parameters
      (with the angle bracket syntax).

      Thus, the ~Pop~ method of ~Stack<T>~ is NOT a /generic method/ -- it just
      uses a existing type parameter.

    - /Methods/ and /types/ are the ONLY constructs that can introduce type
      parameters.

      /Properties/, /indexers/, /events/, /fields/, /constructors/, /operators/,
      and so on CANNOT declare /type parameters/.

      + NOT /generic methods/ but interesting:
        An indexer that returns a generic item
        #+BEGIN_SRC csharp
          public T this [int index] => data [index];
        #+END_SRC

      + Constructors can partake in existing type parameters, but NOT _introduce_
        them:
        #+BEGIN_SRC csharp
          public Stack<T>() {}    // Illegal
        #+END_SRC

*** DONE Declaring Type Parameters - 117
    CLOSED: [2017-10-24 Tue 19:28]
    - /Type parameters/ can be introduced in the declaration of
      + /classes/
      + /structs/
      + /interfaces/
      + /delegates/ (covered in Chapter 4)
      + methods

    - _Generic type names_ and _method names_ can be overloaded as long as the
      NUMBER of /type parameters/ is different.

    - _NOTE_:
      Convention:
      + Single type parameter usually use ~T~
      + Multiple type parameters usually use names which _prefixed_ ~T~.

*** DONE ~typeof~ and Unbound Generic Types - 118
    CLOSED: [2017-10-24 Tue 19:36]
    - /Unbound generic types/ can exist at runtime -- purely as a ~Type~ object.
      #+BEGIN_SRC csharp
        class A<T> {}
        class A<T1, T2> {}

        // ...

        Type a1 = typeof (A<>);
        Type a2 = typeof (A<,>);   // Use commas to indicate multiple type args
      #+END_SRC

      =TODO= =IMPORTANT=
      Open generic types are used in conjunction with the Reflection API (Chapter 19).

    - You can also use ~typeof~ operator to specify a closed type:
      ~Type a3 = typeof (A<int, int>);~

      or an open type (which is closed at runtime):
      ~class B<T> { void X() { Type t = typeof (T); } }~

*** DONE The ~default~ Generic Value - 118
    CLOSED: [2017-10-24 Tue 19:38]
    Use ~defalut(T)~ to get the default value for a generic type parameter.
    - ~null~ for /reference types/.
    - bitwise-zeroing value for /value types/.

*** DONE Generic Constraints - 118 - =RE-READ=
    CLOSED: [2017-10-24 Tue 19:50]
    - Possible constraints:
      + ~where T : base-class   \slash{}\slash{} Base-class constraint~
      + ~where T : interface    \slash{}\slash{} Interface constraint~
      + ~where T : class        \slash{}\slash{} Reference-type constraint~
      + ~where T : struct       \slash{}\slash{} Value-type constraint (excludes Nullable types)~
      + ~where T : new()        \slash{}\slash{} Parameterless constructor constraint~
      + ~where T : T            \slash{}\slash{} Naked type constraint~

    - Example:

      Requirement:
      ~T~ must be derived from ~SomeClass~ (identical is OK).
      ~U~ must provide a parameterless constructor.

      #+BEGIN_SRC csharp
        class SomeClass {}
        interface Interface1 {}

        class GenericClass<T, U>
            where T : SomeClass, Interface1
            where U : new()
        {
            // ...
        }
      #+END_SRC

    - /Constraints/ can be applied wherever /type parameters/ are defined, in both
      + methods
      + type definitions

*** DONE Subclassing Generic Types - 120
    CLOSED: [2017-10-24 Tue 19:53]
    #+BEGIN_SRC csharp
      class Stack<T> { ... }

      class SpecialStack<T> : Stack<T> { ... }
      class IntStack : Stack<int> { ... }

      class List<T> { ... }
      class KeyedList<T, TKey> : List<T> { ... }
    #+END_SRC

*** DONE Self-referencing Generic Declarations - 120 =RE-READ=
    CLOSED: [2017-10-24 Tue 20:06]
    Page 120 CODE

*** DONE Static Data - 121
    CLOSED: [2017-10-24 Tue 20:07]
    #+BEGIN_SRC csharp
      class Bob<T> { public static int Count; }

      class Test
      {
          static void Main()
          {
              Console.WriteLine (++Bob<int>.Count);    // 1
              Console.WriteLine (++Bob<int>.Count);    // 2
              Console.WriteLine (++Bob<string>.Count);    // 1
              Console.WriteLine (++Bob<object>.Count); // 1
          }
      }
    #+END_SRC

*** DONE Type Parameters and Conversions - 121 =RE-READ=
    CLOSED: [2017-10-24 Tue 20:12]
    - C#'s /cast operator/ can perform several kinds of conversion, including:
      + Numeric conversion
      + Reference conversion
      + Boxing/unboxing conversion
      + Custom conversion (via operator overloading; see Chapter 4)

    - The decision as to which kind of conversion will take place happens at
      /compile time/, based on the known types of the operands.

    - 

*** DONE Covariance - 122 =RE-READ=
    CLOSED: [2017-10-24 Tue 20:32]
**** Variance is not automatic - 123
**** DONE Arrays - 123
     CLOSED: [2017-10-24 Tue 20:22]
     For historical reasons, array types support /covariance/.
     #+BEGIN_SRC csharp
       Bear[] bears = new Bear[3];
       Animal[] animals = bears;   // OK due to covariance

       // Even though `animal` is of type `Animal[]`, its elements are still bears, and
       // you cannot assign a `Camel` object to a `Bear` typed variable.
       animals[0] = new Camel();   // Runtime error
     #+END_SRC

**** Declaring a covariant type parameter - 124

*** DONE Contravariance - 125 =RE-READ=
    CLOSED: [2017-10-24 Tue 20:33]
*** DONE C# Generics Versus C++ Templates - 126 =RE-READ=
    CLOSED: [2017-10-24 Tue 20:33]

* TODO 4. Advanced C# - 127
** TODO Delegates - 127
   - delegate :: an object that knows how to call a method.

   - A /delegate type/ defines the kind of method that delegate instances can
     call.
     =TODO=
     Specifically, it defines the /method's return type/ and its /parameter
     types/.

   - Example:
     #+BEGIN_SRC csharp
       // Defines a delegate type
       delegate int Transformer (int x);

       class Test
       {
           static void Main()
           {
               Transformer t = Square;       // Create delegate instance
               int result = t(3);            // Invoke delegate
               Console.WriteLine (result);   // 9
           }

           // `Transformer` is compatible with ANY method with an `int` return type and
           // a single `int` parameter, such as this:
           static int Square (int x) => x * x;
       }
     #+END_SRC


     + ~Transformer t = Square;~ is shorthand for
       ~Transformer t = new Transformer (Square);~

     + ~t(3)~ is shorthand for
       ~t.Invoke(3)~


   - /delegate/ helps decoupling the caller from the target method.

   - _NOTE_:
     A /delegate/ is similar to a /callback/, a general term that captures
     constructs such as C /function pointers/.

*** DONE Writing Plug-in Methods with Delegates - 128
    CLOSED: [2017-10-22 Sun 23:49]
    - A /delegate/ variable is assigned a method _at runtime_.
      This is useful for writing /plug-in methods/.

    - The ~Transformer~ method has a /delegate parameter/, for specifying a
      plug-in transform.

    - How to pass a /delegate/:
      #+BEGIN_SRC csharp
        public delegate int Transformer (int x);

        class Util
        {
            public static void Transform (int[] values, Transformer t)
            {
                for (int i = 0; i < values.Length; i++)
                {
                    values[i] = t (values[i]);
                }
            }
        }

        class Test
        {
            static void Main()
            {
                int[] values = { 1, 2, 3 };
                Util.Transform (values, Square);
                foreach (int i in values)
                    Console.Write (i + "  ");
            }

            static int Square (int x) => x * x;
        }
      #+END_SRC

*** DONE Multicast Delegates - 129
    CLOSED: [2017-10-23 Mon 00:07]
    - All /delegate instances/ have multicast capability. This means that a
      /delegate instance/ can reference NOT just a SINGLE target method, but also
      a list of target methods. The ~+~ and ~+=~ operators combine delegate
      instances.

    - ~null~ related:
      #+BEGIN_SRC csharp
        SomeDelegate d = null;
        d += SomeMethod1;        // Equivalent (when d is null) to d = SomeMethod1;

        d -= SomeMethod1;        // Equivalent to d = null;
      #+END_SRC

    - _NOTE_:
      /Delegates/ are _immutable_, so when you call ~+=~ or ~-=~, you're in fact
      creating a _new_ /delegate instance/ and assigning it to the existing
      variable.

    - If a multicast delegate has a nonvoid return type, the caller receives the
      return value from the last method to be invoked.

      The preceding methods are still called, but their return values are
      _discarded_. In most scenarios in which /multicast delegates/ are used,
      they have ~void~ return types, so this subtlety does not arise.

    - _NOTE_:
      + ~System.Delegate~ <- ~System.MulticastDelegate~ <- ALL /delegate/'s.

      + ~+~, ~-~, ~+=~, and ~-=~ operations made on a /delegate/ to the _static_
        ~Combine~ and ~Remove~ methods of the ~System.Delegate~ class.

**** Multicast delegate example - 130
     #+BEGIN_SRC csharp
       public delegate void ProgressReporter (int percentComplete);

       public class Util
       {
           public static void HardWork (ProgressReporter p)
           {
               for (int i = 0; i < 10; i++)
               {
                   p (i * 10); // Invoke delegate
                   System.Threading.Thread.Sleep (100); // Simulate hard work
               }
           }
       }

       class Test
       {
           static void Main()
           {
               ProgressReporter p = WriteProgressToConsole;
               p += WriteProgressToFile;
               Util.HardWork (p);
           }

           static void WriteProgressToConsole (int percentComplete)
               => Console.WriteLine (percentComplete);

           static void WriteProgressToFile (int percentComplete)
               => System.IO.File.WriteAllText ("progress.txt",
                                               percentComplete.ToString());
       }
     #+END_SRC

*** DONE Instance Versus Static Method Targets - 130
    CLOSED: [2017-10-23 Mon 00:12]
    - delegate object, the latter must maintain a reference not only to the
      method, but also to the instance to which the method belongs. The
      System.Delegate class’s Target property represents this instance (and will
      be null for a delegate referencing a static method).

    - Example:
      #+BEGIN_SRC csharp
        public delegate void ProgressReporter (int percentComplete);

        class Test
        {
            static void Main()
            {
                X x = new X();
                ProgressReporter p = x.InstanceProgress;
                p(99); // 99
                Console.WriteLine (p.Target == x); // True
                Console.WriteLine (p.Method); // Void InstanceProgress(Int32)
            }
        }

        class X
        {
            public void InstanceProgress (int percentComplete)
                => Console.WriteLine (percentComplete);
        }
      #+END_SRC

*** DONE Generic Delegate Types - 131
    CLOSED: [2017-10-27 Fri 02:38]
    Example:
    #+BEGIN_SRC csharp
        public delegate T Transformer<T> (T arg);

        public class Util
        {
            public static void Transform<T> (T[] values, Transformer<T> t)
            {
                for (int i = 0; i < values.Length; i++)
                    values[i] = t (values[i]);
            }
        }

        class Test
        {
            static void Main()
            {
                int [] values = { 1, 2, 3 };
                Util.Transform (values, Square);  // Hook in Square
                foreach (int i in values)
                    Console.Write (i + "  ");     // 1  4  9
            }
            static int Square (int x) => x * x;
        }
      #+END_SRC

*** DONE The ~Func~ and ~Action~ Delegates - 131
    CLOSED: [2017-10-27 Fri 02:43]
    - ~Func~ and ~Action~ delegates are defined in the ~System~ namespace.
      #+BEGIN_SRC csharp
        delegate TResult Func <out TResult> ();
        delegate TResult Func <in T, out TResult> (T arg);
        delegate TResult Func <in T1, in T2, out TResult> (T1 arg1, T2 arg2);
        // ... and so on, up to T16

        delegate void Action ();
        delegate void Action <in T> (T arg);
        delegate void Action <in T1, in T2> (T1 arg1, T2 arg2);
        // ... and so on, up to T16
      #+END_SRC

    - Use ~Func~ to re-write the example in the last section:
      #+BEGIN_SRC csharp
        public static void Transform<T> (T[] values, Func<T,T> transformer)
        {
            for (int i = 0; i < values.Length; i++)
                values[i] = transformer (values[i]);
        }
      #+END_SRC

    - _NOTE_:
      Prior to Framework 2.0, the ~Func~ and ~Action~ delegates did _NOT exist_
      (because generics did not exist).

      It's for this historical reason that much of the Framework uses custom
      delegate types rather than ~Func~ and ~Action~.

*** DONE Delegates Versus Interfaces - 132
    CLOSED: [2017-10-27 Fri 02:56]
    - A /delegate design/ may be a _BETTER_ choice than an /interface design/ if
      one or more of these conditions are true:
      + The interface defines only a single method.
      + Multicast capability is needed.
      + The subscriber needs to implement the interface multiple times.

    - Though it seems that use /interface design/ we can implement the
      ~Transform~ example in the sections before.
      #+BEGIN_SRC csharp
        public interface ITransformer
        {
            int Transform (int x);
        }

        public class Util
        {
            public static void TransformAll (int[] values, ITransformer t)
            {
                for (int i = 0; i < values.Length; i++)
                    values[i] = t.Transform (values[i]);
            }
        }

        class Squarer : ITransformer
        {
            public int Transform (int x) => x * x;
        }


        class Test
        {
            static void Main()
            {
                int[] values = { 1, 2, 3 };
                Util.TransformAll (values, new Squarer());
                foreach (int i in values)
                    Console.WriteLine (i);
            }
        }
      #+END_SRC


      However, if we need NOT ONLY ~Squarer~ but also ~Cuber~, we have to
      implement the interface multiple times:
      #+BEGIN_SRC csharp
        class Squarer : ITransformer
        {
            public int Transform (int x) => x * x;
        }

        class Cuber : ITransformer
        {
            public int Transform (int x) => x * x * x;
        }


        class Test
        {
            static void Main()
            {
                int[] values = { 1, 2, 3 };
                Util.TransformAll (values, new Squarer());
                foreach (int i in values)
                    Console.WriteLine (i);

                Util.TransformAll (values, new Cuber());
                foreach (int i in values)
                    Console.WriteLine (i);
            }
        }
      #+END_SRC

*** TODO Delegate Compatibility - 133
**** Type compatibility - 133
**** Parameter compatibility - 134
**** Return type compatibility - 135
**** Generic delegate type parameter variance - 135

** TODO Events - 136
   - When using /delegates/, two emergent roles commonly appear:
     + broadcaster :: a type that contains a /delegate/ field.
       and
     + subscriber :: the method target recipients.

   - The /broadcaster/ decides when to broadcast by invoking the /delegate/.

   - A /subscriber/ decides when to start and stop listening by calling ~+=~ and
     ~-=~ on the broadcaster's /delegate/.

     =TODO=
     A subscriber does NOT know about, or interfere with, other subscribers.

   - events :: language features that formalizes the pattern above.

   - An /event/ is a construct that exposes just the subset of /delegate/
     features required for the _broadcaster/subscriber model_.

     The main purpose of /events/ is to prevent /subscribers/ from interfering
     with one another.

   - Example:
     #+BEGIN_SRC csharp
       // Delegate definition
       public delegate void PriceChangedHandler (decimal oldPrice,
                                                 decimal newPrice);

       public class Broadcaster
       {
           // Event declaration
           public event PriceChangedHandler PriceChanged;
       }
     #+END_SRC

     + Code _within_ the ~Broadcaster~ type has full access to ~PriceChanged~ and
       can treat it as a delegate.

     + Code _outside_ of ~Broadcaster~ can ONLY perform ~+=~ and ~-=~ operations
       on the ~PriceChanged~ event.

*** TODO Standard Event Pattern - 138
*** DONE Event Accessors - 141
    CLOSED: [2017-10-27 Fri 03:28]
    - event's accessors :: the implementations of its ~+=~ and ~-=~ functions.

    - By default, /event's accessors/ are implemented implicitly by the compiler.
      For example, ~public event EventHandler PriceChanged;~ will be converted to:
      + A private delegate field

      + A public pair of event accessor functions (~add_PriceChanged~ and
        ~remove_PriceChanged~), whose implementations forward the ~+=~ and ~-=~
        operations to the /private delegate field/.

    - Manually implement the convertion above will take over this process from
      the compiler:
      #+BEGIN_SRC csharp
        private EventHandler priceChanged;    // Declare a private delegate

        public event EventHandler PriceChanged
        {
            add    { priceChanged += value; }
            remove { priceChanged -= value; }
        }
      #+END_SRC
      This example is _functionally identical_ to C#'s default accessor
      implementation (EXCEPT that C# also ensures thread safety around updating
      the /delegate/ via a lock-free compare-and-swap algorithm -- see
      http://albahari.com/threading).

    - With explicit event accessors, you can apply more complex strategies to the
      storage and access of the underlying delegate. There are three scenarios
      where this is useful: =TODO= =???=
      + When the event accessors are merely relays for another class that is
        broadcasting the event.

      + When the class exposes a large number of events, where most of the time
        very few subscribers exist, such as a Windows control. In such cases, it
        is better to store the subscriber’s delegate instances in a dictionary,
        since a dictionary will contain less storage overhead than dozens of
        null delegate field references.

      + When explicitly implementing an interface that declares an event.
        #+BEGIN_SRC csharp
          public interface IFoo { event EventHandler Ev; }

          class Foo : IFoo
          {
              private EventHandler ev;
              event EventHandler IFoo.Ev
              {
                  add { ev += value; }
                  remove { ev -= value; }
              }
          }
        #+END_SRC

    - _NOTE_:
      The ~add~ and ~remove~ parts of an /event/ are compiled to ~add_XXX~ and
      ~remove_XXX~ methods.

*** DONE Event Modifiers - 142
    CLOSED: [2017-10-27 Fri 03:12]
    - Like /methods/, /events/ can be ~virtual~, ~overridden~, ~abstract~, or
      ~sealed~.

    - Events can also be ~static~:
      #+BEGIN_SRC csharp
        public class Foo
        {
            public static event EventHandler<EventArgs> StaticEvent;
            public virtual event EventHandler<EventArgs> VirtualEvent;
        }
      #+END_SRC

** DONE Lambda Expressions - 143
   CLOSED: [2017-10-27 Fri 03:58]
   - lambda expression :: an /unnamed method/ written in place of a /delegate
        instance/.

   - The compiler immediately converts the lambda expression to either:
     + A delegate instance.

     + An /expression tree/, of type ~Expression<TDelegate>~, representing the code
       inside the lambda expression in a /traversable object model/. This allows
       the lambda expression to be interpreted later at runtime (see “Building
       Query Expressions” on page 385 in Chapter 8). =TODO=

   - A lambda expression has the following form:
     ~(parameters) => expression-or-statement-block~
     If only single parameter, the parentheses can be omitted.

   - Each parameter of the lambda expression _corresponds_ to a /delegate/
     parameter.

     The type of the expression (which may be ~void~) corresponds to the return
     type of the /delegate/.

   - Lambda expressions are used most commonly with the ~Func~ and ~Action~
     /delegates/.

   - /Lambda expressions/ were introduced in C# 3.0.

*** DONE Explicitly Specifying Lambda Parameter Types - 144
    CLOSED: [2017-10-27 Fri 03:40]
    When cannot infer the type(s) of /lambda parameters/, write it out
    explicitly.

    Example
    #+BEGIN_SRC csharp
      void Foo<T> (T x)         {}
      void Bar<T> (Action<T> a) {}

      Bar (x => Foo (x));   // Fail to compile: What type is x?

      // Fix the above compile error
      // #1
      Bar ((int x) => Foo(x));

      // #2
      Bar<int> (x => Foo(x));  // Specify type parameter for Bar

      // #3
      Bar<int> (Foo);         // As above, but with method group
      // TODO: METHOD GOURP???
    #+END_SRC

*** DONE Capturing Outer Variables - 144
    CLOSED: [2017-10-27 Fri 03:58]
    - =From Jian= I should use ~readonly~ ~factor~!!!
      #+BEGIN_SRC csharp
        int factor = 2;
        Func<int, int> multiplier = n => n * factor;
        factor = 10;
        Console.WriteLine (multiplier (3)); // 30
      #+END_SRC

    - /Capturing/ is internally implemented by "hoisting" the _captured
      variables_ into _fields of a private class_. When the method is called, the
      class is instantiated and lifetime-bound to the delegate instance.

**** Capturing iteration variables - 145
     - C#'s lambda expression captures reference, rather than it value.
       =From Jian= I don't like this.
       #+BEGIN_SRC csharp
         Action[] actions = new Action[3];

         for (int i = 0; i < 3; i++)
             actions [i] = () => Console.Write (i);

         foreach (Action a in actions) a(); // 333
       #+END_SRC

     - _NOTE_:
       Before C# 5.0 the behavior of ~foreach~ variable is like variable in a
       for loop. This has been fixed -- now ~foreach~ is a real iteration.
       #+BEGIN_SRC csharp
         Action[] actions = new Action[3];
         int i = 0;

         foreach (char c in "abc")
             actions [i++] = () => Console.Write (c);

         foreach (Action a in actions) a(); // ccc in C# 4.0
                                            // abc in C# 5.0+
       #+END_SRC

     - _NOTE_:
       =From Jian= Here I re-write something from the book.
       YES! this is a breaking change. However, this is a breaking change that
       correct a bad design and indicate an undetected bug. This also gives us a
       lesson that even if your code currently works well, it might be wrong if
       you code didn't follow the right semantics (~foreach~ is a kind of
       iteration rather than loop).

** DONE Anonymous Methods - 147
   CLOSED: [2017-10-27 Fri 04:07]
   /Anonymous methods/ are a C# 2.0 feature that has been mostly subsumed by C#
   3.0 lambda expressions.

   - An /anonymous method/ is like a /lambda expression/, but it _LACKS_ the
     following features:
     + Implicitly typed parameters.
     + Expression syntax (an anonymous method must always be a statement block).
     + The ability to compile to an expression tree by assigning to
       ~Expression<T>~.

   - Syntax:
     #+BEGIN_SRC csharp
       delegate int Transformer (int i);

       // This is a method
       Transformer sqr = delegate (int x) { return x * x; };
       // // It lambda expression form (appearence on changes in the RHS):
       // Transformer sqr = x => x * x;

       Console.WriteLine (sqr(3));
     #+END_SRC

   - /Anonymous methods/ capture outer variables _in the same way_ /lambda
     expressions/ do.

   - _NOTE_: =TODO= =???= =???=
     A _UNIQUE_ feature of /anonymous methods/ is that you can _omit_ the
     parameter declaration entirely -- even if the delegate expects it. This can
     be useful in declaring events with a default empty handler:
     ~public event EventHandler Clicked = delegate { };~
     This avoids the need for a null check before firing the event. =TODO= =???=
     The following is also legal:
     #+BEGIN_SRC csharp
       // Notice that we omit the parameters:
       Clicked += delegate { Console.WriteLine ("clicked"); };
     #+END_SRC

** TODO ~try~ Statements and Exceptions - 148
*** The ~catch~ Clause - 149
*** The ~finally~ Block - 151
**** The ~using~ statement - 152

*** Throwing Exceptions - 152
**** Rethrowing an exception - 153

*** Key Properties of ~System.Exception~ - 154
*** Common Exception Types - 154
*** The TryXXX Method Pattern - 155
*** Alternatives to Exceptions - 156
** TODO Enumeration and Iterators - 156
*** Enumeration - 156
*** Collection Initializers - 157
*** Iterators - 158
*** Iterator Semantics - 159
**** ~yield break~ - 160
**** Iterators and ~try/catch/finally~ blocks - 160

*** Composing Sequences - 161

** TODO Nullable Types - 162
*** ~Nullable<T>~ struct - 162
*** Implicit and explicit nullable conversions - 163
*** Boxing and unboxing nullable values - 163
*** Operator Lifting - 163
**** Equality operators (~==~ and ~!=~) - 164
**** Relational operators (~<~, ~<=~, ~>=~, ~>~) - 165
**** All other operators (~+~, ~−~, ~*~, ~/~, ~%~, ~&~, ~|~, ~^~, ~\lt{}\lt{}~, ~\gt{}\gt{}~, ~+~, ~++~, ~--~, ~!~, ~~~) - 165
**** Mixing nullable and non-nullable operators - 165

*** bool? with ~&~ and ~|~ Operators - 165
*** Nullable Types & Null Operators - 166
*** Scenarios for Nullable Types - 166
*** Alternatives to Nullable Types - 167

** TODO Operator Overloading - 168
*** Operator Functions - 168
*** Overloading Equality and Comparison Operators - 169
*** Custom Implicit and Explicit Conversions - 170
*** Overloading true and false - 171

** TODO Extension Methods - 171
*** Extension Method Chaining - 172
*** Ambiguity and Resolution - 173
**** Namespaces - 173
**** Extension methods versus instance methods - 173
**** Extension methods versus extension methods - 174

** TODO Anonymous Types - 174
** TODO Dynamic Binding - 175
*** Static Binding Versus Dynamic Binding - 176
*** Custom Binding - 177
*** Language Binding - 177
*** RuntimeBinderException - 178
*** Runtime Representation of Dynamic - 178
*** Dynamic Conversions - 179
*** var Versus dynamic - 180
*** Dynamic Expressions - 180
*** Dynamic Calls Without Dynamic Receivers - 181
*** Static Types in Dynamic Expressions - 182
*** Uncallable Functions - 182

** TODO Attributes - 183
*** Attribute Classes - 183
*** Named and Positional Attribute Parameters - 184
*** Attribute Targets - 184
*** Specifying Multiple Attributes - 185

** TODO Caller Info Attributes (C# - 5) - 185
** TODO Unsafe Code and Pointers - 187
*** Pointer Basics - 187
*** Unsafe Code - 187
*** The fixed Statement - 187
*** The Pointer-to-Member Operator - 188
*** Arrays - 189
**** The stackalloc keyword - 189
**** Fixed-size buffers - 189

*** ~void*~ - 189
*** Pointers to Unmanaged Code - 190

** TODO Preprocessor Directives - 190
*** Conditional Attributes - 191
*** Pragma Warning - 192

** TODO XML Documentation - 193
*** Standard XML Documentation Tags - 193
*** User-Defined Tags - 195
*** Type or Member Cross-References - 196

* TODO 5. Framework Overview - 199
** TODO The CLR and Core Framework - 202
*** System Types - 202
*** Text Processing - 202
*** Collections - 202
*** Queries - 202
*** XML - 203
*** Diagnostics and Code Contracts - 203
*** Concurrency and Asynchrony - 203
*** Streams and I/O - 204
*** Networking - 204
*** Serialization - 204
*** Assemblies, Reflection, and Attributes - 204
*** Dynamic Programming - 205
*** Security - 205
*** Advanced Threading - 205
*** Parallel Programming - 205
*** Application Domains - 206
*** Native and COM Interoperability - 206

** TODO Applied Technologies - 206
*** User Interface Technologies - 206
**** ASP.NET - 206
**** Windows Presentation Foundation (WPF) - 207
**** Windows Forms - 208
**** Windows RT and Xamarin - 208
**** Silverlight - 209

*** Backend Technologies - 209
**** ADO.NET - 209
**** Windows Workflow - 210
**** COM+ and MSMQ - 210

*** Distributed System Technologies - 210
**** Windows Communication Foundation (WCF) - 210
**** Web API - 211
**** Remoting and .ASMX Web Services - 211
* TODO 6. Framework Fundamentals - 213
** TODO String and Text Handling - 213
*** Char - 213
*** String - 215
**** Constructing strings - 215
**** Null and empty strings - 216
**** Accessing characters within a string - 216
**** Searching within strings - 216
**** Manipulating strings - 217
**** Splitting and joining strings - 218
**** String.Format and composite format strings - 218

*** Comparing Strings - 219
**** Ordinal versus culture comparison - 220
**** String equality comparison - 220
**** String-order comparison - 221

*** StringBuilder - 222
*** Text Encodings and Unicode - 223
**** Obtaining an Encoding object - 224
**** Encoding for file and stream I/O - 225
**** Encoding to byte arrays - 225
**** UTF-16 and surrogate pairs - 226

** TODO Dates and Times - 226
*** TimeSpan - 227
*** DateTime and DateTimeOffset - 228
**** Choosing between DateTime and DateTimeOffset - 228
**** Constructing a DateTime - 229
**** Constructing a DateTimeOffset - 230
**** The current DateTime/DateTimeOffset - 231
**** Working with dates and times - 232
**** Formatting and parsing - 233
**** Null DateTime and DateTimeOffset values - 233

** TODO Dates and Time Zones - 234
*** DateTime and Time Zones - 234
*** DateTimeOffset and Time Zones - 235
*** TimeZone and TimeZoneInfo - 235
**** TimeZone - 235
**** TimeZoneInfo - 235

*** Daylight Saving Time and DateTime - 239

** TODO Formatting and Parsing - 240
*** ToString and Parse - 241
*** Format Providers - 241
**** Format providers and CultureInfo - 242
**** Using NumberFormatInfo or DateTimeFormatInfo - 243
**** Composite formatting - 243
**** Parsing with format providers - 244
**** IFormatProvider and ICustomFormatter - 244

** TODO Standard Format Strings and Parsing Flags - 246
*** Numeric Format Strings - 246
*** NumberStyles - 248
*** Date/Time Format Strings - 250
**** Parsing and misparsing DateTimes - 251

*** DateTimeStyles - 252
*** Enum Format Strings - 253

** TODO Other Conversion Mechanisms - 253
*** Convert - 253
**** Rounding real-to-integral conversions - 254
**** Parsing numbers in base 2, 8, and 16 - 254
**** Dynamic conversions - 254
**** Base 64 conversions - 255

*** XmlConvert - 255
*** Type Converters - 256
*** BitConverter - 256

** TODO Globalization - 257
*** Globalization Checklist - 257
*** Testing 258

** TODO Working with Numbers - 258
*** Conversions - 258
*** Math - 259
*** BigInteger - 259
*** Complex - 260
*** Random - 261

** TODO Enums - 262
*** Enum Conversions - 263
**** Enum to integral conversions - 263
**** Integral-to-enum conversions - 264
**** String conversions - 264

*** Enumerating Enum Values - 265
*** How Enums Work - 265

** TODO Tuples - 266
*** Comparing Tuples - 266

** TODO The Guid Struct - 267
** TODO Equality Comparison - 267
*** Value Versus Referential Equality - 268
*** Standard Equality Protocols - 269
**** ~==~ and ~!=~ - 69
**** The virtual ~Object.Equals~ method - 269
**** The static ~object.Equals~ method - 270
**** The static ~object.ReferenceEquals~ method - 271
**** The ~IEquatable<T>~ interface - 272
**** When ~Equals~ and ~==~ are not equal - 272

*** Equality and Custom Types - 269
**** Changing the meaning of equality - 273
**** Speeding up equality comparisons with structs - 274
**** How to override equality semantics - 274
**** Overriding GetHashCode - 274
**** Overriding Equals - 275
**** Overloading ~==~ and ~!=~ - 276
**** Implementing ~IEquatable<T>~ - 276
**** An example: The Area struct - 276
**** Pluggable equality comparers - 277

** TODO Order Comparison - 278
*** ~IComparable~ - 278
**** ~IComparable~ versus ~Equals~ - 279

*** ~<~ and ~>~ - 279
*** Implementing the ~IComparable~ Interfaces - 280

** TODO Utility Classes - 281
*** Console - 281
*** Environment - 282
*** Process - 282
*** AppContext - 284

* TODO 7. Collections - 285
** TODO Enumeration - 285
*** ~IEnumerable~ and ~IEnumerator~ - 286
*** ~IEnumerable<T>~ and ~IEnumerator<T>~ - 287
**** ~IEnumerable<T>~ and ~IDisposable~ - 288

*** Implementing the Enumeration Interfaces - 289

** TODO The ~ICollection~ and ~IList~ Interfaces - 293
*** ~ICollection<T>~ and ~ICollection~ - 294
*** ~IList<T>~ and ~IList~ - 295
*** ~IReadOnlyList<T>~ - 296

** TODO The Array Class - 297
*** Construction and Indexing - 299
*** Enumeration - 301
*** Length and Rank - 301
*** Searching - 302
*** Sorting - 303
*** Reversing Elements - 304
*** Copying - 305
*** Converting and Resizing - 305

** TODO Lists, Queues, Stacks, and Sets - 305
*** List<T> and ArrayList - 306
*** LinkedList<T> - 308
*** Queue<T> and Queue - 310
*** Stack<T> and Stack - 311
*** BitArray - 312
*** HashSet<T> and SortedSet<T> - 312

** TODO Dictionaries - 314
*** ~IDictionary<TKey,TValue>~ - 315
*** ~IDictionary~ - 316
*** ~Dictionary<TKey,TValue>~ and ~Hashtable~ - 317
*** ~OrderedDictionary~ - 318
*** ~ListDictionary~ and ~HybridDictionary~ - 318
*** Sorted Dictionaries - 319

** TODO Customizable Collections and Proxies - 321
*** ~Collection<T>~ and ~CollectionBase~ - 321
**** ~CollectionBase~ - 323

*** ~KeyedCollection<TKey,TItem>~ and ~DictionaryBase~ - 323
**** ~DictionaryBase~ - 326

*** ~ReadOnlyCollection<T>~ - 326

** TODO Plugging in Equality and Order - 327
*** ~IEqualityComparer~ and ~EqualityComparer~ - 328
**** ~EqualityComparer<T>.Default~ - 329

*** ~IComparer~ and ~Comparer~ - 330
*** ~StringComparer~ - 332
*** ~IStructuralEquatable~ and ~IStructuralComparable~ - 333

* TODO 8. LINQ Queries - 335
** Getting Started - 335
** Fluent Syntax - 337
*** Chaining Query Operators - 338
**** Why extension methods are important - 340
*** Composing Lambda Expressions
**** Lambda expressions and Func signatures - 341
**** Lambda expressions and element typing

*** Natural Ordering - 343
*** Other Operators

** Query Expressions - 344
*** Range Variables - 346
*** Query Syntax Versus SQL Syntax - 347
*** Query Syntax Versus Fluent Syntax - 347
*** Mixed-Syntax Queries - 348

** Deferred Execution - 348
*** Reevaluation - 349
*** Captured Variables - 350
*** How Deferred Execution Works - 351
*** Chaining Decorators - 352
*** How Queries Are Executed - 354

** Subqueries - 355
*** Subqueries and Deferred Execution - 358
   
** Composition Strategies - 358
*** Progressive Query Building - 358
*** The into Keyword - 360
**** Scoping rules - 360

*** Wrapping Queries - 361

** Projection Strategies - 362
*** Object Initializers - 362
*** Anonymous Types - 362
*** The ~let~ Keyword - 363

** Interpreted Queries - 364
*** How Interpreted Queries Work - 366
**** Execution - 367

*** Combining Interpreted and Local Queries - 368
*** AsEnumerable - 369

** LINQ to SQL and Entity Framework - 371
*** LINQ to SQL Entity Classes - 371
*** Entity Framework Entity Classes - 372
*** DataContext and ObjectContext - 374
**** Typed contexts - 375
**** Object tracking - 376

*** Associations - 378
*** Deferred Execution with L2S and EF - 379
*** DataLoadOptions - 381
**** Specifying a filter in advance - 381
**** Eager loading - 382

*** Eager Loading in Entity Framework - 382
*** Updates - 382
*** API Differences Between L2S and EF - 384

** Building Query Expressions - 385
*** Delegates Versus Expression Trees - 386
**** Compiling expression trees - 386
**** AsQueryable - 387

*** Expression Trees - 387
**** The Expression DOM - 388

* TODO 9. LINQ Operators - 391
** Overview - 393
*** Sequence→Sequence - 393
**** Filtering - 393
**** Projecting - 394
**** Joining - 394
**** Ordering - 394
**** Grouping - 394
**** Set operators - 394
**** Conversion methods: Import - 395
**** Conversion methods: Export - 395

*** Sequence→Element or Value - 395
**** Element operators - 395
**** Aggregation methods - 395
**** Quantifiers - 395

*** Void→Sequence - 395
**** Generation methods - 395

** Filtering - 396
*** Where - 396
**** Query syntax - 396
**** Enumerable.Where implementation - 397
**** Overview - 397
**** Indexed filtering - 397
**** SQL LIKE comparisons in LINQ to SQL and EF - 398
**** < and > string comparisons in LINQ to SQL and EF - 398
**** WHERE x IN (..., ..., ...) in LINQ to SQL and EF - 398

*** Take and Skip - 398
*** TakeWhile and SkipWhile - 399
*** Distinct - 399

** Projecting - 400
*** Select - 400
**** Query syntax - 400
**** Enumerable implementation - 400
**** Overview - 400
**** Indexed projection - 401
**** Select subqueries and object hierarchies - 401
**** Subqueries and joins in LINQ to SQL and EF - 402
**** Projecting into concrete types - 403

*** SelectMany - 405
**** Query syntax - 405
**** Enumerable implementation - 405
**** Overview - 405
**** Multiple range variables - 406
**** Thinking in query syntax - 407
**** Joining with SelectMany - 408
**** SelectMany in LINQ to SQL and EF - 409
**** Outer joins with SelectMany - 410

** Joining - 412
*** ~Join~ and ~GroupJoin~ - 412
**** Join arguments - 412
**** GroupJoin arguments - 412
**** Query syntax - 412
**** Overview - 413
**** Join - 413
**** Joining on multiple keys - 415
**** Joining in fluent syntax - 415
**** GroupJoin - 416
**** Flat outer joins - 417
**** Joining with lookups - 417
**** Enumerable implementations - 419

*** The ~Zip~ Operator - 419

** Ordering - 420
*** OrderBy, OrderByDescending, ThenBy, and ThenByDescending - 420
**** OrderBy and OrderByDescending arguments - 420
**** ThenBy and ThenByDescending arguments - 420
**** Query syntax - 420
**** Overview - 421
**** Comparers and collations - 422
**** ~IOrderedEnumerable~ and ~IOrderedQueryable~ - 422

** Grouping - 423
*** GroupBy - 423
**** Query syntax - 423
**** Overview - 423
**** GroupBy in LINQ to SQL and EF - 425
**** Grouping by multiple keys - 426
**** Custom equality comparers - 426

** Set Operators - 426
*** Concat and Union - 426
*** Intersect and Except - 426

** Conversion Methods - 427
*** ~OfType~ and ~Cast~ - 428
*** ~ToArray~, ~ToList~, ~ToDictionary~, and ~ToLookup~ - 429
*** ~AsEnumerable~ and ~AsQueryable~ - 429

** Element Operators - 430
*** ~First~, ~Last~, and ~Single~ - 431
*** ~ElementAt~ - 431
*** ~DefaultIfEmpty~ - 432

** Aggregation Methods - 432
*** ~Count~ and ~LongCount~ - 432
*** ~Min~ and ~Max~ - 433
*** ~Sum~ and ~Average~ - 433
*** ~Aggregate~ - 434
**** Unseeded aggregations - 435
**** Traps with unseeded aggregations - 435

** Quantifiers - 437
*** ~Contains~ and ~Any~ - 437
*** ~All~ and ~SequenceEqual~ - 437

** Generation Methods - 438
*** ~Empty~ - 438
*** ~Range~ and ~Repeat~ - 438

* TODO 10. LINQ to XML - 441
** Architectural Overview - 441
*** What Is a DOM? - 441
*** The LINQ to XML DOM - 442

** X-DOM Overview - 442
*** Loading and Parsing - 444
*** Saving and Serializing - 445

** Instantiating an X-DOM - 446
*** Functional Construction - 446
*** Specifying Content - 447
*** Automatic Deep Cloning - 448

** Navigating and Querying - 448
*** Child Node Navigation - 449
**** FirstNode, LastNode, and Nodes - 449
**** Retrieving elements - 450
**** Retrieving a single element - 451
**** Retrieving descendants - 451

*** Parent Navigation - 452
*** Peer Node Navigation - 452
*** Attribute Navigation - 453

** Updating an X-DOM - 453
*** Simple Value Updates - 454
*** Updating Child Nodes and Attributes - 454
*** Updating Through the Parent - 455
**** Removing a sequence of nodes or attributes - 455

** Working with Values - 456
*** Setting Values - 457
*** Getting Values - 457
*** Values and Mixed Content Nodes - 458
*** Automatic XText Concatenation - 459

** Documents and Declarations - 459
*** XDocument - 459
*** XML Declarations - 461
**** Writing a declaration to a string - 462

** Names and Namespaces - 463
*** Namespaces in XML - 463
**** Prefixes - 464
**** Attributes - 464

*** Specifying Namespaces in the X-DOM - 465
*** The X-DOM and Default Namespaces - 466
*** Prefixes - 467

** Annotations - 468
** Projecting into an X-DOM - 469
*** Eliminating Empty Elements - 471
*** Streaming a Projection - 472
*** Transforming an X-DOM - 473
**** Advanced transformations - 474

* TODO 11. Other XML Technologies - 477
** XmlReader - 478
*** Reading Nodes - 479
*** Reading Elements - 481
**** Optional elements - 482
**** Random element order - 482
**** Empty elements - 483
**** Other ReadXXX methods - 483

*** Reading Attributes - 485
**** Attribute nodes - 485

*** Namespaces and Prefixes - 486

** XmlWriter - 487
*** Writing Attributes - 488
*** Writing Other Node Types - 488
*** Namespaces and Prefixes - 488

** Patterns for Using XmlReader/XmlWriter - 489
*** Working with Hierarchical Data - 489
*** Mixing XmlReader/XmlWriter with an X-DOM - 491
**** Using XmlReader with XElement - 492
**** Using XmlWriter with XElement - 493

** XSD and Schema Validation - 493
*** Performing Schema Validation - 494
**** Validating with an XmlReader - 494
**** Validating an X-DOM - 495

** XSLT - 496

* TODO 12. Disposal and Garbage Collection - 499
** IDisposable, Dispose, and Close - 499
*** Standard Disposal Semantics - 500
**** Close and Stop - 501

*** When to Dispose - 501
*** Opt-in Disposal - 503
*** Clearing Fields in Disposal - 504

** Automatic Garbage Collection - 505
*** Roots - 506
*** Garbage Collection and WinRT - 507

** Finalizers - 507
*** Calling Dispose from a Finalizer - 508
*** Resurrection - 510
**** GC.ReRegisterForFinalize - 511

** How the Garbage Collector Works - 512
*** Optimization Techniques - 512
**** Generational collection - 513
**** The large object heap - 514
**** Concurrent and background collection - 514
**** GC notifications (server CLR) - 515

*** Forcing Garbage Collection - 515
*** Tuning Garbage Collection - 516
*** Memory Pressure - 516

** Managed Memory Leaks - 516
*** Timers - 518
*** Diagnosing Memory Leaks - 519

** Weak References - 520
*** Weak References and Caching - 521
*** Weak References and Events - 521

* TODO 13. Diagnostics and Code Contracts - 525
** TODO Conditional Compilation - 525
*** Conditional Compilation Versus Static Variable Flags - 526
*** The Conditional Attribute - 527
**** Alternatives to the Conditional attribute - 528

** TODO Debug and Trace Classes - 529
*** Fail and Assert - 529
*** TraceListener - 530
*** Flushing and Closing Listeners - 532

** TODO Code Contracts Overview - 532
*** Why Use Code Contracts? - 533
*** Contract Principles - 534
**** Compilation - 535
**** The binary rewriter - 535
**** Asserting versus throwing on failure - 536
**** Purity - 536

** TODO Preconditions - 537
*** ~Contract.Requires~ - 537
    - *What Should You Put in Preconditions?*

*** ~Contract.Requires<TException>~ - 537
*** ~Contract.EndContractBlock~ - 540
*** Preconditions and Overridden Methods - 541

** TODO Postconditions - 541
*** ~Contract.Ensures~ - 541
*** ~Contract.EnsuresOnThrow<TException>~ - 542
*** ~Contract.Result<T>~ and ~Contract.ValueAtReturn<T>~ - 542
*** ~Contract.OldValue<T>~ - 542
*** Postconditions and Overridden Methods

** TODO Assertions and Object Invariants - 543
*** Assertions - 543
**** ~Contract.Assert~ - 543
**** ~Contract.Assume~ - 544

*** Object Invariants - 544

** TODO Contracts on Interfaces and Abstract Methods - 545
** TODO Dealing with Contract Failure - 546
*** The ContractFailed Event - 547
*** Exceptions Within Contract Conditions - 548

** TODO Selectively Enforcing Contracts - 548
*** Contracts in Release Builds - 548
*** Call-Site Checking - 549

** TODO Static Contract Checking - 549
*** The ~ContractVerification~ Attribute - 550
*** Baselines - 551
*** The ~SuppressMessage~ Attribute - 551

** TODO Debugger Integration - 551
*** Attaching and Breaking - 551
*** Debugger Attributes - 552

** TODO Processes and Process Threads - 552
*** Examining Running Processes - 552
*** Examining Threads in a Process - 553

** TODO StackTrace and StackFrame - 553
** TODO Windows Event Logs - 555
*** Writing to the Event Log - 556
*** Reading the Event Log - 556
*** Monitoring the Event Log - 557

** TODO Performance Counters - 557
*** Enumerating the Available Counters - 558
*** Reading Performance Counter Data - 559
*** Creating Counters and Writing Performance Data - 561

** TODO The Stopwatch Class - 562

* TODO 14. Concurrency and Asynchrony - 563
** Introduction - 563
** Threading - 564
*** Creating a Thread
*** Join and Sleep
*** Blocking
**** I/O-bound versus compute-bound
**** Blocking versus spinning

*** Local Versus Shared State
*** Locking and Thread Safety
*** Passing Data to a Thread
**** Lambda expressions and captured variables

*** Exception Handling
**** Centralized exception handling

*** Foreground Versus Background Threads
*** Thread Priority
*** Signaling
*** Threading in Rich-Client Applications
*** Synchronization Contexts
*** The Thread Pool
**** Entering the thread pool
**** Hygiene in the thread pool

** Tasks - 581
*** Starting a Task
**** Wait
**** Long-running tasks

*** Returning values
*** Exceptions
**** Exceptions and autonomous tasks

*** Continuations
*** TaskCompletionSource
*** Task.Delay

** Principles of Asynchrony - 589
*** Synchronous Versus Asynchronous Operations
*** What is Asynchronous Programming?
*** Asynchronous Programming and Continuations
*** Why Language Support Is Important

** Asynchronous Functions in C# - 594
*** Awaiting
**** Capturing local state
**** Awaiting in a UI
**** Comparison to coarse-grained concurrency

*** Writing Asynchronous Functions
**** Returning ~Task<TResult>~
**** Asynchronous call graph execution
**** Parallelism

*** Asynchronous Lambda Expressions
*** Asynchronous Methods in WinRT
*** Asynchrony and Synchronization Contexts
**** Exception posting
**** OperationStarted and OperationCompleted

*** Optimizations
**** Completing synchronously
**** Avoiding excessive bouncing

** Asynchronous Patterns - 610
*** Cancellation
*** Progress Reporting
**** ~IProgress<T>~ and ~Progress<T>~

*** The Task-based Asynchronous Pattern (TAP)
*** Task Combinators
**** WhenAny
**** WhenAll
**** Custom combinators

** Obsolete Patterns - 618
*** Asynchronous Programming Model (APM)
**** Asynchronous delegates

*** Event-Based Asynchronous Pattern (EAP)
*** BackgroundWorker

* TODO 15. Streams and I/O - 623
** Stream Architecture - 623
** Using Streams - 625
*** Reading and Writing - 627
*** Seeking - 628
*** Closing and Flushing - 629
*** Timeouts - 629
*** Thread Safety - 629
*** Backing Store Streams - 629
*** FileStream - 630
**** Constructing a FileStream - 630
**** Specifying a filename - 631
**** Specifying a FileMode - 632
**** Advanced FileStream features - 633

*** MemoryStream - 633 
*** PipeStream - 634
**** Named pipes - 635
**** Anonymous pipes - 636

*** BufferedStream - 638

** Stream Adapters - 639
*** Text Adapters - 639
*** StreamReader and StreamWriter - 641
**** Character encodings - 642
**** StringReader and StringWriter - 644

*** Binary Adapters - 645
*** Closing and Disposing Stream Adapters - 646

** Compression Streams - 647
*** Compressing in Memory - 648

** Working with ZIP Files - 649
** File and Directory Operations - 650
*** The File Class - 650
**** Compression and encryption attributes - 651
**** File security - 653

*** The Directory Class - 654
*** FileInfo and DirectoryInfo - 654
*** Path - 655
*** Special Folders - 657
*** Querying Volume Information - 659
*** Catching Filesystem Events - 659

** File I/O in Windows Runtime - 661
*** Working with Directories - 661
*** Working with Files - 662
*** Isolated Storage in Windows Store Apps - 663

** Memory-Mapped Files - 663
*** Memory-Mapped Files and Random File I/O - 663
*** Memory-Mapped Files and Shared Memory - 663
*** Working with View Accessors - 665

** Isolated Storage - 666
*** Isolation Types - 666
*** Reading and Writing Isolated Storage - 668
*** Store Location - 669
*** Enumerating Isolated Storage - 670

* TODO 16. Networking - 673
** Network Architecture - 673
** Addresses and Ports - 675
** URIs - 676
** Client-Side Classes - 679
*** WebClient - 679
*** WebRequest and WebResponse - 681
*** HttpClient - 683
**** GetAsync and response messages - 684
**** SendAsync and request messages
**** Uploading data and HttpContent - 685
**** HttpMessageHandler - 685
**** Unit testing and mocking - 685
**** Chaining handlers with DelegatingHandler - 686

*** Proxies - 687
*** Authentication - 688
**** CredentialCache - 689
**** Authenticating via headers with HttpClient - 690

*** Exception Handling - 690

** Working with HTTP - 692
*** Headers - 692
*** Query Strings - 693
*** Uploading Form Data - 693
*** Cookies - 695
*** Forms Authentication - 696
*** SSL - 697

** Writing an HTTP Server - 698
** Using FTP - 701
** Using DNS - 703
** Sending Mail with SmtpClient - 703
** Using TCP - 704
*** Concurrency with TCP - 707

** Receiving POP- 3 Mail with TCP - 708
** TCP in Windows Runtime - 709

* TODO 17. Serialization - 713
** Serialization Concepts - 713
*** Serialization Engines - 714
**** Why three engines? - 714
**** The data contract serializer - 715
**** The binary serializer - 715
**** XmlSerializer - 716
**** IXmlSerializable - 716

*** Formatters - 716
*** Explicit Versus Implicit Serialization - 717

** The Data Contract Serializer - 717
*** DataContractSerializer Versus NetDataContractSerializer - 718
*** Using the Serializers - 718
**** Specifying a binary formatter - 721
*** Serializing Subclasses - 721
*** Object References - 723
**** Preserving object references - 724

*** Version Tolerance - 725
**** Required members - 725

*** Member Ordering - 726
*** Null and Empty Values - 726

** Data Contracts and Collections - 727
*** Subclassed Collection Elements - 728
*** Customizing Collection and Element Names - 729

** Extending Data Contracts - 730
*** Serialization and Deserialization Hooks - 730
*** Interoperating with [Serializable] - 731
*** Interoperating with IXmlSerializable - 733

** The Binary Serializer - 733
*** Getting Started - 733

** Binary Serialization Attributes - 735
*** ~[NonSerialized]~ - 735
*** ~[OnDeserializing]~ and ~[OnDeserialized]~ - 735
*** ~[OnSerializing]~ and ~[OnSerialized]~ - 736
*** ~[OptionalField]~ and Versioning - 737

** Binary Serialization with ISerializable - 738
*** Subclassing Serializable Classes - 740

** XML Serialization - 742
*** Getting Started with Attribute-Based Serialization - 742
**** Attributes, names, and namespaces - 743
**** XML element order - 744

*** Subclasses and Child Objects - 744
**** Subclassing the root type - 744
**** Serializing child objects - 745
**** Subclassing child objects - 746

*** Serializing Collections - 747
**** Working with subclassed collection elements - 748

*** IXmlSerializable - 749

* 18. Assemblies - 753
** What's in an Assembly - 753
*** The Assembly Manifest
*** The Application Manifest
*** Modules
*** The Assembly Class

** Strong Names and Assembly Signing - 758
*** How to Strongly Name an Assembly
*** Delay Signing

** Assembly Names - 761
*** Fully Qualified Names
*** The AssemblyName Class
*** Assembly Informational and File Versions

** Authenticode Signing - 764
*** How to Sign with Authenticode
*** Authenticode Validation

** The Global Assembly Cache - 768
*** How to Install Assemblies to the GAC
*** GAC and Versioning

** Resources and Satellite Assemblies - 770
*** Directly Embedding Resources
*** .resources Files
*** .resx Files
*** Satellite Assemblies
*** Cultures and Subcultures

** Resolving and Loading Assemblies - 779
*** Assembly and Type Resolution Rules
*** AssemblyResolve
*** Loading Assemblies

** Deploying Assemblies Outside the Base Folder - 784
** Packing a Single-File Executable - 785
*** Selective Patching
** Working with Unreferenced Assemblies - 787

* 19. Reflection and Metadata - 789
** Reflecting and Activating Types - 790
*** Obtaining a Type
*** Type Names
*** Base Types and Interfaces
*** Instantiating Types
*** Generic Types

** Reflecting and Invoking Members - 797
*** Member Types
*** C# Members Versus CLR Members
*** Generic Type Members
*** Dynamically Invoking a Member
*** Method Parameters
*** Using Delegates for Performance
*** Accessing Nonpublic Members
*** Generic Methods
*** Anonymously Calling Members of a Generic Interface

** Reflecting Assemblies - 810
*** Loading an Assembly into a Reflection-Only Context
*** Modules

** Working with Attributes - 812
*** Attribute Basics
*** The AttributeUsage Attribute
*** Defining Your Own Attribute
*** Retrieving Attributes at Runtime
*** Retrieving Attributes in the Reflection-Only Context

** Dynamic Code Generation - 818
*** Generating IL with DynamicMethod
*** The Evaluation Stack
*** Passing Arguments to a Dynamic Method
*** Generating Local Variables
*** Branching
*** Instantiating Objects and Calling Instance Methods
*** Exception Handling

** Emitting Assemblies and Types - 825
*** Saving Emitted Assemblies
*** The Reflection.Emit Object Model

** Emitting Type Members - 828
*** Emitting Methods
*** Emitting Fields and Properties
*** Emitting Constructors
*** Attaching Attributes

** Emitting Generic Methods and Types - 834
*** Defining Generic Methods
*** Defining Generic Types

** Awkward Emission Targets - 836
*** Uncreated Closed Generics
*** Circular Dependencies

** Parsing IL - 840
*** Writing a Disassembler

* TODO 20. Dynamic Programming - 847
** The Dynamic Language Runtime - 847
   - *What Are Call Sites?*

** Numeric Type Unification - 849
** Dynamic Member Overload Resolution - 850
*** Simplifying the Visitor Pattern - 850
**** Variations - 852
     - *Multiple Dispatch*

*** Anonymously Calling Members of a Generic Type - 853

** Implementing Dynamic Objects - 856
*** DynamicObject - 856
*** ExpandoObject - 859

** Interoperating with Dynamic Languages - 859
*** Passing State Between C# and a Script - 860

* TODO 21. Security - 863
** Permissions - 863
*** CodeAccessPermission and PrincipalPermission
*** PermissionSet
*** Declarative Versus Imperative Security

** Code Access Security (CAS) - 868
*** How Code Access Security Is Applied
*** Testing for Full Trust

** Allowing Partially Trusted Callers - 871
*** Elevation of Privilege
*** APTCA and [SecurityTransparent]

** The Transparency Model - 873
*** How the Transparency Model Works
*** How to Write APTCA Libraries with Transparency
*** Transparency in Full-Trust Scenarios

** Sandboxing Another Assembly - 881
*** Asserting Permissions

** Operating System Security - 885
*** Running in a Standard User Account
*** Administrative Elevation and Virtualization

** Identity and Role Security - 888
*** Assigning Users and Roles

** Cryptography Overview - 889
** Windows Data Protection - 890
** Hashing - 891
** Symmetric Encryption - 892
*** Encrypting in Memory
*** Chaining Encryption Streams
*** Disposing Encryption Objects
*** Key Management

** Public Key Encryption and Signing - 897
*** The RSA Class
*** Digital Signing

* TODO 22. Advanced Threading - 903
** Synchronization Overview - 904
** Exclusive Locking - 904
*** The lock Statement
*** ~Monitor.Enter~ and ~Monitor.Exit~
**** The lockTaken overloads
**** TryEnter

*** Choosing the Synchronization Object
*** When to Lock
*** Locking and Atomicity
*** Nested Locking
*** Deadlocks
*** Performance
*** Mutex

** Locking and Thread Safety - 912
*** Thread Safety and .NET Framework Types
**** Locking around thread-safe objects
**** Static members
**** Read-only thread safety

*** Thread Safety in Application Servers
*** Immutable Objects

** Nonexclusive Locking - 918
*** Semaphore
*** Reader/Writer Locks
**** Upgradeable locks
**** Lock recursion

** Signaling with Event Wait Handles - 923
*** AutoResetEvent
**** Two-way signaling

*** ManualResetEvent
*** CountdownEvent
*** Creating a Cross-Process EventWaitHandle
*** Wait Handles and Continuations
*** Converting Wait Handles to Tasks
*** WaitAny, WaitAll, and SignalAndWait
**** Alternatives to WaitAll and SignalAndWait

** The Barrier Class - 932
** Lazy Initialization - 933
*** Lazy<T>
*** LazyInitializer

** Thread-Local Storage - 936
*** [ThreadStatic]
*** ~ThreadLocal<T>~
**** ~ThreadLocal<T>~ and instance fields

*** GetData and SetData

** Interrupt and Abort - 938
** Suspend and Resume - 939
** Timers - 940
*** Multithreaded Timers
*** Single-Threaded Timers

* TODO 23. Parallel Programming - 945
** Why PFX? - 945
*** PFX Concepts - 946
*** PFX Components - 946
*** When to Use PFX - 946

** PLINQ - 948
*** Parallel Execution Ballistics - 950
*** PLINQ and Ordering - 951
*** PLINQ and Limitations - 952
*** Example: Parallel Spellchecker - 952
**** Using ~ThreadLocal<T>~ - 953

*** Functional Purity - 954
*** Setting the Degree of Parallelism - 955
**** Changing the degree of parallelism - 955

*** Cancellation - 955
*** Optimizing PLINQ - 956
**** Output-side optimization - 956
**** Input-side optimization - 957
**** Optimizing custom aggregations - 959

** The Parallel Class - 961
*** ~Parallel.Invoke~ - 962
*** ~Parallel.For~ and ~Parallel.ForEach~ - 963
**** Outer versus inner loops - 964
**** Indexed Parallel.ForEach - 964
**** ParallelLoopState: Breaking early out of loops - 965
**** Optimization with local values - 966

** Task Parallelism - 968
*** Creating and Starting Tasks - 969
**** Specifying a state object - 969
**** TaskCreationOptions - 969
**** Child tasks - 970

*** Waiting on Multiple Tasks - 970
*** Canceling Tasks - 971
*** Continuations - 972
**** Continuations and ~Task<TResult>~ - 972
**** Continuations and exceptions - 973
**** Continuations and child tasks - 973
**** Conditional continuations - 975
**** Continuations with multiple antecedents - 976
**** Multiple continuations on a single antecedent - 976

*** Task Schedulers - 977
*** TaskFactory - 977
**** Creating your own task factories - 977

** Working with AggregateException - 978
*** Flatten and Handle - 979
**** Flatten - 979
**** Handle - 979

** Concurrent Collections - 980
*** ~IProducerConsumerCollection<T>~
*** ~ConcurrentBag<T>~

** ~BlockingCollection<T>~ - 983
*** Writing a Producer/Consumer Queue - 984
**** Leveraging Tasks - 985

* TODO 24. Application Domains - 989
** Application Domain Architecture - 989
** Creating and Destroying Application Domains - 990
** Using Multiple Application Domains - 992
** Using DoCallBack - 994
** Monitoring Application Domains - 995
** Domains and Threads - 995
** Sharing Data Between Domains - 997
*** Sharing Data via Slots - 997
*** Intra-Process Remoting - 998
*** Isolating Types and Assemblies - 1000
**** Type discovery

* TODO 25. Interoperability - 1003
** Calling into Native DLLs - 1003
** Type Marshaling - 1004
*** Marshaling Common Types - 1004
*** Marshaling Classes and Structs - 1005
*** In and Out Marshaling - 1006

** Callbacks from Unmanaged Code - 1007
** Simulating a C Union - 1007
** Shared Memory - 1008
** Mapping a Struct to Unmanaged Memory - 1011
*** fixed and fixed {...} - 1014

** COM Interoperability - 1015
*** The Purpose of COM - 1015
*** The Basics of the COM Type System - 1016
**** ~IUnknown~ and ~IDispatch~

** Calling a COM Component from C# - 1017
*** Optional Parameters and Named Arguments - 1018
*** Implicit ref Parameters - 1019
*** Indexers - 1019
*** Dynamic Binding - 1020

** Embedding Interop Types - 1020
*** Type Equivalence - 1021

** Primary Interop Assemblies - 1021
** Exposing C# Objects to COM - 1022

* TODO 26. Regular Expressions - 1023
** TODO Regular Expression Basics - 1024
*** Compiled Regular Expressions - 1025
*** RegexOptions - 1025 
*** Character Escapes - 1026
*** Character Sets - 1027

** TODO Quantifiers - 1028
*** Greedy Versus Lazy Quantifiers - 1029

** TODO Zero-Width Assertions - 1029
*** Lookahead and Lookbehind - 1029
*** Anchors - 1030
*** Word Boundaries - 1031

** TODO Groups - 1032
*** Named Groups - 1033

** TODO Replacing and Splitting Text - 1033
*** MatchEvaluator Delegate - 1034
*** Splitting Text - 1034

** TODO Cookbook Regular Expressions - 1035
*** Recipes - 1035
**** Matching US Social Security number/phone number
**** Extracting “name = value” pairs (one per line)
**** Strong password validation
**** Lines of at least 80 characters
**** Parsing dates/times (N/N/N H:M:S AM/PM)
**** Matching Roman numerals
**** Removing repeated words
**** Word count
**** Matching a Guid
**** Parsing an XML/HTML tag
**** Splitting a camel-cased word
**** Obtaining a legal filename
**** Escaping Unicode characters for HTML
**** Unescaping characters in an HTTP query string
**** Parsing Google search terms from a web stats log

** TODO Regular Expressions Language Reference - 1038

* TODO 27. The Roslyn Compiler - 1043
** TODO Roslyn Architecture - 1044
*** Workspaces - 1044

** TODO Syntax Trees - 1045
*** SyntaxTree Structure - 1045
**** Common properties and methods - 1047

*** Obtaining a Syntax Tree - 1048
*** Traversing and Searching a Tree - 1049
**** Traversing children - 1050
**** Traversing parents - 1052
**** Finding a child by its offset - 1052
**** CSharpSyntaxWalker - 1053

*** Trivia - 1053
**** Preprocessor directives - 1054
**** Structured trivia - 1055

*** Transforming a Syntax Tree - 1056
**** Handling changes to the source code - 1057
**** Creating new nodes, tokens, and trivia with SyntaxFactory - 1057
**** CSharpSyntaxRewriter - 1059

** TODO Compilations and Semantic Models - 1060
*** Creating a Compilation - 1060
**** Diagnostics - 1062

*** Emitting an Assembly - 1062
*** Querying the Semantic Model - 1062
**** Symbols - 1063
**** SymbolInfo -1064
**** Symbol accessibility - 1065
**** Declared symbols - 1065
**** TypeInfo - 1066
**** Looking up symbols - 1066

*** Example: Renaming a Symbol - 1067

* Index - 1073
