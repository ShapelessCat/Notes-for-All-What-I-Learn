#+TITLE: Core Java
#+SUBTITLE: Volume I && II -- Fundamentals and TODO
#+VERSION: 11th, 2019, Java SE11
#+AUTHOR: Cay S. Horstmann
#+STARTUP: overview
#+STARTUP: entitiespretty

* Preface - xix
* Acknowledgments - xxv
* Volumne I
** TODO Chapter 1: An Introduction to Java - 1
*** 1.1 Java as a Programming Platform - 1
*** 1.2 The Java "White Paper" Buzzwords - 2
**** 1.2.1 Simple - 3
**** 1.2.2 Object-Oriented - 4
**** 1.2.3 Distributed - 4
**** 1.2.4 Robust - 4
**** 1.2.5 Secure - 4
**** 1.2.6 Architecture-Neutral - 5
**** 1.2.7 Portable - 6
**** 1.2.8 Interpreted - 7
**** 1.2.9 High-Performance - 7
**** 1.2.10 Multithreaded - 7
**** 1.2.11 Dynamic - 8

*** 1.3 Java Applets and the Internet - 8
*** 1.4 A Short History of Java - 10
*** 1.5 Common Misconceptions about Java - 13

** TODO Chapter 2: The Java Programming Environment - 17
*** 2.1 Installing the Java Development Kit - 18
**** 2.1.1 Downloading the JDK - 18
     - Java Jargons:
       + Java Development Kit (JDK) :: The name describe it. It is required for any Java developer.

       + Java Runtime Environment (JRE) :: The software for consumers who want to run Java programs
         * JRE is officially published before JDK 10 TODO ???
             Since JDK 10, you don't have official JRE, but you can customize your
           project specific JRE.

       + Sever JRE :: The software for running Java programs on servers

       + Standard Edition (SE) :: The Java pla
tform for use on desktops and simple
            server applications

       + Enterprise Edition (EE) :: The Java platform for complex server applications

       + Micro Edition (ME) :: The Java platform for use on small devices

       + JavaFX :: Java GUI toolkit. It is included in Java SE prior to Java 11.

       + Java 2 (acronym: J2) :: An outdated term that described Java versions from
            1998 until 2006.
         * *CAUTION*:
           "Java 2 or J2" does not mean "Java SE 2" (there is not jargon as "Java
           SE 2" in Java 2 days, I just mock the later "Java SE 9" pattern).

       + Software Development Kit (SDK) :: The official name of the later term /JDK/
            from 1998 until 2006 (The Java 2 (J2) era).

       + Update (u) :: Oracle's term for a bug fix release up to Java 8.
         * OUTDATED since Java 9.
         * What's new??? TODO

     - History:
       1. Java version 1.2 ~ 1.4 development kit were known as the Java /SDK/.

       2. You might run into the term Java 2 that was coined in 1998 when the
          marketing folks at Sun felt that a fractional version number increment
          did not properly communicate the momentous advances of JDK 1.2.
            However, since they had that insight only after the release, they
          decided to keep the version number 1.2 for the development kit.
          Subsequent releases were numbered 1.3, 1.4, and 5.0.
            The platform, however, was renamed from Java to Java 2. Thus, we had
          Java 2 Standard Edition Software Development Kit Version 5.0, or J2SE
          SDK 5.0.
          TODO RE-ORG

       3. In 2006, the numbering was simplified.
          Since then, we have Java SE <Java Version> like Java SE 6 and Java SE 7.
          However, The "internal" version numbers are 1.6.0, 1.7.0, and 1.8.0.

       4. The minor madness of the "internal" version finally run its course with Java SE 9,
          when the version number became 9, and then 9.0.1 (TODO: semantic versioning???).
          + The version number specification requires that trailing zeroes are dropped
            for the fleeting interval between a major release and its first security update.

     - Summary:
       + Java 1.0 -> Java 1.1 -> J2SE 1.2 -> J2SE 1.3 -> J2SE 1.4 -> J2SE 5.0 -> Java SE 6 -> ...

       + TODO ??? -> Java 2 SDK 1.2 -> ... -> Java 2 SDK 1.4 -> Java 2 SDK 5.0 -> JDK 6 -> ...

**** 2.1.2 Setting up the JDK - 20
**** 2.1.3 Installing Source Files and Documentation - 22

*** 2.2 Using the Command-Line Tools - 23
*** 2.3 Using an Integrated Development Environment - 29
*** 2.4 JShell - 32

** TODO Chapter 3: Fundamental Programming Structures in Java - 37
*** DONE 3.1 A Simple Java Program - 38
    CLOSED: [2019-12-19 Thu 15:25]
    - access modifier :: TODO Chapter 5

    - Java identifier TODO

    - The length of a Java identifier is essentially unlimited (by JLS).
      =from Jian= However, in practice, it is limited by the JVMS and the /file
      system/ where it reside.

    - For /class name/, use "CamelCase".

*** DONE 3.2 Comments - 41
    CLOSED: [2019-12-15 Sun 18:34]
    - Three types:
      + Single line comment:
        ~//~

      + Multiple lines comment:
        start ~/*~ and end ~*/~
        * _CAUTION_: ~/* */~ comments do NOT nest in Java.

      + Multiple lines comment (can generate document automatically):
        start ~/**~ and end ~*/~

*** DONE 3.3 Data Types - 42 - TODO
    CLOSED: [2019-12-17 Tue 22:50]
    - Java is a *strongly typed language*.

    - There are *8* /primitive types/.
      + 4 integer types
      + 2 double types
      + 1 char type - used for /code units/ in the Unicode encoding scheme!
      + 1 boolean type

**** DONE 3.3.1 Integer Types - 43
      CLOSED: [2019-12-15 Sun 19:04]
      - =from Jian=
        All Java integer types have /total order/.

      - Java Integer Types
        | Type    | Storage Requirement | Range (inclusive)    |
        |---------+---------------------+----------------------|
        | ~int~   | 4 bytes             | -2**31 ~ (2**31 - 1) |
        | ~short~ | 2 bytes             | -2**15 ~ (2**15 - 1) |
        | ~long~  | 8 bytes             | -2**63 ~ (2**63 - 1) |
        | ~byte~  | 1 byte              | -2**7 ~ (2**7 - 1)   |

      - Best practice of why to use one type:
        1. Use ~int~ in most situations
          =from Jian= TODO rationale

        2. When the range of the value you want to represent exceeds the range of ~int~.

        3. ~byte~ and ~short~ are mainly intended for specialized applications
           For example,
           + low-level file handling
           + for large arrays when storage space is at a premium

      - Suffix for /integer number literals/:
        ~l~ and ~L~ for ~long~

      - Prefix for /integer number literals/:
        + Hexadecimal: ~0x~ or ~0X~
          * =from Jian= You may like ~0x~, because we usually use hexadecimal number
            representation with _capital letters_!
            For instance, ~0xCAFE~ is more readible than ~0XCAFE~!!!

        + Octal: ~0~

        + Binary (since Java SE 7): ~0b~ or ~0B~

      - Since Java SE 7:
        You can insert underscores to any position in number literals to improve readibility!
        For instance, ~1_000_000~ or ~1_000000~.

**** DONE 3.3.2 Floating-Point Types - 44
     CLOSED: [2019-12-16 Mon 11:20]
     - =from Jian=
       All Java floating-point types have /partial order/.
       Because of the existence of ~Float.NaN~ and ~Double.NaN~
       + *CAUTION*:
         ~NaN~'s reside in the ~Float~ and ~Double~, NOT ~float~ and ~double~!!!

     - Java Floating-Point Types
       | Type     | Storage Requirement | Range                                   |
       |----------+---------------------+-----------------------------------------|
       | ~float~  | 4 bytes             | TODO (6 ~ 7 significant decimal digits) |
       | ~double~ | 8 bytes             | TODO (15 significant decimal digits)    |

     - Suffix for /floating-point number literals/:
       * ~f~ and ~F~ for ~float~

       * ~d~ and ~D~ for ~double~
         Since ~double~ is the defult of a /floating-point number literal/,
         mostly there is no reason to use this.

     - NOTE: TODO TODO TODO
       You can specify floating-point literals in hexadecimal.
       For example,
       0.125 = 2–3 can be written as 0x1.0p-3. In hexadecimal notation, you use a
       p, not an e, to denote the exponent. (An e is a hexadecimal digit.) Note
       that the mantissa is written in hexadecimal and the exponent in decimal.
       The base of the exponent is 2, not 10.

     - Java floating-point number follow the IEEE 754 spec, and there are *3*
       special floating-point values to denote overflows and errors:
       + Positive infinity
       + Negagtive infinity
       + NaN (not a number)

     - How to get these special values (=from Jian= not exhaustive???):
       + Positive infinity:
         Divide a positive number by 0

       + NaN:
         The squre root of a negative number

     - NOTE:
       ~NaN~ equals nothing, and it even doesn't have the equality to itself.
       Use ~Float.isNaN~ / ~Dboule.isNaN~ to check if a value is ~NaN~.

     - CAUTION:
       If you need precise numerical computations _WITHOUT_ /roundoff errors/,
       use the ~BigDecimal~ class.

**** DONE 3.3.3 The ~char~ Type - 46
     CLOSED: [2019-12-17 Tue 21:46]
     - Some Unicode characters can be described with _one_ ~char~ value,
       while other Unicode characters require _two_ ~char~ values.
       + This is due to the width of ~char~, one ~char~ can have be expressed as
         values from ~\u0000~ to ~\uFFFF~, which can't represent all Unicode
         characters.

     - *CAUTION* =IMPORTANT=
       + *TRAP* !!!
         Unicode escape sequences are processed before the code is parsed.
         For example,
         * ~"\u0022+\u0022"~ (~\u0022~ is ~"~) is
           #+begin_src java
             // the cancatenation of two empty strings
             ""+""  // "" + ""
           #+end_src
           and the result is an empty string ~""~.

         * If you write a comment like ~// \u000A is a newline~, you will get an
           compile error because ~\u000A~ is a _newline character_.

         * If you write a comment like ~// look inside c:\users~, you will get an
           compile error because ~\u~ is not followed by _four hex digits_.

**** DONE 3.3.4 Unicode and the ~char~ Type - 47 - TODO
     CLOSED: [2019-12-17 Tue 22:50]
     - code point :: a code value that is associated with a character in an encoding
                     scheme.

     - surrogates area :: TODO TODO TODO TODO TODO TODO ???
          U+D800 to U+DBFF for the first code unit;
          U+DC00 to U+DFFF for the second code unit.

     - UTF-16 :: a scheme of encoding that represents all /Unicode code points/ in
                 a variable-length code.
       + The characters in the /basic multilingual plance/ are represented as
         16-bit values, call /code units/.

       + The /supplementary characters/ are encoded as *consecutive pairs* of /code units/.

       + Each of the values in such an encoding pair falls into a range of 2048
         unused values of the basic multilingual plane, called the /surrogates
         area/ (U+D800 to U+DBFF for the first code unit, U+DC00 to U+DFFF for
         the second code unit). This is rather clever, because you can
         immediately tell whether a code unit encodes a single character or it
         is the first or second part of a supplementary character. For example,
         Image (the mathematical symbol for the set of octonions,
         http://math.ucr.edu/home/baez/octonions) has code point U+1D546 and is
         encoded by the two code units U+D835 and U+DD46. (See
         https://tools.ietf.org/html/rfc2781 for a description of the encoding
         algorithm.) TODO TODO TODO TODO TODO TODO !!! TODO TODO TODO

     - History:
       1. In the 1980s, a fixed 2-byte code was more than sufficient to encode all
          characters used in all languages in the world (at that time).

       2. In 1991, Unicode 1.0 was released,  it uses slightly _less than half_ of
          the available 65536 code values.

       3. However, overtime Unicode grew beyond 65536 characters.
            Unicode then had to update the standard and use more than 2 bytes to
          represent a Unicode character.

       4. The updaed Unicode standard has /code points/ grouped into 17 /code planes/.
          + The _first_ /code plane/, called the /basic multilingual plance/, consists
            of the "classic" Unicode characters with code points U+0000 to U+FFFF.

          + _Sixteen_ additional planes, with /code points/ U+10000 to U+10FFFF, hold
            the /supplementary characters/ -- these planes are called /supplementary
            plannes/.

       5. In Java, the ~char~ type describes a /code unit/ in the UTF-16 encoding.


**** DONE 3.3.5 The ~boolean~ Type - 48
     CLOSED: [2019-12-16 Mon 11:21]
     You _CANNOT_ convert between integers and boolean values.

*** DONE 3.4 Variables and Constants - 48 - TODO =Changed in Version 11=
    CLOSED: [2019-12-16 Mon 17:43]
    - Java Identifier :: TODO TODO TODO
      + _TIP_:
        Use the ~Character.isJavaIdentifierStart~ and ~Character.isJavaIdentifierPart~
        to check.

    - Symbols like '+' or '©' cannot be used inside variable names, nor can spaces.

    - The length of a variable name is essentially unlimited.
      =from Jian=
      Be unlimited by language spec, and be limited by JVM (class file format
      spec) or OS.

    - Mustn't use /Java reserved word/ as a /variable name/.

**** DONE 3.4.1 Declaring Variables - 48
**** DONE 3.4.2 Initializing Variables - 50
     CLOSED: [2019-12-16 Mon 17:42]
     - Use after initialization.

     - You can:
       + Declare first and then initialize it.
       + declare and initialize on the same line.

     - In Java, it is considered good style to declare variables as closely as
       possible to the point where they are first used.

**** DONE 3.4.3 Constants - 51
     CLOSED: [2019-12-16 Mon 17:42]
     ~final~
     - ~const~ is a reserved Java keyword, but it is not in use in current version.

**** DONE 3.4.4 Enumerated Types - 52

*** TODO 3.5 Operators - 52
**** 3.5.1 Arithmetic Operators - 52
**** 3.5.2 Mathematical Functions and Constants - 54
**** 3.5.3 Conversions between Numeric Types - 56
     - Figure 3.1 Legal conversions between numeric types

**** 3.5.4 Casts - 57
**** DONE 3.5.5 Combining Assignment with Operators - 58
     CLOSED: [2019-12-16 Mon 17:48]
     NOTE:
     #+begin_src java
       int x = 0;
       int y = x;
       x += 3.5;
       assert(x == (int)(y + 3.5));
     #+end_src

**** DONE 3.5.6 Increment and Decrement Operators - 58
     CLOSED: [2019-12-16 Mon 17:50]
     Avoid using increment and decrement operators,
     =from Jian= especially the postfix one.

**** DONE 3.5.7 Relational and ~boolean~ Operators - 59
     CLOSED: [2019-12-16 Mon 17:51]
     Java also support the /tenary operator/ ~?:~

**** DONE 3.5.8 Bitwise Operators - 60
     CLOSED: [2019-12-16 Mon 18:04]
     - Built-in bitwise operators:
       + ~&~ (and)
       + ~|~ (or)
       + ~^~ (xor)
       + ~   (not)

     - Example:
       Mask out all but the 4th digit -- return is 1 if it is 1, or else 0
       ~int fourthBitFromRight = (n & 0b1000) / 0b1000;~

     - NOTE
       Apply ~&~ or ~|~ on _booleans_, and the result will be of /boolean type/.
       They are similar to ~&&~ and ~||~, except that they are *NOT /short circuit/.*

     - *CAUTION*
       + The RHS argument of the /shift operators/ *is reduced modulo 32* if the
         LHS is not ~long~.

       + If the LHS is ~long~, *modulo 64*.

       + Example:
         ~1 << 35~ is the same as ~1 << 3~ or ~8~

     - C++ NOTE:
       C/C++ spec doesn't guarantee that if a ~>>~ performs an /arithetic shift/ or
       a /logical shift/. It is implementation-dependent.

**** DONE 3.5.9 Parentheses and Operator Hierarchy - 61
     CLOSED: [2019-12-16 Mon 18:09]
     - Table 3.4 Operator Precedence
       TODO TODO TODO

     - Example:
       After doing ~a += b += c~,
       ~b~ equals ~b + c~ and ~a~ equals ~a + b + c~.
       The value of ~b += c~ is the increased ~b~, which equals ~b + c~.

     - C++ NOTE:
       Unlike C or C++, Java does _NOT_ have a /comma operator/.
       However, you can use a comma-separated list of expressions in the first
       and third slot of a ~for~ statement.

*** DONE 3.6 Strings - 62 - TODO
    CLOSED: [2019-12-17 Tue 23:17]
    Java does NOT have a built-in string type; Instead, its standard library contains
    a /predefined class/ called ~String~.

**** DONE 3.6.1 Substrings - 62
     CLOSED: [2019-12-17 Tue 22:54]
     #+begin_src java
       String greeting = "Hello";
       String s = greeting.substring(0, 3);  // "Hel"
     #+end_src

**** DONE 3.6.2 Concatenation - 63
     CLOSED: [2019-12-17 Tue 22:54]
     - ~+~

     - ~String.join(" / ", "S", "M", "L", "XL");~
       returns ~"S / M / L / XL"~

     - As of Java 11, there is a ~repeat~ /method:
       ~"Java".repeated(3);~
       returns ~"JavaJavaJava"~

**** DONE 3.6.3 Strings Are Immutable - 63
     CLOSED: [2019-12-17 Tue 23:02]
     - The immutability does _NOT_ make Java ~String~ inefficient!
       The reason is Java compiler can arrange that strings are *shared*.

     - Overall, the designers of Java decided that
       _the efficiency of sharing_ *outweighs* _the inefficiency of string
       editing by extracting substrings and concatenating_.
       TODO WHY TODO???

     - Use ~StringBuilder~ is you need a mutable representation of a string.

**** DONE 3.6.4 Testing Strings for Equality - 65
     CLOSED: [2019-12-17 Tue 23:07]
     Use the ~equals~ method of ~String~.
     *Mustn't* use ~==~ if you don't want to compare there identity (address in
     memory).

     - C++ Note:
       For comparing string values
       + C++ programmers use ~==~ to check the equality between string values (not address).
       + C programmers use ~strcmp~. Java has an exact analog: ~compareTo~.

**** DONE 3.6.5 Empty and Null Strings - 66
     CLOSED: [2019-12-17 Tue 23:08]
**** TODO 3.6.6 Code Points and Code Units - 66
     - TODO

     - TODO

     - TODO

     - TODO

     - NOTE
       The JVM does _NOT_ have to implement strings as sequences of /code units/,
       which is not efficient in space.
       + In Java 9,
         * strings that hold _ONLY_ /single-byte code units/ use /a ~byte~ array/.
         * all others use /a ~char~ array/.

**** TODO 3.6.7 The ~String~ API - 68
     - TODO

     - TODO

     - TODO

     - NOTE
       In the API notes, there are a few parameters of type ~CharSequence~.
       It is an /interface type/ to which all strings belong.
       + =from Jian= I guess the /string/ here is in concept, which is more than
         just ~String~.

**** DONE 3.6.8 Reading the Online API Documentation - 71
     CLOSED: [2019-12-17 Tue 23:17]
**** DONE 3.6.9 Building Strings - 74
    CLOSED: [2019-12-16 Mon 18:16]
    - Use ~StringBuilder~

    - NOTE:
      + ~StringBuilder~ class was introduced in JDK 5.0.
        Not thread safe.

      + Before JDK 5.0, there is a similar class ~StringBuffer~.
        It is slightly less efficient, but thread safe.

      + The APIs of ~StringBuilder~ and ~StringBuffer~ are identical.

    - The most import methods of ~StringBuilder~ (5.0+)

*** TODO 3.7 Input and Output - 75
**** 3.7.1 Reading Input - 75
**** 3.7.2 Formatting Output - 78
**** 3.7.3 File Input and Output - 83

*** DONE 3.8 Control Flow - 86
    CLOSED: [2019-12-19 Thu 15:21]
**** DONE 3.8.1 Block Scope - 86
     CLOSED: [2019-12-17 Tue 23:27]
     - block :: a number of Java statements, surrounded by a pair of braces.

     - A /block/ define the scope of your variables.

     - /Blocks/ can be nested inside another one.

     - Declare _identically named variables_ in two /nested blocks/ will trigger
       an /compiling error/.
       #+begin_src java
         public static void main(String[] args)
         {
             int n;
             // ...
             {
                 int k;
                 int n;  // ERROR -- can't redefine `n` in inner block
                 // ...
             }
         }
       #+end_src
       =from Jian= Not an issue in Scala.
       + /Nested blocks/ are not used as much as in Scala.
         The _REASON_ is that Java is not a expression based language, and its
         block can't return a value, which make the reason of inner block
         existence is only for /side effects/.

     - C++ NOTE
       C++ can redefine a variable inside a nested block. The inner one will shaddow
       the outer one.

**** DONE 3.8.2 Conditional Statements - 87
     CLOSED: [2019-12-17 Tue 23:28]
     ~if ... else if ... else~

**** DONE 3.8.3 Loops - 91
     CLOSED: [2019-12-17 Tue 23:35]
     - ~while~ loop

     - ~do ... while~ loop

**** DONE 3.8.4 Determinate Loops - 95
     CLOSED: [2019-12-17 Tue 23:35]
     - ~for~ loop

     - CAUTION:
       Mostly, there is no reason to use floating-point number as the condition
       to do a ~for~ loop like ~for (double x = 0; x != 10; x += 0.1)~.
       + *This may never stop* becase of the roundoff errors, which comes from the
         representation of floating-numbers, and it can't be avoided.

       + =from Jian=
         Is there an example that people need to use floating-point number in ~for~
         loop condition??? TODO TODO TODO

     - NOTE
       See Section 3.10.3 for the /for each loop/

**** DONE 3.8.5 Multiple Selections -- The ~switch~ Statement - 99
     CLOSED: [2019-12-19 Thu 14:55]
     The ~if/else~ construct can be cumbersome when you have to deal with
     _multiple selections with many alternatives_. Java has a ~switch~ statement
     that is exactly like the ~switch~ statement in C and C++, warts and all.

     - Use the ~-Xlint:fallthrough~ option to detect the unexpected fallthrough
       (forget ~break~).
       + If you want to use this option, but also know some of the fallthroughs
         are expected, annotate them with ~@SuppressWarnings("fallthrough")~.
         =from Jian= this is not a fine grained one, it is applied to the
         /method/ level.

     - A ~case~ label can be
       + A /constant expression/ of type ~char~, ~byte~, ~short~, or ~int~
       + An /enumerated constant/
       + /String literal/ (since Java 7)

     - When you use the ~switch~ statement with /enumerated constants/, you _need
       not_ supply the name of the enumeration in each label:
       #+begin_src java
         Size sz = ...;
         switch (sz)
         {
             case SMALL:  // no need to use `Size.SMALL`
                 // ...
                 break;
            //...
         }
       #+end_src

**** DONE 3.8.6 Statements That Break Control Flow - 102
     CLOSED: [2019-12-19 Thu 15:21]
     Java has /labeled break/ (unlike C++), though mostly people use ~break~
     without label to break the innermost structure.

     - No label ~break~ is pretty simple.
       Let's inspect /labeled break/:
       + /Label/ _MUST_ precede the outermost loop out of which you want to break.
         It also _MUST_ be followed by a colon.
         #+begin_src java
           Scanner in = new Scanner(System.in);
           int n;

           read_data:
           while (. . .) // this loop statement is tagged with the label
           {
               // . . .
               for (. . .) // this inner loop is not labeled
               {
                   System.out.print("Enter a number >= 0: ");
                   n = in.nextInt();
                   if (n < 0) // should never happen—can't go on
                       break read_data;  // break out of read_data loop
                   // . . .
               }
           }

           // this statement is executed immediately after the labeled break
           if (n < 0) // check for bad situation
           {
               // deal with bad situation
           }
           else
           {
               // carry out normal processing
           }
         #+end_src

     - NOTE
       You can label any block and _jump OUT_ of it with ~break~.
       #+begin_src java
         label:
         {
             // ...
             if (condition) break label;  // exits block
             // ...
         }
         // jumps here when the break statement executes
       #+end_src
       However, you _can NEVER jump INTO_ a block.

     - The ~continue~ statement transfers control to the header of the _innermost_
       enclosing loop.

     - There is also a /labeled continue/ that jumps to the header of the loop with
       the matching label.

     - *TIP*
       ~break~ and ~continue~ statements are often confusing.
       You can always express the same logic without ~break~ and ~continue~.
       + =from Jian=
         Therefore, everytime you use them, you should justify yourself.
         I believe that there are some situations ~break~ and ~continue~ can be
         a greate solution. I have this belief especially because Java is still
         a imperative language, and imperative solutions may require some
         imperative ways with ~break~ and ~continue~.

*** TODO 3.9 Big Numbers - 105
*** DONE 3.10 Arrays - 108
    CLOSED: [2019-12-19 Thu 14:47]
**** DONE 3.10.1 Declaring Arrays - 108
     CLOSED: [2019-12-19 Thu 13:46]
     - NOTE
       _BOTH ~int[] a;~ and ~int a[];~ are legal._
       Most Java Programmers *prefer the former style* because it neatly
       separates the type info ~int[]~ from the variable name.

     - Array literals:
       + ~int[] smallPrimes = { 2, 3, 5, 7, 11 , 13 };~

       + A comma after the last element is allowed, which is convenient for an array
         to which you keep adding values over time:
         ~int[] smallPrimes = { 2, 3, 5, 7, 11 , 13, };~

       + Anonymous array:
         ~new int[] { 17, 19, 23, 29, 31, 37 }~

     - NOTE
       It is legal to have arrays of length 0.
       Construct an array of length 0 as ~new elementType[0]~ or ~new
       elementType[] {}~.

**** DONE 3.10.2 Accessing Array Elements - 109
     CLOSED: [2019-12-19 Thu 13:48]
     Use the ~length~ field to get the lenght of an array.

**** DONE 3.10.3 The "for each" Loop - 110
     CLOSED: [2019-12-19 Thu 14:07]
     - Syntax: ~for (variable : collection) statement~
       + The ~collection~ must implement ~Iterable~.

     - A easier way to print all values of an array: ~Array.toString(arr)~.
       + If you ever tried ~array.toString~, and you are not a tool maker, mostly
         you don't expect this representation when you develop an application
         software.

**** DONE 3.10.4 Array Copying - 111
     CLOSED: [2019-12-19 Thu 14:19]
     - You can assign one array variable to another,
       but then both variables _refer to the same array_:
       #+begin_src java
         int[] luckyNumbers = smallPrimes;
         luckyNumbers[5] = 12;  // now smallPrimes[5] is also 12
       #+end_src

     - If you _don't want_ both variables refer to the same array, use ~Arrays.copy~:
       #+begin_src java
         int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length);
       #+end_src
       + A common use of this /method/ is to increase the size of an array -- the
         second parameter can be smaller or greater than the array being copied.

       + If the second parameter is greater than the array being copied, fill the
         extra slots with
         + ~0~ if the array contains /numbers/
         + ~false~ if the array contains /boolean/

     - C++ NOTE
       TODO

**** DONE 3.10.5 Command-Line Parameters - 112
     CLOSED: [2019-12-19 Thu 14:22]
     - C++ NOTE
       For Java, the name of the program is not stored in the ~args~ array of
       the ~main~ function.

**** DONE 3.10.6 Array Sorting - 113
     CLOSED: [2019-12-19 Thu 14:30]
     ~Arrays.sort~ uses a tuned version of the QuickSort algorithm.
     It is a in-place sort.

**** DONE 3.10.7 Multidimensional Arrays - 116
     CLOSED: [2019-12-19 Thu 14:39]
     - Initialize with multidimensional array literal:
       #+begin_src java
         int[][] magicSquare =
         {
             { 16,  3,  2, 13 },
             {  5, 10, 11,  8 },
             {  9,  6,  7, 12 },
             {  4, 15, 14,  1 },
         }
       #+end_src

     - *TIP*
       A quick-and-dirty way to print out a multidimensional array:
       ~System.out.println(Array.deepToString(arr))~

**** DONE 3.10.8 Ragged Arrays - 120
     CLOSED: [2019-12-19 Thu 14:47]
     - Java has no multidimensional arrays at all, only one-dimensional arrays.
       Multidimensional arrays are faked as "arrays of arrays. -- A Java
       Multidimensional array is actually a Java array with elements of
       references to other arrays.

     - Because of the reality of Java multidimensional arrays, it is easy to
       understand why Java multidimensional arrays does NOT need to a
       rectangular shape.

     - C++ NOTE
       TODO
       TODO
       TODO

       
** TODO Chapter 4: Objects and Classes - 129
   - In this chapter, we
     + Instroduce you to OOP
     + Show you how to create objects that belongs to classes from the standard Java library
     + Sow you how to write your own classes

*** DONE 4.1 Introduction to Object-Oriented Programming - 130
    CLOSED: [2019-12-18 Wed 15:18]
**** DONE 4.1.1 Classes - 131
     CLOSED: [2019-12-16 Mon 18:32]
     - Encapsulation / information hiding :: TODO TODO TODO

     - The key to making encapsulation work is to have methods never directly access
       instance fields in a class other than their own.

**** DONE 4.1.2 Objects - 132
     CLOSED: [2019-12-18 Wed 14:02]
     =IMPORTANT= =RE-READ=
     - To work with OOP, you should be able to identify three key characteristics of objects:
       + The object's _behavior_ :: what can you do with this object, or what
            methods can you apply to it?

       + The object's _state_ :: how does the object react when you invoke those
            methods?

       + The object's _identity_ :: how is the object distinguished from others
            that may have the same /behavior/ and /state/?

     - _All_ /objects/ that are /instances/ of the *same* /class/ share a family
       resemblance by supporting the same /behavior/.
       + The /behavior/ of an /object/ is defined by the /methods/ that you can call.

     - Information about what an object current look like (=from Jian= status) is
       the /object's state/.
       + An /object's state/ may CHANGE OVER TIME, but *NOT Spontaneously*.

       + A CHANGE in the /state/ of an object must be a consequence of /methods
         calls/. *If an object’s state changed without a method call on that
         object, someone _BROKE_ /encapsulation/.*

     - _These key characteristics can influence each other._
       + For example, the /state/ of an object can influence its /behavior/.
         We can use "order" to illustrate this:
         * If an _order_ is "shipped" or "paid", it may reject a /method call/
           that asks it to add or remove items.

         * Conversely, if an _order_ is "empty" -- no items have yet been ordered --
           it should not allow itself to be shipped.

**** DONE 4.1.3 Identifying Classes - 133
     CLOSED: [2019-12-16 Mon 18:36]
     - /Classes/ correspond to _nouns_; /methods/ correspond to _verbs_.

     - Of course, the "noun and verb" is but a _rule of thumb_.
       Only experience can help you decide which _nouns_ and _verbs_ are the important
       ones when building your /classes/.

**** DONE 4.1.4 Relationships between Classes - 133
     CLOSED: [2019-12-18 Wed 15:18]
     - The most common relationships between classes are
       + Dependence ("uses–a")
       + Aggregation ("has–a")
       + Inheritance ("is–a")

     - /Coupling/ comes from the "uses-a" relation.

*** TODO 4.2 Using Predefined Classes - 135
    - Utility class ~Math~ _ONLY_ /encapsulates/ functionalities;
      + it _NEITHER_ needs _NOR_ /hides data/.
      + since there is _NO_ data, you do NOT need to worry about making objects
        and initializing their instance fields -- there are NOT ANY!

    - We will use more typical non-singleton class ~Date~ as a example predefined
      class to talk about
      + how to construct objects
      + call methods of this class

**** DONE 4.2.1 Objects and Object Variables - 136
     CLOSED: [2019-12-18 Wed 17:09]
     - constructor :: TODO

     - C++ Note TODO TODO TODO

**** DONE 4.2.2 The ~LocalDate~ Class of the Java Library - 139
     CLOSED: [2019-12-18 Wed 17:09]
     - An instance of the ~Date~ class has a /state/ --
       namely, a _PARTICULAR point in time_.

     - In ~Date~, the time is represented by the number of (positive or negative)
       _milliseconds_ from a fixed point, the so-called /epoch/.
       + epoch :: the instant of 00:00:00 UTC, January 1, 1970.

       + UTC :: Coordinated Universal Time

     - /UTC/ is a scientific time standard which is, for practical purposes, the
       same as the more familiar GMT, or Greenwich Mean Time.

     - ~Date~ is not very useful for manipulating the kind of _calendar info_ that
       humans use for dates.
       + A _particular point in time_ has *different representation in different
         _calendars_.* For example, in the /epoch/ definition above, we use a
         calendar for of the /Gregorian calendar/.

     - NOTE =IMPORTANT=
       Book:
       Calendrical Calculations by Nachum Dershowitz and Edward M. Reingold
       (Cambridge University Press, The Ultimate Edition, 2018).

     - The library designers decided to
       _separate the concerns_ of /keeping time/ and /attaching names to points in time/.
       + Use ~Date~ to represent a point in time;

       + Use ~LocalDate~ to express days in familiar calendar notation.
         * TODO =from Jian=
           ~LocalDate~ doesn't include time info besides calendar date, and it can't
           be converted to ~Instant~, while ~LocalDateTime~ has all required info
           and it can be converted to ~Instant~.

     - SEPARATING _time measurement_ FROM _calendars_ is good object-oriented design.
       In general, it is a good idea to use different classes to express differnt
       concepts.

     - =from Jian=
       Because of the separation and concerns and backward compatibility requirement,
       The /constructors/ of ~Date~, except ~Date()~, are DEPRECATED.
       + If not for compatibility, I don't think there is any reason that we should
         keep ~Date~. A proof is that ~Date~ has a /static method/ ~from~, which
         accepts a ~Instant~ value. This implies that an ~Instant~ value has all
         (maybe more) info to construct a ~Date~.

     - Construct ~LocalDate~ with /static factory methods/ like:
       + ~LocalDate.now()~
       + ~LocalDate.of(1999, 12, 31)~

     - ~LocalDate~ has the methods ~getYear~, ~getMonthValue~, and ~getDayOfMonth~.
       + NOTE:
         ~Date~ also has similar methods: ~getDay~, ~getMonth~, and ~getYearl~, but
         because of the _separation of concerns_ mentioned above, they are DEPRECATED!
         *We should NEVER try to get a specific calendar info from a ~Date~.*

     - *TIP*
       Use the JDK provided _jdeprscan_ for checking whether your code uses
       /deprecated features/ of the Java API.

**** TODO 4.2.3 Mutator and Accessor Methods - 141 - TODO
     - mutator :: a /method/ that *mutate* an object its owen /fields/.

     - accessor :: a /method/ that *accessor* an object its owen /fields/ with changing it.

     - =from Jian=
       CAUTION: *Not all* /methods/ belongs to either /mutator/ or /accessor/!

     - Here is a example that should not use /mutator/ in design, and use /mutator/
       makes it misleading in semantics (=from Jian= I didn't use the original
       example in the book, this is a modifed one):
       #+begin_src scala
         // Good practice!
         // `plusDays` is not a mutator -- it doesn't mutate the `newYearsEve` object
         LocalDate aThousandDaysLater = newYearsEve.plusDays(1000);

         // Bad practice!
         GregorianCalendar newYearsEve = new GregorianCalendar(1999, 11, 31);
         // odd feature of that class: month numbers go from 0 to 11
         newYearsEve.add(Calendar.DAY_OF_MONTH, 1000);
       #+end_src
       =from Jian=
       If we modify the ~newYearsEve~ in place, the no longer new years eve
       ~newYearsEve~ will still have this name, which is misleading.
         Of course, we can use the name ~someDay~ in the orginal example in the
       book. However, though there is no misleading name, but ~someDay~ is a
       meaningless name, and we should avoid this kind of name in our code.
       *Here is a example that only non-mutator methods are good design*.

     - C++ NOTE
       C++ can use ~const~ suffix denotes /accessor methods/.
       A method that is NOT declared as ~const~ is _ASSUMED_ to be a /mutator/.
       =from Jian= It seems this ASSUMED /mutator/ is not the /mutator/ we
       defined above. It is more general.
       #+begin_src c++
         class MyBar;

         class Foo
         {
           public:
             MyBar GetMyBar() const { return mMyBar; } // accessor
             void SetMyBar(MyBar aMyBar) { mMyBar = aMyBar; } // mutator

           private:
             MyBar mMyBar;
         }
       #+end_src
       Java doesn't have a syntax to distinguish /accessors/ and /mutators/.

     - Listing 4.1 =CalendarTest/CalendarTest.java=
       TODO =READ=

*** TODO 4.3 Defining Your Own Classes - 145
**** 4.3.1 An Employee Class - 145
**** 4.3.2 Use of Multiple Source Files - 149
**** 4.3.3 Dissecting the Employee Class - 149
**** 4.3.4 First Steps with Constructors - 150
**** 4.3.5 Implicit and Explicit Parameters - 152
**** 4.3.6 Benefits of Encapsulation - 153
**** 4.3.7 Class-Based Access Privileges - 156
**** 4.3.8 Private Methods - 156
**** 4.3.9 Final Instance Fields - 157

*** TODO 4.4 Static Fields and Methods - 158
**** 4.4.1 Static Fields - 158
**** 4.4.2 Static Constants - 159
**** 4.4.3 Static Methods - 160
**** 4.4.4 Factory Methods - 161
**** 4.4.5 The main Method - 161

*** TODO 4.5 Method Parameters - 164
*** TODO 4.6 Object Construction - 171
**** 4.6.1 Overloading - 172
**** 4.6.2 Default Field Initialization - 172
**** 4.6.3 The Constructor with No Arguments - 173
**** 4.6.4 Explicit Field Initialization - 174
**** 4.6.5 Parameter Names - 175
**** 4.6.6 Calling Another Constructor - 176
**** 4.6.7 Initialization Blocks - 177
**** 4.6.8 Object Destruction and the finalize Method - 181

*** TODO 4.7 Packages - 182
**** 4.7.1 Class Importation - 183
**** 4.7.2 Static Imports - 185
**** 4.7.3 Addition of a Class into a Package - 185
**** 4.7.4 Package Scope - 189

*** TODO 4.8 JAR Files - 190
**** 4.8.1 Creating JAR files
**** 4.8.2 The Manifest
**** 4.8.3 Executable JAR Files
**** 4.8.4 Multi-Release JAR Files
**** 4.8.5 A Note about Command-Line Options

*** TODO 4.9 Documentation Comments - 194
**** 4.9.1 Comment Insertion - 194
**** 4.9.2 Class Comments - 195
**** 4.9.3 Method Comments - 195
**** 4.9.4 Field Comments - 196
**** 4.9.5 General Comments - 196
**** 4.9.6 Package and Overview Comments - 198
**** 4.9.7 Comment Extraction - 198

*** TODO 4.10 Class Design Hints - 200

** TODO Chapter 5: Inheritance - 203
*** 5.1 Classes, Superclasses, and Subclasses - 204
**** 5.1.1 Defining Subclasses - 204
**** 5.1.2 Overriding Methods - 206
**** 5.1.3 Subclass Constructors - 207
**** 5.1.4 Inheritance Hierarchies - 212
**** 5.1.5 Polymorphism - 213
**** 5.1.6 Understanding Method Calls - 214
**** 5.1.7 Preventing Inheritance: Final Classes and Methods - 217
**** 5.1.8 Casting - 219
**** 5.1.9 Abstract Classes - 221
**** 5.1.10 Protected Access - 227

*** 5.2 ~Object~: The Cosmic Superclass - 228
**** 5.2.1 Variables of Type ~Object~
**** 5.2.2 The ~equals~ Method
**** 5.2.3 Equality Testing and Inheritance
**** 5.2.4 The ~hashCode~ Method
**** 5.2.5 The ~toString~ Method

*** 5.3 Generic Array Lists
**** 5.3.1 Declaring Array Lists
**** 5.3.2 Accessing Array List Elements
**** 5.3.2 Compatibility between Typed and Raw Array Lists - 251

*** 5.4 Object Wrappers and Autoboxing - 252
*** 5.5 Methods with a Variable Number of Parameters - 256
*** 5.6 Enumeration Classes - 258
*** 5.7 Reflection - 260
    - reflective :: A program that can *analyze* the capabilities of /classes/.

    - You can use /reflection/ mechanism to:
      + *Analyze the capabilities* of /classes/ _at runtime_;

      + *Inspect objects* _at runtime_ --
        for example, to write a single ~toString~ method that works for all classes;
        =TODO= =???=

      + Implement generic array manipulation code;

      + Take advantage of ~Method~ /objects/ that work just _like_ /function pointers/
        in languages such as C++.

    - /Reflection/ is a _powerful_ and _complex_ mechanism;
      however, it is of interest MAINLY TO _tool builders_, NOT _application
      programmers_.

**** DONE 5.7.1 The ~Class~ Class - 261
     CLOSED: [2019-05-17 Fri 12:26]
     - While your program is running, the Java runtime system always maintains what
       is called runtime type identification on all objects. This information
       keeps track of the class to which each object belongs. Runtime type
       information is used by the virtual machine to select the correct methods
       to execute.

     - ~Class.forName~ accept a string parameter like ="java.util.Random"=
       =TODO= NOTE

     - *TIP*:
       + =TODO= JVM class file loading

       + At startup, the class containing your main method is loaded. It loads all
         classes that it needs. Each of those loaded classes loads the classes that it
         needs, and so on. That can take a long time for a big application, frustrating the
         user.You can give the users of your program an illusion of a faster start with
         the following trick. Make sure the class containing the main method does not explicitly
         refer to other classes. In it, display a splash screen. Then manually force
         the loading of other classes by calling Class.forName.

     - Obtain an object of type ~Class~ is a convenient shorthand.
       If ~T~ is ANY Java type (or the ~void~ keyword), then ~T.class~ is the
       matching /class object/.
       + For example:
         #+begin_src java
           Class cl1 = Random.class;  // if you import `java.util.*`
           Class cl2 = int.class;
           Class cl3 = Double[].class;
         #+end_src

     - *NOTE*
       *The ~Class~ /class/ is actually a /generic class/.* For example,
       ~Employee.class~ is of type ~Class<Employee>~.
       =TODO=
         We are not dwelling on this issue because it would further complicate an
       already abstract concept. For most practical purposes, you can ignore the
       type parameter and work with the raw Class type. See Chapter 8 for more
       information on this issue.

     - *CAUTION*
       For historical reasons, the ~getName~ /method/ returns somewhat strange names
       for /array types/ (=from Jian= this is their representations in java class
       file):
       + ~Double[].class.getName()~ returns ~"[Ljava.lang.Double;"~
       + ~int[].class.getName()~ returns ~"[I"~

     - =from Jian=
       + Why there is no ~;~ at end of the ~int[].class.getName()~ result???

     - The JVM manages a *unique* ~Class~ object for EACH /type/.
       Therefore, *you can use the ~==~ operator to compare /class objects/:*
       ~e.getClass() == Employee.class~

     - Create an /instance/ of a /class/ _on the fly_.
       ~e.getClass().newInstance();~ -- an exception is thrown if the /class/ does
       _NOT_ have a /no-argument constructor/.

     - A combination of ~forName~ and ~newInstance~ lets you create an object from
       a _class name_ stored in a string:
       #+begin_src java
         String s = "java.util.Random";
         Object m = Class.forName(s).newInstance();
       #+end_src

     - *NOTE*
       When you need to provide parameters for the constructor of a class,
       use the ~java.lang.reflect.Constructor.newInstance(Object[] args)~ /method/.
       =TODO= See section 5.7.6 for more info on how to supply parameters. =TODO=

     - *C++ NOTE*
       =TODO=
       C++ and Java comparison.

**** DONE 5.7.2 A Primer on Catching Exceptions - 263
     CLOSED: [2019-05-17 Fri 12:36]
     When doint relfections, like using ~static Class formName(String className)~
     /method/, you often need to handle exceptions.

**** DONE 5.7.3 Resources
**** TODO 5.7.4 Using Reflection to Analyze the Capabilities of Classes - 265
     Here is a brief overview of the most important parts of the reflection
     mechanism for letting you examine the structure of a class.

     - There are ~Field~, ~Method~, and ~Constructor~ in the ~java.lang.reflect~
       package.

**** TODO 5.7.5 Using Reflection to Analyze Objects at Runtime - 271
**** TODO 5.7.6 Using Reflection to Write Generic Array Code - 276
     The ~Array~ /class/ in the ~java.lang.reflect~ /package/ allows you to _create
     /arrays/ dynamically_.

     - This is used, for example, in the implementation of the ~copyOf~ /method/ in
       the ~Arrays~ /class/.
       #+begin_src java
         Employee[] a = new Employee[100];
         // ...
         // array is full
         a = Arrays.copyOf(a, 2 * a.length);
       #+end_src
       + Q :: How can one write such a /generic method/?
              It helps that an ~Employee[]~ array can be converted to an
              ~Object[]~ array. =???=
       + A :: xx
         * Bad and useless solution:
           #+begin_src java
             pbulic static Object[] badCopyOf(Object[] a, int newLength) // not useful
             {
                 Object[] newArray = new Object[newLength];
                 System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));
                 return newArray;
             }
           #+end_src
           The problem of this solution is the return type ~Object[]~ is not what
           we want!

         * Good solution:
           #+begin_src java
             public static Object goodCopyOf(Object a, int newLength) {
                 Class cl = a.getClass();
                 if (!cl.isArray())
                     return null;
                 else {
                     Class componentType = cl.getComponentType();
                     Object newArray = Array.newInstance(componentType, newLength);
                     int length = Array.getLength(a);
                     System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));
                     return newArray;
                 }
             }
           #+end_src

**** TODO 5.7.6 Invoking Arbitrary Methods and Constructors - 279
     On the surface, Java does NOT have C/C++-like /method pointers/ -- that is,
     ways of giving the location of a /method/ to anthoer /method/. This is Java's
     design decision (in general, for most cases).
       However, the /reflection/ mechanism allows you to call arbirary /methods/.

     - NOTE: =TODO= =TODO=
       C#'s /delegate/

     -

*** 5.8 Design Hints for Inheritance - 283

** TODO Chapter 6: Interfaces, Lambda Expressions, and Inner Classes - 287
*** 6.1 Interfaces - 288
**** 6.1.1 The Interface Concept - 288
**** 6.1.2 Properties of Interfaces - 295
**** 6.1.3 Interfaces and Abstract Classes - 297
**** 6.1.4 Static and Private Methods - 298
**** 6.1.5 Default Methods - 298
**** 6.1.6 Resolving Default Method Conflicts - 300
**** 6.1.7 Interfaces and Callbacks - 302
**** 6.1.8 The ~Comparator~ Interface - 305
**** 6.1.9 Object Cloning - 306

*** 6.2 Lambda Expressions - 314
**** 6.2.1 Why Lambdas? - 314
**** 6.2.2 The Syntax of Lambda Expressions - 315
**** 6.2.3 Functional Interfaces - 318
**** 6.2.4 Method References - 319
**** 6.2.5 Constructor References - 321
**** 6.2.6 Variable Scope - 322
**** 6.2.7 Processing Lambda Expressions - 324
**** 6.2.8 More about Comparators - 328

*** 6.3 Inner Classes - 329
**** 6.3.1 Use of an Inner Class to Access Object State - 331
**** 6.3.2 Special Syntax Rules for Inner Classes - 334
**** 6.3.3 Are Inner Classes Useful? Actually Necessary? Secure? - 335
**** 6.3.4 Local Inner Classes - 339
**** 6.3.5 Accessing Variables from Outer Methods - 339
**** 6.3.6 Anonymous Inner Classes - 342
**** 6.3.7 Static Inner Classes - 346

*** 6.4 Service Loaders
*** 6.5 Proxies - 350
**** 6.5.1 When to Use Proxies - 350
**** 6.5.2 Creating Proxy Objects - 350
**** 6.5.3 Properties of Proxy Classes - 355

** TODO Chapter 7: Exceptions, Assertions, and Logging - 357
   - If you don't want users who are using your software go away forever because of
     a programming mistake or some external circumstance, you must:
     + Notify the user of an erro
     + Save all work
     + Allow users to gracefully exit the program

*** 7.1 Dealing with Errors - 358
    - TODO NOTE
    - TODO NOTE
    - TODO NOTE

**** DONE 7.1.1 The Classification of Exceptions - 359
     CLOSED: [2020-01-08 Wed 01:03]
     - In Java, an /exception/ object is *ALWAYS* an instance of a /class/ derived
       from ~Throwable~!

     - Figure 7.1 Exception hierarchy in Java
                                       |- ...
                     |---- ~Error~ ----|- ...
                     |                 |- ...
       ~Throwable~ --|
                     |                  |- ~RuntimeException~
                     --- ~Exception~ --- - ~IOException~
                                        |- ...

       + ~Error~
         * isemantics describes
           - /internal errors/
           - /resource EXHAUSTION situations/ inside the /Java Runtime System/.

         * You should not throw an object of type/subtype of ~Error~  -- there is
           little you can do, beyond notifying the user and trying to termiate the
           program gracefully.

         * ~Erro~ is quite RARE.

       + ~Exception~ has _TWO_ /DIRECT subclass/, see above.
         * The rule "if it is a ~RuntimeException~, it was your fault" works pretty
           well. For example, ~ArrayIndexOutOfBoundsException~ and ~NullPointerException~.
           - =from Jian=
             There is another situation, sometimes you just want to throw out an
             /exception/ and terminate your program, but the /exception/ is by
             accident a /checked exception/. People often wrap this /exception/ info
             in to a ~RuntimeException~, and throw it.

           - ~Error~ and ~RuntimeException~ belong to the category called as
             /unchecked exception/. All other exceptions are /checked exceptions/.

     - *C++ Note*
       C++ has *TWO* FUNDAMENTAL /exception classes/:
       + ~runtime_error~: unpredictable problems --
         completely opposite to the throwables that are not ~RuntimeException~.

       + ~logic_error~: logical errors in program --
         it is the equivalent of Java's ~RuntimeException~.

**** DONE 7.1.2 Declaring Checked Exceptions - 361
     CLOSED: [2020-01-10 Fri 20:32]
     Not only tell the Java compiler the input and output of a /method/,
     BUT ALSO tell the compiler what can go wrong (=from Jian= of course, only
     the ones that can be handled by programmers -- /checked exceptions/).

     - Examples:
       + ~public FileInputStream(String name) throws FileNotFoundException~
       + ~public Image loadImage(String s) throws FileNotFoundException, EOFException~

     - /unchecked exceptions/ are either beyond your control (~Error~) or result
       from conditions that you should not have allowed in the first place
       (~RuntimeException~).

     - *CAUTION*
       If you _override a method_ from a superclass,
       the /checked exceptions/ that the subclass method declares *cannot be
       more general than those of the superclass method*.
       + It is OK to (=from Jian= What's the subtype relation if take the ~throws~
         statement as a part of the type signature TODO)
         * throw _more specific_ exceptions,
           or
         * _not to throw any_ exceptions in the subclass method.

     - *C++ Note*
       TODO

**** TODO 7.1.3 How to Throw an Exception - 364
**** TODO 7.1.4 Creating Exception Classes - 365

*** 7.2 Catching Exceptions - 367
**** 7.2.1 Catching an Exception - 367
**** 7.2.2 Catching Multiple Exceptions - 369
**** 7.2.3 Rethrowing and Chaining Exceptions - 370
**** 7.2.4 The ~finally~ Clause - 372
**** 7.2.5 The ~try~-with-Resources Statement - 376
**** 7.2.6 Analyzing Stack Trace Elements - 377

*** 7.3 Tips for Using Exceptions - 381
*** 7.4 Using Assertions - 384
**** 7.4.1 The Assertion Concept - 384
**** 7.4.2 Assertion Enabling and Disabling - 385
**** 7.4.3 Using Assertions for Parameter Checking - 386
**** 7.4.4 Using Assertions for Documenting Assumptions - 387

*** 7.5 Logging - 389
**** 7.5.1 Basic Logging - 389
**** 7.5.2 Advanced Logging - 390
**** 7.5.3 Changing the Log Manager Configuration - 392
**** 7.5.4 Localization - 393
**** 7.5.5 Handlers - 394
**** 7.5.6 Filters - 398
**** 7.5.7 Formatters - 399
**** 7.5.8 A Logging Recipe - 399

*** 7.6 Debugging Tips - 409

** TODO Chapter 8: Generic Programming - 415
*** 8.1 Why Generic Programming? - 416
**** 8.1.1 The Advantage of Type Parameters - 416
**** 8.1.2 Who Wants to Be a Generic Programmer? - 417

*** 8.2 Defining a Simple Generic Class - 418
*** 8.3 Generic Methods - 421
*** 8.4 Bounds for Type Variables - 422
*** 8.5 Generic Code and the Virtual Machine - 425
**** 8.5.1 Type Erasure - 425
**** 8.5.2 Translating Generic Expressions - 426
**** 8.5.3 Translating Generic Methods - 427
**** 8.5.4 Calling Legacy Code - 429

*** 8.6 Restrictions and Limitations - 430
**** 8.6.1 Type Parameters Cannot Be Instantiated with Primitive Types - 430
**** 8.6.2 Runtime Type Inquiry Only Works with Raw Types - 431
**** 8.6.3 You Cannot Create Arrays of Parameterized Types - 431
**** 8.6.4 Varargs Warnings - 432
**** 8.6.5 You Cannot Instantiate Type Variables - 433
**** 8.6.6 You Cannot Construct a Generic Array - 434
**** 8.6.7 Type Variables Are Not Valid in Static Contexts of Generic Classes - 436
**** 8.6.8 You Cannot Throw or Catch Instances of a Generic Class - 436
**** 8.6.9 You Can Defeat Checked Exception Checking - 437
**** 8.6.10 Beware of Clashes after Erasure - 439

*** 8.7 Inheritance Rules for Generic Types - 440
*** 8.8 Wildcard Types - 442
**** 8.8.1 The Wildcard Concept - 442
**** 8.8.2 Supertype Bounds for Wildcards - 444
**** 8.8.3 Unbounded Wildcards - 447
**** 8.8.4 Wildcard Capture - 448

*** 8.9 Reflection and Generics - 450
**** 8.9.1 The Generic ~Class~ Class - 450
**** 8.9.2 Using ~Class<T>~ Parameters for Type Matching - 452
**** 8.9.3 Generic Type Information in the Virtual Machine - 452
**** 8.9.4 Type Literals

     
** TODO Chapter 9: Collections - 481
*** 9.1 The Java Collections Framework - 482
**** 9.1.1 Separating Collection Interfaces and Implementation - 482
**** 9.1.2 The ~Collection~ Interface - 485
**** 9.1.3 Iterators - 485
**** 9.1.4 Generic Utility Methods - 489

*** 9.2 Interfaces in the Collections Framework - 492
*** 9.3 Concrete Collections - 494
**** 9.3.1 Linked Lists - 496
**** 9.3.2 Array Lists - 507
**** 9.3.3 Hash Sets - 507
**** 9.3.4 Tree Sets - 511
**** 9.3.5 Queues and Deques - 516
**** 9.3.6 Priority Queues - 518

*** 9.4 Maps - 519
**** 9.4.1 Basic Map Operations - 519
**** 9.4.2 Updating Map Entries - 523
**** 9.4.3 Map Views - 525
**** 9.4.4 Weak Hash Maps - 526
**** 9.4.5 Linked Hash Sets and Maps - 527
**** 9.4.6 Enumeration Sets and Maps - 529
**** 9.4.7 Identity Hash Maps - 530

*** 9.5 Views and Wrappers - 532
**** 9.5.1 Small Collections - 532
**** 9.5.2 Subranges - 534
**** 9.5.3 Unmodifiable Views - 535
**** 9.5.4 Synchronized Views - 536
**** 9.5.5 Checked Views - 536
**** 9.5.6 A Note on Optional Operations - 537

*** 9.6 Algorithms - 541
**** 9.6.1 Why Generic Algorithms? - 541
**** 9.6.2 Sorting and Shuffling - 543
**** 9.6.3 Binary Search - 546
**** 9.6.4 Simple Algorithms - 547
**** 9.6.5 Bulk Operations - 549
**** 9.6.6 Converting between Collections and Arrays - 550
**** 9.6.7 Writing Your Own Algorithms - 551

*** 9.7 Legacy Collections - 552
**** 9.7.1 The ~Hashtable~ Class - 553
**** 9.7.2 Enumerations - 553
**** 9.7.3 Property Maps - 555
**** 9.7.4 Stacks - 558
**** 9.7.5 Bit Sets - 559
     
** TODO Chapter 10: Graphics User Interface Programming - 565
*** 10.1 A History of Java User Interface Toolkits - 565
*** 10.2 Displaying Frames - 567
**** 10.2.1 Creating a Frame - 568
**** 10.2.2 Frame Properties - 570

*** 10.3 Displaying Information in a Component - 574
**** 10.3.1 Working with 2D Shapes - 579
**** 10.3.2 Using Color - 587
**** 10.3.3 Using Fonts - 589
**** 10.3.4 Displaying Images - 597

*** 10.4 Event Handling - 598
**** 10.4.1 Basics Event Handling Concepts - 598
**** 10.4.2 Example: Handling a Button Click - 600
**** 10.4.3 Specifying Listeners Concisely - 604
**** 10.4.4 Adapter Classes - 605
**** 10.4.5 Actions - 608
**** 10.4.6 Mouse Events - 614
**** 10.4.7 The AWT Event Hierarchy - 620

*** 10.5 The Preferences API - 624

** TODO Chapter 11: User Interface Components with Swing - 631
*** 11.1 Swing and the Model-View-Controller Design Pattern - 632
*** 11.2 Introduction to Layout Management - 636
**** 11.2.1 Layout Managers
**** 11.2.2 Border Layout
**** 11.2.3 Grid Layout

*** 11.3 Text Input - 643
**** 11.3.1 Text Fields
**** 11.3.2 Labels and Labeling Components
**** 11.3.3 Password Fields
**** 11.3.4 Text Areas
**** 11.3.5 Scroll Panes

*** 11.4 Choice Components - 651
**** 11.4.1 Checkboxes
**** 11.4.2 Radio Buttons
**** 11.4.3 Borders
**** 11.4.4 Combo Boxes
**** 11.4.5 Sliders

*** 11.5 Menus - 671
**** 11.5.1 Menu Building
**** 11.5.2 Icons in Menu Items
**** 11.5.3 Checkbox and Radio Button Menu Items
**** 11.5.4 Pop
**** 11.5.5 Keyboard Mnemonics and Accelerators
**** 11.5.6 Enabling and Disabling Menu Items
**** 11.5.7 Toolbars
**** 11.5.8 Tooltips

*** 11.6 Sophisticated Layout Management - 690
**** 11.6.1 The Grid Bag Layout
***** 11.6.1.1 The ~gridx~, ~gridy~, ~gridwidth~, and ~gridheight~ Parameters
***** 11.6.1.2 Weight Fields
***** 11.6.1.3 The ~fill~ and ~anchor~ Parameters
***** 11.6.1.4 Padding
***** 11.6.1.5 Alternative Method to Specify the ~gridx~, ~gridy~, ~gridwidth~, and ~gridheight~ Parameters
***** 11.6.1.6 A Grid Bag Layout Recipe
***** 11.6.1.7 A Helper Class to Tame the Grid Bag Constraints

**** 11.6.2 Custom Layout Managers

*** 11.7 Dialog Boxes - 706
**** 11.7.1 Option Dialogs
**** 11.7.2 Creating Dialogs
**** 11.7.3 Data Exchange
**** 11.7.4 File Dialogs
     
** TODO Chapter 12: Concurrency - 733
   - process :: xxx

   - thread :: yyy

*** TODO 12.1 What Are Threads? - 734
    - A bouncing ball animation.
      Figure 14.1

    - We first show the single thread version.

    - Launches a ball from the upper left corner of the screen and the ball begins
      bouncing.
      + The handler of the Start button calls the ~addBall~ method.
        This /method/ contains a loop running through 1000 moves, and each call to
        ~move~ moves the ball by a small amount, adjusts the direction if it bounces
        against a wall, and redraws the panel.

    - code
      #+BEGIN_SRC java
        Ball ball = new Ball();
        panel.add(ball);

        for (int i = 1; i <= STEPS; i++)
        {
            ball.move(panel.getBounds());
            panel.paint(panel.getGraphics());
            Thread.sleep(DELAY);
        }
      #+END_SRC
      + The the ~Thread.sleep~ make the _current_ /thread/ pause.

      + The ~sleep~ /method/ can *throw* an ~InterruptedException~.
        We discuss this /exception/ and its proper handling _LATER_.

        For now, we simply terminate the bouncing if this /exception/ occurs.

*** TODO 12.2 Thread States - 739
**** 12.2.1 New Threads - 740
**** 12.2.2 Runnable Threads - 740
**** 12.2.3 Blocked and Waiting Threads - 741
**** 12.2.4 Terminated Threads - 742

*** TODO 12.3 Thread Properties - 743
**** 12.3.1 Interrupting Threads - 743
**** 12.3.2 Daemon Threads - 746
**** 12.3.3 Thread Names - 747
**** 12.3.4 Handlers for Uncaught Exceptions - 747
**** 12.3.5 Thread Properties - 749

*** TODO 12.4 Synchronization - 750
**** 12.4.1 An Example of a Race Condition
**** 12.4.2 The Race Condition Explained
**** 12.4.3 Lock Objects
**** 12.4.4 Condition Objects
**** 12.4.5 The ~synchronized~ Keyword
**** 12.4.6 Synchronized Blocks
**** 12.4.7 The Monitor Concept
**** 12.4.8 Volatile Fields
**** 12.4.9 Final Variables
**** 12.4.10 Atomics
**** 12.4.11 Deadlocks
**** 12.4.12 Thread-Local Variables
**** 12.4.13 Why the ~stop~ and ~suspend~ Methods Are Deprecated

*** TODO 12.5 Thread-Safe Collections - 781
**** 12.5.1 Blocking Queues
**** 12.5.2 Efficient Maps, Sets, and Queues
**** 12.5.3 Atomic Update of Map Entries
**** 12.5.4 Bulk Operations on Concurrent Hash Maps
**** 12.5.5 Concurrent Set Views
**** 12.5.6 Copy on Write Arrays
**** 12.5.7 Parallel Array Algorithms
**** 12.5.8 Older Thread-Safe Collections

*** TODO 12.6 Tasks and Thread Pools - 800
**** TODO 12.6.1 Callables and Futures
**** TODO 12.6.2 Executors
**** TODO 12.6.3 Controlling Groups of Tasks
**** TODO 12.6.4 The Fork-Join Framework

*** TODO 12.7 Asynchronous Computations - 814
**** 12.7.1 Completable Futures - 815
**** 12.7.2 Composing Completable Futures - 817
**** 12.7.3 Long-Running Tasks in User Interface Callbacks - 823

*** TODO 12.8 Processes - 831
**** TODO 12.8.1 Building a Process - 832
**** TODO 12.8.2 Running a Process - 834
**** TODO 12.8.3 Process Handles - 835
     
** TODO Appendix A - 839
** TODO Index - 843
** TODO Bonus Chapter 13: JavaFX - 1
*** 13.1 A Brief History of Java GUI Programming - 1
*** 13.2 Displaying Information in a Scene - 3
**** 13.2.1 Our First JavaFX Application - 3
**** 13.2.2 Drawing Shapes - 7
**** 13.2.3 Text and Images - 11
     
*** 13.3 Event Handling - 16
**** 13.3.1 Implementing Event Handlers - 16
**** 13.3.2 Reacting to Property Changes - 17
**** 13.3.3 Mouse and Keyboard Events - 20
     
*** 13.4 Layout - 28
**** 13.4.1 Layout Panes - 29
**** 13.4.2 FXML - 35
**** 13.4.3 CSS - 42
    
*** 13.5 User Interface Controls - 47
**** 13.5.1 Text Input - 47
**** 13.5.2 Choices - 52
**** 13.5.3 Menus - 59
**** 13.5.4 Simple Dialogs - 67
**** 13.5.5 Fancy Controls - 77
     
*** 13.6 Properties and Bindings - 82
**** 13.6.1 JavaFX Properties - 82
**** 13.6.2 Bindings - 84

*** 13.7 Long-Running Tasks in User Interface Callbacks - 91 
    
* Volumne II
** TODO Chapter 1: Streams
   /Streams/ provide _a view of data_ that lets you specify computations at a
   higher conceptual level. With a /stream/, you specify what, not how!

   - You leave the scheduling of operations to the implementation.
     TODO: Simplify this example.
     For example, suppose you want to compute the average of a certain property.
     You specify the source of data and the property, and the stream library can
     then optimize the computation, for example by using multiple threads for
     computing sums and counts and combining the results.

*** DONE 1.1 From Iterating to Stream Operations
    CLOSED: [2019-12-19 Thu 19:40]
    - Example:
      #+begin_src java
        // Read file into string
        var contents = new String(Files.readAllBytes(Paths.get("alice.txt")), StandardCharsets.UTF_8);
        // Split into words; nonletters are delimiters
        List<String> words = List.of(contents.split("\\PL+"));

        // Java's traditional way
        int count = 0;
        for (String w: words) {
            if (w.length() > 12) ++count;
        }

        // Use Stream
        long count = words.stream()
            .filter(w -> w.length() > 12)
            .count();
      #+end_src
      + Optimize the _stream version_ is simply:
        #+begin_src java
          long count = words.parallelStream()
              .filter(w -> w.length() > 12)
              .count();
        #+end_src

    - Difference between /streams/ and /collections/:
      1. _A /stream/ doesn't store its elements._

      2. Immutable

      3. /Lazy/ when possible.

    - For the /stream/, there are
      + /intermediate operations/ (lazy)
      + /terminal operation/ (eager).

    - APIs
      + ~Stream<T> filter(Predicate<? super T> p)~
      + ~long count()~
      + ~default Stream<E> stream()~
      + ~default Stream<E> parallelStream()~

*** TODO 1.2 Stream Creation
    #+begin_src java
      int power(int a, int b) {
          return
              switch(a) {
              case 0  -> 0;
              case aa ->
                  switch(b) {
                  case 0  -> 1;
                  case bb -> {
                      int half = power(a, b / 2);
                      yield b % 2 == 0 ? half * half: half * half * a;
                  }
              }
          }
      }
    #+end_src

*** TODO 1.3 The ~filter~, ~map~, and ~flatMap~ Methods
*** TODO 1.4 Extracting Substreams and Combining Streams
*** TODO 1.5 Other Stream Transformations
*** TODO 1.6 Simple Reductions
*** DONE 1.7 The Optional Type
    CLOSED: [2019-12-19 Thu 18:03]
    ~Optional<T>~ is safer only if you use it right.
    If you don't use ~Optional~ values correctly, you have no benefit over the
    "something or null" approach of the past.
    - =from Jian=
      + The essential difference between ~null~ and ~Optional<T>~ is that there is
        _no simple_ systematical way to deal with ~null~. Even if you can find a way,
        it will keep challenging human cognitive capacity, and finally make itself
        unapplicable.
          On the hand, there is a _simple_ systematical way can be used to deal
        with ~Optional<T>~, which is easy even for normal human cognitive
        capacity.

      + This means when we talk about ~Optional<T>~ is safer,
        * *we mean under some simple (simple to learn and simple to use)
          operation, it is simple*

        * *we don't mean without considering corresponding operations, ~Optional<T>~
          is more safer than ~null~.*

        * This is easy to understand that when we talk about an algebra, we talk
          about its property under some operations. Only the operations can define
          an algebra.

**** DONE 1.7.1 Getting an Optional Value
     CLOSED: [2019-12-19 Thu 16:47]
     #+begin_src java
       // The wrapped string, or "" if none
       String result = optionalString.orElse("");

       // The function is only called when needed
       String result = optionalString.orElseGet(() -> System.getProperty("myapp.default"));

       // Supply a method that yields an exception object
       String result = optionalString.orElseThrow(IllegalStateException::new);
     #+end_src
     - ~T orElse(T other)~
     - ~T orElseGet(Supplier<? extends T> other)~
     - ~<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)~

**** DONE 1.7.2 Consuming an Optional Value
     CLOSED: [2019-12-19 Thu 16:54]
     - The ~ifPresent~ /method/ is like Scala's ~option.foreach~ /method/.
       #+begin_src java
         // `process` is a function
         optionalValue.ifPresent(v -> process(v));

         // More concrete: add the wrapped value to a set
         optionalValue.ifPresent(results::add);
       #+end_src
       + ~void ifPresent(Consumer<? super T> action)~

     - Two actions for value present and value not present, respectively:
       #+begin_src java
         optionValue.ifPresentOrElse(v -> System.out.println("Found " + v),
                                     () -> logger.warning("No match"));
       #+end_src
       + ~void ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)~
         Added since Java 9

**** DONE 1.7.3 Pipelining Optional Values
     CLOSED: [2019-12-19 Thu 17:04]
     - ~map~ and ~filter~ methods
       #+begin_src java
         // TODO: Not separate side effect and side effect free case.
         //       Can we do similar thing as in Scala: when only side effect, use `ifPresent`
         optionalValue.map(results::add);

         Optional<String> transformed = optionalString
             .filter(s -> s.length() >= 8)
             .map(String::toUpperCase);
       #+end_src
       + ~<U> Optional<U> map(Function<? super T,? extends U> mapper)~
       + ~Optional<T> filter(Predicate<? super T> predicate)~

     - ~or~ method is like the ~option.orElse~ method in Scala:
       #+begin_src java
         // Supply an Optional
         Optional<String> result = optionalString.or(() -> alternatives.stream().findFirst());
       #+end_src
       + ~Optional<T> or(Supplier<? extends Optional<? extends T>> supplier)~
         Since Java 9

**** DONE 1.7.4 How Not to Work with Optional Values
     CLOSED: [2019-12-19 Thu 17:29]
     - Example 1:
       #+begin_src java
         Optional<T> optionalValue = . . .;
         optionalValue.get().someMethod()

         // is no safer than

         T value = . . .;
         value.someMethod();
       #+end_src
       + ~T get()~

     - Example 2:
       #+begin_src java
         if (optionalValue.isPresent()) optionalValue.get().someMethod();

         // is no easier than

         if (value != null) value.someMethod();
       #+end_src
       + ~boolean isPresent()~

     - TODO

     - NOTE
       *Java 10* introduces a _scarier-sounding synonym_ for the ~get~ /method/.
       Call ~optionalValue.orElseThrow()~ to *make explicit* that the method
       will throw a ~NoSuchElementException~ if the ~optionalValue~ is empty.
         The hope is that programmers will only call that method when it is
       absolutely clear that the ~Optional~ is never empty.
       + =from Jian=
         This is a standard Java style (imperative language style, or no strong
         enough type system language style) -- the dirty solution is Okay if the
         danger is explicit -- =from Jian= not a criticize.

     - ~T orElseThrow()~ since Java 10

     - Here are a few more tips for the proper use of the ~Optional~ type:
       + _A variable of type ~Optional~ should never be ~null~._
         =from Jian=
         This is not an issue of ~Optional~.
         This is an issue of Java that it can't remove ~null~ from the language
         itself -- for a real world language, we must deal with backward
         compatibility issue.

       + _Don't use fields of type ~Optional~._
         The cost is an additional object.
         Inside a class, using ~null~ for an absent field is manageable.

       + _Don't put ~Optional~ objects in a /set/, and don't use them as /keys/
         for a /map/._
         * Solution: *Collect the values instead.*

**** DONE 1.7.5 Creating Optional Values
     CLOSED: [2019-12-19 Thu 17:45]
     - ~Optional.of(v)~ and ~Optional.empty()~
       + ~static <T> Optional<T> of(T value)~
       + ~static <T> Optional<T> empty()~

     - ~Optional.ofNullable(obj)~ is like Scala's ~Option(obj)~.
       + ~static <T> Optional<T> ofNullable(T value)~

**** DONE 1.7.6 Composing Optional Value Functions with ~flatMap~
     CLOSED: [2019-12-19 Thu 17:48]
     ~<U> Optional<U> flatMap(Function<? super T,? extends Optional<? extends U>> mapper)~

**** DONE 1.7.7 Turning an Optional into a Stream
     CLOSED: [2019-12-19 Thu 18:03]
     The stream method turns an ~Optional<T>~ into a ~Stream<T>~ with zero or one
     element.

     - Q :: Sure, why not, but why would you ever want that?
     - A :: Answer by example: Suppose you have a stream of user IDs and a method
            ~Optional<User> lookup(String id)~.
       + Q :: How do you get a /stream/ of users, skipping those invalid IDs?
       + A :: Here are _two_ ways:
         * Naive and not elegant, though it is safe even though it uses ~isPresent~ and ~get~.
           #+begin_src java
             Stream<String> ids = ...;
             Stream<User> users = ids.map(Users::lookup)
                 .filter(Optional::isPresent)
                 .map(Optional::get);
           #+end_src
           We still want to avoid the /look unsafe methods/ (low level API),
           especially in a not-low-level application.

         * Elegant way with no _low level API_:
           #+begin_src java
             Stream<User> users = ids.map(Users::lookup).flatMap(Optional::stream);
           #+end_src

     - NOTE
       An example of work with the exist _return ~null~ methods_:
       #+begin_src java
         // `Users::classicLookup` can return `null`

         // 1
         Stream<User> users = ids.map(Users::classicLookup).filter(Objects::nonNull);

         // 2
         Stream<User> users = ids.flatMap(id -> Stream.ofNullable(Users::classicLookup(id)))

         // 3
         Stream<User> users = ids.map(Users::classicLookup).flatMap(Stream::ofNullable);
       #+end_src
       + =from Jian=
         Since ~Stream~ is /lazy/, I don't prefer the *2* way, which has a nested
         function call. It is not as readable as *1* and *3*.

*** TODO 1.8 Collecting Results
*** TODO 1.9 Collecting into Maps
*** TODO 1.10 Grouping and Partitioning
*** TODO 1.11 Downstream Collectors
*** TODO 1.12 Reduction Operations
*** TODO 1.13 Primitive Type Streams
*** TODO 1.14 Parallel Streams

** TODO Chapter 2: Input and Output
*** 2.1 Input/Output Streams
**** 2.1.1 Reading and Writing Bytes
**** 2.1.2 The Complete Stream Zoo
**** 2.1.3 Combining Input/Output Stream Filters
**** 2.1.4 Text Input and Output
**** 2.1.5 How to Write Text Output
**** 2.1.6 How to Read Text Input
**** 2.1.7 Saving Objects in Text Format
**** 2.1.8 Character Encodings

*** 2.2 Reading and Writing Binary Data
**** 2.2.1 The DataInput and DataOutput interfaces
**** 2.2.2 Random-Access Files
**** 2.2.3 ZIP Archives

*** 2.3 Object Input/Output Streams and Serialization
**** 2.3.1 Saving and Loading Serializable Objects
**** 2.3.2 Understanding the Object Serialization File Format
**** 2.3.3 Modifying the Default Serialization Mechanism
**** 2.3.4 Serializing Singletons and Typesafe Enumerations
**** 2.3.5 Versioning
**** 2.3.6 Using Serialization for Cloning

*** 2.4 Working with Files
**** 2.4.1 Paths
**** 2.4.2 Reading and Writing Files
**** 2.4.3 Creating Files and Directories
**** 2.4.4 Copying, Moving, and Deleting Files
**** 2.4.5 Getting File Information
**** 2.4.6 Visiting Directory Entries
**** 2.4.7 Using Directory Streams
**** 2.4.8 ZIP File Systems

*** 2.5 Memory-Mapped Files
**** 2.5.1 Memory-Mapped File Performance
**** 2.5.2 The Buffer Data Structure

*** 2.6 File Locking
*** 2.7 Regular Expressions
**** 2.7.1 The Regular Expression Syntax
**** 2.7.2 Matching a String
**** 2.7.3 Finding Multiple Matches
**** 2.7.4 Splitting along Delimiters
**** 2.7.5 Replacing Matches

** Chapter 3: XML
*** 3.1 Introducing XML
*** 3.2 The Structure of an XML Document
*** 3.3 Parsing an XML Document
*** 3.4 Validating XML Documents
**** 3.4.1 Document Type Definitions
**** 3.4.2 XML Schema
**** 3.4.3 A Practical Example

*** 3.5 Locating Information with XPath
*** 3.6 Using Namespaces
*** 3.7 Streaming Parsers
**** 3.7.1 Using the SAX Parser
**** 3.7.2 Using the StAX Parser

*** 3.8 Generating XML Documents
**** 3.8.1 Documents without Namespaces
**** 3.8.2 Documents with Namespaces
**** 3.8.3 Writing Documents
**** 3.8.4 Writing an XML Document with StAX
**** 3.8.5 An Example: Generating an SVG File

*** 3.9 XSL Transformations

** TODO Chapter 4: Networking
*** 4.1 Connecting to a Server
**** 4.1.1 Using Telnet
**** 4.1.2 Connecting to a Server with Java
**** 4.1.3 Socket Timeouts
**** 4.1.4 Internet Addresses

*** 4.2 Implementing Servers
**** 4.2.1 Server Sockets
**** 4.2.2 Serving Multiple Clients
**** 4.2.3 Half-Close
**** 4.2.4 Interruptible Sockets

*** 4.3 Getting Web Data
**** 4.3.1 URLs and URIs
**** 4.3.2 Using a URLConnection to Retrieve Information
**** 4.3.3 Posting Form Data

*** 4.4 The HTTP Client
*** 4.5 Sending E-Mail

** Chapter 5: Database Programming
*** 5.1 The Design of JDBC
**** 5.1.1 JDBC Driver Types
**** 5.1.2 Typical Uses of JDBC

*** 5.2 The Structured Query Language
*** 5.3 JDBC Configuration
**** 5.3.1 Database URLs
**** 5.3.2 Driver JAR Files
**** 5.3.3 Starting the Database
**** 5.3.4 Registering the Driver Class
**** 5.3.5 Connecting to the Database

*** 5.4 Working with JDBC Statements
**** 5.4.1 Executing SQL Statements
**** 5.4.2 Managing Connections, Statements, and Result Sets
**** 5.4.3 Analyzing SQL Exceptions
**** 5.4.4 Populating a Database

*** 5.5 Query Execution
**** 5.5.1 Prepared Statements
**** 5.5.2 Reading and Writing LOBs
**** 5.5.3 SQL Escapes
**** 5.5.4 Multiple Results
**** 5.5.5 Retrieving Autogenerated Keys

*** 5.6 Scrollable and Updatable Result Sets
**** 5.6.1 Scrollable Result Sets
**** 5.6.2 Updatable Result Sets

*** 5.7 Row Sets
**** 5.7.1 Constructing Row Sets
**** 5.7.2 Cached Row Sets

*** 5.8 Metadata
*** 5.9 Transactions
**** 5.9.1 Programming Transactions with JDBC
**** 5.9.2 Save Points
**** 5.9.3 Batch Updates
**** 5.9.4 Advanced SQL Types

*** 5.10 Connection Management in Web and Enterprise Applications

** DONE Chapter 6: The Date and Time API - TODO =READ-API-DOC=
   CLOSED: [2019-12-19 Thu 12:24]
   Time is simple, but deal with humans time is complicated!!!
   - In this chapter, you will learn
     + what makes time computations so vexing
     + how the Date and Time API solves these issues.

*** DONE 6.1 The Time Line
    CLOSED: [2019-12-19 Thu 01:29]
    - The Java Date and Time API specification requires that Java uses a time scale
      that (these give Java the flexibility to adjust to future changes in the
      official time TODO TODO TODO =WHY= ???):
      + Has 86,400 seconds per day (smoothing /leap seconds/)
      + Exactly matches the official time at noon each day
      + Closely matches it elsewhere, in a precisely defined way

    - ~java.time.Instant~ represents a point on the time line (=from Jian= the role
      of, though not officially, effectively deprecated ~java.util.Date~).

    - ~Instant~ has nanosecond precision.

    - ~Instant.MIN~ and ~Instant.MAX~ -- they are in billion years order, which
      is enough to describe all practical purposes for human society, though not
      enough to describe the age of the universe (around 13.5 billion years).

    - ~Instant.now()~

    - duration (in java time concepts) :: the amount of time between two instants.

    - Use ~Duration.between~ to find out the difference between two /instants/.

    - Get the lenght of a ~Duration~ in conventional units by calling ~toNanos~,
      ~toMillis~, ~toSeconds~, ~toMinutes~, ~toHours~, or ~toDays~.
      + NOTE
        In Java 8, there is no ~toSeconds~, and you had to call ~getSeconds~ instead.
        * =from Jian= ~toSeconds~ and ~getSeconds~ have the same implementation.
          _WHY_ Java 9 add ~toSeconds~ /methods/ and not deprecate ~getSeconds~
          /method/?

        * A ~long~ can hold almost 300 years of *nanoseconds*.
          *ONLY* when your durations are shorter than that, ~toNanos~ can work
          without /overflow/.
          - =from Jian=
            Good news is that if it /overflow/, you can see an ~ArithmeticException~.
            I get this info by reading the comment of ~toNanos~

    - *The ~Instant~ and ~Duration~ object are _IMMUTABLE_.*

    - ~instant.plus~, ~instant.minus~, ~duration.plus~, and ~duration.minus~
      require ~TemporalAmount~ type parameter, and both ~Duration~ and ~Period~
      implement the ~TemporalAmount~ interface.

    - The ~Duration.between~ /method/ requires ~Temporal~ interface type parameters,
      and the ~Instant~ class as well as ~LocalDate~ / ~LocalDateTime~ / ~LocalTime~
      implements ~Temporal~.

*** DONE 6.2 Local Dates
    CLOSED: [2019-12-19 Thu 04:27]
    In the last section we discussed the _absolute time_, and this section we will
    discuss _human time_.

    - There are *TWO* kinds of human time in the Java API:
      + local date/time (doesn't include time zone info)
      + zoned time

    - Recommendation:
      Don't use zoned time unless you really want to represent _ABSOLUTE time
      instances_.
      + For example,
        Birthday, holidays, schedule times, and so on are usually best represented
        as /locate dates or times/.

    - *UNLIKE* the irregular conventions in UNIX and ~java.util.Date~, where _months
      are zero-based_ and _years are counted from 1900_, you supply the usual numbers
      or correponding ~Month~ enumeration for the month of year.

    - The difference between two time instants of type ~Instant~ is a ~Duration~.
      The difference between two time local dates of type ~LocalDate~ is a ~Period~.

    - The ~LocalDate~ API take the /leap year/ into account, therefore, for example,
      when you calculate a birthday of next year from a given birthday,
      + the *RIGHT* ways
        * ~birthday.plus(Period.ofYears(1))~
        * ~birthday.plusYears(1)~

      + the *WRONG* way
        ~birthday.plus(Period.ofDays(365))~

    - =from Jian=
      + To get a /duration/ between two /instants/, we can
        * Use /static method/ ~Duration.between~
        * Use /instance method/ ~until(anotherInstant, timeUnit)~ (not exact types in code)

      + Similarly, to get a /period/ between two /local dates/, we can
        * Use /static method/ ~Period.between~
        * Use /instance method/ ~until(anotherLocalDate, timeUnit)~ (not exact types in code)

    - ~Instant~ has only one ~until~ /method/ with signature
      ~long until(Temporal endExclusive, TemporalUnit unit)~,
      while ~LocalDate~ has two ~unitl~ /methods/ with signatures
      ~long until(Temporal endExclusive, TemporalUnit unit)~ and ~Period until(Temporal endExclusive)~

    - =from Jian=
      You can't recover the exact time lapse from a ~Period~ instances.
      Once a ~Period~ instance is created, the infomation about the start and
      end dates are lost. Since different monthes has different days, the days
      in a February can change because of existence of /leap days/.
      + Because of this reason, if you want to know the exact time lapse, don't use
        the ~Period until(Temporal endExclusive)~ method of ~LocalDate~, and use
        the other ~long until(Temporal endExclusive, TemporalUnit unit)~.

    - ~LocalDate.of(1900, Month.January, 1).getDayOfWeek()~
      returns a enumeration value of ~DayOfWeek~.
      ~DayOfWeek~ enumeration values count from ~DayOfWeek.MONDAY~ of value ~1~.

    - ~DayOfWeek~ enumeration has convenience /methods/ ~plus~ and ~minus~ to
      compute weekdays modulo 7.

    - NOTE
      + ~java.time.DayOfWeek~'s /weekend days/ actually come at the end of the week.
      + ~java.util.Calendar.DAY_OF_WEEK~ has ~Sunday~ has value 1 and ~Saturday~ value 7.
        * =from Jian=
          This is why we shouldn't use ~Calendar~ even if it is not yet marked DEPRECATED.

    - Java 9 adds two useful /methods/ ~datesUntil~ that yield /streams/ of ~LocalDate~
      objects:
      #+begin_src java
        LocalDate start = LocalDate.of(2000, 1, 1);
        LocalDate endExclusive = LocalDate.now();
        Stream<LocalDate> allDays = start.datesUntil(endExclusive);
        Stream<LocalDate> firstDaysInMonth = start.datesUntil(endExclusive, Period.ofMonths(1));
        start.datesUntil(endExclusive, Period.ofMonths(1));
      #+end_src

    - Partial date info classes:
      + ~MonthDay~
      + ~YearMonth~
      + ~Year~

*** DONE 6.3 Date Adjusters - TODO _READ API DOC in the book_
    CLOSED: [2019-12-19 Thu 04:49]
    From the name of ~TemporalAdjusters~, according to the naming convention of
    Java library, we know it's a /utility class/ (a container for a group of
    /static methods/).

    - /Adjusters/ are used to do calculation like "get the first Tuesday of every
      month."
      #+begin_src java
        LocalDate firstTuesday = LocalDate.of(year, month, 1)
            .with(TemporalAdjusters.nextOrSame(DayOfWeek.TUESDAY));
      #+end_src

    - Make your own /adjuster/ by _implementing_ the ~TemporalAdjuster~ /interface/.
      Here is an /adjuster/ for computing the next weekday:
      #+begin_src java
        TemporalAdjuster NEXT_WORKDAY = w ->
        {
            var result = (LocalDate) w;
            do
            {
                result = result.plusDays(1);
            } while (result.getDayOfWeek().getValue() >= 6);

            return result;
        };

        LocalDate backToWork = today.with(NEXT_WORKDAY);
      #+end_src
      You must cast the ~Temporal~ type ~w~ to ~LocalDate~ to do your further
      calculation.
      + A better solution, *NO* /cast/:
        #+begin_src java
          TemporalAdjuster NEXT_WORKDAY = TemporalAdjusters.ofDateAdjuster(w ->
            {
                var result = w;  // NO cast
                do
                {
                    result = result.plusDays(1);
                } while (result.getDayOfWeek().getValue() >= 6);

                return result;
            });
        #+end_src

*** DONE 6.4 Local Time
    CLOSED: [2019-12-19 Thu 04:31]
    A ~LocalTime~ represents a time of day, such as 15:30:00.
    A ~LocalDateTime~ represents a date and the time of day.

    - The ~toString~ representation of ~LocalTime~ is a 24 hours form.
      NO AM/PM, which is a formatter issue. TODO See "Section 6.6".

*** DONE 6.5 Zoned Time
    CLOSED: [2019-12-19 Thu 11:48]
    - /Time zones/ are complicated due to
      1. They are an entirely human creation, are even messier than the complications
         caused by the _earth's irregular rotation_.
      2. Their _irregular and shifting boundaries_ and, to make matters worse, the
         /daylight savings time/.

    - The /Internet Assigned Numbers Authority (IANA)/ keeps a database of all known
      time zones around the world (http://www.iana.org/time-zones), which is updated
      several times per year.

    - Java uses the IANA database.

    - *Each time zone has an ID*.

    - Call ~ZoneId.getAvailableZoneIds~ to get all available time zones.

    - At the time of this wrting, there are almost 600 IDs.

    - Use ~ZonedId.of(id)~ to get the a ~ZonedId~ object.

    - Call ~localDateTime.atZone(zoneId)~ to get a ~ZonedDateTime~ object from a
      ~LocalDateTime~ object.

    - You can also construct a ~ZonedDateTime~ by calling the /static method/
      ~ZonedDateTime.of(year, month, day, hour, minute, second, nano, zoneId)~
      For example,
      #+begin_src java
        ZonedDateTime apollo11launch = ZonedDateTime.of(1969, 7, 16, 9, 32, 0, 0, ZoneId.of("America/New_York"));
        // 1969-07-16T09:32-04:00[America/New_York]
      #+end_src

    - ~ZonedDateTime~ <--> ~Instant~
      + Call ~zonedDateTime.toInstant~ to get an ~Instant~ object.
      + Call ~instant.atZone(zoneId)~ to get an ~ZonedDateTime~ object.

    - NOTE
      /UTC/ is a _compromise_ between "Coordinated Universal Time" (En) and
      "Temps Universel Coordiné", having the distinction of being incorrect in
      either language.
      + UTC is the time at the Greenwich Royal Observatory, without /daylight saving
        time/.

    - Many of the /methods/ of ~ZonedDateTime~ are the _SAME_ as those of ~LocalDateTime~
      (see the API notes at the end of this section).
      + Most are straightforward,
      + *but daylight savings time introduces some complications.*

    - Deal with /daylight saving time/:
      + Get a /daylight saving time/ ~ZonedDateTime~ object from the time before
        _START /daylight saving time/:_
        #+begin_src java
          ZonedDateTime skipped = ZonedDateTime.of(LocalDate.of(2013, 3, 31),
                                                   LocalTime.of(2, 30),
                                                   ZoneId.of("Europe/Berlin"));
          // Constructs March 31 3:30
          // NOT the nonexistent time March 31 2:30
        #+end_src

      + Get a not /daylight saving time/ ~ZonedDateTime~ object from the time of
        a _/daylight saving time/_:
        #+begin_src java
          // `ZonedDateTime.of` always create the earlier one
          ZonedDateTime ambiguous = ZonedDateTime.of(LocalDate.of(2013, 10, 27), // End of daylight savings time
                                                     LocalTime.of(2, 30),
                                                     ZoneId.of("Europe/Berlin"));
          // 2013-10-27T02:30+02:00[Europe/Berlin]

          // Use this way to get the later one.
          // You can see they have the same local time but different time zone.
          ZonedDateTime anHourLater = ambiguous.plusHours(1);
          // 2013-10-27T02:30+01:00[Europe/Berlin]
        #+end_src

      + *CAUTION*
        *ATTENTION*!!!
        _Adjusting a date across daylight savings time boundaries_.
        For example,
        if you set a meeting for next week,
        what you actually want is ~meetingTime.plus(Period.ofDays(7))~, and it
        shouldn't not ~meetingTime.plus(Duration.ofDays(7))~.
        * The plus /duration/ is not wrong, it is just not what you want!

        * =from Jian= =IMPORTANT=
          Most you want to work with _non-human-involved time_ (~Instant~ and
          ~Duration~) and _human-involved time_ (~ZonedDateTime~, ~LocalDateTime~,
          and ~Period~) *separately*.
            If you mix these two categories, the result is often not what you want,
          though the result is valid.

*** DONE 6.6 Formatting and Parsing - TODO _READ when using it_
    CLOSED: [2019-12-19 Thu 12:13]
    - NOTE
      The ~java.time.format.DateTimeFormatter~ class is intended as a replacement
      for ~java.util.DateFormat~. If you need an instance of the latter for
      backward compatibility, call ~formatter.toFormat()~.

*** DONE 6.7 Interoperating with Legacy Code
    CLOSED: [2019-12-19 Thu 12:23]
    The new Java Date and Time API will have to interoperate with existing
    classes -- in particular, the ubiquitous ~java.util.Date~,
    ~java.util.GregorianCalendar~, and ~java.sql.Date/Time/Timestamp~ and their
    subclasses.

    - To interoperate, both _new API_ and _old API_ have the back-and-forth conversion.

    - Table 6.4 Conversions between java.time Classes and Legacy Classes =IMPORTANT=
      =Re-Read=

    - =from Jian= Correspondance (simplified version of the first column in Table 6.4)
      + ~Instant~: ~java.util.Date~, ~java.nio.file.attribute.FileTime~
      + ~ZonedDateTime~: ~java.util.GregorianCalendar~ ( how about ~java.util.Calendar~???)
      + ~LocalDateTime~: ~java.sql.Timestamp~
      + ~LocalDate~: ~java.sql.Date~
      + ~LocalTime~: ~java.sql.Time~
      + ~DateTimeFormatter~: ~java.text.DateFormat~
      + ~ZoneId~: ~java.util.TimeZone~

** Chapter 7: Internationalization
*** 7.1 Locales
**** 7.1.1 Why Locales?
**** 7.1.2 Specifying Locales
**** 7.1.3 The Default Locale
**** 7.1.4 Display Names

*** 7.2 Number Formats
**** 7.2.1 Formatting Numeric Values
**** 7.2.2 Currencies

*** 7.3 Date and Time
*** 7.4 Collation and Normalization
*** 7.5 Message Formatting
**** 7.5.1 Formatting Numbers and Dates
**** 7.5.2 Choice Formats

*** 7.6 Text Input and Output
**** 7.6.1 Text Files
**** 7.6.2 Line Endings
**** 7.6.3 The Console
**** 7.6.4 Log Files
**** 7.6.5 The UTF-8 Byte Order Mark
**** 7.6.6 Character Encoding of Source Files

*** 7.7 Resource Bundles
**** 7.7.1 Locating Resource Bundles
**** 7.7.2 Property Files
**** 7.7.3 Bundle Classes

*** 7.8 A Complete Example

** TODO Chapter 8: Scripting, Compiling, and Annotation Processing
*** 8.1 Scripting for the Java Platform
**** 8.1.1 Getting a Scripting Engine
**** 8.1.2 Script Evaluation and Bindings
**** 8.1.3 Redirecting Input and Output
**** 8.1.4 Calling Scripting Functions and Methods
**** 8.1.5 Compiling a Script
**** 8.1.6 An Example: Scripting GUI Events

*** 8.2 The Compiler API
**** 8.2.1 Invoking the Compiler
**** 8.2.2 Launching a Compilation Task
**** 8.2.3 Capturing Diagnostics
**** 8.2.4 Reading Source Files from Memory
**** 8.2.5 Writing Byte Codes to Memory
**** 8.2.6 An Example: Dynamic Java Code Generation

*** 8.3 Using Annotations
**** 8.3.1 An Introduction into Annotations
**** 8.3.2 An Example: Annotating Event Handlers

*** 8.4 Annotation Syntax
**** 8.4.1 Annotation Interfaces
**** 8.4.2 Annotations
**** 8.4.3 Annotating Declarations
**** 8.4.4 Annotating Type Uses
**** 8.4.5 Annotating this

*** 8.5 Standard Annotations
**** 8.5.1 Annotations for Compilation
**** 8.5.2 Annotations for Managing Resources
**** 8.5.3 Meta-Annotations

*** 8.6 Source-Level Annotation Processing
**** 8.6.1 Annotation Processors
**** 8.6.2 The Language Model API
**** 8.6.3 Using Annotations to Generate Source Code

*** 8.7 Bytecode Engineering
**** 8.7.1 Modifying Class Files
**** 8.7.2 Modifying Bytecodes at Load Time

** TODO Chapter 9: The Java Platform Module System
*** 9.1 The Module Concept
*** 9.2 Naming Modules
*** 9.3 The Modular “Hello, World!” Program
*** 9.4 Requiring Modules
*** 9.5 Exporting Packages
*** 9.6 Modular JARs
*** 9.7 Modules and Reflective Access
*** 9.8 Automatic Modules
*** 9.9 The Unnamed Module
*** 9.10 Command-Line Flags for Migration
*** 9.11 Transitive and Static Requirements
*** 9.12 Qualified Exporting and Opening
*** 9.13 Service Loading
*** 9.14 Tools for Working with Modules

** Chapter 10: Security
*** 10.1 Class Loaders
**** 10.1.1 The Class-Loading Process
**** 10.1.2 The Class Loader Hierarchy
**** 10.1.3 Using Class Loaders as Namespaces
**** 10.1.4 Writing Your Own Class Loader
**** 10.1.5 Bytecode Verification

*** 10.2 Security Managers and Permissions
**** 10.2.1 Permission Checking
**** 10.2.2 Java Platform Security
**** 10.2.3 Security Policy Files
**** 10.2.4 Custom Permissions
**** 10.2.5 Implementation of a Permission Class

*** 10.3 User Authentication
**** 10.3.1 The JAAS Framework
**** 10.3.2 JAAS Login Modules

*** 10.4 Digital Signatures
**** 10.4.1 Message Digests
**** 10.4.2 Message Signing
**** 10.4.3 Verifying a Signature
**** 10.4.4 The Authentication Problem
**** 10.4.5 Certificate Signing
**** 10.4.6 Certificate Requests
**** 10.4.7 Code Signing

*** 10.5 Encryption
**** 10.5.1 Symmetric Ciphers
**** 10.5.2 Key Generation
**** 10.5.3 Cipher Streams
**** 10.5.4 Public Key Ciphers

** Chapter 11: Advanced Swing and Graphics
*** 11.1 Tables
**** 11.1.1 A Simple Table
**** 11.1.2 Table Models
**** 11.1.3 Working with Rows and Columns
***** 11.1.3.1 Column Classes
***** 11.1.3.2 Accessing Table Columns
***** 11.1.3.3 Resizing Columns
***** 11.1.3.4 Resizing Rows
***** 11.1.3.5 Selecting Rows, Columns, and Cells
***** 11.1.3.6 Sorting Rows
***** 11.1.3.7 Filtering Rows
***** 11.1.3.8 Hiding and Displaying Columns

**** 11.1.4 Cell Rendering and Editing
***** 11.1.4.1 Rendering Cells
***** 11.1.4.2 Rendering the Header
***** 11.1.4.3 Editing Cells
***** 11.1.4.4 Custom Editor
***** 11.1.4.4 Custom Editors

*** 11.2 Trees
**** 11.2.1 Simple Trees
***** 11.2.1.1 Editing Trees and Tree Paths

**** 11.2.2 Node Enumeration
**** 11.2.3 Rendering Nodes
**** 11.2.4 Listening to Tree Events
**** 11.2.5 Custom Tree Models

*** 11.3 Advanced AWT
**** 11.3.1 The Rendering Pipeline
**** 11.3.2 Shapes
***** 11.3.2.1 The Shape Class Hierarchy
***** 11.3.2.2 Using the Shape Classes

**** 11.3.3 Areas
**** 11.3.4 Strokes
**** 11.3.5 Paint
**** 11.3.6 Coordinate Transformations
**** 11.3.7 Clipping
**** 11.3.8 Transparency and Composition

*** 11.4 Raster Images
**** 11.4.1 Readers and Writers for Images
***** 11.4.1.1 Obtaining Readers and Writers for Image File Types
***** 11.4.1.2 Reading and Writing Files with Multiple Images

**** 11.4.2 Image Manipulation
***** 11.4.2.1 Constructing Raster Images
***** 11.4.2.2 Filtering Images

*** 11.5 Printing
**** 11.5.1 Graphics Printing
**** 11.5.2 Multiple-Page Printing
**** 11.5.3 Print Services
**** 11.5.4 Stream Print Services
**** 11.5.5 Printing Attributes

** TODO Chapter 12: Native Methods
*** 12.1 Calling a C Function from a Java Program
*** 12.2 Numeric Parameters and Return Values
*** 12.3 String Parameters
*** 12.4 Accessing Fields
**** 12.4.1 Accessing Instance Fields
**** 12.4.2 Accessing Static Fields

*** 12.5 Encoding Signatures
*** 12.6 Calling Java Methods
**** 12.6.1 Instance Methods
**** 12.6.2 Static Methods
**** 12.6.3 Constructors
**** 12.6.4 Alternative Method Invocations

*** 12.7 Accessing Array Elements
*** 12.8 Handling Errors
*** 12.9 Using the Invocation API
*** 12.10 A Complete Example: Accessing the Windows Registry
**** 12.10.1 Overview of the Windows Registry
**** 12.10.2 A Java Platform Interface for Accessing the Registry
**** 12.10.3 Implementation of Registry Access Functions as Native Methods

** Index
** Credits
** Code Snippets

* _xx
* Unrelated
   #+begin_src java
     int binarySearch(int[] a, int target) {
         int left = 0;
         int right = a.length;

         while (left < right) {
             int mid = (left + right) >>> 1;

             if (a[mid] == target) {
                 return mid;
             } else if (a[mid] < target) {
                 left = mid + 1;
             } else {
                 right = mid;
             }
         }

         return -1;
     }
   #+end_src

   #+begin_src java
     int binarySearchClosest(int[] a, int target) {
         int left = 0;
         int right = a.length - 1;

         while (left < right - 1) {
             int mid = (left + right) >>> 1;

             if (a[mid] == target) {
                 return mid;
             } else if (a[mid] < target) {
                 left = mid;
             } else {
                 right = mid;
             }
         }

         return Math.abs(a[left] - target) <= Math.abs(a[right] - target) ? left : right;
     }
   #+end_src
