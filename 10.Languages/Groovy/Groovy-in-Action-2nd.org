#+TITLE: Groovy in Action, 2nd
#+VERSION: 2015, Covers Groovy 2.4
#+AUTHOR: Dierk Konig, Paul King
#+STARTUP: overview
#+STARTUP: entitiespretty

* foreword to the first edition - xix
* preface - xx
* acknowledgments - xxiii
* about this book - xxv
* about the authors - xxx
* PART 1 THE GROOVY LANGUAGE - 1
* TODO 1 Your way to Groovy - 3
** 1.1 The Groovy story - 4
*** 1.1.1 What is Groovy? - 5
*** 1.1.2 Playing nicely with Java: seamless integration - 6
*** 1.1.3 Power in your code: a feature-rich language - 9
*** 1.1.4 Community driven but corporate backed - 13

** 1.2 What Groovy can do for you - 14
*** 1.2.1 Groovy for the busy Java professional - 14
*** 1.2.2 Groovy for the polyglot programmer - 15
*** 1.2.3 Groovy for pragmatic programmers, extremos, and agilists - 16

** 1.3 Running Groovy - 17
*** 1.3.1 Using groovysh for a welcome message - 18
*** 1.3.2 Using groovyConsole - 18
*** 1.3.3 Using the groovy command - 20

** 1.4 Compiling and running Groovy - 22
*** 1.4.1 Compiling Groovy with groovyc - 22
*** 1.4.2 Running a compiled
*** 1.4.3 Groovy script with Java - 23

** 1.5 Groovy IDE and editor support - 23
*** 1.5.1 IntelliJ IDEA plug-in - 24
*** 1.5.2 NetBeans IDE plug-in - 25
*** 1.5.3 Eclipse plug-in - 26
*** 1.5.4 Groovy support in other editors - 26

** 1.6 Summary - 26

* TODO 2 Overture: Groovy basics 28
** DONE 2.1 General code appearance - 29
   CLOSED: [2018-01-06 Sat 23:11]
*** DONE 2.1.1 Commenting Groovy code - 29
    CLOSED: [2018-01-06 Sat 22:44]
    Same as Java

*** DONE 2.1.2 Comparing Groovy and Java syntax - 29
    CLOSED: [2018-01-06 Sat 23:11]
    - Most Groovy code -- but not all -- appears exactly as it would in Java.

    - Neither language (Java or Groovy) is a superset of the other (Groovy or
      Java).
      + For instance,
        Groovy currently doesn't support /multiple initialization and iteration
        statements/ in the classic ~for (init1, init2; test; inc1, inc2) { ...}~
        loop.

      + Slightly different semantics. For example, ~==~

    - =TODO= List

    - =TODO= List

*** DONE 2.1.3 Beauty through brevity - 30
    CLOSED: [2018-01-06 Sat 23:11]
    - Example,
      Compare
      #+BEGIN_SRC java
        java.net.URLEncoder.encode("a b", "UTF-8");
      #+END_SRC

      and

      #+BEGIN_SRC groovy
        URLEncoder.encode 'a b', 'UTF-8'
      #+END_SRC

    - Groovy automatically imports the packages:
      + ~java.io.*~
      + ~java.lang.*~ (this is the ONLY one Java imports by default)
      + ~java.math.BigDecimal~
      + ~java.math.BigInteger~
      + ~java.net.*~
      + ~java.util.*~
      + ~groovy.lang.*~
      + ~groovy.util.*~

    - =TODO= List =TODO=
      + _Chapter 7_, optional ~return~ statements.

      + The dot (~.~) is optional when chaining method is called:
        ~buy(best).of(stocks)~ can be written as ~buy best of stocks~.
        _Chapter 7_

      + /Type declarations/ can be optional
        OR
        Use ~def~ to signal that you don't care about the type.

      + Optional /type casts/

      + NO /checked exception/.

** DONE 2.2 Probing the language with assertions - 31
   CLOSED: [2018-01-06 Sat 23:33]
   - Groovy provides assertions with the ~assert~ /keyword/.

   - Example,
     #+BEGIN_SRC scala
       // Groovy
       assert(true)
       assert 1 == 1
       def x = 1
       assert x == 1
       def y = 1; assert y == 1
     #+END_SRC

   - In Groovy the ~==~ operator denotes /equality/, *not* /identity/.

   - The ~def~ keyword means "dynamically typed."

   - The error message of ~def a = 5; def b = 9; assert b == a + a~ is
     #+BEGIN_SRC text
       ERROR org.codehaus.groovy.runtime.powerassert.PowerAssertionError:
       assert b == a + a
              | |  | | |
              9 |  5 | 5
                |    10
                false
     #+END_SRC
     =From Jian= So clear!!!

** DONE 2.3 Groovy at a glance - 34
   CLOSED: [2018-01-07 Sun 19:46]
*** DONE 2.3.1 Declaring classes - 35
    CLOSED: [2018-01-06 Sat 23:55]
    #+BEGIN_SRC scala
      // Groovy
      class Book {
        private String title

        Book (String theTitle) {
          title = theTitle
        }

        String getTitle() {
          return title
        }
      }
    #+END_SRC

    - Methods are ~public~ by DEFAULT

    - Details in Chap 7 =TODO=

*** DONE 2.3.2 Using scripts - 35
    CLOSED: [2018-01-06 Sat 23:55]
    - The typically extension of Groovy scripts are =.groovy=, that can be
      executed from the command shell like this: ~$ groovy myfile.groovy~.

      You can also use the shabang line.

    - Scripts contain Groovy statements *without* an enclosing ~class~
      declaration.

      Scripts can even contain /method/ definitions *outside* of /class
      definitions/ to better structure the code.

      =TODO= You’ll learn more about scripts in chapter 7.

    - Example
      #+BEGIN_SRC scala
        // Groovy
        // Assume `Book` is in the `classpath`
        Book gina = new Book('Groovy in Action')
        assert gina.getTitle() == 'Groovy in Action'
        assert getTitleBackwards(gina) == 'noitcA ni yvoorG'

        String getTitleBackwards(book) {
          String title = book.getTitle
          return title.reverse()
        }
      #+END_SRC
      + In Groovy script, in text, a use can be written before the required
        method definition. This is because the script is processed before run by
        JVM, NOT excute directly line by line from the top to the bottom.

      + The given script use ~Book~, which requires the =Book.groovy= file, which
        contains the ~Book~ class, must reside on the classpaht.

*** DONE 2.3.3 GroovyBeans - 36
    CLOSED: [2018-01-07 Sun 17:28]
    #+BEGIN_SRC scala
      // Groovy
      class BookBean {
        String title
      }

      def groovyBook = new BookBean()

      groovyBook.setTitle('Groovy in Action')
      assert groovyBook.getTitle() == 'Groovy in Action'

      groovyBook.title = 'Groovy conquers the world'
      assert groovyBook.title == 'Groovy conquers the world'
    #+END_SRC

    - If ~title~ is private, there will be NO ~setTitle~ method.

    - =TODO= More details in Chapter 7

*** DONE 2.3.4 Annotations 37
    CLOSED: [2018-01-07 Sun 18:14]
    Use ~@Immutable~ as example

    - A /Groovy bean/ can be marked as /immutable/, which means that
      the class becomes /final/, *ALL* its fields become /final/, and you CANNOT
      change its state after construction.

    - Exmaple:
      #+BEGIN_SRC scala
        import groovy.transform.Immutable

        @Immutable class FixedBook {  // AST annotation
          String title
        }

        def gina = new FixedBook('Groovy in Action')           // Positional constructors
        def regina = new FixedBook(title: 'Groovy in Action')  // Named-arg constructors

        assert gina.title == 'Groovy in Action'
        assert gina == regina

        try {
          gina.title = "Oops!"
          assert false, "should not reach here"
        } catch (ReadOnlyPropertyException expected) {
          println "Expected Error: '$expected.message'"
        }
      #+END_SRC

    - The ~@Immutable~ does more than you can see:
      + it adds a correct ~hashCode()~ implementation
      + it enforces /defensive copying/ =???= for access to all /properties/ that
        aren't immutable by themselves.

    - defensive copying :: http://www.javapractices.com/topic/TopicAction.do?Id=15

    - =TODO= =???=
      Most Groovy annotations, like ~@Immutable~, instruct the compiler to execute
      an AST transformation.

*** DONE 2.3.5 Using grapes 38
    CLOSED: [2018-01-07 Sun 18:19]
    - The ~@Grab~ annotation is used to explicitly define your external library
      dependencies within a script.

    - grapes :: external Groovy library dependencies.

    - Listing 2.6  Grabbing external libraries
      #+BEGIN_SRC scala
        @Grab('commons-lang:commons-lang:2.4')
        import org.apache.commons.lang.ClassUtils

        class Outer {
          class Innter {}
        }

        assert !ClassUtils.isInnerClass(Outer)
        assert ClassUtils.isInnerClass(Outer.Innter)
      #+END_SRC

*** DONE 2.3.6 Handling text 39
    CLOSED: [2018-01-07 Sun 18:48]
**** GSTRINGS - 73
     - Both single quotes and double quotes can be used for strings.

     - Double quotes strings are (?) of type ~GString~, which can have
       interpolation.

**** REGULAR EXPRESSIONS - 73
    - Groovy supports /regular expressions/ *at the language level*.

    - Declare a pattern with ~//~
      Match a pattern with ~=~~

    - Example:
      ~assert '12345' =~ /\d+/~
      ~assert 'xxxxx' == '12345'.replaceAll(/\d/, 'x')~

*** DONE 2.3.7 Numbers are objects 40
    CLOSED: [2018-01-07 Sun 18:49]
    Numbers are /objects/

*** DONE 2.3.8 Using lists, maps, and ranges 40
    CLOSED: [2018-01-07 Sun 19:06]
**** LISTS - 75
     #+BEGIN_SRC scala
       def roman = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII']
       assert roman[4] == 'IV'

       roman[8] = 'VIII'
       assert roman.size() == 9
     #+END_SRC

     /List/ is like Java /array/, but more expressive.

     =From Jian= From the usage, which doesn't discourage indexing, I think it
     is *NOT* /liked list/.

**** SIMPLE MAPS - 75
     #+BEGIN_SRC scala
       def http = [
         100 : 'CONTINUE',
         200 : 'OK',
         400 : 'BAD REQUEST'
       ]

       assert http[200] == 'OK'
       http[500] = 'INTERNAL SERVER ERROR'
       assert http.size() == 4
     #+END_SRC

**** RANGES - 76
     #+BEGIN_SRC scala
       def x = 1..10
       assert x.contains(5)
       assert !x.contains(15)
       assert x.size() == 10
       assert x.from == 1
       assert x.to == 10
       assert x.reverse() == 10..1
     #+END_SRC

*** DONE 2.3.9 Code as objects: closures 43
    CLOSED: [2018-01-07 Sun 19:44]
    - ~[1, 2, 3].each { entry -> println entry }~

    - Listing 2.7  Counting all the clinks at a party using a closure
      #+BEGIN_SRC scala
        def totalClinks = 0
        def partyPeople = 100

        1.upto(partyPeople) { guestNumber ->
          clinksWithGuest = guestNumber - 1
          totalClinks += clinksWithGuest
        }

        assert totalClinks == (partyPeople * (partyPeople - 1)) / 2
      #+END_SRC

*** DONE 2.3.10 Groovy control structures 45
    CLOSED: [2018-01-07 Sun 18:57]
    - In conditionals, ~null~ is treated like ~false~, and so are
      _empty_ strings, collections, and maps.

    - Listing 2.8  Control structures
      #+BEGIN_SRC scala
        // if
        if (false) assert false

        // if ... else ...
        if (null)
        {
          assert false
        }
        else
        {
          assert true
        }

        def i = 0
        // classic while
        while (i < 10) {
          i++
        }
        assert i == 10


        def clinks = 0
        // for in range
        for (remainingGuests in 0..9) {
          clinks += remainingGuests
        }

        assert clinks == (10*9)/2
        // for in list
        def list = [0, 1, 2, 3]
        for (j in list) {
          assert j == list[j]
        }

        // each
        list.each() { item ->
          assert item == list[item]
        }

        // Classifer switch
        switch(3) {
          case 1 : assert false; break
          case 3 : assert true; break
          default: assert false
        }
      #+END_SRC

** TODO 2.4 Groovy's place in the Java environment - 46
*** TODO 2.4.1 My class is your class - 47
    - =TODO= NOTE

*** TODO 2.4.2 GDK: the Groovy library - 48
    - x

*** TODO 2.4.3 Groovy compiler lifecycle - 49
**** GROOVY CLASS GENERATION AT WORK - 50
**** GROOVY IS DYNAMIC - 51
**** GROOVY CAN BE STATIC - 86

** TODO 2.5 Summary - 53

* TODO 3 Simple Groovy datatypes - 54
  - This chapter covers
    + Groovy's approach to typing
    + Operators as method implementations
    + Strings, regular expressions, and numbers

** TODO 3.1 Objects, objects everywhere - 55
*** TODO 3.1.1 Java's type system: primitives and references - 55
*** DONE 3.1.2 Groovy's answer: everything's an object - 56
    CLOSED: [2018-01-07 Sun 21:20]
    - Table 3.1 Java's primitive datatypes and their wrappers

    - *Difference*: Groovy has literals for ~java.math.BigDecimal~ and
      ~java.math.BigInteger~. Both use ~G~ suffix.
        Whether to use a ~BigInteger~ or a ~BigDecimal~ to hold a literal with a
      ~G~ suffix depending on the presence or absence of a decimal point.

    - ~BigDecimal~ is the _DEFAULT type_ of noninteger literals.

*** TODO 3.1.3 Interoperating with Java: automatic boxing and unboxing - 57
*** TODO 3.1.4 No intermediate unboxing - 58

** DONE 3.2 The concept of optional typing - 58
   CLOSED: [2018-01-07 Sun 22:00]
   Groovy implicitly assumes these variables to be of static type
   ~java.lang.Object~.

*** DONE 3.2.1 Assigning types - 59
    CLOSED: [2018-01-07 Sun 21:30]
    - The ~def~ keyword is used to indicate that _no particular type is
      specified_, which means ~java.lang.Object~.

    - It does *NOT* matter whether you declare a variable to be of type ~int~ or
      ~Integer~. Groovy uses the reference type (~Integer~) either way.

    - Still /type safe/. For example, you CANNOT assign a ~java.util.Date~ to a
      reference of type ~java.lang.Number~. 

*** DONE 3.2.2 Dynamic Groovy is type safe - 59
    CLOSED: [2018-01-07 Sun 21:32]
    - =TODO=
      In chapter 10, we’ll explore how to make Groovy provide more type checking
      at compile time to match and even exceed the kind of checking you might
      expect from Java.

    - optional typing :: ...

    - Groovy enforces the Java type system! But it only does so at runtime, while
      Java does so with a mixture of compile-time and runtime checks.

      + The fact that Java does part of the work at runtime can easily be
        inferred from the fact that Java programs can still raise
        ~ClassCastExceptions~ and other *runtime typing errors*.

      + All this explains why the Groovy compiler6 takes no issue with
        #+BEGIN_SRC scala
          // Groovy
          Integer myInt = new Object()
          println myInt
        #+END_SRC
        but when running the code, the cast from ~Object~ to ~Integer~ is enforced
        and you'll see
        #+BEGIN_SRC text
          org.codehaus.groovy.runtime.typehandling.GroovyCastException:
             Cannot cast object 'java.lang.Object@5b0bc6'
             with class 'java.lang.Object' to class 'java.lang.Integer'
        #+END_SRC

        This is like the Java code
        ~Integer myInt = (Integer) returnsObject();~, which is OK when compile:
        at compile time, ~returnsObject()~ is of type ~Object~. Java compiler
        will expect its /runtime type/ can be right (namely ~Integer~ or can be
        casted to ~Integer~).

      + footnote 5:
        Groovy will still do some compile-time checks even when _compiling
        dynamically_. For instance, if you declare that a class implements an
        interface, Groovy requires that at compile time it contains the methods
        from the interface.

    - *Groovy types aren't dynamic, they never change*
      Do NOT use "dynamic typing" in Groovy.

    - =TODO=
      Type declarations and type casts also play an important role in the Groovy
      method dispatch that we’ll examine in more detail in _chapters 7 and 8_.
      Casts come with some additional logic to make development easier.

*** DONE 3.2.3 Let the casting work for you - 62
    CLOSED: [2018-01-07 Sun 21:56]
    - To complete the picture, Groovy actually applies convenience logic when
      casting.

      The exhaustive list can be looked up in
      ~DefaultTypeTransformation.castToType~.

    - _Two_ notable features are baked into the Groovy type casting logic that
      may be surprising at first, but make for really elegant code:
      + casting /lists/ to *arbitrary* classes.

      + casting /maps/ to *arbitrary* classes.

      Examples:
      The following listing introduces these features by creating ~Point~,
      ~Rectangle~, and ~Dimension~ objects.
      #+BEGIN_SRC scala
        // Groovy
        import java.awt.*

        Point topLeft = new Point(0, 0)     // classic
        Point botRight = [100, 100]         // List cast
        Point center = [x:50, y:50]         // Map cast

        assert botRight instanceof Point
        assert center instanceof Point

        def rect = new Rectangle()
        rect.location = [0, 0]              // Point
        rect.size = [width:100, height:100] // Dimension
      #+END_SRC

      =From Jian= Do this kind of tricky things because of the lack of pattern
      matching.

*** DONE 3.2.4 The case for optional typing - 63
    CLOSED: [2018-01-07 Sun 22:00]
    - *Duck typing*

    - *RULE OF THUMB* of Experienced Groovy programmers:
      as soon as you think about the type of a reference, declare it; if you’re
      thinking of it as “just an object,” leave the type out.

      =From Jian= 
      This is *NOT* good!

** TODO 3.3 Overriding operators - 64
*** 3.3.1 Overview of overridable operators - 64
*** 3.3.2 Overridden operators in action - 66
*** 3.3.3 Making coercion work for you - 68

** TODO 3.4 Working with strings - 69
*** 3.4.1 Varieties of string literals - 69
*** 3.4.2 Working with GStrings - 72
*** 3.4.3 From Java to Groovy - 74

** TODO 3.5 Working with regular expressions - 76
*** 3.5.1 Specifying patterns in string literals - 77
*** 3.5.2 Applying patterns - 79
*** 3.5.3 Patterns in action - 81
*** 3.5.4 Patterns and performance - 83
*** 3.5.3 Patterns for classification - 84

** TODO 3.6 Working with numbers - 85
*** 3.6.1 Coercion with numeric operators - 85
*** 3.6.2 GDK methods for numbers - 88

** TODO 3.7 Summary - 89

* TODO 4 Collective Groovy datatypes - 91
** 4.1 Working with ranges - 92
*** 4.1.1 Specifying ranges - 93
*** 4.1.2 Ranges are objects - 94
*** 4.1.3 Ranges in action - 95

** 4.2 Working with lists - 97
*** 4.2.1 Specifying lists - 97
*** 4.2.2 Using list operators - 98
*** 4.2.3 Using list methods - 101
*** 4.2.4 Lists in action - 105

** 4.3 Working with maps - 107
*** 4.3.1 Specifying maps - 108
*** 4.3.2 Using map operators - 109
*** 4.3.3 Maps in action - 113

** 4.4 Notes on Groovy collections - 114
*** 4.4.1 Understanding concurrent modification - 114
*** 4.4.2 Distinguishing between copy and modify semantics - 115

** 4.5 Summary 116

* TODO 5 Working with closures - 117
** 5.1 A gentle introduction to closures - 118
** 5.2 The case for closures - 119
*** 5.2.1 Using iterators - 119
*** 5.2.2 Handling resources with a protocol - 121

** 5.3 Declaring closures - 123
*** 5.3.1 Simple declaration - 123
*** 5.3.2 Using assignments for declaration - 124
*** 5.3.3 declaration - 124
*** 5.3.4 Referring to methods as closures - 125
*** 5.3.5 Comparing the available options - 126

** 5.4 Using closures - 127
*** 5.4.1 Calling a closure - 127
*** 5.4.2 More closure capabilities - 130

** 5.5 Understanding closure scope - 134
*** 5.5.1 Simple variable scope - 135
*** 5.5.2 Inspecting closure scope - 136
*** 5.5.3 Scoping at work: the classic accumulator test - 139

** 5.6 Returning from closures - 140
** 5.7 Support for design patterns - 141
*** 5.7.1 Relationship to the Visitor pattern - 142
*** 5.7.2 Relationship to the Builder pattern - 143
*** 5.7.3 Relationship to other patterns - 143

** 5.8 Summary - 144

* TODO 6 Groovy control structures - 145 _READing_
  - This chapter covers
    + Groovy truth
    + Conditionals and branching
    + Looping
    + Exception handling

** DONE 6.1 Groovy truth - 146
   CLOSED: [2018-01-07 Sun 22:23]
*** DONE 6.1.1 Evaluating Boolean tests - 146
    CLOSED: [2018-01-07 Sun 22:11]
    - The expression of a Boolean test can be of any (nonvoid) type.

    - Table 6.1 Sequence of rules used to evaluate a Boolean test
      =IMPORTANT=
      | Runtime type      | Evaluation criterion required for truth |
      |-------------------+-----------------------------------------|
      | Boolean           | Corresponding Boolean value is true     |
      | Matcher           | Matcher has a match                     |
      | Collection        | Collection is nonempty                  |
      | Map               | Map is nonempty                         |
      | String, GString   | String is nonempty                      |
      | Number, Character | Value is nonzero                        |
      | None of the above | Object reference is non-null            |

      + footnote 2:
        It would be rare to encounter a situation where more than one rule
        matched, but you never know when someone will subclass ~java.lang.Number~
        and implement ~java.util.Map~ at the same time.

*** DONE 6.1.2 Assignments within Boolean tests 147
    CLOSED: [2018-01-07 Sun 22:23]
    Groovy, like Java, allows assignment to be a Boolean test.

    Remember the return value of an assignment is the assigned value.

    Since the feature of the Boolean test of Groovy, this case is *MORE*
    complicated in Groovy than in Java.

    - =From Jian=
      Best solution (if NOT change Groovy itself):
      Should never let an assignment appear in the Boolean test site.

    - Groovy does NOT allow assignment to appear in the
      _top-level ~if~ Boolean test site_.
      #+BEGIN_SRC scala
        // Groovy
        if (x = 2) { println x }    // NOT allowed
        if ((x = 2)) { println x }  // OK
      #+END_SRC

      This helps in the most comman cases, but it does NOT help in other cases.

** DONE 6.2 Conditional execution structures - 149
   CLOSED: [2018-01-07 Sun 23:05]
*** DONE 6.2.1 The humble ~if~ statement - 149
    CLOSED: [2018-01-07 Sun 22:27]
*** DONE 6.2.2 The conditional ~?:~ operator and Elvis - 150
    CLOSED: [2018-01-07 Sun 22:30]
    - Groovy allows the shortcut:
      ~def value = argument ?: standard~

*** DONE 6.2.3 The ~switch~ statement and the ~in~ operator - 151
    CLOSED: [2018-01-07 Sun 22:52]
**** THE SWITCH STRUCTURE - 185
**** SWITCH WITH CLASSIFIERS - 186
     - /Classifier/ is eligible as a ~switch~ case if it implements the ~isCase~
       method.
       #+BEGIN_SRC java
         // Groovy
         switch (candidate) {
           case classifier1 : handle1(); break
           case classifier2 : handle2(); break
           default          : handleDefault()
         }
       #+END_SRC
       is roughly equivalent (besides the /fall through/ and exit handling) to
       #+BEGIN_SRC scala
         if      (classifier1.isCase(candidate)) handle1()
         else if (classifier2.isCase(candidate)) handle2()
         else    handleDefault()
       #+END_SRC

     - Listing 6.6  Advanced ~switch~ and mixed classifiers
       #+BEGIN_SRC java
         // Groovy
         switch (10) {
           case 0          : assert false ; break
           case 0..9       : assert false ; break
           case [8,9,11]   : assert false ; break
           case Float      : assert false ; break
           case {it%3 == 0}: assert false ; break
           case ~/../      : assert true  ; break
           default         : assert false ; break
         }
       #+END_SRC
       + The new feature is that we can _classify by type_.
         ~Float~ is of type ~java.lang.Class~, and the GDK *enhances* ~Class~ by
         adding an ~isCase~ method that tests the candidate with ~isInstance~.

       + The ~isCase~ method on /closures/ passes the ~candidate~ (the argument
         in the example above) into the /closure/ and returns the result of the
         /closure/ call coerced to a ~Boolean~.

       + *~/../* is a ~Pattern~ and the ~isCase~ method on patterns applies its
         test to the ~toString~ value of the argument.

     - Table 6.2 Standard implementations of ~isCase~ for ~switch~, ~grep~, and ~in~
       =IMPORTANT=
       | Class        | ~a.isCase(b)~ implemented as          |
       |--------------+---------------------------------------|
       | ~Object~     | ~a.equals(b)~                         |
       | ~Class~      | ~a.isInstance(b)~                     |
       | ~Collection~ | ~a.contains(b)~                       |
       | ~Range~      | ~a.contains(b)~                       |
       | ~Pattern~    | ~a.matcher(b.toString()).matches()~   |
       | ~String~     | ~(a==null && b==null) \vert{}\vert{} a.equals(b)~ |
       | ~Closure~    | ~a.call(b)~                           |

       + ~collection.grep(classifier)~

**** THE ~in~ OPERATOR - 187
     #+BEGIN_SRC scala
       def okValues = [1, 2, 3]
       def value = 2
       assert value in okValues
     #+END_SRC

     - *Advanced topic*
       It's possible to overload the ~isCase~ method to support different kinds
       of classification logic depending on the candidate type.

*** DONE 6.2.4 Sanity checking with assertions - 154 =RE-READ=
    CLOSED: [2018-01-07 Sun 23:05]
**** DONE PRODUCING INFORMATIVE FAILURE MESSAGES - 188
     CLOSED: [2018-01-07 Sun 22:58]
     - ~assert~ can have the second argument, which is usually an message string.

     - This leads to the following best practices with assertions:
       =IMPORTANT=
       + Before writing an assertion, let your code fail, and see whether any
         other thrown exception is good enough.

       + When writing an assertion, let it fail the first time, and see whether
         the failure message is sufficient. If not, add a message. Let it fail
         again to verify that the message is now good enough.

       + If you feel you need an assertion to clarify or protect your code, add
         it regardless of the previous rules.

       + If you feel you need a message to clarify the meaning or purpose of your
         assertion, add it regardless of the previous rules.

**** DONE ENSURE CODE WITH INLINE UNIT TESTS - 189
     CLOSED: [2018-01-07 Sun 23:05]
**** DONE RELATIONSHIPS TO OTHER ASSERTIONS - 190
     CLOSED: [2018-01-07 Sun 23:05]

** DONE 6.3 Looping - 157
   CLOSED: [2018-01-07 Sun 23:40]
*** DONE 6.3.1 Looping with ~while~ - 157
    CLOSED: [2018-01-07 Sun 23:24]
    - Like Java, ONLY Boolean test part is different.

    - *NOTE*:
      There are no ~do {} while(condition)~ or ~repeat {} until (condition)~
      loops in Groovy.

      + Of course with closures you could write your own *do-while* or
        *repeat-until* control structures with only some _minor restrictions_
        and differences compared to a language-supported equivalent.

        =TODO=
          We discuss some of these differences in the next section. In chapter 19,
        we look at a ~WhenUntilTransform~ which even removes some of the
        limitations.

*** DONE 6.3.2 Looping with ~for~ - 158
    CLOSED: [2018-01-07 Sun 23:40]
    - Groovy encourage this pattern ~for (variable in iterable) { body }~, though
      it support most of the the other patterns of Java ~for~ loop.

    - =TODO= =??=
      In fact, any object can be an iterable. =???=
      Groovy applies the same logic as for /object iteration/, described in
      chapter 12.

      Using the for loop with /object iteration/ as described in section 12.1.3 provides
      some very powerful combinations. You can use it to print a file line-by-line via
      #+BEGIN_SRC scala
        def file = new File('myFileName.txt')
        for (line in file) println line
      #+END_SRC

    - Or to print all one-digit matches of a regular expression:
      #+BEGIN_SRC scala
        def matcher = '12xy3'=~/\d/
        for (match in matcher) println match
      #+END_SRC

    - If the container object is ~null~, *NO* iteration will occur:
      ~for (x in null) println 'This will not be printed!'~

    - If Groovy _CANNOT make the container object iterable by any means_, the
      fallback solution is to do an iteration that contains only the container
      object itself:
      ~for (x in new Object()) println "Printed once for object $x"~

** TODO 6.4 Exiting blocks and methods - 160
*** TODO 6.4.1 Normal termination: ~return~ / ~break~ / ~continue~ - 160
    - =TODO= note

    - =TODO=
      As a final note on return handling, remember that closures, when used with
      iteration methods like each, have a different meaning of return than the
      control structures while and for, as explained in section 5.6.

*** TODO 6.4.2 Exceptions: ~throw~ / ~try ... catch ... finally~ - 161

** TODO 6.5 Summary - 162

* TODO 7 Object orientation, Groovy style - 164
** 7.1 Defining classes and scripts - 165
*** 7.1.1 Defining fields and local variables - 165
*** 7.1.2 Methods and parameters - 168
*** 7.1.3 Safe dereferencing with the ?. operator - 172
*** 7.1.4 Constructors - 173

** 7.2 Organizing classes and scripts - 175
*** 7.2.1 File to class relationship - 176
*** 7.2.2 Organizing classes in packages - 177
*** 7.2.3 Further classpath considerations - 180

** 7.3 Advanced object-oriented features - 181
*** 7.3.1 Using inheritance - 181
*** 7.3.2 Using interfaces - 182
*** 7.3.3 Multimethods - 183
*** 7.3.4 Using traits - 185

** 7.4 Working with GroovyBeans - 187
*** 7.4.1 Declaring beans - 187
*** 7.4.2 Working with beans - 189
*** 7.4.3 Using bean methods for any object - 192
*** 7.4.4 Fields, accessors, maps, and Expando - 193

** 7.5 Using advanced syntax features - 194
*** 7.5.1 Querying objects with GPaths - 194
*** 7.5.2 Injecting the spread operator - 197
*** 7.5.3 Concise syntax with command chains - 198

** 7.6 Summary - 199

* TODO 8 Dynamic programming with Groovy - 200
** 8.1 What is dynamic programming? - 202
** 8.2 Meta Object Protocol - 202
** 8.3 Customizing the MOP with hook methods - 204
*** 8.3.1 Customizing methodMissing - 204
*** 8.3.2 Customizing propertyMissing - 206
*** 8.3.3 Using closures for dynamic hooks - 207
*** 8.3.4 Customizing GroovyObject methods - 208

** 8.4 Modifying behavior through the metaclass - 210
*** 8.4.1 MetaClass knows it all - 210
*** 8.4.2 How to find the metaclass and invoke methods - 211
*** 8.4.3 Setting other metaclasses - 213
*** 8.4.4 Expanding the metaclass - 214
*** 8.4.5 Temporary MOP modifications using category classes - 219
*** 8.4.6 Writing extension modules - 222
*** 8.4.7 Using the @Category annotation - 223
*** 8.4.8 Merging classes with Mixins - 224

** 8.5 Real-world dynamic programming in action - 227
*** 8.5.1 Calculating with metrics - 227
*** 8.5.2 Replacing constructors with factory methods - 228
*** 8.5.3 Fooling IDEs for fun and profit - 228
*** 8.5.4 Undoing metaclass modifications - 230
*** 8.5.5 The Intercept/Cache/Invoke pattern - 231

** 8.6 Summary - 232

* TODO 9 Compile-time metaprogramming and AST transformations - 233
** 9.1 A brief history - 234
*** 9.1.1 Generating bytecode, not source code - 234
*** 9.1.2 Putting the power of code generation in the hands of developers - 235

** 9.2 Making Groovy cleaner and leaner - 235
*** 9.2.1 Code-generation transformations - 236
*** 9.2.2 Class design and design pattern annotations - 245
*** 9.2.3 Logging improvements - 252
*** 9.2.4 Declarative concurrency - 254
*** 9.2.5 Easier cloning and externalizing - 258
*** 9.2.6 Scripting support - 263
*** 9.2.7 More transformations - 267

** 9.3 Exploring AST - 268
*** 9.3.1 Tools of the trade - 270
*** 9.3.2 Other tools - 271

** 9.4 AST by example: creating ASTs - 272
*** 9.4.1 Creating by hand - 272
*** 9.4.2 AstBuilder.buildFromSpec - 273
*** 9.4.3 AstBuilder.buildFromString - 274
*** 9.4.4 AstBuilder.buildFromCode - 275

** 9.5 AST by example: local transformations - 276
** 9.6 AST by example: global transformations - 282
** 9.7 Testing AST transformations - 286
** 9.8 Limitations - 290
*** 9.8.1 It's early binding - 290
*** 9.8.2 It's fragile - 290
*** 9.8.3 It adds complexity - 290
*** 9.8.4 Its syntax is fixed - 291
*** 9.8.5 It's not typed - 291
*** 9.8.6 It's unhygienic - 291

** 9.9 Next steps - 292
** 9.10 Summary - 292

* TODO 10 Groovy as a static language - 294
** 10.1 Motivation for optional static typing - 295
*** 10.1.1 The role of types in Groovy - 296
*** 10.1.2 Type checking a dynamic language? - 296

** 10.2 Using @TypeChecked - 298
*** 10.2.1 Finding typos - 299
*** 10.2.2 Resolving method calls - 300
*** 10.2.3 Checking assignments 301 
*** 10.2.4 Type inference - 303
*** 10.2.5 Type-checked Grooviness - 306
*** 10.2.6 Type checking closures - 310
*** 10.2.7 Revisiting dynamic features in light of type checking - 316
*** 10.2.8 Mixing type-checked code with dynamic code - 319

** 10.3 Flow typing - 320
*** 10.3.1 Least upper bound - 323
*** 10.3.2 Smart instanceof inference - 325
*** 10.3.3 Closure-shared variables - 326

** 10.4 Static compilation - 327
*** 10.4.1 ~@CompileStatic~ - 328
*** 10.4.2 Method dispatch - 329

** 10.5 Static type checking extensions - 332
*** 10.5.1 ~@DelegatesTo~ revisited - 334
*** 10.5.2 Type checking extension scripts - 335
*** 10.5.3 extension scripts - 335
*** 10.5.4 Limits - 339

** 10.6 Summary - 340

* PART 2 AROUND THE GROOVY LIBRARY - 341
* TODO 11 Working with builders - 343
** 11.1 Learning by example: Using a builder - 345
** 11.2 Building object trees with NodeBuilder - 347
*** 11.2.1 NodeBuilder in action: a closer look at builder code - 348
*** 11.2.2 Understanding the builder concept - 350
*** 11.2.3 Smart building with logic - 350

** 11.3 Working with MarkupBuilder - 352
*** 11.3.1 Building XML - 352
*** 11.3.2 Building HTML - 354

** 11.4 Working with StreamingMarkupBuilder - 355
** 11.5 Task automation with AntBuilder - 356
*** 11.5.1 From Ant scripts to Groovy scripts - 357
*** 11.5.2 How AntBuilder works - 358
*** 11.5.3 Smart automation scripts with logic - 359

** 11.6 Easy GUIs with SwingBuilder - 360
*** 11.6.1 Reading a password with SwingBuilder - 361
*** 11.6.2 Creating Swing widgets - 363
*** 11.6.3 Arranging your widgets - 366
*** 11.6.4 Referring to widgets - 370
*** 11.6.5 Using Swing actions - 372
*** 11.6.6 Using models - 374
*** 11.6.7 Binding made easy - 377
*** 11.6.8 Putting it all together - 380

** 11.7 Modern UIs with GroovyFX SceneGraphBuilder - 386
*** 11.7.1 Application design with FXML - 388
*** 11.7.2 Properties and binding - 389
*** 11.7.3 Groovy desktop applications - 389

** 11.8 Creating your own builder - 390
*** 11.8.1 Subclassing BuilderSupport - 391
*** 11.8.2 Subclassing FactoryBuilderSupport - 395
*** 11.8.3 Rolling your own - 398

** 11.9 Summary - 399

* TODO 12 Working with the GDK - 401
** 12.1 Working with objects - 402
*** 12.1.1 Interactive objects - 402
*** 12.1.2 Convenient Object methods - 405
*** 12.1.3 Iterative Object methods - 408

** 12.2 Working with files and I/O - 411
*** 12.2.1 Traversing the filesystem - 412
*** 12.2.2 Reading from input sources - 417
*** 12.2.3 Writing to output destinations - 418
*** 12.2.4 Filters and conversions - 420
*** 12.2.5 Streaming serialized objects - 422
*** 12.2.6 Temporary data and file copying - 422

** 12.3 Working with threads and processes - 423
*** 12.3.1 Groovy multithreading - 424
*** 12.3.2 Integrating external processes - 426

** 12.4 Working with templates - 429
*** 12.4.1 Understanding the template format - 430
*** 12.4.2 Templates in action - 431
*** 12.4.3 Advanced template issues - 433

** 12.5 Working with Groovlets - 434
*** 12.5.1 Starting with “Hello world” - 435
*** 12.5.2 Groovlet binding - 437
*** 12.5.3 Templating Groovlets - 441

** 12.6 Summary - 443

* 13 Database programming with Groovy - 445
** 13.1 Groovy SQL: a better JDBC - 446
*** 13.1.1 Setting up for database access - 447
*** 13.1.2 Executing SQL - 452

** 13.2 Advanced Groovy SQL - 463
*** 13.2.1 Performing transactional updates - 463
*** 13.2.2 Working with batches - 464
*** 13.2.3 Working with pagination - 466
*** 13.2.4 Fetching metadata - 466
*** 13.2.5 Working with named and namedordinal parameters - 469
*** 13.2.6 Using stored procedures - 471

** 13.3 DataSets for SQL without SQL - 474
*** 13.3.1 Using DataSet operations - 475
*** 13.3.2 DataSets on database views - 479

** 13.4 Organizing database work - 481
*** 13.4.1 Architectural overview - 481
*** 13.4.2 Specifying the application behavior - 483
*** 13.4.3 Implementing the infrastructure - 484
*** 13.4.4 Using a transparent domain model - 488
*** 13.4.5 Implementing the application layer - 489

** 13.5 Groovy and NoSQL - 492
*** 13.5.1 MongoDB: A document-style database - 492
*** 13.5.2 Neo4J: A graph database - 495

** 13.6 Other approaches - 503
** 13.7 Summary - 504

* TODO 14 Working with XML and JSON - 506
** 14.1 Reading XML documents - 507
*** 14.1.1 Working with a DOM parser - 508
*** 14.1.2 Reading with a Groovy parser - 513
*** 14.1.3 Reading with a SAX parser - 518
*** 14.1.4 Reading with a StAX parser - 519

** 14.2 Processing XML - 521
*** 14.2.1 In-place processing 522 
*** 14.2.2 Streaming processing - 524
*** 14.2.3 Updating XML 529 
*** 14.2.4 Combining with XPath - 531

** 14.3 Parsing and building JSON - 538
*** 14.3.1 Parsing JSON - 538
*** 14.3.2 Building JSON - 540

** 14.4 Summary - 542

* TODO 15 Interacting with Web Services 543
** 15.1 An overview of Web Services 544
** 15.2 Reading RSS and ATOM 545
** 15.3 Using a REST-based API 547
** 15.4 Using XML-RPC 553
** 15.5 Applying SOAP 555
*** 15.5.1 Doing SOAP with plain Groovy 556
*** 15.5.2 Simplifying SOAP
*** 15.5.3 access using HTTPBuilder 558
*** 15.5.4 Simplifying SOAP access
*** 15.5.5 using groovy-wslite 559

** 15.6 Summary 560

* TODO 16 Integrating Groovy - 561
** 16.1 Prelude to integration - 562
*** 16.1 Integrating appropriately - 563
*** 16.2 Setting up dependencies - 564

** 16.2 Evaluating expressions and scripts with GroovyShell - 565
*** 16.2.1 Starting simply - 565
*** 16.2.2 Passing parameters within a binding - 567
*** 16.2.3 Generating dynamic classes at runtime - 569
*** 16.2.4 Parsing scripts - 569
*** 16.2.5 Running scripts or classes - 571
*** 16.2.6 Further parameterization of GroovyShell - 571

** 16.3 Using the Groovy script engine - 575
*** 16.3.1 Setting up the engine - 575
*** 16.3.2 Running scripts - 576
*** 16.3.3 Defining a different resource connector - 576

** 16.4 Working with the GroovyClassLoader - 577
*** 16.4.1 Parsing and loading Groovy classes - 577
*** 16.4.2 The chicken and egg dependency problem - 579
*** 16.4.3 Providing a custom resource loader - 580
*** 16.4.4 Playing it safe in a secured sandbox - 581

** 16.5 Spring integration - 584
*** 16.5.1 Wiring GroovyBeans - 585
*** 16.5.2 Refreshable beans - 587
*** 16.5.3 Inline scripts - 587

** 16.6 Riding Mustang and JSR-223 - 588
*** 16.6.1 Introducing JSR-223 - 588
*** 16.6.2 The script engine manager and its script engines - 589
*** 16.6.3 Compilable and invocable script engines - 590
*** 16.6.4 Polyglot programming - 592

** 16.7 Mastering CompilerConfiguration - 592
*** 16.7.1 The import customizer - 594
*** 16.7.2 The source-aware customizer - 595
*** 16.7.3 Writing your own customizer - 597
*** 16.7.4 The configscript compilation option - 598

** 16.8 Choosing an integration mechanism - 600
** 16.9 Summary - 601

* PART 3 APPLIED GROOVY - 603
* TODO 17 Unit testing with Groovy - 605
** 17.1 Getting started - 606
*** 17.1.1 Writing tests is easy - 607
*** 17.1.2 GroovyTestCase: an introduction - 608
*** 17.1.3 Working with GroovyTestCase - 610

** 17.2 Unit testing Groovy code - 611
** 17.3 Unit testing Java code - 614
** 17.4 Organizing your tests - 617
*** 17.4.1 Test suites - 617
*** 17.4.2 Parameterized or data-driven testing - 618
*** 17.4.3 Property-based testing - 619

** 17.5 Advanced testing techniques - 621
*** 17.5.1 Testing made groovy - 622
*** 17.5.2 Stubbing and mocking - 623
*** 17.5.3 Using GroovyLogTestCase - 628
*** 17.5.4 Unit testing performance - 629
*** 17.5.5 Code coverage with Groovy - 631

** 17.6 IDE integration - 634
*** 17.6.1 Using GroovyTestSuite - 635
*** 17.6.2 Using AllTestSuite - 637

** 17.7 Testing with the Spock framework - 638
*** 17.7.1 Testing with mocks 639 
*** 17.7.2 Data-driven Spock tests - 642

** 17.8 Build automation - 644
*** 17.8.1 Build integration with Gradle - 644
*** 17.8.2 Build integration with Maven - 647

** 17.9 Summary - 649

* TODO 18 Concurrent Groovy with GPars - 650
** 18.1 Concurrency for the rest of us - 651
*** 18.1.1 Concurrent != parallel - 651
*** 18.1.2 Introducing new concepts - 653

** 18.2 Concurrent collection processing - 654
*** 18.2.1 Transparently concurrent collections - 655
*** 18.2.2 Available fork/join methods - 657

** 18.3 Becoming more efficient with map/filter/reduce - 659
** 18.4 Dataflow for implicit task coordination - 662
*** 18.4.1 Testing for deadlocks - 662
*** 18.4.2 Dataflow on sequential datatypes - 663
*** 18.4.3 Final thoughts on dataflow - 665

** 18.5 Actors for explicit task coordination - 665
*** 18.5.1 Using the strengths of Groovy - 669

** 18.6 Agents for delegated task coordination - 671
** 18.7 Concurrency in action - 671
** 18.8 Summary - 675

* TODO 19 Domain-specific languages - 676
** 19.1 Groovy’s flexible nature - 677
*** 19.1.1 Back to omitting parentheses - 677

** 19.2 Variables, constants, and method injection - 681
*** 19.2.1 Injecting constants through the binding - 682
*** 19.2.2 Injecting methods into a script - 684
*** 19.2.3 Adding imports and static imports automatically - 685
*** 19.2.4 Injecting methods (revisited) - 687
*** 19.2.5 Adding closures to the binding - 688

** 19.3 Adding properties to numbers - 690
** 19.4 Leveraging named arguments - 693
** 19.5 Command chains - 696
** 19.6 Defining your own control structures - 699
** 19.7 Context switching with closures - 710
** 19.8 Another technique for builders - 715
** 19.9 Securing your DSLs - 718
*** 19.9.1 Introducing SecureASTCustomizer - 718
*** 19.9.2 The ArithmeticShell - 719
*** 19.9.3 Stopping the execution of your programs - 721
*** 19.9.4 Preventing cheating with metaprogramming - 723

** 19.10 Testing and error reporting - 725
** 19.11 Summary - 731

* TODO 20 The Groovy ecosystem - 732
** 20.1 Groovy Grapes for self-contained scripts - 733
** 20.2 Scriptom for Windows automation - 735
** 20.3 GroovyServ for quick startup - 737
** 20.4 Gradle for project automation - 738
** 20.5 CodeNarc for static code analysis - 741
** 20.6 GContracts for improved design - 743
** 20.7 Grails for web development - 745
** 20.8 Griffon for desktop applications - 749
** 20.9 Gaelyk for Groovy in the cloud - 752
** 20.10 Summary - 754

* appendix A Installation and documentation - 756
* appendix B Groovy language information - 759
* appendix C GDK API quick reference - 762
* appendix D Cheat sheets - 819
* appendix E Annotation parameters - 825
* appendix F Compiler phases - 842
* appendix G AST visitors - 844
* appendix H Type checking extensions - 850
* appendix I Android support - 861
* index - 863
