#+TITLE: Kotlin in Action
#+VERSION: 2017, 1st
#+AUTHOR: Dmitry Jemerov, Svetlana Isakova
#+FOREWORD: Andrey Breslav
#+STARTUP: overview
#+STARTUP: entitiespretty

* foreword - xv
* preface - xvii
* acknowledgments - xix
* about this book - xxi
* about the authors - xxiv
* about the cover illustration - xxv
* PART 1 I NTRODUCING KOTLIN - 1
* TODO 1 Kotlin: what and why - 3
** TODO 1.1 A taste of Kotlin - 3
** TODO 1.2 Kotlin's primary traits - 4
*** TODO Target platforms: server-side, Android, anywhere Java runs - 4
*** TODO Statically typed - 5
*** TODO Functional and object-oriented - 6
*** TODO Free and open source - 7

** TODO 1.3 Kotlin applications - 7
*** TODO Kotlin on the server side - 8
*** TODO Kotlin on Android - 9

** TODO 1.4 The philosophy of Kotlin - 10
*** TODO Pragmatic - 10
*** TODO Concise - 11
*** TODO Safe - 12
*** TODO Interoperable - 12

** DONE 1.5 Using the Kotlin tools - 10
   CLOSED: [2018-05-26 Sat 14:40]
*** DONE 1.5.1 Compiling Kotlin code - 13
    CLOSED: [2018-05-26 Sat 14:28]
    - Conventional extension:
      =.kt=

    - Compiler:
      =kotlinc=

    - Run:
      use =java= to run the jar file generated by =kotlinc= (with its package
      flag(s)).

    - Figure 1.1 Kotlin build process

    - Kotlin is compatiable with all those common Java build systems such as
      /Mavan/, /Gradle/, or /Ant/.

*** DONE 1.5.2 Plug-in for IntelliJ IDEA and Android Studio - 14
    CLOSED: [2018-05-26 Sat 14:29]
*** DONE 1.5.3 Interactive shell - 15
    CLOSED: [2018-05-26 Sat 14:36]
    ~kotlinc~

    =IMPORTANT= =From Jian= =TODO=
    It seems there is a *BUG* if you use ~kotlinc~ as a REPL (Jian's Ver
    1.2.40):
      you cannot use the ~:quit~ command as the first command after getting into
    the REPL. ~:quit~ only works since the second prompt shows up!

*** DONE 1.5.4 Eclipse plug-in - 15
    CLOSED: [2018-05-26 Sat 14:36]
*** DONE 1.5.5 Online playground 15
    CLOSED: [2018-05-26 Sat 14:36]
    http://try.kotl.in

*** DONE 1.5.6 Java-to-Kotlin converter - 15
    CLOSED: [2018-05-26 Sat 14:38]
    - It is extremely easy if you use IntelliJ IDEA:
      + paste Java code fragment into a Kotlin file can trigger the conversion
        action;

      + invokde the "Convert Java File to Kotlin File" action to convert an
        entire file.

** DONE 1.6 Summary - 15
   CLOSED: [2018-05-30 Wed 13:46]
   - Kotlin is /statically typed/ and supports /type inference/, allowing it to
     maintain, while keeping the source code _concise_,
     + _correctness_
     + _performance_ 
     
   - Kotlin supports both /object-oriented/ and /functional programming/ styles,
     + *enabling* _higher-level abstractions_ through /first-class functions/

     + *simplifying* _testing_ and _multithreaded development_ through the support
       of /immutable values/.

   - It works well for server-side applications, fully supporting all existing
     Java frameworks and providing new tools for common tasks such as
     /HTML generation/ =TODO= =???= and /persistence/.

   - It works for Android as well, thanks to a _COMPACT /runtime/,_ special compiler
     support for Android API's, and a rich library providing Kotlin-friendly
     functions for common Android development tasks. =TODO= =???=

   - It's free and open source, with full support for the major IDE s and /build
     systems/.

   - Kotlin is _pragmatic_, _safe_, _concise_, and _interoperable_, meaning it
     focuses on
     + using proven solutions for common tasks,
     + preventing common errors such as ~NullPointerException~'s,
     + supporting compact and easy-to-read code,
     + providing unrestricted integration with Java.

* DONE 2 Kotlin basics - 17
  CLOSED: [2018-05-26 Sat 14:23]
  - This chapter covers
    + Declaring functions, variables, classes, enums, and properties
    + Control structures in Kotlin
    + Smart casts
    + Throwing and handling exceptions 

** DONE 2.1 Basic elements: functions and variables - 18
   CLOSED: [2018-05-26 Sat 10:59]
*** DONE 2.1.1 Hello, world! - 18
    CLOSED: [2018-05-26 Sat 10:44]
    #+BEGIN_SRC java
      fun main(args: Array<String>) {
          println("Hello, world!")
      }
    #+END_SRC
    - The function can be declared at the top level of a file.

    - The is no special syntax for /arrays/ as in Java like ~[]int~.
      The ~Array~ itself is just a normal type, with the most general syntax.

    - ~println~ is a wrapper of Java's ~System.out.println~, and you no longer
      need the prefixed package name in Java.

    - Semicolons can be omitted.

*** DONE 2.1.2 Functions - 18
    CLOSED: [2018-05-26 Sat 10:47]
    - Example:
      #+BEGIN_SRC java
        fun max(a: Int, b: Int): Int {
            return if (a > b) a else b
        }
      #+END_SRC

    - *Statements and expressions*
      - In Kotlin, most /control structures/, _EXCEPT_ for the /loops/ (~for~,
        ~do~, and ~do/ while~) are /expressions/.

      - /assignments/:
        * Kotlin: statements

        * Java: expressions

**** EXPRESSION BODIES - 19
     - For single expression body, NO curly braces and the ~return~ are required.
       ~fun max(a: Int, b: Int): Int = if (a > b) a else b~

       This is called a /expression body/.
       The one with curly braces is called a /block body/.

     - =IMPORTANT=
       Omitting the /return type/ is allowed _ONLY_ for functions with an
       /expression body/ -- that's a conscious design choice, not a theory
       limitation!!!
       ~fun max(a: Int, b: Int) = if (a > b) a else b~

*** DONE 2.1.3 Variables Easier string formatting: string templates - 22
    CLOSED: [2018-05-26 Sat 10:59]
    - If a variable doesn't have an /initializer/, you need to specify its type
      _EXPLICITLY_:
      #+BEGIN_SRC java
        val answer: Int
        answer = 42
      #+END_SRC
**** Mutable and Immutable Variables - 21
     ~val~ and ~var~

*** DONE 2.1.4 Easier string formatting: string templates - 22
    CLOSED: [2018-05-26 Sat 11:03]
    - /string templates/
      For instance,
      + Simple expression: ~println("Hello, $name!")~
      + Complex expression: ~println("Hello, ${args[0]}!")~

** DONE 2.2 Classes and properties - 23
   CLOSED: [2018-05-26 Sat 12:38]
   #+BEGIN_SRC java
     /* Java */
     public class Person {
         private final String name;
         public Person(String name) {
             this.name = name;
         }
         public String getName() {
             return name;
         }
     }
   #+END_SRC
   has corresponding Kotlin code: ~class Person(val name: String)~, this is often
   called /value objects/ -- only data but no code inside body. The ~public~
   keyword disappears -- it is the default visibility in Kotlin.

*** DONE 2.2.1 Properties - 23
    CLOSED: [2018-05-26 Sat 12:26]
    - In Kotlin, /properties/ are a *first-class language feature*, which entirely
      replaces /fields/ and /accessor methods/.

      You declare a /property/ in a /class/ _the same way you declare a variable_:
      with
      + ~val~: A ~val~ /property/ is *read-only*

      + ~var~: a ~var~ /property/ is *mutable*

    - The relation between Java's getter/setter and Kotlin's.
      =From Jian= I don't know if there is such a rule in Scala!?
      + ~getName~ <-> ~name~, and ~setName~ <-> ~name~ (= ...)

      + ~isMarried~ <-> ~married~, and ~setMarried~ <-> ~married~ (=...)

    - TIP
      You can also use the Kotlin property syntax for classes defined in Java.
      Getters in a Java class can be accessed as val properties from Kotlin, and
      get- ter/setter pairs can be accessed as var properties. For example, if a
      Java class defines methods called getName and setName , you can access it
      as a property called name . If it defines isMarried and setMarried
      methods, the name of the corresponding Kotlin property will be isMarried .
      =TODO=

*** DONE 2.2.2 Custom accessors - 25
    CLOSED: [2018-05-26 Sat 12:26]
    #+BEGIN_SRC java
      class Rectangle(val height: Int, val width: Int) {
          val isSquare: Boolean
              get() {
                  return height == width
              }
          // OR, for short,
          // get() = height == width
      }
    #+END_SRC
    - Then you can use the ~isSquqre~ /property/, both in Kotlin and Java.

*** DONE 2.2.3 Kotlin source code layout: directories and packages - 26
    CLOSED: [2018-05-26 Sat 12:37]
    - The /package/ of Kotlin is similar to that of Java.

    - As in Java (UNLIKE Scala), /import statements/ are placed at the *beginning*
      of the file and use the ~import~ keyword.

    - Example:
      #+BEGIN_SRC scala
        package geometry.shapes

        import java.util.Random

        class Rectangle(val height: Int, val width: Int) {
          val isSquare: Boolean
              get() = height == width
        }


        fun createRandomRectangle(): Rectangle {
          val random = Random()
          return Rectangle(random.nextInt(), random.nextInt())
        }
      #+END_SRC

    - Use ~.*~ to import all in a particular /package/.
      For instance, ~import geometry.shapes.*~

    - In Kotlin, you can put _MULTIPLE_ /classes/ in the same file and choose ANY
      name (NO need to match the file name to a /class/ like in Java) for that
      file.

    - Kotlin doesn't impose layout restriction to packages.
      For instance, under the =geometry= folder, you have two files =example.kt=
      and =shapes.kt=, they can be the ~geometry.example~ /package/ and the
      ~geometry.shapes~ /package/, respectively, if you want.

      =Suggestion= Keep follow the Java convention, and you'll work well with Java
      without find ways to get rid of any meaningless troubles.

** DONE 2.3 Representing and handling choices: enums and ~when~ - 28
   CLOSED: [2018-05-26 Sat 13:51]
   ~when~ as a replace of Java ~switch~, but more powerful.

*** DONE 2.3.1 Declaring ~enum~ classes - 28
    CLOSED: [2018-05-26 Sat 12:46]
    #+BEGIN_SRC scala
      enum class Color {
        RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
      }
    #+END_SRC
    - In Kotlin, ~enum~ is a so-called /soft keyword/: it has a special meaning
      when it comes before ~class~, but you can use it as a regular name in other
      places.

    - Just as in Java,
      ~enum~'s are *NOT* lists of values: you can declare /properties/ and /methods/
      on ~enum class~'es. Here's how it works.
      #+BEGIN_SRC scala
        enum class Color(
            val r: Int, val g: Int, val b: Int
        ) {
          RED(255, 0, 0), ORANGE(255, 165, 0),
          YELLOW(255, 255, 0), GREEN(0, 255, 0), BLUE(0, 0, 255),
          INDIGO(75, 0, 130), VIOLET(238, 130, 238);  // The semicolon here is required.

          fun rgb() = (r * 256 + g) * 256 + b  // Define a method on the enum class
        }

        // >>>
        println(Color.BLUE.rgb())
        // 255
      #+END_SRC

      + =IMPORTANT=
        The example shows the ONLY place the semicolon is *MANDATORY*!!!
        It is use d separate the /enum constant list/ from the /method
        definition(s)/.

*** DONE 2.3.2 Using ~when~ to deal with enum classes - 29
    CLOSED: [2018-05-26 Sat 12:51]
    - Example:
      #+BEGIN_SRC scala
        fun getMnemonic(color: Color) =
          when (color) {
            Color.RED    -> "Richard"
            Color.ORANGE -> "Of"
            Color.YELLOW -> "York"
            Color.GREEN  -> "Gave"
            Color.BLUE   -> "Battle"
            Color.INDIGO -> "In"
            Color.VIOLET -> "Vain"
          }

        //  >>>
        println(getMnemonic(Color.BLUE))
        // Battle
      #+END_SRC
      + NO fallthrough, therefore no need for ~break~'s

    - Example:
      #+BEGIN_SRC scala
        fun getWarmth(color: Color) = when(color) {
          Color.RED, Color.ORANGE, Color.YELLOW  -> "warm"
          Color.GREEN                            -> "neutral"
          Color.BLUE, Color.INDIGO, Color.VIOLET -> "cold"
        }

        //  >>>
        println(getWarmth(Color.ORANGE))
        // warm
      #+END_SRC

      + Simplify the code
        #+BEGIN_SRC scala
          import ch02.colors,Color
          import ch02.colors,Color.*

          fun getWarmth(color: Color) = when(color) {
            RED, ORANGE, YELLOW  -> "warm"
            GREEN                -> "neutral"
            BLUE, INDIGO, VIOLET -> "cold"
          }
        #+END_SRC

*** DONE 2.3.3 Using ~when~ with arbitrary objects - 30
    CLOSED: [2018-05-26 Sat 12:59]
    ~when~ allows any object, rahter than, like Java, only constants.

    - Example:
      #+BEGIN_SRC scala
        fun mix(c1: Color, c2: Color) =
            when (setOf(c1, c2)) {
                setOf(RED, YELLOW)  -> ORANGE
                setOf(YELLOW, BLUE) -> GREEN
                setOf(BLUE, VIOLET) -> INDIGO
                else                -> throw Exception("Dirty color")
        }

        // >>>
        println(mix(BLUE, YELLOW))
        // GREEN
      #+END_SRC
      + ~setOf~ creates a ~Set~ with given elements.

*** DONE 2.3.4 Using ~when~ without an argument - 31
    CLOSED: [2018-05-26 Sat 13:10]
    We want to avoid creating ~Set~ for every branch just for match, which can be
    costly, though mostly we don't care about it.

    =From Jian= Does Scala have this problem???

    #+BEGIN_SRC scala
      fun mixOptimized(c1: Color, c2: Color) =
          when {
              (c1 == RED && c2 == YELLOW) ||
              (c1 == YELLOW && c2 == RED) ->
                  ORANGE

              (c1 == YELLOW && c2 == BLUE) ||
              (c1 == BLUE && c2 == YELLOW) ->
                  GREEN

              (c1 == BLUE && c2 == VIOLET) ||
              (c1 == VIOLET && c2 == BLUE) ->
                  INDIGO

              else -> throw Exception("Dirty color")
      }

      // >>>
      println(mixOptimized(BLUE, YELLOW))
      // GREEN
    #+END_SRC
    + NO argument ~when~ try to match a bool value ~true~.

*** DONE 2.3.5 Smart casts: combining type checks and casts - 31
    CLOSED: [2018-05-26 Sat 13:20]
    - /interface/ implemetation doesn't have a keyword, use ~:~.

      =From Jian= This syntax design is good!

    - Example:
      #+BEGIN_SRC scala
        interface Expr
        class Num(val value: Int) : Expr
        class Sum(val left: Expr, val right: Expr) : Expr
      #+END_SRC

      + The Kotlin way use ~is~ to *check* (as ~instanceof~ in Java) and /cast/
        the type (the /cast/ step is done by the compiler if you use ~is~, this
        is called the /smart cast/).
        #+BEGIN_SRC scala
          fun eval(e: Expr): Int {
            if (e is Num) {
              return e.value

              //// if there is no smart cast:
              // val n = e as Num
              // return n.value
            }

            if (e is Sum) {
              return eval(e.left) + eval(e.right)
            }

            throw IllegalArgumentException("Unknown expression")
          }
        #+END_SRC

*** DONE 2.3.6 Refactoring: replacing ~if~ with ~when~ - 33
    CLOSED: [2018-05-26 Sat 13:51]
    - Refactor with the ~if/else if/else~ expression
      #+BEGIN_SRC scala
        fun eval(e: Expr): Int =
          if (e is Num) {
            e.value
          } else if (e is Sum) {
            eval(e.left) + eval(e.right)
          } else {
            throw IllegalArgumentException("Unknown expression")
          }
  
        // >>>
        println(eval(Sum(Num(1), Num(2))))
        // 3
      #+END_SRC

    - As in Java, the curly braces are _optional_ if there's only ONE expression
      in an if branch.

    - Refactor with ~when~ -- less boilerplate code
      #+BEGIN_SRC scala
        fun eval(e: Expr): Int =
            when (e) {
                is Num -> e.value
                is Sum -> eval(e.left) + eval(e.right)
                else   -> throw IllegalArgumentException("Unknown expression")
            }
      #+END_SRC

*** DONE 2.3.7 Blocks as branches of ~if~ and ~when~ - 34
    CLOSED: [2018-05-26 Sat 13:51]
    The branches of ~if~ and ~when~ can be /blocks/.
    Unlike Scala (if consider Kotlin's ~when~ as Scala's ~match~), curly braces
    is mandatory for ~when~'s branches if there is more than one statements!

    - Example:
      #+BEGIN_SRC scala
        fun evalWithLogging(e: Expr): Int =
          when (e) {
            is Num -> {
              println("num: ${e.value}")
              e.value
            }

            is Sum -> {
              val left = evalWithLogging(e.left)
              val right = evalWithLogging(e.right)
              println("sum: $left + $right")
              left + right
            }

            else -> throw IllegalArgumentException("Unknown expression")
        }
      #+END_SRC

** DONE 2.4 Iterating over things: ~while~ and ~for~ loops - 35
   CLOSED: [2018-05-26 Sat 14:09]
   - The ~while~ loop is _identical_ to the one in Java.

   - The ~for~ loop exists in ONLY ONE form, which is equivalent to Java's
     /for-each loop/.

*** DONE The ~while~ loop - 35
    CLOSED: [2018-05-26 Sat 13:53]
    Kotlin has ~while~ and ~do/while~ loops.

*** DONE Iterating over numbers: ranges and progressions - 36
    CLOSED: [2018-05-26 Sat 14:01]
    - Use ~..~ to generate /ranges/.
      For instance, ~val oneToTen = 1..10~
      *CAUTION* this ~..~ is like Scala's ~to~, rahte than ~until~.

    - progression :: iterate over ALL the values in a /range/.

    - Fizz-Buzz game.
      #+BEGIN_SRC scala
        fun fizzBuzz(i: Int) = when {
            i % 15 == 0 -> "FizzBuzz "
            i % 3 == 0  -> "Fizz "
            i % 5 == 0  -> "Buzz "
            else        -> "$i "
        }

        // >>>
        for (i in 1..100) {
            print(fizzBuzz(i))
        }

        // 1 2 Fizz 4 Buzz Fizz 7 ..
      #+END_SRC

    - Countdown and with steps:
      #+BEGIN_SRC scala
        for (i in 100 downTo 1 step 2) {
          print(fizzBuzz(i))
        }
        // Buzz 98 Fizz 94 92 FizzBuz 88 ...
      #+END_SRC

    - Use ~until~ to create a /(end) exlusive range/.

*** DONE Iterating over maps - 37
    CLOSED: [2018-05-26 Sat 14:02]
    #+BEGIN_SRC scala
      val binaryReps = TreeMap<Char, String>()

      for (c in 'A'..'F') {
        val binary = Integer.toBinaryString(c.toInt())
        binaryReps[c] = binary
      }

      for ((letter, binary) in binaryReps) {
        println("$letter = $binary")
      }
    #+END_SRC

    - More /unpack/ syntax in Section 7.4.1

    #+BEGIN_SRC scala
      val list = arrayListOf("10", "11", "1001")

      for ((index, element) in list.withIndex()) {
        println("$index: $element")
      }
    #+END_SRC

*** DONE Using ~in~ to check collection and range membership - 38
    CLOSED: [2018-05-26 Sat 14:09]
    ~in~ or ~!in~
    - Example:
      #+BEGIN_SRC scala
        fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'
        fun isNotDigit(c: Char) = c !in '0'..'9'
      #+END_SRC

    - Example (with ~when~):
      #+BEGIN_SRC scala
        fun recognize(c: Char) = when (c) {
            in '0'..'9'              -> "It's a digit!"
            in 'a'..'z', in 'A'..'Z' -> "It's a letter!"
            else                     -> "I don't know..."
        }
      #+END_SRC

    - If you have any class that _supports_ /comparing instances/ (by implementing
      the ~java.lang.Comparable~ /interface/), you can create /ranges/ of objects
      of that type.

** DONE 2.5 Exceptions in Kotlin - 39
   CLOSED: [2018-05-26 Sat 14:12]
   - The basic form for exception-handling statements in Kotlin is _similar_ to
     Java's. For instance,
     #+BEGIN_SRC scala
       if (percentage !in 0..100) {
         throw IllegalArgumentException(
           "A percentage value must be between 0 and 100: $percentage")
       }
     #+END_SRC
     + NO ~new~ here

   - Unlike Java, Kotlin's ~throw~ is an /expression/.

     =From Jian= Expression for side-effect??? Similar in Scala??? From the
     usage, it seems it is!

*** DONE ~try~, ~catch~, and ~finally~ - 40
    CLOSED: [2018-05-26 Sat 14:16]
    #+BEGIN_SRC scala
      fun readNumber(reader: BufferedReader): Int? {
        try {
          val line = reader.readLine()
          return Integer.parseInt(line)
        }
        catch (e: NumberFormatException) {
          return null
        }
        finally {
          reader.close()
        }
      }
    #+END_SRC

*** DONE ~try~ as an expression - 41
    CLOSED: [2018-05-26 Sat 14:22]
    #+BEGIN_SRC scala
      fun readNumber(reader: BufferedReader) {
          val number = try {
              Integer.parseInt(reader.readLine())
          } catch (e: NumberFormatException) {
              null
          }

          println(number)
      }

      // >>>
      val reader = BufferedReader(StringReader("not a number"))

      // >>>
      readNumber(reader)
      // null
    #+END_SRC

** DONE 2.6 Summary - 42
   CLOSED: [2018-05-26 Sat 14:23]

* DONE 3 Defining and calling functions - 44
  CLOSED: [2018-05-27 Sun 19:58]
  - This chapter covers
    + /Functions/ for working with /collections/, /strings/, and /regular
      expressions/

    + Using /named arguments/, /default parameter values/, and the /infix call
      syntax/

    + *Adapting* Java libraries to Kotlin _through_ /extension functions/ and
      /properties/ =TODO= =???=

    + Structuring code with _top-level and local_ /functions/ and /properties/

** DONE 3.1 Creating collections in Kotlin - 45
   CLOSED: [2018-05-26 Sat 14:56]
   #+BEGIN_SRC scala
     val set = hashSetOf(1, 7, 53)
     val list = arrayListOf(1, 7, 53)
     val map = hashMapOf(1 to "one", 7 to "seven", 53 to "fifty-three")
   #+END_SRC

   - You can use the ~javaClass~ (be equivalent to Java's ~getClass()~ /method/)
     to get type of you collections:
     #+BEGIN_SRC scala
       println(set.javaClass)
       // class java.util.HashSet

       println(list.javaClass)
       // class java.util.ArrayList

       println(map.javaClass)
       // class java.util.HashMap
     #+END_SRC
     You see Kotlin does NOT have its own collection classes.
       This is a *design choice* _based on_ the idea that "interact with Java
     well is important for Kotlin".

     However, Kotlin _add more_ /methods/ to them (=From Jian= for now, *HOW* is
     NOT explained)! For instance, ~last()~ for ~List~, and ~max()~ for a
     collection of comparable values.

   - =TODO=
     And in section 6.3, you'll learn how the Java collection classes are
     represented in the Kotlin type system.

** DONE 3.2 Making functions easier to call - 46
   CLOSED: [2018-05-26 Sat 15:32]
    #+BEGIN_SRC scala
      fun <T> joinToString(
          collection: Collection<T>,
          separator: String,
          prefix: String,
          postfix: String
      ): String {

          val result = StringBuilder(prefix)

          for ((index, element) in collection.withIndex()) {
              if (index > 0) result.append(separator)
              result.append(element)
          }

          result.append(postfix)
          return result.toString()
      }
    #+END_SRC

*** DONE 3.2.1 Named arguments - 47
    CLOSED: [2018-05-26 Sat 15:13]
    - The invocation like ~joinToString(collection, " ", " ", ".")~ will confuse
      people who read this code.

    - Java does NOT have /named arguments/, while Kotlin has!
      ~joinToString(collection, separator = " ", prefix = " ", postfix = ".")~
      + Specify the /unnamed arguments/ first followed by the /named arguments/.

      This is much better than the Java way:
      #+BEGIN_SRC java
        joinToString(collection, /* separator */ " ", /* prefix */ " ", /* postfix */ ".");
      #+END_SRC

    - *WARNING*
      _UNFORTUNATELY_, you *CANNOT* use /named arguments/ when calling /methods
      written in Java/, including /methods/ from the JDK and the Android framework.

      _Storing parameter names in =.class= files_ is supported as an *OPTIONAL
      feature* ONLY starting with Java 8, and

      *Kotlin maintains compatibility with Java 6.*

        As a result, the compiler can't recognize the parameter
      names used in your call and match them against the method definition.

*** DONE 3.2.2 Default parameter values - 48 =IMPORTANT=
    CLOSED: [2018-05-26 Sat 15:13]
    =IMPORTANT=
    *Default values and Java* 
    Given that Java does *NOT* have the concept of /default parameter values/,
    you have to specify all the parameter values explicitly when you call a
    Kotlin function with default parameter values _from Java_.

    If you frequently need to call a function from Java and want to make it
    easier to use for Java callers, you can annotate it with ~@JvmOverloads~.
    This instructs the compiler to generate Java overloaded methods, omitting
    each of the parameters one by one, starting from the last one.

    For example, if you annotate ~joinToString~ with ~@JvmOverloads~, the
    following overloads are generated:
    #+BEGIN_SRC java
      /* Java */
      String joinToString(Collection<T> collection, String separator,
                          String prefix, String postfix);

      String joinToString(Collection<T> collection, String separator,
                          String prefix);

      String joinToString(Collection<T> collection, String separator);

      String joinToString(Collection<T> collection);
    #+END_SRC
    Each overload uses the default values for the parameters that have been omitted
    from the signature.

*** DONE 3.2.3 Getting rid of static utility classes: top-level functions and properties - 49
    CLOSED: [2018-05-26 Sat 15:25]
    #+BEGIN_SRC scala
      // join.kt
      package strings

      fun joinToString(...): String { ... }
    #+END_SRC

    - Q :: How to use this in Java?

    - A :: The Kotlin's code above is equivalent to Java's code
      #+BEGIN_SRC java
        package strings;

        public class JoinKt {
            public static String joinToString(...) { ... }
        }
      #+END_SRC

      You can use it in Java in this way:
      #+BEGIN_SRC java
        import strings.JoinKt;

        JoinKt.joinToString(list, ", ", "", "");
      #+END_SRC

    - *Changing the file class name*
      To *change the name* of the _generated class_ that contains Kotlin
      /top-level functions/, you add a ~@JvmName~ /annotation/ to the file.

      *Place it _at the beginning of the file_, _BEFORE_ the /package name/:*
      #+BEGIN_SRC scala
        @file:JvmName("StringFunctions")
        package strings

        fun joinToString(...): String { ... }
      #+END_SRC

      Now the function can be called as follows:
      #+BEGIN_SRC java
        import strings.StringFunctions;

        StringFunctions.joinToString(list, ", ", "", "");
      #+END_SRC

      A detailed discussion of the annotation syntax comes later, in chapter 10.

*** DONE Top-Level Properties - 51
    CLOSED: [2018-05-26 Sat 15:32]
    /properties/ can also be top-level in Kotlin, though this feature is NOT
    used as much as the /top-level functions/.
    #+BEGIN_SRC scala
      var opCount = 0

      fun performOperation() {
        opCount++
        // ...
      }

      fun reportOperationCount() {
        println("Operation performed $opCount times")
      }
    #+END_SRC

    - As normal /class-level properties/, the ~val~ /properties/ come with a
      /getter/, and the ~var~ /properties/ come with a /getter/ and /setter/.

    - If you want a constant like Java's ~public static final~ /field/, you should
      use the ~const~ modifier, *which
      is allowed for /properties of /primitive types/, as well as ~String~:*
      ~const val UNIX_LINE_SEPARATOR = "\n"~

** DONE 3.3 Adding methods to other people's classes: extension functions and properties - 51
   CLOSED: [2018-05-27 Sun 15:23]
   - extension function :: a function that can be called as a member of a /class/
        but is defined outside of it.

   - Example:
     #+BEGIN_SRC scala
       package Strings

       fun Strings.lastChar(): Char = this.get(this.length - 1)
       //// Or, for short:
       // fun Strings.lastChar(): Char = get(length - 1)

       // println("Kotlin".lastChar())
       //// n
     #+END_SRC

   - /receiver type/ and /receiver object/

   - The /extension function/ *cannot break* the /encapsulation/!!!!!!

     You *CANNOT* access the /private/ or /protected/ memmbers of the /class/ of
     a /extension funciton/.

   - On the /call site/, /extension functions/ are *indistinguishable* from
     /members/, and often _it doesn't matter_ whether the particular /method/ is
     a /member/ or an /extension/.

*** DONE 3.3.1 Imports and extension functions - 53
    CLOSED: [2018-05-26 Sat 17:15]
    Import the /extension functions/ as importing /classes/:
    - ~import strings.lastChar~

    - ~import strings.*~

    - ~import strings.lastChar as last~

*** DONE 3.3.2 Calling extension functions from Java - 53
    CLOSED: [2018-05-26 Sat 17:19]
    - Under the hood,
      an /extension function/ is a /static method/ that accepts the /receiver
      object/ as its *first argument*.

      Calling it doesn't involve
      + creating adapter objects
        or
      + any other runtime overhead.

    - Suppose you put your top-level functions in a file named =StringUtil.kt=:
      #+BEGIN_SRC java
        /* Java */
        char c = StringUtilKt.lastChar("Java");
      #+END_SRC

      Of course, you can ~import static StringUtilKt.*~ and use ~lastChar~ directly!

*** DONE 3.3.3 Utility functions as extensions No overriding for extension functions - 55
    CLOSED: [2018-05-26 Sat 17:26]
    - The final version of ~joinToString~, which is almost exactly what you'll
      find in the Kotlin standard library:
      #+BEGIN_SRC scala
        fun <T> Collection<T>.joinToString(
                separator: String = ", ",
                prefix: String = "",
                postfix: String = ""
        ): String {
            val result = StringBuilder(prefix)

            for ((index, element) in this.withIndex()) {
              if (index > 0) result.append(separator)
              result.append(element)
            }

            result.append(postfix)
            return result.toString()
        }

        // >>>
        val list = listOf(1, 2, 3)

        // >>>
        println(list.joinToString(separator = "; ", prefix = "(", postfix = ")"))
        // (1; 2; 3)
      #+END_SRC

    - Because /extension functions/ are effectively /syntactic sugar/ over /static
      method calls/, you can use a *more specific type* as a /receiver type/,
      _NOT ONLY_ a /class/.
        Let’s say you want to have a join function that can be invoked only on
      _collections of strings_:
      #+BEGIN_SRC scala
        fun Collection<String>.join(
            separator: String = ", ",
            prefix: String = "",
            postfix: String = ""
        ) = joinToString(separator, prefix, postfix)


        // >>>
        println(listOf("one", "two", "eight").join(" "))
        // one two eight
      #+END_SRC

    - We now what are underhood, then we know
      The _static nature_ of /extensions/ also means that /extension functions/
      *CANNOT be /overridden/ in /subclasses/.*
      =See Next Section=

*** DONE 3.3.4 No overriding for extension functions - 55
    CLOSED: [2018-05-26 Sat 17:37]
    - If a /extension function/ can be called *depends on*
      + the /static type/

      + *NOT* the /dynamic type (run time type)/

      of the /receiver object/

    - *NOTE*
      If a /member function/ and a /extension function/ have the same signature,
      *ALWAYS the /member function/ wins*.

      =IMPORTANT=
      You should keep this in mind when extending the API of classes:
      if the API is changed, and a new /member function/ is added, which has the
      same signature as a old /extension function/, then the invocation will
      change, which is, of course, a disaster!!!

      =From Jian= At least, hope there is a warning!!!

*** DONE 3.3.5 Extension properties - 56
    CLOSED: [2018-05-27 Sun 15:20]
    - Even though /extension properties/ are called /properties/,
      *they CANNOT have any state* -- since they are just /syntactic sugar/, NOT
      really be added to corresponding types objects, *there is NO proper place
      to store state*!

    - For example,
      + Listing 3.7 - Declaring an extension property
        #+BEGIN_SRC scala
          val String.lastChar: Char
            get() = get(length - 1)
        #+END_SRC
        * _The getter must always be defined, because there's NO backing field
          and therefore NO default /getter/ implementation._

      + Listing 3.8 - Declaring a mutable extension property
        #+BEGIN_SRC scala
          var StringBuilder.lastChar: Char
              get() = get(length - 1)

              set(value: Char) {
                  this.setCharAt(length - 1, value)
              }
        #+END_SRC

    - Like /extension functions/, in Java, you should invoke its /getter/
      explicitly: ~StringUtilKt.getLastChar("Java")~

** DONE 3.4 Working with collections: varargs, infix calls, and library support - 57
   CLOSED: [2018-05-27 Sun 16:03]
   This section shows some of the functions from the Kotlin standard library for
   working with collections. Along the way, it describes a few related language
   features:

   - The ~vararg~ keyword, which allows you to declare a function taking an
     arbitrary number of arguments

   - An /infix notation/ that lets you call some one-argument functions without
     ceremony

   - /Destructuring declarations/ that allow you to unpack a single composite
     value into multiple variables

*** DONE 3.4.1 Extending the Java Collections API - 57
    CLOSED: [2018-05-27 Sun 15:44]
*** DONE 3.4.2 Varargs: functions that accept an arbitrary number of arguments - 58
    CLOSED: [2018-05-27 Sun 15:52]
    - For example,
      we saw ~listOf~ function, which may take any number of arguments.
      Here is the declaration header of it:
      ~fun listOf<T>(vararg values: T): List<T> { ... }~

    - Differences between Kotlin and Java in varable number of parameters:
      + Difference SYTAX, Java use ~args...~

      + In Java, you pass the array.
        In Kotlin, you must pass the unpacked /array/ with the /spread operator/ ~*~:
        #+BEGIN_SRC scala
          fun main(args: Array<String>) {
            val list = listOf("args: ", *args)
            println(list)
          }
        #+END_SRC

*** DONE 3.4.3 Working with pairs: infix calls and destructuring declarations - 59 
    CLOSED: [2018-05-27 Sun 16:03]
    - /infix calls/ can be used with /regular methods/ and /extension functions/
      that have *ONE required parameter*. You need the ~infix~ keyword!
      For instance, ~infix fun Any.to(other: Any) = Pair(this, other)~ (this is
      NOT the one in the standard libary, which should use /generics/)

    - /destruturing declaration/
      For instance, you can unpack a ~Pair~ with the syntax:
      ~val (number, name) = 1 to "one"~
      and
      #+BEGIN_SRC scala
        for ((index, element) in collection.withIndex()) {
            println("$index: $element")
        }
      #+END_SRC

    - =TODO= Section 7.4 - the _general rules_ for
      _destructuring an expression and using it to initialize several variables._

** DONE 3.5 Working with strings and regular expressions - 60
   CLOSED: [2018-05-27 Sun 19:56]
*** DONE 3.5.1 Splitting strings - 60
    CLOSED: [2018-05-27 Sun 18:46]
    - Java ~String~'s ~split~ /method/ often confuses the programmer!
      It accept a ~String~, but use it as a /regex/.

    - Kotlin defineds some /extension functions/,
      the one that takes a /regex/ requires a value of ~Regex~ type, not ~String~.

      You can get an array of ~[122, 345, 6, A]~ from
      + ~"12.345-6.A".split("\\.|-".toRegex())~

      + ~"12.345-6.A".split(".", "-")~

      + ~"12.345-6.A".split('.', '-')~

*** DONE 3.5.2 Regular expressions and triple-quoted strings - 61
    CLOSED: [2018-05-27 Sun 19:18]
    - For simple problem, use some substring methods with specified separators.
      For instance,
      #+BEGIN_SRC scala
        fun parsePath(path: String) {
          val directory = path.substringBeforeLast("/")
          val fullName = path.substringAfterLast("/")
          val fileName = fullName.substringBeforeLast(".")
          val extension = fullName.substringAfterLast(".")
          println("Dir: $directory, name: $fileName, ext: $extension")
        }

        // >>>
        parsePath("/Users/yole/kotlin-book/chapter.adoc")
        // Dir: /Users/yole/kotlin-book, name: chapter, ext: adoc
      #+END_SRC

    - Use regex:
      #+BEGIN_SRC scala
        fun parsePath(path: String) {
          val regex = """(.+)/(.+)\.(.+)""".toRegex()
          val matchResult = regex.matchEntire(path)
          if (matchResult != null) {
            val (directory, filename, extension) = matchResult.destructured
            println("Dir: $directory, name: $filename, ext: $extension")
          }
        }
      #+END_SRC
      + /triple-quoted string/ is just /raw string/ -- no extra /backslash escape/
        required for escaping /backslash/.

      + Use the ~toRegex~ method to convert a string to a regex.

      + If the ~matchResult~ is NOT ~null~, you can destruct it with the
        ~destructured~ /method/.

*** DONE 3.5.3 Multiline triple-quoted strings - 62
    CLOSED: [2018-05-27 Sun 19:56]
    - Example:
      #+BEGIN_SRC scala
        val kotlinLogo = """| //
                           .|//
                           .|/ \"""

        // >>>
        println(kotlinLogo.trimMargin("."))
        //   | //
        //   |//
        //   |/ \
      #+END_SRC

    - A triple-quoted string can contain line breaks,
      + but you can't use special characters like =\n=.

      + On the other hand, you don't have to escape ~\~, so, for instance,
        the Windows-style path ~"C:\\Users\\yole\\kotlin-book"~ can be written
        as ~"""C:\Users\yole\ kotlin-book"""~.

    - You can combine /string templates/ and /triple-quote string/ together.
      However, since you CANNOT use escape in /triple-quote strings/, if you want
      to have a =$= character in your string, you do it in this way:
      ~val price = """${'$'}99.9"""~.

    - *NOTE*
      And indeed, a large portion of the /Kotlin standard library/ is made up of
      /extension functions/ for /standard Java classes/.

      =IMPORTANT= =!!!=
      The /Anko library/ (https://github.com/kotlin/anko), also built by
      JetBrains, provides /extension functions/ that make the Android API more
      Kotlin-friendly.

** DONE 3.6 Making your code tidy: local functions and extensions - 64
   CLOSED: [2018-05-26 Sat 15:52]
   - The evolution of codes:
     + Listing 3.11 - A function with repetitive code
       #+BEGIN_SRC scala
         class User(val id: Int, val name: String, val address: String)

         fun saveUser(user: User) {
             if (user.name.isEmpty()) {
                 throw IllegalArgumentException(
                     "Can't save user ${user.id}: empty Name")
             }

             if (user.address.isEmpty()) {
                 throw IllegalArgumentException(
                     "Can't save user ${user.id}: empty Address")
             }

             // Save user to the database
         }

         saveUser(User(1, "", ""))
         // java.lang.IllegalArgumentException: Can't save user 1: empty Name
       #+END_SRC

     + Listing 3.12 - Extracting a local function to avoid repetition
       #+BEGIN_SRC scala
         class User(val id: Int, val name: String, val address: String)

         fun saveUser(user: User) {
             fun validate(user: User,
                          value: String,
                          fieldName: String) {
                 if (value.isEmpty()) {
                     throw IllegalArgumentException(
                         "Can't save user ${user.id}: empty $fieldName")
                 }
             }

             validate(user, user.name, "Name")
             validate(user, user.address, "Address")
             // Save user to the database
         }
       #+END_SRC

     + Listing 3.13 - Accessing outer function parameters in a local function
       #+BEGIN_SRC scala
         class User(val id: Int, val name: String, val address: String)

         fun saveUser(user: User) {
             fun validate(value: String,
                          fieldName: String) {
                 if (value.isEmpty()) {
                     throw IllegalArgumentException(
                         "Can't save user ${user.id}: empty $fieldName")
                 }
             }

             validate(user.name, "Name")
             validate(user.address, "Address")
             // Save user to the database
         }
       #+END_SRC

     + Listing 3.14 - Extracting the logic into an /extension function/
       #+BEGIN_SRC scala
         class User(val id: Int, val name: String, val address: String)

         fun User.validateBeforeSave() {
             fun validate(value: String, fieldName: String) {
                 if (value.isEmpty()) {
                     throw IllegalArgumentException(
                         "Can't save user $id: empty $fieldName")
                 }
         }

             validate(name, "Name")
             validate(address, "Address")
         }

         fun saveUser(user: User) {
             user.validateBeforeSave()
             // Save user to the database
         }
       #+END_SRC

       * =TODO= =???= 
         Extracting a piece of code into an /extension function/ turns out to be
         surprisingly useful.

         Even though ~User~ is a part of your codebase and not a library class,
         + you don't want to put this logic into a method of ~User~ , because
           it's not relevant to any other places where ~User~ is used.

         + If you follow this approach the API of the /class/ contains only the
           essential /methods/ used everywhere, so the /class/ remains small and
           easy to wrap your head around.
             On the other hand, /functions/ that primarily deal with a single
           =TODO= =???= =???= =???= =???=
           object and don't need access to its private data can access its
           members without extra qualification, as in listing 3.14.

   - As a general rule for readability, we don't recommend using more than one
     level of nesting.

** DONE 3.7 Summary - 66
   CLOSED: [2018-05-27 Sun 19:58]

* TODO 4 Classes, objects, and interfaces - 67 -- =Reading=
  - This chapter covers
    + /Classes/ and /interfaces/

    + Nontrivial /properties/ and /constructors/

    + /Data classes/

    + /Class delegation/

    + Using the ~object~ keyword

** DONE 4.1 Defining class hierarchies - 68
   CLOSED: [2018-05-27 Sun 23:17]
*** DONE 4.1.1 Interfaces in Kotlin - 68
    CLOSED: [2018-05-27 Sun 20:41]
    - We'll begin with a look at defining and implementing /interfaces/.

      /Kotlin interfaces/ are SIMILAR TO those of /Java 8/:
      they can contain
      + definitions of /abstract methods/

      + implementations of /non-abstract methods/ (similar to the Java 8
        /default methods/). Kotlin doesn't have and need the ~default~ keyword.

      + They *CANNOT* contain any /state/.

    - Example (Define and implement an /interface/)
      #+BEGIN_SRC scala
        interface Clickable {
          fun click()
        }

        class Button : Clickable {
          override fun click() = println("I was clicked")
        }
      #+END_SRC

    - Use the ~override~ modifier is _mandatory_ in Kotlin.

    - If a /class/ implement two /interfaces/ with same signature and name
      /methods/, neither one will win by default. *You must explicitly implement
      yours*.
      #+BEGIN_SRC scala
        interface Clickable {
          fun click()

          fun showOff() = println("I'm clickable!")
        }

        interface Focusable {
          fun setFocus(b: Boolean) =
            println("I ${if (b) "got" else "lost"} focus.")

          fun showOff() = println("I'm focusable!")
        }

        class Button : Clickable, Focusable {
          override fun click() = println("I was clicked")

          override fun showOff() {
            super<Clickable>.showOff()
            super<Focusable>.showOff()
          }
        }
      #+END_SRC

    - *Implementing interfaces with method bodies in Java*
      *Kotlin 1.0 has been designed to target Java 6*,
      which DOESN'T support /default methods/ in /interfaces/.
        Therefore, it compiles each /interface/ with /default methods/ to a
      combination of a regular /interface/ and a /class/ containing the /method/
      bodies as /static methods/.

      + The /interface/ contains ONLY declarations

      + the /class/ contains all the implementations as static methods.

      =IMPORANT= =!!!= =IMPORTANT=
      Therefore, if you need to implement such an /interface/ in a Java class, you
      have to define your own implementations of all /methods/, including those
      that have method bodies in Kotlin.

*** DONE 4.1.2 ~open~, ~final~, and ~abstract~ modifiers: ~final~ by default - 70
    CLOSED: [2018-05-27 Sun 21:10]
    - Kotlin's /classs/ and /(concrete) methods/  are ~final~ _by default_.
      Add ~open~ for the /methods/ that open to be /overridden/.
      #+BEGIN_SRC scala
        open class RichButton : Clickable {
          fun disable() {}

          open fun animate() {}

          override fun click() {}
        }
      #+END_SRC

    - The /overridability/ is _inherited by default_!
      Use ~final~ to change the /overridability/ of your /subclasses/ or /their
      methods/.
      #+BEGIN_SRC scala
        open class Richbutton : Clickable {
          final override fun click() {}
        }
      #+END_SRC

    - *Open classes and smart casts* =TODO= =RE-READ= =???=
      One significant benefit of classes that are final by default is that they
      enable smart casts in a larger variety of scenarios.
        As we mentioned in section 2.3.5, smart casts work only for variables
      that couldn’t have changed after the type check. For a class, this means
      smart casts can only be used with a class property that is a val and that
      doesn’t have a custom accessor. This requirement means the property has to
      be final, because otherwise a subclass could override the property and
      define a cus- tom accessor, breaking the key requirement of smart casts.
      Because properties are final by default, you can use smart casts with most
      properties without thinking about it explicitly, which improves the
      expressiveness of your code.

    - In interfaces, you don't use ~final~ , ~open~ , or ~abstract~.

      =IMPORTANT=
      =From Jian= Even /concrete methods/ cannot be ~final~.
      If it is, you cannot override it to solve confliction comes from multiple
      /interfaces/.

    - /Abstract members/ are _ALWAYS_ ~open~, and they cannot be marked as ~final~.

*** DONE 4.1.3 Visibility modifiers: public by default - 73
    CLOSED: [2018-05-27 Sun 23:17]
    - The default visibility in Java, /package-private/, is _NOT present_ in Kotlin.

      Kotlin uses /packages/ ONLY as a way of organizing code in namespaces;
      _it does *NOT* use them for visibility control_.

    - As an alternative, Kotlin offers a _NEW_ /visibility modifier/, ~internal~,
      which means "visible inside a /module/."

      A /module/ is a set of Kotlin files compiled together.
      It may be
      + an IntelliJ IDEA module
      + an Eclipse project
      + a Maven or Gradle project
      + or a set of files compiled with an invocation of the Ant task.

    - The advantage of /internal visibility/ is that it provides real encapsulation
      for the implementation details of your /module/.
        With Java, the encapsulation can be easily broken, because external code
      can define /classes/ in the _SAME_ /packages/ used by your code and thus
      get access to your /package-private/ declarations.

    - ~private~ can be used in the top-level declarations.
      Then, the top-level declarations are only visible in the file where they
      are declared.

    - Table 4.2 - Kotlin visibility modifiers
      | Modifier         | Class member          | Top-level declaration |
      |------------------+-----------------------+-----------------------|
      | public (default) | Visible everywhere    | Visible everywhere    |
      | ~internal~       | Visible in a module   | Visible in a module   |
      | ~protected~      | Visible in subclasses | --                    |
      | ~private~        | Visible in a class    | Visible in a file     |

    - *Kotlin's visibility modifiers and Java* =TOOD= =RE-READ= =NOTE= =???=
      ~public~, ~protected~, and ~private~ modifiers in Kotlin are preserved when compil-
      ing to Java bytecode. You use such Kotlin declarations from Java code as if they were
      declared with the same visibility in Java. The only exception is a private class: it’s
      compiled to a package-private declaration under the hood (you can’t make a class
      private in Java).

      But, you may ask, what happens with the internal modifier? There’s no direct ana-
      logue in Java. Package-private visibility is a totally different thing: a module usually
      consists of several packages, and different modules may contain declarations from
      the same package. Thus an internal modifier becomes public in the bytecode.
      This correspondence between Kotlin declarations and their Java analogues (or their
      bytecode representation) explains why sometimes you can access something from
      Java code that you can’t access from Kotlin. For instance, you can access an inter-
      nal class or a top-level declaration from Java code in another module, or a
      protected member from Java code in the same package (similar to how you do that
      in Java).

      But note that the names of internal members of a class are mangled. Technically,
      internal members can be used from Java, but they look ugly in the Java code. That
      helps avoid unexpected clashes in overrides when you extend a class from another
      module, and it prevents you from accidentally using internal classes.

    - =See the Next Section=
      One more difference in visibility rules between Kotlin and Java is that an
      /outer class/ doesn’t see /private members/ of its /inner (or nested) classes/
      in Kotlin.

*** DONE 4.1.4 Inner and nested classes: nested by default - 75
    CLOSED: [2018-05-27 Sun 23:17]
    The _difference_ is that Kotlin /nested classes/ do _NOT have access_ to the
    /outer class/ instance, _unless you specifically request that_.

    - =TODO= =NOTE= =???=

    - Table 4.3 - Correspondence between nested and inner classes in Java and Kotlin
      | Class A declared within another class B                                           | In Java          | Ininner class Kotlin       |
      |-----------------------------------------------------------------------------------+------------------+-----------------|
      | Nested class (doesn't store a reference to an outer class) static class A class A | ~static class~ A | ~class~ A       |
      | Inner class (stores a reference to an outer class) class A inner class A          | ~class~ A        | ~inner class~ A |

    - After using ~inner~, you can use ~this@OuterName~ to reference the /outer class/!
      =IMPORTANT= Java doesn't do it his way!

*** DONE 4.1.5 Sealed classes: defining restricted class hierarchies - 77
    CLOSED: [2018-05-27 Sun 23:02]
    You may remember when you use ~when~, you always need to write the ~else~
    branch to catch all else, and usually since nothing can be their, you can't
    get any meaningful value, you just _throw an exception_.

    - To avoid the ~else~ branch, use the ~sealed~ /classes/

      Note that the ~sealed~ modifier implies that the /class/ is /open/, and NO
      explicit ~open~ modifier required!

    - _WITHOUT_ ~sealed~
      #+BEGIN_SRC scala
        interface Expr
        class Num(val value: Int) : Expr
        class Sum(val left: Expr, val right: Expr) : Expr

        fun eval(e: Expr): Int =
          when (e) {
            is Num -> e.value
            is Sum -> eval(e.right) + eval(e.left)
            else   -> throw IllegalArgumentException("Unknown expression")  // You have to!
        }
      #+END_SRC

    - With ~sealed~
      #+BEGIN_SRC scala
        sealed class Expr {
          class Num(val value: Int) : Expr()
          class Sum(val left: Expr, val right: Expr) : Expr()
        }

        fun eval(e: Expr): Int =
          when (e) {
            is Expr.Num -> e.value
            is Expr.Sum -> eval(e.right) + eval(e.left)
          }
      #+END_SRC
      Combine ~sealed class~ with ~when~, an /exhaustiveness check/ will be applied!

    - There is *NO* /sealed interface/!

      Under the hood, the ~Expr~ /class/ has a /private constructor/, which can
      be called ONLY inside the /class/. You can't declare a /sealed interface/.

      =???= =TODO= =IMPORTANT=
      Why? If you could, the Kotlin compiler wouldn't be able to guarantee
      that someone couldn't implement this interface in the Java code.

    - *NOTE*
      In Kotlin 1.0, the /sealed/ functionality is rather *restricted*. For
      instance, all the /subclasses/ _must be nested_, and a /subclass/ *CANNOT*
      be made a ~data class~ (/data classes/ are covered later in this chapter).

      Kotlin 1.1 *relaxes* the restrictions and lets you define /subclasses/ of
      /sealed classes/ *anywhere* _in the same file_.

** DONE 4.2 Declaring a class with nontrivial constructors or properties - 78
   CLOSED: [2018-05-31 Thu 11:03]
   - Kotlin LIKE Scala, UNLIKE Java, distinguishes the /primary constructor/ and
     the /secondary constructor(s)/.

   - Kotlin also allows you to put additional initialization logic in /initializer blocks/.

*** DONE 4.2.1 Initializing classes: primary constructor and initializer blocks - 79
    CLOSED: [2018-05-31 Thu 09:52]
    - In chapter 2, you saw how to declare a simple class:
      ~class User(val nickname: String)~

      We can write it in the most explicit way:
      #+BEGIN_SRC scala
        class User constructor(_nickname: String) {
          val nickname: String

          init {
            nickname = _nickname
          }
        }
      #+END_SRC
      + Here we see two new /keywords/: ~constructor~ and ~init~

      + Because the /primary constructor/ has a constrained syntax,
        it CANNOT contain the initialization code; that's why you have
        /initializer blocks/.

      + If you want to, you can declare _SEVERAL_ /initializer blocks/ in one
        /class/.

    - In this example, you _DON'T NEED_ to place the initialization code in the
      /initializer block/, because it can be combined with the declaration of
      the ~nickname~ /property/.

      You can also _OMIT_ the ~constructor~ /keyword/
      if there are _no annotations or visibility modifiers_ on the /primary
      constructor/. If you apply those changes, you get the following:
      #+BEGIN_SRC scala
        class User(_nickname: String) {
          val nickname = _nickname
        }
      #+END_SRC

    - /Default values/ for /constructor parameters/ is also available!

    - To create an instance of a class, you call the constructor directly, _WITHOUT_
      the ~new~ keyword. This is UNLIKE Scala, which requires ~apply~
      /method(s)/ to do the same thing.

    - Kotlin use the similar way to initalize the /superclass/:
      #+BEGIN_SRC scala
        open class User(val nickname: String) { ... }
        class TwitterUser(nickname: String) : User(nickname) { ... }
      #+END_SRC

    - As Java and Scala, if you _don't declare_ any /constructors/ for a /class/,
      a /default constructor/ that _does nothing_ will be *generated* for you.

    - You need to explicitly invoke the /superclass constructor(s)/. Even if it
      only have the /default constructor/, you need the empty parentheses!
      #+BEGIN_SRC scala
        open class Button
        class RadioButton: Button()
      #+END_SRC

    - The /private constructors/, which often works with /companion objects/.
      For instance, ~class Secretive private constructor() {}~

    - *Alternatives to private constructors*
      In Java, you can use a /private constructor/ that prohibits class
      instantiation to expression a container of static utility memebers or is a
      singleton.

      Don't do this in Kotlin!
      Kotlin has two functionalities to do these things, respectively!
      + /top-level functions/
      + ~object~

*** DONE 4.2.2 Secondary constructors: initializing the superclass in different ways - 81
    CLOSED: [2018-05-31 Thu 10:01]
    - *TIP*
      Kotlin mostly don't need MULTIPLE /constructors/ because of the /default
      constructor parameters/ feature.

    - Example:
      #+BEGIN_SRC scala
        open class View {
          constructor(ctx: Context) {
            // some code
          }
          constructor(ctx: Context, attr: AttributeSet) {
            // some code
          }
        }
      #+END_SRC

      + Extends this /class/ with ~super~:
        #+BEGIN_SRC scala
          class MyButton : View {
            constructor(ctx: Context)
                : super(ctx) {
              // ...
            }
            constructor(ctx: Context, attr: AttributeSet)
                : super(ctx, attr) {
              // ...
            }
          }
        #+END_SRC

      + Call another /constructor/ of the same /class/ with ~this~:
        #+BEGIN_SRC scala
          class MyButton : View {
            constructor(ctx: Context): this(ctx, MY_STYLE) {
              // ...
            }

            constructor(ctx: Context, attr: AttributeSet): super(ctx, attr) {
              // ...
            }
          }
        #+END_SRC

    - _Java interoperability_ is the main use case when you need to use /secondary
      constructors/.

*** DONE 4.2.3 Implementing properties declared in interfaces - 83
    CLOSED: [2018-05-31 Thu 10:28]
    - In Kotlin, an /interface/ can contain /abstract property declarations/.

    - Example:
      #+BEGIN_SRC scala
        interface User {
          val nickname: String
        }

        class PrivateUser(override val nickname: String) : User

        class SubscribingUser(val email: String) : User {
          override val nickname: String
          get() = email.substringBefore('@')
        }

        class FacebookUser(val accountId: Int) : User {
          override val nickname = getFacebookName(accountId)
        }

        println(PrivateUser("test@kotlinlang.org").nickname)
        // test@kotlinlang.org

        println(SubscribingUser("test@kotlinlang.org").nickname)
        // test
      #+END_SRC
      + =From Jian= The ~override~ is mandatory even for abstract members???
        =TODO= =???=

    - In addition to /abstract property declarations/, an /interface/ can contain
      /properties/ _with /getters/ and /setters/,_ as long as they *don't
      reference* a /backing field/. (A /backing field/ would require storing state
      in an /interface/, which isn't allowed.)

*** DONE 4.2.4 Accessing a backing field from a getter or setter - 85
    CLOSED: [2018-05-31 Thu 10:47]
    - Example:
      #+BEGIN_SRC scala
        class User(val name: String) {
          var address: String = "unspecified"
              set(value: String) {
                println("""
                    Address was changed for $name:
                    "$field" -> "$value".""".trimIndent())
                field = value
              }
        }
      #+END_SRC
      + The ~field~ is a special identifier to reference the value of this field.

      + The /getter/ here is trivial, re-define is NOT required.

      + The /getter/ can ONLY *read* the field.

      + The /setter/ can *read* the field and *modify* the field.

    - Sometimes you don't need to change the default implementation of an accessor,
      but you need to _CHANGE its /visibility/._
      =TODO=
      Let’s see how you can do this.

*** DONE 4.2.5 Changing accessor visibility - 86
    CLOSED: [2018-05-31 Thu 11:03]
    - Example:
      #+BEGIN_SRC scala
        class LengthCounter {
          var counter: Int = 0
              private set

          fun addWord(word: String) {
              counter += word.length
          }
        }
      #+END_SRC
      + The ~counter~ can be access by the public, but it shouldn't be modified
        by the public.

    - *More about properties later* =TODO= =TODO= =TODO=
      Later in the book, we’ll continue our discussion of properties. Here are
      some references:
      + The ~lateinit~ /modifier/ on a non-null property specifies that this property
        is initialized later, after the constructor is called, which is a common
        case for some frameworks.
        =TODO=
        This feature will be covered in chapter 6.

      + /LAZY initialized properties/, as part of the more general /delegated
        properties/ feature, will be covered in chapter 7. =TODO=

        For compatibility with Java frameworks, you can use annotations that
        emulate Java features in Kotlin. For instance, the ~@JvmField~ annotation
        on a /property/ *exposes a public field without accessors*.

        You'll learn more about /annotations/ in chapter 10. =TODO=

      + The ~const~ modifier makes working with annotations more convenient and
        lets you use a /property/ of a primitive type or String as an annotation
        argument.
        Chapter 10 provides details. =TODO=

** DONE 4.3 Compiler-generated methods: data classes and class delegation - 87
   CLOSED: [2018-05-31 Thu 11:58]
*** DONE 4.3.1 Universal object methods - 87
    CLOSED: [2018-05-31 Thu 11:23]
**** DONE String Representation: ~toString()~
     CLOSED: [2018-05-31 Thu 11:23]
**** DONE Object Equality: ~equals()~
     CLOSED: [2018-05-31 Thu 11:23]
     - ~==~ *for equality*
       In Kotlin, the ~==~ operator is the default way to compare two objects:
       it compares their values by calling ~equals~ under the hood. Thus, if
       ~equals~ is /overridden/ in your /class/, you can safely compare its
       instances using ~==~.
         For /reference comparison/, you can use the ~===~ operator, which works
       exactly the same as ~==~ in Java by /comparing the object references/.

     - Example:
       #+BEGIN_SRC scala
         class Client(val name: String, val postalCode: Int) {
           override fun equals(other: Any?): Boolean {
             if (other == null || other !is Client)
               return false

             return name == other.name &&
                    postalCode == other.postalCode
           }

           override fun toString() = "Client(name=$name, postalCode=$postalCode)"
         }
       #+END_SRC

     - *Reminder*
       + Kotlin's ~is~ is the analogue of Java's ~instanceof~.
         It checks whether a value has the specified type.
         ~!is~ is the negation of ~is~.

     - In chapter 6, =TODO= =???= =IMPORTANT=
       we'll discuss /nullable types/ in detail and why the condition
       ~other == null || other !is Client~ can be simplified to ~other !is Client~ .

**** DONE Hash Containers: ~hashCode()~
     CLOSED: [2018-05-31 Thu 11:23]

*** DONE 4.3.2 Data classes: autogenerated implementations of universal methods - 89
    CLOSED: [2018-05-31 Thu 11:36]
    - If you want your class to be a convenient /holder for your data/, you need
      to *override* these methods: ~toString~ , ~equals~ , and ~hashCode~.

      The Kotlin way: use ~data class~

    - These three /methods/ isn't a complete list of useful /methods/ generated
      for /data classes/.

**** DONE Data Classes and Immutability: The ~copy~ method
     CLOSED: [2018-05-31 Thu 11:35]
     - Though the properties of a /data class/ can be both ~val~ ro ~var~,
       ~var~ is not friendly for ~HashMap~.
       =From Jian= This is explained the Scala book I read.

     - The ~copy~ method is also a /generated method/, and you can copy a
       /data class/ and specify the new property value without changing the
       other property values.
       For example:
       #+BEGIN_SRC scala
         data class Client(val name: String, val postalCode: Int)

         val bob = Client("Bob", 973293)
         val newBob = bob.copy(postalCode = 973293)
       #+END_SRC

*** DONE 4.3.3 Class delegation: using the ~by~ keyword - 91
    CLOSED: [2018-05-31 Thu 11:58]
    - =From Jian=
      Kotlin doesn't have Scala's /implicit conversion/, and it needs to
      functionalities to do the same thing:
      + /extension functions/
      + /class delegation/

    - We want /class delegation/, and we want do the same thing as in Java (use
      the /decorator pattern/), which requires a fairly large amount of
      boilerplate code (though IDEs like IntelliJ IDEA have dedicated features
      to generate that code for you).

      Kotlin use ~by~.

      + The Java's /decorator pattern/ (in Kotlin without ~by~):
        #+BEGIN_SRC scala
          class DelegatingCollection<T> : Collection<T> {
              private val innerList = arrayListOf<T>()
              override val size: Int
                  get() = innerList.size
              override fun isEmpty(): Boolean = innerList.isEmpty()
              override fun contains(element: T): Boolean = innerList.contains(element)
              override fun iterator(): Iterator<T> = innerList.iterator()
              override fun containsAll(elements: Collection<T>): Boolean = innerList.containsAll(elements)
          }
        #+END_SRC

      + Kotlin with ~by~
        #+BEGIN_SRC scala
          class DelegatingCollection<T>(
            innerList: Collection<T> = arrayListOf<T>()
          ) : Collection<T> by innerList {}
        #+END_SRC
        * The example is the simplest one.
          In real world, you may ~override~ some methods, and ignore the
          boilerplate code with the help of ~by~.
          #+BEGIN_SRC scala
            class CountingSet<T>(
              val innerSet: MutableCollection<T> = HashSet<T>()
            ) : MutableCollection<T> by innerSet {

              var objectsAdded = 0

              override fun add(element: T): Boolean {
                objectsAdded++
                return innerSet.add(element)
              }

              override fun addAll(c: Collection<T>): Boolean {
                objectsAdded += c.size
                return innerSet.addAll(c)
              }
            }

            val cset = CountingSet<Int>()
            cset.addAll(listOf(1, 1, 2))
            println("${cset.objectsAdded} objects were added, ${cset.size} remain")
            // 3 objects were added, 2 remain
          #+END_SRC

** TODO 4.4 The ~object~ keyword: declaring a class and creating an instance, combined - 93
   - ~object~ declaration is a way to define a /singleton/.

   - /Companion objects/ can contain /factory methods/ and /other methods/ that
     are related to this /class/ BUT do *NOT* require a /class/ instance to be
     called. Their members can be accessed _via ~class~ name_.

   - /Object expression/ is used instead of Java's /anonymous inner class/.
     =???= =TODO=

*** DONE 4.4.1 Object declarations: singletons made easy - 93
    CLOSED: [2018-05-28 Mon 21:14]
    - Java Singleton Pattern ::
         Define a /class/ with a ~private~ /constructor/ and a /static field/
         holding the ONLY existing instance of the /class/.

    - The only things that aren't allowed in an /objec declaration/ are
      /constructors/ (either primary or secondary).

    - *UNLIKE* /instances/ of REGULAR /classes/,

      /object declarations/ are reated immediately at the point of definition,
      _NOT_ through /constructor/ calls from other places in the code.

      Therefore, defining a /constructor/ for an /object declaration/ doesn't make
      sense.

    - ~object~ can inherit from /classes/ and /interfaces/, but they shouldn't
      have /states/. =???= =TODO= =How to Avoid=

    - *Singletons and dependency injection*
      =TODO= NOTE =TODO=

    - *Using Kotlin objects from Java*
      An /object declaration/ in Kotlin is compiled as a /class/ with a /static
      field/ holding its /single instance/, which is *always named* ~INSTANCE~.
        If you implemented the /Singleton pattern/ in Java, you'd probably do the
      same thing by hand. Thus, to use a Kotlin ~object~ from the Java code, you
      access the _static_ ~INSTANCE~ /field/:
      ~CaseInsensitiveFileComparator.INSTANCE.compare(file1, file2);~

      In this example, the ~INSTANCE~ /field/ has the type
      ~CaseInsensitiveFileComparator~.

*** TODO 4.4.2 Companion objects: a place for factory methods and static members - 96
    - Kotlin, like Scala, doesn't have Java's ~static~ keyword.
      Therefore, like Scala, Kotlin _CANNOT_ define /static members/.

      _As a replacement_,
      Kotlin relies on /package-level functions/ and /object declarations.

    - In most cases, it's _RECOMMANDED_ that you use /top-level functions/.
      However, /top-level functions/ cannot access ~private~ members of a /class/.

      If you want to access the ~private~ members of a /class/, you can define a
      /companion objects/, which is marked with the ~companion~ keyword.
      For instance,
      #+BEGIN_SRC scala
        class A {
          companion object {
            fun bar() {
              println("Companion object called");
            }
          }
        }

        // >>>
        A.bar()
        // Companion object called
      #+END_SRC

    - /top-level functions/
      =From Jian= The meaning and the usage of Kotlin's /companion object/ is
      similar (if not same, I'm not sure) to Scala's /companion object/,
      However, _they have *DIFFERENT* SYNTAX._

      + Example:
        #+BEGIN_SRC scala
          class A {
            companion object {
              fun bar() {
                println("Companion object called")
              }
            }
          }
        #+END_SRC

    - Remember when we promised you a good place to call a /private constructor/?
      That's the /companion object/. The /companion object/ has access to all
      /private members/ of the /class/, including the /private constructor/, and
      it's an ideal candidate to implement the /Factory pattern/. =TODO= =NOTE=

    - Example:
      =TODO=

*** TODO 4.4.3 Companion objects as regular objects - 98
*** TODO 4.4.4 Object expressions: anonymous inner classes rephrased - 100

** DONE 4.5 Summary - 101
   CLOSED: [2018-05-31 Thu 12:06]
   - /Interfaces/ in Kotlin are similar to Java's
     BUT *can contain default implementations (which Java supports only since
     version 8) and /properties/*.

   - All declarations are ~final~ and ~public~ *by default*.

   - To make a declaration non-final , mark it as ~open~.

   - ~internal~ declarations are visible in the same /module/. =???=

   - Nested classes are *NOT* /inner/ _by default_.
     Use the keyword ~inner~ to store a reference to the /outer class/.

   - A ~sealed~ /class/ can only have /subclasses/ nested in its declaration
     (Kotlin 1.1 will allow placing them *anywhere in the same file*).

   - /Initializer blocks/ and /secondary constructors/ provide flexibility for
     *initializing* /class instances/.

   - You use the ~field~ identifier to reference a /property backing field/ from
     the /accessor/ body.

   - /Data classes/ provide compiler-generated ~equals~, ~hashCode~, ~toString~,
     ~copy~, and other /methods/.

   - /Class delegation/ helps to avoid writing the simple method delegations
     explicitly.

   - Object declaration is Kotlin's way to define a singleton class.

   - /Companion objects/ (along with /package-level functions and properties/)
     replace Java's /static method and field/ definitions.

   - /Companion objects/, like other objects, can _implement_ /interfaces/, as
     well as have /extension functions and properties/.

   - Object expressions are Kotlin's replacement for Java's /anonymous inner
     classes/, with added power such as the ability to implement multiple
     /interfaces/ and to modify the variables defined in the scope where the
     object is created.
     =TODO= =TODO= =TODO=

* TODO 5 Programming with lambdas - 103 -- =Reading=
  This chapter covers
  - Lambda expressions and member references

  - Working with collections in a functional style

  - Sequences: performing collection operations lazily

  - Using Java functional interfaces in Kotlin

  - Using lambdas with receivers

** DONE 5.1 Lambda expressions and member references - 104
   CLOSED: [2018-05-29 Tue 19:20]
*** DONE 5.1.1 Introduction to lambdas: blocks of code as function parameters - 104
    CLOSED: [2018-05-29 Tue 16:03]
*** DONE 5.1.2 Lambdas and collections - 105
    CLOSED: [2018-05-29 Tue 16:21]
    - En:
      tenets - 原則

    - Most of the tasks we perform with /collections/ *follow a few common patterns*,
      so the code that implements them _SHOULD live in a library._

      But without /lambdas/, it's difficult to provide a _concise_ and _convenient_
      library for working with /collections/.

    - Example:
      Suppose we have a ~Person~ /data class/ and we have a list of ~Person~:
      ~val people = listOf(Person("Alice", 29), Person("Bob", 31))~~. We want to
      find the oldest of them.

      + NO /lambda/ way:
        #+BEGIN_SRC scala
          fun findTheOldest(people: List<Person>) {
            var maxAge = 0
            var theOldest: Person? = null

            for (person in people) {
              if (person.age > maxAge) {
                maxAge = person.age
                theOldest = person
              }
            }

            println(theOldest)
          }

          // >>> findTheOldest(people)
          Person(name=Bob, age=31)
        #+END_SRC

      + With a /lambda/:
        ~people.maxBy { it.age }~

      + With a /member reference/ -- a shorthand for writing /lambda/ of some
        special cases:
        ~people.maxBy(Person::age)~

*** DONE 5.1.3 Syntax for lambda expressions - 106
    CLOSED: [2018-05-29 Tue 16:59]
    - SYNTAX (by example):
      + with argument(s): ~{ x: Int, y: Int -> x + y }~ 
      + NO argument: ~{ println(42) }~ 

    - A lambda expression in Kotlin is ALWAYS
      + surrounded by curly braces.
      + NO parentheses around the arguments.
      + arrow (~->~) from argument list from the body of the /lambda/.

    - Call the /lambda/ directly (RARELY used): 
      ~{ println(42) }()~

    - With the library function ~run~:
      ~run { println(42) }~

      =From Jian= How to run it with parameters??? =TODO=

    - =TODO=
      In section 8.2,
      you’ll learn why such invocations have no runtime overhead and are as
      efficient as built-in language constructs.

    - With the raw syntax:
      ~people.maxBy({ p: Person -> p.age })~

      1. In Kotlin, a /syntactic convention/ lets you move a /lambda expression/
         *out* of parentheses _if it's the *last argument* in a function call_.
         ~people.maxBy() { p: Person -> p.age }~

      2. The empty parentheses can be omitted.
         ~people.maxBy { p: Person -> p.age }~

    - Multiple parameters, and the last is a /lambda/:
      #+BEGIN_SRC scala
        val people = listOf(Person("Alice", 29), Person("Bob", 31))
        val names = people.joinToString(separator = " ",
                                        transform = { p: Person -> p.name })
        println(names)
        // Alice Bob
      #+END_SRC

      + Move the /lambda/ out: ~people.joinToString(" ") { p: Person -> p.name }~
        In this version, we cannot use the /named parameter/. Some people prefer
        the /named parameter/ version, some people prefer the _moved out_ version.

    - *INTELLIJ TIP*
      To convert one syntactic form to the other, you can use the actions:
      + "Move lambda expression out of parentheses"
      + "Move lambda expression into parentheses"

    - The type annotation of the parameter ~p~ in the /lambdas/ above can be
      omitted due to the type inference.

    - The default parameter name: ~it~ -- ~people.maxBy { it.age }~
      This name is generated
      + if the context expects a /lambda/ with _only one argument_,
        and
      + its type can be inferred.

    - However, if you store a /lambda/ in a variable, there's no context from
      which to infer the parameter types, so you have to specify them
      explicitly:
      #+BEGIN_SRC scala
        val getAge = { p: Person -> p.age }
        people.maxBy(getAge)
      #+END_SRC

    - Example (multiple-line body):
      #+BEGIN_SRC scala
        val sum = { x: Int, y: Int ->
           println("Computing the sum of $x and $y...")
           x + y
        }

        // >>>
        println(sum(1, 2))
        // Computing the sum of 1 and 2
        // 3
      #+END_SRC

*** DONE 5.1.4 Accessing variables in scope - 109
    CLOSED: [2018-05-29 Tue 17:06]
    - One _important difference_ between Kotlin and Java is that
      in Kotlin, you aren't restricted to accessing final variables -- you can
      also *modify* variables from _within_ a /lambda/.

    - *Capturing a mutable variable: implementation details*
      =TODO= =NOTE= =TODO=

    -  =TODO= =???= =TODO= =???= =?????????????????????????????????=
    - An important *CAVEAT*: =TODO= =???= =TODO= =???=
      if a /lambda/ is used as an /event handler/ or is otherwise /executed
      asynchronously/, the modifications to /local variables/ will _occur ONLY
      when the /lambda/ is *executed*._

      For example, the following code isn't a correct way to count button clicks:
      #+BEGIN_SRC scala
        fun tryToCountButtonClicks(button: Button): Int {
          var clicks = 0
          button.onClick { clicks++ }
          return clicks
        }
      #+END_SRC

      + This function will always return 0.

      + Even though the ~onClick~ handler will modify the value of clicks, you
        won't be able to observe the modification, because the ~onClick~ handler
        will be called after the function returns.

      + A correct implementation of the function would need to store the click
        count not in a local variable, but in a location that remains accessible
        outside of the function -- for example, in a property of a class.

*** DONE 5.1.5 Member references - 111 
    CLOSED: [2018-05-29 Tue 19:20]
    - Use the ~::~ operator for that:
      + Reference a /method/ or /field/:
        * ~val getAge = Person::age~

        * ~people.maxBy(Person::age)~

      + Reference the /top-level function/:
        * xxxx
          #+BEGIN_SRC scala
            fun salute() = println("Salute!")

            // >>>
            run(::salute)
            // Salute!
          #+END_SRC

        * ~val netAction = ::sendEmail~

      + Lazy creation of an object:
        Use a /constructor reference/ to store and postpone the action of creating
        an instance of a class.
        #+BEGIN_SRC scala
          data class Person(val name: String, val age: Int)

          val createPerson = ::Person
          println(p)
          // Person(name=Alice, age=29)
        #+END_SRC

      + Reference the /extension functions/ in the same way:
        #+BEGIN_SRC scala
          fun Person.isAdult() = age >= 21
          val predicate = Person::isAdult
        #+END_SRC

    - Bound references: =TODO= =NOTE=
      + In Kotlin 1.0, when you take a _reference to a method or property_ of a
        /class/, you ALWAYS need to provide an /instance/ of that /class/ when
        you call the reference.

      + Kotlin 1.1 plan:
        Support for /bound member references/, which allow you to use the
        /member-reference syntax/ to *capture* a /reference to the method/ *on a
        specific object instance*, is planned for Kotlin 1.1:
        #+BEGIN_SRC scala
          val p = Person("Dimitry", 34)
          val personsAgeFunction = Person::age
          println(personsAgeFunction(p))
          // 34

          val dmitrysAgeFunction = p::age
          println(dmitrysAgeFunction())
          // 34
        #+END_SRC
        Note that ~personsAgeFunction~ is a _ONE-ARGUMENT function_ (it returns
        the ~age~ of a _given ~person~)_, whereas ~dmitrysAgeFunction~ is a
        _ZERO-ARGUMENT function_ (it returns the ~age~ of a _specific ~person~)_.

        Before Kotlin 1.1, you needed to write the lambda ~{ p.age }~ explicitly
        instead of using the /bound member reference/ ~p::age~.

** TODO 5.2 Functional APIs for collections - 113
*** TODO 5.2.1 Essentials: ~filter~ and ~map~ - 113
*** TODO 5.2.2 ~all~, ~any~, ~count~, and ~find~: applying a predicate to a collection - 115
*** TODO 5.2.3 ~groupBy~: converting a list to a map of groups - 117
*** TODO 5.2.4 ~flatMap~ and ~flatten~: processing elements in nested collections - 117

** TODO 5.3 Lazy collection operations: sequences - 118
*** TODO 5.3.1 Executing sequence operations: intermediate and terminal operations - 120
*** TODO 5.3.2 Creating sequences - 122

** TODO 5.4 Using Java functional interfaces - 123
*** TODO 5.4.1 Passing a lambda as a parameter to a Java method - 124
*** TODO 5.4.2 SAM constructors: explicit conversion of lambdas to functional interfaces - 126

** TODO 5.5 Lambdas with receivers: ~with~ and ~apply~ - 128
*** TODO 5.5.1 The ~with~ function - 128
*** TODO 5.5.2 The ~apply~ function - 130

** TODO 5.6 Summary - 131

* TODO 6 The Kotlin type system - 133 -- =Reading=
  - This chapter covers
    + /Nullable types/ and SYNTAX for dealing with ~null~'s

    + /Primitive types/ and their _correspondence_ to the /Java types/

    + /Kotlin collections/ and their _relationship_ to Java

  - Compared to Java, /Kotlin's type system/ 
    + *introduces* several new features that are essential for improving the
      reliability of your code, such as support for /nullable types/ and
      /read-only collections/.

    + *removes* some of the features of the /Java type system/ that have
      turned out to be unnecessary or problematic, such as /first-class support
      for arrays/.

  =TOOD=
  Let's look at the details.

** TODO 6.1 Nullability - 133
   - EN:
     conceal  -  隱匿

   - The common guiding thoughts for modern languages, including Kotlin, is to
     _convert_ these problems from /runtime errors/ into /compile-time/ errors.

     However, they have different ways to deal with ~null~.

   - =TODO=
     We'll cover the details of *mixing* Kotlin and Java code with respect to
     /nullable types/.

*** DONE 6.1.1 Nullable types - 134
    CLOSED: [2018-05-30 Wed 10:39]
    - You can put a _question mark_ AFTER ANY /type/ to form /nullable types/.

    - For example, if you declare a function: ~fun strLen(s: String) = s.length~,
      you cannot pass a ~null~ to it, or else you will see a compiler error:
      =ERROR: Null can not be a value of a non-null type String=

    - If you think people may pass ~null~ as a parameter to a function ~strLen~,
      and you think this is reasonable in you practice, you define this function
      with a /nullable type/ parameter ~fun strLen(s: String?) = ...~

    - /Nullable types/ *force* you to do /null-check/.
      The compiler error of the definition ~fun strLenSafe(s: String?) = s.length()~
      is: 
      #+BEGIN_SRC text
        ERROR: only safe (?.) or non-null asserted (!!.) calls are allowed
         on a nullable receiver of type kotlin.String?
      #+END_SRC

    - You *CANNOT* assign it to a variable of a /non-null type/:
      #+BEGIN_SRC scala
        val x: String? = null
        val y: String = x
        // ERROR: Type mismatch: inferred type is String? but String was expected
      #+END_SRC

    - You *CANNOT* pass a value of a /nullable type/ as an argument to a function
      having a /non-null parameter/:
      #+BEGIN_SRC scala
        strLen(x)
        // ERROR: Type mismatch: inferred type is `String?` but `String` was expected
      #+END_SRC

    - The most important thing is to compare it with ~null~.
      The compiler can remember the result of comparisons.
      #+BEGIN_SRC scala
        fun strLenSafe(s: String?): Int =
          if (s != null) strLen(s) else 0
      #+END_SRC

    - =TODO=
      You don't want to always use ~if/else~ and comparisons to check the
      /nullable type/, which is cumbersome. The are more convenient way to do
      this. Explain later!

*** DONE 6.1.2 The meaning of types - 136
    CLOSED: [2018-05-30 Wed 10:51]
    - ...

    - *Other ways to cope with ~NullPointerException~ errors*
      In Java,
      + ~@Nullable~ and ~@NotNull~
        There are tools (for example, IntelliJ IDEA's built-in code inspections)
        that can use these /annotations/ to detect places where a
        ~NullPointerException~ can be thrown.

      + ~Optional~ introduced by Java 8.
        =From Jian= There are some bias from the author

        *NON-Biased Part*
        + =From Jian=
          Even if you have ~Optional~, you don't have /monad/, and the code can
          be verbose.

        + Even if you have ~Optional~ since Java 8, you still need to deal with
          ~null~ from other places -- this situation won't change utill Java
          deprecate ~null~ forever, and this definitely won't happen!

    - You know all type check happens in /compile time/, including the checks
      for /non-null types/ and /nullable types/. *NO* /runtime overhead/.

*** DONE 6.1.3 Safe call operator: ~?.~ - 137
    CLOSED: [2018-05-30 Wed 11:07]
    - The /safe-call operator/ ~?.~ helps you to combine _a ~null~ check_ and a
      _method call_ into a SINGLE OPERATION.

    - For example,
      ~s?.toUpperCase()~ is equivalent to ~if (s != null) s.toUpperCase() else null~

      *CAUTION*
      The /return type/ of ~s.toUpperCase()~ is ~String~, and
      the /return type/ of ~s?.toUpperCase()~ is ~String?~.

    - /Safe calls/ can be used for _accessing properties_ as well, NOT JUST for
      _method calls_.
      For example,
      #+BEGIN_SRC scala
        class Employee(val name: String, val manager: Employee?)

        fun managerName(employee: Employee): String? = employee.manager?.name

        val ceo = Employee("Da Boss", null)
        val developer = Employee("Bob Smith", ceo)
        println(managerName(developer))
        // Da Boss
        println(managerName(ceo))
        // null
      #+END_SRC

    - Sequences of calls with ~null~ checks are a common sight in Java code, and
      you've now seen how Kotlin makes them more concise.

*** DONE 6.1.4 Elvis operator: ~?:~ - 139
    CLOSED: [2018-05-30 Wed 11:20]
    The /elvis operator/ ~?:~ is used to provide a /default value/.

    - For example:
      ~fun foo(s: String?) { val t: String = s ?: "" }~

    - One reason that ~?:~ is particularly handy in Kotlin is that operations such
      as ~return~ and ~throw~ works as expressions and therefore can be used as the
      /default value/ part of ~?:~, which is very convenient to use ~?:~ for
      checking the preconditions.

    - ~with~ ?????????? =TODO=

*** DONE 6.1.5 Safe casts: ~as?~ - 140
    CLOSED: [2018-05-30 Wed 11:37]
    ~as?~ combine /a castable check/ and a /cast/.
    If the the /castable check/ fails, a ~null~ is the result.

    - One common pattern of using a /safe cast/ is combining it with the /Elvis
      operator/.

      For example, this comes in handy for implementing the ~equals~ /method/.
      #+BEGIN_SRC scala
        class Person(val firstName: String, val lastName: String) {

          override fun equals(o: Any?): Boolean {
            val otherPerson = o as? Person ?: return false
            return otherPerson.firstName == firstName &&
              otherPerson.lastName == lastName
          }

          override fun hashCode(): Int =
            firstName.hashCode() * 37 + lastName.hashCode()
        }

        val p1 = Person("Dmitry", "Jemerov")
        val p2 = Person("Dmitry", "Jemerov")
        println(p1 == p2)       // true
        println(p1.equals(42))  // false
      #+END_SRC

*** DONE 6.1.6 Not-null assertions: ~!!~ - 141 =???= =TODO= =RE-READ=
    CLOSED: [2018-05-30 Wed 11:49]
    Use ~!!~ to convert a /nullable value/ to a /non-~null~ value/ or throw a
    ~NullPointerException~

    - You can do something like:
      #+BEGIN_SRC scala
        fun ignoreNulls(s: String?) {
          val sNotNull: String = s!!
            println(sNotNull.length)
        }

        ignoreNulls(null)
        // Exception in thread "main" kotlin.KotlinNullPointerException
        //     at <...>.ignoreNulls(07_NotnullAssertions.kt:2)
      #+END_SRC
      + This is very interesting. Mostly you write something like this because
        you don't have a good solution for this problem.

      + But =TODO= =???=
        there are situations when /not-null assertions~ are the appropriate solution
        for a problem: when you check for ~null~ in one function and use the
        value in _another_ function, the compiler can't recognize that the use is safe.
        If you’re certain the check is always performed in another function, you
        may not want to duplicate it before using the value; then you can use a
        not- null assertion instead. =TODO= =???=

*** DONE 6.1.7 The ~let~ function - 143
    CLOSED: [2018-05-30 Wed 11:56]
    ~foo?.let lambda-expression~
    - For example,
      #+BEGIN_SRC scala
        val email: String? = ...
        if (email != null) sendEmailTo(email)
      #+END_SRC

      Can be written as ~emil?.let { sendEmailTo(it) }~

    - When you need to check multiple values for ~null~ , you can use _NESTED_
      ~let~ calls to handle them.

      *BUT* in most cases, such code ends up fairly verbose and hard to follow.
      It's generally easier to use a regular ~if~ expression to check all the
      values together.

*** TODO 6.1.8 Late-initialized properties - 145
*** TODO 6.1.9 Extensions for nullable types - 146
*** TODO 6.1.10 Nullability of type parameters - 148
*** TODO 6.1.11 Nullability and Java - 149

** DONE 6.2 Primitive and other basic types - 153
   CLOSED: [2018-05-30 Wed 13:36]
   - Unlike Java, Kotlin does _NOT differentiate_ /primitive types/ and /wrappers/.
*** DONE 6.2.1 Primitive types: ~Int~, ~Boolean~, and more - 153
    CLOSED: [2018-05-30 Wed 12:16]
    - At /runtime/, the /number types/ are represented in _the most efficient
      way possible_.

    - The full list of types that correspond to Java primitive types is:
      + Integer types: ~Byte~, ~Short~, ~Int~, ~Long~
      + Floating-point number types: ~Float~, ~Double~
      + Character type: ~Char~
      + Boolean type: ~Boolean~

    - Conversions:
      + /Kotlin types/ like ~Int~  ---->  /Java primitive type/

        Simple!
        Both cannot be the ~null~ reference.

      + /Java primitive type/  ---->  /Kotlin types/ like ~Int~

        Simple!
        /Java primitive types/ become non-~null~ types (not platform types) in Kotlin

*** DONE 6.2.2 Nullable primitive types: ~Int?~, ~Boolean?~, and more - 154
    CLOSED: [2018-05-30 Wed 12:25]
    - Kotlin /nullable types values/ will be compiled to the corresponding /Java
      wrapper types/.

    - As mentioned earlier, /generic classes/ are another case when /Java wrapper
      types/ come into play.

      If you use a /primitive type/ as a /type argument/ of a /class/, Kotlin
      uses the boxed representation of the /type/.

      For example, this creates a list of boxed ~Integer~ values, even though
      you've NEVER specified a /nullable type/ or used a ~null~ value:
      ~val listOfInts = listOf(1, 2, 3)~

    - As a consequence, if you need to _efficiently store large collections of
      primitive types_, you need to
      + either use a third-party library (such as Trove4J,
        http://trove.starlight-systems.com) that provides support for such
        collections
        =From Jian= HOW???
        or
      + store them in /arrays/.

*** DONE 6.2.3 Number conversions - 155
    CLOSED: [2018-05-30 Wed 12:41]
    - Kotlin doesn't automatically convert numbers from one type to the other
      required compatible type. Since there is NOT /implicit conversions/ as in
      Scala, *all types conversions must explicit*!!!
      #+BEGIN_SRC scala
        val i = 1
        val l: Long = i  // Error: type mismatch
        val j: Long = i.toLong()
      #+END_SRC

    - /Conversion functions/ are defined for every /primitive type/ (except
      ~Boolean~).

    - *Primitive type literals*
      + For /primitive types/, use /suffix type indicator letters/!

      + For Hexadecimal literals, use the ~0x~ or ~0X~

      + For Binary literals, use the ~0b~ or ~0B~

      + You can insert underscores to numbers to improve the readability (Fron
        Kotlin 1.1 on!)

    - Pass /primitive types literal values/ to a function, and the compiler can
      help the function picking the most proper type even without the /suffix
      type indicator letters/:
      #+BEGIN_SRC scala
        fun foo(l: Long) = println(l)

        val b: Byte = 1
        val l = b + 1L
        foo(42)
      #+END_SRC
      There is no explicit conversion, and they are legal code!

    - LIKE Java, Kotlin doesn't introduce any overhead for /overflow checks/!
      The programmer must pay attention to the overflow possibility in some
      calculation!!!

    - *Conversion from String*
      Also use the ~toNumberType~ pattern methods, such as ~toInt~, ~toByte~,
      defined in the Kotlin standard library.

*** DONE 6.2.4 ~Any~ and ~Any?~: the root types - 157
    CLOSED: [2018-05-30 Wed 13:36]
    - In Kotlin, ~Any~ is a /supertype/ of *ALL* /types/.

    - *CAUTION*
      ~Any~ is a /non-~null~ type/,
      The type can hold any value possible value in Kotlin is ~Any?~.

    - ALL Kotlin /classes/ have the following _three_ /methods/ _inherited_ from
      ~Any~ :
      + ~toString~
      + ~equals~
      + ~hashCode~

    - Besides the three /methods/ metioned above, other /methods/ defined on
      ~java.lang.Object~ (such as ~wait~ and ~notify~) aren't available on ~Any~,
      but you can call them if you MANUALLY /cast/ the value to ~java.lang.Object~.

      =From Jian= I don't quite understand why design like this???
      =From Jian= How does Scala???

*** DONE 6.2.5 The ~Unit~ type: Kotlin's ~void~ - 157
    CLOSED: [2018-05-30 Wed 13:30]
    - In most cases, you won't notice the difference between Java's ~void~ and
      Kotlin's ~Unit~.

    - Q :: What _distinguishes_ Kotlin's ~Unit~ from Java's ~void~, then?

    - A :: ~Unit~ is a full-fledged /type/, and, _UNLIKE_ ~void~, it can be used
           as a /type argument/.

           ONLY ONE value of ~Unit~ type exists;
           it’s also called ~Unit~ and is _returned implicitly_.

           =From Jian= When do we need to do such a nasty thing??? Override a
           generic function (mostly no side effect) with a function with
           side-effect only.

           This is useful when you override a function that returns a /generic
           parameter/ and make it return a value of the ~Unit~ type:

           For example,
           #+BEGIN_SRC scala
             interface Processor<T> {
               fun process(): T
             }

             class NoResultProcessor : Processor<Unit> {
               override fun process() {
                 // do stuff

                 // You don’t need an explicit `return` here!
               }
             }
           #+END_SRC

    - In Java if you want do something like in the above example, you have _two_
      methods:
      + Use a separate interface (such as ~Callable~ and ~Runnable~).

      + Use the ~java.lang.Void~ type, and you must write down ~return null;~
        explicitly.

*** DONE 6.2.6 The ~Nothing~ type: "This function never returns" - 158
    CLOSED: [2018-05-30 Wed 13:18]
    - For some functions in Kotlin, the concept of a /return value/ doesn't make
      sense because _they never complete successfully_.

      For example,
      + In many testing libraries, there is a ~fail~ function, it
        (=From Jian= ALWAYS???)fails the current test by throwing an exception
        with a special message.

      + A function that has an infinite loop which will never complete
        successfully.

    - The ~Nothing~ type does NOT have ANY values, so it only makes sense to
      + use it as a function /return type/

      + use it as a /type argument/ for a /type parameter/ that's used as a
        /generic function/ /return type/.

    - Functions returning ~Nothing~ can be used on the _right side_ of the /Elvis
      operator/ to perform /precondition checking/:
      #+BEGIN_SRC scala
        val address = company.address ?: fail("No address")
        println(address.city)
      #+END_SRC

    - ~Nothing~ is very useful! =IMPORTANT=
      The compiler knows that a function with this /return type/ *never terminates
      normally* and uses that information when _analyzing_ the code calling the
      function.

      For example,
      In the previous example, the compiler infers that the type of ~address~ is
      non-~null~, because the branch handling the case when it's ~null~ always
      throws an exception.

** TODO 6.3 Collections and arrays - 159
*** TODO 6.3.1 Nullability and collections - 159
*** TODO 6.3.2 Read-only and mutable collections - 161
*** TODO 6.3.3 Kotlin collections and Java - 163
*** TODO 6.3.4 Collections as platform types - 165
*** TODO 6.3.5 Arrays of objects and primitive types - 167

** DONE 6.4 Summary - 170
   CLOSED: [2018-05-30 Wed 12:49]
   - Kotlin's support of /nullable types/ that detects possible ~NullPointerException~
     errors at /compile time/.

   - Kotlin provides tools such as /safe calls/ (~?.~), the /Elvis operator/ (~?:~),
     /not-null assertions/ (~!!~), and the ~let~ function for _dealing with_
     /nullable types/ concisely.

   - The ~as?~ operator provides an easy way to /cast/ a value to a /type/ and it
     also handle the case when it has a incompatible /type/.

   - Types coming from Java are interpreted as /platform types/ in Kotlin,
     allowing the developer to treat them as either /nullable/ or non-~null~.

   - Types representing basic numbers (such as Int ) look and function like
     regular classes but are usually compiled to Java primitive types.

   - Nullable primitive types (such as Int? ) correspond to boxed primitive types
     in Java (such as java.lang.Integer ).

   - The ~Any~ type is a /supertype/ of all other types and is analogous to Java's
     ~Object~.

     ~Unit~ is an analogue of Java's ~void~ .

   - The ~Nothing~ type is used as a /return type/ of functions that *don't
     terminate normally*.
     =TODO=

   - Kotlin uses the standard Java classes for /collections/ and
     enhances them with a _DISTINCTION_ between _read-only and mutable
     collections_.

   - You need to carefully consider /nullability/ and /mutability/ of parameters
     WHEN you *extend* /Java classes/ or *implement* /Java interfaces/ in Kotlin.
     =TODO=

   - Kotlin's ~Array~ class looks like a regular /generic class/,
     but it's compiled to a /Java array/.

   - _Arrays of primitive types_ are represented by special classes such as
     ~IntArray~.

* PART 2 EMBRACING KOTLIN - 171
* TODO 7 Operator overloading and other conventions - 173
** TODO 7.1 Overloading arithmetic operators - 173
*** Overloading binary arithmetic operations - 174
*** Overloading compound assignment operators - 177
*** Overloading unary operators - 178

** TODO 7.2 Overloading comparison operators - - 180
*** Equality operators: ~equals~ - 180
*** Ordering operators: ~compareTo~ - 181

** TODO 7.3 Conventions used for collections and ranges - 182
*** Accessing elements by index: ~get~ and ~set~ - 182
*** The ~in~ convention - 184
*** The ~rangeTo~ convention - 185
*** The ~iterator~ convention for the ~for~ loop - 186

** TODO 7.4 Destructuring declarations and component functions - 187
*** Destructuring declarations and loops - 188

** TODO 7.5 Reusing property accessor logic: delegated properties - 189
*** Delegated properties: the basics - 189
*** Using delegated properties: lazy initialization and “by lazy()” - 190
*** Implementing delegated properties - 192
*** Delegated-property translation rules - 195
*** Storing property values in a map - 196
*** Delegated properties in frameworks - 197

** TODO 7.6 Summary - 199

* TODO 8 Higher-order functions: lambdas as parameters and return values - 200
** TODO 8.1 Declaring higher-order functions - 201
*** Function types - 201
*** Calling functions passed as arguments - 202
*** Using function types from Java - 204
*** Default and null values for parameters with function types Returning functions from functions - 207
*** Removing duplication through lambdas - 209

** TODO 8.2 Inline functions: removing the overhead of lambdas - 211
*** How inlining works - 211
*** Restrictions on inline functions - 213
*** Inlining collection operations - 214
*** Deciding when to declare functions as inline - 215
*** Using inlined lambdas for resource management - 216  

** TODO 8.3 Control flow in higher-order functions - 217
*** Return statements in lambdas: return from an enclosing function - 217
*** Returning from lambdas: return with a label - 218
*** Anonymous functions: local returns by default - 220

** TODO 8.4 Summary 221

* TODO 9 Generics - 223
** TODO 9.1 Generic type parameters - 224
*** Generic functions and properties - 224
*** Declaring generic classes - 226
*** Type parameter constraints - 227
*** Making type parameters non-null - 229

** TODO 9.2 Generics at runtime: erased and reified type parameters - 230
*** Generics at runtime: type checks and casts - 230
*** Declaring functions with reified type parameters - 233
*** Replacing class references with reified type parameters - 235
*** Restrictions on reified type parameters - 236

** TODO 9.3 Variance: generics and subtyping - 237
*** Why variance exists: passing an argument to a function - 237
*** Classes, types, and subtypes - 238
*** Covariance: preserved subtyping relation - 240
*** Contravariance: reversed subtyping relation - 244
*** Use-site variance: specifying variance for type occurrences - 246
*** Star projection: using ~*~ instead of a type argument - 248

** TODO 9.4 Summary 252

* TODO 10 Annotations and reflection - 254
** TODO 10.1 Declaring and applying annotations - 255
*** Applying annotations - 255
*** Annotation targets - 256
*** Using annotations to customize JSON serialization - 258
*** Declaring annotations - 260
*** Meta-annotations: controlling how an annotation is processed - 261
*** Classes as annotation parameters - 262
*** Generic classes as annotation parameters - 263

** TODO 10.2 Reflection: introspecting Kotlin objects at runtime - 264
*** The Kotlin reflection API: KClass, KCallable, KFunction, and KProperty - 265
*** Implementing object serialization using reflection - 268
*** Customizing serialization with annotations - 270
*** JSON parsing and object deserialization - 273
*** Final deserialization step: ~callBy()~ and creating objects using reflection - 277

** TODO 10.3 Summary - 281 

* TODO 11 DSL construction - 282
** TODO 11.1 From APIs to DSLs - 283
*** The concept of domain-specific languages - 284
*** Internal DSLs - 285
*** Structure of DSLs - 286
*** Building HTML with an internal DSL - 287

** TODO 11.2 Building structured APIs: lambdas with receivers in DSLs - 288
*** Lambdas with receivers and extension function types - 288
*** Using lambdas with receivers in HTML builders - 292
*** Kotlin builders: enabling abstraction and reuse - 296

** TODO 11.3 More flexible block nesting with the ~invoke~ convention - 299
*** The ~invoke~ convention: objects callable as functions - 299
*** The ~invoke~ convention and functional types - 300
*** The ~invoke~ convention in DSLs: declaring dependencies in Gradle - 301

** TODO 11.4 Kotlin DSLs in practice - 303
*** Chaining infix calls: ~should~ in test frameworks - 303
*** Defining extensions on primitive types: handling dates - 305
*** Member extension functions: internal DSL for SQL - 306
*** Anko: creating Android UIs dynamically - 309

** TODO 11.5 Summary - 310

* TODO appendix A Building Kotlin projects - 313
** A.1 Building Kotlin code with Gradle - 313
*** A.1.1 Building Kotlin Android applications with Gradle - 314
*** A.1.2 Building projects that use annotation processing - 314

** A.2 Building Kotlin projects with Maven - 315
** A.3 Building Kotlin code with Ant - 315

* TODO appendix B Documenting Kotlin code - 317
** B.1 Writing Kotlin documentation comments - 317
** B.2 Generating API documentation - 319

* TODO appendix C The Kotlin ecosystem - 320
** C.1 Testing - 320
** C.2 Dependency injection - 321
** C.3 JSON serialization - 321
** C.4 HTTP clients - 321
** C.5 Web applications - 321
** C.6 Database access - 322
** C.7 Utilities and data structures - 322
** C.8 Desktop programming - 322

* index - 323


