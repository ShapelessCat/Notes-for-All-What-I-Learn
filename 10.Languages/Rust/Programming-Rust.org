#+TITLE: Programming Rust
#+SUBTITLE: FAST, SAFE SYSTEMS DEVELOPMENT
#+VERSION: 2017, 1st
#+AUTHOR: Jim Blandy and Jason Orendorff
#+STARTUP: overview
#+STARTUP: entitiespretty

* 1. Why Rust? - 1
  - Enter Rust:
    a *safe* (memory safety), *concurrent* (trustworthy concurrency) language
    with the *performance* of C and C++.

  - Rust shares the ambitions Bjarne Stroustrup articulates for C++ in his paper
    "Abstraction and the C++ Machine Model:"
    #+BEGIN_QUOTE
    In general, C++ implementations obey the *zero-overhead principle*:
    What you don't use, you don't pay for.

    And further: What you do use, you couldn't hand code any better.
    #+END_QUOTE

  - The key to meeting all these promises is Rust's novel system of /ownership/,
    /moves/, and /borrows/, checked at /compile time/ and carefully designed to
    complement Rust's flexible static type system.

  - Rust is able to prevent /data races/ at /compile time/.

  - In fact, Servo and Rust have grown up together, with Servo using the latest
    new language features, and Rust evolving based on feedback from Servo's
    developers.

** DONE Type Safety - 3
   CLOSED: [2018-05-19 Sat 14:21]
   =TODO= =NOTE=

* TODO 2. A Tour of Rust - 7 -- =Reading=
  - In this chapter we'll look at several short programs to see _HOW_ Rust's
    + syntax
    + types
    + semantics

    fit together to support

    + safe
    + concurrent
    + efficient

    code.

** DONE Downloading and installing Rust - 7
   CLOSED: [2018-05-31 Thu 14:13]
   - The recommend way is to use the tool *rustup*.
     It's a tool for _managing Rust installations_, like RVM for Ruby or NVM for
     Node.

   - Once you finish the installation, you have *three* new commands:
     + *cargo* :: The Rust's tool as
       * _compilation manager_
       * _package manager_
       * _general-purpose_

       You can use it to
       + _start a new project_
       + _build_ and _run_ your program,
       + _manage any external libraries_ your code depends on.

     + *rustc* :: Rust's compiler.
                  Usually we let _Cargo_ invoke the compiler for us.

     + *rustdoc* :: Rust documentation tool.
                    Like *rustc*, we usually let _Cargo_ run *rustdoc* for us.

   - Example:
     ~cargo new --bin hello~
     Create a new package directory named =hello=, and the =--bin= flag directs
     Cargo to prepare this as an /executable/, not a /library/.

     + Inside the =hello= directory is by default initalized as a /git repository/
       (with a =.gitignore= file), you have =Cargo.toml= and the =src= folder.

     + You can record the /dependencies/ of your package in the =Cargo.toml= file,
       and Cargo will take care of downloading, building, and updating those
       libraries for us.
       =TODO= Cover the =Cargo.toml= file in detail in Chapter 8.

   - ~cargo --vcs none [other flags and their values]~
     Tell Cargo to skip the step of initalized your package as a git
     repository.

   - ~cargo run~
     _build_ and _run_ your program.

   - Cargo places the executable in the =target= subdirectory at the top of the
     package.
       You can check the =target/debug= directory, and the executable is inside
     named as =hello=.

   - ~cargo clean~
     clean up the generated files

** DONE A Simple Function - 10
   CLOSED: [2018-05-31 Thu 15:06]
   - Example (Euclid's algorithm):
     #+BEGIN_SRC rust
       fn gcd(mut n: u64, mut m: u64) -> u64 {
           assert!(n != 0 && m != 0);

           while m != 0 {
               if m < n {
                   let t = m;
                   m = n;
                   n = t;
               }
               m = m % n;
           }
           n
       }
     #+END_SRC

   - =From Jian=
     I don't like the usage of ~assert!~ in the above example code!
     If should use something like ~require!~, which is a better word for
     precondition check!

   - UNLIKE C/C++, Rust's ~assert!~ CANNOT be skipped in all cases!

     There is a ~debug_assert!~ macro do the similar thing, but it can be
     skipped when the program is compiled for speed.

** DONE Writing and Running Unit Tests - 11
   CLOSED: [2018-05-31 Thu 15:51]
   - Example:
     #+BEGIN_SRC rust
       #[test]
       fn test_gcd() {
           assert_eq!(gcd(14, 15), 1);
           assert_eq!(gcd(2 * 3 * 5 * 11 * 17,
                          3 * 7 * 11 * 13 * 19),
                      3 * 11);
       }
     #+END_SRC

   - The ~#[test]~ atop the definition marks ~test_gcd~ as a test function, to be
     _skipped in normal compilations_,
     but included and called automatically if we run our program with the ~cargo
     test~ command.

   - The /tests/ can be scatter in throughout our source tree.

   - The ~#[test]~ is an example of an /attribute/.

   - /Attributes/ are an open-ended system for *marking* functions and other
     declarations with _extra information_, like /attributes/ in C++ and C#, or
     /annotations/ in Java.

     They're used to control
     + compiler warnings
     + code style checks
     + include code conditionally (like ~#ifdef~ in C and C++)
     + tell Rust how to interact with code written in other languages, and so on.

     We'll see more examples of /attributes/ as we go.

** DONE Handling Command-Line Arguments - 12
   CLOSED: [2018-05-31 Thu 16:42]
   Example:
   #+BEGIN_SRC rust
     use std::io::Write;
     use std::str::FromStr;
     fn main() {
         let mut numbers = Vec::new();

         for arg in std::env::args().skip(1) {
             numbers.push(u64::from_str(&arg)
                          .expect("error parsing argument"));
         }

         if numbers.len() == 0 {
             writeln!(std::io::stderr(), "Usage: gcd NUMBER ...").unwrap();
             std::process::exit(1);
         }

         let mut d = numbers[0];
         for m in &numbers[1..] {
             d = gcd(d, *m);
         }

         println!("The greatest common divisor of {:?} is {}",
                  numbers, d);
     }
   #+END_SRC

   Let's take it piece by piece:
   - The ~use~ lines:
     The ~use~ /declarations/ bring the two /traits/ ~Write~ and ~FromStr~ into scope.

     + =TODO= We'll cover ~traits~ in detail in Chapter 11, but for now we'll
       simply say that a /trait/ is a collection of /methods/ that /types/ can
       implement.

     + Although we never use the names ~Write~ or ~FromStr~ elsewhere in the program,
       a /trait/ _MUST be in scope_ in order to use its /methods/.

       In the present case:
       * Any type that implements the ~Write~ /trait/ has a ~write_fmt~ /method/ that
         *writes* _formatted text_ to a /stream/.

         The ~std::io::Stderr~ type implements ~Write~, and we'll use the
         ~writeln!~ /macro/ to print error messages; that /macro/ expands to
         code that uses the ~write_fmt~ /method/.

       * Any type that implements the ~FromStr~ /trait/ has a ~from_str~ /method/
         that tries to *parse* a value of that type from a string. The ~u64~ type
         implements ~FromStr~, and we'll call ~u64::from_str~ to parse our
         command-line arguments.

   - ~let mut numbers = Vec::new();~
     Even though /vectors/ are designed to be grown and shrunk dynamically, we must
     still mark the variable ~mut~ for Rust to let us push numbers onto the end
     of it.

     =IMPORTANT= =???=
     =From Jian= ~mut~ here is used to manage the _content_ of the vector
     ~numbers~, rather the the reference saved in ~numbers~!
     *This is different from most of the other languages!*

   - The ~for arg in std::env::args().skip(1)~ block: 
     + The ~std::env::args()~ returns an /iterator/.

       * =En=:
         ubiquitous

       * Rust's /iterators/ are very _EFFICIENT_:
         the compiler is usually able to *translate* them into the same code as
         a handwritten loop.
         =TODO= HOW in Chapter 15

     + The ~numbers.push(u64::from_str(&arg).expect("error parsing argument"));~ line:
       * The ~from_str~ function does NOT return a ~u64~ directly, but rather a
         ~Result~ value that indicates whether the parse succeeded or failed.
         - A ~Result~ value can be one of two variants:
           + ~Ok(v)~

           + ~Err(e)~

         - UNLIKE most modern languages, Rust does NOT have /exceptions/:
           all /errors/ are handled using either ~Result~ or /panic/, as
           outlined in Chapter 7. =TODO=

         - Check the success of our parse by using ~Result~'s ~expect~ /method/.
           + If the result is some ~Err(e)~, ~expect~
             1. _prints_ a message that includes a description of ~e~
             2. _exits the program immediately_.
           + If the result is ~Ok(v)~, ~expect~ simply returns ~v~ itself.

   - The ~if numbers.len() == 0~ block:
     + The ~.unwrap()~ call is a terse way to _check_ that the attempt to print
       the error message _did not itself fail_; an ~expect~ call would work too,
       but that's probably not worth it.

     + Simple introduction to the /ownership/ and /borrow/ ...

   - _UNLIKE_ C and C++, which require ~main~ to
     + return zero if the program finished successfully
       or

     + a /nonzero exit status/ if something went wrong,

     Rust assumes that if ~main~ returns at all, the program finished
     successfully. _ONLY_ by *EXPLICITLY calling* functions like ~expect~ or
     ~std::process::exit~ can we cause the program to terminate with an /error
     status code/.

   - Check the standard library documentation in your browser with the command
     ~rustup doc --std~

** DONE A Simple Web Server - 17 =TODO= =NOTE=
   CLOSED: [2018-06-01 Fri 21:08]
   - crate :: A Rust package, whether a library or an executable.

   - To show how this works, we'll put together a *simple web server* using the
     /iron web framework/, the hyper HTTP server, and various other /crates/ on
     which they depend.

     + As shown in Figure 2-1, our website will prompt the user for two numbers,
       and compute their greatest common divisor.

   - =Cargo.toml=
     #+BEGIN_SRC toml
       [package]
       name = "iron-gcd"
       version = "0.1.0"
       authors = ["You <you@example.com>"]

       [dependencies]
       iron = "0.5.1"
       mime = "0.2.3"
       router = "0.5.1"
       urlencoded = "0.5.0"
     #+END_SRC

   - The basic version (incomplete!):
     #+BEGIN_SRC rust
       extern crate iron;
       #[macro_use] extern crate mime;

       use iron::prelude::*;
       use iron::status;

       fn main() {
           println!("Serving on http://localhost:3000...");
           Iron::new(get_form).http("localhost:3000").unwrap();
       }

       fn get_form(_request: &mut Request) -> IronResult<Response> {
           let mut response = Response::new();

           response.set_mut(status::Ok);
           response.set_mut(mime!(Text/Html; Charset=Utf8));
           response.set_mut(r#"
               <title>GCD Calculator</title>
               <form action="/gcd" method="post">
                 <input type="text" name="n"/>
                 <input type="text" name="n"/>
                 <button type="submit">Compute GCD</button>
               </form>
           "#);

           Ok(response)
       }
     #+END_SRC
     + The ~#[macro_use]~ /attribute/ alters Rust that we plan to use /macros/
       *exported* by this /crate/.

     + Use ~*~ to import all the public names of a /module/ is often NOT a good
       idea, but for a module named ~prelude~, which by convention provides
       general facilities that any user of the /crate/ will probably need. In
       this case, a wildcard ~use~ directive makes a bit more sense.

     + =TODO= NOTES =TODO=

   - =TODO= NOTES =TODO=
   - =TODO= NOTES =TODO=
   - =TODO= NOTES =TODO=

** TODO Concurrency - 23
*** TODO What the Mandelbrot Set Actually Is - 24
*** TODO Parsing Pair Command-Line Arguments - 28
*** TODO Mapping from Pixels to Complex Numbers - 31
*** TODO Plotting the Set - 32
*** TODO Writing Image Files - 34
*** TODO A Concurrent Mandelbrot Program - 35
*** TODO Running the Mandelbrot Plotter - 40
*** TODO Safety Is Invisible - 41

* TODO 3. Basic types - 43 - =READING=
  - Rust's types serve several goals:
    * Safety

    * Efficiency:
        Programmers have fine-grained control over how Rust programs represent
      values in memory, and can choose /types/ they know the processor will
      handle efficiently.
      *Programs needn't pay for generality or flexibility they don't use.*

    * Concision:
      With type inference, programmers don't need to manually written out most
      types, which make Rust code usually much less cluterred with types than
      the analogous C++ program would be.
      
  - /Types/ can help Rust compiler to choose _GOOD machine-level_ /representations/
    for values your program operate on:
    /representations/ whose _performance_ you *can predict*, and which give you
    full access to the machine's capabilities.

  - Rust has two features to facilitate your program:
    * /type inference/
    * /generics/

  - Here's a summary of the sorts of /types/ you'll see in Rust.
    This table shows Rust's /primitive types/, some /VERY common types/ from the
    standard library, and some examples of /user-defined types/:
    * Signed and unsigned integers,
      of explicitly given bit width
      + Types: ~i8~, ~i16~, ~i32~, ~i64~, ~u8~, ~u16~, ~u32~, ~u64~
      + Values: ~42~, ~-5i8~, ~0x400u16~, ~0o100i16~, ~20_922_789_888_000u64~,
                ~b'*'~ (~u8~ byte literal)

    * Signed and unsigned integers,
      the same size as an address on the machine (32 or 64 bits)
      + Types: ~isize~, ~usize~
      + Values: ~137~, ~-0b0101_0010isize~, ~0xffff_fc00usize~

    * IEEE floating-point numbers
      + Types: ~f32~ (single precision), ~f64~ (double precision)
      + Values: ~1.61803~, ~3.14f32~, ~6.0221e23f64~

    * Boolean
      + Types: ~bool~
      + Values: ~true~, ~false~

    * Unicode character, 32 bits wide
      + Types: ~char~
      + Values: ~'*'~, ~'\n'~, ~'字'~, ~'\x7f'~, ~'\u{CA0}'~

    * Tuple
      + Example type: ~(char, u8, i32)~
      + Example type value: ~('%', 0x7f, -1)~

    * "unit" (empty) tuple
      + Type: ~()~
      + Singleton value: ~()~

    * Named-field struct
      + Example type: ~struct S { x: f32, y: f32 }~
      + Example type value: ~S { x: 120.0, y: 209.0 }~

    * Tuple-like struct
      + Example type: ~struct T(i32, char);~
      + Example type value: ~T(120, 'X')~

    * Unit-like struct; has no fields
      + Example type: ~struct E;~
      + Example type value: ~E~

    * Enumeration, algebraic data type
      + Example type: ~enum Attend { OnTime, Late(u32) }~
      + Example type value: ~Attend::Late(5)~, ~Attend::OnTime~

    * ~Box~: owning pointer to value in heap
      + Example type: ~Box<Attend>~
      + Example type value: ~Box::new(Late(15))~

    * /Shared and mutable references/
      nonowning pointers that must not outlive their referent
      + Example type: ~&i32~, ~&mut i32~
      + Example type value: ~&s.y~, ~&mut v~

    * /UTF-8 string/, _DYNAMICALLY SIZED_
      + Type: ~String~
      + Values: ~"ラーメン: ramen".to_string()~

    * Reference to ~str~: *nonowning* /pointer/ to UTF-8 text
      + Type: ~&str~
      + Values: ~"そば: soba"~, ~&s[0..12]~

    * Array
      + Example types: ~[f64; 4]~, ~[u8; 256]~
      + Example type values: ~[1.0, 0.0, 0.0, 1.0]~, ~[b' '; 256]~

    * Vector, varying length; elements all of same type
      + Example type: ~Vec<f64>~
      + Example type values: ~vec![0.367, 2.718, 7.389]~

    * Reference to slice: reference to a portion of an array or vector, comprising
      pointer and length
      + Types: ~&[u8]~, ~&mut [u8]~
      + Values: ~&v[10..20]~, ~&mut a[..]~

    * Trait object: reference to any value that implements a given set of methods
      + ~&Any~, ~&mut Read~
      + value as ~&Any~,  ~&mut file~ as ~&mut Read~

    * Pointer to function
      + ~fn(&str, usize) -> isize~
      + ~i32::saturating_add~

    * Closure
      + (Closure types have no written form)
      + ~\vert{}a, b\vert{} a*a + b*b~

  - Most of these /types/ are convered in this chapter, except for the following:
    * /struct types/, _Chapter 9_.

    * /enumerated types/, _Chapter 10_.

    * /trait objects/, _Chapter 11_.

    * We describe the essentials of ~String~ and ~&str~ here,
      but provide more detail in _Chapter 17_.

    * /function and closure types/, _Chapter 14_.

** DONE Machine Types - 46
   CLOSED: [2021-01-11 Mon 21:56]
   - The footing of Rust's type system is
     * a collection of /fixed-width numeric types/,
       chosen to match the types that almost all modern processors implement
       directly in hardware, and

     * the ~Boolean~ and /character types/.

   - Sizes and representations:
     |  Size (bits) | Unsigned integer | Signed integer | Floating-point |
     |--------------+------------------+----------------+----------------|
     |            8 | ~u8~             | ~i8~           |                |
     |           16 | ~u16~            | ~i16~          |                |
     |           32 | ~u32~            | ~i32~          | ~f32~          |
     |           64 | ~u64~            | ~i64~          | ~f64~          |
     | Machine word | ~usize~          | ~isize~        |                |

     * =from Jian=
       ~u128~ and ~i128~ are added in the current Rust version (Rust 2018???).

   - Machine Word :: a value _the size of an address_ on the machine the code
                     runs on, _usually_ 32 bits or 64 bits, which depends on
                     the concrete target machine.

*** DONE Integer Types - 47
    CLOSED: [2021-01-11 Mon 11:23]
    - *UNLIKE* C and C++,
      Rust treats /characters/ as _distinct_ from the /numeric types/.
      =TODO= Read "Characters" on Page 52.

    - ~usize~ are analogous to ~size_t~ in C/C++.

    - ~isize~ are analogous to ~ptrdiff_t~ in C/C++.

    - Rust requires /array indices/ to be ~usize~.

    - Values representing
      * the _sizes_ of /arrays/ or /vectors/

      * the _counts of the number of elements_ in some data structure

      also generally have the ~usize~ type.

    - In /debug build/, Rust compiler checks for /integer overflow/ in arithmetic:
      #+BEGIN_SRC rust
        let big_val = std::i32::MAX;
        let x = big_val + 1;  // panic: arithmetic operation overflowed
      #+END_SRC

    - In /release build/, this addition would wrap to a NEGATIVE number
      (*UNLIKE* C++, where /signed integer overflow/ is /undefined behavior/).

      However, it is still a bad to do this operation if you don't want to give
      up forever.

      * Solution:
        Explicitly tell the compiler that you really know what you do!
        ~let x = big_val.wrapping_add(1);  // ok~

    - /Integer literals/ in Rust can take suffix indicating their type.
      For instance, ~42u8~ and ~1729isize~

    - /Inference/ usually identifies a unique type,
      BUT sometimes any one of several types would work.
      In this case, Rust defaults to ~i32~, if that is among the possibilities.
      Otherwise, report the ambiguity as an error!

    - The radix prefixes of /Integer literals/: ~0x~, ~0o~, and ~0b~.
      * =from Jian=
        Rust is the only language I know that uses ~0o~.
        I LIKE IT!!!

    - You can insert _underscore_ to make long numbers more legible.
      For instance, ~4_294_967_295~.
        The positions of the _underscore_ is *FLEXIBLE* -- it's designed for
      human, NOT for the compiler! For instance, ~0xfff_ffff~, or ~127_u8~.

    - /Byte literals/
      Only ASCII characters may appear in /byte literals/.
      For example, ~b'a'~
      * Also, pay attention to the /escape sequences/ -- there are a few
        characters that you cannot simply place after the single quote,
        because that would be either syntactically ambiguous or hard to read.
        | Character       | Byte literal | Numeric equivalent |
        |-----------------+--------------+--------------------|
        | Single quote, ' | ~b'\''~      | 39u8               |
        | Backslash, \    | ~b'\\'~      | 92u8               |
        | Newline         | ~b'\n'~      | 10u8               |
        | Carriage return | ~b'\r'~      | 13u8               |
        | Tab             | ~b'\t'~      | 9u8                |

      * For characters that are hard to write or read, you can write their code
        in hexadecimal instead, in the form of ~b'\xHH'~, where HH is ANY
        two-digit hexadecimal number, represents the byte whose value is HH.

      * Since /byte literals/ are just another notation for ~u8~ values, consider
        whether a SIMPLE /numeric literal/ might be more legible:
        it probably makes sense to use ~b'\x1b'~ instead of simply ~27~
        _ONLY when you want to EMPHASIZE that the value represents an ASCII code._

    - Convert from one integer type to another integer type with the ~as~
      operator. For instance, ~10_i8 as u16~

      * Note:
        the documentation contains *SEPARATE pages* for the /type/ ITSELF
        + for _“i32 (primitive type)”_,
        + and for the /module/ dedicated to that /type/, _“std::i32”_.

    - *CAUTION* =IMPORTANT= =IMPORTANT= =IMPORTANT= =IMPORTANT= =IMPORTANT= =IMPORTANT=
      that /method calls/ have a /higher precedence/ than /unary prefix operators/.
      * =from Jian=
        This is often generate unexpected result:
        ~-4i32.abs()~ will be ~-4~, rather than ~4~.

*** DONE Floating-Point Types - 50
    CLOSED: [2021-01-11 Mon 14:40]
    - Rust provides
      * IEEE single-precision floating type ~f32~:
        + at least *6* decimal digits
        + Roughly -3.4 \times{} 10^{38} to +3.4 \times{} 10^{38}

      * IEEE double-precision floating type ~f64~:
        + at least *15* decimal digits
        + Roughly -1.8 \times{} 10^{308} to +1.8 \times{} 10^{308}

    - Following the IEEE 754-2008 specification,
      these types include
      + _positive and negative *infinities*,_
      + *distinct* _positive and negative *zero values*,_
      + a *not-a-number value*

    - Rust's ~f32~ and ~f64~ correspond to
      * the ~float~ and ~double~ types in C and C++ implementations that _support_
        IEEE floating point;

      * Java, which _always_ uses IEEE floating point.

    - Example for the /floating-point literals/:
      ~31415.926e-4f64~
      * integer part: 31415
      * fractional part: .926
      * exponent: e-4
      * type suffix: f64

    - Every part of a /floating-point number/ after the _integer part_ is OPTIONAL,
      but *at least one of* the _fractional part_, _exponent_, or _type suffix_
      *must* be present, to _distinguish_ it from an /integer literal/.

      * ~5.~ is a valid floating-point constant.

      * The default type is ~f64~, if both would be possible,
        which is similar as C/C++/Java.

    - Rust treats /integer literals/ and /floating-point literals/ as *DISTINCT*
      classes:
      it will never infer a floating-point type for an /integer literal/, or vice
      versa.

    - You can add _underscore_ to the _fractional part_.

    - The ~std::f32~ and ~std::f64~ /modules/ define _constants_ for the
      IEEE-required special values like ~INFINITY~, ~NEG_INFINITY~, ~NAN~, and
      ~MIN~ and ~MAX~ (the largest and smallest finite values).

    - The ~std::f32::consts~ and ~std::f64::consts~ modules provide various
      commonly used mathematical constants like ~E~, ~PI~, and _the square root
      of two_.

    - The ~f32~ and ~f64~ types provide a FULL COMPLEMENT of /methods/ for mathematical
      calculations; for example, ~3f64.sqrt()~.

    - The ~type suffix~ is often not required, but when the context is _not clear_,
      you need to write them down:
      #+begin_src rust
        // NOT Compilable!
        println!("{}", (2.0).sqrt());
      #+end_src

      The correct version can be one of
      * ~println!("{}", (2.0_f64).sqrt());~ or with ~f32~
      * ~println!("{}", f64::sqrt(2.0));~ or with ~f32~

    - You shouldn't expect any implicity conversion for these non collectiontypes
      in Rust. If the conversion is required, use /type cast/ -- the ~as~ syntax.

*** DONE The ~bool~ Type - 51
    CLOSED: [2021-01-11 Mon 14:42]
    - ~as~ can be used to convert ~bool~ values to ~integer~ types:
      #+BEGIN_SRC rust
        assert_eq!(false as i32, 0);
        assert_eq!(true as i32, 1);
      #+END_SRC
      However, you CANNOT convert in the other direction.

    - The info of a ~bool~ value can be saved in a single bit,
      HOWEVER, Rust use an _ENTIRE byte_ for a ~bool~ value in memory, so you
      can create a /pointer/ to it.

*** DONE Characters - 52
    CLOSED: [2021-01-11 Mon 21:56]
    - Character (Rust's) :: ~char~ represents a single Unicode character, as a
                            32-bit value.

    - Rust uses the ~char~ type for single characters in isolation,
      BUT Rust uses the /UTF-8 encoding/ for /strings/ and /streams/ of text.
      So,
      a ~String~ represents its text as a sequence of /UTF-8 bytes/,
      *NOT* as an array of ~char~.

    - If you prefer, you can write out a character's /Unicode code point/ in
      hexadecimal:
      * If a /code point/ is in the range U+0000 to U+007F, which is drawn from
        the ASCII character set, can write the character as ~'\xHH'~, where =HH=
        is a two digit hexadecimal number.

      * You can write any Unicode character as ~'\u{HHHHHH}'~, where =HHHHHH= is
        a hexadecimal number between one and six digits long.

    - A ~char~ *ALWAYS* holds a /Unicode code point/ in the range
      * from 0x0000 to 0xD7FF
        OR
      * from 0xE000 to 0x10FFFF

      A ~char~ is *NEVER* a surrogate pair half (from 0xD800 to 0xDFFF), or a
      value outside the Unicode codespace, that is, greater than 0x10FFFF.

    - Conversions:
      Rust *Never Implicitly* converts BETWEEN ~char~ AND _any other type._

      * ~char~ --> integer numbers
        Do the *explicit conversion* with ~as~.

      * integer numbers --> ~char~
        + If you do this directly with ~as~, you can only from ~u8~ to ~char~
          - Rationale:
            *Rust intends the ~as~ operator to perform _ONLY_ cheap, infallible
            conversions*,
            BUT
            every integer type _other than_ ~u8~ includes values that are NOT
            permitted /Unicode code points/, so those conversions would _require
            runtime checks_.

        + You can use ~std::char::from_u32~, and take any ~u32~ value and returns
          an ~Option<char>~.

    - Check the ~std::char~ to learn more useful methods.
      For instance,
      #+BEGIN_SRC rust
        assert_eq!('*'.is_alphabetic(), false);
        assert_eq!('β'.is_alphabetic(), true);
        assert_eq!('8'.to_digit(10), Some(8));
        assert_eq!('ಠ'.len_utf8(), 3);
        assert_eq!(std::char::from_digit(2, 10), Some('2'));
      #+END_SRC

    - Single /characters/ are NOT very interesting as /strings/ and /streams/.
      =TODO= "String Types" on page 64.

** DONE Tuples - 54
   CLOSED: [2021-01-11 Mon 22:02]
   - For example,
     ~("Brazil", 1985)~ is a tuple fo type ~(&str, i32)~ (or whatever integer
     type, within a proper context, Rust infers from ~1985~).

   - You can access the elememnts of a /tuple/ ~t~ with ~t.0~, ~t.1~, and so on.

   - unit type :: it is an /empty tuple/, ~()~.

   - Since there is only one value for this type, /unit type/ is written as ~()~. 
     It is used as the return type of functions with only side-effect.

   - Rust consistently permits an *extra trailing comma* everywhere commas are
     used: /function arguments/, /arrays/, /struct/ and /enum/ definitions, and
     so on.

     * For instance, ~("Brazil", 1985)~ and ~("Brazil", 1985,)~ are equivalent.

     * *Rationale*:
       This may look odd to human readers, but it can make diffs easier to read
       when entries are added and removed at the end of a list.

   - *UNLIKE* Scala, Rust support /single element tuple/, though the syntax is a
     little wierd! For instance, ~("lonely hearts",)~ is a /single element tuple/
     of type ~(&str,)~. Here the ~,~ in both /value/ and /type/ are mandatory!

     =TODO= =???=
     =From Jian= Why do we need /single element tuple/??? Scala has proved that
     /single element tuple/ is NOT useful -- there are always ways to use other
     techniques, and not redundant!

** Pointer types - 55
   - Rust has _SEVERAL_ /types/ that represent _memory addresses_.

   - =TODO=
     NOTE
     * Languages like Java:
     * Rust:

   - We'll discuss *three* /pointer types/ here:
     * /references/
     * /boxes/
     * /unsafe pointers/

*** DONE References - 56
    CLOSED: [2019-08-01 Thu 22:16]
    - Examples of reference,
      + ~&String~ (pronounced "ref String")
      + ~&i32~ (pronounced "ref 32 bit int(eger)").

    - It's easiest to get started by thinking of /references/ as Rust's _BASIC
      pointer type_ -- A /reference/ can point to ANY /value/ ANYWHERE, /stack/
      or /heap/.

    - Rust has ~&~ and ~*~ for /reference/ related operations.
      They are _very much like_ the ~&~ and ~*~ operators in C and C++.

      + ~&x~ produces a /reference/ to ~x~;
        in Rust terminology, we say that it /borrows/ a /reference/ to ~x~.

      + Given a /reference/ ~r~, the expression ~*r~ refers to the value ~r~
        points to.

    - Immutable reference :: ~&T~, like ~const T*~ in C.

    - Mutable reference :: ~&mut T~, like ~T*~ in C.

    - *LIKE* the ~&~ and ~*~ operators in C and C++,
      a /reference/ does *NOT automatically* free any resources when it goes out
      of scope.

    - *UNLIKE* the /pointers/ in C/C++,
      + Rust /references/ are *NEVER null*:
        there is simply *no way* to produce a /null reference/ in /safe Rust/.

      + Rust tracks the /ownership/ and /lifetimes/ of values, so mistakes like
        /dangling pointers/, /double frees/, and /pointer invalidation/ are
        *ruled out at compile time*.
        TODO
        Chapter 5 explains Rust's rules for _safe reference use_.

*** DONE Boxes - 56
    CLOSED: [2019-08-01 Thu 22:21]
    The simplest way to *allocate* a value in the /heap/ is to use ~Box::new~:
    #+BEGIN_SRC rust
      let t = (12, "eggs");  // (i32, &str)
      let b = Box::new(t);   // Box<(i32, &str)>
    #+END_SRC

    When ~b~ _goes out of scope_, the memory is freed immediately,
    UNLESS ~b~ has been /moved/ -- by returning it, for example. =TODO=
    =TODO= Chpater 4

*** DONE Raw Pointers - 57
    CLOSED: [2019-08-01 Thu 22:24]
    - Rust also has the /raw pointer types/ ~*mut T~ and ~*const T~.
      /Raw pointers/ really are just *LIKE* pointers in C++.

    - Using a /raw pointer/ is *UNSAFE*, because Rust makes no effort to track
      what it points to. For example, /raw pointers/
      + may be /null/
      + may point to memory that
        * _has been freed_
        * now _contains a value of a DIFFERENT type._

      *All the classic pointer mistakes of C++ are offered for your enjoyment.*

      However, you may *ONLY* _dereference_ /raw pointers/ *within* an ~unsafe~
      block.

    - ~unsafe~ block :: is Rust's opt-in mechanism for advanced language features
                        whose safety is up to you.

    - If your code has _NO_ ~unsafe~ blocks (or if those it does have are written
      correctly), then the safety guarantees we emphasize throughout this book
      still hold.
      TODO
      For details, see Chapter 21.

** Arrays, Vectors, and Slices - 57
   - Rust has *three* types for representing a _sequence of values_ in memory:
     + ~[T; N]~ 
       An /array/ of ~N~ values, each of type ~T~.
       * The array size ~N~ is a _CONSTANT determined at /compile time/._ 
         It CANNOT be modified.

     + ~Vec<T>~
       A /vector/ of ~T~'s, which is a _dynamically allocated_, _growable_
       sequence of values of type ~T~. Since its elements live on the /heap/, so
       you can _resize_ /vectors/ at will.

     + ~&[T]~: a /shared slice of ~T~'s/
       ~&mut [T]~: a /mutable slice of ~T~'s/.
         You can think of a /slice/ as a /pointer/ to its first element, together
       with a _count_ of the number of elements you can access starting at that
       point. (=from Jian= this is a /fat pointer/?)

       * A /mutable slice/ ~&mut [T]~ lets you read and modify elements, but
         *CANNOT be shared*;

       * a /shared slice/ ~&[T]~ lets you *share access* among several readers,
         but does *NOT let you MODIFY elements*.

   - All these _three_ types:
     + have the ~len~ /method/.
     + use the SYNTAX ~v[i]~ to index elements.
     + /index/ (~i~ above) must be ~usize~.
     + out of bound indexing will lead to a /panic/.

*** DONE Arrays - 58
    CLOSED: [2019-08-07 Wed 00:34]
    - SYNTAX:
      + Basic: ~let lazy_caterer: [u32; 6] = [1, 2, 4, 7, 11, 16];~
      + Fill in N same values: ~[true; 10000]~ creates an array of 10000 ~true~'s

    - Rust has *NO* notation for an /uninitialized array/. (In general, Rust
      _ensures_ that code can _NEVER_ access any sort of /uninitialized value/.)

    - Rust /arrays/ does *NOT* have /methods/ like
      + iterating over elements,
      + searching,
      + sorting,
      + filling,
      + filtering, and so on.

    - The methods above are */methods/ of /slices/.*
      In fact, even the ~len~ /method/ is a /slice/ only /method/.
        However, Rust *implicitly coverts* a /reference/ to an /array/ to a
      /slice/ when searching for /methods/, so _you can call any /slice/
      /method/ on an /array/ DIRECTLY._ For example,
      #+begin_src rust
        let mut chaos = [3, 5, 4, 1, 2];
        chaos.sort();
        assert_eq!(chaos, [1, 2, 3, 4, 5]);
      #+end_src
      This is because the operand of ~sort~ is a /reference/.

    - TODO "Slices" on page 62.

*** DONE Vectors - 59
    CLOSED: [2019-08-07 Wed 00:42]
    - SYNTAX (Type):
      ~Vec<T>~

    - vector :: resizable array, which is allocated on the /heap/.

    - The ~vec!~ /macro/ is used to create /vecotr literal/:
      For instance,
      #+BEGIN_SRC rust
        let mut v = vec![2 ,3 ,5, 7];
        assert_eq!(v.iter().fold(1, |a, b| a * b), 210);
      #+END_SRC

    - Add an element: ~v.push(11);~

    - Fill in a /vector/ with a value (the syntax is similar to that of
      /arrays/): ~vec![0; rows * cols]~

    - If you want an empty /vector/ and then push elements into it, use the
      ~Vec::new~ method, which is the same as ~vec![]~.
      #+BEGIN_SRC rust
        let mut v = Vec::new();
        v.push("step");
        v.push("on");
        v.push("no");
        v.push("pets");
        assert_eq!(v, vec!["step", "on", "no", "pets"]);
      #+END_SRC

    - Build a /vector/ from the values produced by an /iterator/:
      #+BEGIN_SRC rust
        let v: Vec<i32> = (0..5).collect();
        assert_eq!(v, [0, 1, 2, 3, 4]);
      #+END_SRC
      The type ~Vec<i32>~ here is *required*, or the ~collect~ method doesn't
      know the type of the value it will generate.

    - As with /arrays/, you can use /slice methods/ on /vectors/:
      #+BEGIN_SRC rust
        // palindrome!
        let mut v = vec!["a man", "a plan", "a canal", "panama"];
        v.reverse();
        // Reasonable yet disappointing:
        assert_eq!(v, vec!["panama", "a canal", "a plan", "a man"]);
      #+END_SRC
      + Here, the ~reverse~ /method/ is actually defined on /slices/, but the
        call *implicitly borrows* a ~&mut [&str]~ /slice/ from the /vector/, and
        invokes ~reverse~ on that.

    - A ~Vec<T>~ consists of *three* values:
      + a /pointer/ to the heap-allocated buffer allocated to hold the elements;

      + the /number of elements/ that buffer has the capacity to store;
        =From Jian= the ~capacity~ /method/

      + the /number it actually contains now/ (in other words, its length).
        =From Jian= the ~len~ /method/

    - When the buffer has reached its /capacity/, adding another element to the
      /vector/ entails
      1. *allocating* a larger buffer

      2. *copying* the present contents into it

      3. *updating* the vector's /pointer/ and /capacity/ to describe the new
         buffer
         + capacity :: the buffer it can hold without reallocation.

      4. finally *freeing* the old one.

    - Create a /vector/ with specified /capacity/, and observe its change after
      pushing some elements into it:
      #+BEGIN_SRC rust
        let mut v = Vec::with_capacity(2);
        assert_eq!(v.len(), 0);
        assert_eq!(v.capacity(), 2);

        v.push(1);
        v.push(2);
        assert_eq!(v.len(), 2);
        assert_eq!(v.capacity(), 2);

        v.push(3);
        assert_eq!(v.len(), 3);
        assert_eq!(v.capacity(), 4);
      #+END_SRC
      For the last part above, the /capacity/ you see in your system may be
      _different_.

    - ~insert~ and ~remove~
      #+BEGIN_SRC rust
        let mut v = vec![10, 20, 30, 40, 50];

        v.insert(3, 35);
        assert_eq!(v, [10, 20, 30, 35, 40, 50]);

        v.insert(1);
        assert_eq!(v, [10, 30, 35, 40, 50]);
      #+END_SRC

    - ~pop~
      #+BEGIN_SRC rust
        let mut v = vec!["carmen", "miranda"];
        assert_eq!(v.pop(), Some("miranda"));
        assert_eq!(v.pop(), Some("carmen"));
        assert_eq!(v.pop(), None);
      #+END_SRC

    - Iterate over a /vector/ with ~for~:
      #+BEGIN_SRC rust
        let languages: Vec<String> = std::env::args().skip(1).collect();
        for l in languages {
            println!("{}: {}", l,
                     if l.len() % 2 == 0 {
                         "functional"
                     } else {
                         "imperative"
                     });
        }
        // cargo run Lisp Scheme C C++ Fortran
      #+END_SRC

    - ~Vec~ is an ordinary type defined in Rust,
      NOT built into the language.

      =TODO= Chapter 21 covers how to implement such types

*** DONE Building Vectors Element by Element - 62
    CLOSED: [2019-08-07 Wed 01:46]
    - Building a vector one element at a time
      is *not*
      _as bad as it might sound_.

    - Whenever a vector outgrows its buffer's /capacity/, it chooses a new buffer
      *twice* as large as the old one.
        The total size of all the previous, smaller buffers put together is _2n – 1_,
      very close to the final buffer size. Since the number of actual elements
      is at least half the buffer size, *the /vector/ has always performed _LESS
      THAN two copies_ per element!*
        What this means is that using ~Vec::with_capacity~ instead of ~Vec::new~
      is a way to gain a *constant factor improvement* in speed, _RATHER THAN an
      algorithmic improvement._

    - For *small* /vectors/, avoiding a few calls to the /heap allocator/ can make
      an observable difference in performance.

*** DONE Slices - 62
    CLOSED: [2019-08-07 Wed 01:51]
    - /slice/ (~[T]~) :: a region of an /array/ OR /vector/.
      + Since a /slice/ can be any length, /slices/ *CANNOT* be stored directly
        in variables or passed as function arguments.

      + /Slices/ are _ALWAYS passed by /reference/._
          This is why we often call ~&[T]~'s or ~&str~'s a /slices/, but it is
        acutally /references to a slices/ -- /slices/ *almost always appear
        behind /references/!*
        TODO HOW TO not behind /references/??? TODO

    - A /reference/ to a /slice/ is /a *fat* pointer/:
      a two-word value comprising
      + a /pointer/ to the /slice/'s first element
      + the number of elements in the /slice/.

    - Example:
      #+BEGIN_SRC rust
        let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];
        let a: [f64; 4] = [0.0, 0.707, 1.0, 0.707];

        let sv: &[f64] = &v;
        let sa: &[f64] = &a;
      #+END_SRC
      + Rust _automatically_ converts the ~&Vec<f64>~ /reference/ and the
        ~&[f64; 4]~ /reference/ to /slice references/ that point directly to the
        data.

    - An ORDINARY /reference/ is a non-owning pointer to _a single value_;
      An /reference/ to a /slice/ is a non-owning pointer to _several values_;
        =from Jian= I think the _several_ about is the because /reference to
      slices/ includes length.

    - You can get /a reference to a slice/ by indexing it with a range of:
      + an /array/ or /vector/,
        OR
      + _a /slice/ of an EXISTING /slice/,_
      #+BEGIN_SRC rust
        print(&v[0..2]);  // print the first two elements of v
        print(&a[2..]);   // print elements of a starting with a[2]
        print(&sv[1..3]); // print v[1] and v[2]
      #+END_SRC

** String Types - 64 - =TODO= =Re-Read=
   - C++ has *two* /string types/:
     + ~const char *~: /String literals/
     + ~std::string~: Dynamically creating strings at runtime
     _Rust has a similar design as C++._

   - TODO More details in Chapter 17.

*** DONE String Literals - 64
    CLOSED: [2018-05-21 Mon 18:44]
    - SYNTAX: double quoted sequences of characters.

    - A string may span multiple lines:
      #+BEGIN_SRC rust
        println!("In the room the women come and go,
            Singing of Mount Abora");

        // In the room the women come and go,
        //     Singing of Mount Abora
      #+END_SRC
      The /newline character/, as well as the /spaces/ _at the begining of the
      second line_ are included in this /string literal/.

    - Q :: How about if we want to remove the /newline/ and the leading whitespaces
           of the next line?

    - A :: Add a _backslash_, then the /newline/ and the _leading whitespace_
           on the next line are dropped:
      #+BEGIN_SRC rust
        println!("It was a bright, cold day in April, and \
                  there were four of us-\
                  more or less.");

        // It was a bright, cold day in April, and there were four of us-more or less.
      #+END_SRC

    - /Raw string/ can _REDUCE_ the _double backslashes_ in some strings (e.g.
      _Windows pathes_ and _regular expressions_):

        All backslashes and whitespace characters inside a /raw string/ are
      included _verbatim_ in the string. *No escape sequences are reconized.*
      #+BEGIN_SRC rust
        let default_win_install_path = r"C:\Program Files\Gorillas";
        let pattern = Regex::new(r"\d+(\.\d+)*");
      #+END_SRC

      + You *CANNOT* include a double-quote character in a /raw string/ SIMPLY BY
        putting a backslash in front of it.

        * Solution: Use pound signs with /raw string/:
          #+BEGIN_SRC rust
            println!(r###"
                This raw string started with 'r###"'.
                Therefore it does not end until we reach a quote mark ('"')
                followed immediately by three pound signs ('###'):
            "###)
          #+END_SRC
          You can add as many pound signs as needed to make it clear where the
          /raw string/ ends.

*** DONE Byte Strings - 65
    CLOSED: [2019-08-07 Wed 02:11]
    - byte string :: a /string literal/ with the ~b~ prefix.

    - Such a /byte string/ is a /slice of ~u8~ (byte) values/ --
      RATHER THAN Unicode text.

    - /Byte strings/ *do NOT have any of the string methods.* The most string-like
      thing about /byte strings/ is the syntax we used to write it.

    - Example,
      #+BEGIN_SRC rust
        let method = b"GET";
        assert_eq(method, &[b'G', b'E', b'T']);
      #+END_SRC
      + Here ~method~ is if type ~&[u8; 3]~

    - This combines with all the other string syntax we've shown:
      + span multiple lines

      + use escape sequences

      + use backslashes to join lines.

    - /raw byte string/ starts with ~br"~

    - /byte strings/ can only contains ASCII and =\xHH= escape sequences.
        You *CANNOT* save other Unicode characters in bytes to form /byte
      strings/.

*** DONE Strings in Memory - 65 TODO =RE-READ=
    CLOSED: [2018-05-21 Mon 23:10]
    - Rust /strings/ are sequences of Unicode characters,
      but they are NOT stored in memory as array of ~char~'s (UTF-16 in Rust).

      Instead, they are *stored using UTF-8*, a variable-width encoding.

    - Figure 3-3 shows the ~String~ and ~&str~ values created by the code:
      #+BEGIN_SRC rust
        let noodles: String = "noodles".to_string();
        let oodles: &str = &noodles[1..];
        let poodles: &str = "ಠ_ಠ";
      #+END_SRC
      + A ~String~ has a /resizable buffer/ holding UTF-8 text.
        The buffer is allocated on the /heap/.

        The implementation of ~String~:
        It uses a ~Vec<u8>~ to hold the data. This ~Vec<u8>~ is guaranteed to hold
        well-formed UTF-8.

      + A ~&str~, like other slice references, is a /fat pointer/, containing both
        * the address of the actual data

        * the length of this /slice/.

      + You can think of a ~&str~ as being nothing more than a ~&[u8]~ that is
        guaranteed to hold well-formed UTF-8.

      + A /string literal/ is a ~&str~ that refers to preallocated text, typically
        stored in read-only memory along with the program's machine code (=???=).
          In the preceding example, ~poodles~ is a /string literal/, pointing to
        seven bytes that are created when the program begins execution, and that
        last until it exits

    - A ~&str~ (pronounced "stir" or "string slice").

    - ~&str~'s ~len()~ /method/ returns its length in byte.
      ~&str~'s ~chars().count()~ returns the number of characters.

    - It is *IMPOSSIBLE* to modify a ~&str~.
      #+begin_src rust
        let mut s = "hello";
        s[0] = 'c';    // error: the type `str` cannot be mutably indexed
        s.push('\n');  // error: no method named `push` found for the `&str`
      #+end_src

    - Create new /strings/ at /run time/, use ~String~.

    - The type ~&mut str~ does exist, but it is *not very useful*, since almost
      any operation on UTF-8 can _CHANGE its *overall byte length*,_ and a /slice/
      *CANNOT reallocate* its referent.

      =From Jian= This means if you think you need ~&mut str~, you operation mustn't
      change it overall byte length, and you must justify your reasoning!!!
      _In general, this is *IMPOSSIBLE*._

        In fact, the only operations available on ~&mut str~ are ~make_ascii_uppercase~
      and ~make_ascii_lowercase~ , which modify the text in place and affect only
      /single-byte character/'s, by definition.

*** DONE String - 67 TODO =RE-READ=
    CLOSED: [2018-05-21 Mon 23:23]
    - ~&str~ is very much like ~&[T]~: a /fat pointer/ to some data.

    - ~String~ is analogous to ~Vec<T>~:
      |                                                  | ~Vec<T>~            | ~String~            |
      |--------------------------------------------------+---------------------+---------------------|
      | Automatically frees buffers                      | Yes                 | Yes                 |
      | Growable                                         | Yes                 | Yes                 |
      | ~::new()~ and ~::with_capacity()~ static methods | Yes                 | Yes                 |
      | ~.reverse()~ and ~.capacity()~ methods           | Yes                 | Yes                 |
      | ~.push()~ and ~.pop()~ methods                   | Yes                 | Yes                 |
      | Range syntax ~v[start..stop]~                    | Yes, returns ~&[T]~ | Yes, returns ~&str~ |
      | Automatic conversion                             | ~&Vec<T>~ to ~&[T]~ | ~&String~ to ~&str~ |
      | Inherits methods                                 | From ~&[T]~         | From ~&str~         |

    - Like a ~Vec~,
      each ~String~ has its own /heap-allocated buffer/ that is _NOT shared_ with
      any other ~String~. When a ~String~ variable goes out of scope, the buffer
      is _automatically freed_, unless the ~String~ was /moved/.

    - There are several ways to create ~String~'s:
      + The ~.to_string()~ /method/ converts a ~&str~ to a ~String~.
        This *copies* the string:
        ~let error_message = "too many pets".to_string();~

      + The ~format!()~ macro works just like ~println!()~, except that
        * it returns a new ~String~ instead of writing text to /stdout/
        * it doesn't automatically add a new line at the end.
        #+BEGIN_SRC rust
          assert_eq!(format!("{}°{:02}′{:02}′′N", 24, 5, 23),
                     "24°05′23′′N".to_string());
        #+END_SRC

      + /Arrays/, /slices/, and /vectors/ of strings have two methods, ~.concat()~ and
        ~.join(sep)~, that form a new String from many strings.
        #+BEGIN_SRC rust
          let bits = vec!["veni", "vidi", "vici"];
          assert_eq!(bits.concat(), "venividivici");
          assert_eq!(bits.join(", "), "veni, vidi, vici");
        #+END_SRC

    - The choice sometimes arises of which type to use: ~&str~ or ~String~.
      =TODO=
      Chapter 5 addresses this question in detail.

      For now it will suffice to point out that a ~&str~ can refer to any /slice/
      of any /string/, whether it is a /string literal/ (stored in the executable)
      or a ~String~ (allocated and freed at run time).

      =IMPORTANT=
        This means that ~&str~ is more appropriate for /function arguments/ when
      the caller should be allowed to pass either kind of string.

*** DONE Using Strings - 68 TODO =RE-READ=
    CLOSED: [2018-05-22 Tue 09:03]
    - /Strings/ support the ~==~ and ~!=~ operators.
      They are used to _compare their values_, rather than /address/ as in Java.
      ~assert!("ONE".to_lowercase() == "one");~

    - /Strings/ also support the comparison operators ~<~, ~<=~, ~>~, and ~>=~,
      as well as many useful methods and functions -- search "~str~ (primitive
      type)" or the "~std::str~" module (or just flip to Chapter 17). =TODO=
      Here are a few examples:
      #+BEGIN_SRC rust
        assert!("peanut".contains("nut"));
        assert_eq!("ಠ_ಠ".replace("ಠ", "■"), "■_■");
        assert_eq!("    clean\n".trim(), "clean");

        for word in "veni, vidi, vici".split(", ") {
            assert!(word.starts_with("v"));
        }
      #+END_SRC

    - Keep in mind that, you shouldn't belive in your eyes and the common sense in
      your language and culture!
      + Given the nature of Unicode, simple char-by-char comparison does not always
        give the expected answers -- differnt binary forms can have the same display!

        For example, the Rust strings ~"th\u{e9}"~ and ~"the\u{301}"~ are both
        valid Unicode representations for *thé*, the French word for tea.

      + Similarly, Rust's ordering operators like ~<~ use a simple /lexicographical
        order/ based on /character code point values/.
          This ordering only sometimes resembles the ordering used for text in the
        user's language and culture.

      =TODO=
      We discuss these issues in more detail in Chapter 17.

*** DONE Other String-Like Types - 68 TODO =RE-READ=
    CLOSED: [2018-05-22 Tue 08:59]
    - Rust guarantees that strings are valid UTF-8.

    - Sometimes a program really needs to be able to deal with strings that are
      not valid Unicode.

      + Scenario:
        This usually happens when a Rust program has to interoperate with some
        other system that doesn't enforce any such rules.
          For example, in most OS's it's easy to create a file with a filename
        that isn't valid Unicode. What should happen when a Rust program comes
        across this sort of filename?

      + Rust's Solution is to offer a few string-like types for these situations:
        * Stick to ~String~ and ~&str~ for Unicode text.

        * When working with filenames, use ~std::path::PathBuf~ and ~&Path~ instead.

        * When working with binary data that isn't character data at all, use ~Vec<u8>~
          and ~&[u8]~.

        * When working with environment variable names and command-line arguments
          in the native form presented by the operating system, use ~OsString~ and
          ~&OsStr~.

        * When interoperating with C libraries that use null-terminated strings,
          use ~std::ffi::CString~ and ~&CStr~. =IMPORTANT=

** DONE Beyond the basics - 69
   CLOSED: [2021-01-11 Mon 22:05]
   - There are *three* kinds of /user-defined types/, and we'll cover them in
     *three* successive chapters:
     * ~struct~'s in Chapter 9; =TODO=
     * ~enum~'s in Chapter 10;  =TODO=
     * ~trait~'s in Chapter 11. =TODO=

   - /Functions/ and /closures/ have their own types, TODO covered in Chapter 14.

   - The types that make up the standard library are covered throughout the book.
     For example, Chapter 16 presents _the standard collection types_. TODO

* DONE 4. Ownership - 71
  CLOSED: [2018-05-22 Tue 14:50]
** DONE Ownership - 73 =TODO= =NOTE=
   CLOSED: [2018-05-22 Tue 14:50]
   - Rust makes the following pair of promises, both essential to a safe systems
     programming language:
     + You decide the /lifetime/ of each value in your program.
       Rust frees memory and other resources belonging to a value promptly, at a
       point under your control.

     + Even so, your program will *NEVER* use a pointer to an object after it has
       been freed.
       * Using a dangling pointer is a common mistake in C and C++:
         - if you're lucky, your program crashes.
         - if you’re unlucky, your program has a security hole.

       Rust catches these mistakes at /compile time/.

   - =EN= culprit
   - =EN= relinquish control
   - =EN= wager

   - =NOTE=

** DONE Moves - 77
   CLOSED: [2018-05-22 Tue 12:30]
   - In Rust, _for most types_, operations like
     + *assigning* a value to a variable,
     + *passing* it to a function
     + *returning* it from a function
     don't copy the value: they /move/ it.

   - move :: The source relinquishes /ownership/ of the value to the _destination_,
             and becomes _uninitialized_; the _destination_ now *controls* the
             value's lifetime.

   - =TODO= note
   - Python way:
     Copy /pointers/, and use /reference counts/.
     + Cheap to create new variables.
     + Need to maintain /reference counts/ for gc.

   - C++ way:
     Create multiple copies, and each pointer points to its own copy..
     + expensive in creating new variables.
     + Clear in the references of each pointer, and NO /reference counts/.

   - The code below are legal for Python and C++:
     + Python
       #+BEGIN_SRC python
         s = ['udon', 'ramen', 'soba']
         t = s
         u = s
       #+END_SRC

     + C++
       #+BEGIN_SRC c++
         using namespace std;
         vector<string> s = {"udon", "ramen", "soba"};
         vector<string> t = s;
         vector<string> u = s;
       #+END_SRC

   - The similar code is illegal in Rust:
     #+BEGIN_SRC rust
       let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
       let t = s;
       let u = s;

       // error[E0382]: use of moved value: `s`
       //  --> ownership_double_move.rs:9:9
       //   |
       // 8 |     let t = s;
       //   |         - value moved here
       // 9 |     let u = s;
       //   |         ^ value used here after move
       //   |
     #+END_SRC

     The Rust way is NOT intuitive for other languages users, but it has the
     benefits from both Python way and C++ way: Cheap in re-assignment, and
     _NO_ /reference counts/ required.

     + The price you pay is that you must explicitly ask for copies when you
       want them
       #+BEGIN_SRC rust
         let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
         let t = s.clone();
         let u = s.clone();
       #+END_SRC

     + If you really want the Python way, using /reference counts/, you need to
       use The ~Rc~ and ~Arc~ pointer.
       =TODO=
       See "Rc and Arc: Shared Ownership" on page 90.

*** DONE More Operations That Move - 82
    CLOSED: [2018-05-22 Tue 12:05]
    - If you /move/ a value into a variable that was _already initialized_, Rust
      /drops/ the variable's prior value.
      #+BEGIN_SRC rust
        let mut s = "Govinda".to_string();
        s = "Siddhartha".to_string(); // value "Govinda" dropped here
      #+END_SRC

    - If a variable value is /moved/, you assign it a new value (of course, it
      should be a ~mut~ variable), nothing will be /dropped/.
      #+BEGIN_SRC rust
        let mut s = "Govinda".to_string();
        let t = s;
        s = "Siddhartha".to_string();  // nothing is dropped here
      #+END_SRC

    - =TOOD= NOTE
      Read This Example to find out /moves/.

    - /Moving/ values may sound inefficient, but there are two things to keep in
      mind:
      + The /moves/ always apply to the /value proper/, not the /heap storage/
        they own. For /vectors/ and /strings/, the /value proper/ is the three-word
        header alone.

      + The Rust compiler's code generation is good at *seeing through* all these
        /moves/; in practice, the machine code often stores the value directly
        where it belongs.

*** DONE Moves and Control Flow - 84
    CLOSED: [2018-05-22 Tue 11:44]
    The general principle is that, if it's possible for a variable to have had
    its value moved away, and it hasn't definitely been given a new value since,
    it’s considered uninitialized.

    More concrete examples (they are so natural and easy to understand):
    - ~if~
      #+BEGIN_SRC rust
        let x = vec![10, 20, 30];

        if c {
            f(x); // ... ok to move from x here
        } else {
            g(x); // ... and ok to also move from x here
        }

        h(x) // BAD: x is uninitialized here if either path uses it
      #+END_SRC

    - loop
      + Illegal
        #+BEGIN_SRC rust
          let x = vec![10, 20, 30];

          while f() {
              g(x);  // bad: x would be moved in first iteration,
                     // uninitialized in second
          }
        #+END_SRC

      + Legal
        #+BEGIN_SRC rust
          let mut x = vec![10, 20, 30];

          while f() {
              g(x);      // move from x
              x = h();   // give x a fresh value
          }

          e(x);
        #+END_SRC

*** DONE Moves and Indexed Content - 84
    CLOSED: [2018-05-22 Tue 12:30]
    Sometimes you need to assign the values of elements of a collection to a
    variable. If this /moves/ these element values directly, it is wierd that
    we had a initialized collection before, and we will have a collection which
    has uninitialized elements! Rust _forbid_ you doing this :
    #+BEGIN_SRC rust
      // With Compile Error!!!


      // Build a vector of the strings "101", "102", ... "105"
      let mut v = Vec::new();
      for i in 101 .. 106 {
          v.push(i.to_string());
      }

      // Pull out random elements from the vector.
      let third = v[2];
      let fifth = v[4];

      // error[E0507]: cannot move out of indexed content
      //   --> ownership_move_out_of_vector.rs:14:17
      //    |
      // 14 |     let third = v[2];
      //    |                 ^^^^
      //    |                 |
      //    |                 help: consider using a reference instead `&v[2]`
      //    |                 cannot move out of indexed content
    #+END_SRC

    - This is abnormal. We must find a way to resolve this!!!

      Solutions (=From Jian= the main idea is NO gap (uninitialized elements) in
      the middle):
      #+BEGIN_SRC rust
        // Build a vector of the strings "101", "102", ... "105"
        let mut v = Vec::new();
        for i in 101 .. 106 {
            v.push(i.to_string());
        }
      #+END_SRC

      1. Pop a value _off the end_ of the /vector/:
         #+BEGIN_SRC rust
           let fifth = v.pop().unwrap();
           assert_eq!(fifth, "105");
         #+END_SRC

      2. Move a value out of the middle of the vector, and move the last
         element into its spot:
         =From Jian= This operation is wierd ...
         #+BEGIN_SRC rust
           let second = v.swap_remove(1);
           assert_eq!(second, "102");
         #+END_SRC

      3. Swap in another value for the one we're taking out:
         #+BEGIN_SRC rust
           let third = std::mem::replace(&mut v[2], "substitute".to_string());
           assert_eq!(third, "103");
         #+END_SRC

      Let's see what's left of our /vector/ after the operations in steps 1, 2, 3:
      ~assert_eq!(v, vec!["101", "104", "substitute"]);~

    - Collection types like ~Vec~ also generally _offer_ /methods/ to *consume*
      all their elements in a loop:
      #+BEGIN_SRC rust
        let v = vec!["liberté".to_string(),
                     "égalité".to_string(),
                     "fraternité".to_string()];

        for mut s in v {
            s.push('!');
            println!("{}", s);
        }
      #+END_SRC
      This loop will take the ownership of the value of ~v~.

    - If you do find yourself needing to move a value out of an owner that the compiler
      can’t track, you might consider changing the owner’s type to something that can
      dynamically track whether it has a value or not. For example, here’s a variant on the
      earlier example:
      #+BEGIN_SRC rust
        struct Person { name: Option<String>, birth: i32 }
        let mut composers = Vec::new();
        composers.push(Person { name: Some("Palestrina".to_string()),
                                birth: 1525 });
      #+END_SRC
      + You still CANNOT do this: ~let first_name = composers[0].name;~
        Same error as we saw before!

      + But you can do
        #+BEGIN_SRC rust
          let first_name = std::mem::replace(&mut composers[0].name, None);
          assert_eq!(first_name, Some("Palestrina".to_string()));
          assert_eq!(composers[0].name, None);
        #+END_SRC

      + Actually, the ~Option~ way is common enough and you can use a more specific
        /method/ to do the same thing as the ~std::mem::replace~ line above:
        ~let first_name = composers[0].name.take();~

** DONE ~Copy~ Types: The Exception to Moves - 86
   CLOSED: [2018-05-22 Tue 14:21]
   /Moves/ keep ownership of such types clear and assignment cheap.
   But for simpler types like integers or characters, this sort of careful
   handling really isn't necessary.

   - Assigning a value of a ~Copy~ type *copies* the value, _rather than_ /moving/
     it.

   - ~Copy~ types:
     + all the machine integer, floating-point numeric types, the ~char~ and
       ~bool~ types, and a few others.

       =From Jian= (NO SURE?!) All the types that don't need to allocate heap
       storage are ~Copy~ types.

     + A /tuple/ or /fixed-size array/ of ~Copy~ types elements is itself a
       ~Copy~ type.

   - ~struct~'s are by default NOT ~Copty~ type.
     However, if all the fields of a ~struct~ are ~Copy~ types, you can make this
     ~struct~ type ~Copy~ type as well by placing the /attribute/
     ~#[derive(Copy, Clone)]~ above the definition, like so:
     #+BEGIN_SRC rust
       #[derive(Copy, Clone)]
       struct Label { number: u32 }
     #+END_SRC

     + *CAUTION*:
       All fields MUST BE ~Copy~ types!!! OR you'll see an /error/ even if you
       use the /attribute/ ~#[derive(Copy, Clone)]~.

   - Q: Why use non-~Copy~ type as DEFAULT?

     A: If NOT, the type will be very restricted, which can only contain types
        that have no heap storage allocation.

        Change the non-~Copy~ types to ~Copy~ types won't affect your code.
        However, the opposite direction is different, and you need to modify
        your code.

   - One of Rust's principles is that
     + *costs should be apparent to the programmer*.

     + *Basic operations must remain simple*.

     + *Potentially expensive operations should be explicit*,
       like the calls to ~clone~ in the earlier example that make _deep copies_
       of /vectors/ and the /strings/ they contain.

   - =TODO= =TODO= =TODO=
     ~trait~ in general in Chapter 11
     Traits ~Copy~ and ~Clone~ in general in Chapter 13

** DONE ~Rc~ and ~Arc~: shared ownership - 90
   CLOSED: [2019-11-30 Sat 21:12]
   ALTHOUGH most values have *UNIQUE* /owners/ in typical Rust code,
   IN SOME CASES it's _difficult to find every value a single owner_ that has
   the /lifetime/ you need -- you'd like the value to _simply live until
   everyone's done using it._

   - For these cases, Rust provides the /reference-counted pointer types/:
     + ~Rc~ /reference count/
     + ~Arc~ /atomic reference count/

   - As expected, with the help of Rust design and implementation,
     _both ~Rc~ and ~Arc~ are entirely safe_:
     + You CANNOT
       forget to adjust the reference count

     + You CANNOT
       create other pointers to the referent that Rust doesn't notice

     + You CANNOT
       stumble over any of the other sorts of problems that accompany
       reference-counted pointer types in C++.

   - ~Rc~ and ~Arc~ are very similar!
     *The ONLY DIFFERENCE* between them is that an ~Arc~ (/atomic reference count/)
     is safe to share between threads directly, whereas a plain ~Rc~ uses faster
     /non-thread-safe/ code to update its reference count.

     + Use ~Rc~ if you won't share it between /threads/, and avoid performance
       penalty of an ~Arc~.

     + Rust will *prevent* you from accidentally passing ~Rc~ across a /thread
       boundary/.

     *The two types are otherwise equivalent.*

   - Because of the similarity between ~Rc~ and ~Arc~,
     we'll only talk about ~Rc~ in this section.

   - Use ~Rc~ to simulate the earlier Python code we saw.
     #+BEGIN_SRC rust
       use std::rc::Rc;

       // Rust can infer all these types; written out for clarity
       let s: Rc<String> = Rc::new("shirataki".to_string());
       let t: Rc<String> = s.clone();
       let u: Rc<String> = s.clone();
     #+END_SRC
     + For any type ~T~, an ~Rc<T>~ value is a /pointer/ to a /heap-allocated/ ~T~
       that has had a /reference count/ _affixed to it_.

     + *Cloning an ~Rc<T>~ value does _NOT copy the ~T~ value_;*
       instead, it simply
       * _creates_ ANOTHER /pointer/ to it
         AND
       * _increments_ the /reference count/.

     + The usual /ownership rules/ apply to the ~Rc~ /pointers/ themselves,
       and when the last extant ~Rc~ is /dropped/, Rust /drops/ the ~String~ as
       well.

   - You can use any of ~T~'s usual /methods/ directly on an ~Rc<T>~.

     + In our example, call ~String~'s /methods/ directly on an ~Rc<String>~:
       #+BEGIN_SRC rust
         assert!(s.contains("shira"));
         assert_eq!(t.find("taki"), Some(5));
         println!("{} are quite chewy, almost bouncy, but lack flavor", u);
       #+END_SRC

     + Figure 4-12. A reference-counted string, with three references.

   - A value owned by an ~Rc~ /pointer/ is *immutable*.
     For example, if you try to add some text to the end of the string:
     #+BEGIN_SRC rust
       s.push_str(" noodles");

       // error: cannot borrow immutable borrowed content as mutable
       //   --> ownership_rc_mutability.rs:12:5
       //    |
       // 12 |     s.push_str(" noodles");
       //    |     ^ cannot borrow as mutable
     #+END_SRC
     + Rust's memory and thread-safety guarantees _depend on_ ensuring that *NO*
       value is ever _SIMULTANEOUSLY_ *shared* _and_ *mutable*.
         Rust assumes the referent of an ~Rc~ /pointer/ might in general be *shared*,
       so it _MUST NOT be_ *mutable*.

       TODO We explain why this restriction is important in _Chapter 5 References_.

   - /Circular reference/ issue:
     + _It is POSSIBLE to leak values in Rust this way_,
       but such situations are *RARE*:
       * You cannot create a /circular reference/ without, at some point, making
         an older value -- =from Jian= _No simple and naive way to create
         /circular reference/,_ which is *GOOD*!
         - Q :: WHY?
         - A :: This obviously
           + _requires_ the older value to be *mutable*.
           + Since ~Rc~ pointers hold their referents *immutable*,
             it's _not normally possible_ to create a cycle.

       * _HOWEVER_,
         Rust does provide ways to create mutable portions of otherwise
         immutable values; this is called /interior mutability/.
         - If you combine those techniques with ~Rc~ pointers, you can create a
           cycle and leak memory.
         - TODO we cover it in “Interior Mutability” on page 205. TODO

   - You can
     sometimes AVOID creating cycles of ~Rc~ pointers by using /weak pointers/,
     ~std::rc::Weak~, for some of the links instead. 
       However, _we won't cover those in this book;_ see the standard library's
     documentation for details.

   - We haved learned _TWO ways_ to relax the rigidity of the /ownership tree/:
     /Moves/ and /reference-counted pointers/. 
       In the next chapter, we'll look at a _THIRD way_: /BORROWING references to
     values/.

* DONE 5. References and borrowing - 93
  CLOSED: [2018-06-14 Thu 21:17]
  - ALL the /pointer types/ we've seen SO FAR are /owning pointer types/:
    + the simple ~Box<T>~ heap pointer,
    + the pointers internal to ~String~ and ~Vec~ values

  - Owning pointers :: when the /owner/ is /dropped/, the /referent/ goes with
       it.

  - Rust also has /nonowning pointer types/ called /references/, which have no
    effect on their /referents' lifetimes/.

  - It's rather the opposite (/owning pointer types/ and /non-owning pointer types/):
    /references/ must *never outlive* their /referents/.

    You must make it _APPARENT_ in your code that *NO* /reference/ can possibly
    _outlive_ the value it points to.

    To emphasize this, Rust referes to creating a /reference/ to some value as
    /borrowing/ the value:
    What you have borrowed, you must eventually return to its owner!

  - You have two kinds of /references/:
    + shared references :: ~&variable~

    + mutable references :: ~&mut variable~

  - (I didn't copy the wrong code, which is used to introduce the concepts of
    /shared references/ and /mutable references/ here, ONLY the right one -- use
    /reference/ rather than /move/):
    #+BEGIN_SRC rust
      use std::collections::HashMap;

      type Table = HashMap<String, Vec<String>>;

      fn show(table: &Table) {
          for (artist, works) in table {
              println!("works by {}:", artist);
              for work in works {
                  println!(" {}", work);
              }
          }
      }

      fn main() {
          let mut table = Table::new();
          table.insert("Gesualdo".to_string(),
                       vec!["many madrigals".to_string(),
                            "Tenebrae Responsoria".to_string()]);
          table.insert("Caravaggio".to_string(),
                       vec!["The Musicians".to_string(),
                            "The Calling of St. Matthew".to_string()]);
          table.insert("Cellini".to_string(),
                       vec!["Perseus with the head of Medusa".to_string(),
                            "a salt cellar".to_string()]);
          show(table);
      }
    #+END_SRC

  - Modify the ~table~ with with /mutable references/:
    #+BEGIN_SRC rust
      fn sort_works(table: &mut Table) {
          for (_artist, works) in table {
              works.sort();
          }
      }
      sort_works(&mut table);
    #+END_SRC

  - Pass it /by value/, you use the /move/ semantics, and give out the /ownership/.
    Pass it /by reference/, you keep the /ownership/.

** DONE References as Values - 97
   CLOSED: [2018-06-14 Thu 02:41]
*** DONE Rust References Versus C++ References - 97
    CLOSED: [2018-05-24 Thu 12:07]
    - In a nutshell, whereas
      + C++ converts _IMPLICITLY_ between /references/ and /lvalues/ (that is,
        expressions referring to locations in memory), with these conversions
        appearing anywhere they're needed,
        #+BEGIN_SRC c++
          int x = 10;
          int &r = x;       // initialization creates reference implicitly
          assert(r == 10);  // implicitly dereference r to see x's value
          r = 20;           // stores 20 in x, r itself still points to x
        #+END_SRC

      + in Rust you use the ~&~ and ~*~ operators to create and follow /references/,
        #+BEGIN_SRC rust
          let x = 10;
          let r = &x;        // &x is a shared reference to x
          assert!(*r = 10);  // explicitly dereference r
        #+END_SRC

        To create a /mutable reference/, use the ~&mut~ operator:
        #+BEGIN_SRC rust
          let mut y = 32;
          let m = &mut y;     // &mut y is a mutable reference to y
          *m += 32;           // explicitly dereference m to set y's value
          assert!(*m == 64);  // add to see y's new value
        #+END_SRC

        with the *exception* of the ~.~ operator, which /borrows/ and
        /dereferences/ _IMPLICITLY_.
        * For instance:
          #+BEGIN_SRC rust
            struct Anime { name: &'static str, bechdel_pass: bool };
            let aria = Anime { name: "Aria: The Animation", bechdel_pass: true };
            let anime_ref = &aria;
            assert_eq!(anime_ref.name, "Aria: The Animation");

            // Equivalent to the above, but with the dereference written out:
            assert_eq!((*anime_ref).name, "Aria: The Animation");
          #+END_SRC

        * ~println!~ macro used in the ~show~ function in the last section expands
          to code that uses the ~.~ operator, so it takes advantage of this
          /implicit deference/ as well.

        * The ~.~ operator can also /implicitly borrow/ a /reference/ to its
          _left operand_, if needed for a /method/ call.
          For example,
          ~Vec~'s ~sort~ /method/ takes a /mutable reference/ to the vector, so
          the two calls shown here are equivalent:
          #+BEGIN_SRC rust
            let mut v = vec![1973, 1968];

            v.sort();
            // implicitly borrows a mutable reference to v

            (&mut v).sort();
            // equivalent; much uglier
          #+END_SRC

*** DONE Assigning References - 98
    CLOSED: [2018-05-24 Thu 12:17]
    - *Assigning* to a Rust /reference/ makes it _point at a new value_:
      #+BEGIN_SRC rust
        let x = 10;
        let y = 20;
        let mut r = &x;

        if b { r = &y; }
        assert!(*r == 10 || *r == 20);
      #+END_SRC
      The /reference/ ~r~ INITIALLY _points to_ ~x~.
      But if ~b~ is ~true~, the code points it at ~y~ instead, as illustrated in
      Figure 5-1. =TODO= =REVIEW=

      This is *very different from C++*,
      where *assigning* to a /reference/ *stores* the value in its /referent/.
      There's *NO WAY* to point a C++ /reference/ to a location _other than_ the
      one it was initialized with.
      =From Jian=
      The rationale is easy to understand: you didn't /move/ the value, just use
      a /reference/, it is reasonable to NOT write the value to the address where
      the /reference/ ~r~ was initialized to point to.

*** DONE References to References - 99
    CLOSED: [2018-05-24 Thu 12:22]
    - Rust permits /references to references/:
      #+BEGIN_SRC rust
        struct Point { x: i32, y: i32 };
        let point = Point { x: 1000, y: 729 };
        let r: &Point = &point;
        let rr: &&Point = &r;
        let rrr: &&&Point = &rr;
      #+END_SRC
      The ~.~ operator follows as many /references/ as it takes to find its
      target: ~assert_eq!(rrr.y, 729);~

      See the Figure 5-2. A chain of references to references (memory layout)

*** DONE Comparing References - 99
    CLOSED: [2018-05-24 Thu 12:29]
    - Like the ~.~ operator, Rust's comparison operators “see through” any number
      of /references/, *as long as both operands have the SAME type* (=From
      Jian= you can compare SAME type values):
      #+BEGIN_SRC rust
        let x = 10;
        let y = 10;

        let rx = &x;
        let ry = &y;

        let rrx = &rx;
        let rry = &ry;

        assert!(rrx <= rry);
        assert!(rrx == rry);
      #+END_SRC

    - If you actually want to know WHETHER two /references/ point to the SAME
      memory, you can use ~std::ptr::eq~, which compares them as addresses:
      #+BEGIN_SRC rust
        assert!(rx == ry);              // their referents are equal
        assert!(!std::ptr::eq(rx, ry)); // but occupy different addresses
      #+END_SRC
      =IMPORTANT=

*** DONE References Are Never Null - 100
    CLOSED: [2018-05-24 Thu 12:32]
    /References/ are NEVER /null/.
    Outside ~unsafe~ block, you CAN'T convert zero into a /reference/ -- the way
    you can used to create /null/ in C/C++.

*** DONE Borrowing References to Arbitrary Expressions - 100
    CLOSED: [2018-05-24 Thu 12:46]
    - Whereas
      C and C++ ONLY let you apply the ~&~ operator to _CERTAIN kinds of
      expressions_,

      Rust lets you /borrow/ a /reference/ to the value of *ANY* sort of expression
      at all:
      #+BEGIN_SRC rust
        fn factorial(n: usize) -> usize {
            (1..n+1).fold(1, |a, b| a * b)
        }

        let r = &factorial(6);
        assert_eq!(r + &1009, 1729);
      #+END_SRC
      + In situations like this, Rust simply creates an /anonymous variable/ to
        hold the expression's value, and makes the /reference/ point to that.
          The /lifetime/ of this /anonymous variable/ depends on what you do
        with the /reference/:
        * If you *immediately assign* the /reference/ to a /variable/ in a ~let~
          statement (or make it part of some /struct/ or /array/ that is being
          immediately assigned), then Rust makes the /anonymous variable/ live as
          long as the variable the ~let~ initializes.
            In the preceding example, Rust would do this for the referent of ~r~.

        * Otherwise, the /anonymous variable/ lives to the end of the _enclosing
          statement_. In our example, the /anonymous variable/ created to hold
          ~1009~ lasts only to the end of the ~assert_eq!~ statement.

      + This design seems error-prone for C/C++.
        However, Rust will never let you write code that would produce a
        /dangling reference/. The pointer to /anonymous variables/ will be
        /dropped/ when beyond their /lifetime/.

    - If the /reference/ could ever be used *beyond* the /anonymous variable/'s
      /lifetime/, Rust will always report the problem to you at /compile time/.
        You can then fix your code to keep the referent in a /named variable/
      with an _appropriate_ (=???=) /lifetime/.
      =TODO= =TODO= =TODO=
      
*** DONE References to Slices and Trait Objects - 101
    CLOSED: [2018-06-14 Thu 02:39]
    - The /references/ we've shown _so far_ are all _SIMPLE_ /addresses/.

    - HOWEVER, Rust also includes *TWO* kinds of /fat pointers/.

    - fat pointers :: two-word values carrying the address of some value, along
                      with some further information necessary to put the value
                      to use.

    - A /reference to a slice/ is a /fat pointer/,
      carrying the _starting address_ of the /slice/ and its _length_.

      =TODO= =REVIEW=
      We described slices in detail in Chapter 3.

    - Rust's other kind of /fat pointer/ is a /trait object/,

      =From Jian= =???= =TODO= Should be a /trait object/ or a /reference trait object/ ???????

      a /reference/ to a value that implements a certain /trait/.

      A /trait object/ carries
      + a /value/'s /address/

      + a /pointer/ to the /trait/'s implementation appropriate to that value,
        for invoking the /trait/'s /methods/.

      =TODO=
      We'll cover /trait objects/ in detail in "Trait Objects" on page 238.

    - ASIDE FROM carrying this extra data,
      /slice references/ and /trait object references/ behave just like the other
      sorts of /references/ we've shown so far in this chapter:
      + they don't own their referents;

      + they are NOT allowed to _outlive_ their referents;

      + they may be /mutable/ or /shared/; and so on.

** TODO Reference Safety - 101
*** DONE Borrowing a Local Variable - 101
    CLOSED: [2018-05-24 Thu 14:25]
    A pretty obvious case: you _can't_ /borrow/ a /reference/ to a local variable
    and take it out of the variable's scope:

    - Example:
      #+BEGIN_SRC rust
        {
            let r;
            {
                let x = 1;
                r = &x;
            }
            assert_eq!(*r, 1);  // bad: reads memory `x` used to occupy
        }
      #+END_SRC

      Error Message:
      #+BEGIN_SRC text
        error: `x` does not live long enough
          --> references_dangling.rs:8:5
           |
        7  |         r = &x;
           |              - borrow occurs here
        8  |     }
           |     ^ `x` dropped here while still borrowed
        9  |     assert_eq!(*r, 1); // bad: reads memory `x` used to occupy
        10 | }
           | - borrowed value needs to live until here
      #+END_SRC

    - /Lifetimes/ are entirely figments of Rust's /compile-time/ imagination.

      At /runtime/, a /reference/ is nothing but an address;
      its /lifetime/ is *part of* its /type/ and has _NO_ /runtime/
      representation.

    - In this example, there are *three* /lifetimes/ whose relationships we need
      to work out. The variables ~r~ and ~x~ each have a /lifetime/, extending

      from _the point at which they're initialized_
      until _the point that they go out of scop_.

      The third /lifetime/ is that of a /reference type/: the type of the
      /reference/ we /borrow/ to ~&x~, and store in ~r~.

      Here's one *constraint* that should seem pretty obvious:
      if you have a variable ~x~, then a /reference/ to ~x~ *must not* _outlive_
      ~x~ itself, as shown in Figure 5-3.

    - The rules Rust compiler used to do the lifetime check is NOT so different
      from the process C and C++ programmers impose on themselves; the
      difference is that _Rust knows the rules, and *enforces* them_.

*** TODO Receiving References as Parameters - 105
*** DONE Passing References as Arguments - 107
    CLOSED: [2018-06-14 Thu 17:38]
    Now that we've shown how a function's signature relates to its body, let's
    examine how it relates to the function's callers.

    - Example:
      #+BEGIN_SRC rust
        // This could be written more briefly: fn g(p: &i32),
        // but let's write out the lifetimes for now.
        fn g<'a>(p: &'a i32) { ... }

        let x = 10;
        g(&x);
      #+END_SRC
      + From ~g~'s signature alone, Rust knows it will _NOT_ save ~p~ anywhere
        that might outlive the call:
        any /lifetime/ that encloses the call must work for ~'a~.

    - When defining /functions/ and /types/, you need to figure out /lifetime
      parameters/.

      When using them, Rust infers the /lifetimes/ for you.

    - With a definition of wrong /lifetime parameters/ settings,
      the code won't compile:
      #+BEGIN_SRC rust
        fn f(p: &'static i32) { ... }

        let x = 10;
        f(&x);
      #+END_SRC
    
*** DONE Returning References - 107
    CLOSED: [2018-06-14 Thu 17:50]
    #+BEGIN_SRC rust
      // v should have at least one element
      fn smallest(v: &[i32]) -> &i32 {
          let mut s = &v[0];

          for r in &v[1..] {
              if *r < *s { s = r; }
          }

          s
      }
    #+END_SRC
    - We've omitted lifetimes from that function's signature in the usual way.

      + When a function
        takes a SINGLE /reference/ as an argument, and
        returns a SINGLE /reference/,

        Rust assumes that the two must have the SAME /lifetime/.

      + Write it explicitly:
        ~fn smallest<'a>(v: &'a [i32]) -> &'a i32 { ... }~

    - You cannot use it in this way:
      #+BEGIN_SRC rust
        let s;
        {
            let parabola = [9, 4, 1, 0, 1, 4, 9];
            s = smallest(&parabola);
        }
        assert_eq!(*s, 0);  // bad: points to element of dropped array
      #+END_SRC
      The first line of the error message is:
      ~error: `parabola` does not live long enough~
    
*** TODO Structs Containing References - 109
    - x

    - =???= =TODO=
      In fact, ... ???

    - x

*** TODO Distinct Lifetime Parameters - 111
*** DONE Omitting Lifetime Parameters - 112
    CLOSED: [2018-06-14 Thu 21:17]
    - In the simplest case, if your function _doesn't return_ any /references/ (or
      other types that require /lifetime parameters/), then you never need to
      write out /lifetimes/ for your parameters -- *Rust just assigns a DISTINCT
      /lifetime/ to each spot that needs one.* For example:
      #+BEGIN_SRC rust
        struct S<'a, 'b> {
            x: &'a i32,
            y: &'b i32
        }

        fn sum_r_xy(r: &i32, s: S) -> i32 {
            r + s.x + s.y
        }
      #+END_SRC

      This function's signature is shorthand for:
      ~fn sum_r_xy<'a, 'b, 'c>(r: &'a i32, s: S<'b, 'c>) -> i32~

    - If there's only a _SINGLE_ /lifetime/ that appears among your function's
      parameters, then Rust _assumes_ ANY /lifetimes/ in your return value must
      be that one:
      #+BEGIN_SRC rust
        fn first_third(point: &[i32; 3]) -> (&i32, &i32) {
            (&point[0], &point[2])
        }
      #+END_SRC
      With all the lifetimes written out, the equivalent would be:
      ~fn first_third<'a>(point: &'a [i32; 3]) -> (&'a i32, &'a i32)~

    - If there are _MULTIPLE_ /lifetimes/ among your parameters,
      then there's NO natural reason to prefer one over the other for the return
      value, and
      *Rust makes you spell out what's going on*.

    - But as one final shorthand,
      if your function is a /method/ on some /type/ and takes its ~self~
      parameter /by reference/, then that breaks the tie:
        Rust assumes that ~self~'s /lifetime/ is the one to give EVERYTHING in
      your /return value/.

      + Example:
        #+BEGIN_SRC rust
          struct StringTable {
              elements: Vec<String>,
          }

          impl StringTable {
              fn find_by_prefix(&self, prefix: &str) -> Option<&String> {
                  for i in 0 .. self.elements.len() {
                      if self.elements[i].starts_with(prefix) {
                          return Some(&self.elements[i]);
                      }
                  }
                  None
              }
          }
        #+END_SRC
        The ~find_by_prefix~ /method/'s signature is shorthand for:
        ~fn find_by_prefix<'a, 'b>(&'a self, prefix: &'b str) -> Option<&'a String>~

    - *SUMMARY*:
      All these abbreviations meant to be helpful without introducing surprises.
      _When they're NOT what you want, you can always write the /lifetimes/ out
      explicitly._

** TODO Sharing Versus Mutation - 114
** DONE Taking Arms Against a Sea of Objects - 121
   CLOSED: [2018-06-14 Thu 03:06]
   - The disadvantages of languages with GC:
     Since it is easy to get not-in-use memeory back, you may create many objects
     you think you need without a fully consideration of your design and memory
     use, and build connections between them -- finally, When everything depends
     on everything else like this Figure 5-10,

     (=From Jian= two reasons:
     you create two many objects you actually don't need if you have a better
     design, and with this bad design you often have to build unecessary
     dependencies between these objects).

     it's hard to test, evolve, or even think about any component in isolation.

   - One fascinating thing about Rust is that the /ownership model/ puts a speed
     bump on the highway to hell.
     =From Jian= *Make dangerous things verbose*
       It takes a bit of effort to make a cycle in Rust -- two values such that
     each one contains a reference pointing to the other. You have to use a /smart
     pointer type/, such as ~Rc~, and /interior mutability/ -- a topic we haven't
     even covered yet. =TODO=

   - Rust prefers for /pointers/, /ownership/, and /data flow/ to pass through
     the system *in one direction*, as shown in Figure 5-11.

     Rust's /ownership model/ will give you some trouble when you want to do
     some bad design.
       The cure is to do some up-front design and build a better program.

   - Rust is all about *transferring* the pain of understanding your program _from
     the future to the present_.

     + It works unreasonably well:
       * not only can Rust force you to understand why your program is thread-safe,
       * it can even require some amount of high-level architectural design.

* DONE 6. Expressions - 123
  CLOSED: [2018-05-23 Wed 22:43]
** DONE An Expression Language - 123
   CLOSED: [2018-05-22 Tue 21:19]
   Rust is what is called an *expression* language.

** DONE Blocks and Semicolons - 124
   CLOSED: [2018-05-22 Tue 21:19]
   - /Blocks/, too, are /expressions/
     A /block/ produces a value and can be used _ANYWHERE_ a value is needed:
     #+BEGIN_SRC rust
       let display_name = match post.author() {
           Some(author) => author.name(),
           None         => {
               let network_info = post.get_network_metadata()?;
               let ip           = network_info.client_address();
               ip.to_string()  // NO semicolon here!!!
           }
       }
     #+END_SRC
     + The ~ip.to_string()~ line has no semicolon, and it is the returned value.

     + If all lines in a block has a semicolon at the end, the return value is
       ~()~.

     + Tips:
       #+BEGIN_SRC rust
         // error[E0308]: mismatched types
         //   --> expressions_missing_semicolon.rs:19:9
         //    |
         // 19 |         page.compute_size() // oops, missing semicolon
         //    |         ^^^^^^^^^^^^^^^^^^^ expected (), found tuple
         //    |
         //    = note: expected type `()`
         //               found type `(u32, u32)`
       #+END_SRC
       If you made this mistake in a C or Java program, the compiler would simply
       point out that you’re missing a semicolon. Here's what Rust says:
         Rust assumes you've omitted this semicolon on purpose; it doesn't consider
       the possibility that it's just a typo. A confused error message is the result.
       =IMPORTANT= =IMPORTANT= =IMPORTANT=
       *When you see error message that includes =expected type `()`= , look for
       a missing semicolon first.*

   - Empty statements, ~;~'s, are also allowed in /blocks/.

** DONE Declarations - 126
   CLOSED: [2019-11-23 Sat 21:01]
   - ~let~ is kinda of like the ~final~ in Java in some aspect, if not all:
     #+BEGIN_SRC rust
       let name;

       if user.has_nickname() {
           name = user.nickname();
       } else {
           name = generate_unique_name();
           user.register(&name);
       }
     #+END_SRC
     ~name~ assignment appears in two places, but can ONLY be one of them.
     Thus, no ~mut~ required in the declaration of ~name~;

   - Use before initialization is, of course, can be detected by the compiler.

   - A /block/ can also contain /item declarations/.
     + item :: simply any declaration that could appear globally in a program or
               module, such as a ~fn~, ~struct~, or ~use~. For instance,
       #+BEGIN_SRC rust
         use std::io;
         use std::cmp::Ordering;

         fn show_files() -> io::Result<()> {
             let mut v = vec![];
             // ...
             fn cmp_by_timestamp_then_name(a: &FileInfo, b: &FileInfo) -> Ordering {
                 a.timestamp.cmp(&b.timestamp)  // first, compare timestamps
                     .reverse()                 // newest file first
                     .then(a.path.cmp(&b.path)) // compare paths to break ties
             }
             v.sort_by(cmp_by_timestamp_then_name);
             // ...
         }
       #+END_SRC
       + TODO Later chapters will cover /items/ in details.

   - Rust's ~fn~'s declared in a block is not a /closure/ -- it can't access local
     variables or arguments that happen to be in scope in other languages.
       For example, the ~cmp_by_timestamp_then_name~ above can't access variable
     ~v~ directly.
     + Rust also has /closures/. See Chapter 14.

   - TODO
     A block can even contain a whole /module/.
     TODO =IMPORTANT= for using /macro/:
     + Q :: This may seem a bit much -- do we really need to be able to nest every
            piece of the language inside every other piece?

     + A :: Programmers (and particularly programmers using /macros/) have a way
            of finding uses for every scrap of orthogonality the language provides.

** DONE ~if~ and ~match~ - 127
   CLOSED: [2018-05-22 Tue 21:19]
   - SYNTAX ~if .. else if .. else~:
     #+BEGIN_SRC rust
       if condition1 {
           block_1
       } else if condition2 {
           block_2
       } else {
           block_n
       }
     #+END_SRC
     + /conditions/ doesn't require parentheses.
       The compiler will emit a warning when unnecessary parentheses are
       present.

     + The curly braces for the body blocks are mandatory!

   - SYNTAX ~match~:
     #+BEGIN_SRC rust
       match value {
           pattern => expr,
           // ...
       }
     #+END_SRC
     + If ~expr~ above is a block, the comma may be dropped

     + ~match~ has /exhaustiveness check/

   - The optimization of ~match~:
     + Use a /jump table/, just like a ~switch~ statement in C++.

     + When each arm of a ~match~ produces a constant value, the compiler builds
       an array of those values, and the ~match~ is compiled into an array access.
       Apart from a bounds check, there is a branch-free code.

*** DONE ~if let~ - 129
    CLOSED: [2018-05-22 Tue 21:19]
    - SYNTAX:
      #+BEGIN_SRC rust
        if let pattern = expr {
            block_1
        } else {
            block_2
        }
      #+END_SRC
      + It's never strictly necessary to use ~if let~,
        because ~match~ can do everything ~if let~ can do.

        =From Jian=
        ~match~ syntax is good for aligning conditions and operations, which is
        very convenient! I can imagine any cases that I want to use ~if let~!!!
          I use ~if let~-like syntax in Go, juse because Go DOESN'T HAVE ~match~!

** DONE Loops - 130
   CLOSED: [2018-05-22 Tue 22:01]
   - SYNTAX:
     #+BEGIN_SRC rust
       while condition {
           block
       }

       while let pattern = expr {
           block
       }

       loop {
           block
       }

       for pattern in collection {
           block
       }
     #+END_SRC
     + /Loops/ are also expressions, but they ONLY produce useless value ~()~.

     + ~while~ behaves exactly like the C equivalent, except Rust is stongly
       typed, which means /condition/ must be ~bool~.

     + ~loop~ is used to write /infinite loops/ (with mechanism inside to stop it,
       for instance ~break~ or ~return~ inside).

     + In the ~for~ loop, we often use /range/.
       For instance, ~0..20~ and ~std::ops::Range { start: 0, end: 20 }~ are the
       same, and they are /ranges/.

       ~Range~ can be used with ~for~ loops because ~Range~ is an /iterable type/,
       it implements the ~std::iter::IntoIterator~ /trait/.
       =TODO= Chapter 15
       The standard collections are all iterable, as are /arrays/ and /slices/.

   - In keeping with Rust's /move/ semantics, a ~for~ loop over a value *consumes*
     the value:
     #+BEGIN_SRC rust
       let strings: Vec<String> = error_messages();

       for s in strings {              // each String is moved into s here...
           println!("{}", s);
       }                               // ...and dropped here

       println!("{} error(s)", strings.len()); // error: use of moved value
     #+END_SRC
     + GOOD: This design promises the simplicity in theory.

     + Not so Good, but can be easily walked around:
       * It is very inconvenient in many cases. Use /reference/ instead!
         #+BEGIN_SRC rust
           for rs in &strings {
               println!("String {:?} is at address {:p}.", *rs, rs);
           }
         #+END_SRC
         - ~&strings~ here is ~&Vec<String>~, and
           ~rs~ is ~&String~.

       * Use ~mut~ /reference/ provides a ~mut~ /reference/ to each element:
         #+BEGIN_SRC rust
           for rs in &mut strings {  // the type of `rs` is `&mut String`
               rs.push('\n');  // add a newline to each string
           }
         #+END_SRC

   - =TODO=
     Chapter 15 covers ~for~ loops in greater detail and show many other ways to
     use /iterators/.

   - ~break~ expression exits an _enclosing loop_.

     In Rust, ~break~ works only in /loops/!
       Since ~match~ (the Rust version of C/C++ ~switch~) dosen't have the
     feature of /fall-through/, it doesn't need ~break~.

   - ~continue~

   - A /loop/ can be *labeled* with a /lifetime/.
     =From Jian= the example code below doesn't have a explicit lifetime?!
     #+BEGIN_SRC rust
       'search:
       for room in apartment {
           for spot in room.hiding_spots() {
               if spot.contains(keys) {
                   println!("Your keys are {} in the {}.", spot, room);
                   break 'search;
               }
           }
       }
     #+END_SRC
     + /Labels/ can also be used with ~continue~.

** DONE ~return~ Expressions - 132
   CLOSED: [2018-05-22 Tue 22:07]
   - ~return~ without follow-up value means return ~()~

   - ~return~ can abandon work in progress.
     If you call a function with this kind of ~return~, you may want to use ~?~
     operator to check for errors after calling.
       For instance, ~let output = File::create(filename)?;~, it is shorthand for
     a ~match~ expression:
     #+BEGIN_SRC rust
       let output = match File::create(filename) {
           Ok(f)    => f,
           Err(err) => return Err(err)
       }
     #+END_SRC
     =TODO= See "Propagating Errors" on page 152.

** DONE Why Rust Has ~loop~ - 133
   CLOSED: [2019-11-27 Wed 23:20]
   - Several pieces of the Rust compiler analyze the /flow of control/ through your
     program.
     + Rust checks that
       _EVERY path_ through a /function/ _returns a value_ of the _expected
       return type_.
       * To do this correctly,
         it *needs* to know whether or not it's possible to reach the end of the
         function.

     + Rust checks that
       /local variables/ are _NEVER used uninitialized_.
         This entails checking every path through a function to
       MAKE SURE _there's no way to reach a place where a variable is used
       without having already passed through code that initializes it_.

     + Rust WARNS about
       /unreachable code/.

   - The analysis above is /flow-sensitive analyses/;
     Java has had a /definite assignment analysis/, similar to Rust's, for years.

   - When enforcing the rules in /flow-sensitive analyses/,
     a language must strike a balance between
     + *simplicity* --
       make it easier for programmers to figure out what the compiler is talking
       about sometimes.

       AND

     + *cleverness* --
       Eliminate false warnings and cases where hte compiler rejects a safe program.

   - Rust went for *simplicity*!!!
     Its /flow-sensitive analyses/ do *NOT* examine loop conditions at all, instead
     simply assuming that any condition in a program can be either true or false.
     + Because of this Rust will reject some safe programs like
       #+begin_src rust
         fn wait_for_process(process: &mut Process) -> i32 {
             while true {
                 if process.wait() {
                     return process.exit_code();
                 }
             }
         }  // error: not all control paths return a value
       #+end_src
       * =from Jian=
         We all know the ~return process.exit_code();~ will be reached if this
         function can be finished. However, since the /flow-sensitive analyses/
         of Rust doesn't check and consider the ~while~ condition ~true~ as TRUE
         or FALSE.

     + The ~loop~ expression is offered to help tell the compiler directly that
       "I mean loop forever if no break inside".

*** Rust's type system is affected by control flow, too.
    =from Jian= _I add this subsection, which is not a separate subsection in book_

    - Earlier we said that all branches of an /if expression/ must have the SAME
      type. _BUT_ it would be silly to enforce this rule on some specific blocks.

      + This kind of special blocks includes (not a complete list)
        * a ~break~ or /return expression/
        * an /infinite loop/
        * a call to ~panic!()~ or ~std::process:exit()~.

      + What all those above expressions have in common is that *they never finish
        in the usual way*, producing a value. For example
        * A ~break~ or ~return~ *exits* the current block ABRUPTLY;
        * an /infinite loop/ *never finishes* at all.

    - divergent function :: functions that NEVER returns.

    - Q :: Then how can we type a /divergent function/???

    - A :: Use the special return type ~!~. =from Jian= Bottom???

    - Example:
      + From Standard library:
        ~std::process::exit()~ has the signature of ~fn exit(code: i32) -> !~

      + User defined:
        #+begin_src rust
          fn serve_forever(socket: ServerSocket, handler: ServerHandler) -> ! {
              socket.listen();
              loop {
                  let s = socket.accept();
                  handler.handle();
              }
          }
        #+end_src

    - Of course,
      *Rust considers it an error if the /divergent function/ return normally.*

** DONE Function and Method Calls - 134
   CLOSED: [2018-05-23 Wed 21:43]
   - Rust usually makes a _sharp distinction_ between /references/ and the
     /values/ they refer to.

     + You cannot pass a /reference/ to a function requires a /value/, or vice versa.

     + However, the ~.~ operator AUTOMATICALLY *dereferences* the caller or
       *borrows* a /reference/ to it as needed.

   - SYNTAX for calling /static methods/:
     ~let mut numbers = Vec::new();~

   - One quirk of Rust syntax:
     When the invocation involves types with generic type parameter(s), the syntax
     is *NOT* intuitive:

     + Error:
       #+BEGIN_SRC rust
         return Vec<i32>::with_capacity(1000);     // error: something about chained comparisons

         let ramp = (0 .. n).collect<Vec<i32>>();  // same error
       #+END_SRC
       The compiler consider ~<~ as /less than operator/, this must be avoided.

       =From Jian= a patchy solution again!

     + Solution:
       * With wierd syntax!
         prefix the type parameter parts with ~::~
         #+BEGIN_SRC rust
           return Vec::<i32>::with_capacity(1000);     // ok, using ::<
           let ramp = (0 .. n).collect::<Vec<i32>>();  // ok, using ::<
         #+END_SRC

       * (_PREFERED_) With the help of /type inference/:
         #+BEGIN_SRC rust
           return Vec::with_capacity(10);            // ok, if the fn return type is Vec<i32>
           let ramp: Vec<i32> = (0 .. n).collect();  // ok, variable's type is given
         #+END_SRC

** DONE Fields and Elements - 135
   CLOSED: [2018-05-23 Wed 22:02]
   - For example:
     #+BEGIN_SRC rust
       game.black_pawns  // struct field
       coords.1          // tuple elements
     #+END_SRC

   - If the left of the dot is a /reference/ or /smart pointer type/, it is
     AUTOMATICALLY *dereferenced*, just as for /method/ calls.

   - SYNTAX like ~pieces[i]~ for /arrays/, /slices/ and /vectors/.

   - The ~..~ operator allows either operand to be omitted.
     #+BEGIN_SRC rust
       ..      // RangeFull
       a ..    // RangeFrom { start: a }
       .. b    // RangeTo { end: b }
       a .. b  // RangeFrom { start: a, end: b }
     #+END_SRC
     + =TODO= =???=
       Only /ranges/ that include a /start value/ are /iterable/,
       =???=

** DONE Reference Operators - 137
   CLOSED: [2018-05-23 Wed 22:18]
   The /address-of operators/, ~&~ and ~&mut~ (covered in Chapter 5).

   The unary ~*~ operator is used to access the value pointed to by a /reference/.
   1. When there is the caller before ~.~, who is a /reference/, /auto dereference/
      will happen.

   2. Therefore, ONLY when we want to read or write the entire value that the
      reference points to. For instance, pass its value as a parameter.
      #+BEGIN_SRC rust
        let padovan: Vec<u64> = compute_padovan_sequence(n);

        for elem in &padovan {
            draw_triangle(turtle, *elem);
        }
      #+END_SRC

** DONE Arithmetic, Bitwise, Comparison, and Logical Operators - 137 =TODO=
   CLOSED: [2018-05-23 Wed 22:30]
   Rust has the usual arithmetic operators, ~+~, ~-~, ~*~, ~/~, and ~%~.
   These operators are mostly like their counterpart in the other languages.

   We'll focus on the few points where Rust departs from tradition:

   - As mentioned in Chapter 3,
     + integer overflow is detected, and causes a /panic/, *in debug builds*.

     + The standard library provides /methods/ LIKE ~a.wrapping_add(b)~ for
       *unchecked* arithmetic.

   - Dividing an integer by zero triggers a /panic/ *even in release builds*.

     Integers have a method ~a.checked_div(b)~ that returns an ~Option~ (~None~
     if ~b~ is zero) and NEVER /panics/.

   - ~%~ can be applied to BOTH /integers/ and /floating numbers/.
     As in C, the result has the same sign as the LHS of the ~%~.

   - Rust use ~!~ rather than the ~~~ for bitwise NOT.

   - /Bit shifting/ is ALWAYS
     + sign-extending on /signed integer types/

     + zero-extending on /unsigned integer types/.

     Since Rust has /unsigned integers/, it does NOT need Java's ~>>>~ operator.

   - *UNLIKE C*, =TODO=
     /Bitwise operations/ have _higher PRECEDENCE_ than comparisons,
     unlike C, so if you write ~x & BIT != 0~ , that means ~(x & BIT) != 0~ , as
     you probably intended.
       This is much more useful than C's interpretation, ~x &(BIT != 0)~ , which
     tests the wrong bit!

** DONE Assignment - 138
   CLOSED: [2018-05-23 Wed 22:36]
   - /assignment/ *moves* values of /non-copyable types/.

   - You _cannot_ make a chain of element assignment, and there -- the rightmost
     one will return a ~()~

   - Rust doesn't have ~++~ and ~--~
** DONE Type Casts - 139
   CLOSED: [2019-11-24 Sun 00:10]
   Converting a /value/ from one /type/ to another usually requires an *explicit
   cast* in Rust. Casts use the ~as~ /keyword/:
   #+begin_src rust
     let x = 17;              // x is type i32
     let index = x as usize;  // convert to usize
   #+end_src
   =from Jian= Of course, this piece of code is just a illustration, and you should
   never write code in this way.

   - Several kinds of casts are permitted:
     + _Numbers_ may be cast from any of the built-in numeric types to any other.
       * _Casting an integer to another integer type_ is always well-defined.
         + To a narrower type => truncation
         + Signed integer to wider type => sign-extended
         + Unsigned integer to wider type => zero-extended

       * *CAUTION*
         Cast a large /floating-point value/ to an /integer type/ that is too small
         to represent it can lead to an /undefined behavior/ EVEN IN SAFE Rust.
         This is a compiler error http://github.com/rust-lang/rust/issues/10184.

     + Values of type ~bool~, ~char~, or of a C-like ~enum~ type, may be cast to
       any /integer type/.
       * The other direction cast is not allowed.

       * However, there is some function like ~std::char::from_u32()~ can do the
         other direction conversion, and return ~Option<char>~.

       * The requirement of other direction conversion has grown rare -- we typically
         convert whole strings or streams at once, and algorithms on Unicode text are
         often nontrivial and best left to libraries.


     + Some casts involving /unsafe pointer types/ are also allowed.
       TODO _See "Raw Pointers" on page 538_ TODO

   - Though _MOST_ conversion usually requires a cast.
     A _FEW_ conversions involving /reference types/ are so STRAIGHTFORWARD that
     the language performs them even *WITHOUT* a /cast/. One trivial example is
     converting a ~mut~ /reference/ to a non-~mut~ /reference/.
     + Several more significant automatic conversions can happen, though:
       * Values from type ~&String~ to type ~&str~.
       * Values from type ~&Vec<i32>~ to ~&[i32]~.
       * Values from type ~&Box<Chessboard>~ to ~&Chessboard~.

   - The conversions above are called /deref coercions/, because they apply to
     types that implement the ~Deref~ built-in /trait/.

   - The purpose of ~Deref~ coercion is to make smart pointer types, like ~Box~,
     behave as much like the underlying value as possible. Using a
     ~Box<Chessboard>~ is mostly just like using a plain ~Chessboard~, thanks to
     ~Deref~ .

   - User-defined types can implement the ~Deref~ trait, too.
     TODO When you need to write your own smart pointer type, _see “Deref and
     DerefMut” on page 289._

** DONE Closures - 140
   CLOSED: [2019-11-24 Sun 00:10]
   - Example:
     ~let is_even = |x| x % 2 == 0~

   - If you do specify a /return type/, the body of the closure must be a /block/.
     #+begin_src rust
       // Error
       let is_even = |x: u64| -> bool x % 2 == 0;

       // Ok
       let is_even = |x: u64| -> bool { x % 2 == 0 };
     #+end_src

** DONE Precedence and Associativity - 140
   CLOSED: [2019-11-24 Sun 00:16]
   - =IMPORTANT= Table 6-1. Expressions TODO

   - All of the operators that can usefully be chained are /left-associative/.
     =from Jian= _are_ here is actually _must be_

   - Operators that _CANNOT be chained_:
     + /comparison operators/
     + /assignment operators/
     + /range operator/ ~..~

** DONE Onward - 142
   CLOSED: [2018-05-23 Wed 22:43]
   
* DONE 7. Error Handling - 145
  CLOSED: [2018-06-25 Mon 02:48]
  - There are two kinds of errors-handling in Rust:
    + /panic/

    + ~Results~

  - Ordinary errors are handled using ~Result~'s.

    These are typically caused by things _outside_ the program, and such situations
    occur is NOT up to us; even a bug-free program will encounter them from time to
    time. For instance, erroneous input, a network outage, or a permissions problem.

    =TODO=
    Most of this chapter is dedicated to that kind of error.

  - /Panic/ is for the other kind of error, the kind that *should NEVER happen*.

** DONE Panic - 145
   CLOSED: [2018-06-04 Mon 17:23]
   - A program /panics/ when it encounters something so messed up that there MUST
     BE a _bug_ in the program itself. Something like:
     + Out-of-bounds array access

     + Integer division by zero

     + Calling ~.unwrap()~ on an Option that happens to be ~None~

     + Assertion failure

     + the /macro/ ~panic!()~, for cases where your own code find some inconsistency
       during the calculation and discovers that it has gone wrong, and therefore
       need to trigger a /panic/ directly by your code, the ~panic!()~.

       * ~panic!()~ accepts optional ~println!()~-style arguments, for building
         an error message.

   - Check the examples given above, you see that /panics/ are programmer's fault!

   - When a /panic/ happen, Rust gives you a choice:
     + *unwind* the /stack/, which is the *default*!

     + *abort* the /process/

*** TODO Unwinding - 146
    - =EN=
      + pirates divvy up the booty from a raid - 海盜們從突襲中分出戰利品

      + loot - 贓物

    - =TODO= NOTE

    - /Panic/ is _NOT crash_!

      /Panic/ is _NOT undefined behavior_!

    - /Panic/ is more like Java's ~RuntimeException~, or C++'s ~std::logic_error~.

    - The behavior of a /panic/ is *well-defined*;
      it just *shouldn't be happening*!

    - /Panic/ is *safe*!
      It doesn't violate any of Rust's safety rules!

      The idea is that Rust catches the invalid operations, or whatever it is,
      *before* anything bad happens. Since it would be unsafe to proceed, so Rust
      _unwinds the stack_. But the rest of the process can continue running.

    - /Panic/ is *per* /thread/.
      =IMPORTANT=
      =TODO= In Chapter 19, we'll show how a parent thread can find out when a
      child thread panics and handle the error gracefully.

    - There is also a way to *catch* /stack unwinding/, _allowing_ the /thread/
      to *survive and continue running*.
        The standard library function ~std::panic::catch_unwind()~ does this.

        We won't cover how to use it, but this is the mechanism used by Rust's
      /test/ harness to *recover* when an /assertion fails/ in a /test/. (It can
      also be necessary when writing Rust code that can be called from C or C++,
      because *unwinding across non-Rust code is undefined behavior*; =TODO= see
      Chapter 21.) =IMPORTANT=

*** TODO Aborting - 147

** DONE Result - 148
   CLOSED: [2018-06-25 Mon 02:48]
   - Rust does NOT have /exception/!
     Instead, /functions/ that can fail have a /return type/ that says so.
     For instance,
     ~fn get_weather(location: LatLng) -> Result<WeatherReport, io::Error>~

*** DONE Catching Errors - 148
    CLOSED: [2018-06-10 Sun 13:42]
    - Pattern matching is the most thorough way of dealing with a ~Result~.
      It is the equivalent of ~try/catch~ in other languages.

    - ~match~ is a bit verbose, so ~Result<T, E>~ offers a variety of /methods/
      that are useful in particular common cases. Each of these /methods/ has a
      ~match~ expression in its implementation.

      + ~result.is_ok()~ and ~result.is_err()~

      + ~result.ok()~ returns the success value, if any, as an ~Option<T>~.

      + ~result.err()~ returns the error value, if any, as an ~Option<E>~.

      + ~result.unwrap_or(fallback)~ returns the success value, if ~result~ is a
        success result. Otherwise, it returns ~fallback~, discarding the error
        value.

        If you have a appropriate fallback value, this is a good alternative to
        ~.ok()~ because the /return type/ is ~T~, not ~Option<T>~.

      + ~result.unwrap_or_else(fallback_fn)~ returns the success value, ...
        This is good for the case that the computation of the ~fallback~ value is
        costly.

      + ~result.unwrap()~ returns the success value, or panic if the ~result~ is
        an error.

      + ~result.expect(message)~ is similar to the ~unwrap~ method, but with an
        error message in case of panic.

      + Two /methods/ for /borrowing references/ to the value in a ~Result~:
        * ~result.as_ref()~ converts a ~Result<T, E>~ to a ~Result<&T, &E>~,
          borrowing a reference to the success or error value in the existing
          ~result~.

        * ~result.as_mut()~
          ~Result<&mut T, &mut E>~

        These two /methods/ are very useful -- all the other /methods/ introduced
        here, except the ~result.is_ok()~ and the ~result.is_err()~ consumes the
        ~self~, this may not be what you want.

*** DONE Result Type Aliases - 150
    CLOSED: [2018-06-10 Sun 13:46]
    Sometimes you may see a type like ~Result<()>~, which means this ~Result~ /type
    alias/ is being used.

    ~pub type Result<T> = result::Result<T, Error>;~. This example is in the /module/
    of ~std::io~, and the ~Error~ is the ~std::io::Error~.

*** DONE Printing Errors - 150
    CLOSED: [2018-06-10 Sun 14:08]
    Sometimes the only way to handle an error is by dumping it to the terminal and
    moving on.

    - All the errors, such as ~std::io::Error~, ~std::fmt::Error~, and
      ~std::str::Utf8Error~, implement the ~std::error:Error~ /trait/, which means
      they share the following features:
      + Use ~{}~ format specifier to display a brief error message.
        Use ~{:?}~ format specifier to display a ~Debug~ view of the error.

      + ~err.description()~ returns an error message as a ~&str~.

      + ~err.cause()~ returns an ~Option<&Error>~: the underlying error, if any,
        that triggered ~err~.

        =RE-READ= More details!!!

    - Printing an error value does NOT also print out its cause.

      If you want to be sure to print all the available information, use this function:
      #+BEGIN_SRC rust
        use std::error::Error;
        use std::io::{Write, stderr};

        /// Dump an error message to `stderr`.
        ///
        /// If another error happens while building the error message or
        /// writing to `stderr`, it is ignored.
        fn print_error(mut err: &Error) {
            let _ = writeln!(stderr(), "error: {}", err);
            while let Some(cause) = err.cause() {
                let _ = writeln!(stderr(), "caused by: {}", cause);
                err = cause;
            }
        }
      #+END_SRC

    - The standard library's error types do NOT include a /stack trace/,

      but the ~error-chain~ *crate* makes it easy to define your own custom
      error type that supports grabbing a /stack trace/ when it's created.

      It uses the ~backtrace~ /crate/ to capture the stack.

*** DONE Propagating Errors - 152
    CLOSED: [2018-06-25 Mon 00:52]
    - The behavior of ~?~ depends on whether this function returns a _success
      result_ or an _error result_ (*To ensure that this works, ~?~ can only be
      used in functions that have a ~Result~ return type*):
      + On success
        it /unwraps/ the ~Result~ to get the /success value/ inside.
        The type of weather here is not ~Result<WeatherReport, io::Error>~ but
        simply ~WeatherReport~.

      + On error
        it immediately returns from the enclosing function, passing the error
        result up the call chain.

    - The behavior of ~?~ is like
      #+BEGIN_SRC rust
        let weather = match get_weather(hometown) {
            Ok(success_value) => success_value,
            Err(err) => return Err(err)
        }
      #+END_SRC
      + The _ONLY differences_ between this and the ~?~ operator are some fine points
        involving types and conversions.
        =TODO=
        We'll cover those details in the next section.

    - Legacy code:
      ~try!()~ was introduced in Rust 1.13.
      ~let weather = try!(get_weather(hometown));~
      This /macro/ expands to the pattern matching above.

    - Error handling is sometimes pervasive in your program:
      #+BEGIN_SRC rust
        use std::fs;
        use std::io;
        use std::path::Path;

        for move_all(src: &Path, dst: &Path) -> io::Result<()> {
            for entry_result in src.read_dir()? {  // opening dir could fail
                let entry = entry_result?;         // reading dir could fail
                let dst_file = dst.join(entry.file_name());
                fs::rename(entry.path(), dst_file)?;  // renaming could fail
            }
            Ok(())  // phew!
        }
      #+END_SRC

*** DONE Working with Multiple Error Types - 153
    CLOSED: [2018-06-25 Mon 01:53]
    Example code:
    #+BEGIN_SRC rust
      use std::io::{self, BufRead};

      /// Read integers from a text file.
      /// The file should have one number on each line.
      fn read_numbers(file: &mut BufRead) -> Result<Vec<i64>, io::Error> {
          let mut numbers = vec![];
          for line_result in file.lines() {
              let line = line_result?;      // reading lines can fail
              numbers.push(line.parse()?);  // parsing integers can fail
          }
          Ok(numbers)
      }

      /// numbers.push(line.parse()?);     // parsing integers can fail
      ///              ^^^^^^^^^^^^^ the trait `std::convert::From<std::num::ParseIntError>`
      ///                            is not implemented for `std::io::Error`
    #+END_SRC
    - In Chapter 2, the Mandelbrot set example, we define a ~ImageError~, and
      implements conversions from ~io::Error~ and several other error types to
      ~ImageError~.

      If you prefer this way, you can use the ~errorchain~ /crate/, which is
      designed to help you define good error types with just a few lines of
      code.

    - You can use a /trait object/ and /generics/ to save the used errors to
      an error type you defined.
      #+BEGIN_SRC rust
        type GenError = Box<std::error::Error>;
        type GenResult<T> = Result<T, GenError>;
      #+END_SRC
      Then change the return type of ~read_numbers()~ to ~GenResult<Vec<i64>>~.

      + Incidentally, the ~?~ operator does this /automatic conversion/ using a
        standard method that you can use yourself. To convert any error to the
        GenError type, call
        #+BEGIN_SRC rust
          GenError::from() :
          let io_error = io::Error::new(          // make our own io::Error
              io::ErrorKind::Other, "timed out");
          return Err(GenError::from(io_error));   // manually convert to GenError
        #+END_SRC
        =TODO= We'll cover the ~From~ /trait/ and its ~from()~ /method/ fully in
        Chapter 13.

      + The *Downside* of this method is:
        the /return type/ NO LONGER *communicates* precisely what kinds of errors
        the caller can expect. _The caller must be ready for anything._

      + If you're calling a function that returns a ~GenResult~, and you want to
        *handle _one_ particular kind of error, but let _all others_ propagate out*,

        use the generic method ~error.downcast_ref::<ErrorType>()~. It borrows a
        reference to the error, if it happens to be the particular type of error
        you're looking for:
        #+BEGIN_SRC rust
          loop {
              match compile_project() {
                  Ok(()) => return Ok(()),
                  Err(err) => {
                      if let Some(mse) = err.downcast_ref::<MissingSemicolonError>() {
                          insert_semicolon_in_source_code(mse.file(), mse.line())?;
                          continue; // try again!
                      }
                      return Err(err);
                  }
              }
          }
        #+END_SRC
        Many languages have built-in syntax to do this, but it turns out to be
        rarely needed. Rust has a method for it instead.
        =TODO= =RE-READ= !!!

*** DONE Dealing with Errors That "Can't Happen" - 155
    CLOSED: [2018-06-25 Mon 02:12]
    Use the ~.unwrap()~ /mehtod/. If we are wrong, and the error CAN happend,
    then we would /panic/.

    For example, the ~Write~ /trait/ defines a common set of /methods/ (~.write()~
    and others) for text and binary output. All of those /methods/ return ~io::Result~'s,
    but if you happend to be writing to a ~Vec<u8>~, they can't fail. In such cases,
    it's acceptable to use ~.unwrap()~ or ~.expect(message)~ to dispensse with the
    ~Result~'s.

*** DONE Ignoring Errors - 156
    CLOSED: [2018-06-25 Mon 00:55]
    For example, the call to ~writeln!~ can have error. If you want to ignore it
    without getting any warnings, try:
    ~let _ = writeln!(stderr(), "error: {}", err);  // ok, ignore result~

*** DONE Handling Errors in ~main()~ - 156
    CLOSED: [2018-06-25 Mon 02:24]
    - In _most places_ where a ~Result~ is produced,
      letting the error bubble up to the /caller/ is the *right behavior*.
        This is why ~?~ is a single character in Rust. As we've seen, in some
      programs it's used on many lines of code in a row.

    - Before Rust 1.26, you can't use ~?~ in the ~main()~ function, whose /return
      type/ cannot be ~Result~.

      =From Jian= This book is published before Rust 1.26.
      Since Rust 1.26, the ~main()~ function can be of ~Result~ /return type/,
      and you can use ~?~ in it.

    - For the cases of prior to Rust 1.26, you can use ~.expect()~ /method/.
      If this call returns an error result, the ~.expect()~ /method/ /panics/.

      Panicking in the main thread prints an error message, then exists with a
      *nonzero exit code*, which is roughly the desired behavior.

    - For example,
      #+BEGIN_SRC rust
        fn main() {
            calculate_tides().expect("error");  // the buck stops here
        }
      #+END_SRC
      The error message is lost in the noise.
      #+BEGIN_SRC bash
        # $ tidecalc --planet mercury

        ##   thread 'main' panicked at 'error: "moon not found"', /buildslave/rust-buildbot/s
        ##   lave/nightly-dist-rustc-linux/build/src/libcore/result.rs:837
        ##   note: Run with `RUST_BACKTRACE=1` for a backtrace.
      #+END_SRC

      The ~RUST_BACKTRACE=1~ here is bad advice in this particular case.
      You should print it out by yourself, and get a nice and tidy output:
      #+BEGIN_SRC rust
        fn main() {
            if let Err(err) = calculate_tides() {
                print_error(&err);
                std::process::exit(1);
            }
        }
        // $
        // tidecalc --planet mercury
        //
        /// error: moon not found
      #+END_SRC

*** DONE Declaring a Custom Error Type - 157
    CLOSED: [2018-06-25 Mon 02:48]
    - Define a basic version, and use ~Err~ to convert it to an ~std::error::Error~:
      #+BEGIN_SRC rust
        // json/src/error.rs
        #[derive(Debug, Clone)]
        pub struct JsonError {
            pub message: String,
            pub line: usize,
            pub column: usize,
        }

        // inside a function
        // ...
           return Err(JsonError {
               message: "expected ']' at end of array".to_string(),
               line: current_line,
               column: current_column
           });
        // ...
      #+END_SRC

    - Define a standard error types:
      #+BEGIN_SRC rust
        use std;
        use std::fmt;

        #[derive(Debug, Clone)]
        pub struct JsonError {
            pub message: String,
            pub line: usize,
            pub column: usize,
        }

        // Errors should be printable.
        impl fmt::Display for JsonError {
            fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
                write!(f, "{} ({}:{})", self.message, self.line, self.column)
            }
        }

        // Errors should implement the std::error::Error trait.
        impl std::error::Error for JsonError {
            fn description(&self) -> &str {
                &self.message
            }
        }
      #+END_SRC

*** DONE Why Results? - 158
    CLOSED: [2018-06-10 Sun 14:19]
    Here are the key points of the design:
    + Rust requires the programmer to make some sort of decision, and record it in the
      code, at every point where an error could occur. This is good because otherwise,
      it's easy to get error handling wrong through neglect.
      =SIMPIFY THIS NOTE=

      =From Jian= You cannot neglect it, but much better than Java's /checked
      exception/.

    + Use ~?~ to do error propagation.
      Thus error plumbing does not clutter up your code the way it does in C and Go.
      Yet it's still visible.

    + Since the possibility of errors is part of every function's /return type/,
      it's clear which functions can fail and which can't.
      =From Jian= It is visible, but much better than Java's /checked exception/.

      If you change a function to be fallible, you're _changing_ its /return type/,
      so the compiler will make you update that function's downstream users.

    + Rust checks that ~Result~ values are used, so you can't accidentally let an
      error pass silently (a common mistake in C).

    + Since ~Result~ is a data type like any other, it's easy to store success and
      error results in the same collection. _This makes it easy to model PARTIAL
      success._
        For example, if you’re writing a program that loads millions of records
      from a text file, and you need a way to cope with the likely outcome that
      most will succeed, but some will fail, you can represent that situation in
      memory using a vector of ~Result~'s.

* DONE 8. Crates and Modules - 161
  CLOSED: [2018-07-01 Sun 20:24]
  - This chapter covers the features of Rust that help keep your program organized:
    /crates/ and /modules/.

  - We'll also cover a wide range of topics that come up naturally as your project
    grows, including
    + how to *document* and *test* Rust code,
    + how to *silence* unwanted /compiler warnings/,
    + how to use Cargo to *manage* project /dependencies/ and /versioning/,
    + how to *publish* open source libraries on _crates.io_, and more.

** DONE Crates - 161
   CLOSED: [2018-06-04 Mon 03:34]
   - Rust programs are made of /creates/.

   - Each /crate/ is a /Rust project/:
     + all the source code for a single library or executable

     + plus
       * any associated tests
       * examples
       * tools
       * configuration
       * other things.

   - Later on, we'll see how to tell Cargo to fetch source code from
     + a /Git repository/
       OR 
     + the /local filesystem/ rather than /crates.io/.

   - Once it has obtained all the source code, Cargo compiles all the crates.
     It runs ~rustc~, the Rust compiler, _ONCE_ for each /crate/ in the
     project's dependency graph.

     + When compiling libraries, Cargo uses the =--crate-type lib= option.
       This tells ~rustc~ _NOT_ to look for a ~main()~ function _BUT_ instead to
       produce an =.rlib= file containing compiled code in a form that later
       ~rustc~ commands can use as input.

       When compiling a program, Cargo uses ~--crate-type bin~, and the result
       is a binary executable for the target platform: =mandelbrot.exe= on
       Windows, for example.

   - =TODO= NOTE !!!
   - =TODO= NOTE !!!
   - =TODO= NOTE !!!

   - ~cargo build~ supports all sorts of options, most of which are beyond the
     scope of this book, but we will mention one here:
     ~cargo build --release~ produces an optimized build.

     + Release builds run faster,

     + but
       * they take _longer_ to compile,

       * they _don't check_ for /integer overflow/,

       * they _skip_ ~debug_assert!()~ assertions, and

       * the /stack traces/ they generate on /panic/ are generally *less* reliable.

*** DONE Build Profiles - 164
    CLOSED: [2018-06-04 Mon 03:34]
    - There are several _configuration settings_ you can put in your =Cargo.toml=
      file that affect the ~rustc~ command lines that ~cargo~ generates.
      | Command line            | Cargo.toml section used |
      |-------------------------+-------------------------|
      | ~cargo build~           | ~[profile.debug]~       |
      | ~cargo build --release~ | ~[profile.release]~     |
      | ~cargo test~            | ~[profile.test]~        |

    - The *defaults* are usually fine,
      but one _EXCEPTION_ we've found is when you want to use a /profiler/ -- a
      tool that measures where your program is spending its CPU time. 

      + To get the best data from a /profiler/, you need both
        * optimizations (usually enabled ONLY in release builds)
        * debug symbols (usually enabled ONLY in debug builds).

      To enable both, add this to your =Cargo.toml=:
      #+BEGIN_SRC toml
        [profile.release]
        debug = true  # enable debug symbols in release builds
      #+END_SRC
      + The ~debug~ setting controls the =-g= option to =rustc=.

      With this configuration, when you type =cargo build --release=, you'll get
      a binary with /debug symbols/. The optimization settings are unaffected.

    - *The Cargo documentation* lists many other settings you can adjust.
      =TODO= =IMPORTANT= =READ=

** DONE Modules - 165
   CLOSED: [2018-06-04 Mon 14:36]
   - modules :: Rust's namespaces.

   - /Modules/ are containers for the /functions/, /types/, /constants/, and so on
     that make up your Rust program or library.

     Whereas /crates/ are about code sharing *between* projects, modules are about
     code organization *within* a project. The look like:
     #+BEGIN_SRC rust
       mod spores {
           use cells::Cell;

           /// A cell mode by an adult fern. It disperses on the wind as part of
           /// the fern life cycle. A spore grows into a prothallus -- a whole
           /// separate organism, up to 5mm across -- which produces the zygote
           /// that grows into a new fern. (Plant sex is complicated.)
           pub struct Spore {
               // ...
           }

           // Simulate the production of a spore by meiosis.
           pub fn produce_spore(factory: &mut Sporangium) -> Spore {
               // ...
           }

           // Mix genes to prepare for meiosis (part of interphase).
           fn recombine(parent: &mut Cell) {
               // ...
           }

           // ...
       }
     #+END_SRC

   - Anything that isn't marked ~pub~ is /private/.

   - /Modules/ can _nest_.
     It's fairly common to see a /module/ that's just a collection of /submodules/.
     #+BEGIN_SRC rust
       mod plant_structures {
           pub mod roots {
               // ...
           }

           pub mod stems {
               // ...
           }

           pub mod leaves {
               // ...
           }
       }
     #+END_SRC

*** DONE Modules in Separate Files - 166
    CLOSED: [2018-06-04 Mon 13:18]
    - A module can also be written like this:
      ~mod spores;~

      This tells the compiler that the ~spores~ /module/ lives in a separate file,
      called =spores.rs=:

    - Rust _NEVER_ compiles /modules/ separately, even if they're in separate files:
      when you build a Rust /crate/, you're *recompiling* _ALL_ of its /modules/.

    - A /module/ can have _its own directory_.

      When Rust sees ~mod spores;~, it checks for both =spores.rs= and =spores/mod.rs;=
      *if neither file exists, or both exist, that's an error.*

    - For example (the earlier example ~plant_structures~)
      + Directory Structure:
        #+BEGIN_SRC text
          fern_sim/
          ├── Cargo.toml
          └── src/
              ├── main.rs
              ├── spores.rs
              └── plant_structures/
                  ├── mod.rs
                  ├── leaves.rs
                  ├── roots.rs
                  └── stems.rs
        #+END_SRC

      + Declare /modules/ 
        Declare ~pub mod plant_structures;~ in the =main.rs= causes Rust to load
        =plant_structures/mod.rs=, which declares the three /submodules/:
        #+BEGIN_SRC rust
          // in plant_structures/mod.rs
          pub mod roots;
          pub mod stem;
          pub mod leaves;
        #+END_SRC

        The content of those three /modules/ is stored in separate files named
        =leaves.rs=, =roots.rs=, and =stem.rs=, located alongside =mod.rs= in the
        =plant_structures= directory.

*** DONE Paths and Imports - 167
    CLOSED: [2018-06-04 Mon 13:43]
    - ~::~ is used to access features of a /module/.
      Code anywhere in your project can refer to any standard library feature by
      writing out its /absolute path/:
      #+BEGIN_SRC rust
        if s1 > s2 {
            ::std::mem::swap(&mut s1, &mut s2);
        }
      #+END_SRC
      + It is obvious we have a function call.
        Since it starts with a double colon, it is an absolute path.

        * The path ~::std~ refers to the /top-level module/ of the standard
          library.

        * ~::std::mem~ is a /submodules/ within the standard library, and
          ~::std::mem::swap~ is a /public function/ in that /module/.

    - You can /import/ features into the modules where they're used with ~use~:
      #+BEGIN_SRC rust
        use std::mem;

        if s1 > s2 {
            mem::swap(&mut s1, &mut s2);
        }
      #+END_SRC
      + /Paths/ in ~use~ declarations are automatically /absolute paths/, so there
        is no need for a leading ~::~.

    - /Import/ multiple features at once:
      + ~use std::collections::{HashMap, HashSet};~
      + ~use std::io::prelude::*;~

    - /Modules/ do not automatically inherit names from their /parent modules/.
      For example, suppose we have this in our =proteins/mod.rs=:
      #+BEGIN_SRC rust
        // proteins/mod.rs
        pub enum AminoAcid { ... }
        pub mod synthesis;
      #+END_SRC
      Then the code in =synthesis.rs= does NOT automatically see the type ~AminoAcid~.
      Instead, each module starts with a black slate and must import the names it
      uses:
      #+BEGIN_SRC rust
        // proteins/synthesis.rs
        use super::AminoAcid;  // explicitly import from parent

        pub fn synthesize(seq: &[AminoAcid]) // ...
      #+END_SRC

    - As in the example above, ~super~ is used to access the /parent module/.

    - ~self~ is used to represent /current module/, and you may use it to import
      /current modules/' /submodules/' features:
      #+BEGIN_SRC rust
        // in protein/mod.rs

        // import from a submodule
        use self::synthesis::synthesize;

        // import names from an enum,
        // so we can write `Lys` for lysine, rather than `AminoAcid::Lys`
        use self::AminoAcid::*;
      #+END_SRC

    - Use ~self~ and ~super~ to write /relative paths/.

    - /Submodules/ *can access* /private items/ in their /parent modules/, but they
      have to *import each one by name*.

      use ~super::*;~ ONLY imports items that are marked ~pub~.

    - There is a natural analogy between /modules/ and the /files and
      directories/ of a /Unix filesystem/.
      + ~super~ like ~..~
      + ~self~ like ~.~
      + ~use~ like ~ln~
      + ~extern crate~ like mount a filesystem

*** DONE The Standard Prelude - 169
    CLOSED: [2018-06-04 Mon 13:50]
    - The standard library ~std~ is *automatically* linked with every project.
      It's as though your =lib.rs= or =main.rs= contained an _invisible declaration_
      for it: ~extern crate std;~

    - The /standard prelude/, where is the place ~Vec~ and ~Result~ reside, is
      automatically imported.
        Rust behaves as though every /module/, including the /root module/, started
      with the following import: ~use std::prelude::v1::*;~

    - Naming a /module/ ~prelude~ is just a _convention_ that tells users it's
      meant to be imported using ~*~.
        Ususlly, this is the only use of ~*~, which is encouraged.

*** DONE Items, the Building Blocks of Rust - 170 =RE-READ=
    CLOSED: [2018-06-04 Mon 14:35]
    - A /module/ is made up of /items/.

    - There are several kinds of /item/, and the list is really a list of the
      language's major features:
      + Functions

      + Types =TODO= =RE-READ=
        * User-defined types are introduced using the ~struct~, ~enum~, and ~trait~
          keywords. =TODO= We'll dedicate a chapter to each of them.

        * A /struct's fields/, even /private fields/, are accessible *throughout*
          the /module/ where the /struct/ is declared.

          *Outside* the /module/, only /public fields/ are accessible.

        * It turns out that *enforcing /access control/ by /module/,* rather than
          by /class/ as in Java or C++, is surprisingly helpful for software design.
          - It cuts down on boilerplate /getter/ and /setter/ methods.

          - it largely eliminates the need for anything like C++ ~friend~ declarations.

          - A single /module/ can define several types that work closely together,
            such as perhaps ~frond::LeafMap~ and ~frond::LeafMapIter~, accessing
            each other's /private fields/ as needed, while still hiding those
            implementation details from the rest of your program.

      + Type aliases
        The Rust's ~type~ keyword is like the ~typedef~ in C++.
        ~type Table = HashMap<String, Vec<String>>;~

      + ~impl~ blocks
        It is used to attach /methods/ to /types/.
        For instance,
        #+BEGIN_SRC rust
          impl Cell {
              pub fn distance_from_origin(&self) -> f64 {
                  f64::hypot(self.x, self.y)
              }
          }
        #+END_SRC
        + ~impl~ blocks *CANNOT* be marked ~pub~.

        + /individual methods/ can be marked ~pub~ to make them visible outside
          the current /module/.

        + /Private methods/, like /private struct fields/, are *visible throughout
          the /module/ where they're declared.*

      + Constants =RE-READ=
        The ~const~ keyword introduces a constant.
        The syntax is just LIKE ~let~ except that it may be marked ~pub~, and
        the /type/ is *required*.

        * Uppercase names are conventional for constants.
          For instance: ~pub const ROOM_TEMPERATURE: f64 = 20.0; // Celsius~

        * The ~static~ keyword introduces a /static item/, which is nearly the
          same thing: ~pub static ROOM_TEMPERATURE: f64 = 68.0; // Fahrenheit~

        * A constant is a bit like a C++ ~#define:~ the value is compiled into
          your code every place it's used.

          A ~static~ is a variable that's set up *before* your program starts
          running and lasts until it exits.

        * Use /constants/ for /magic numbers and strings/ in your code.

          Use /statics/ for larger amounts of data, or any time you'll need to
          /borrow a reference/ to the constant value. =TODO= =???=

          =TODO=
          =From Jian=  What are the restrictions for ~const~ and ~static~ values???

        * /constants/ cannot be marked as ~mut~.

          /statics/ can be marked as ~mut~, but as discussed in Chapter 5 =TODO=,
          Rust has no way to enforce its rules about exclusive access on ~mut
          statics~ -- which means a /mut static/ is inherently *non-thread-safe*,
          and /safe code/ cannot use them at all:
          #+BEGIN_SRC rust
            static mut PACKETS_SERVED: usize = 0;
            println!("{} served", PACKETS_SERVED);  // error: use of mutable static
          #+END_SRC

          - Rust discourages global mutable state. For a discussion of the alternatives,
            see "Global Variables" on page 496. =TODO=

      + Modules
        A /module/ can contain /submodules/.
        It can be /public/ or /private/, like any other named item.

      + Imports
        ~use~ and ~extern crate~ declarations are /items/ too.

        Even though they're just aliases, they can be ~pub~!
        #+BEGIN_SRC rust
          // in plant_structures/mod.rs
          // ...
          pub use self::leaves::Leaf;
          pub use self::roots::Root;
        #+END_SRC
        * This means that ~Leaf~ and ~Root~ are /public items/ of the ~plant_structures~
          /module/. They're still simple aliases for ~plant_structures::leaves::Leaf~
          and ~plant_structures::roots::Root~.

        * Another example,
          The /standard prelude/ is written as just such a series of ~pub~ imports.

      + ~extern~ blocks
        Declare a collection of functions written in some other language
        (typically C or C++), and that your Rust code can call them.
        =TODO= See Chapter 21

    - Rust *warns* about /items/ that are _declared_, but _never used_:
      For example,
      #+BEGIN_SRC text
        warning: function is never used: `is_square`
          --> src/crates_unused_items.rs:23:9
           |
        23 | /         pub fn is_square(root: &Root) -> bool {
        24 | |             root.cross_section_shape().is_square()
        25 | |         }
           | |_________^
           |
      #+END_SRC
      This warning can be puzzling, because there are _TWO_ very different
      possible causes:
      + Perhaps this function really is dead code at the moment.
        OR
      + Maybe you meant to use it in other /crates/. =TODO= =TODO= =TODO=
        In that case, you need to *mark it and all enclosing modules as public.*

** DONE Turning a Program into a Library - 172
   CLOSED: [2018-06-04 Mon 17:44]
   You have a executable, and you want to add more facilities.

   You first want to factor out some of functionalities from the executable to a
   /library/.

   - The first step is to factor your existing project into _two_ parts:
     + a /library crate/, which contains all the shared code;

     + an /executable/, which contains the code that's only needed for your existing
       command-line program.

   - Read the (grossly simplified) original code:
     #+BEGIN_SRC rust
       struct Fern {
           size: f64,
           growth_rate: f64
       }

       impl Fern {
           /// Simulate a fern growing for one day.
           fn grow(&mut self) {
               self.size *= 1.0 + self.growth_rate;
           }
       }

       /// Run a fern simulation for some number of days.
       fn run_simulation(fern: &mut Fern, days: usize) {
           for _ in 0 .. days {
               fern.grow();
           }
       }

       fn main() {
           let mut fern = Fern {
               size: 1.0,
               growth_rate: 0.001
           };
           run_simulation(&mut fern, 1000);
           println!("final fern size: {}", fern.size);
       }
     #+END_SRC
     + Assume you have a trivial =Cargo.toml= file:
       #+BEGIN_SRC toml
         [package]
         name = "fern_sim"
         version = "0.1.0"
         authors = ["You <you@example.com>"]
       #+END_SRC

   - Turning this program into a library is easy. Here are the STEPS:
     1. *Rename* the file =src/main.rs= to =src/lib.rs=.

     2. *Add* the ~pub~ keyword to items in =src/lib.rs= that will be public features
        of our library.

     3. *Move* the ~main~ function to a temporary file somewhere.
        =TODO=
        We'll come back to it in a minute.

     The resulting =src/lib.rs= file looks like this:
     #+BEGIN_SRC rust
       pub struct Fern {
           pub size: f64,
           pub growth_rate: f64
       }

       impl Fern {
           /// Simulate a fern growing for one day.
           pub fn grow(&mut self) {
               self.size *= 1.0 + self.growth_rate;
           }
       }

       /// Run a fern simulation for some number of days.
       pub fn run_simulation(fern: &mut Fern, days: usize) {
           for _ in 0 .. days {
               fern.grow();
           }
       }
     #+END_SRC

   - We did nothing to the =Cargo.toml= file.
     By default, =cargo build= looks at the files in our source directory and
     figures out what to build. When it sees the file =src/lib.rs=, it knows to
     build a library.

   - The code in =src/lib.rs= forms the /root module/ of the library.
     Other /crates/ that USE our /library/ can ONLY access the /public items/ of
     this /root module/.

** DONE The =src/bin= Directory - 174
   CLOSED: [2018-06-04 Mon 17:58]
   - *Cargo has some built-in support for _small programs_ that live in the SAME
     codebase as a library.*

   - You can put our program and our library in the same codebase.
     Move the ~main~ function code to the file =src/bin/efern.rs=:
     #+BEGIN_SRC rust
       extern crate fern_sim;
       use fern_sim::{Fern, run_simulation};

       fn main() {
           let mut fern = Fern {
               size: 1.0,
               growth_rate: 0.001
           };

           run_simulation(&mut fern, 1000);
           println!("final fern size: {}", fern.size);
       }
     #+END_SRC

   - Because we've put this file into =src/bin=, the next time we run =cargo build=,
     Cargo will compile _BOTH_
     + the ~fern_sim~ library
       and
     + this program

   - Then you can run the ~efern~ program using =cargo run --bin efern=.
     Use =--verbose= to show the commands Cargo is running:
     #+BEGIN_SRC bash
       #$
       cargo build --verbose
       #Compiling fern_sim v0.1.0 (file:///.../fern_sim)
       #  Running `rustc src/lib.rs --crate-name fern_sim --crate-type lib ...`
       #  Running `rustc src/bin/efern.rs --crate-name efern --crate-type bin ...`

       #$
       cargo run --bin efern --verbose
       #    Fresh fern_sim v0.1.0 (file:///.../fern_sim)
       #  Running `target/debug/efern`

       # final fern size: 2.7169239322355985
     #+END_SRC

   - This time, we still didn't have to make any changes to =Cargo.toml=.
     Thanks to the Cargo default behavior -- it automatically treats =.rs= files
     in =src/bin= as extra programs to build.

   - If you decide to put the executable to its own isolated project, in a
     completely separate directory, you need to add a =Cargo.toml= listing
     ~fern_sim~ as a dependency (suppose these two projects in reside in the
     same directory):
     #+BEGIN_SRC toml
       [dependencies]
       fern_sim = { path = "../fern_sim" }
     #+END_SRC

** DONE Attributes - 175
   CLOSED: [2018-06-04 Mon 18:30]
   Any /item/ in a Rust program can be decorated with /attributes/.

   - /Attributes/ are Rust's catch-all syntax for writing
     + miscellaneous instructions
       and
     + advice to the compiler.

     =From Jian= This is like Java's /annotations/.

   - For example, suppose you're getting this warning:
     + You see a warning like:
       #+BEGIN_SRC text
         libgit2.rs: warning: type `git_revspec` should have a camel case name
             such as `GitRevspec`, #[warn(non_camel_case_types)] on by default
       #+END_SRC

       But you chose this name for a reason, and you wish Rust would shut up about
       it. You can use ~#[allow]~:
       #+BEGIN_SRC rust
         #[allow(non_camel_case_types)]
         pub struct git_revspec {
             // ...
         }
       #+END_SRC

     + /Canditional compilation/ is another feature that's written using an /attribute/,
       the ~#[cfg]~:
       #+BEGIN_SRC rust
         // Only include this module in the project if we're building for Android.
         #[cfg(target_os = "android")]
         mod mobile;
       #+END_SRC

   - You can find a COMPREHENSIVE /attributes/ usage in the *Rust Reference*.
     =TODO= The most commonly used options for ~#[cfg]~ are listed here:
     =TODO= table.

   - The ~#[inline]~ /attribute/.
     #+BEGIN_SRC rust
       /// Adjust levels of ions etc. in two adjacent cells
       /// due to osmosis between them.
       #[inline]
       fn do_osmosis(c1: &mut Cell, c2: &mut Cell) {
           // ...
       }
     #+END_SRC

     + There's one situation where /inlining/ _WON'T happen WITHOUT_ ~#[inline]~.

       When a function or method defined in one /crate/ is _called in another_
       /crate/, Rust WON'T /inline/ it UNLESS
       * it's /generic/ (it has /type parameters/)
         OR 
       * it's explicitly marked ~#[inline]~.

   - This ~#[inline]~ is only a suggestion.
     Rust also supports
     + the more insistent ~#[inline(always)]~;
     + never /inline/ ~#[inline(never)]~.

   - Some /attributes/, like ~#[cfg]~ and ~#[allow]~, can be attached to _a *whole*
     module_ and _apply to everything in it_.

     Others, like ~#[test]~ and ~#[inline]~ , must be attached to _individual_
     /items/.

   - The Rust Reference documents *the full set of supported attributes* in detail.

   - To attach an attribute to _a *whole* crate_, add it at the top of the =main.rs=
     or =lib.rs= file, *before* any /items/, and write ~#!~ instead of ~#~ , like
     this:
     #+BEGIN_SRC rust
       // libgit2_sys/lib.rs
       #![allow(non_camel_case_types)]

       pub struct git_revspec {
           // ...
       }

       pub struct git_error {
           // ...
       }
     #+END_SRC
     + The ~#!~ tells Rust to attach an /attribute/ to the _ENCLOSING_ /item/ rather
       than whatever comes next: in this case, the ~#![allow]~ /attribute/ attaches
       to the _WHOLE_ ~libgit2_sys~ crate, *not just* /struct/ ~git_revspec~.

   - ~#!~ can also be used *inside* /functions/, /structs/, and so on, *but it's
     only TYPICALLY used at the beginning of a file*, to attach an /attribute/ to
     the *whole* /module/ or /crate/.

     Some /attributes/ always use the ~#!~ syntax because they can *only be applied
     to a WHOLE /crate/.*

   - For example, the ~#![feature]~ attribute is used to *turn on* /unstable features/
     of the Rust language and libraries, /features/ that are EXPERIMENTAL, and therefore
     might _have bugs_ or might be _changed or removed in the future_.

     For instance, as we're writing this, Rust has experimental support for
     128-bit integer types ~i128~ and ~u128~ ; but since these types are
     experimental, you can only use them by

     + installing the Nightly version of Rust
       and
     + explicitly declaring that your crate uses them:
       #+BEGIN_SRC rust
         #![feature(i128_type)]

         fn main() {
             // Do my math homework, Rust!
             println!("{}", 9204093811595833589_u128 * 19973810893143440503_u128);
         }
       #+END_SRC

     Over time, the Rust team sometimes /stabilizes/ an /experimental feature/, so
     that it becomes a standard part of the language. The ~#![feature]~ /attribute/
     then becomes superfluous, and Rust generates a warning advising you to remove
     it.

** DONE Tests and Documentation - 178
   CLOSED: [2018-07-01 Sun 20:24]
   - A SIMPLE /unit testing framework/ is *built into* Rust.

   - tests :: /ordinary functions/ marked with the ~#[test]~ /attribute/.

   - For example,
     #+BEGIN_SRC rust
       #[test]
       fn math_works() {
           let x: i32 = 1;
           assert!(x.is_positive());
           assert!(x + 1, 2);
       }
     #+END_SRC

   - Use ~cargo test~ to run all the tests.
     #+BEGIN_SRC bash
       #$
       cargo test
       #   Compiling math_test v0.1.0 (file:///.../math_test)
       #     Running target/release/math_test-e31ed91ae51ebf22
       #
       # running 1 test
       # test math_works ... ok
       #
       # test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
     #+END_SRC
     You'll also see some output about /doc-tests/, which we'll get to in this
     section in a minute.

   - This *works the _same_ WHETHER* your /crate/ is an /executable/ or a /library/.

   - Use command like =cargo test math= to run tests that _contains_ the word ="math"=.

   - ~assert!(expr)~

   - ~assert_eq!(v1, v2)~ is just like ~assert!(v1 == v2)~,
     _EXCEPT_ that if the /assertion/ fails, the error message shows both values.

   - You can use these /macros/ in ordinary code, to *check /invariants/,*
     but note that ~assert!~ and ~assert_eq!~ are even used in /release builds/.

     Use ~debug_assert!~ and ~debug_assert_eq!~ if you only want them in /debug
     builds/.

   - To *TEST error cases*, add the ~#[should_panic]~ /attribute/ to your test to
     specify the error that should happen:
     #+BEGIN_SRC rust
       /// This test passes only if division by zero causes a panic
       /// as we claimed in the previous chapter.

       #[test]
       #[should_panic(expected="divide by zero")]
       fn test_divide_by_zero_error() {
           1 / 0; // should panic!
       }
     #+END_SRC

   - Use =cargo build= or =cargo build --release= *skip* the testing code.

   - By convention, when your tests get substantial enough to require support
     code, is to put them in a ~tests~ /module/ and declare the WHOLE /module/
     to be testing-only using the ~#[cfg(test)]~ /attribute/:
     #+BEGIN_SRC rust
       #[cfg(test)]   // include this module only when testing
       mod tests {
           fn roughly_equal(a: f64, b: f64) -> bool {
               (a - b).abs() < 1e-6
           }

           #[test]
           fn trig_works() {
               use std::f64::consts::PI;
               assert!(roughly_equal(PI.sin(), 0.0));
           }
       }
     #+END_SRC
     If you don't do this, in a /nontesting build/, ~roughly_equal~ is unused,
     and you will receive a warning like:
     ~warning: function is never used: `roughly_equal`~

   - /Rust's test/ harness uses _multiple threads_ to run several tests at a time,
     a nice side benefit of your Rust code being *thread-safe by default*.

     To disable this,
     + either run a single test, =cargo test testname=;
       or
     + set the /environment variable/ ~RUST_TEST_THREADS~ to ~1~.

*** DONE Integration Tests - 180
    CLOSED: [2018-06-25 Mon 23:20]
    - Integration tests :: =.rs= files that live in a =tests= directory _alongside_
         your project's =src= directory.

    - When you run =cargo test=, Cargo compiles each /integration test/ as a *SEPARATE,
      STANDALONE /crate/,* linked with your library and the Rust test harness. 

      Example:
      #+BEGIN_SRC rust
        // tests/unfurl.rs - Fiddleheads unfurl in sunlight

        extern crate fern_sim;
        use fern_sim::Terrarium;
        use std::time::Duration;

        #[test]
        fn test_fiddlehead_unfurling() {
            let mut world = Terrarium::load("tests/unfurl_files/fiddlehead.tm");
            assert!(world.fern(0).is_furled());
            let one_hour = Duration::from_secs(60 * 60);
            world.apply_sunlight(one_hour);
            assert!(world.fern(0).is_fully_unfurled());
        }
      #+END_SRC

      + The point of /integration tests/ is that they see your /crate/ *from the
        outside*, just as a user would. *They test the /crate/'s /public API/.*

        This is why we did _NOT_ put the /integration tests/ in to the ~fern_sim~
        project, and use the ~extern crate fern_sim;~.

    - ~cargo test~ runs *BOTH* /unit tests/ and /integration tests/.

      Use ~cargo test --test unfurl~ to run the /integration tests/ in the
      particular file =tests/unfurl.rs=.

*** DONE Documentation - 181
    CLOSED: [2018-07-01 Sun 19:50]
    The command ~cargo doc~ creates HTML documentation for your library.

    - ~cargo doc --no-deps --open~
      + ~--no-deps~:
        generate documentation only for your /crate/ itself, and NOT for all the
        /crates/ it depends on.

      + ~--open~:
        Open the documentation in your browser afterward.

    - Cargo saves the new documentation files in =target/doc=.
      The starting page is =target/doc/fern_sim/index.html=.

    - The documentation is generated from the ~pub~ features of your library, plus
      any ~doc~ comments you've attached to them.

    - Rust treats comments start with ~///~ as a ~#[doc]~ /attribute/:
      #+BEGIN_SRC rust
        /// Simulate the production of a spore by meiosis.
        pub fn produce_spore(factory: &mut Sporangium) -> Spore {
            // ...
        }
      #+END_SRC

      is exactly the same as:

      #+BEGIN_SRC rust
        #[doc = "Simulate the production of a spore by meiosis."]
        pub fn produce_spore(factory: &mut Sporangium) -> Spore {
            // ...
        }
      #+END_SRC

      + When you *compile* or *test* a library, these /attributes/ are IGNORED.
        When you *generate* documentation, ~doc~ comments on public features are
        included in the output.

      + Likewise, comments starting with ~//!~ are treated as ~#![doc]~ /attributes/,
        and are attached to the enclosing feature, typically a module or crate.

        For example, your =fern_sim/src/lib.rs= file might begin like this:
        #+BEGIN_SRC rust
          //! Simulate the growth of ferns, from the level of
          //! individual cells on up.
        #+END_SRC

    - The content of a ~doc~ comment is treated as /Markdown/.
      You can also fall back on HTML.

    - Code samples:
      + You can use ~`backticks`~ to set off bits of code in the middle of running
        text. In the output, these snippets will be formatted in a fixed-width font.

      + Larger code samples
        * can be added by indenting _FOUR_ spaces.
          #+BEGIN_SRC rust
            /// A block of code in a doc comment:
            ///
            ///     if everything().works() {
            ///         println!("ok");
            ///     }
          #+END_SRC

        * Or use Markdown fenced code blocks. This has exactly the same effect.
          #+BEGIN_SRC rust
            /// Another snippet, the same code, but written differently:
            ///
            /// ```
            /// if everything().works() {
            ///     println!("ok");
            /// }
            /// ```
          #+END_SRC

*** DONE Doc-Tests - 182
    CLOSED: [2018-07-01 Sun 20:24]
    When you run tests in a Rust library crate,
    Rust *checks* that all the code that _appears in your documentation_
    actually _runs and works_.

    - Each block of code that appears in a doc comment is compiled as a *SEPARATE*
      executable crate.

      Then, they are linked with your library.

      run it.

    - Here is a standalone example of a doc-test.
      Create a new project by running ~cargo new ranges~ and put this code in
      =ranges/src/lib.rs=:
      #+BEGIN_SRC rust
        use std::ops::Range;
        /// Return true if two ranges overlap.
        ///
        ///     assert_eq!(ranges::overlap(0..7, 3..10), true);
        ///     assert_eq!(ranges::overlap(1..5, 101..105), false);
        ///
        /// If either range is empty, they don't count as overlapping.
        ///
        ///     assert_eq!(ranges::overlap(0..0, 0..10), false);
        ///
        pub fn overlap(r1: Range<usize>, r2: Range<usize>) -> bool {
            r1.start < r1.end && r2.start < r2.end &&
                r1.start < r2.end && r2.start < r1.end
        }
      #+END_SRC
      + The two small blocks of code in the doc comment appear in the documentation
        generated by cargo doc , as shown in *Figure 8-3*.

      + Run it:
        #+BEGIN_SRC bash
          ## $ cargo test
          ##    Compiling ranges v0.1.0 (file:///.../ranges)
          ## ...
          ##    Doc-tests ranges
          ##
          ## running 2 tests
          ## test overlap_0 ... ok
          ## test overlap_1 ... ok
          ##
          ## test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
        #+END_SRC

        If you pass the ~--verbose~ flag to Cargo, you'll see that it's using
        ~rustdoc --test~ to run these two tests.
          Rustdoc stores each code sample in a separate file, adding a few lines
        of boilerplate code, to produce two programs.

        * Here's the first:
          #+BEGIN_SRC rust
            extern crate ranges;
            fn main() {
                assert_eq!(ranges::overlap(0..7, 3..10), true);
                assert_eq!(ranges::overlap(1..5, 101..105), false);
            }
          #+END_SRC

        * And here’s the second:
          #+BEGIN_SRC rust
            extern crate ranges;
            fn main() {
                assert_eq!(ranges::overlap(0..0, 0..10), false);
            }
          #+END_SRC

    - *The idea behind doc-test*
      + It is _NOT_ to put all the tests into comments.

      + Rather, you write the best possible documentation, and Rust makes sure the
        code samples in your documentation actually compile and run.

    - For the code that is necessary to make the code compile, but not for the
      documentation, you can put a ~#~ followed by a space at the beginning of
      that line.
      #+BEGIN_SRC rust
        /// Let the sun shine in and run the simulation for a given
        /// amount of time.
        ///
        ///     # use fern_sim::Terrarium;
        ///     # use std::time::Duration;
        ///     # let mut tm = Terrarium::new();
        ///     tm.apply_sunlight(Duration::from_secs(60));
        ///
        pub fn apply_sunlight(&mut self, time: Duration) {
            // ...
        }
      #+END_SRC

    - Sometimes it’s helpful to show a complete sample program in documentation,
      including a main function and an extern crate declaration. Obviously, if
      those pieces of code appear in your code sample, you do not also want
      Rustdoc to add them automatically. The result wouldn’t compile. Rustdoc
      therefore treats any code block containing the exact string fn main as a
      complete program, and doesn’t add anything to it.

    - Testing can be disabled for specific blocks of code.
      You need to use a fenced code block.
      + Compile, but not run:
        ~```no_run~

      + Don't compile
        ~```ignore~

    - For non-Rust code:
      + For example, use ~```c++~, ~```sh~, and ~```text~.

      + If ~rustdoc~ doesn't know the names, it will still recognize that the code
        block is NOT Rust, and it disables code highlighting as well as doc-testing.

** DONE Specifying Dependencies - 185
   CLOSED: [2018-06-04 Mon 20:14]
   - =EN=
     nuanced - 细微差别的

   - Several ways to specify dependencies:
     + NOT published on crate.io
       For instance, specify a Git repository URL and revision:
       ~image = { git = "https://github.com/Piston/image.git", rev = "528f19c" }~

       * As shown here, you can specify the particular ~rev~, ~tag~ , or ~branch~
         to use. (These are all ways of telling Git which revision of the source
         code to check out.)

     + Specify a directory that contains the crate's source code:
       ~image = { path = "vendor/image" }~

*** DONE Versions - 186
    CLOSED: [2018-06-04 Mon 20:09]
    - Cargo interprets the library /crates/ versions info in =Cargo.toml= *rather
      loosely*.

    - It uses the most recent version of a /crate/ that considered compatible with
      the given version base on the rules of /Semantic Versioning/.
      =TODO= Details Note

    - Ways to specify versions in a =Cargo.toml= file:
      | Cargo.toml line         | Meaning                                                       |
      |-------------------------+---------------------------------------------------------------|
      | image = "=0.10.0"       | Use only the exact version 0.10.0                             |
      | image = ">=1.0.5"       | Use 1.0.5 or any higher version (even 2.9, if it's available) |
      | image = ">1.0.5 <1.1.9" | Use a version that's higher than 1.0.5, but lower than 1.1.9  |
      | image = "<=2.7.10"      | Use any version up to 2.7.10                                  |

      + Another version specification you'll occasionally see is the wild card ~*~.
        This tells Cargo that any version will do. Unless some other =Cargo.toml=
        file contains a more specific constraint, Cargo will use _the latest
        available version_.

        =TODO=
        See https://doc.rust-lang.org/cargo/reference/publishing.html to learn
        more details.

    - All the above rules mentioned above is a convention that Cargo will use.
      A developer should follow this convention!!!

      If you break the compatibility, you should bump the version!!!

*** DONE ~Cargo.lock~ - 187
    CLOSED: [2018-06-04 Mon 20:14]
    - Rationale: =TODO=

    - Cargo has a built-in mechanism, the first time you build a project, Cargo
      outputs a =Cargo.lock= file that *records* the _exact version_ of every
      /crate/ it used.

    - Cargo upgrade to newer versions only when you tell it to,
      + either by manually bumping up the version number in your =Cargo.toml=

      + or by runing =cargo update=.

    - If your project is an /executable/, you should commit =Cargo.lock= to version
      control. That way, everyone who builds your project will consistently get the
      same versions.

      The HISTORY of your =Cargo.lock= file will record your dependency updates.

** DONE Publishing Crates to crates.io - 188
   CLOSED: [2018-07-01 Sun 05:49]
   1. Run ~cargo package~ in your project.
      =From Jian= must be top-level?

      - This command creates a file (in this case, =target/package/fern_sim-0.1.0.crate=)
        containing all your library's source files, including =Cargo.toml=.
          _This is the file that you'll upload to crates.io to share with the
        world._
          Cargo then _double-checks_ its work by building your library from the
        =.crate= file, just as your eventual users will.

      (You can use =cargo package --list= to see which files are included)

   2. You may see a warning message like:
      #+BEGIN_SRC text
        warning: manifest has no description, license, license-file, documentation,
        homepage or repository. See http://doc.crates.io/manifest.html#package-metadata
        for more info.
      #+END_SRC
      + This message tells you that the ~[package]~ section of =Cargo.toml= is
        missing some information that will be important to /downstream users/.

        *The URL in the warning is an excellent resource*
        =TODO= READ IT!!!

      + You can fix the warning by adding a few lines to =Cargo.toml=:
        #+BEGIN_SRC toml
          [package]
          name = "fern_sim"
          version = "0.1.0"
          authors = ["You <you@example.com>"]
          license = "MIT"
          homepage = "https://fernsim.example.com/"
          repository = "https://gitlair.com/sporeador/fern_sim"
          documentation = "http://fernsim.example.com/docs"
          description = """
          Fern simulation, from the cellular level up.
          """
        #+END_SRC
        Remember the downstream users can see all the information in this file,
        and before publishment, double-check to make sure that there is no private
        information that you don't want to others know.

   3. About the /dependencies/ of your /crate/.
      You may indicate dependencies in the way like ~image = {path = "vendor/image" }~.
      This ~path~ is a local path, which is NOT available for the other users. Therefore,
      Cargo *ignores* the ~path~ key in automatically downloaded libraries, and *this can
      cause build errors*.

      + How to fix it?
        Mostly your dependencies should be on crates.io too, and you should specify
        a version number instead of a =path=: ~image = "0.6.1"~

        * If you prefer, you can specify both:
          ~image = { path = "vendor/image", version = "0.6.1" }~
          *In this case, it is YOUR RESPONSIBILITY to make sure that the two
          stay in sync.*

   4. Get an account on crates.io.
      Your "Account Settings" page will show a =cargo login= command, like this
      one: =$ cargo login 5j0dV54BjlXBpUUbfIj7G9DvNl1vsWW1=

      Cargo saves the key in a configuration file, and the API key should be
      kept secret, like a password.

      *So run this command ONLY on a computer you control.*

   5. Run ~cargo publish~

** DONE Workspaces - 190
   CLOSED: [2018-06-04 Mon 19:48]
   Suppose you have written many /crates/. They live side by side in a SINGLE
   source repository:
   #+BEGIN_SRC text
     fernsoft/
     ├── .git/...
     ├── fern_sim/
     │   ├── Cargo.toml
     │   ├── Cargo.lock
     │   ├── src/...
     │   └── target/...
     ├── fern_img/
     │   ├── Cargo.toml
     │   ├── Cargo.lock
     │   ├── src/...
     │   └── target/...
     └── fern_video/
         ├── Cargo.toml
         ├── Cargo.lock
         ├── src/...
         └── target/...
   #+END_SRC
   Each /crate/ has its own /build directory/, =target=, which contains a separate
   build of all the crate's dependencies.

   These /build directories/ are *completely independent*.

   Even if two crates have a common dependency, they can’t share any compiled
   code.

   - Q :: This is wasteful. Do we have another way?

   - A :: You can save compilation time and disk space by using a Cargo /workspace/,
          a collection of /crates/ that share a COMMON /build directory/ and
          =Cargo.lock= file.
     1. Details:
       * Create a =Cargo.toml= file in your _repository's root directory_ and put
         these lines in it;
         #+BEGIN_SRC toml
           [workspace]
           members = ["fern_sim", "fern_img", "fern_video"]
         #+END_SRC
         =fern_sim=, =fern_img"=, and =fern_video= are your /crate/ directory names.

       * You also need to delete all the =Cargo.lock= files and =target= directories
         that exist in those subdirectories.

     2. Once you've done these steps above, =cargo build= in ANY /crate/ will
        automatically create and use a _shared_ /build directory/ under the root
        directory (in this case, =fernsoft/target=).

        The command =cargo build --all= builds all /crates/ in the CURRENT /workspace/.
        =cargo test= and =cargo doc= accept the =--all= option as well.

** DONE More Nice Things - 191
   CLOSED: [2018-06-04 Mon 19:26]
   In case you're NOT delighted yet, the Rust community has a few more odds and
   ends for you:
   - When you publish an open source /crate/ on *crates.io*, your documentation
     is _AUTOMATICALLY_ rendered and hosted on =docs.rs= thanks to Onur Aslan.

   - If your project is on GitHub, /Travis CI/ can build and test your code on
     EVERY push.

     It's surprisingly easy to set up; see travis-ci.org for details. If you're
     already familiar with Travis, this =.travis.yml= file will get you started:
     #+BEGIN_SRC yaml
       language: rust
       rust:
         - stable
     #+END_SRC

   - You can generate a =README.md= file _from_ your /crate/'s top-level doc-comment.
     This feature is offered as a _third-party Cargo plugin_ by Livio Ribeiro.

     Run =cargo install readme= to install the plugin, then =cargo readme --help=
     to learn how to use it.

   We could go on.

* DONE 9. Structs - 193
  CLOSED: [2018-06-06 Wed 22:19]
  - Rust has *three* kinds of /struct types/:
    + named-field,
    + tuple-like,
    + unit-like,

    which _differ in_ HOW YOU REFER TO THEIR COMPONENTS:
    + a named-field struct gives a name to each component

    + a tuple-like struct identifies them by the order in which they appear

    + a unit-like structs have no components at all; these are not common, but
      more useful than you might think. =TODO= =???=

  - In this chapter, we'll
    + explain each kind in DETAIL

    + show what they look like IN MEMORY.

    + cover
      * HOW to ADD /methods/ to them

      * HOW to DEFINE /generic struct types/ that work with many different component types

      * HOW to ask Rust to GENERATE implementations of common handy /traits/ for
        your /structs/.

** DONE Named-Field Structs - 193
   CLOSED: [2018-06-05 Tue 13:49]
   - Define (by example):
     #+BEGIN_SRC rust
       /// A rectangle of eight-bit grayscale pixels.
       struct GrayscaleMap {
           pixels: Vec<u8>,
           size: (usize, usize)
       }
     #+END_SRC
     + By convention
       * Use CamelCase for the name of /types/.
       * Use snake\under{}case for the name of /fields/ and /methods/.

   - Use (by example):
     #+BEGIN_SRC rust
       let width = 1024;
       let height = 576;
       let image = GrayscaleMap {
           pixels: vec![0; width * height],
           size: (width, height)
       };
     #+END_SRC

     A shorthand for populating fields from local variables or arguments with the
     same name:
     #+BEGIN_SRC rust
       fn new_map(size: (usize, usize), pixels: Vec<u8>) -> GrayscaleMap {
           assert_eq!(pixels.len(), size.8 * size.1);
           GrayscaleMap { pixels, size }
       }
     #+END_SRC

   - A /struct/ and its /fields/ are _private by default_, which means they can
     only be seen in the /module/ where it is defined.

     Use ~pub~ to make a /struct/ public! Don't forget to also add ~pub~ to
     fields.

   - =TODO= The first paragraph of Page 195 =???=

   - Use ~.. EXPR~ to initialize some /fields/ that has not been initialized.
     #+BEGIN_SRC rust
       struct Broom {
           name: String,
           height: u32,
           health: u32,
           position: (f32, f32, f32),
           intent: BroomIntent
       }

       /// Two possible alternatives for what a `Broom` could be working on.
       #[derive(Copy, Clone)]
       enum BroomIntent { FetchWater, DumpWater }

       // Receive the input Broom by value, taking ownership.
       fn chop(b: Broom) -> (Broom, Broom) {
           // Initialize `broom1` mostly from `b`, changing only `height`. Since
           // `String` is not `Copy`, `broom1` takes ownership of `b`'s name.
           let mut broom1 = Broom { height: b.height / 2, .. b };

           // Initialize `broom2` mostly from `broom1`. Since `String` is not
           // `Copy`, we must clone `name` explicitly.
           let mut broom2 = Broom { name: broom1.name.clone(), .. broom1 };

           // Give each fragment a distinct name.
           broom1.name.push_str(" I");
           broom2.name.push_str(" II");

           (broom1, broom2)
       }
     #+END_SRC

** DONE Tuple-Like Structs - 196
   CLOSED: [2018-06-05 Tue 14:01]
   - Example:
     ~struct Bounds(usize, usize);~

     It's like a tuple, but it must be created with the /struct/ name.
     ~let image_bounds = Bounds(1024, 768);~

   - The values held by a tuple-like /struct/ are called /elements/.

   - Access the /elements/ of a tuple just as you would a tuple's:
     ~assert_eq!(image_bounds.0 * image_bounds.1, 786432);~

   - Use ~pub~:
     ~pub struct Bounds(pub usize, pub usize);~

   - The expression ~Bounds(1024, 768)~ _looks like_ a /function call/, and in
     fact it is: defining the type also _implicitly defines_ a function:
     ~fn Bounds(elem0: usize, elem1: usize) -> Bounds { ... }~

   - At the most fundamental level,
     _named-field_ and _tuple-like_ /structs/ are very similar.

   - /Tuple-like structs/ are good for /newtypes/, /structs/ with a single component
     that you define to get stricter type checking. For example, if you are working
     with ASCII-only text, you might define a /newtype/ like this:
     ~struct Ascii(Vec<u8>);~

     Using this /type/ for your ASCII strings is much better than simply passing
     around ~Vec<u8>~ buffers and explaining what they are in the comments.

     =TODO=
     We'll give an example of using /newtypes/ for efficient type conversions in
     Chapter 21.

** DONE Unit-Like Structs - 197
   CLOSED: [2018-06-05 Tue 14:09]
   - Define (by example):
     #+BEGIN_SRC rust
       struct Onesuch;
     #+END_SRC

   - A value of such a type occupies no memory, much like the unit type ~()~.

     Rust doesn't bother actually storing /unit-like struct/ values in memory or
     generating code to operate on them, because it can tell everything it might
     need to know about the value from its type alone.
       But logically, an empty struct is a type with values like any other -- or
     more precisely, a type of which there is only a single value: ~let o = Onesuch;~

   - =TODO= =???= =???= =???= =???= =???= =???= =???= =???= =???=
     You've already encountered a /unit-like struct/ when reading about "Fields
     and Elements” on page 135. Whereas an expression like ~3..5~ is shorthand
     for the /struct value/ ~Range { start: 3, end: 5 }~ , the expression ~..~, a
     range omitting both end-points, is shorthand for the /unit-like struct/
     value ~RangeFull~.

   - =TODO= =TODO= =TODO=
     /Unit-like structs/ can also be useful when working with /traits/, which
     we'll describe in Chapter 11.

** DONE Struct Layout - 197
   CLOSED: [2018-06-05 Tue 14:20]
   - Figure 9-1. A ~GrayscaleMap~ structure in memory

     + UNLIKE C and C++, Rust _doesn't make specific promises_ about how it will
       order a struct's fields or elements in memory;
         Figure 9-1 shows only one possible arrangement.

     + However, Rust does promise to *store fields' values directly* IN the _struct's
       block of memory_.

       Whereas JavaScript, Python, and Java would put the ~pixels~ and ~size~ values
       each in their own heap-allocated blocks and have ~GrayscaleMap~'s fields
       point at them,
       =TODO= =???= =???= =???= =???= =???= =???= =???= =???= =???= =???= =???=
         Rust embeds pixels and size directly in the GrayscaleMap value. Only the
       heap-allocated buffer owned by the pixels vector remains in its own
       block.

   - You can ask Rust to lay out our structures in a way compatible with C and C++,
     using the ~#[repr(C)]~ /attribute/. =TODO= We'll cover this in detail in
     Chapter 21.

** DONE Defining Methods with ~impl~ - 198
   CLOSED: [2018-06-05 Tue 19:16]
   You can define /methods/ on ANY /struct type/ you define in a SEPARATE
   ~impl~ block.
   For example,
   #+BEGIN_SRC rust
     /// A last-in, first-out queue of characters.
     pub struct Queue {
         older: Vec<char>,  // older elements, eldest last.
         younger: Vec<char> // younger elements, youngest last.
     }

     impl Queue {
         pub fn new() -> Queue {
             Queue { older: Vec::new(), younger: Vec::new() }
         }

         /// Push a character onto the back of a queue.
         pub fn push(&mut self, c: char) {
             self.younger.push(c);
         }

         /// Pop a character off the front of a queue. Return `Some(c)` if there
         /// was a character to pop, or `None` if the queue was empty.
         pub fn pop(&mut self) -> Option<char> {
             if self.older.is_empty() {
                 if self.younger.is_empty() {
                     return None;
                 }

                 // Bring the elements in younger over to older, and put them in
                 // the promised order.
                 use std::mem::swap;
                 swap(&mut self.older, &mut self.younger);
                 self.older.reverse();
             }

             // Now older is guaranteed to have something. Vec's pop method
             // already returns an Option, so we're set.
             self.older.pop()
         }
     }
   #+END_SRC

   - /Methods/ are also known as /associated functions/.
     + /static method/: ~new~ -- usage: ~TypeName::method~
     + /instance methods/: ~push~ and ~pop~ -- usage: ~instanceName::method~

   - Rust lets you omit the type, and write ~self~, ~&self~, or ~&mut self~ as
     shorthand for ~self: Queue~, ~self: &Queue~ or ~self: &mut Queue~.

   - UNLIKE C++ and Java, the ~self~ must be used explicitly everytime!

   - _SYNTACTIC SUGAR_:
     Simply writing ~q.push(...)~ _borrows a mutable reference_ to ~q~ , as if
     you had written ~(&mut q).push(...)~, since that's what the ~push~
     /method/'s ~self~ requires.

   - Although you can have many separate ~impl~ blocks for a single type, they
     *MUST* all be in the SAME /crate/ that defines that type.

     =TODO=
     However, Rust does let you attach your own methods to other types; we'll
     explain how in Chapter 11.

   - Pros of separating a type's /methods/ from its definition:
     + It's always easy to find a type's /data members/.

       /Data members/ are NOT mixed with tens of /functoin members/ as in C++.

     + Although one can imagine fitting /methods/ into the syntax for /named-field
       structs/, it's not so neat for /tuple-like and unit-like structs/.
       =From Jian= TODO ??? IMAGINE ??

       Pulling methods out into an ~impl~ block allows a single syntax for all
       three.

     + The same ~impl~ syntax also serves neatly for implementing /traits/, which
       we will go into in Chapter 11.

** DONE Generic Structs - 202
   CLOSED: [2018-06-05 Tue 20:14]
   - For example,
     #+BEGIN_SRC rust
       pub struct Queue<T> {
           older: Vec<T>,
           younger: Vec<T>
       }
     #+END_SRC

     The corresponding ~impl~ block:
     #+BEGIN_SRC rust
       impl<T> Queue<T> {
           pub fn new() -> Queue<T> {
               Queue { older: Vec::new(), younger: Vec::new() }
           }

           pub fn push(&mut self, t: T) {
               self.younger.push(t);
           }

           pub fn is_empty(&self) -> bool {
               self.older.is_empty() && self.younger.is_empty()
           }

           // ...
       }
     #+END_SRC

   - Inside the ~impl~ block of ~Queue<T>~, you can use ~Self~ to represent ~Queue<T>~.

   - In the body of ~new~ you didn't write the /type parameter/ in the construction
     expression; simply writing ~Queue { ... }~ was good enough due to /type inference/
     -- since there is only one type that works for the function's return value.

   - However, you'll always need to supply /type parameters/ in /function signatures/
     and /type definitions/. Rust doesn't infer those; instead, it uses those
     /explicit types/ as the *basis* from which it infers types within function bodies.

   - With the help of /type inference/, you usully don't write code like:
     ~let mut q = Queue::<char>::new();~

     You can write:
     #+BEGIN_SRC rust
       let mut q = Queue::new();
       let mut r = Queue::new();

       q.push("CAD");  // apparently a Queue<&'static str>
       r.push(0.74);   // apparently a Queue<f64>

       q.push("BTC");  // Bitcoins per USD, 2017-5
       r.push(2737.7); // Rust fails to detect irrational exuberance
     #+END_SRC

** DONE Structs with Lifetime Parameters - 203
   CLOSED: [2018-06-05 Tue 21:03]
   For example, here's a structure that might hold references to the greatest
   and least elements of some slice:
   #+BEGIN_SRC rust
     struct Extrema<'elt> {
         greatest: &'elt i32,
         least: &'elt i32
     }

     fn find_extrema<'s>(slice: &'s [i32]) -> Extrema<'s> {
         let mut greatest = &slice[0];
         let mut least = &slice[0];

         for i in 1..slice.len() {
             if slice[i] < *least    { least    = &slice[i]; }
             if slice[i] > *greatest { greatest = &slice[i]; }
         }

         Extrema { greatest, least }
     }
   #+END_SRC
   - Since in the ~find_extrema~ function, the ~'s~ is the only /lifetime/, you
     can write ~fn find_extrema<'s>(slice: &'s [i32]) -> Extrema~ for short.

     You might have meant ~Extrema<'static>~, but that's pretty unusual.
     *Rust provides a shorthand for the common case!*

** DONE Deriving Common Traits for Struct Types - 204
   CLOSED: [2018-06-05 Tue 14:37]
   - After defining a /struct/, you would quickly notice that it's a bit of a pain:
     + you can't print it with ~println!("{:?}", point);~

     + it does NOT support the ~==~ and ~!=~ operators.

     Each of these features has a name in Rust -- ~Copy~, ~Clone~, ~Debug~, and
     ~PartialEq~. They are called /traits/. You can add these features to your
     /struct/:
     #+BEGIN_SRC rust
       #[derive(Copy, Clone, Debug, PartialEq)]
       struct Point {
           x: f64,
           y: f64
       }
     #+END_SRC

   - ~PartialCmp~ can also be derived to support the comparison operators ~<~, ~>~,
     ~<=~, and ~>=~. We haven't done so here, because comparing two points to see
     if one is "less than" the other is actually a pretty weird thing to do.

   - Implementing a /trait/ is automatically a *public* feature, so copyability,
     cloneability, and so forth are all part of your /struct's public API/ and
     should be chosen deliberately. =IMPORTANT=

   - =TODO=
     We'll describe Rust's standard /traits/ in detail, and tell which ones are
     ~#[derive]~ able, in Chapter 13.

** TODO Interior Mutability - 205
   - =EN=
     Interior - 內部

   - /Mutability/ is like anything else:
     in excess, it causes problems, but you often want just a little bit of it.

* DONE 10. Enums and patterns - 211
  CLOSED: [2018-06-06 Wed 22:19]
  - Rust /enumerations/ (simply /enums/) are the analog of /algebraic data types/
    (or known as /sum types/ or /discriminated unions/) in ML and Haskell.

** DONE Enums - 212
   CLOSED: [2018-06-06 Wed 19:59]
   - Simple, C-style enums are straightforward:
     #+BEGIN_SRC rust
       enum Ordering {
           Less,
           Equal,
           Greater
       }
     #+END_SRC
     + The ~Less~, ~Equal~, and ~Greater~ are called /constructors/.

     + /Function/ that use this /enum/:
       #+BEGIN_SRC rust
         use std::cmp::Ordering;

         fn compare(n: i32, m: i32) -> Ordering {
             if n < m {
                 Ordering::Less
             } else if n > m {
                 Ordering::Greater
             } else {
                 Ordering::Equal
             }
         }
       #+END_SRC
       * If you don't want the ~Ordering::~ part, you can ~use std::cmp::Ordering::*;~.
         However, this is NOT recommended.

       * If a /enums/ is in the current module, you can ~use self::EnumName::*;~

   - In memory, values of C-style enums are stored as integers.
     Occasionally it's useful to tell Rust which integers to use:
     #+BEGIN_SRC rust
       enum HttpStatus {
           Ok = 200,
           NotModified = 304,
           NotFound = 404,
           // ...
       }
     #+END_SRC
     Otherwise Rust will assign the numbers for you, starting at 0.

   - By default, Rust stores C-style enums using the smallest built-in integer type
     that can accomodate them.
     #+BEGIN_SRC rust
       use std::mem::size_of;

       assert_eq!(size_of::<Ordering>(), 1);
       assert_eq!(size_of::<HttpStatus>(), 2);  // The number `404` doesn't fit in a `u8`
     #+END_SRC

   - You can override Rust's choice of in-memory representation by adding a ~#[repr]~
     /attribute/ to the /enum/.
     =TODO=
     For details, see Chapter 21.

   - Casting a C-style /enum/ to an integer is allowed:
     ~assert_eq!(HttpStatus::Ok as i32, 200);~

     You cannot cast an integer to a /enum/ with ~as~.
     If you still want this, try
     #+BEGIN_SRC rust
       fn http_status_from_u32(n: u32) -> Option<HttpStatus> {
           match n {
               200 => Some(HttpStatus::Ok),
               200 => Some(HttpStatus::NotModified),
               200 => Some(HttpStatus::NotFound),
               // ...
               _   => None
           }
       }
     #+END_SRC
     or use the ~enum_primitive~ /crate/. =TODO=
     It contains a /macro/ that _autogenerates_ this kind of conversion code for
     you.

   - As with /structs/, the compiler will implement features like the ~==~ operator
     for you, but you have to ask.
     #+BEGIN_SRC rust
       #[derive(Copy, Clone, Debug, PartialEq)]
       enum TimeUnit {
           Seconds, Minutes, Hours, Days, Months, Years
       }
     #+END_SRC

   - /Enums/ can have /methods/, just like /structs/:
     #+BEGIN_SRC rust
       impl TimeUnit {
           /// Return the plural noun for this time unit.
           fn plural(self) -> &'static str {
               match self {
                   TimeUnit::Seconds => "seconds",
                   TimeUnit::Minutes => "minutes",
                   TimeUnit::Hours   => "hours",
                   TimeUnit::Days    => "days",
                   TimeUnit::Months  => "months",
                   TimeUnit::Years   => "years"
               }
           }

           // Return the singular noun for this time unit.
           fn singular(self) -> &'static str {
               self.plural().trim_right_matches('s')
           }
       }
     #+END_SRC

*** DONE Enums with Data - 214 - =Re-Write Notes=
    CLOSED: [2018-06-06 Wed 17:59]
    - Example:
      #+BEGIN_SRC rust
        /// A timestamp that has been deliberately rounded off, so our program
        /// says "6 months ago" instead of "February 9, 2016, at 9:49 AM".
        #[derive(Copy, Clone, Debug, PartialEq)]
        enum RoughTime {
            InThePast(TimeUnit, u32),
            JustNow,
            InTheFuture(TimeUnit, u32)
        }
      #+END_SRC
      The /enum variants/ that takes argument(s) are called /tuple variants/.

    - /Enums/ can also have /struct variants/, which contain /named fields/, just
      like ordinary structs:
      #+BEGIN_SRC rust
        enum Shape {
            Sphere { center: Point3d, radius: f32 },
            Cuboid { corner1: Point3d, corner2: Point3d }
        }

        let unit_sphere = Shape::Sphere { center: ORIGIN, radius: 1.0 };
      #+END_SRC

    - In all, Rust has *three* kinds of /enum variant/,
      echoing the *three* kinds of /struct/ we showed in the previous chapter.
      + /Variants with no data/ correspond to /unit-like structs/.

      + /Tuple variants/ look and function just like /tuple structs/.

      + /Struct variants/ have curly braces and /named fields/.

      *A single /enum/ can have /variants/ of _ALL three_ kinds.*
      #+BEGIN_SRC rust
        enum RelationshipStatus {
            Single,
            InARelationship,
            ItsComplicated(Option<String>),
            ItsExtremelyComplicated {
                car: DifferentialEquation,
                cdr: EarlyModernistPoem
            }
        }
      #+END_SRC

    - All constructors and fields of a public enum are automatically public.

*** DONE Enums in Memory - 215
    CLOSED: [2018-06-06 Wed 19:18]
    - In memory, /enums with data/ are stored as
      + a SMALL /integer tag/
      + enough memory to hold all the /fields/ of the /largest variant/.

    - The /tag field/ is for _Rust's INTERNAL USE_.
      It tells
      1. which /constructor/ created the value
      2. (therefore) which /fields/ it has.

    - As of Rust 1.17, ~RoughTime~ fits in _8 bytes_, as shown in Figure 10-1

      *Rust makes NO PROMISES about enum LAYOUT,* however, in order to leave the
      door open for future optimizations.
        In some cases, it would be possible to pack an /enum/ more efficiently
      than the figure suggests. We'll show later in this chapter how Rust can
      already *OPTIMIZE AWAY the /tag field/ for some enums*.
      =TODO= See the /Generic Enums with ~Box~ types/ in "Generic Enums" section.

*** DONE Rich Data Structures Using Enums - 216
    CLOSED: [2018-06-06 Wed 19:59]
    - Enums are also useful for quickly implementing tree-like data structures.

    - For example, suppose a Rust program needs to work with arbitrary JSON data.
      In memory, any JSON document can be represented as a value of this Rust
      type:
      #+BEGIN_SRC rust
        enum Json {
            Null,
            Boolean(bool),
            Number(f64),
            String(String),
            Array(Vec<Json>),
            Object(Box<HashMap<String, Json>>)
        }
      #+END_SRC

    - The JSON standard specifies the various data types that can appear in a JSON
      document:
      + ~null~
      + Boolean values
      + numbers
      + strings
      + arrays of JSON values
      + objects with string keys and JSON values.

      The ~Json~ /enum/ simply spells out these types.

    - This is not a hypothetical example.
      A very similar /enum/ can be found in ~serde_json~, _a serialization
      library for Rust structs_ that is one of the most-downloaded crates on
      _crates.io_.

    - The ~Box~ around the ~HashMap~ that represents an ~Object~ serves only to
      make all ~Json~ values more compact. =From Jian= eliminate /tag fields/???

      In memory, values of type ~Json~ take up *FOUR machine words*:

      + ~String~ and ~Vec~ values are THREE words, and Rust adds A /tag/ byte.

      + ~Null~ and ~Boolean~ values don't have enough data in them to use up all
        that space, but all values of one /enum/, here the ~Json~, must be the
        same size. The extra space goes unused.

        Figure 10-2 shows some examples of how ~Json~ values actually look in
        memory.

    - A ~HashMap~ is larger still.
      If we had to leave room for it in every ~Json~ value, they would be quite
      large, eight words or so.

      *But a ~Box<HashMap>~ is a single word*: it's just a pointer to
      heap-allocated data.

      We could make ~Json~ even _more compact_ *by boxing more fields*.

    - C++ Version of ~Json~:
      =TODO= =NOTE=

*** DONE Generic Enums - 218
    CLOSED: [2018-06-06 Wed 18:48]
    - Examples:
      #+BEGIN_SRC rust
        enum Option<T> {
            None,
            Some(T)
        }

        enum Result<T, E> {
            Ok(T),
            Err(E)
        }
      #+END_SRC

    - These types are familiar enough by now, and the syntax for /generic enums/
      is the _same as_ for /generic structs/.

    - =TODO= =???= =???=
      One unobvious detail is
      that Rust can eliminate the /tag field/ (See the Enums in Memory section)
      of ~Option<T>~ when the type ~T~ is a ~Box~ or some other /smart pointer
      type/. An ~Option<Box<i32>>~ is stored in memory as a single machine word,
      + 0 for ~None~
      + nonzero for ~Some~ boxed value.

    - Generic data structures can be built with just a few lines of code:
      #+BEGIN_SRC rust
        // An ordered collection of `T`s.
        enum BinaryTree<T> {
            Empty,
            NonEmpty(Box<TreeNode<T>>)
        }

        // A part of a `BinaryTree`.
        struct TreeNode<T> {
            element: T,
            left: BinaryTree<T>,
            right: BinaryTree<T>,
        }
      #+END_SRC
      These few lines of code define a ~BinaryTree~ type that can store any number
      of values of type ~T~.

      + Use it:
        #+BEGIN_SRC rust
          use self::BinaryTree::*;

          let jupiter_tree = NonEmpty(Box::new(TreeNode {
              element: "Jupiter",
              left: Empty,
              right: Empty
          }));

          let mercury_tree = Empty;

          let mars_tree = NonEmpty(Box::new(TreeNode {
              element: "Mars",
              left:     jupiter_tree,
              right:    mercury_tree,
          }));
        #+END_SRC

    - =TODO=
      Later in this chapter, we'll show how to implement an ~add~ /method/ on the
      ~BinaryTree~ type, so that we can instead write:
      #+BEGIN_SRC rust
        let mut tree = BinaryTree::Empty;

        for planet in planets {
            tree.add(planet);
        }
      #+END_SRC

    - =Re-Read= =TODO=
      No matter what language you’re coming from, creating data structures like
      BinaryTree in Rust will likely take some practice. It won’t be obvious at first where to
      put the Box es. One way to find a design that will work is to draw a picture like
      Figure 10-3 that shows how you want things laid out in memory. Then work back‐
      ward from the picture to the code. Each collection of rectangles is a struct or tuple;
      each arrow is a Box or other smart pointer. Figuring out the type of each field is a bit
      of a puzzle, but a manageable one. The reward for solving the puzzle is control over
      your program’s memory usage.

    - The price (real costs, costs at the first glance but actually investment)
      of using Rust's /enums/:
      + The memory cost of the /tag field/ in memory.
        Up to 8 bytes in the worst case, but that is usually negligible.

      + You cannot access fields of a /enum/ regardless of whether they are acutally
        present in the value -- even you know, you must also let the compiler know.

        =TODO= Use /patterns/ to solve this problem, and you will like this solution.

        =From Jian= This is NOT a cost. It's a cost at the first glance, and it
        is actually a good investment!

** DONE Patterns - 221
   CLOSED: [2018-06-06 Wed 22:19]
   - Example:
     #+BEGIN_SRC rust
       enum RoughTime {
           InThePast(TimeUnit, u32),
           JustNow,
           InTheFuture(TimeUnit, u32)
       }

       fn rough_time_to_english(rt: RoughTime) -> String {
           match rt {
               RoughTime::InThePast(units, count)   => format!("{} {} ago", count, units.plural()),
               RoughTime::JustNow                   => format!("just now"),
               RoughTime::InTheFuture(units, count) => format!("{} {} from now", count, units.plural())
           }
       }
     #+END_SRC

   - /Expressions/ *produce* values; /patterns/ *consume* values.
     The two use a lot of the same syntax.

   - Rust /patterns/ are their own little language, _summarized in Table 10-1_.
     | Pattern type            | Example                             | Notes                                         |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Literal                 | ~100~                               | Matches an exact value; the name of a ~const~ |
     |                         | ~"name"~                            | is also allowed                               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Range                   | ~0 ... 100~                         | Matches any value in range, including the end |
     |                         | ~'a' ... 'k'~                       | value                                         |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Wildcard                | ~_~                                 | Matches any value and ignores it              |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Variable                | ~name~                              | Like ~_~ but moves or copies the value into a |
     |                         | ~mut count~                         | new local variable                            |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | ref variable            | ~ref field~                         | Borrows a reference to the matched value      |
     |                         | ~ref mut field~                     | instead of moving or copying it               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Binding with subpattern | ~val @ 0 ... 99~                    | Matches the pattern to the right of ~@~,      |
     |                         | ~ref circle @ Shape::Circle { .. }~ | using the variable name to the left           |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Enum pattern            | ~Some(value)~                       |                                               |
     |                         | ~None~                              |                                               |
     |                         | ~Pet::Orca~                         |                                               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Tuple pattern           | ~(key, value)~                      |                                               |
     |                         | ~(r, g, b)~                         |                                               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Struct pattern          | ~Color(r, g, b)~                    |                                               |
     |                         | ~Point { x, y }~                    |                                               |
     |                         | ~Card { suit: Clubs, rank: n }~     |                                               |
     |                         | ~Account { id, name, .. }~          |                                               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Reference               | ~&value~                            | Matches only reference values                 |
     |                         | ~&(k, v)~                           |                                               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Multiple patterns       | ~'a' \vert{} 'A'~                         | In ~match~ only (not valid in ~let~ , etc.)   |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Guard expression        | ~x if x * x <= r2~                  | In ~match~ only (not valid in ~let~ , etc.)   |
     |-------------------------+-------------------------------------+-----------------------------------------------|

*** DONE Literals, Variables, and Wildcards in Patterns - 223
    CLOSED: [2018-06-06 Wed 20:38]
*** DONE Tuple and Struct Patterns - 225
    CLOSED: [2018-06-06 Wed 20:43]
    - /Patterns/ like ~Point { x: x, y: y }~ are common when MATCHING /structs/,
      and the redundant names are visual clutter, so Rust has a _shorthand_ for
      this: ~Point {x, y}~.

    - Even with the shorthand, it is cumbersome to match a large struct when we
      only care about a few fields:
      #+BEGIN_SRC rust
        match get_account(id) {
            // ...
            Some(Account {
                    name, language, // <--- the 2 things we care about
                    id: _, status: _, address: _, birthday: _, eye_color: _,
                    pet: _, security_question: _, hashed_innermost_secret: _,
                    is_adamantium_preferred_customer: _ }) =>
                language.show_custom_greeting(name)
        }
      #+END_SRC

      =IMPORTANT=
      To avoid this, use ~..~ to tell Rust you don't care about any of the other fields:
      #+BEGIN_SRC rust
        Some(Account { name, language, .. }) =>
            language.show_custom_greeting(name)
      #+END_SRC

*** DONE Reference Patterns - 226
    CLOSED: [2018-06-06 Wed 22:00]
    - Example:
      + With compiler error
        #+BEGIN_SRC rust
          match account {
              Account { name, language, .. } => {
                  ui.greet(&name, &language);
                  ui.show_settings(&account);  // error: use of moved value `account`
              }
          }
        #+END_SRC
        * This code works if ~name~ and ~language~ are copiable.

        * If ~name~ and ~language~ are NOT copiable, we bind ~name~ and ~language~
          with *moving* them, we cannot use ~account~ in the
          ~ui.show_settings(&account);~ line.
          
      + Fix it:
        #+BEGIN_SRC rust
          match account {
              Account { ref name, ref language, .. } => {
                  ui.greet(&name, &language);
                  ui.show_settings(&account);
              }
          }
        #+END_SRC

    - Use ~ref mut~ to /borrow/ /mutable reference/.

    - Match /reference/:
      #+BEGIN_SRC rust
        match sphere.center() {
            &Point3d { x, y, z } => ......
        }
      #+END_SRC

    - =NOTE= =TODO=
      This is a bit tricky because Rust is following a pointer here, an action
      we usually associate with the ~*~ operator, not the ~&~ operator.

      + Rationale:
        The thing to remember is that *patterns and expressions are natural
        opposites*. For instance,
        * The expression ~(x, y)~ makes two values into a new /tuple/,
          but the pattern ~(x, y)~ does the opposite: it matches a /tuple/ and
          _breaks_ out the two values.

        * It's the same with ~&~.
          - In an /expression/, ~&~ *creates* a /reference/.
          - In a /pattern/, ~&~ *matches* a /reference/.

    - Matching a reference follows all the rules we’ve come to expect.

      + Lifetimes are enforced.

      + You CANNOT get ~mut~ access via a /shared reference/.

      + You CANNOT /move/ a value out of a /reference/, even a ~mut~ /reference/.

        (When we match ~&Point3d { x, y, z }~, the variables ~x~, ~y~, and ~z~
        receive copies of the coordinates, leaving the original ~Point3d~ value
        intact. It works because those fields are /copyable/.)

        If we try the same thing on a ~struct~ with *noncopyable* /fields/,
        we'll get an error:

        #+BEGIN_SRC rust
          match friend.borrow_car() {
              Some(&Car { engine, .. }) => // error: can't move out of borrow
                  //     ...
              None => {}
          }

        #+END_SRC

        Scrapping a borrowed car for parts is not nice, and Rust won't stand for
        it. You can use a ~ref~ pattern to /borrow/ a /reference/ to a part. You
        just don't own it.
        ~Some(&Car { ref engine, .. }) => // ok, engine is a reference~

*** DONE Matching Multiple Possibilities - 229
    CLOSED: [2018-06-06 Wed 20:44]
    - Use ~|~ to match several /patterns/.

    - Use ~...~ to match a whole /range/ (=IMPORTANT= INCLUSIVE) of values.
      #+BEGIN_SRC rust
        match next_char {
            '0' ... '9' =>
                self.read_number(),
            'a' ... 'z' | 'A' ... 'Z' =>
                self.read_word(),
            ' ' | '\t' | '\n' =>
                self.skip_whitespace(),
            _ =>
                self.handle_punctuation()
        }
      #+END_SRC

*** DONE Pattern Guards - 229
    CLOSED: [2018-06-06 Wed 20:49]
    #+BEGIN_SRC rust
      match robot.last_known_location() {
          Some(point) if self.distance_to(point) < 10 =>
              short_distance_strategy(point),
          Some(point) =>
              long_distance_strategy(point),
          None =>
              searching_strategy()
      }
    #+END_SRC
    + Use ~Some(ref point)~
      if the ~point~ above is NOT copyable.

*** DONE ~@~ patterns - 230
    CLOSED: [2018-06-06 Wed 20:57]
    - On success, instead of creating variables for parts of the matched value,
      it creates a single variable ~x~ and *moves* or *copies* the whole value
      into it. =Re-Read=

    - For example, say you have this code:
      #+BEGIN_SRC rust
        match self.get_selection() {
            rect @ Shape::Rect(..) =>
                optimized_paint(&rect),
            // Shape::Rect(top_left, bottom_right) =>
            //     optimized_paint(&Shape::Rect(top_left, bottom_right)),

            other_shape =>
                paint_outline(other_shape.get_outline()),
        }
      #+END_SRC

    - ~@~ patterns are also useful with ranges:
      #+BEGIN_SRC rust
        match chars.next() {
            Some(digit @ '0' ... '9') => read_number(digit, chars),
            // ...
        }
      #+END_SRC

*** DONE Where Patterns Are Allowed - 230
    CLOSED: [2018-06-06 Wed 22:14]
    - Although patterns are most prominent in match expressions, they are also
      allowed in several other places, _typically in place of an identifier._

    - For example:
      #+BEGIN_SRC rust
        // ...unpack a struct into three new local variables
        let Track { album, track_number, title, .. } = song;

        // ...unpack a function argument that's a tuple
        fn distance_to((x, y): (f64, f64)) -> f64 { ... }

        // ...iterate over keys and values of a HashMap
        for (id, document) in &cache_map {
            println!("Document #{}: {}", id, document.title);
        }

        // ...automatically dereference an argument to a closure
        // (handy because sometimes other code passes you a reference
        // when you'd rather have a copy)
        let sum = numbers.fold(0, |a, &num| a + num);
      #+END_SRC

      + =From Jian= I don't quite understand the last line? I mean what's special???

    - irrefutable patterns :: patterns that always match.

    - /Irrefutable patterns/ are special in Rust.
      They're the only /patterns/ allowed in the four places shown here (after
      ~let~ , in /function/ arguments, after ~for~ , and in /closure/ arguments).

    - /Refutable patterns/ are allowed in ~match~, ~if let~, and ~while let~.

*** DONE Populating a Binary Tree 232
    CLOSED: [2018-06-06 Wed 22:19]
    #+BEGIN_SRC rust
      impl<T: Ord> BinaryTree<T> {

          fn add(&mut self, value: T) {
              match *self {
                  BinaryTree::Empty =>
                      ,*self = BinaryTree::NonEmpty(Box::new(TreeNode {
                          element: value,
                          left: BinaryTree::Empty,
                          right: BinaryTree::Empty
                      })),
                  BinaryTree::NonEmpty(ref mut node) =>
                      if value <= node.element { node.left.add(value); }
                      else                     { node.right.add(value); }
              }
          }

      }

      let mut tree = BinaryTree::Empty;
      tree.add("Mercury");
      tree.add("Venus");
    #+END_SRC

** DONE The Big Picture - 233 =Re-Read=
   CLOSED: [2018-06-06 Wed 20:03]
   TODO: NOTES

* DONE 11. Traits and Generics - 235
  CLOSED: [2019-07-29 Mon 01:30]
  - Rust supports /polymorphism/ with two related features:
    + /generics/ -- =From Jian= /parametric polymorphism/.
      For instance, ~Vec<T>~

    + /traits/ -- =From Jian= /Ad hoc polymorphism/ inspired by Haskell's /typeclass/.
      For instance, things that have ~.write()~ /method/, including ~File~'s and
      ~TcpStream~'s.
      * Functionally, Rust /traits/ are like the /rich interfaces/ supported by Scala;

      * The way to use Rust /traits/ is like the way to use Haskell's /typeclasses/,
        and the only but import difference is to use certain /trait/ it must be
        in scope!!!

  - About /traits/:
    + We'll also use /traits/ to add /extension methods/ to EXISTING /types/,
      even built-in types like ~str~ and ~bool~.

    + We'll explain
      * *why* adding a /trait/ to a /type/ costs no extra memory
        and
      * *how* to use /traits/ *without virtual method call overhead*.

    + We'll see that built-in /traits/ are the hook into the language that Rust
      provides for /operator overloading/ and _other features_.

    + =TODO= =???=
      We'll cover /the ~Self~ type/, /associated methods/, and /associated types/,
      *three features Rust lifted from Haskell* that elegantly solve problems that
      other languages address with workarounds and hacks.

  - About /generics/.

  - /Generics/ and /traits/ are closely related.

    Rust makes us declare the ~T: Ord~ requirement (called a /bound/) up front,
    before using the ~<=~ operator to compare two values of type ~T~.

    + So we'll also talk about =TODO=
      * how ~&mut Write~ and ~<T: Write>~ are *similar*,
      * how they're *different*, and
      * how to *choose between* these two ways of using /traits/.

** DONE Using Traits - 237
   CLOSED: [2018-06-21 Thu 19:19]
   - Most often,
     _a /trait/ _represents_ a *capability*: something a type can do._

     + For example:
       * A value that implements ~std::io::Write~
         can write out bytes.

       * A value that implements ~std::iter::Iterator~
         can produce a sequence of values (=From Jian= Lazily???).

       * A value that implements ~std::clone::Clone~
         can make clones of itself in memory.

       * A value that implements ~std::fmt::Debug~
         can be printed using ~println!()~ with the ~{:?}~ /format specifier/.

   - These /traits/ in the entry above are all part of /Rust's standard library/,
     and many standard types implement them.
     + ~Write~ is implemented by
       * ~std::fs::File~: writes bytes *to a local file*

       * ~std::net::TcpStream~ writes *to a network connection*

       * ~Vec<u8>~ appends some data *to the end*

     + ~Iterator~ is implemented by
       * ~Range<i32>~ (the type of ~0..10~) and some _iterator types_ associated
         with /slices/, /hash tables/

     + *Most* _standard library types_ implement ~Clone~.
       =TODO= =???= =???=
       The *EXCEPTIONS* are mainly types like ~TcpStream~ that _represent more
       than just data in memory._

     + Likewise, *most* standard library types support ~Debug~ .

   - In Rust, there is one _UNUSUAL rule_ about /trait methods/:
     *the /trait/ itself must be in scope. Otherwise, all its /methods/ are
     HIDDEN.*
     =from Jian= Acutally, both Haskell and Scala use this kind of implicit
                 behavior to support /ad hoc polymorphism/.
     For example,
     #+BEGIN_SRC rust
       use std::io::Write;

       let mut buf: Vec<u8> = vec![];
       buf.write_all(b"hello")?;  // This is ok only when we have the `use` line above.
     #+END_SRC
     + This rule is the result of a Rust design:
       you can *add new methods* to any type -- even standard library types like
       ~u32~ and ~str~.

     + This rule help resolving most name confliction problems in DIFFERENT /traits/.
       This can happen in languages like Java.

   - If a /trait/ is inside /the standard prelude/, you don't need a ~use~ statement.
     TODO We'll cover many of them in Chapter 13.

   - Rust's /traits/' /methods/ are like /virtual methods/ in C++ and C#, while,
     in Rust, there is *NO* /runtime overhead/ *except* the ONLY case when you
     call through things the only info you know is about its trait, like ~& mut
     Write~. Use the code below as an illustration:
     + *Without* /runtime overhead/ (the compiler knows the ~write_all~ method is
       called from a ~Vec<u8>~):
       #+BEGIN_SRC rust
         use std::io::Write;

         let mut buf: Vec<u8> = vec![];
         buf.write_all(b"hello")?;  // no runtime overhead
       #+END_SRC

     + *With* /runtime overhead/:
       #+BEGIN_SRC rust
         use std::io::Write;

         // Here `&mut Write` is the type of `writer` below.
         // If we can't infer its exact type, there is runtime overhead.
         writer.write_all(b"hello")?;
       #+END_SRC

     Rust can even /inline/ the /method/ (C++ and C# will _often_ do the same,
     _although the posibility of subclassing sometimes precludes this_.)

*** DONE Trait Objects - 238
    CLOSED: [2019-07-27 Sat 22:39]
    - There are *two* ways of using /traits/ to write /polymorphic/ code in Rust:
      + /trait objects/, which is presented in this section
      + /generics/

    - Rust does *NOT* permit variables of type ~Write~:
      #+BEGIN_SRC rust
        use std::io::Write;

        let mut buf: Vec<u8> = vec![];
        let writer: Write = buf;  // error: `Write` does NOT have a constant size
      #+END_SRC
      + *The _SIZE_ of a variable has to be known at compile time*, and
        types that implement ~Write~ _can be ANY size_.

      + It seems C# and Java do not have this restriction.
        *However*, the reality is they acutally save a /reference/, which as a
        known size -- this is *NOT* the case in Rust,
        *Rust does NOT have a /reference/ BY DEFAULT.*

      + Q :: Then how can we create a ~writer~ like above but with the size info?
      + A :: Write out the /reference/ EXPLICITLY:
        #+BEGIN_SRC rust
          let writer: &mut Write = &mut buf;
        #+END_SRC

      + trait object :: a /reference/ to a /trait/ type.
        * Like any other /references/, a /trait object/
          - points to some value
          - has a /lifetime/
          - can be either ~mut~ or /shared/

      + What makes a /trait object/ different is that
        Rust usually does *NOT* know the type of the referent at /compile time/.
          So a /trait object/ includes a little *EXTRA INFORMATION about the
        referent's type*. This is strictly for Rust's own use behind the scenes:
        when you call ~writer.write(data)~, Rust needs the type information to
        _dynamically call_ the right ~write~ /method/ depending on the type of
        ~*writer~.

        * You can't query the type information directly,
          Therefore, *rust does NOT support /downcasting/ from the /trait object/
          to a /concrete type/.*
          ~&mut Write~ back to a concrete type like ~Vec<u8>~.

          =From Jian=
          This is very important!!! 
          Solving a problem is the process of information reduction.
          In most cases, you should NOT add information back -- the opposite direction
          of information reduction.

        * =From Jian=
          - Q :: Does rust have reflection???
          - A :: It seems not! If there is reflection, I think /downcast/ /trait
                 objects/ to _concrete types_ can happen. 

*** DONE Trait Object Layout - 239
    CLOSED: [2019-07-28 Sun 00:05]
    - _In memory_,
      a /trait object/ is a /fat pointer/ (takes up two machine words):
      + a /pointer/ to the /value/
      + a /pointer/ to the _table_ representing the /value's type/.

    - Figure 11-1. /Trait objects/ in memory
      =IMPORTANT=

    - Page 239 - last paragraph - =From Jian= No Note with my first glance
      =Re-Read= later!

    - Seasoned C++ programmers will notice the Rust and C++ use memory a bit differently:
      + In C++
        The /vtable (virtual table) pointer/, or /vptr/, is stored *as part of*
        the /struct/.

        * =from Jian=
          The result of this design is the size of a specific struct depends on
          how many super types it implemented.
            This is _not friendly to_ one struct implementing many super types.

          - This design is reasonable for C++. Its super type implementation is
            NOT a open system -- implement many super types will make a struct
            too complicated.

          - Rust chooses a different design, this is because Rust's traits
            implementation is designed for a open system. In a specific scope
            you usually will never have a too many implemented traits -- only
            the ones you imported will be used!
              This design make Rust have a better extensibility, as well as
            control the size of the struct.

      + In Rust
        Rust uses /fat pointers/ instead. Why does Rust design like this?
        * The /struct/ itself contains nothing but its fields.
            This way, one /struct/ can implement dozens of /traits/ *without
          containing dozens of /vptrs/.*

        * Even types like ~i32~, which aren't big enough to accommodate a /vptr/,
          can implement /traits/.
          =From Jian= This successfully solve the *dilemma* in most other OOP
          languages:
          - If basic types are object, they can be two heavy (this is true in most
            OOP language, but not true in Rust).
            =From Jian= for example, Java's ~Integer~.

          - If basic types are NOT object, they can't have /methods/ (this is true
            in most OOP language, for example, Java's ~int~ but not true in Rust).
            =From Jian= for example, Java's ~int~.

    - Rust AUTOMATICALLY *converts* /ordinary references/ into /trait objects/
      when needed.
        This is why we're able to pass ~&mut local_file~ to ~say_hello~ in this
      example:
      #+BEGIN_SRC rust
        let mut local_file = File::create("hello.txt")?;
        say_hello(&mut local_file)?;
      #+END_SRC
      + Here ~&mut local_file~ is of type ~&mut File~, which is a _CONCRETE type_,
        NOT a /trait object/.
          The ~sey_hello~ /method/ accepts a parameter of type ~&mut Write~, which
        is a /trait object/.

      + Likewise, Rust will happily convert a ~Box<File>~ to a ~Box<Write>~, a
        value that _OWNS_ a /writer/ in the /heap/:
        ~let w: Box<Write> = Box::new(local_file);~

    - This kind of conversion is the *ONLY way* to *create* a /trait object/.

      What the computer is actually doing here is very simple:
      At the point where the conversion happens, Rust knows the referent's true
      type (in this case, ~File~), so it just adds the address of the
      appropriate /vtable/, turning the /regular pointer/ into a /fat pointer/.

*** DONE Generic Functions - 240
    CLOSED: [2019-07-28 Sun 00:25]
    - Let's re-write the ~say_hello()~ that toke a /trait object/ as a /generic
      function/:
      #+BEGIN_SRC rust
        fn say_hello<W: Write>(out: &mut W) -> std::io::Result<()> {
            out.write_all(b"hello world\n")?;
            out.flush()
        }
      #+END_SRC
      + Only the signature has changed:
        * ~fn say_hello(out: &mut Write)~ is a /plain function/.

        * ~fn say_hello<W: Write>(out: &mut W)~ is a /generic function/.

      + Which type ~W~ stands for depends on how the /generic function/ is used:
        * ~say_hello(&mut local_file)?;~ calls ~say_hello::<File>~

        * ~say_hello(&mut bytes)?;~ calls ~say_hello::<Vec<u8>>~

        Rust generates separate machine code for this version of the function,
        calling the corresponding ~Vec<u8>~ /methods/.

      + It's seldom necessary to write the concrete /type parameter(s)/ type(s)
        explicitly.

        Only when there is not any arguments that provide useful clues, you may
        have to spell it out:
        #+BEGIN_SRC rust
          // calling a generic method collect<C>() that takes no arguments
          let v1 = (0 .. 1000).collect();  // error: can't infer type
          let v1 = (0 .. 1000).collect::<Vec<i32>>();  //ok
        #+END_SRC

    - *CONVENTION*
      /Type parameters/ are usually *single uppercase letters*.

    - Sometimes we need *MULTIPLE* abilities from a /type parameter/,
      Here we are planning to determine which values are the most common? The
      usual way is to use the values as key in a /hash table/. That means the
      values need to support the ~Hash~ and ~Eq~ operations. Then the /bound/ of
      ~T~ CANNOT be ~<T: Debug>~. It should be:
      #+BEGIN_SRC rust
        fn top_ten<T: Debug + Hash + Eq>(values: &Vec<T>) { ... }
      #+END_SRC
      + Some types implement ~Debug~ , some implement ~Hash~ , some support ~Eq~;
        and a few, like ~u32~ and ~String~ , implement ALL three, as shown in
        *Figure 11-2*.

    - It's also possible for a /type parameter/ to have *NO* /bounds/ at all,
      BUT you can't do much with a value if you haven't specified any /bounds/ for it.
      You can
      + /move/ it.
      + put it into a /box/ or /vector/.
      That's about it.

    - _In SYNTAX_, we have two ways to write down the /bounds/:
      + cluttered
        #+BEGIN_SRC rust
          /// Run a query on a large, partitioned data set.
          /// See <http://research.google.com/archive/mapreduce.html>.
          fn run_query<M: Mapper + Serialize, R: Reducer + Serialize>(
              data: &DataSet, map: M, reduce: R) -> Results
          { ... }
        #+END_SRC

      + non-cluttered
        #+BEGIN_SRC rust
          fn run_query<M, R>(data: &DataSet, map: M, reduce: R) -> Results
              where M: Mapper + Serialize,
                    R: Reducer + Serialize
          { ... }
        #+END_SRC
        * This kind of ~where~ clause is also allowed on /generic structs/,
          /generic enums/, /type aliases/, and /methods/ -- *ANYWHERE /bounds/
          are permitted*.

    - A /generic function/ can have BOTH
      + /lifetime parameters/
      + /type parameters/.

    - /Lifetime parameters/ *COME FIRST*:
      #+BEGIN_SRC rust
        /// Return a reference to the point in `candidates` that's
        /// closest to the `target` point.
        fn nearest<'t, 'c, P>(target: &'t P, candidates: &'c [P]) -> &'c P
            where P: MeasureDistance
        { ... }
      #+END_SRC

    - /Lifetimes/ *NEVER* have any impact on /machine code/.
      Two calls to ~nearest()~ using the SAME /type/ ~P~, but DIFFERENT /lifetimes/,
      will _call the SAME_ /compiled function/.
        Only *differing* /types/ cause Rust to compile _MULTIPLE_ copies of a
      /generic function/.

    - TODO We'll cover generic traits later in this chapter.
      
*** DONE Which to Use - 243
    CLOSED: [2019-07-28 Sun 01:29]
    *The CHOICE of whether to use /trait objects/ or /generic/ code is _SUBTLE_.*
    Since both features are based on /traits/, _they have a lot IN COMMON_.

    - /Trait objects/
      + *WHENEVER* you need a /collection/ of values of MIXED /types/. =EVERYDAY USE=
        * It is technically possible to make /generic/ salad:
          #+BEGIN_SRC rust
            trait Vegetable {
                // ...
            }
  
            struct Salad<V: Vegetable> {
                veggies: Vec<V>
            }
          #+END_SRC
          _BUT_ you won't like this -- since the element of each /vector/ must
          have constant size, you can only put one kind of vegetable in one salad,
          for example, ~Salad<IcebergLettuce>~, which is usually not what you
          want.

          Here is the /trait object/ solution:
          #+BEGIN_SRC rust
            struct Salad {
                // Here you must use `Box<Vegetable>`, which has a constant size.
                // Actually, `Vegetable` itself is NOT a trait object!
                veggies: Vec<Box<Vegetable>>
            }
          #+END_SRC

      + *Reduce* the total amount of compiled code. =Rarely USE=
          Rust may have to compile a /generic function/ MANY times, *once for
        each type* it's used with -- this could _make the binary large_, a
        phenomenon called /code bloat/ in C++ circles.
          Constrained environments do exist, though most of time we don't need
        to consider this.

    - /Generics/
      *ALL the other* situations except those above (
       1. same trait mixed types collections;
       2. constrained hardware environements
      ).
      + Advantage 1: *speed*.
        NO /dynamic dispatch/.
        For a /generic function/, each available type has its own copy/version of
        compiled code.
        * For instance, a GENERIC ~min()~ can be as fast as ~min_u8()~, ~min_u64()~

        * Or consider this /generic function/ call:
          #+BEGIN_SRC rust
            let mut sink = std::io::sink();
            say_hello(&mut sink)?;
          #+END_SRC
          Because of the nature of ~sink~, Rust can use the known information
          (from /generics/). In short, Rust has all the information it needs to
          optimize away this function entirely -- the compiler knows both
          ~Sink::write_all()~ and ~Sink::flush()~ do nothing, and neither method
          ever returns an error.

          - Compare to the behavior with /trait object/:
            Rust _NEVER_ knows that type of value a /trait object/ points to _UNTIL_
            /runtime/. So, in this example, even if you pass a ~Sink~, the *OVERHEAD*
            of _calling virtual methods_ and _checking for errors_ still applies.

      + Advantage 2: NOT EVERY /trait/ can support /trait objects/.
        /Traits/ support several features, such as /static methods/, that work
        only with /generics/:
        they rule out /trait objects/ entirely. We'll point out these features as
        we come to them. TODO

** DONE Defining and Implementing Traits - 245
   CLOSED: [2019-07-28 Sun 05:08]
   You can only put the mandatory definitions in a trait implementation.
   Helper functions must be saved in a separate ~impl~ block. For instance,
   #+begin_src rust
     impl Broom {
         /// Helper function used by Broom::draw() below.
         for broomstick_range(&self) -> Range<i32> {
             self.y - self.height - 1 .. self.y
         }
     }

     impl Visible for Broom {
         fn draw(&self, canvas: &mut Canvas) {
             for y in self.broomstick_range() {
                 // ...
             }
             // ...
         }
         // ...
     }
   #+end_src

*** DONE Default Methods - 246
    CLOSED: [2019-07-28 Sun 01:35]
    =From Jian= Like Scala, Rust support /trait default methods/.
    The design idea is the same as Scala:
    The /methods/ of /trait/ can be categoried as /core method(s)/ and /common
    method(s)/. The /common method(s)/ depend on the /core methods/ -- which are
    the most specific for different types, and they should be implemented by the
    user who define this type. The /common method(s)/ are the /methods/ that
    mostly are not very specific for different types, and the DEFAULT
    implementation can fulfill most expectations.

    For example, the ~std::io::Write~ has a /default method/ ~write_all~.
    #+BEGIN_SRC rust
      trait Write {
          fn write(&mut self, buf: &[u8]) -> Result<usize>;

          fn flush(&mut self) -> Result<()>;

          fn write_all(&mut self, buf: &[u8]) -> Result<()> {
              let mut bytes_written = 0;
              while bytes_written < buf.len() {
                  bytes_written += self.write(&buf[bytes_written..])?;
              }
              Ok(())
          }
          // ...
      }
    #+END_SRC

    Implement ~Write~ for ~Sink~:
    #+BEGIN_SRC rust
      use std::io::{Write, Result};

      impl Write for Sink {
          fn write(&mut self, buf: &[u8]) -> Result<usize> {
              // Claim to have successfully written the whole buffer.
              Ok(buf.len())
          }

          fn flush(&mut self) -> Result<()> {
              Ok(())
          }
      }
    #+END_SRC

*** DONE Traits and Other People's Types - 247
    CLOSED: [2019-07-28 Sun 04:27]
    Rust lets you implement ANY /trait/ on ANY /type/,
    AS LONG AS _EITHER_ the /trait/ _OR_ the /type/ is introduced in the
    *CURRENT* /crate/.

    - /extension trait/

    - You can even use a /generic ~impl~ block/ to add an /extension trait/ to a
      whole family of types at once. /Generic implementation/:
      #+BEGIN_SRC rust
        use std::io::{self, Write};

        /// Trait for values to which you can send HTML.
        trait WriteHtml {
            fn write_html(&mut self, &HtmlDocument) -> io::Result<()>;
        }

        /// You can write HTML to any std::io writer.
        impl<W:Write> WriteHtml for W {
            fn write_html(&mut self, html: &HtmlDocument) -> io::Result<()> {
                // ...
            }
        }
      #+END_SRC

    - We said earlier that when you _implement_ a /trait/,
      *either the /trait/ or the /type/ must be _NEW_ in the _current_ /crate/.*
      + This is the /coherence rule/,
        which helps Rust ensure that /trait/ implementations are *unique*.

    - Then, for example, you can't ~impl Write for u8~, because both ~Write~ and
      ~u8~ are defined in the standard library. If this is allowed, there could
      be multiple implementations of ~Write~ for ~u8~, in different crates, and
      Rust would *have NO reasonable way* to decide which implementation to use for
      a given method call.

    - C++ has a similar uniqueness restriction:
      the /One Definition Rule/. In typical C++ fashion, it isn't enforced by the
      compiler, except in the simplest cases, and you get /undefined behavior/ if
      you break it.

*** DONE ~Self~ in Traits - 249
    CLOSED: [2019-07-28 Sun 04:50]
    Some /methods/ in a /trait/ contains parameters or return values of
    *corresponding* /type/ in the implementation for a specific /type/. Since
    you don't have the names of types who will implement this /trait/, we use
    the name ~Self~, which means this /type/ always matches ~this~.

    =From Jian= As the ~this.type~ in Scala.

    - Example:
      #+BEGIN_SRC rust
        pub trait Clone {
            fn clone(&self) -> Self;

            // ...
        }
      #+END_SRC

    - A /trait/ that uses the ~Self~ type is *incompatible* with /trait object/.

    - Example of mis-use ~Self~
      #+BEGIN_SRC rust
        pub trait Spliceable {
            fn splice(&self, other: &Self) -> Self;
        }

        impl Spliceable for CherryTree {
            fn splice(&self, other: &Self) -> Self {
                // ...
            }
        }

        impl Spliceable for Mammoth {
            fn splice(&self, other: &Self) -> Self {
                // ...
            }
        }

        // ERROR: the trait `Spliceable` cannot be made into an object
        fn splice_anything(left: &Spliceable, right: &Spliceable) {
            let combo = left.splice(right);
            // ...
        }
      #+END_SRC
      + The ~splice_anything~ /method/ uses /trait object/, but this is wrong.

        At /compile time/, the compiler cannot know the exact types of ~left~ and
        ~right~, and it can't check the compatibility of the two ~Self~'s of
        each parameter (their types can be one of ~CherryTree~ or ~Mammoth~).

        * =IMPORTANT=
          /Trait objects/ are _really intended for_ the SIMPLEST kinds of /traits/,
          the kinds that could be implemented using /interfaces/ in Java or
          abstract base classes in C++.
            The more ADVANCED FEATURES of /traits/ are useful, but they _can't
          coexist with_ /trait objects/ because with /trait objects/, you *lose
          the type information* Rust needs to type-check your program.

      + Now, had we wanted genetically improbable splicing, we could have designed
        a /trait object/-friendly /trait/:
        #+BEGIN_SRC rust
          pub trait MegaSpliceable {
              fn splice(&self, other: &MegaSpliceable) -> Box<MegaSpliceable>;
          }
        #+END_SRC
        This /trait/ is *COMPATIBLE* with /trait objects/.
        There's no problem type-checking calls to this ~.splice()~ /method/
        because the type of the argument other is not required to match the type
        of ~self~, as long as both types are ~MegaSpliceable~.
        =Re-Read=

*** DONE Subtraits - 250
    CLOSED: [2019-07-28 Sun 04:54]
    You can declare that _a /trait/ is an EXTENSION of another /trait/._

    - For example,
      #+BEGIN_SRC rust
        /// Someone in the game world, either the player or some other
        /// pixie, gargoyle, squirrel, ogre, etc.
        trait Creature: Visible {
            fn position(&self) -> (i32, i32);

            fn facing(&self) -> Direction;

            // ...
        }
      #+END_SRC

      Then every /type/ implements ~Creature~ MUST also implement the ~Visible~:
      #+BEGIN_SRC rust
        impl Visible for Broom {
            // ...
        }

        impl Creature for Broom {
            // ...
        }
      #+END_SRC
      + Here implementation order is not import

      + =from Jian=
        Not only *decouple* /type/ and /traits/, also *decouple* the implementations
        of /traitS/.

*** DONE Static Methods - 251
    CLOSED: [2019-07-28 Sun 05:08]
    NOT like most OOP languages, Rust /trait/ CAN INCLUDE both /constructors/ and
    /static methods/ -- /methods/ that don't have ~self~ related first parameters.

    - For example:
      #+BEGIN_SRC rust
        trait StringSet {
            /// Return a new empty set.
            fn new() -> Self;

            /// Return a set that contains all the strings in `strings`.
            fn from_slice(strings: &[&str]) -> Self;

            /// Find out if this set contains a particular `value`.
            fn contains(&self, string: &str) -> bool;

            /// Add a string to this set.
            fn add(&mut self, string: &str);
        }
      #+END_SRC

    - In *nongeneric* code, these functions can be called using ~::~ syntax, just
      like any other /static method/.
      #+begin_src rust
      
      #+end_src

    - In *generic* code, it's the same, except the type is often a type variable,
      as in the call to ~S::new()~ shown here:
      #+begin_src rust
        /// Return the set of words in `document` that aren't in `wordlist`.
        fn unknown_words<S: StringSet>(document: &Vec<String>, wordlist: &S) -> S {
            let mut unknowns = S::new();
            for word in document {
                if !wordlist.contains(word) {
                    unknowns.add(word);
                }
            }
            unknowns
        }
      #+end_src

    - As we mentioned before, also like Java and C# interfaces, ONLY /trait objects/
      do _NOT support_ /static methods/.

        If you want to call /static methods/ from a /trait objects/, the ~Self~
      in the /trait/ definition must be bound by ~Sized~.

      =from Jian= =START=
      This is similar to Scala's ~self =>~ syntax, though this syntax in Scala is
      NOT used for supporting /static method/ in /trait/, acutally Scala does NOT
      allow this.
      #+begin_src scala
        trait A { self: Bound =>
          // ...
        }
      #+end_src
      =from Jian= =END=

      This /bound/ tells Rust that /trait objects/ are excused from supporting
      this /method/. ~StringSet~ /trait objects/ are then allowed; they _still
      do NOT support_ the TWO /static methods/, but you can *create* them and
      *use* them to call ~.contains()~ and ~.add()~.

      =TODO= =???= =???= =???=
      =EXAMPLE REQUIRED!!!=
        The same trick works for ANY OTHER /method/ that is _INCOMPATIBLE_ with
      /trait objects/.
      =TODO= =???= =???= =???=

      (We will forgo the rather tedious technical explanation
      of why this works, but the Sized trait is covered in Chapter 13.)
      #+BEGIN_SRC rust
        trait StringSet {
            fn new() -> Self
                where Self: Sized;

            fn from_slice(strings: &[&str]) -> Self
                where Self: Sized;

            fn contains(&self, string: &str) -> bool;

            fn add(&mut self, string: &str);
        }
      #+END_SRC

** DONE Fully Qualified Method Calls - 252
   CLOSED: [2019-07-28 Sun 05:15]
   - A /method/ is just a special kind of function.
     _FOUR_ equivalent calls:
     #+BEGIN_SRC rust
       "hello".to_string();

       str::to_string("hello");

       ToString::to_string("hello");

       <str as ToString>::to_string("hello");
     #+END_SRC
     + The second form looks exactly _LIKE_ (not "IS") a /static method/ call.
       Just pass the ~self~ (here it is "hello") as the first argument.

     + Since ~to_string~ is a /method/ of the standard ~ToString~ /trait/,
       we have the third and the forth.

     + Except the most often used ~"hello".to_string();~,
       the other forms are called /qualified method calls/.

       * /qualified method calls/ specify the /type/ or /trait/ that a /method/
         is associated with.

         The forth one, with the angle brackets, specifies BOTH /type/ and
         /trait/: a /fully qualified method call/.

   - When you write calls like ~"hello".to_string()~, using the ~.~ operator,
     you do _NOT say exactly which_ ~to_string~ /method/ you're calling.
       Rust has a _method lookup algorithm_ that figures this out, depending on
     the types, deref coercions, and so on.
       With /fully qualified calls/, you can say *EXACTLY* which method you mean,
     and *that can help in a few odd cases*.
     + When more than one /methods/ have the *SAME NAME*.
       For example, ~Outlaw~ has two ~.draw()~ /methods/ from _TWO_ different
       /traits/, one for drawing it on the screen and one for interacting with
       the law:
       #+BEGIN_SRC rust
         outlaw.draw();  // error: draw on screen or draw pistol?

         Visible::draw(&outlaw);  // ok: draw on screen
         HasPistol::draw(&outlaw);  // ok: corral
       #+END_SRC
       It's better solution if you can rename one conflict method name.
       However, sometimes you can't.

     + When the type of the ~self~ argument *CANNOT be inferred*:
       #+BEGIN_SRC rust
         let zero = 0;  // type unspecified; could be `i8`, `u8`, ...

         zero.abs();  // error: method `abs` not found
         i64::abs(zero);  // ok
       #+END_SRC
       =From Jian= this is just a example for illustration, in the real world, you
       may prefer write the declaration as ~let zero = 0_i64;~

     + When using the function itself as a function value:
       =From Jian= I think this is often used!!!
       =IMPORTANT=
       #+BEGIN_SRC rust
         let words: Vec<String> =
             line.split_whitespace()  // iterator produces `&str` values
                 .map(<str as ToString>::to_string)  // ok
                 .collect();
       #+END_SRC

     + When calling /trait methods/ in /macros/.
       =TODO= We'll explain in Chapter 20.

   - /Fully qualified syntax/ also works for /static methods/.
     In the previous section, we wrote ~S::new()~ to create a new set in a
     /generic function/.
       We could also have written ~StringSet::new()~ or ~<S as StringSet>::new()~.

** DONE Traits That Define Relationships Between Types - 253
   CLOSED: [2019-07-28 Sun 17:04]
   We have looked /traits/ that _stands alone_.
   /Traits/ can also *describe relationships BETWEEN types*.
   For example,

   - /Trait/ ~std::iter::Iterator~
     *relates* _each iterator type_ *with* _the type of value it produces_.
     =from Jian= Dependent type???

   - /Trait/ ~std::ops::Mul~
     *relates* types that can be multiplied -- the LHS and RHS of ~*~ doesn't
     need to be the same type, the result type is also need to be decided when
     LHS and RHS have different types.

   - The ~rand~ /crate/ includes both
     + a /trait/ for /random number generators (~rand::Rng~)/
     + a /trait/ for /types/ that _can be randomly generated (~rand::Rand~)_.
     *The /traits/ themselves define exactly how these types work together.*

   - The key skill here is
     the ability to
     + _read traits and method signatures_
       AND
     + _figure out what they say about the types involved_.

*** DONE Associated Types (or How Iterators Work) - 254
    CLOSED: [2019-07-28 Sun 16:21]
    Example:
    #+BEGIN_SRC rust
      pub trait Iterator {
          type Item;

          fn next(&mut self) -> Option<Self::Item>;

          // ...
      }
    #+END_SRC
    - The ~Item~ is called /associated type/.

    - In the signature of ~next(&mut self) -> Option<Self::Item>~, we use
      ~Self::Item~, not just plain ~Item~, BECAUSE ~Item~ is a feature of _EACH_
      type of /iterator/, *NOT a standalone type*.

    - Implement ~Iterator~ for a type:
      #+BEGIN_SRC rust
        // (code from the std::env standard library module)
        impl Iterator for Args {
            type Item = String;

            fn next(&mut self) -> Option<String> {
                // ...
            }
            // ...
        }
      #+END_SRC

    - Generic code can use associated types:
      #+BEGIN_SRC rust
        /// Loop over an iterator, storing the values in a new vector.
        fn collect_into_vector<I: Iterator>(iter: I) -> Vec<I::Item> {
            let mut results = Vec::new();

            for value in iter {
                results.push(value);
            }
            results
        }
      #+END_SRC
      + this is actually the ~.collect()~ /method/ in the standard library.
        TODO See Chapter 15!
        =From Jian= I don't know if the details are same.

    - Another example:
      #+BEGIN_SRC rust
        /// Print out all the values produced by an iterator
        fn dump<I>(iter: I)
            where I: Iterator
        {
            for (index, value) in iter.enumerate() {
                println!("{}: {:?}", index, value);  // error
            }
        }

        // error[E0277]: the trait bound `<I as std::iter::Iterator>::Item:
        //               std::fmt::Debug` is not satisfied
        //     --> traits_dump.rs:10:37
        //     |
        //  10
        //     |                             ^^^^^ the trait `std::fmt::Debug`
        //     |                             is not implemented for
        //     |                             `<I as std::iter::Iterator>::Item`
        //     |
        //     = help: consider adding a
        //             `where <I as std::iter::Iterator>::Item: std::fmt::Debug` bound
        //     = note: required by `std::fmt::Debug::fmt`
      #+END_SRC
      The compiler has already tell you how to eliminate this error.
      However, you don't need to write it in such a long form:
      + ~use std::fmt::Debug;~
        and
      + re-write the ~where~ line to ~where I: Iterator, I::Item: Debug~
        OR
        specify the ~I::Item~ exact type with ~where I: Iterator<Item=String>~

        * This ~where I: Iterator<Item=String>~ syntax can be used *ANYWHERE* the
          name of a /trait/ can be used, including trait object types:
          #+BEGIN_SRC rust
            fn dump(iter: &mut Iterator<Item=String>) {
                for (index, s) in iter.enumerate() {
                    println!("{}: {:?}", index, s);
                }
            }
          #+END_SRC

    - /Associated types/ are generally useful WHENEVER a /trait/ needs to cover
      _more than just /methods/._
      + In a /thread pool library/, a ~Task~ /trait/,
        _REPRESENTING_ a unit of work, could have an /associated ~Output~ type/.
        TODO ???

      + A ~Pattern~ trait, representing a way of searching a string, could have
        an /associated ~Match~ type/,
        _REPRESENTING_ all the information gathered by matching the pattern to
        the string.
        #+BEGIN_SRC rust
          trait Pattern {
              type Match;

              fn search(&self, string: &str) -> Option<Self::Match>;
          }

          /// You can search a string for a particular character.
          impl Pattern for char {
              /// A "match" is just the location where the
              /// character was found.
              type Match = usize;

              fn search(&self, string: &str) -> Option<usize> {
                  // ...
              }
          }
        #+END_SRC

      + A library for working with relational databases might have a /Database
        Connection trait/ with /associated types/ _REPRESENTING_ /transactions/,
        /cursors/, /prepared statements/, and so on.

    - /Associated types/ are perfect for cases where each implementation has one
      specific related type:
      each type of ~Task~ produces a particular type of ~Output~;
      each type of ~Pattern~ looks for a particular type of ~Match~.

      TODO ???
      However, as we'll see, some relationships among types are not like this.

*** DONE Generic Traits (or How Operator Overloading Works) - 257
    CLOSED: [2019-07-28 Sun 16:21]
    #+BEGIN_SRC rust
      /// std::ops::Mul, the trait for types that support `*`.
      pub trait Mul<RHS> {
          /// The resulting type after applying the `*` operator
          type Output;

          /// The method for the `*` operator
          fn mul(self, rhs: RHS) -> Self::Output;
      }
    #+END_SRC
    This is just a illustration of /generic traits/, the real ~Mul~ /trait/ looks
    like this:
    #+BEGIN_SRC rust
      pub trait Mul<RHS=Self> {
          // ...
      }
    #+END_SRC
    - The syntax ~RHS=Self~ means that ~RHS~ defaults to ~Self~.
      + If I write ~impl Mul for Complex~, without specifying ~Mul~'s type parameter,
        it means ~impl Mul<Complex> for Complex~.

      + If I write ~where T: Mul~, it means ~where T: Mul<T>~.

    - In Rust, you can overload ~*~ by implementing the ~Mul~ /trait/.

*** DONE Buddy Traits (or How ~rand::random()~ Works) - 258 - TODO =RE-READ=
    CLOSED: [2019-07-28 Sun 17:04]
    There's one more way to _use /traits/ to EXPRESS RELATIONSHIPS BETWEEN /types/._

    - buddy traits :: simple traits that designed to work together.

    - The ~rand~ crate for generating random numbers.
      The main feature of ~rand~ is the ~random()~ function.
      + Example:
        #+begin_src rust
          use rand::random;

          let x = random::<f64>();   // a number, 0.0 <= x < 1.0
          let b = random::<bool>();  // true or false
        #+end_src

    - For many programs, the code above is enough.
      But the ~rand~ /crate/ also offers several different, but *interoperable*,
      /random number generators/.

    - All the /random number generators/ in the library implement a common /trait/:
      #+begin_src rust
        /// A random number generator.
        pub trait Rng {
            fn next_u32(&mut self) -> u32;
            // ...
        }
      #+end_src
      + An ~Rng~ is simply a value that can spit out integers on demand.

      + The ~rand~ library provides a few different implementations, including
        * ~XorShiftRng~: a fast pseudorandom number generator;
        * ~OsRng~: much slower, but truly unpredicatable, for use in cryptography.

    - The /buddy trait/ is called ~Rand~:
      #+begin_src rust
        /// A type that can be randomly generated using an `Rng`.
        pub trait Rand: Sized {
            fn rand<R: Rng>(rng: &mut R) -> Self;
        }
      #+end_src
      + Types like ~f64~ and ~bool~ implement this /trait/.
        _Pass_ any /random number generator/ to their ~::rand()~ /method/, and it
        _returns_ a random value:
        #+begin_src rust
          let x = f64::rand(rng);
          let b = bool::rand(rng);
        #+end_src

    - In fact the ~random()~ we see in the beginning of this section is nothing
      but a thin wrapper that passes a globally allocated ~Rng~ to this ~rand~
      /method/. One way to implement it is like this:
      #+begin_src rust
        pub fn random<T: Rand>() -> T {
            T::rand(&mut global_rng())
        }
      #+end_src

    - TODO ???
      When you see /traits/ that use OTHER /traits/ as /bounds/ (the way ~Rand::rand()~
      uses ~Rng~), you know that those two (=from Jian= or more??) /traits/ are
      mix-and-match: _any_ ~Rng~ can generate values of _every_ ~Rand~ type.
      + Since the /methods/ involved are /generic/, Rust generates optimized
        machine code for each combination of ~Rng~ and ~Rand~ that your program
        actually uses.

    - TODO =IMPORTANT=
    - TODO =IMPORTANT=
    - TODO =IMPORTANT=
    - TODO =IMPORTANT=

    - SUMMARY:
      In the last three sections, we've shown *three ways* /traits/ can _describe
      relationships between types_.
        *All of these can also be seen as ways of _avoiding_ virtual method
      /overhead/ and /downcasts/,* since _they allow Rust to know MORE /concrete
      types/ at /compile time/._

** DONE Reverse-Engineering Bounds - 260
   CLOSED: [2019-07-29 Mon 01:19]
   Sometimes you don't have one single /trait/ you need to implements some generics,
   and you can use the compiler error messages as a guide to complete your code.

   =from Jian= At the end of this section, we will see how does our code can be
   simplified when there is a proper single trait covers all what we want.

   Suppose we have:
   #+BEGIN_SRC rust
     fn dot(v1: &[i64], v2: &[i64]) -> i64 {
         let mut total = 0;
         for i in 0 .. v1.len() {
             total = total + v1[i] * v2[i];
         }
         total
     }
   #+END_SRC
   You want a generics version to support some other numeric types.

   - Step 1: Replace the type with type parameters (*non-compilable*)
     #+BEGIN_SRC rust
       fn dot<N>(v1: &[N], v2: &[N]) -> N {
           let mut total = 0;
           for i in 0 .. v1.len() {
               total = total + v1[i] * v2[i];
           }
           total
       }
     #+END_SRC
     Try to compile, and Rust complains about the use of ~+~ and ~*~ and the
     type of ~0~. These problem can be solve by using ~Add~, ~Mul~, and
     ~Default~ as bounds of ~N~.

   - Step 2: Add /bounds/ (*non-compilable*)
     #+BEGIN_SRC rust
       use std::ops::{Add, Mul};

       fn dot<N: Add + Mul + Default>(v1: &[N], v2: &[N]) -> N {
           let mut total = N::default();
           for i in 0 .. v1.len() {
               total = total + v1[i] * v2[i];
           }
           total
       }
     #+END_SRC
     ~Add~ and ~Mul~ has no promise about the output type, and the compiler will
     complain again.

   - Step 3: Add /constraint/ to the _output types_. (*non-compilable*)
     #+BEGIN_SRC rust
       use std::ops::{Add, Mul};

       fn dot<N>(v1: &[N], v2: &[N]) -> N
           where N: Add<Output=N> + Mul<Output=N> + Default {
           let mut total = N::default();
           for i in 0 .. v1.len() {
               total = total + v1[i] * v2[i];
           }
           total
       }
     #+END_SRC
     Try to compile, and the error message is like:
     #+begin_src text
       error[E0508]: cannot move out of type `[N]`, a non-copy array
        --> traits_generic_dot_3.rs:7:25
         |
       7 | total = total + v1[i] * v2[i];
         |                 ^^^^^ cannot move out of here
     #+end_src
     The compiler doesn't know ~v1[i]~ is a copiable value.

   - Step 4: Add ~Copy~ as a /bound/
     #+BEGIN_SRC rust
       use std::ops::{Add, Mul};

       fn dot<N>(v1: &[N], v2: &[N]) -> N
           where N: Add<Output=N> + Mul<Output=N> + Default + Copy {
           let mut total = N::default();
           for i in 0 .. v1.len() {
               total = total + v1[i] * v2[i];
           }
           total
       }
     #+END_SRC

   - Discussion:
     Rust has no single ~Number~ /trait/ in the standard library that included
     all the operators and methods we wanted to use.
       There's a popular open source crate called ~num~ that defines such a
     /trait/! Add it to the =Cargo.toml= and written:
     #+BEGIN_SRC rust
       extern crate num;
       use num::Num;

       fn dot<N: Num + Copy>(v1: &[N], v2: &[N]) -> N {
           // Since now we use `Num` instead of `Default`, the default value
           // becomes `N::zero()`
           let mut total = N::zero();
           for i in 0 .. v1.len() {
               total = total + v1[i] * v2[i];
           }
           total
       }
     #+END_SRC
     + Just as in /object-oriented programming/,
       the _right_ /interface/ makes everything nice,
       in /generic programming/, the _right_ /trait/ makes everything nice.


     + Q :: Why go to all this trouble?
            Why didn't Rust's designers make the /generics/ more like /C++
            templates/, where the /constraints/ are left /implicit/ in the code,
            à la /duck typing/?

     + A :: Advantages:
       * /forward compatibility/ of generic code.
         You _can_ change the implementation of a /public generic function or
         method/, and
         *IF* you did *not change* the /signature/, you have *not broken* any of
         its users.

       * /bounds/ is that when you do get a compiler error, at least the compiler
         can tell you where the trouble is.
           This sounds simple, but C++ compiler error messages involving templates
         can't do as good as Rust compiler. The error messages can come from the
         template -- or its caller, which might also be a template -- or that
         template's caller...

       * *Perhaps the most important advantage* of writing out the /bounds/ explicitly
         is simply that *THEY ARE THERE*, in the code and in the documentation.
         - You can look at the /signature/ of a /generic function/ in Rust and
           see exactly what kind of arguments it accepts.
           The same can't be said for templates.

         - The work that goes into fully documenting argument types in C++ libraries
           like Boost is even more arduous than what we went through here. The
           Boost developers don't have a compiler that checks their work.

** DONE Conclusion - 263
   CLOSED: [2018-06-22 Fri 03:41]
   - /Traits/ are one of the *main organizing features* in Rust, and with good
     reason.
       There's nothing better to design a program or library around than a good
     /interface/.

   - Now that we've laid a foundation, we can start talking about the many ways
     /traits/ and /generics/ are used in Rust code.
     _The fact is, we've only begun to scratch the surface._
     _The next two chapters cover common traits provided by the standard library._
     Upcoming chapters cover /closures/, /iterators/, _input/output_, and
     /concurrency/. /Traits/ and /generics/ play a central role in all of these
     topics.

* DONE 12. Operator Overloading - 265
  CLOSED: [2018-06-25 Mon 18:06]
  - Table 12-1. Summary of /traits/ for /operator overloading/
    =From Jian= Categories:
    + Unary operators
    + Arithmetic operators
    + Bitwise operators
    + Compound assignment arithmetic operators
    + Compound assignment bitwise operators
    + Comparison
    + Indexing

** DONE Arithmetic and Bitwise Operators - 266
   CLOSED: [2018-06-07 Thu 18:33]
   - Examples:
     + ~a + b~ is a shorthand for ~a.add(b)~,
       this operator comes from ~std::ops::Add~.

     + ~a * b~ is a shorthand for ~a.mul(b)~,
       this operator comes from ~std::ops::Mul~.

     + ~-a~ is a shorthand for ~a.neg()~,
       this operator comes from ~std::ops::Neg~.

     You can use these methods calls ONLY WHEN you import the corresponding
     /traits/.

   - The definition of ~std::ops::Add~:
     #+BEGIN_SRC rust
       trait Add<RHS=Self> {
           type Output;
           fn add(self, rhs: RHS) -> Self::Output;
       }
     #+END_SRC

     + Implement the ~Add~ for a fixed type, for example, ~i32~:
       #+BEGIN_SRC rust
         use std::ops::Add;

         impl Add for Complex<i32> {
             type Output = Complex<i32>;

             fn add(self, rhs: Self) -> Self {
                 Complex { re: self.re + rhs.re, im: self.im + rhs.im }
             }
         }
       #+END_SRC

     + Implement the ~Add~ for with generics, and keep the lhs and rhs have the
       same types. This is the most preferred one in Rust:
       #+BEGIN_SRC rust
         use std::ops::Add;

         impl<T> Add for Complex<T>
             where T: Add<Output=T>
         {
             type Output = Self;

             fn add(self, rhs: Self) -> Self {
                 Complex { re: self.re + rhs.re, im: self.im + rhs.im }
             }
         }
       #+END_SRC

     + The most general solution, which is NOT preferred in Rust -- in practice,
       Rust tends to avoid supporting mixed-type operations:
       #+BEGIN_SRC rust
         use std::ops::Add;

         impl<L, R, O> Add<Complex<R>> for Complex<L>
             where L: Add<R, Output=O>
         {
             type Output = Complex<O>;

             fn add(self, rhs: Complex<R>) -> Self::Output {
                 Complex { re: self.re + rhs.re, im: self.im + rhs.im }
             }
         }
       #+END_SRC

   - Rust's /built-in traits/ for /arithmetic/ and /bitwise/ operators come in
       *three* groups:
     + unary operators

     + binary operators

     + compound assignment operators

*** DONE Unary Operators - 268
    CLOSED: [2018-06-07 Thu 17:48]
    =TODO=
    Aside from the /dereferencing operator/ ~*~, which we'll cover separately in
    "Deref and DerefMut" on page 289, Rust has *two* /unary operators/:

    - Table 12-2. Built-in traits for unary operators
      | Trait name      | Expression | Equivalent expression |
      |-----------------+------------+-----------------------|
      | ~std::ops::Neg~ | ~-x~       | ~x.neg()~             |
      | ~std::ops::Not~ | ~!x~       | ~x.not()~             |

    - ~std::ops::Neg~ corresponds to /unary negation operator/ ~-~:
      + ALL of Rust's /numeric types/ implement

    - ~std::ops::Not~ corresponds to /unary complement operator/ ~!~,
      it behaves as the two functionalities ~!~ and ~~~ in C/C++.
      + For /integer types/, it is /bitwise complement/ (flips the bits);

      + For /bool/, it is /bool complement/.

    - There are also ~std::ops::Neg~ and ~std::ops::Not~ implementations for
      /references/ to those types.

    - These /traits/' definitions:
      #+BEGIN_SRC rust
        trait Neg {
            type Output;
            fn neg(self) -> Self::Output;
        }

        trait Not {
            type Output;
            fn not(self) -> Self::Output;
        }
      #+END_SRC

    - Example (the generics implementation of negating complex numbers):
      #+BEGIN_SRC rust
        use std::ops::Neg;

        impl<T, O> Neg for Complex<T>
            where T: Neg<Output=O>
        {
            type Output = Complex<O>;

            fn neg(self) -> Complex<O> {
                Complex { re: -self.re, im: -self.im }
            }
        }
      #+END_SRC

*** DONE Binary Operators - 269
    CLOSED: [2018-06-07 Thu 18:08]
    Table 12-3. Built-in traits for binary operators
    |----------------------+--------------------+------------+-----------------------|
    | Category             | Trait name         | Expression | Equivalent expression |
    |----------------------+--------------------+------------+-----------------------|
    | Arithmetic operators | ~std::ops::Add~    | ~x + y~    | ~x.add(y)~            |
    |                      | ~std::ops::Sub~    | ~x - y~    | ~x.sub(y)~            |
    |                      | ~std::ops::Mul~    | ~x * y~    | ~x.mul(y)~            |
    |                      | ~std::ops::Div~    | ~x / y~    | ~x.div(y)~            |
    |                      | ~std::ops::Rem~    | ~x % y~    | ~x.rem(y)~            |
    |----------------------+--------------------+------------+-----------------------|
    | Bitwise operators    | ~std::ops::BitAnd~ | ~x & y~    | ~x.bitand(y)~         |
    |                      | ~std::ops::BitOr~  | ~x \vert{} y~    | ~x.bitor(y)~          |
    |                      | ~std::ops::BitXor~ | ~x ^ y~    | ~x.bitxor(y)~         |
    |                      | ~std::ops::Shl~    | ~x << y~   | ~x.shl(y)~            |
    |                      | ~std::ops::Shr~    | ~x >> y~   | ~x.shr(y)~            |
    |----------------------+--------------------+------------+-----------------------|

    - ALL of Rust's /numeric types/ implement the /arithmetic operators/.

    - All of these /traits/ here have the same general form.
      For example:
      #+BEGIN_SRC rust
        trait BitXor<RHS=Self> {
            type Output;
            fn bitxor(self, rhs: RHS) -> Self::Output;
        }
      #+END_SRC
      + The ~Shl~ and ~Shr~ /traits/ *DEVIATE slightly from this pattern*:
        they do not default their ~RHS~ type parameter to ~Self~,
        so you *must always supply the righthand operand type explicitly*.

    - You can use the ~+~ operator to *concatenate* a ~String~ with a ~&str~ /slice/
      or another ~String~.

      However, Rust does not permit the left operand of ~+~ to be a ~&str~, to
      discourage building up LONG strings by repeatedly concatenating small
      pieces on the left. (This performs poorly, requiring time QUADRATIC in the
      final length of the string.)

      + Generally, the ~write!~ /macro/ is better for building up strings _piece
        by piece_;
        =TODO=
        we show how to do this in “Appending and Inserting Text” on page 399.

*** DONE Compound Assignment Operators - 270
    CLOSED: [2018-06-07 Thu 18:33]
    Table 12-4. Built-in /traits/ for /compound assignment operators/
    |----------------------+-----------------------+------------+-----------------------|
    | Category             | Trait name            | Expression | Equivalent expression |
    |----------------------+-----------------------+------------+-----------------------|
    | Arithmetic operators | ~std::ops::AddAssign~ | ~x += y~   | ~x.add_assign(y)~     |
    |                      | ~std::ops::SubAssign~ | ~x -= y~   | ~x.sub_assign(y)~     |
    |                      | ~std::ops::MulAssign~ | ~x *= y~   | ~x.mul_assign(y)~     |
    |                      | ~std::ops::DivAssign~ | ~x /= y~   | ~x.div_assign(y)~     |
    |                      | ~std::ops::RemAssign~ | ~x %= y~   | ~x.rem_assign(y)~     |
    |----------------------+-----------------------+------------+-----------------------|
    | Bitwise operators    | ~std::ops::BitAnd~    | ~x &= y~   | ~x.bitand_assign(y)~  |
    |                      | ~std::ops::BitOr~     | ~x \vert{}= y~   | ~x.bitor_assign(y)~   |
    |                      | ~std::ops::BitXor~    | ~x ^= y~   | ~x.bitxor_assign(y)~  |
    |                      | ~std::ops::Shl~       | ~x <<= y~  | ~x.shl_assign(y)~     |
    |                      | ~std::ops::Shr~       | ~x >>= y~  | ~x.shr_assign(y)~     |
    |----------------------+-----------------------+------------+-----------------------|

    - ALL of Rust's /numeric types/ implement the /arithmetic compound assignment
      operators/.

      Rust's /integer types/ and /bool/ implement the /bitwise compound assignment
      operators/.

    - /Compound assignment operators/ always return ~()~ -- they are all used for
      side-effect.

    - The way how Rust's /compound assignment operators/ are defined are different
      from /compound assignment operators/ in other languages:
      + In other languages,
        ~x += y~ is considered as a shorthand of ~x = x + y~, which means it is
        a composition of two operations.

      + In Rust,
        The /built-in trait/ for a /compound assignment operator/ is *completely
        independent* of the /built-in trait/ for the CORRESPONDING /binary operator/.

        ~x += y~ corresponds to the ~x.add_assign(y)~, which is the ONLY /method/
        of /trait/ ~std::ops::AddAssign~ /trait/:
        #+BEGIN_SRC rust
          trait AddAssign<RHS=Self> {
              fn add_assign(&mut self, RHS);
          }
        #+END_SRC

    - A _generic implementation_ of ~AddAssign~ for our ~Complex~ type is straightforward:
      #+BEGIN_SRC rust
        use std::ops::AddAssign;

        impl<T> AddAssign for Complex<T>
            where T: AddAssign<T>
        {
            fn add_assign(&mut self, rhs: Complex<T>) {
                self.re += rhs.re;
                self.im += rhs.im;
            }
        }
      #+END_SRC

    - As with the /binary traits/ ~Shl~ and ~Shr~, the ~ShlAssign~ and ~ShrAssign~
      /traits/ _deviate slightly_ from the pattern followed by the other
      /compound assignment traits/:
      they do NOT default their ~RHS~ /type parameter/ to ~Self~ , so you MUST
      ALWAYS supply the righthand operand type EXPLICITLY.

** DONE Equality Tests - 272
   CLOSED: [2018-06-25 Mon 03:28]
   Rust's equality operators, ~==~ and ~!=~, are shorthand for calls to the
   ~std::cmp::PartialEq~ /trait/'s ~eq~ and ~ne~ /methods/:
   ~assert_eq!(x \equal{}\equal{} y, x.eq(&y));~
   ~assert_eq!(x != y, x.ne(&y));~

   - Definition of ~std::cmp::PartialEq~:
     #+BEGIN_SRC rust
       trait PartialEq<Rhs: ?Sized = Self> {
           fn eq(&self, other: &Rhs) -> bool;
           fn ne(&self, other: &Rhs) -> bool { !self.eq(other)}
       }
     #+END_SRC

   - A complete implementation of ~PartialEq~ for ~Complext~
     #+BEGIN_SRC rust
       impl<T: PartialEq> PartialEq for Complex<T> {
           fn eq(&self, other: &Complex<T>) -> bool {
               self.re == other.re && self.im == other.im
           }
       }
     #+END_SRC

   - Rust does NOT have inheritance, and the equality definition is simple.
     You can ask Rust to generate an implementation of ~PartialEq~ for you
     automatically with the ~#[derive]~ /attribute/.

     The ONLY requirement is that each of the new type field should have
     implemented ~PartialEq~.

   - UNLIKE the /arithmetic and bitwise traits/, which take their operands /by value/,
     ~PartialEq~ takes its operands /by reference/ -- even non-~Copy~ values won't
     be moved.

   - ~where Rhs: ?Sized~ *relaxes* Rust's _usual requirement_ that /type parameters/
     must be /sized types/, letting us write /traits/ like ~PartialEq<str>~ or
     ~PartialEq<[T]>~.

   - WHY do we name this /trait/ ~PartialEq~ rather than ~Eq~ or ~Equal~???
     + The definition in mathematics of *the equivalence relation* imposes three
       requirements: for ANY values x and y
       * x \equal{}\equal{} y         <===>         y \equal{}\equal{} x

       * x \equal{}\equal{} y and y \equal{}\equal{} z         <===>         x \equal{}\equal{} z

       * x \equal{}\equal{} x

     + Because of the IEEE standard, floating-point values have ~NaN~'s, which
       _does NOT satisfy_ the third requirement!
       * NaN != NaN

       * NaN < NaN \equal{}\equal{} false
         NaN > NaN \equal{}\equal{} false
         NaN <= NaN \equal{}\equal{} false
         NaN >= NaN \equal{}\equal{} false

   - There is a /trait/ ~std::cmp::Eq~, and it is the /subtrait/ of ~PartialEq~.
     It does NOT have additional /methods/. Even though, NO new /methods/, you
     should guarantee x == x if you want to implement ~Eq~.

     + ~trait Eq: PartialEq<Self> { }~

   - In practice, every implementation of ~PartialEq~ can be ~Eq~, except ~f32~
     and ~f64~.

   - The implmenetation is simple:
     ~impl<T: Eq> Eq for Complex<T> { }~
     However, mostly we prefer use the ~#[derive]~ /attribute/ for generating ~Eq~.

   - If you use ~#[derive]~, Rust will check the two (~PartialEq~) or three (~Eq~)
     requirements are imposed.

** DONE Ordered Comparisons - 275
   CLOSED: [2018-06-25 Mon 17:39]
   Rust specifies the behavior of the ordered comparison operators ~<~, ~>~, ~<=~,
   and ~>=~ all in terms of a SINGLE /trait/, ~std::cmp::PartialOrd~:
   #+BEGIN_SRC rust
     trait PartialOrd<Rhs = Self>: PartialEq<Rhs> where Rhs: ?Sized {
         fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

         fn lt(&self, other: &Rhs) -> bool { ... }
         fn le(&self, other: &Rhs) -> bool { ... }
         fn gt(&self, other: &Rhs) -> bool { ... }
         fn ge(&self, other: &Rhs) -> bool { ... }
     }
   #+END_SRC
   - The ONLY method of ~PartialOrd~ you must implement yourself is ~partial_cmp~,
     which returns ~Some(o)~. Then ~o~ indicates ~self~'s relationship to other:
     #+BEGIN_SRC rust
       enum Ordering {
           Less,       // self < other
           Equal,      // self == other
           Greater,    // self > other
       }
     #+END_SRC

   - If, for some reason, you want to call the /method/ and use pattern matching
     to match ~Ordering~ values, you need ~std::cmp::PartialOrd~ and
     ~std::cmp::Ordering~ in scope.

   - If you know that values of *TWO* /types/ are *ALWAYS* _ordered_ with respect
     to each other, then you can implement the stricter ~std::cmp::Ord trait~:
     #+BEGIN_SRC rust
       trait Ord: Eq + PartialOrd<Self> {
           fn cmp(&self, other: &Self) -> Ordering;
       }
     #+END_SRC
     Almost all types the implmenet ~PartialOrd~ should also implement ~Ord~.
     In the standard library, ~f32~ and ~f64~ are the only exceptions.

** DONE ~Index~ and ~IndexMut~ - 277
   CLOSED: [2018-06-25 Mon 18:06]
   You can specify how an /indexing expression/ like ~a[i]~ works on your type by
   implementing the ~std::ops::Index~ and ~std::ops::IndexMut~ /traits/.

   - Arrays support the ~[]~ operator directly,

     On any other type,
     + the expression ~a[i]~ is normally shorthand for ~*a.index(i)~, where index
       is a /method/ of the ~std::ops::Index~ /trait/.
       #+BEGIN_SRC rust
         trait Index<Idx> {
             type Output: ?Sized;
             fn index(&self, index: Idx) -> &Self::Output;
         }
       #+END_SRC

     + If the expression is being *assigned to* or *borrowed mutably*, it's instead
       shorthand for ~*a.index_mut(i)~, a call to the /method/ of the ~std::ops::IndexMut~
       /trait/.
       #+BEGIN_SRC rust
         trait IndexMut<Idx>: Index<Idx> {
             fn index_mut(&mut self, index: Idx) -> &mut Self::Output;
         }
       #+END_SRC

   - /Slices/ implement ~Index<usize>~ and ~Index<Range<usize>>~.
     ~a[i..j]~ is a shorthand of ~*a.index(std::ops::Range { start: i, end: j })~

   - ONE *limitation* of ~IndexMut~:
     by design, it must return a /mutable reference/ to some value.

     This is why you CANNOT use an expression like ~m["十"] = 10;~ to insert a
     value into the ~HashMap~ ~m~: 
     the table would need to create an entry for ~"十"~ first, with some /default value/,
     and _return_ a /mutable reference/ to that.
       But *not all types have CHEAP default values,* and some may be EXPENSIVE to /drop/;
     it would be a waste to create such a value only to be immediately /dropped/ by the
     assignment.

     =IMPORTANT= =Watch ON this=
     (There are plans to improve this in later versions of the language.)

   - In chapter 2, in the Mandelbrot set ploter, we have an indexing:
     ~pixels[row * bounds.0 + column] = ...;~.
     It would be nicer to have an ~Image<u8>~ type that acts like a two-dimensional
     array, allowing us to access pixels without having to write out all the arithmetic:
     ~image[row][column] = ...;~

     + Code:
       #+BEGIN_SRC rust
         struct Image<P> {
             width: usize,
             pixels: Vec<P>
         }

         impl<P: Default + Copy> Image<P> {
             /// Create a new image of the given size.
             fn new(width: usize, height: usize) -> Image<P> {
                 Image {
                     width,
                     pixels: vec![P::default(); width * height]
                 }
             }
         }

         // And here are implementations of Index and IndexMut that would fit the bill:
         impl<P> std::ops::Index<usize> for Image<P> {
             type Output = [P];
             fn index(&self, row: usize) -> &[P] {
                 let start = row * self.width;
                 &self.pixels[start .. start + self.width]
             }
         }

         impl<P> std::ops::IndexMut<usize> for Image<P> {
             fn index_mut(&mut self, row: usize) -> &mut [P] {
                 let start = row * self.width;
                 &mut self.pixels[start .. start + self.width]
             }
         }
       #+END_SRC
       This implementation also guarantees the supposed behavior: out-of-bounds
       access is _detected_ and causes a /panic/.
   
** DONE Other Operators - 280
   CLOSED: [2018-06-07 Thu 18:18]
   - *NOT ALL* /operators/ can be /overloaded/ in Rust.

     For example, as of Rust 1.17,
     + the /error-checking operator/ ~?~ works _ONLY_ with ~Result~ values;
     + the /logical operators/ ~&&~ and ~||~ are limited to ~Boolean~ values _ONLY_;
     + The ~..~ operator _ALWAYS_ creates ~Range~ values;
     + the ~&~ operator _ALWAYS_ /borrows references/;
     + the ~=~ operator _ALWAYS_ /moves/ or /copies/ values.

     None of them can be overloaded.

   - ~Deref~ and ~DerefMut~ are explained in the next Chapter.
     They do more than just overload a few operators.

   - Rust does NOT support /overloading/ the /function call operator/, ~f(x)~.

     Instead, when you need a /callable value/, you'll typically just write a
     /closure/.

     =TODO= We'll explain how this works and cover the ~Fn~, ~FnMut~, and
     ~FnOnce~ special /traits/ in Chapter 14.

* TODO 13. Utility Traits - 281
  - Several /built-in traits/ let you hook into parts of the Rust language and
    standard library:
    + Use the ~Drop~ /trait/ to _clean up_ values when they _go out of scope_,
      LIKE /destructors/ in C++.

    + /Smart pointer types/, like ~Box<T>~ and ~Rc<T>~, can implement the ~Deref~
      /trait/ to make the pointer reflect the /methods/ of the wrapped value.

    + By implementing the ~From<T>~ and ~Into<T>~ /traits/, you can tell Rust how
      to convert a value from one type to another.

  - We'll cover each of the /traits/ shown in Table 13-1:
    + ~Drop~
      /Destructors/.
      Cleanup code that Rust runs automatically whenever a value is dropped.

    + ~Sized~
      Marker /trait/ for types with a *fixed size* known at /compile time/,
      as _opposed to_ types (such as /slices/) that are *dynamically sized*.

    + ~Clone~
      Types that support *cloning* values.

    + ~Copy~
      Marker /trait/ for types that can be cloned simply by making a
      byte-for-byte copy of the memory containing the value.

    + ~Deref~ and ~DerefMut~
      /Traits/ for /smart pointer types/.

    + ~Default~
      Types that have a sensible "default value."

    + ~AsRef~ and ~AsMut~
      /Conversion traits/ for *borrowing* one type of /reference/ from another.

    + ~Borrow~ and ~BorrowMut~
      /Conversion traits/, like ~AsRef~ / ~AsMut~,
      BUT additionally GUARANTEEING consistent hashing, ordering, and equality.
      =???= =TODO=

    + ~From~ and ~Into~
      /Conversion traits/ for *transforming* one type of value into another.

    + ~ToOwned~
      /Conversion trait/ for converting a /reference/ to an /owned value/.

  - There are OTHER IMPORTANT /standard library traits/ as well. TODO TODO
    + Cover ~Iterator~ and ~IntoIterator~ in Chapter 15.
    + Cover ~Hash~, for computing hash codes, in Chapter 16.
    + Cover ~Send~ and ~Sync~, which mark thread-safe types, in Chapter 19.

** TODO ~Drop~ - 282
   #+BEGIN_SRC rust
     trait Drop {
         fn drop(&mut self);
     }
   #+END_SRC

   - When a value's /owner/ GOES AWAY, we say that Rust *drops* the /value/.

   - *Dropping* a /value/ entails freeing whatever _other values_, /heap storage/,
     and /system resources/ the value owns.

   - *Drops* occur under a variety of circumstances:
     + when a variable goes *out of scope*;

     + when an expression's value is *discarded by* the ~;~ /operator/;

     + when you *truncate* a /vector/, *removing* elements from its end;

     + and so on. =TODO=

   - For types that implement ~std::ops::Drop~, *Rust calls* (NOT you) its ~drop~
     /method/, *before* proceeding to *drop* whatever values its fields or
     elements own, as it normally would.

   - Implicit invocation of ~drop~ is the *only way* to call that /method/;

     if you try to invoke it EXPLICITLY yourself, _Rust flags that as an error_.

   - TODO
     NOTE

   - TODO
     NOTE

** TODO ~Sized~ - 285
   ~Sized~ is a /marker trait/ -- it doesn't have any /method/, and _ONLY Rust,
   NOT you_, can implement it.

   - sized type :: one whose values ALL have the same size in memory.

   - *Almost all* /types/ in Rust are /sized/.

   - Unsized types:
     For example,
     * ~str~ (note, without an ~&~).

     * /Array slices types/ like ~[T]~ (again, without an ~&~) are unsized, too.

     * The /referent/ of a /trait object/.

** TODO ~Clone~ - 287
   #+BEGIN_SRC rust
     trait Clone: Sized {
         fn clone(&self) -> Self;
         fn clone_from(&mut self, source: &Self) {
             ,*self = source.clone()
         }
     }
   #+END_SRC

** TODO ~Copy~ - 289
   The ~std::clone::Clone~ /trait/ is for types that can make copies of themselves.
   #+BEGIN_SRC rust
     trait Clone: Sized {
         fn clone(&self) -> Self;

         fn clone_from(&mut self, source: &Self) {
             ,*self = source.clone()
         }
     }
   #+END_SRC

   - The ~clone~ method should construct an _independent copy_ of ~self~ and return
     it.

   - Since this /method's return type/ is ~Self~, and /functions/ may NOT return
     /unsized values/, the ~Clone~ /trait/ itself extends the ~Sized~ /trait/:
     this has the effect of _bounding_ implementations' ~Self~ type to be ~Sized~.

   - 
   
** TODO ~Deref~ and ~DerefMut~ - 289
   #+BEGIN_SRC rust
     trait Deref {
         type Target: ?Sized;
         fn deref(&self) -> &Self::Target;
     }

     trait DerefMut: Deref {
         fn deref_mut(&mut self) -> &mut Self::Target;
     }
   #+END_SRC

** DONE ~Default~ - 292
   CLOSED: [2018-07-06 Fri 14:13]
   #+BEGIN_SRC rust
     trait Default {
         fn default() -> Self;
     }
   #+END_SRC
   Some types have a REASONABLY OBVIOUS /default value/, and you can specify it by
   implementing the ~std::default::Default~ /trait/.
   
   - For example,
     #+BEGIN_SRC rust
       impl Default for String {
           fn default() -> String {
               String::new()
           }
       }
     #+END_SRC

   - _ALL_ of Rust's /collection types/ implement ~Default~, with /default values/
     of *EMPTY collection*.

     + This design is helpful WHEN you need to build a collection of values, BUT
       want to let your caller decide exactly what sort of collection to build.

       =From Jian= Then,
       You can specify the ~Default~ /trait/, RATHER THAN the /concrete type/.

       For example,
       the ~Iterator~ /trait/'s ~partition~ /method/ splits the values the /iterator/
       produces into two collections, using a /closure/ to decide where each value
       goes:
       #+BEGIN_SRC rust
         use std::collections::HashSet;
         let squares = [4, 9, 16, 25, 36, 49, 64];
         let (powers_of_two, impure): (HashSet<i32>, HashSet<i32>) =
             squares.iter().partition(|&n| n & (n-1) == 0);
         assert_eq!(powers_of_two.len(), 3);
         assert_eq!(impure.len(), 4);
       #+END_SRC
       * The /closure/ ~|&n| n & (n-1) == 0~ uses some /bit-fiddling/ to recognize
         numbers that are powers of two, and ~partition~ uses that to produce two
         ~HashSet~'s.

       * ~partition~ is *NOT SPECIFIC to* ~HashSet~'s; you can use it to produce
         ANY sort of collection you like, as long as the collection type implements
         - ~Default~, to produce an empty col‐ lection to start with,
           and
         - ~Extend<T>~, to add values of ~T~ to the collection.

       * ~String~ implements ~Default~ and ~Extend<char>~, so you can write:
         #+BEGIN_SRC rust
           let (upper, lower): (String, String)
               = "Great Teacher Onizuka".chars().partition(|&c| c.is_uppercase());
           assert_eq!(upper, "GTO");
           assert_eq!(lower, "reat eacher nizuka");
         #+END_SRC

   - Another common use of ~Default~ is to produce default values for structs that
     represent a large collection of parameters, most of which you won't usually
     need ot change.

     For example, the ~glium~ /crate/ provides Rust bindings for the powerful and
     complex OpenGL graphics library. The ~glium::DrawParameters~ /struct/ includes
     22 fields, each controlling a different detail of how OpenGL should render some
     bit of graphics.
       The ~glium~ draw function expects a ~DrawParameters~ struct as an argument.
     Since ~DrawParameters~ implements ~Default~, you can create one to pass to
     ~draw~, _mentioning *ONLY* those fields you want to change_:
     #+BEGIN_SRC rust
       let params = glium::DrawParameters {
           line_width: Some(0.02),
           point_size: Some(0.02),
           .. Default::default()  // The syntax of this usage
       };

       target.draw(..., &params).unwrap();
     #+END_SRC

   - *IF* a type ~T~ implements ~Default~,
     then the standard library implements ~Default~ *AUTOMATICALLY* for ~Rc<T>~,
     ~Arc<T>~, ~Box<T>~, ~Cell<T>~, ~RefCell<T>~, ~Cow<T>~, ~Mutex<T>~, and ~RwLock<T>~.
       The /default value/ for the type ~Rc<T>~, for example, is an ~Rc~
     pointing to the /default value/ for type ~T~.

   - *IF* _ALL_ the element types of a /tuple type/ implement ~Default~,
     then the /tuple type/ does too.

   - Rust does *NOT IMPLICITLY implement* ~Default~ for /struct types/,
     BUT *IF* _ALL_ of a /struct/'s fields implement ~Default~ , you can implement
     ~Default~ for the struct automatically using ~#[derive(Default)]~.

   - The /default value/ of any ~Option<T>~ is ~None~.

** TODO ~AsRef~ and ~AsMut~ - 294
   #+BEGIN_SRC rust
     trait AsRef<T: ?Sized> {
         fn as_ref(&self) -> &T;
     }

     trait AsMut<T: ?Sized> {
         fn as_mut(&mut self) -> &mut T;
     }
   #+END_SRC

** TODO ~Borrow~ and ~BorrowMut~ - 296
   #+BEGIN_SRC rust
     trait Borrow<Borrowed: ?Sized> {
         fn borrow(&self) -> &Borrowed;
     }

     trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {
         fn borrow_mut(&mut self) -> &mut Borrowed;
     }
   #+END_SRC

** TODO ~From~ and ~Into~ - 297
   #+BEGIN_SRC rust
     trait Into<T>: Sized {
         fn into(self) -> T;
     }

     trait From<T>: Sized {
         fn from(T) -> Self;
     }
   #+END_SRC

** TODO ~ToOwned~ - 300
   #+BEGIN_SRC rust
     trait ToOwned {
         type Owned: Borrow<Self>;
         fn to_owned(&self) -> Self::Owned;
     }
   #+END_SRC

** TODO ~Borrow~ and ~ToOwned~ at Work: The Humble ~Cow~ - 300
   #+BEGIN_SRC rust
     enum Cow<'a, B: ?Sized + 'a>
         where B: ToOwned
     {
         Borrowed(&'a B),
         Owned(<B as ToOwned>::Owned),
     }
   #+END_SRC

* DONE 14. Closures - 303 - =Re-READ=
  CLOSED: [2018-06-12 Tue 19:33]
  - Example:
    #+BEGIN_SRC rust
      struct City {
          name: String,
          population: i64,
          country: String,
          // ...
      }
    #+END_SRC

    + WITHOUT a /closure/:
      #+BEGIN_SRC rust
        /// Helper function for sorting cities by population.
        fn city_population_descending(city: &City) -> i64 {
            -city.population
        }
        fn sort_cities(cities: &mut Vec<City>) {
            cities.sort_by_key(city_population_descending);
        }
      #+END_SRC

    + WITH a /closure/:
      #+BEGIN_SRC rust
        fn sort_cities(cities: &mut Vec<City>) {
            cities.sort_by_key(|city| -city.population);
        }
      #+END_SRC

  - In this chapter,
    + you'll learn
      * how to use closures with standard library methods
      * how a closure can “capture” variables in its scope
      * how to write your own functions and methods that take closures as arguments
      * how to store closures for later use as callbacks.

    + We'll also explain
      * how /Rust closures/ work
      * why they're *faster* than you might expect.

** DONE Capturing Variables - 305
   CLOSED: [2018-06-12 Tue 19:33]
   - A /closure/ can USE DATA that belongs to an /enclosing function/.

*** DONE Closures That Borrow - 306
    CLOSED: [2018-06-11 Mon 17:37]
    Example code:
    #+BEGIN_SRC rust
      fn sort_by_statistic(cities: &mut Vec<City>, stat: Statistic) {
          cities.sort_by_key(|city| -city.get_statistic(stat));
      }
    #+END_SRC
    + When Rust creates the /closure/, it /automatically borrows/ a /reference/
      to ~stat~.

    + Since this /closure/ contains a /reference/ to ~stat~, Rust WON'T let it
      outlive ~stat~.

*** DONE Closures That Steal - 306
    CLOSED: [2018-06-11 Mon 17:49]
    #+BEGIN_SRC rust
      fn start_sorting_thread(mut cities: Vec<City>, stat: Statistic)
                              -> thread::JoinHandle<Vec<City>>
      {
          let key_fn = move |city: &City| -> i64 { -city.get_statistic(stat) };

          thread::spawn(move || {
              cities.sort_by_key(key_fn);
              cities
          })
      }
    #+END_SRC
    - The FIRST /closure/, ~key_fn~, takes /ownership/ of ~stat~.
      Then the SECOND /closure/ takes /ownership/ of both ~cities~ and ~key_fn~.

    - We get something important by accepting Rust's strict rules: /thread safety/.

      Values are moved rather than being shared across /threads/.

** TODO Function and Closure Types - 308
   - For example,
     ~fn city_population_descending(city: &City) -> i64 { -city.population }~ has
     type ~fn(&City) -> i64~.

   - /Structs/ may have /function-typed fields/.

   - /Generic types/ like ~Vec~ can store scads of functions, as long as they all
     share the same ~fn~ type.

   - /Function values/ are *tiny*:
     a ~fn~ value is the memory address of the function's machine code, just LIKE
     a /function pointer/ in C++.

** TODO Closure Performance - 310
** TODO Closures and Safety - 311
*** TODO Closures That Kill - 312
*** TODO ~FnOnce~ - 312
*** TODO ~FnMut~ - 314
    - =EN=
      swath - 大片

** TODO Callbacks - 316
** TODO Using Closures Effectively - 319
   - Some code patterns that are commonplace in languages with GC like Java, C#,
     and JavaScript will *NOT* work in Rust WITHOUT CHANGES.

   - =EN=
     divvy up - 分紅

* TODO 15. Iterators - 321 - =Reading=
  Rust has a very rich API for its /iterators/.
    Use the /methods/ of /iterators/ is very common in idiomatic Rust, and being
  familiar with the tools that come with them is essential to mastering the
  language.

  - ~for~ loop provides a natural syntax for using /iterators/, but there are more
    /methods/ can be called from /iterators/.

  - Example:
    1. Use ~for~ and the ~Range<i32>~ /iterator/:
       #+begin_src rust
         fn triangle(n: i32) -> i32 {
             let mut sum = 0;
             for i in 1..n+1 {
                 sum += i;
             }
             sum
         }
       #+end_src

    2. A equivalent but more concise way:
       #+begin_src rust
         fn triangle(n: i32) -> i32 {
             (1..n+1).fold(0, |sum, item| sum + item)
         }
       #+end_src
       This is concise, and it is a pretty standard fare for functional
       programming languages.
       + Q :: Then what is special for it in Rust?
       + A :: Rust's iterators were carefully designed to ensure that the compiler
              can translate them into excellent machine code as well!

  - In a /release build/ of the 2 shown above,Rust knows the definition of ~fold~,
    and will do:
    1. INLINE the ~fold~ into ~triangle~
    2. INLINE the /closure/ ~|sum, item| sum + item~
    3. Replace the summation with the formula ~n * (n+1) / 2~

  - The rest of this chapter falls into *five* parts:
    1. We'll explain the ~Iterator~ and ~IntoIterator~ /traits/, which are the
       foundation of Rust's /iterators/.

    2. Then we'll go over the *three* stages of a typical /iterator/ pipeline:
       1. *creating* an /iterator/ from some sort of _value source_;

       2. *adapting* one sort of /iterator/ into another by *selecting* or *processing*
          values as they go by;

       3. *consuming* the values the /iterator/ produces.

    3. We'll show how to *implement* /iterators/ for your own types.

** DONE The ~Iterator~ and ~IntoIterator~ Traits - 322
   CLOSED: [2018-06-12 Tue 22:08]
   - iterator :: Any value that implements the ~std::iter::Iterator~ /trait/.

   - The ~Iterator~ trait:
     #+BEGIN_SRC rust
       trait Iterator {
           type Item;

           fn next(&mut self) -> Option<Self::Item>;
           // ... // many default methods
       }
     #+END_SRC

   - If there's a natural way to iterate over certain type, this type can implement
     ~std::iter::IntoIterator~, whose ~into_iter~ /method/ takes a value and
     returns an /iterator/ over it:
     #+BEGIN_SRC rust
       trait IntoIterator where Self::IntoIter::Item == Self::Item {
           type Item;
           type IntoIter: Iterator;
           fn into_iter(self) -> Self::IntoIter;
       }
     #+END_SRC

   - ~IntoIter~ is the type of the /iterator/ value ITSELF, and ~Item~ is the type
     of value it produces.

     The /vector reference/ ~&v~ is the /iterable/ in this case.

   - iterable :: Any type that implements ~IntoIterator~ (because it's something
                 you could iterate over if you asked)

   - Under the hood, every ~for~ loop is just shorthand for calls to ~IntoIterator~
     and ~Iterator~ methods:
     #+BEGIN_SRC rust
       let mut iterator = (&v).into_iter();

       while let Some(element) = iterator.next() {
           println!("{}", element);
       }
     #+END_SRC
     Although a ~for~ loop always calls ~into_iter~ on its operand, you can also
     pass /iterators/ to ~for~ loops directly; this occurs when you loop over a
     ~Range~.

     + Rationale:
       ALL /iterators/ AUTOMATICALLY implement ~IntoIterator~, with an ~into_iter~
       /method/ that simply returns the /iterator/.

   - After a /iterator/'s ~next~ /method/ returns ~None~, in most cases, it will
     keep returning ~None~, but NOT all /iterators/ have this behavior.

     See page 338 -- use the ~fuse~ /adapter method/ to force the ~None~ values
     after the first ~None~ value.

   - Here's some terminology for /iterators/:
     + An /iterator/ produces /values/.

     + The /values/ an /iterator/ produces are /items/.

     + The code that receives the /items/ an /iterator/ produces is the /consumer/.
       In this example, the ~for~ loop *consumes* the /iterator/'s /items/.

** DONE Creating ~Iterator~'s - 324
   CLOSED: [2018-07-03 Tue 12:22]
   The Rust standard library documentation explains in detail what sort of /iterators/
   each type provides, but the library _follows some general conventions_ to help you
   get oriented and find what you need.

*** DONE ~iter~ and ~iter_mut~ Methods - 324
    CLOSED: [2018-07-03 Tue 11:54]
    - ~iter~ produces a /shared reference/ to each /item/.

    - ~iter_mut~ produces a /mutable reference/ to each /item/.

    - /Slices/ like ~&[T]~ and ~&str~ have ~iter~ and ~iter_mut~ methods too.

*** DONE ~IntoIterator~ Implementations - 325
    CLOSED: [2018-07-03 Tue 12:22]
    - MOST /collections/ actually provide _several_ implementations of ~IntoIterator~,
      for /shared references/, /mutable references/, and /moves/:
      + Given a /shared reference/ to the /collection/, ~into_iter~ returns an
        /iterator/ that produces /shared references/ to its items.

        For example,
        ~favorites~ is a ~Vec<String>~, and the call ~(&favorites).into_iter()~
        would return an /iterator/ whose ~Item~ type is ~&String~.

        ~for element in &collection { ... }~

      + Given a /mutable reference/ to the /collection/, ~into_iter~ returns an
        /iterator/ that produces /mutable references/ to the items.

        For example,
        ~vector~ is some ~Vec<String>~, and the call ~(&mut vector).into_iter()~
        returns an /iterator/ whose ~Item~ type is ~&mut String~.

        ~for element in &mut collection { ... }~

      + When passed the /collection/ by value, ~into_iter~ returns an /iterator/
        that takes /ownership/ of the /collection/ and returns /items/ by /value/;

        the items' /ownership/ moves from the /collection/ to the /consumer/, and
        the _ORIGINAL_ /collection/ is *consumed* in the process.

        For example, the call ~favorites.into_iter()~ in the preceding code
        returns an /iterator/ that produces each string by value; the consumer
        receives /ownership/ of each string. When the /iterator/ is /dropped/,
        any elements remaining in the ~BTreeSet~ are /dropped/ too, and the set's
        non-empty husk is disposed of.

        ~for element in collection { ... }~

    - =EN=
      husk - 壳

    - *NOT every type provides all THREE implementations.*
      =page= 326 start

      For example,
      + ~HashSet~, ~BTreeSet~ and ~BinaryHeap~ do _NOT_ implement ~IntoIterator~
        on /mutable references/,
        SINCE modifying their elements *would probably VIOLATE* the type's /invariants/:
        the modified value might have a different hash value, or be ordered
        differently with respect to its neighbors, so modifying it would leave
        it incorrectly placed.

      + Other types do support _mutation_, but only PARTIALLY.
        For example, ~HashMap~ and ~BTreeMap~ produce
        * /mutable reference/ to their /entries' values/,

        * but ONLY /shared references/ to their keys, for similar reasons to those
          given earlier.

      + /Slices/ implement *two* of the three ~IntoIterator~ variants;
        SINCE they _do NOT own_ their elements, there is NO "by value" case.
        INSTEAD, ~into_iter~ for ~&[T]~ and ~&mut [T]~ returns an /iterator/
        that produces /shared and mutable references/ to the elements.

        If you imagine the underlying /slice/ type ~[T]~ as a collection of some
        sort, this fits neatly into the overall pattern.

    - You may have noticed that the first two ~IntoIterator~ variants, for /shared
      and mutable references/, are *equivalent to* calling ~iter~ or ~iter_mut~
      on the referent.

      + Q :: Why does Rust provide both?

      + A :: 
        1. ~IntoIterator~ is what makes ~for~ loops work, so that's obviously necessary.
           But when you're not using a ~for~ loop, ~favorites.iter()~ is clearer than
           ~(&favorites).into_iter()~.

           Iteration by /shared reference/ is something you'll need frequently,
           so ~iter~ and ~iter_mut~ are still valuable for their _ergonomics_.

        2. IntoIterator can also be useful in generic code: you can use a bound
           like ~T~:
           ~IntoIterator~ to restrict the type variable ~T~ to types that can be
           iterated over. Or, you can write ~T: IntoIterator<Item=U>~ to further
           require the iteration to produce a particular type ~U~. For example,
           this function dumps values from any iterable whose items are
           printable with the ~"{:?}"~ format:
           #+BEGIN_SRC rust
             use std::fmt::Debug;

             fn dump<T, U>(t: T)
                 where T: IntoIterator<Item=U>,
                       U: Debug
             {
                 for u in t {
                     println!("{:?}", u);
                 }
             }
           #+END_SRC

           =IMPORTANT=
           You *CANNOT* write this /generic function/ using ~iter~ and ~iter_mut~,
           SINCE *they're NOT /methods/ of any /trait/:*
           most /iterable/ types just happen to have /methods/ by those names.

*** DONE ~drain~ Methods - 327 =???=
    CLOSED: [2018-06-13 Wed 08:59]
    - Many collection types provide a ~drain~ method.

    - ~drain~ :: a kind of /method/ that takes a /mutable reference/ to the /collection/
                 and returns an /iterator/ that passes /ownership/ of each element to
                 the consumer.

      + However,
        _UNLIKE_ the ~into_iter()~ /method/, which takes the /collection/
        _by value_ and _consumes_ it,

        ~drain~ merely _borrows_ a /mutable reference/ to the /collection/,
        =TODO= =???= =???=
        and when the /iterator/ is _dropped_, it _removes_ any remaining elements
        from the /collection/, and leaves it empty.

    - On types that can be indexed by a range, like ~String~'s, /vectors/, and
      ~VecDeque~'s, the ~drain~ /method/
      + takes a range of elements to remove,
      + _rather than_ draining the entire sequence:

      #+BEGIN_SRC rust
        use std::iter::FromIterator;

        let mut outer = "Earth".to_string();
        let inner = String::from_iter(outer.drain(1..4));

        assert_eq!(outer, "Eh");
        assert_eq!(inner, "art");
      #+END_SRC
      + If you do need to ~drain~ the ENTIRE sequence, use the full range, ~..~,
        as the argument.
    
*** DONE Other ~Iterator~ Sources - 328
    CLOSED: [2018-06-13 Wed 09:07]
    =IMPORTANT= =!!!!!!=
    Table 15-1. Other /iterators/ in the standard library

** DONE ~Iterator~ Adapters - 330
   CLOSED: [2018-07-01 Sun 20:35]
*** DONE ~map~ and ~filter~ - 330
    CLOSED: [2018-06-13 Wed 09:24]
    - Example:
      #+BEGIN_SRC rust
        let text = " ponies   \n   giraffes\niguanas  \nsquid".to_string();
        let v: Vec<&str> = text.lines()
            .map(str::trim)
            .filter(|s| *s != "iguanas")
            .collect();
        assert_eq!(v, ["ponies", "giraffes", "iguanas", "squid"]);
      #+END_SRC

    - A chain of /iterator adapters/ is like a pipeline in the Unix shell.

    - These adapters' signatures:
      #+BEGIN_SRC rust
        fn map<B, F>(self, f: F) -> some Iterator<Item=B>
            where Self: Sized, F: FnMut(Self::Item) -> B;

        fn filter<P>(self, predicate: P) -> some Iterator<Item=Self::Item>
            where Self: Sized, P: FnMut(&Self::Item) -> bool;
      #+END_SRC
      + The ~some~ part is NOT Valid Rust.
        * footnote: =TODO=
          Rust RFC 1522 will add syntax to the language very much like our some
          Iterator notation. As of Rust 1.17, it is not yet included in the
          language by default.

        The real /return types/ are opaque ~struct~ types, which aren't
        informative (therefore not be presented here).

    - Since most /adapters/ take ~self~ _by value_, they require ~Self~ to be ~Sized~
      (which all COMMON /iterators/ are).

    - There are two important points to notice about iterator adapters.
      =TODO= =NOTE=
      + Laziness =TODO=

      + Efficiency =TODO=

*** DONE ~filter_map~ and ~flat_map~ - 332
    CLOSED: [2018-06-13 Wed 09:49]
    - The signature of the ~filter_map~ /method/:
      #+BEGIN_SRC rust
        fn filter_map<B, F>(self, f: F) -> some Iterator<Item=B>
            where Self: Sized, F: FnMut(Self::Item) -> Option<B>;
      #+END_SRC
      This signature is similar to ~map~, but the /return type/ of ~F~ is
      different. The one for ~map~ is ~B~, and the one for ~filter_map~ is
      ~Option<B>~.

      Here ~Option~ type is used to do something similar to the ~predicate~ for
      the ~filter~ /method/ -- this time we use ~Option~, instead of ~bool~, to
      filter out the values we don't want (when the value is ~None~).

    - Example:
      #+BEGIN_SRC rust
        use std::str::FromStr;

        let text = "1\nfrond .25 289\n3.1415 estuary\n";
        for number in text.split_whitespace()
            .filter_map(|w| f64::from_str(w).ok()) {
                println!("{:4.2}", number.sqrt());
        }

        // 1.00
        // 0.50
        // 17.00
        // 1.77
      #+END_SRC

      The equivalent but more verbose version of only using ~map~ and ~filter~:
      #+BEGIN_SRC rust
        text.split_whitespace()
            .map(|w| f64::from_str(w))
            .filter(|r| r.is_ok())
            .map(|r| r.unwrap())
      #+END_SRC

    - The signature of the ~flat_map~ /method/:
      #+BEGIN_SRC rust
        fn flat_map<U, F>(self, f: F) -> some Iterator<Item=U::Item>
            where F: FnMut(Self::Item) -> U, U: IntoIterator;
      #+END_SRC
      + The /closure/ passed to ~flat_map~ must return an /iterable/, but any sort
        of /iterable/ will do.

        footnote 2:
        Since ~Option~ is an /iterable/, for the /closures/ that returns ~Option~
        types, ~flat_map~ is equivalent to the ~filter_map~.

    - Example:
      Map countries to their major cities:
      #+BEGIN_SRC rust
        use std::collections::HashMap;

        let mut major_cities = HashMap::new();
        major_cities.insert("Japan", vec!["Tokyo", "Kyoto"]);
        major_cities.insert("The United States", vec!["Portland", "Nashville"]);
        major_cities.insert("Brazil", vec!["São Paulo", "Brasília"]);
        major_cities.insert("Kenya", vec!["Nairobi", "Mombasa"]);
        major_cities.insert("The Netherlands", vec!["Amsterdam", "Utrecht"]);

        let countries = ["Japan", "Brazil", "Kenya"];

        for &city in countries.iter().flat_map(|country| &major_cities[country]) {
            println!("{}", city);
        }
      #+END_SRC
      Because of the /laziness/,
      *use ~next~ to retrive every element will NOT trigger concatenation operations.*

*** DONE ~scan~ - 335
    CLOSED: [2018-06-13 Wed 10:04]
    =From Jian=
    LIKE a ~reduce~ /method/ in other languages, but this one can stop in the
    middle by some condition -- last returning value is ~None~.

    This ~scan~ is totally different in semantics from the one in Scala.

    - Example:
      #+BEGIN_SRC rust
        let iter = (0..10)
            .scan(0, |sum, item| {
                *sum += item;
                if *sum > 10 {
                    None
                } else {
                    Some(item * item)
                }
            });

        assert_eq!(iter.collect::<Vec<i32>>(), vec![0, 1, 4, 9, 16]);
      #+END_SRC

    - =From Jian=
      Try to find or create a function of:
      #+BEGIN_SRC rust
        fn to_option<T>(b: bool, v: T) -> Option<T> {
            match b {
                true => Some(v),
                _ => None
            }
        }
      #+END_SRC
      Then the code in the last example can be re-written as:
      ~(0..10).scan(0, |sum, item| {*sum += item; to_option(*sum > 10, item * item)});~

      =TODO= How to make the second parameter ~v~ /laziness/!!!!!!!!!

*** DONE ~take~ and ~take_while~ - 335
    CLOSED: [2018-06-13 Wed 14:59]
    - The ~take~ /method/:
      #+BEGIN_SRC rust
        fn take(self, n: usize) -> some Iterator<Item=Self::Item>
            where Self: Sized;

        fn take_when<P>(self, predicate: P) -> some Iterator<Item=Self::Item>
            where Self: Sized, P: FnMut(&Self::Item) -> bool;
      #+END_SRC

*** DONE ~skip~ and ~skip_while~ - 336
    CLOSED: [2018-06-13 Wed 15:02]
    These two /methods/ are like the ~drop~ and ~dropWhile~ /methods/ in Scala.

    Not use the word "drop" to avoid miss-leading name -- "drop" has a special
    meaning in the context of Rust.

    #+BEGIN_SRC rust
      fn skip(self, n: usize) -> some Iterator<Item=Self::Item>
          where Self: Sized;

      fn skip_while<P>(self, predicate: P) -> some Iterator<Item=Self::Item>
          where Self: Sized, P: FnMut(&Self::Item) -> bool;
    #+END_SRC
    - xxx

*** DONE ~peekable~ - 337
    CLOSED: [2018-06-13 Wed 16:09]
    - peekable iterator :: You can peek at the next item that will be produced
         _WITHOUT_ actually consuming it.

    - You can turn almost *ANY* /iterator/ into a /peekable iterator/ by calling
      the ~Iterator~ /trait/'s ~peekable~ /method/:
      #+BEGIN_SRC rust
        fn peekable(self) -> std::iter::Peekable<Self>
            where Self: Sized;
      #+END_SRC
      + ~Peekable<Self>~ is a /struct/ that implements ~Iterator<Item=Self::Item>~;

      + ~Self~ is the type of the underlying /iterator/.

    - A ~Peekable~ /iterator/ has an additional /method/ ~peek~ that returns an
      ~Option<&Item>~:
      + ~None~ if the underlying /iterator/ is done

      + ~Some(r)~, where ~r~ is a /shared reference/ to the _NEXT_ /item/.

      (Note that, if the /iterator/'s /item/ type is already a /reference/ to
      something, this ends up being a /reference to a reference/.)

    - Calling ~peek~, and the result will be cached.
      All the other ~Iterator~ methods on ~Peekable~ know about this cache.

    - /Peekable iterators/ are essential when you can't decide how many /items/
      to consume from an /iterator/ until you've gone too far.

    - For example, if you're parsing numbers from a stream of characters, you can't
      decide where the number ends until you've seen the first non-number
      character following it:
      #+BEGIN_SRC rust
        use std::iter::Peekable;

        fn parse_number<I>(tokens: &mut Peekable<I>) -> u32
            where I: Iterator<Item=char>
        {
            let mut n = 0;

            loop {
                match tokens.peek() {
                    Some(r) if r.is_digit(10) => {
                        n = n * 10 + r.to_digit(10).unwrap();
                    }

                    _ => return n
                }
                tokens.next();
            }
        }

        let mut chars = "226153980,1766319049".chars().peekable();
        assert_eq!(parse_number(&mut chars), 226153980);
        // Look, `parse_number` didn't consume the comma! So we will.
        assert_eq!(chars.next(), Some(','));
        assert_eq!(parse_number(&mut chars), 1766319049);
        assert_eq!(chars.next(), None);
      #+END_SRC

*** DONE ~fuse~ - 338
    CLOSED: [2018-06-13 Wed 09:34]
    The subsequent behavior of a ~Iterator~ that has returned ~None~ if NOT forced.

    Most /iterators/ just return ~None~ again, but NOT ALL.
    You cannot make a general assumption!

    The ~fuse~ adapter takes any /iterator/ and turns into one that will definitely
    continue to return ~None~ once it has done so the first time:
    #+BEGIN_SRC rust
      struct Flaky(bool);

      impl Iterator for Flaky {
          type Item = &'static str;
          fn next(&mut self) -> Option<Self::Item> {
              if self.0 {
                  self.0 = false;
                  Some("totally the last item")
              } else {
                  self.0 = true; // D'oh!
                  None
              }
          }
      }
      let mut flaky = Flaky(true);
      assert_eq!(flaky.next(), Some("totally the last item"));
      assert_eq!(flaky.next(), None);
      assert_eq!(flaky.next(), Some("totally the last item"));

      let mut not_flaky = Flaky(true).fuse();
      assert_eq!(not_flaky.next(), Some("totally the last item"));
      assert_eq!(not_flaky.next(), None);
      assert_eq!(not_flaky.next(), None);
    #+END_SRC
    Here we first introduce /struct/ that has a wierd-behaved /interator/ that
    can return other values after returning ~None~, and then we use ~fuse~ to
    convert the original /iterator/ to a well-behaved /iterator/ -- always return
    ~None~ after returning the first ~None~.

    *The fuse adapter is probably most useful in generic code that needs to work
    with iterators of uncertain origin.*
      Rather than hoping that every /iterator/ you'll have to deal with will be
    well-behaved, you can use ~fuse~ to make sure.

*** DONE Reversible ~Iterator~'s and ~rev~ - 339
    CLOSED: [2018-06-13 Wed 16:22]
    Some /iterators/ are able to draw /items/ from both ends of the sequence.
    - Reversible iterators implement ~DoubleEndedIterator~:
      #+BEGIN_SRC rust
        trait DoubleEndedIterator: Iterator {
            fn next_back(&mut self) -> Option<Self::Item>;
        }
      #+END_SRC

    - Example:
      #+BEGIN_SRC rust
        use std::iter::DoubleEndedIterator;
        let bee_parts = ["head", "thorax", "abdomen"];
        let mut iter = bee_parts.iter();

        assert_eq!(iter.next(), Some(&"head"));
        assert_eq!(iter.next_back(), Some(&"abdomen"));
        assert_eq!(iter.next(), Some(&"thorax"));
        assert_eq!(iter.next_back(), None);
        assert_eq!(iter.next(), None);
      #+END_SRC

    - In general, the standard library provides double-ended iteration *whenever
      it's practical*. For instance, ~Vec~, ~BTreeSet~, and ~BTreeMap~.

    - NOT all /iterators/ can do this so easily:
      an /iterator/ producing values from other /threads/ arriving at a /channel/'s
      ~Receiver~ has _NO WAY to anticipate_ what the last value received might be.

    - If an /iterator/ is double-ended, you can reverse it with the ~rev~ /adapter/:
      #+BEGIN_SRC rust
        fn rev(self) -> some Iterator<Item=Self>
            where Self: Sized + DoubleEndedIterator;
      #+END_SRC

    - Most /iterator/ adapters, when possible, preserve the input /iterator/'s
      reversibility in the result /iterator/.

*** DONE ~inspect~ - 340
    CLOSED: [2018-06-13 Wed 16:46]
    - The ~inspect~ adapter is handy for *debugging* pipelines of /iterator/ adapters,
      BUT *it isn't used much in production code*.

    - It simply applies a /closure/ to a /shared reference/ to each /item/, and
      then passes the /item/ through.

      The closure CANNOT affect the /items/,
      but it can do things like _print_ them or _make assertions_ about them.

    - Example:
      #+BEGIN_SRC rust
        let upper_case: String = "große".chars()
            .inspect(|c| println!("before: {:?}", c))
            .flat_map(|c| c.to_uppercase())
            .inspect(|c| println!(" after:     {:?}", c))
            .collect();

        assert_eq!(upper_case, "GROSSE");

        // before: 'g'
        //  after:     'G'
        // before: 'r'
        //  after:     'R'
        // before: 'o'
        //  after:     'O'
        // before: 'ß'
        //  after:     'S'
        //  after:     'S'
        // before: 'e'
        //  after:     'E'
      #+END_SRC
      + The uppercase equivalent of the lowercase German letter ~ß~ is ~SS~, which
        is why ~char::to_uppercase~ returns an /iterator/ over characters, _NOT_
        a single replacement character.

*** DONE ~chain~ - 341
    CLOSED: [2018-06-13 Wed 16:35]
    - The ~chain~ adapter's signature is as follows:
      #+BEGIN_SRC rust
        fn chain<U>(self, other: U) -> some Iterator<Item=Self::Item>
            where Self: Sized, U: IntoIterator<Item=Self::Item>;
      #+END_SRC
      In other words, you can *chain* an /iterator/ together with any /iterable/
      that produces the _SAME_ /item type/.

    - Example,
      ~let v: Vec<i32> = (1..4).chain(vec![20, 30, 40]).collect();~
      Here, the ~v~ is [1, 2, 3, 20, 30, 40]).

    - A /chain iterator/ is _reversible_, if *BOTH* of its underlying /iterators/
      are.

*** DONE ~enumerate~ - 341
    CLOSED: [2018-06-13 Wed 16:31]
    This /method/ returns an /iterator/ with elements of ~(0, A), (1, B), (2,
    C), ......~.

*** DONE ~zip~ - 342
    CLOSED: [2018-06-13 Wed 16:26]
    - The /zipped iterator/
      ends when either of the two underlying /iterators/ ends.

      The length of a /zipped iterator/ depends on the shorter one.

    - Example (~enumerate~-like):
      ~let v: Vec<_> = (0..).zip("ABCD".chars()).collect();~
      The ~v~ here is of value ~vec![(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D')]~.

*** DONE ~by_ref~ - 342
    CLOSED: [2018-06-14 Thu 01:54]
    All the /adapters/ we mentioned take ownership of the underlying /iterator/,
    and provide _NO_ /method/ to give it back.

    You can Use the ~by_ref~ /method/ to /borrow/ a /mutable reference/ to the
    /iterator/, and then apply /adapters/ to the reference. When you are done,
    you drop it, and you can re-gain access to your ORIGINAL /iterator/.

    - Example:
      #+BEGIN_SRC rust
        let message = "To: jimb\r\n\
                       From: id\r\n\
                       \r\n\
                       Oooooh, donuts!!\r\n";

        let mut lines = message.lines();

        println!("Headers:");
        for header in lines.by_ref().take_while(|l| !l.is_empty()) {
            println!("{}" , header);
        }

        println!("\nBody:");
        for body in lines {
            println!("{}" , body);
        }

        // Headers:
        // To: jimb
        // From: id
        //
        // Body:
        // Oooooh, donuts!!
      #+END_SRC

    - The implementation of the ~by_ref~:
      #+BEGIN_SRC rust
        impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {
            type Item = I::Item;

            fn next(&mut self) -> Option<I::Item> {
                (**self).next()
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (**self).size_hint()
            }
        }
      #+END_SRC
      + In other words, if ~I~ is some /iterator type/, then ~&mut I~ is an
        /iterator/ too, whose ~next~ and ~size_hint~ /methods/ defer to its referent.

        When you call an /adapter/ on a /mutable reference/ to an /iterator/, the
        /adapter/ takes /ownership/ of the /reference/, _NOT_ the /iterator/ ITSELF.

        That's just a /borrow/ that ends when the /adapter/ goes out of scope.

*** DONE ~cloned~ - 344
    CLOSED: [2018-06-14 Thu 01:58]
    The ~cloned~ /adapter/ takes an /iterator/ _that produces /references/,_ and
    returns an /iterator/ _that produces /values/ cloned from those /references/._

    Naturally, the referent type *MUST* implement ~Clone~. For example:
    #+BEGIN_SRC rust
      let a = ['1', '2', '3', '∞'];
      assert_eq!(a.iter().next(),          Some(&'1'));
      assert_eq!(a.iter().cloned().next(), Some('1')); 
    #+END_SRC

*** DONE ~cycle~ - 344
    CLOSED: [2018-07-01 Sun 20:35]
    The ~cycle~ adapter returns an /iterator/ that *endlessly repeats* the sequence
    produced by the _UNDERLYING_ /iterator/. The _UNDERLYING_ /iterator/ *must
    implement* ~std::clone::Clone~, so that ~cycle~ can _save_ its initial state
    and _reuse_ it each time the cycle starts again.

    - For example:
      #+BEGIN_SRC rust
        let dirs = ["North", "East", "South", "West"];
        let mut spin = dirs.iter().cycle();
        assert_eq!(spin.next(), Some(&"North"));
        assert_eq!(spin.next(), Some(&"East"));
        assert_eq!(spin.next(), Some(&"South"));
        assert_eq!(spin.next(), Some(&"West"));
        assert_eq!(spin.next(), Some(&"North"));
        assert_eq!(spin.next(), Some(&"East"));
      #+END_SRC

    - The fizz-buzz game implementation that needs NO arithmetic calculation:
      #+BEGIN_SRC rust
        use std::iter::{once, repeat};

        let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
        let buzzes = repeat("").take(4).chain(once("buzz")).cycle();
        let fizzes_buzzes = fizzes.zip(buzzes);

        let fizz_buzz = (1..100).zip(fizzes_buzzes)
            .map(|tuple|
                 match tuple {
                     (i, ("", "")) => i.to_string(),
                     (_, (fizz, buzz)) => format!("{}{}", fizz, buzz)
                 });

        for line in fizz_buzz {
            println!("{}", line);
        }
      #+END_SRC

** TODO Consuming Iterators - 345
*** DONE Simple Accumulation: ~count~, ~sum~, ~product~ - 345
    CLOSED: [2018-06-13 Wed 16:49]
    You can extend ~sum~ and ~product~ to work with other types by implementing
    the ~std::iter::Sum~ and ~std::iter::Product~ /traits/, which we won't
    describe in this book.

*** DONE ~max~, ~min~ - 346
    CLOSED: [2018-06-13 Wed 16:54]
    The /iterator/'s /item type/ must implement ~std::cmp::Ord~ to use the ~max~
    and ~min~ /methods/.

    - ~f32~ and ~f64~ implement ONLY ~std::cmp::PartialOrd~, not ~std::cmp::Ord~,
      so you *CANNOT* use the ~min~ and ~max~ /methods/ to compute the least or
      greatest of a sequence of floating-point numbers.

      This is NOT a popular design, but it is deliberate:
      it's NOT clear what such functions should do with IEEE ~NaN~ values.

    - If you know how you would like to handle ~NaN~ values, you can use ~min_by~
      and ~max_by~ /iterator methods/ instead.

*** DONE ~max_by~, ~min_by~ - 346
    CLOSED: [2018-06-13 Wed 16:57]
    Example:
    #+BEGIN_SRC rust
      use std::cmp::{PartialOrd, Ordering};

      // Compare two f64 values. Panic if given a NaN.
      fn cmp(lhs: &&f64, rhs: &&f64) -> Ordering {
          lhs.partial_cmp(rhs).unwrap()
      }

      let numbers = [1.0, 4.0, 2.0];
      assert_eq!(numbers.iter().max_by(cmp), Some(&4.0));
      assert_eq!(numbers.iter().min_by(cmp), Some(&1.0));

      let numbers = [1.0, 4.0, std::f64::NAN, 2.0];

      assert_eq!(numbers.iter().max_by(cmp), Some(&4.0)); // panics
    #+END_SRC
    - The _DOUBLE_ /references/ in ~cmp~'s parameters arise because ~numbers.iter()~
      produces /references/ to the elements, and then ~max_by~ and ~min_by~ pass
      the /closure references/ to the /iterator/'s /items/.

*** DONE ~max_by_key~, ~min_by_key~ - 347
    CLOSED: [2018-07-01 Sun 22:45]
    - Signatures:
      #+BEGIN_SRC rust
        fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>
            where Self: Sized, F: FnMut(&Self::Item) -> B;

        fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>
            where Self: Sized, F: FnMut(&Self::Item) -> B;
      #+END_SRC

    - Example:
      #+BEGIN_SRC rust
        use std::collections::HashMap;

        let mut populations = HashMap::new();
        populations.insert("Portland",  583_776);
        populations.insert("Fossil",        449);
        populations.insert("Greenhorn",       2);
        populations.insert("Boring",      7_762);
        populations.insert("The Dalles", 15_340);

        assert_eq!(populations.iter().max_by_key(|&(_name, pop)| pop),
                   Some((&"Portland", &583_776)));

        assert_eq!(populations.iter().min_by_key(|&(_name, pop)| pop),
                   Some((&"Greenhorn", &2)));
      #+END_SRC

*** DONE Comparing ~Item~ Sequences - 347
    CLOSED: [2018-07-01 Sun 22:50]
    - You can use ~<~ and ~==~ operators to compare strings, vectors, and slices,
      assuming their individual elements can be compared.

    - /Iterators/ doesn't support Rust's comparison operators, but they do provide
      /methods/ like ~eq~ and ~lt~ that do the same job.

    - Example:
      #+BEGIN_SRC rust
        let packed = "Helen of Troy";
        let spaced = "Helen   of    Troy";
        let obscure = "Helen of Sandusky"; // nice person, just not famous

        assert!(packed != spaced);
        assert!(packed.split_whitespace().eq(spaced.split_whitespace()));

        // This is true because ' ' < 'o'.
        assert!(spaced < obscure);

        // This is true because 'Troy' > 'Sandusky'.
        assert!(spaced.split_whitespace().gt(obscure.split_whitespace()));
      #+END_SRC

    - Using the ~eq~ and ~gt~ /methods/ on these /iterators/ performs a *word-by-word
      comparison*, _INSTEAD OF_ a character-by-character comparison.
        These are all possible because ~&str~ implements ~PartialOrd~ and ~PartialEq~.

*** DONE ~any~ and ~all~ - 348
    CLOSED: [2018-06-13 Wed 16:58]
*** DONE ~position~, ~rposition~, and ~ExactSizeIterator~ - 348
    CLOSED: [2018-07-01 Sun 23:01]
    - Example:
      #+BEGIN_SRC rust
        let text = "Xerxes";
        assert_eq!(text.chars().position(|c| c == 'e'), Some(1));
        assert_eq!(text.chars().position(|c| c == 'z'), None);
      #+END_SRC

    - Example:
      Why cannot we use ~&str~ here? _Explained later in this section._
      #+BEGIN_SRC rust
        let bytes = b"Xerxes";
        assert_eq!(bytes.iter().rposition(|&c| c == b'e'), Some(4));
        assert_eq!(bytes.iter().rposition(|&c| c == b'X'), Some(0));
      #+END_SRC

    - An /exact-size iterator/ is one that implements the ~std::iter::ExactSizeIterator~
      /trait/:
      #+BEGIN_SRC rust
        pub trait ExactSizeIterator: Iterator {
            fn len(&self) -> usize { ... }
            fn is_empty(&self) -> bool { ... }
        }
      #+END_SRC

    - Naturally, *NOT every* /iterator/ knows how many items it will produce in
      advance; in the preceding examples, the ~char~'s /iterator/ on ~&str~ does
      *NOT* (UTF-8 is a variable-width encoding), so _you *CANNOT* use ~rposition~
      on strings_. But an /iterator/ over an /array/ of bytes certainly knows
      the array's length, so it can implement ~ExactSizeIterator~.

*** DONE ~fold~ - 349
    CLOSED: [2018-07-01 Sun 23:07]
    - Signature:
      #+BEGIN_SRC rust
        fn fold<A, F>(self, init: A, f: F) -> A
            where Self: Sized, F: FnMut(A, Self::Item) -> A;
      #+END_SRC

    - Example:
      #+BEGIN_SRC rust
        let a = [5, 6, 7, 8, 9, 10];

        assert_eq!(a.iter().fold(0, |n, _| n+1), 6);      // count
        assert_eq!(a.iter().fold(0, |n, i| n+i), 45);     // sum
        assert_eq!(a.iter().fold(1, |n, i| n*i), 151200); // product

        // max
        assert_eq!(a.iter().fold(i32::min_value(), |m, &i| std::cmp::max(m, i)),
                   10);
      #+END_SRC

    - =From Jian=
      =TODO= =???=
      There is NOT ~reduce~ in Rust as a method of /iterator/'s??????????

    - Note that the /accumulator values/ are *moved into and out* of the /closure/,
      so you can use ~fold~ with non-~Copy~ /accumulator/ types:
      =TODO= =???= =???=
      #+BEGIN_SRC rust
        let a = ["Pack ", "my ", "box ", "with ",
                 "five ", "dozen ", "liquor ", "jugs"];
        let pangram = a.iter().fold(String::new(),
                                    |mut s, &w| { s.push_str(w); s });
        assert_eq!(pangram, "Pack my box with five dozen liquor jugs");
      #+END_SRC

*** DONE ~nth~ - 350
    CLOSED: [2018-06-13 Wed 17:02]
    Skip ~n~ /items/ from the /iterator/, and returns the _NEXT_ /item/, or
    ~None~ if the sequence ends before the point.

    - ~.nth(0)~ is equivalent to ~.next()~.

    - Example:
      #+BEGIN_SRC rust
        let mut squares = (0..10).map(|i| i*i);

        assert_eq!(squares.nth(4), Some(16));
        assert_eq!(squares.nth(0), Some(25));
        assert_eq!(squares.nth(6), None);
      #+END_SRC

    - Its signature is shown here:
      #+BEGIN_SRC rust
        fn nth(&mut self, n: usize) -> Option<Self::Item>
            where Self: Sized;
      #+END_SRC

*** DONE ~last~ - 350
    CLOSED: [2018-06-13 Wed 17:06]
    The ~last~ /method/ *consumes* /items/ until the /iterator/ returns ~None~,
    and then returns the _last_ /item/.

    - Return ~None~ if no /items/ in this /iterator/.

    - Signature:
      ~fn last(self) -> Option<Self::Item>;~

    - Tips:
      If you have a /reversible iterator/, you may prefer ~iter.rev().next()~,
      rather than using the ~last()~ /method/.

*** DONE ~find~ - 351
    CLOSED: [2018-06-13 Wed 17:10]
    - Signature:
      #+BEGIN_SRC rust
        fn find<P>(&mut self, predicate: P) -> Option<Self::Item>
            where Self: Sized,
                  P: FnMut(&Self::Item) -> bool;
      #+END_SRC

      + It returns ~Some~ with the found element when the first time the passed
        in /closure/ returns ~true~.

      + It returns ~None~ if nothing found.

*** TODO Building Collections: ~collect~ and ~FromIterator~ - 351
    - Naturally, ~collect~ itself doesn't know how to construct all these types.

      Rather, when some collection type like ~Vec~ or ~HashMap~ knows how to
      construct itself from an /iterator/, it implements the ~std::iter::FromIterator~
      /trait/, for which ~collect~ is just a convenient veneer:
      #+BEGIN_SRC rust
      trait FromIterator<A>: Sized {
            fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> Self;
        }
      #+END_SRC

    - TODO

    - TODO

*** DONE The ~Extend~ Trait - 353
    CLOSED: [2018-07-02 Mon 02:01]
    - A type that implements the ~std::iter::Extend~ /trait/ has the ~extend~
      /method/ that can add /iterable/'s /items/

    - Example:
      #+BEGIN_SRC rust
        let mut v: Vec<i32> = (0 .. 5).map(|i| 1 << i).collect();
        v.extend(&[32, 57, 99, 163]);
        assert_eq!(v, &[1, 2, 4, 8, 16, 31, 57, 99, 163]);
      #+END_SRC

    - *All* of the /standard collections/ implement ~Extend~, so they *ALL* have
      this /method/; so does ~String~.

      Arrays and slices, which have a fixed length, do _NOT_.

    - Definition:
      #+BEGIN_SRC rust
        trait Extend<A> {
            fn extend<T>(&mut self, iter: T)
                where T: IntoIterator<Item=A>;
        }
      #+END_SRC

      + Obviously, this is _very SIMILAR to_ ~std::iter::FromIterator~: that *creates*
        a _new_ collection, whereas ~Extend~ *extends* an _existing_ collection.

          In fact, several implementations of ~FromIterator~ in the standard library
        simply create a new empty collection, and then call extend to populate it.

        For example, the implementation of ~FromIterator~ for
        ~std::collections::LinkedList~ works this way:
        #+BEGIN_SRC rust
          impl<T> FromIterator<T> for LinkedList<T> {
              fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
                  let mut list = Self::new();
                  list.extend(iter);
                  list
              }
          }
        #+END_SRC

*** DONE ~partition~ - 353
    CLOSED: [2018-07-02 Mon 02:21]
    - The ~partition~ /method/ divides an /iterator/'s items among TWO collections,
      using a closure to decide where each item belongs.

      For example,
      #+BEGIN_SRC rust
        let things = ["doorknob", "mushroom", "noodle", "giraffe", "grapefruit"];
        // Amazing fact: the name of a living thing always starts with an
        // odd-numbered letter.

        let (living, nonliving): (Vec<&str>, _)
            = things.iter().partition(|name| name.as_bytes()[0] & 1 != 0);

        assert_eq!(living, vec!["mushroom", "giraffe", "grapefruit"]);
        assert_eq!(nonliving, vec!["doorknob", "noodle"]);
      #+END_SRC

    - The signature:
      #+BEGIN_SRC rust
        fn partition<B, F>(self, f: F) -> (B, B)
            where Self: Sized,
                  B: Default + Extend<Self.Item>,
                  F: FnMaul(&Self::Item -> book;

      #+END_SRC

    - Whereas ~collect~ requires its /result type/ to implement ~FromIterator~,
      /partition/ instead requires ~std::default::Default~, which all Rust
      collections implement by returning an empty collection, and ~std::default::Extend~.

    - Q :: Why does NOT ~partition~ just split the /iterator/ into _two_ /iterators/,
           instead of building _two_ /collections/?
      + Reason 1:
        /Items/ drawn from the UNDERLYING /iterator/ but NOT yet drawn from the
        appropriate partitioned /iterator/ would need to be buffered somewhere
        -- you would end up building a collection of some sort *internally*,
        anywhay.

      + Fundamental Reason:
        *safety*
        /Partitioning/ one /iterator/ into _two_ would require the two partitions
        to share the _SAME_ UNDERLYING /iterator/. /Iterators/ must be _mutable_
        to be used; so the UNDERLYING /iterator/ would necessarily be shared,
        /mutable state/, which Rust's safety depends on avoiding.

** TODO Implementing Your Own Iterators - 354
   You can implement the ~IntoIterator~ and ~Iterator~ /traits/ for your own
   types, making all the _adapters_ and _consumers_ shown in this chapter
   available for use, along with lots of other library and /crate/ code written
   to work with the standard iterator interface.

   In this section, we'll show a simple iterator over a _range_ type, and then a
   more complex iterator over a _binary tree_ type.

   - *Range*
     #+BEGIN_SRC rust
       struct I32Range {
           start: i32,
           end: i32
       }

       impl Iterator for I32Range {
           type Item = i32;

           fn next(&mut self) -> Option<i32> {
               if self.start >= self.end {
                   return None;
               }
               let result = Some(self.start);
               self.start += 1;
               result
           }
       }
     #+END_SRC
     + Of course, a for loop uses ~IntoIterator::into_iter~ to convert its operand
       into an /iterator/.

       But the standard library provides a _BLANKET implementation_ of ~IntoIterator~
       for every type that implements ~Iterator~, so ~I32Range~ is ready for use:
       #+BEGIN_SRC rust
         let mut pi = 0.0;
         let mut numerator = 1.0;

         for k in (I32Range { start: 0, end: 14 }) {
             pi += numerator / (2*k + 1) as f64;
             numerator /= -3.0;
         }

         pi *= f64::sqrt(12.0);

         // IEEE 754 specifies this result exactly.
         assert_eq!(pi as f32, std:;f32::consts::PI);
       #+END_SRC

   - The ~I32Range~ case is special, in that the /iterable/ and /iterator/ are the
     SAME type.

     Many cases are NOT so simple.

   - *Binary Tree*
     #+BEGIN_SRC rust
       enum BinaryTree<T> {
           Empty,
           NonEmpty(Box<TreeNode<T>>)
       }

       struct TreeNode<T> {
           element: T,
           left: BinaryTree<T>,
           right: BinaryTree<T>
       }
     #+END_SRC

     + The classic way to walk a binary tree is to recurse, using the stack of
       function calls to keep track of your place in the tree and the nodes yet
       to be visited.
         _BUT_ when implementing ~Iterator~ for ~BinaryTree<T>~, each call to
       next must produce exactly one value and return.

       *To keep track of the tree nodes it has yet to produce, the iterator must
       maintain its own stack.* Here's one possible /iterator/ type for ~BinaryTree~:
       #+BEGIN_SRC rust
         use self::BinaryTree::*;

         // The state of an in-order traversal of a `BinaryTree`.
         struct TreeIter<'a, T: 'a> {
             // A stack of references to tree nodes. Since we use `Vec`'s
             // `push` and `pop` methods, the top of the stack is the end of the
             // vector.
             //
             // The node the iterator will visit next is at the top of the stack,
             // with those ancestors still unvisited below it. If the stack is empty,
             // the iteration is over.
             unvisited: Vec<&'a TreeNode<T>>
         }

         impl<'a, T: 'a> TreeIter<'a, T> {
             fn push_left_edge(&mut self, mut tree: &'a BinaryTree<T>) {
                 while let NonEmpty(ref node) = *tree {
                     self.unvisited.push(node);
                     tree = &node.left;
                 }
             }
         }

         impl<T> BinaryTree<T> {
             fn iter(&self) -> TreeIter<T> {
                 let mut iter = TreeIter { unvisited: Vec::new() };
                 iter.push_left_edge(self);
                 iter
             }
         }

         impl<'a, T: 'a> IntoIterator for &'a BinaryTree<T> {
             type Item = &'a T;
             type IntoIter = TreeIter<'a, T>;

             fn into_iter(self) -> Self::IntoIter {
                 self.iter()
             }
         }
       #+END_SRC

* TODO 16. Collections - 359
** TODO Overview - 360
   - Table 16-1. Summary of the standard collections
     =IMPORTANT=

** TODO ~Vec<T>~ - 361
   - Three ways to create vectors with the ~vec!~ macro:
     + ~let mut numbers: Vec<i32> = vec![];~

     + ~let words = vec!["step", "on", "no", "pets"];~

     + ~let mut buffer = vec![0u8; 1024];~

   - A vector has *three* fields: =See Figure 16-1=
     + the /length/
     + the /capacity/
     + a /pointer/ to a /heap/ allocation where the elements are stored.

   - The /empty vector/, initially has a capacity of 0. *NO* /heap/ memory is
     allocated for it _UNTIL_ the first element is added.

   - Like all /collections/, ~Vec~ implements ~std::iter::FromIterator~, so you
     can create a /vector/ from any /iterator/ using the /iterator/'s ~.collect()~
     /method/.

*** DONE Accessing Elements - 362
    CLOSED: [2018-06-22 Fri 04:19]
    - Getting elements of an /array/, /slice/, or /vector/ by index is straight-
      forward:
      #+BEGIN_SRC rust
        // Get a reference to an element
        let first_line = &lines[0];

        // Get a copy of an element
        let fifth_number = numbers[4];       // requires Copy
        let second_line = lines[1].clone();  // requires Clone

        // Get a reference to a slice
        let my_ref = &buffer[4..12];

        // Get a copy of a slice
        let my_copy = buffer[4..12].to_vec();  // requires Clone
      #+END_SRC
      + /Panic/ if an index is out of bounds.

    - Methods:
      + ~slice.first()~, ~slice.last()~, and ~slice.get(index)~
        If the item type is ~T~, the return type of this /method/ is ~Option<&T>~.

      + ~slice.first_mut()~, ~slice.last_mut()~, and ~slice.get_mut(index)~
        The variations of these that /borrow/ ~mut~ /references/.
        If the item type is ~T~, the return type of this /method/ is ~Option<&mut T>~.

      + The /mothods/ above return /references/ of value include /references/.
        The /method/ below make copies.

      + ~slice.to_vec()~
        *Clone* a whole /slice/, returning a new /vector/.
        Only available if the ellements are clonable -- ~where T: Clone~.

*** DONE Iteration - 364
    CLOSED: [2018-06-22 Fri 04:09]
    - /Vectors/ and /slices/ are /iterable/, either /BY value/ or /BY reference/,
      following the pattern described in "IntoIterator Implementations" on page 325.
      + Iterating over a ~Vec<T>~ produces items of type ~T~.
        The elements are *moved out* of the /vector/ one by one, consuming it.

      + Iterating over a value of type ~&[T; N]~ , ~&[T]~ , or ~&Vec<T>~ -- that
        is, a /reference/ to an /array/, /slice/, or /vector/ -- produces items
        of type ~&T~, /references/ to the individual elements, which are *NOT moved*.

      + Iterating over a value of type ~&mut [T; N]~, ~&mut [T]~, or ~&mut Vec<T>~
        produces items of type ~&mut T~.

      =From Jian=
      the way you use the whole /collection/ decide the way you use their /items/.

    - /Arrays/, /slices/, and /vectors/ also have ~.iter()~ and ~.iter_mut()~
      /methods/ (described in "~iter~ and ~iter_mut~ Methods" on page 324) for
      creating /iterators/ that produce /references/ to their elements.

    - =TODO=
      We'll cover some fancier ways to iterate over a slice in "Splitting" on page 368.

*** TODO Growing and Shrinking Vectors - 364
*** DONE Joining - 367
    CLOSED: [2018-06-13 Wed 17:25]
    TWO /methods/ work on _arrays of arrays_, by which we mean ANY /array/, /slice/,
    or /vector/ whose elements are themselves /arrays/, /slices/, or /vectors/.

    - ~slices.concat()~
      Example:
      #+BEGIN_SRC rust
        assert_eq!([[1, 2], [3, 4], [5, 6]].concat(),
                   vec![1, 2, 3, 4, 5, 6]);
      #+END_SRC

    - ~slices.join(&separator)~
      Example:
      #+BEGIN_SRC rust
        assert_eq!([[1, 2], [3, 4], [5, 6]].join(&0),
                   vec![1, 2, 0, 3, 4, 0, 5, 6]);
      #+END_SRC

    - 

*** TODO Splitting - 368
*** DONE Swapping - 370
    CLOSED: [2018-06-13 Wed 17:29]
    There's a convenience /method/ for swapping two elements:
    ~slice.swap(i, j)~ swaps the two elements ~slice[i]~ and ~slice[j]~.

    Vectors have a related method for efficiently removing any element:

    - ~vec.swap_remove(i)~ removes and returns ~vec[i]~. But no sliding.
        This is like ~vec.remove(i)~ except that instead of sliding the rest of
      the vector's elements over to close the gap, *it simply moves ~vec~'s last
      element into the gap.*

      *It's useful when you don't care about the order of the items left in the
      vector.*

*** TODO Sorting and Searching - 370
    - /Slices/ offer *three* /methods/ for sorting:
      + ~slice.sort()~
        NOTE

      + ~slice.sort_by(cmp)~
        NOTE

      + ~slice.sort_by_key(key)~
        NOTE

      All *three* /methods/ perform a /stable sort/.

    - ~slice.reverse()~

    - Once a /slice/ is sorted, it can be efficiently searched:
      + ~slice.binary_search(&value)~, ~slice.binary_search_by(&value, cmp)~, and
        ~slice.binary_search_by_key(&value, key)~
        NOTE

    - One /method/ for searching a /vector/ that is _NOT sorted_:
      + ~slice.contains(&value)~
        NOTE

    - To _find the location_ of a value in a /slice/, like ~array.indexOf(value)~
      in JavaScript, use an /iterator/: ~slice.iter().position(|x| *x == value)~
      This returns an ~Option<usize>~.

*** DONE Comparing Slices - 372
    CLOSED: [2018-06-13 Wed 18:15]
    - If a type ~T~ implements ~PartialEq~ /trait/ (~==~ and ~!=~) or
      ~PartialOrd~ /trait/ (~<~, ~<=~, ~>~, and ~>=~), then the corresponding
      /arrays/ ~[T; N]~, /slices/ ~[T]~, and /vectors/ ~Vec<T>~ support them
      too.

    - If ~T~ supports the operators ~<~, ~<=~, ~>~, and ~>=~ (the ~PartialOrd~
      /trait/, described in "Ordered Comparisons" on page 275), then /arrays/,
      /slices/, and /vectors/ of ~T~ do too.

      /Slice comparisons/ are lexicographical.

    - TWO convenience /methods/ perform common /slice comparisons/:
      + ~slice.starts_with(other)~
        Example:
        ~assert_eq!([1, 2, 3, 4].starts_with(&[1, 2]), true);~
        ~assert_eq!([1, 2, 3, 4].starts_with(&[2, 3]), false);~

      + ~slice.ends_with(other)~
        Example:
        ~assert_eq!([1, 2, 3, 4].ends_with(&[3, 4]), true);~

*** DONE Random Elements - 373
    CLOSED: [2018-06-22 Fri 04:36]
    Use ~rand~ /crate/, which is external, but it is maintained by the official
    Rust team.
    - The ~rand~ /crate/ offers two /methods/ for getting random output from an
      /array/, /slice/, or /vector/:

      + ~rng.choose(slice)~ returns a /reference/ to a _random element_ of a /slice/.
        Like ~slice.first()~ and ~slice.last()~, this returns an ~Option<&T>~ that
        is ~None~ only if the /slice/ is empty.

      + ~rng.shuffle(slice)~ _randomly reorders_ the elements of a /slice/ _IN PLACE_.
        The /slice/ _MUST_ be passed by ~mut~ /reference/.

    You can use ~rand::thread_rng()~ to get a random number generator that
    implements the ~rand::Rng~ /trait/. To call the /methods/ of this generator,
    you need to _import_ ~rand::Rng~. For example, shuffle the vector ~my_vec~:
    #+BEGIN_SRC rust
      use rand::{Rng, thread_rng};

      thread_rng().shuffle(&mut my_vec);
    #+END_SRC

*** TODO Rust Rules Out Invalidation Errors - 373

** DONE ~VecDeque<T>~ - 374
   CLOSED: [2018-07-02 Mon 02:46]
   - Methods:
     + ~deque.push_front(value)~

     + ~deque.push_back(value)~ adds a value at the end. (This method is used much
       more than ~.push_front()~, because the usual convention for queues is that
       values are added at the back and removed at the front, like people waiting
       in a line.)

     + ~deque.pop_front()~
       Returns ~Option<T>~

     + ~deque.pop_back()~
       Returns ~Option<T>~

     + ~deque.front()~ and ~deque.back()~ work like ~vec.first()~ and ~vec.last()~.
       They return a /reference/ to the front or back element of the queue.

       The return value is an ~Option<&T>~.

     + ~deque.front_mut()~ and ~deque.back_mut()~ work like ~vec.first_mut()~ and
       ~vec.last_mut()~ , returning ~Option<&mut T>~.

   - The implementation of ~VecDeque~ is a /ring buffer/, as shown in Figure 16-3.

     Page 375 - implementation details.

   - HOWEVER, because /deques/ _do *NOT* store their elements CONTIGUOUSLY in memory_,
     they do _NOT_ inherit all the /methods/ of /slices/.
     =IMPORTANT=

     One way to perform /vector/ and /slice/ operations on /deque/ data is to
     *convert the ~VecDeque~ to a ~Vec~, do the operation, and then change it back*:
     + ~Vec<T>~ implements ~From<VecDeque<T>>~ , so ~Vec::from(deque)~ turns a /deque/
       into a /vector/.

       This costs ~O(n)~ time, since it may require rearranging the elements.

     + ~VecDeque<T>~ implements ~From<Vec<T>>~, so ~VecDeque::from(vec)~ turns a
       /vector/ into a /deque/.

       This is also ~O(n)~, but it's *usually fast*, even if the /vector/ is large,
       because the /vector/'s /heap allocation/ can *simply be moved to* the new
       /deque/.

       This method makes it easy to *create a /deque/ with specified elements*, even
       though there is no standard ~vec_deque![]~ /macro/:
       #+BEGIN_SRC rust
         use std::collections::VecDeque;
         let v = VecDeque::from(vec![1, 2, 3, 4]);
       #+END_SRC

** DONE ~LinkedList<T>~ - 376
   CLOSED: [2018-07-02 Mon 02:54]
   - Each value of a /linked list/ is stored in a *separate* /heap allocation/.

   - ~std::collections::LinkedList<T>~ is a doubly linked list for Rust.
     It supports a SUBSET of ~VecDeque~'s /methods/.

     + The /methods/ that operate on the _front_ and _back_ of the sequence are
       all there; so are /iterator methods/, ~LinkedList::new()~, and A FEW OTHERS.

     + Because of the INEFFICIENCY, /methods/ that access elements by index are
       generally *omitted*,

     + As of Rust 1.17, Rust's ~LinkedList~ type has *NO* /methods/ for *removing
       a range* of elements from a list or *inserting* elements at specific locations
       in a list.

       *The API seems incomplete.*
       =From Jian= How about now??????? =TODO=

   - For now, the _main advantage_ of ~LinkedList~ over ~VecDeque~ is that
     combining two lists is very fast. ~list.append(&mut list2)~. It takes ~O(1)~
     time.

** DONE ~BinaryHeap<T>~ - 377
   CLOSED: [2018-07-02 Mon 03:06]
   For ~BinaryHeap~ the _greatest value_ always bubbles up to the front of the
   queue.

   - Most commonly used /methods/:
     + ~heap.push(value)~
       ~adds~ a value to the /heap/.

     + ~heap.pop()~
       *removes* and *returns* the _greatest value_ from the /heap/.
       It returns an ~Option<T>~.

     + ~heap.peek()~
       returns a /reference/ to the _greatest value_ in the /heap/.
       The return type is ~Option<&T>~.

   - ~BinaryHeap~ also supports a subset of the /methods/ on ~Vec~, including
     ~BinaryHeap::new()~, ~.len()~, ~.is_empty()~, ~.capacity()~, ~.clear()~, and
     ~.append(&mut heap2)~.

   - Example:
     #+BEGIN_SRC rust
       use std::collections::BinaryHeap;

       let mut heap = BinaryHeap::from(vec![2, 3, 8, 6, 9, 5, 4]);

       assert_eq!(heap.peek(), Some(&9));
       assert_eq!(heap.pop(), Some(9));

       assert_eq!(heap.pop(), Some(8));
       assert_eq!(heap.pop(), Some(6));
       assert_eq!(heap.pop(), Some(5));
       // ...
     #+END_SRC

   - ~BinaryHeap~ works for any types that implements the ~Ord~ build-in trait.

   - ~BinaryHeap~'s ~.iter()~ /method/ does *NOT* produce elements in order!!!
     You need to iterate in order elements like:
     #+BEGIN_SRC rust
       while let Some(task) = heap.pop() {
           handle(task);
       }
     #+END_SRC

** TODO ~HashMap<K, V>~ and ~BTreeMap<K, V>~ - 378
   - Entry :: key-value pair

   - *NO* two /entries/ have the same /key/.

   - A ~HashMap~ stores the /keys/ and /values/ in a /hash table/, so it requires
     a key type ~K~ that implements ~Hash~ and ~Eq~.
     Figure 16-5. A HashMap in memory

   - A ~BTreeMap~ stores the entries in order by /key/, in a tree strucgure, so it
     requires a /key/ type ~K~ that implements ~Ord~.
     Figure 16-6. A BTreeMap in memory

   - The Rust standard library uses /B-trees/ rather than /balanced binary trees/
     for the reasons:
     + /B-trees/ are faster on modern hardware.

     + /Binary trees/ may use fewer comparisons per search than a /B-tree/,
         BUT searching a /B-tree/ has better /locality/. This makes CPU cache
       misses rarer. It's a significant speed boost.

   - Create
     + ~HashMap::new()~ and ~BTreeMap::new()~

     + ~iter.collect()~
       ~iter~ must be an ~Iterator<Item=(K, V)>~

     + ~HashMap::with_capacity(n)~
       *CAUTION* this is for ~HashMap~ only, no similar function for ~BTreeMaps~.
       * There are also related methods
         - ~hash_map.capacity()~
         - ~hash_map.reserve(additional)~
         - ~hash_map.shrink_to_fit()~

   - Work with keys and values:
     + ~map.len()~ returns the NUMBER of /entries/.

     + ~map.is_empty()~

     + ~map.get(&key)~

     + ~map.get_mut(&key)~
       TODO TODO TODO

     + ~map.insert(key, value)~
       If the being inserted ~key~ is already in the /map/, the corresponding
       /value/ will be updated.
       * Returns the *old* /value/ with /type/ ~Option<V>~, if any.

     + ~map.extend(iterable)~

     + ~map.append(&mut map2)~
       Moves all /entries/ from ~map2~ into ~map~. Afterward, ~map2~ is EMPTY.

     + ~map.remove(&key)~
       * Returns the *removed* /value/ with /type/ ~Option<V>~, if any.

     + ~map.clear()~
       Remove all /entries/.

   - For ~BTreeMap<K, V>~ only because of its entries sorted by key:
     + ~btree_map.split_at(&key)~
       *splits* ~btree_map~ in two.
       1. Entries with keys _LESS THAN_ ~key~ are left in ~btree_map~.
       2. Returns a *new* ~BTreeMap<K, V>~ containing the _OTHER entries_.

*** TODO Entries - 381
    - TODO

    - All ~Entry~ values are created by the same /method/:
      + ~map.entry(key)~
        * Returns an ~Entry~ for the given ~key~.
          If _no such key_ in the /map/, this returns a _VACANT ~Entry~._

        * This method takes its ~self~ argument _by ~mut~ reference_ and returns
          an ~Entry~ with a MATCHING /lifetime/:
          #+begin_src rust
            pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V>
          #+end_src

        * Unfortunately, it is not possible to pass a /reference/ of type ~&str~
          to this method if the map has ~String~ keys. The ~.entry()~ /method/,
          in that case, requires a real String .
          TODO TODO TODO

    - ~Entry~ values provide TWO /methods/ for filling in _vacant entries_:
      + ~map.entry(key).or_insert(value)~
        TODO 
        TODO 
        TODO 

      + ~map.entry(key).or_insert_with(default_fn)~
        TODO
        TODO 
        TODO 
    
*** DONE Map Iteration - 383
    CLOSED: [2019-11-24 Sun 03:14]
    - There are several ways to iterate over a map:
      + Iterate and *consume* the /map/: ~for (k, v) in map~ produces ~(K, V)~

      + Iterate over a /shared reference/: ~for (k, v) in &map~ produces ~(&K, &V)~

      + Iterate over a ~mut~ /reference/: ~for (k, v) in &mut map~ produces ~(&K, &mut V)~
        *CAUTION* Again, the /key/ in a map can't be moddified!

    - Like /vectors/, /maps/ have ~.iter()~ and ~.iter_mut()~ /methods/ which return
      /by-reference iterators/, just like iterating over ~&map~ or ~&mut map~. In
      addition:
      + ~map.keys()~ returns an /iterator/ over just the /keys/, _by reference_
      + ~map.values()~ returns an /iterator/ over just the /values/, _by reference_
      + ~map.values_mut()~ returns an /iterator/ over the /values/, _by ~mut~ reference_

    - All ~HashMap~ /iterators/ visit the /map/'s /entries/ *in an arbitrary order*.
      ~BTreeMap~ /iterators/ visit them in order *by key*.

** DONE ~HashSet<T>~ and ~BTreeSet<T>~ - 384
   CLOSED: [2019-11-25 Mon 23:16]
   Rust's TWO /set types/, ~HashSet<T>~ and ~BTreeSet<T>~ are implemented as thin
   wrappers around ~HashMap<T, ()>~ and ~BTreeSet<T, ()>~
   - Create a /set/:
     + ~HashSet::new()~ and ~BTreeSet::new()~
     + ~iter.collect()~
     + ~HashSet::with_capacity(n)~

   - Basic /methods/ in common of the two /set types/:
     + ~set.len()~
     + ~set.is_empty()~
     + ~set.contains(&value)~
     + ~set.insert(value)~ returns
       * ~true~ if a value was added
       * ~false~ if it was already a member of the set.

     + ~set.remove(&value)~ returns
       * ~true~ if a value was removed
       * ~false~ if it was already wasn't a member of the set.

*** DONE Set Iteration - 384
    CLOSED: [2019-11-25 Mon 23:15]
    - _TWO_ ways to iterate over /sets/:
      + By /values/ (consume the /set/): ~for v in set~
      + By /shared reference/: ~for v in &set~

    - NOT Supported:
      Iterate over a set _by ~mut~ reference_
      There is NO WAY to get _a ~mut~ reference_ to a /value/ stored in a /set/.

    - ~set.iter()~ returns an /iterator/ over the members of /set/ /by reference/.

    - Order:
      + ~HashSet~ /iterators/ produce values _in an arbitrary order_.
      + ~BTreeSet~ /iterators/ produce values _in order_, like a _sorted_ vector.

*** DONE When Equal Values Are Different - 385
    CLOSED: [2019-11-25 Mon 22:51]
    - ~set.get(&value)~
      + return type: ~Option<&T>~.
      + returns a /shared reference/ to the member of /set/ that's equal to ~value~.

    - ~set.take(&value)~
      + return type ~Option<T>~.
      + like ~set.remove(&value)~, _BUT_ it returns the removed value, if any.

    - ~set.replace(&value)~
      + return type ~Option<T>~.
      + like ~set.insert(value)~, but if /set/ already contains a value that's
        equal to ~value~, this replaces and returns the _OLD value_.

*** DONE Whole-Set Operations - 385
    CLOSED: [2019-11-25 Mon 22:58]
    - Operations on whole sets (not a single element):
      All below alphabetical name /methods/ return /iterators/;
      all below symbol name /methods/ return _NEW set_.

      + ~set1.intersection(&set2)~
        ~&set1 & set2~

      + ~set1.union(&set2)~ returns an /iterator/.
        ~&set1 | &set2~ returns a _NEW_ /set/.

      + ~set1.difference(&set2)~ returns an /iterator/.
        ~&set1 - &set2~ returns a _NEW_ /set/.

      + ~set1.symmetric_difference(&set2)~
        ~&set1 ^ &set2~

    - There are THREE /methods/ for testing _relationships between sets_:
      + ~set1.is_disjoint(set2)~
      + ~set1.is_subset(set2)~
      + ~set1.is_superset(set2)~
      + ~==~ and ~!=~

** TODO Hashing - 387
*** TODO Using a Custom Hashing Algorithm - 388

** DONE Beyond the Standard Collections - 389
   CLOSED: [2019-11-25 Mon 23:09]
   - Example:
     TODO "Generic Enums" on page 218

   - Rust collection, as much of Rust standard library, they're designed to ensure
     that the need to write ~unsafe~ is as rare as possible.

     =From Jian=
     This also means in the Rust standard library collection implementations source
     code, there are a lot ~unsafe~ code, which are mostly used for efficiency.

* DONE 17. Strings and Text - 391
  CLOSED: [2018-07-11 Wed 16:01]
** DONE Some Unicode Background - 392
   CLOSED: [2018-07-01 Sun 22:05]
*** DONE ASCII, Latin-1, and Unicode - 392
    CLOSED: [2018-07-01 Sun 20:44]
    - /ASCII/: _0 ~ 0x7f_

    - /Unicode/:
      + assigns _0 ~ 0xff_ to the same characters as the ISO/IEC 8859-1 character
        set, an 8-bit superset of ASCII for use with Western European languages.

        Unicode calls this range of code points *the Latin-1 code block*.

        * Since /Unicode/ is a superset of /Latin-1/, converting Latin-1 to Unicode
          doesn't even require a table:
          #+BEGIN_SRC rust
            fn latin1_to_char(latin1: u8) -> char {
                latin1 as char
            }
          #+END_SRC

        * The reverse conversion:
          #+BEGIN_SRC rust
            fn char_to_latin1(c: char) -> Option<u8> {
                if c as u32 <= 0xff {
                    Some(c as u8)
                } else {
                    None
                }
            }
          #+END_SRC

*** DONE UTF-8 - 392
    CLOSED: [2018-07-01 Sun 22:05]
    The Rust ~String~ and ~str~ types represent text using the UTF-8 encoding form.
    UTF-8 encodes a character as a sequence of *one to four bytes* (Figure 17-1).

    - Two restrictions on well-formed UTF-8 sequences:
      + Only the *shortest* encoding is the well-formed one.

        This rule ensures that there is EXACTLY one UTF-8 encoding for a given
        /code point/.

      + Well-formed UTF-8 *MUST NOT* encode numbers from ~0xd800~ through ~0xdfff~,
        of beyond ~0x10ffff~: those are
        * either reserved for noncharacter purposes
          OR
        * outside Unicode's range entirely.

    - Example:
      #+BEGIN_SRC rust
        assert_eq!("うどん: udon".as_bytes(),
                   &[0xe3, 0x81, 0x86, // う
                     0xe3, 0x81, 0xa9, // ど
                     0xe3, 0x82, 0x93, // ん
                     0x3a, 0x20, 0x75, 0x64, 0x6f, 0x6e // : udon
                   ]);
      #+END_SRC

    - The diagram shows some very helpful properties of UTF-8:
      Page 393 ~ 394

*** DONE Text Directionality - 394
    CLOSED: [2018-07-01 Sun 22:05]
    - Unicode stores characters in the order in which they would normally be written
      or read, so the initial bytes of a string holding, say, Hebrew text encode
      the character that would be written at the right: Example-Code-Page 394!

      =From Jian= I CANNOT copy the example code here -- the behavior
      of Hebrew text is weird.

    - A few method names in the standard library use the terms left and right to
      mean the start and end of the text.

** DONE Characters (~char~) - 394
   CLOSED: [2018-07-01 Sun 22:38]
   A Rust ~char~ is a 32-bit value holding a /Unicode code point/.

   - A ~char~ is guaranteed to fall in the range _from 0 to 0xd7ff_, or _in the
     range 0xe000 to 0x10ffff_; all the /methods/ for creating and manipulating
     ~char~ values *ensure* that this is true.

   - The ~char~ type implements ~Copy~ and ~Clone~, along with all the usual /traits/
     for _comparison_, _hashing_, and _formatting_.

   - Notations:
     In the descriptions that follow, the variable ~ch~ is always of type ~char~.

*** DONE Classifying Characters - 395
    CLOSED: [2018-07-01 Sun 22:15]
    - ~ch.is_numeric()~
      A numeric character. This includes the Unicode general categories
      _"Number; digit" and "Number; letter"_, but *NOT* _"Number; other"_

    - ~ch.is_alphabetic()~
      An alphabetic character: Unicode’s "Alphabetic" derived property.

    - ~ch.is_alphanumeric()~
      Either numeric or alphabetic, as defined above.

    - ~ch.is_whitespace()~
      A whitespace character: Unicode character property"WSpace=Y".

    - ~ch.is_control()~
      A control character: Unicode's "Other, control" general category.

*** DONE Handling Digits - 395
    CLOSED: [2018-07-01 Sun 22:38]
    - ~ch.to_digit(radix)~
      Return ~Option(u32)~

      + This recognizes ONLY ASCII digits, NOT the broader class of characters covered
        by ~char::is_numeric~.

      + The ~radix~ parameter can range from 2 to 36.
        For /radixes/ larger than 10, /ASCII letters/ of either case are
        considered digits with values from 10 through 35.

    - ~std::char::from_digit(num, radix)~
      Return ~Option(u32)~

    - ~ch.is_digit(radix)~

    - For example:
      #+BEGIN_SRC rust
        assert_eq!('F'.to_digit(16), Some(15));
        assert_eq!(std::char::from_digit(15, 16), Some('f'));
        assert!(char::is_digit('f', 16));
      #+END_SRC

*** DONE Case Conversion for Characters - 396
    CLOSED: [2018-07-01 Sun 22:32]
    - ~ch.is_lowercase()~ and ~ch.is_uppercase()~

    - ~ch.to_lowercase()~ and ~ch.to_uppercase()~
      Return /iterators/ that produce the characters of the lower- and uppercase
      equivalents of ~ch~, according to the *Unicode Default Case Conversion
      algorithms*:
      #+BEGIN_SRC rust
        let mut upper = 's'.to_uppercase();
        assert_eq!(upper.next(), Some('S'));
        assert_eq!(upper.next(), None);
      #+END_SRC

      + These /methods/ return an /iterator/ _INSTEAD of a single character_
        because case conversion in Unicode is *NOT* always a one-to-one process:
        #+BEGIN_SRC rust
          // The uppercase form of the German letter "sharp S" is "SS":
          let mut upper = 'ß'.to_uppercase();
          assert_eq!(upper.next(), Some('S'));
          assert_eq!(upper.next(), Some('S'));
          assert_eq!(upper.next(), None);

          // Unicode says to lowercase Turkish dotted capital 'İ' to 'i'
          // followed by `'\u{307}'`, COMBINING DOT ABOVE, so that a
          // subsequent conversion back to uppercase preserves the dot.
          let ch = 'İ'; // `'\u{130}'`
          let mut lower = ch.to_lowercase();
          assert_eq!(lower.next(), Some('i'));
          assert_eq!(lower.next(), Some('\u{307}'));
          assert_eq!(lower.next(), None);
        #+END_SRC

        + As a convenience, these iterators implement the ~std::fmt::Display~ /trait/,
          so you can pass them directly to a ~println!~ or ~write!~ /macro/.

*** DONE Conversions to and from Integers - 396
    CLOSED: [2018-07-01 Sun 22:26]
    - ~char~'s to Integers
      Rust's as operator will convert a ~char~ to _ANY_ integer type,
      *silently masking off any upper bits*:
      #+BEGIN_SRC rust
        assert_eq!('B' as u32, 66);
        assert_eq!('饂' as u8, 66);   // upper bits of 1001100101000010 is truncated, and only keep 1000010
        assert_eq!('二' as i8, -116); // same
      #+END_SRC

    - Integers to ~char~'s
      There are _invalid_ code points. If you use ~as~, you'll get some /panic/.
      #+BEGIN_SRC rust
        assert_eq!(char::from(66), 'B');
        assert_eq!(std::char::from_u32(0x9942), Some('饂'));
        assert_eq!(std::char::from_u32(0xd800), None); // reserved for UTF-16
      #+END_SRC

** DONE ~String~ and ~str~ - 397
   CLOSED: [2018-07-11 Wed 16:01]
   - Rust's ~String~ and ~str~ types are *guaranteed* to hold only _well-formed
     UTF-8_.
     + The library ensures this _by restricting_
       * the ways you can create String and str values
       * the operations you can perform on them,

       such that the values are well-formed when introduced, and remain so as
       you work with them.

       *ALL* their /methods/ protect this guarantee:
       no safe operation on them can introduce ill-formed UTF-8.

       This simplifies code that works with the text.

   - Rust places /text-handling methods/ on either ~str~ and ~String~ *depending
     on* whether the /method/ needs a *resizable buffer*, or is happy just using
     the text in place.

     =TODO=
     Since ~String~ _dereferences to_ ~&str~, *EVERY* /method/ defined on ~str~
     is directly available on ~String~ as well.

     =TODO=
     This section presents methods from both types, grouped by rough function.

   - These /methods/ index text _by byte_ offsets, and measure its length _in bytes_,
     _rather than characters_.

     In practice,
     _given the nature of Unicode_, *indexing by character is _NOT_ as useful as
     it may seem, and byte offsets are faster and simpler.*
       If you try to use a byte offset that lands in the midst of some character's
     UTF-8 encoding, the method panics, so you can't introduce ill-formed UTF-8
     this way.

   - A String is implemented as
     a wrapper around a ~Vec<u8>~ that *ensures* the /vector/'s contents are
     always well-formed UTF-8.

       Rust *WILL NEVER* change ~String~ to use a more complicated representation,
     so you can assume *that ~String~ shares ~Vec~'s performance characteristics.*

   - Notations in this section
     |---------------+-------------------------------------------------------------|
     | Variable Name | Presumed type                                               |
     |---------------+-------------------------------------------------------------|
     | string        | ~String~                                                    |
     |---------------+-------------------------------------------------------------|
     | slice         | ~&str~ or something that dereferences to one, like ~String~ |
     |               | or ~Rc<String>~                                             |
     |---------------+-------------------------------------------------------------|
     | ch            | ~char~                                                      |
     |---------------+-------------------------------------------------------------|
     | n             | ~usize~, a length                                           |
     |---------------+-------------------------------------------------------------|
     | i , j         | ~usize~, a byte offset                                      |
     |---------------+-------------------------------------------------------------|
     | range         | A range of ~usize~ byte offsets, either fully bounded like  |
     |               | ~i..j~, or partly bounded like ~i..~, ~..j~, or ~..~        |
     |---------------+-------------------------------------------------------------|
     | pattern       | Any pattern type: ~char~, ~String~, ~&str~, ~&[char]~, or   |
     |               | ~FnMut(char) -> bool~                                       |
     |---------------+-------------------------------------------------------------|

     =TODO= We describe pattern types in “Patterns for Searching Text” on page 402.

*** DONE Creating String Values - 398
    CLOSED: [2018-07-08 Sun 00:47]
    There are a few common ways to create ~String~ values:
    - ~String::new()~ returns a fresh, empty string.
      This has no heap-allocated buffer, but will allocate one as needed.

    - ~String::with_capacity(n)~ returns a fresh, empty string with a buffer *pre-
      allocated* to hold at least ~n~ bytes.
        Use this way to build a string when you know the length of the string in
      advance. This is more efficient than resizing the buffer as you build the
      string.
        The string will _still grow its buffer as needed_ if its length _exceeds_
      ~n~ bytes. Like vectors, strings have ~capacity~, ~reserve~, and ~shrink_to_fit~
      /methods/, but usually the default allocation logic is fine.

    - ~slice.to_string()~ allocates a fresh ~String~ whose contents are a copy of
      /slice/.

    - ~iter.collect()~ constructs a string by concatenating an iterator's items,
      which _can be_ ~char~, ~&str~, or ~String~ values.

      + For example, to remove all spaces from a string, you can write:
        #+BEGIN_SRC rust
          let spacey = "man hat tan";
          let spaceless: String =
              spacey.chars().filter(|c| !c.is_whitespace()).collect();
          assert_eq!(spaceless, "manhattan");
        #+END_SRC

      Using ~collect~ this way takes advantage of ~String~'s implementation of
      the ~std::iter::FromIterator~ /trait/.

    - The ~&str~ type *CANNOT* implement ~Clone~:
      the /trait/ requires clone on a ~&T~ to return a ~T~ value, but ~str~ is
      *unsized*.

      However, ~&str~ does implement ~ToOwned~, which lets the implementer specify
      its owned equivalent, so ~slice.to_owned()~ returns a copy of slice as a
      freshly allocated ~String~.

*** DONE Simple Inspection - 398
    CLOSED: [2018-07-08 Sun 00:56]
    These /methods/ get basic information from /string slices/:
    - ~slice.len()~ is the length of /slice/, *in bytes*.

    - ~slice.is_empty()~ is ~true~ if ~slice.len() == 0~.

    - ~slice[range]~ returns a /slice/ *borrowing* the given portion of ~slice~.
      Partially bounded and unbounded ranges are OK. For example:
      #+BEGIN_SRC rust
        let full = "bookkeeping";
        assert_eq!(&full[..4], "book");
        assert_eq!(&full[5..], "eeping");
        assert_eq!(&full[2..4], "ok");
        assert_eq!(full[..].len(), 11);
        assert_eq!(full[5..].contains("boo"), false);
      #+END_SRC

    - You *CANNOT* index a /string slice/ with a _SINGLE position_, like ~slice[i]~.

      Fetching a _SINGLE character_ at a given byte offset is a bit clumsy:
      you *MUST* produce a ~chars~ /iterator/ over the /slice/, and ask it to
      parse one character's UTF-8:
      #+BEGIN_SRC rust
        let parenthesized = "Rust (饂)";
        assert_eq!(parenthesized[6..].chars().next(), Some('饂'));
      #+END_SRC

      =TODO=
      However, you should *RARELY need* to do this.
      Rust has *much NICER ways* to iterate over /slices/, which we describe in
      “Iterating over Text” on page 403.

    - ~slice.split_at(i)~ returns a tuple of *TWO* shared /slices/ *borrowed* from
      /slice/:
      the portion up to byte offset ~i~, and the portion after it. In other words, this
      returns ~(slice[..i], slice[i..])~ .

    - ~slice.is_char_boundary(i)~ is ~true~ if the byte offset ~i~ falls between
      /character boundaries/, and is thus suitable as an offset into /slice/.

    Naturally, /slices/ can *be compared for* /equality/, /ordered/, and /hashed/.

    Ordered comparison simply _treats the string as_ a sequence of /Unicode code
    points/ and compares them in /lexicographic order/.

*** DONE Appending and Inserting Text - 399
    CLOSED: [2018-07-08 Sun 01:36]
    - The following /methods/ add text to a ~String~:
      + ~string.push(ch)~ appends the character ~ch~ to the *end* string.

      + ~string.push_str(slice)~ appends the full contents of slice .

      + ~string.extend(iter)~ appends the items produced by the /iterator/ ~iter~
        to the string.
          The /iterator/ _can produce_ ~char~, ~str~, or ~String~ values. These
        are ~String~'s implementations of ~std::iter::Extend~:
        #+BEGIN_SRC rust
          let mut also_spaceless = "con".to_string();
          also_spaceless.extend("tri but ion".split_whitespace());
          assert_eq!(also_spaceless, "contribution");
        #+END_SRC

      + ~string.insert(i, ch)~ inserts the single character ~ch~ _AT byte offset_
        ~i~ in string.
          This entails *shifting* over any characters after ~i~ to make room for
        ~ch~, so building up a string this way can require time *quadratic in the
        length of the string*. =????= =TODO= =TODO=

      + ~string.insert_str(i, slice)~ does the same for /slice/, with the same per-
        formance caveat.

    - Since ~String~ implements ~std::fmt::Write~, the ~write!~ and ~writeln!~ /macros/
      can *append* /formatted text/ to ~String~'s:
      #+BEGIN_SRC rust
        use std::fmt::Write;

        let mut letter = String::new();
        writeln!(letter, "Whose {} these are I think I know", "rutabagas")?;
        writeln!(letter, "His house is in the village though;")?;
        assert_eq!(letter, "Whose rutabagas these are I think I know\n\
                            His house is in the village though;\n");
      #+END_SRC
      + Since ~write!~ and ~writeln!~ are designed for writing to /output streams/,
        they return a ~Result~, which Rust complains if you ignore. This code uses
        the ~?~ operator to handle it, but writing to a ~String~ is actually
        infallible, so in this case calling ~.unwrap()~ would be OK too.

    - Since ~String~ implements ~Add<&str>~ and ~AddAssign<&str>~, you can write
      code like this:
      #+BEGIN_SRC rust
        let left = "partners".to_string();
        let mut right = "crime".to_string();
        assert_eq!(left + " in " + &right, "partners in crime");
        right += " doesn't pay";
        assert_eq!(right, "crime doesn't pay");
      #+END_SRC
      + When applied to strings, the ~+~ operator takes its /LEFT operand/ _by value_,
        so it can actually *reuse* that ~String~ as the result of the addition.
          As a consequence, _IF_ the /left operand/'s buffer is *large enough* to
        hold the result, _NO_ allocation is needed.

      + In an unfortunate lack of symmetry, the /LEFT operand/ of ~+~ *CANNOT* be
        a ~&str~, so you CANNOT write: ~let parenthetical = "(" + string + ")";~
        The right way is: ~let parenthetical = "(".to_string() + string + ")";~

        HOWEVER, this restriction does *discourage* building up strings from the
        end backward. This approach performs *poorly* because the text must be
        repeatedly shifted toward the end of the buffer.
        =TODO= =TODO= =TODO=

    - Building strings from beginning to end by appending small pieces, however,
      is *efficient*.
        A String behaves the way a /vector/ does, always _AT LEAST_ *doubling* its
      buffer's size when it needs more /capacity/.
      =Read "Building Vectors Element by Element" on page 62=

      Use ~String::with_capacity~ to crate strings if you know the right buffer
      size, and it can be more efficient by avoding calling to the /heap allocator/.

*** DONE Removing Text - 401
    CLOSED: [2018-07-08 Sun 01:02]
    ~String~ has a few methods for *removing text* (these do *not affect* the
    string's /capacity/; use ~shrink_to_fit~ if you need to free memory):
    - ~string.clear()~ resets string to the *empty* string.

    - ~string.truncate(n)~ discards all characters *after* the _byte offset_ ~n~,
      leaving string with a length of at most ~n~.

      If string is _shorter than_ ~n~ bytes, this has _NO effect_.

    - ~string.pop()~ removes the *last* character from string, if any, and returns
      it as an ~Option<char>~.

    - ~string.remove(i)~ removes the /character/ _at byte offset_ ~i~ from string
      and returns it, *shifting* any following characters toward the front.

      This takes time _linear in the number of following characters_.

    - ~string.drain(range)~ returns an /iterator/ over the given range of _byte
      indices_, and *removes* the characters *once* the /iterator/ is /dropped/.
      Characters after the range are shifted toward the front:
      #+BEGIN_SRC rust
        let mut choco = "chocolate".to_string();
        assert_eq!(choco.drain(3..6).collect::<String>(), "col");
        assert_eq!(choco, "choate");
      #+END_SRC
      If you just want to remove the range, you can just drop the iterator
      immediately, without drawing any items from it:
      #+BEGIN_SRC rust
        let mut winston = "Churchill".to_string();
        winston.drain(2..6);  // drop the generated iterator.
        assert_eq!(winston, "Chill");
      #+END_SRC

*** DONE Conventions for Searching and Iterating - 401
    CLOSED: [2018-07-08 Sun 16:55]
    Rust's standard library functions for searching text and iterating over text
    follow some naming conventions to make them easier to remember:

    - Most operations process text from start to end,
      BUT operations with names starting with ~r~ work _from end to start_.
      For example, ~rsplit~ is the end-to-start version of ~split~.

      In some cases changing direction can affect not only the order in which
      values are produced but also the values themselves.

      =TODO=
      See the diagram in Figure 17-3 for an example of this.

    - Iterators with names ending in ~n~ limit themselves to a given number of
      matches.

    - Iterators with names ending in ~_indices~ produce, together with their usual
      iteration values, the byte offsets in the /slice/ at which they appear.

    The standard library does _NOT_ provide all combinations for every operation.
    For example, many operations do _NOT_ need an ~n~ variant, as it's easy enough
    to simply end the iteration early.

*** DONE Patterns for Searching Text - 402 - =Re-READ=
    CLOSED: [2018-07-08 Sun 17:09]
    - When a standard library function needs to _search_, _match_, _split_, or
      _trim_ text, it accepts several different types to represent what to look
      for:
      #+BEGIN_SRC rust
        let haystack = "One fine day, in the middle of the night";
        assert_eq!(haystack.find(','), Some(12));
        assert_eq!(haystack.find("night"), Some(35));
        assert_eq!(haystack.find(char::is_whitespace), Some(3));
      #+END_SRC

      These types are called /patterns/, and most operations support them:

      #+BEGIN_SRC rust
        assert_eq!("## Elephants"
                   .trim_left_matches(|ch: char| ch == '#' || ch.is_whitespace()),
                   "Elephants");
      #+END_SRC

    - The standard library supports *FOUR* main kinds of /patterns/:
      + A ~char~ as a /pattern/ matches that character.

      + A ~String~ or ~&str~ or ~&&str~ as a /pattern/ matches a substring equal
        to the /pattern/.

      + A ~FnMut(char) -> bool~ /closure/ as a /pattern/ matches a SINGLE character
        for which the /closure/ returns ~true~.

      + A ~&[char]~ as a /pattern/ (not a ~&str~, but a /slice/ of ~char~ values)
        matches any SINGLE character that appears in the list. Note that if you
        write out the list as an array literal, you may need to use an ~as~
        expression to get the type right:
        #+BEGIN_SRC rust
          let code = "\t    function noodle() { ";
          assert_eq!(code.trim_left_matches(&[' ', '\t'] as &[char]),
                     "function noodle() { ");
          // Shorter equivalent: &[' ', '\t'][..]
        #+END_SRC
        Otherwise, Rust will be confused by the fixed-size array type ~&[char; 2]~,
        which is unfortunately not a pattern type.

    - In the library's own code, a /pattern/ is any type that implements the
      ~std::str::Pattern~ /trait/.

      The details of ~Pattern~ are *NOT yet stable*, so you *CANNOT implement* it
      for your own types in stable Rust, but the door is open to permit regular
      expressions and other sophisticated patterns in the future. Rust does
      guarantee that the pattern types supported now will continue to work in
      the future.

*** DONE Searching and Replacing - 403
    CLOSED: [2018-07-09 Mon 18:18]
    Rust has a few /methods/ for *searchings* for /patterns/ in /slices/ and possibly
    *replacing* them with new text:
    - ~slice.contains(pattern)~ returns ~true~ if ~slice~ contains a match for
      /pattern/.

    - ~slice.starts_with(pattern)~ and ~slice.ends_with(pattern)~ return ~true~ if
      /slice/'s initial or final text matches /pattern/ :
      ~assert!("2017".starts_with(char::is_numeric));~

    - ~slice.find(pattern)~ and ~slice.rfind(pattern)~ return ~Some(i)~ if /slice/
      contains a match for /pattern/, where ~i~ is the _byte offset_ at which the
      pattern appears. The ~find~ method returns the _first_ match, ~rfind~ the _last_:
      #+BEGIN_SRC rust
        let quip = "We also know there are known unknowns";
        assert_eq!(quip.find("know"), Some(8));
        assert_eq!(quip.rfind("know"), Some(31));
        assert_eq!(quip.find("ya know"), None);
        assert_eq!(quip.rfind(char::is_uppercase), Some(0));
      #+END_SRC

    - ~slice.replace(pattern, replacement)~ returns a new ~String~ formed by
      replacing all matches for pattern with replacement :
      #+BEGIN_SRC rust
        assert_eq!("The only thing we have to fear is fear itself"
                   .replace("fear", "spin"),
                   "The only thing we have to spin is spin itself");
        assert_eq!("`Borrow` and `BorrowMut`"
                   .replace(|ch:char| !ch.is_alphanumeric(), ""),
                   "BorrowandBorrowMut");
      #+END_SRC

    - ~slice.replacen(pattern, replacement, n)~ does the same, but replaces at most
      the _first n_ matches.

*** DONE Iterating over Text - 403 - *Re-READ*
    CLOSED: [2018-07-09 Mon 18:33]
    The standard library provides several ways to *ITERATE over a /slice/'s text*.
    Figure 17-3 shows examples of some.

    - =From Jian=
      If Figure 17-3 has table boundaries in the figure, the appearence will be
      better.

    - =TODO= NOTE

    - Methods:
      + ~slice.chars()~ returns an iterator over slice ’s characters.

      + ~slice.char_indices()~ returns an iterator over slice ’s characters and their byte
        offsets:
        #+BEGIN_SRC rust
          assert_eq!("élan".char_indices().collect::<Vec<_>>(),
                     vec![(0, 'é'), // has a two-byte UTF-8 encoding
                          (2, 'l'),
                          (3, 'a'),
                          (4, 'n')]);
        #+END_SRC
        Note that this is not equivalent to .chars().enumerate() , since it supplies each
        character’s byte offset within the slice, instead of just numbering the characters.

      + ~slice.bytes()~ returns an iterator over the individual bytes of slice , exposing
        the UTF-8 encoding:
        #+BEGIN_SRC rust
          assert_eq!("élan".bytes().collect::<Vec<_>>(),
                     vec![195, 169, b'l', b'a', b'n']);
        #+END_SRC

      + ~slice.lines()~ returns an /iterator/ over the lines of /slice/.
        Lines are terminated by ~"\n"~ or ~"\r\n"~.
        Each item produced is a ~&str~ borrowing from /slice/.
        The items do *NOT* include the lines' terminating characters.

      + ~slice.split(pattern)~ returns an /iterator/ over the portions of /slice/
        separated by matches of pattern.

        This *produces empty strings* between immediately adjacent matches, as
        well as for matches at the beginning and end of /slice/.

      + The ~slice.rsplit(pattern)~ method is the same, but scans /slice/ from end
        to start, producing matches in that order.

      + ~slice.split_terminator(pattern)~ and ~slice.rsplit_terminator(pattern)~
        are similar, except that the pattern is treated as a terminator, not a separator: if
        pattern matches at the right end of slice , the iterators do not produce an empty
        slice representing the empty string between that match and the end of the slice, as
        split and rsplit do. For example:
        #+BEGIN_SRC rust
          // The ':' characters are separators here. Note the final "".
          assert_eq!("jimb:1000:Jim Blandy:".split(':').collect::<Vec<_>>(),
          vec!["jimb", "1000", "Jim Blandy", ""]);
          // The '\n' characters are terminators here.
          assert_eq!("127.0.0.1 localhost\n\
          127.0.0.1 www.reddit.com\n"
          .split_terminator('\n').collect::<Vec<_>>(),
          vec!["127.0.0.1 localhost",
          "127.0.0.1 www.reddit.com"]);
          // Note, no final ""!
        #+END_SRC

      + The ~slice.splitn(n, pattern)~ and ~slice.rsplitn(n, pattern)~ are like
        ~split~ and ~rsplit~, except that they split the string into *AT MOST ~n~
        /slices/,* at the first or last n-1 matches for pattern .

      + ~slice.split_whitespace()~ returns an /iterator/ over the whitespace-separated
        portions of /slice/.
          A run of multiple whitespace characters is considered a single separator.
          Trailing whitespace is ignored. This uses the *same definition of whitespace*
        as ~char::is_whitespace~:
        #+BEGIN_SRC rust
          let poem = "This is just to say\n\
                      I have eaten\n\
                      the plums\n\
                      again\n";

          assert_eq!(poem.split_whitespace().collect::<Vec<_>>(),
                     vec!["This", "is", "just", "to", "say",
                          "I", "have", "eaten", "the", "plums",
                          "again"]);
        #+END_SRC

      + ~slice.matches(pattern)~ returns an /iterator/ over the matches for pattern
        in /slice/.

        ~slice.rmatches(pattern)~ is the same, but /iterates/ from end to start.

      + ~slice.match_indices(pattern)~ and ~slice.rmatch_indices(pattern)~ are
        similar, except that the items produced are ~(offset, match)~ pairs,
        where offset is the *byte offset* at which the match _begins_, and match
        is the matching /slice/.

*** DONE Trimming - 406
    CLOSED: [2018-07-08 Sun 01:09]
    To /trim/ a string is to remove text, usually whitespace, from the beginning
    or end of the string.
      It's often useful in cleaning up input read from a file where the user might
    have indented text for legibility, or accidentally left trailing whitespace on
    a line.
    - ~slice.trim()~ returns a /subslice/ of /slice/ that *omits* _ANY leading
      and trailing whitespace_. ~slice.trim_left()~ omits only leading whitespace,
      ~slice.trim_right()~ only trailing whitespace:
      #+BEGIN_SRC rust
        assert_eq!("\t*.rs ".trim(), "*.rs");
        assert_eq!("\t*.rs ".trim_left(), "*.rs ");
        assert_eq!("\t*.rs ".trim_right(), "\t*.rs");
      #+END_SRC

    - ~slice.trim_matches(pattern)~ returns a /subslice/ of /slice/ that *omits*
      ALL matches of ~pattern~ *from the _beginning_ and _end_.*
        The ~trim_left_matches~ and ~trim_right_matches~ methods do the same for
      only leading or trailing matches:
      ~assert_eq!("001990".trim_left_matches('0'), "1990");~

    Note that the terms ~left~ and ~right~ in these methods' names always refer
    to the *START* and *END* of the slice, respectively, *regardless of the
    directionality of the text they hold.*

*** DONE Case Conversion for Strings - 406
    CLOSED: [2018-07-08 Sun 01:12]
    The /methods/ ~slice.to_uppercase()~ and ~slice.to_lowercase()~ return a freshly
    allocated string holding the text of /slice/ converted to uppercase or lowercase.
      *The result may not be the same length as /slice/;* (=From Jian= You may
    remember the relation between ß and SS in German) see “Case Conversion for
    Characters” on page 396 for details.

*** DONE Parsing Other Types from Strings - 406
    CLOSED: [2018-07-08 Sun 01:44]
    - Rust provides /standard traits/ for both
      + parsing values from strings
      + producing textual representations of values.

    - If a type implements the ~std::str::FromStr~ /trait/, then it provides a
      standard way to parse a value _from_ a /string slice/:
      #+BEGIN_SRC rust
        pub trait FromStr: Sized {
            type Err;
            fn from_str(s: &str) -> Result<Self, Self::Err>;
        }
      #+END_SRC

    - *ALL* the USUAL /machine types/ implement ~FromStr~:
      #+BEGIN_SRC rust
        use std::str::FromStr;

        assert_eq!(usize::from_str("3628800"), Ok(3628800));
        assert_eq!(f64::from_str("128.5625"), Ok(128.5625));
        assert_eq!(bool::from_str("true"), Ok(true));
        assert!(f64::from_str("not a float at all").is_err());
        assert!(bool::from_str("TRUE").is_err());
      #+END_SRC

    - The ~std::net::IpAddr~ type, an ~enum~ holding either an IPv4 or an IPv6
      internet address, implements ~FromStr~ too:
      #+BEGIN_SRC rust
        use std::net::IpAddr;

        let address = IpAddr::from_str("fe80::0000:3ea9:f4ff:fe34:7a50")?;
        assert_eq!(address,
                   IpAddr::from([0xfe80, 0, 0, 0, 0x3ea9, 0xf4ff, 0xfe34, 0x7a50]));
      #+END_SRC

    - /String slices/ have a ~parse~ /method/ that parses the /slice/ into whatever
      type you like, *assuming it implements ~FromStr~.* As with ~Iterator::collect~,
      you will sometimes need to spell out which type you want, so ~parse~ is
      _not always much more legible_ than calling ~from_str~ directly:
      ~let address = "fe80::0000:3ea9:f4ff:fe34:7a50".parse::<IpAddr>()?;~

      You can compare this with the ~IpAddr::from_str~ version above.

*** DONE Converting Other Types to Strings - 407
    CLOSED: [2018-07-09 Mon 18:55]
    There are *three* MAIN ways to *convert* _nontextual values_ *to* _strings_:

    - Types that have a natural human-readable printed form can implement the
      ~std::fmt::Display~ /trait/, which lets you use the ~{}~ /format
      specifier/ in the ~format!~ /macro/:
      #+BEGIN_SRC rust
        assert_eq!(format!("{}, wow", "doge"), "doge, wow");
        assert_eq!(format!("{}", true), "true");
        assert_eq!(format!("({:.3}, {:.3})", 0.5, f64::sqrt(3.0)/2.0),
                   "(0.500, 0.866)");
        // Using `address` from above.
        let formatted_addr: String = format!("{}", address);
        assert_eq!(formatted_addr, "fe80::3ea9:f4ff:fe34:7a50");
      #+END_SRC

      ALL Rust's /machine numeric types/ implement ~Display~, as do /characters/,
      /strings/, and /slices/.

      The /smart pointer/ types ~Box<T>~ , ~Rc<T>~ , and ~Arc<T>~ implement ~Display~
      if ~T~ itself does: their displayed form is simply that of their /referent/.
      =From Jian= NOT Addresses!!!!!!

      Containers like ~Vec~ and ~HashMap~ do *NOT* implement ~Display~, as there's
      _NO SINGLE natural human-readable form_ for those types.

    - If a type implements ~Display~, the standard library *automatically implements*
      the ~std::str::ToString~ /trait/ for it, whose sole method ~to_string~ can
      be more convenient when you don't need the flexibility of ~format!~:
      #+BEGIN_SRC rust
        // Continued from above.
        assert_eq!(address.to_string(), "fe80::3ea9:f4ff:fe34:7a50");
      #+END_SRC

      The ~ToString~ /trait/ *predates* the introduction of ~Display~ and is
      _LESS flexible_.

      *For your own types, you should generally implement ~Display~ instead of ~ToString~.*

    - _EVERY /public type/ in the /standard library implements/ ~std::fmt::Debug~,_
      which takes a value and formats it as a string in a way helpful to programmers.
      The easiest way to use ~Debug~ to produce a string is via the ~format!~ /macro/'s
      ~{:?}~ /format specifier/:
      #+BEGIN_SRC rust
        // Continued from above.
        let addresses = vec![address,
                             IpAddr::from_str("192.168.0.1")?];
        assert_eq!(format!("{:?}", addresses),
                   "[V6(fe80::3ea9:f4ff:fe34:7a50), V4(192.168.0.1)]");
      #+END_SRC
      + This takes advantage of a /blanket implementation/ of ~Debug~ for ~Vec<T>~,
        for *ANY* ~T~ that _itself implements_ ~Debug~. All of Rust's collection
        types have such implementations.

      + You should implement ~Debug~ for your own types, too.
        *USUALLY it's BEST to let Rust _derive_ an implementation* with the
        /attribute/ ~#[derive(Copy, Clone, Debug)]~

    The ~Display~ and ~Debug~ /formatting traits/ are just two among several that
    the ~format!~ /macro/ and its relatives use to format values as text.

    We'll cover the others, and explain how to implement them all, in
    “Formatting Values” on page 413.

*** DONE Borrowing as Other Text-Like Types - 408 - =TODO= =re-do=
    CLOSED: [2018-07-09 Mon 18:38]
    You can borrow a slice’s contents in several different ways:
    - /Slices/ and ~String~'s implement ~AsRef<str>~, ~AsRef<[u8]>~, ~AsRef<Path>~,
      and ~AsRef<OsStr>~.
        Many /standard library functions/ use these /traits/ *as bounds* on their
      /parameter types/, so you can pass /slices/ and /strings/ to them
      directly, even when what they really want is some other type.

      =TODO= OR =RE-DO= =!!!=
      See "~AsRef~ and ~AsMut~" on page 294 for a more detailed explanation.

    - /Slices/ and /strings/ also implement the ~std::borrow::Borrow<str>~ trait.

      ~HashMap~ and ~BTreeMap~ use ~Borrow~ to make ~String~'s work nicely as keys
      in a table, as do functions like ~[T]::binary_search~.

      =TODO= OR =RE-DO= =!!!=
      See "~Borrow~ and ~BorrowMut~" on page 296 for details.

*** DONE Accessing Text as UTF-8 - 409
    CLOSED: [2018-07-09 Mon 18:58]
    There are *two* MAIN ways to get at the /bytes representing text/, depending
    on whether you want to take /ownership/ of the bytes or just /borrow/ them:

    - ~slice.as_bytes()~ *borrows* /slice/'s bytes as a ~&[u8]~.

      Since this is *not* a /mutable reference/, /slice/ can *assume its bytes will
      remain well-formed UTF-8*.

    - ~string.into_bytes()~ takes /ownership/ of string and returns a ~Vec<u8>~ of
      the /string/'s bytes by value. This is a *cheap conversion*, as it simply
      hands over the ~Vec<u8>~ that _the string had been using as its buffer_.

        Since ~string~ _no longer exists_, there's *NO need* for the bytes to
      continue to be well-formed UTF-8, and the caller is *free to modify* the
      ~Vec<u8>~ as it pleases.

*** DONE Producing Text from UTF-8 Data - 409
    CLOSED: [2018-07-11 Wed 14:44]
    If you have a _block of bytes_ that you BELIEVE _contains UTF-8 data_,
    you have a few options for converting them into ~String~'s or /slices/,
    *depending on how you want to handle errors*:
    - ~str::from_utf8(byte_slice)~
      TAKES _a ~&[u8]~ /slice/ of bytes_ and
      RETURNS a ~Result~: ~Ok(&str)~ that contains well-formed UTF-8 if no error.

    - ~String::from_utf8(vec)~ tries to construct a ~String~ from a ~Vec<u8>~
      _passed by value_. Its /return type/ is ~Result<String, FromUtf8Error>~.
      #+BEGIN_SRC rust
        let good_utf8: Vec<u8> = vec![0xe9, 0x8c, 0x86];
        assert_eq!(String::from_utf8(good_utf8).ok(), Some("錆".to_string()));
        let bad_utf8: Vec<u8> = vec![0x9f, 0xf0, 0xa6, 0x80];
        let result = String::from_utf8(bad_utf8);
        assert!(result.is_err());
        // Since String::from_utf8 failed, it didn't consume the original
        // vector, and the error value hands it back to us unharmed.

        assert_eq!(result.unwrap_err().into_bytes(),
                   vec![0x9f, 0xf0, 0xa6, 0x80]);
      #+END_SRC

      + If ~vec~ holds well-formed UTF-8,
        this RETURNS ~Ok(string)~,
        where *string has _taken /ownership/ of_ ~vec~ for use as its buffer*.
        *NO* /heap allocation/ or /copying/ of the text takes place.

      + If the bytes are not valid UTF-8,
        this RETURNS ~Err(e)~, where ~e~ is a ~FromUtf8Error~ error value.

        The call ~e.into_bytes()~ gives you back the original vector ~vec~, so
        it is *NOT lost* when the conversion fails:


    - ~String::from_utf8_lossy(byte_slice)~ tries to construct a ~String~ or ~&str~
      from a ~&[u8]~ shared /slice of bytes/.

      *This conversion always succeeds, replacing any ill-formed UTF-8 with
      Unicode replacement characters.*

      The /return value/ is a ~Cow<str>~
      + if it contains well-formed UTF-8,
        the result borrows a ~&str~ directly from ~byte_slice~

      + if it contains ill-formed bytes,
        the result owns a freshly _allocated_ ~String~ with replacement
        characters substituted for the ill-formed bytes.

      Hence, when ~byte_slice~ is well-formed, *NO* /heap allocation/ or /copying/
      takes place.

      =TODO=
      We discuss ~Cow<str>~ in more detail in “Putting Off Allocation” on
      page 410.

    - *unsafe function* ~String::from_utf8_unchecked~
      takes ~Vec<u8>~ that MUST contains well-formed UTF-8.

      This simply wraps the ~Vec<u8>~ up as a ~String~ and returns it,
      *without examining the bytes at all*.

      When you want to you this function, it is your responsibility for making
      sure you haven't introduced ill-formed UTF-8 into the system.

    - Similarly, *unsafe function* ~str::from_utf8_unchecked~
      takes a ~&[u8]~ and returns it as a ~&str~, *without checking to see if it
      holds well-formed UTF-8*.

      As with ~String::from _utf8_unchecked~, you are responsible for making
      sure this is safe.

*** DONE Putting Off Allocation - 410
    CLOSED: [2018-07-11 Wed 16:01]
    Suppose you want your program to greet the user. _On Unix_, you could write:
    #+BEGIN_SRC rust
      fn get_name() -> String {
          std::env::var("USER") // Windows uses "USERNAME"
              .unwrap_or("whoever you are".to_string())
      }

      println!("Greetings, {}!", get_name());
    #+END_SRC
    For Unix users, this greets them by username. For Windows users and the tragically
    unnamed, it provides alternative stock text.

    - The ~std::env::var~ function returns a ~String~ -- and has good reasons to
      do so that we won't go into here. =TODO= =???=

        But that means the alternative stock text must also be returned as a ~String~.
      _This is disappointing_: when ~get_name~ returns a /static string/, NO allocation
      should be necessary at all.

    - The /return value/ of ~name~ should be an owned ~String~, sometimes it should
      be a ~&'static str~, and we CAN'T know which one it will be until we run the
      program.

      *This dynamic character is the hint to consider using ~std::borrow::Cow~,*
      the clone-on-write type that can hold _either_ /owned/ _or_ /borrowed/ data.

    - As explained in “Borrow and ToOwned at Work: The Humble Cow” on page 300,
      ~Cow<'a, T>~ is an /enum/ with *two* variants: ~Owned~ and ~Borrowed~.

      + ~Borrowed~ holds a reference ~&'a T~

      + ~Owned~ holds the _owning version_ of ~&T~:
        ~String~ for ~&str~, ~Vec<i32>~ for ~&[i32]~, and so on.

      Whether ~Owned~ or ~Borrowed~, a ~Cow<'a, T>~ can always produce a ~&T~ for
      you to use. In fact, ~Cow<'a, T>~ _dereferences to_ ~&T~, BEHAVING AS a
      kind of /smart pointer/.

    - Changing ~get_name~ to return a ~Cow~ results in the following:
      #+BEGIN_SRC rust
        use std::borrow::Cow;

        fn get_name() -> Cow<'static, str> {
            std::env::var("USER")
                .map(|v| Cow::Owned(v))
                .unwrap_or(Cow::Borrowed("whoever you are"))
        }
      #+END_SRC
      If this SUCCEEDS in reading the "USER" environment variable, the map
      RETURNS the resulting ~String~ as a ~Cow::Owned~.

      If it FAILS, the ~unwrap_or~ returns its ~static &str~ as a ~Cow::Borrowed~.
      The caller can remain unchanged: ~println!("Greetings, {}!", get_name());~

      *As long as ~T~ implements the ~std::fmt::Display~ /trait/, displaying a
      ~Cow<'a, T>~ produces the SAME results as DISPLAYING a ~T~.*

    - ~Cow~ is also useful when you may or _may not need to MODIFY some text_ you
      have /borrowed/.

      When no changes are necessary, you can continue to /borrow/ it. But ~Cow~'s
      namesake *clone-on-write* behavior can give you an /owned, mutable copy/ of
      the value on demand.

      ~Cow~'s ~to_mut~ /method/ makes sure the ~Cow~ is ~Cow::Owned~, applying
      the value's ~ToOwned~ implementation if necessary, and then returns a
      /mutable reference/ to the value.

      + Example:
        #+BEGIN_SRC rust
          fn get_title() -> Option<&'static str> { ... }

          let mut name = get_name();

          if let Some(title) = get_title() {
              name.to_mut().push_str(", ");
              name.to_mut().push_str(title);
          }

          println!("Greetings, {}!", name);
        #+END_SRC
        If ~get_title~ returns ~None~, the ~Cow~ simply carries the /static string/
        all the way through to the ~println!~.

        *You’ve managed to _put off allocation_ UNLESS it's really necessary,
        while still writing straightforward code.*

    - Since ~Cow~ is frequently used for strings, the standard library has some
      *special support* for ~Cow<'a, str>~. It provides ~From~ and ~Into~
      conversions from both ~String~ and ~&str~, so you can write ~get_name~
      more tersely:
      #+BEGIN_SRC rust
        fn get_name() -> Cow<'static, str> {
            std::env::var("USER")
                .map(|v| v.into())
                .unwrap_or("whoever you are".into())
        }
      #+END_SRC

    - ~Cow<'a, str>~ also implements ~std::ops::Add~ and ~std::ops::AddAssign~,
      so to add the ~title~ to the ~name~, you could write:
      #+BEGIN_SRC rust
        if let Some(title) = get_title() {
            name += ", ";
            name += title;
        }
      #+END_SRC

    - Or, since a ~String~ can be a ~write!~ /macro/'s destination:
      #+BEGIN_SRC rust
        use std::fmt::Write;

        if let Some(title) = get_title() {
            write!(name.to_mut(), ", {}", title).unwrap();
        }
      #+END_SRC
      + As before, _no allocation occurs UNTIL_ you try to _modify_ the ~Cow~.

    - Keep in mind that
      NOT every ~Cow<..., str>~ must be ~'static~: you can use ~Cow~ to /borrow/
      previously computed text _UNTIL_ the moment a /copy/ becomes NECESSARY.

*** DONE Strings as Generic Collections - 412
    CLOSED: [2018-07-09 Mon 18:42]
    - ~String~ implements both ~std::default::Default~ and ~std::iter::Extend~:
      ~default~ returns an *empty string*, and ~extend~ can *append* /characters/,
      /string slices/, or /strings/ to the end of a string.

      This is the *SAME combination of /traits/ implemented by Rust's other
      collection types* like ~Vec~ and ~HashMap~ for /generic construction
      patterns/ such as ~collect~ and ~partition~ .

    - The &~str~ type also implements ~Default~, returning an *empty /slice/.*
        This is handy in some corner cases; for example, it lets you derive
      ~Default~ for structures containing /string slices/.

** DONE Formatting Values - 413
   CLOSED: [2018-07-07 Sat 23:32]
   - The /template string/ must be a _constant_, so that _Rust can check it against
     the types of the arguments at compile time_.

   - Each argument *must be used*; Rust reports a compile-time error otherwise.

   - Several standard library features _SHARE_ this little language for formatting strings:
     + ~format!~ uses it to *build* ~String~'s.
     + ~println!~ and ~print!~ *write* formatted text to the /standard output stream/.
     + ~writeln!~ and ~write!~ *write* it to a /designated output stream/.
     + ~panic!~ uses it to *build* a (hopefully informative) expression of terminal dismay.

   - =EN=
     dismay - 驚

   - Rust's formatting facilities are designed to be open-ended -- you can extend
     these /macros/ to support your own types by *implementing* _the ~std::fmt~
     module's /formatting traits/._
       And you can use ~format_args!~ and the ~std::fmt::Arguments~ type to make your
     own /functions/ and /macros/ support the /formatting language/.

   - /Formatting macros/ *ALWAYS borrow shared references* to their arguments;
     they *NEVER take ownership* of them or mutate them.

   - The template's ~{...}~ forms are called /format parameters/, and have the form
     ~{which:how}~. *Both parts are optional; ~{}~ is frequently used.*

     + The =which= value selects which argument following the template should take
       the parameter's place -- you can select arguments _by index or by name_.

       Parameters with no =which= value are simply paired with arguments from left
       to right.

     + The =how= value says how the argument should be formatted:
       * how much padding,
       * to which precision,
       * in which numeric radix,
       * and so on.

       If =how= is present, the colon before it is _required_.

   - Examples table - page 414

   - In a /template string/, use _DOUBLE_ '{' or '}' to show the literal '{' and
     '}'. For example,
     #+BEGIN_SRC rust
       assert_eq!(
           format!("{{a, c}} ⊂ {{a, b, c}}"),
           "{a, c} ⊂ {a, b, c}"
       );
     #+END_SRC

*** DONE Formatting Text Values - 414
    CLOSED: [2018-06-18 Mon 17:49]
    - When formatting a textual type like ~&str~ or ~String~ (in the formatting
      context, ~char~ is treated like a single-character string), the ~how~ value
      of a parameter _has several parts_, ALL _optional_:
      + A /text length limit/.
        * Rust *truncates* your argument if it is longer than this.

        * If you specify no limit, Rust uses the full text.

      + A /minimum field width/.
        * After any truncation, if your argument is shorter than this, Rust *pads*
          it _on the right (by default) with spaces (by default)_ to make a field
          of this width.

        * If omitted, Rust doesn't pad your argument.

      + An alignment.
        If your argument needs to be padded to meet the minimum field width,
        this says where your text should be placed within the field.
          Put your text at the ~<~ (start), ~^~ (middle) , or ~>~ (end).

      + A padding character to use in this padding process.
        * If omitted, Rust uses spaces.

        * If you specify the /padding character/, you MUST also specify the
          /alignment/.

    - Since without ~{:p}~ like /format parameters/ the pointer referents will be
      printed rather than the address, along with ~&str~ and ~String~, you can also
      pass formatting macros /smart pointer types/ with /textual referents/, like
      ~Rc<String>~ or ~Cow<'a, str>~, without manually dereference the value out.

    - Since in general ~std::path::Path~ is NOT quite a well-formed UTF-8 textual
      type, you _CANNOT_ pass it directly to the /formatting macro/.
        However, you can call its ~.display()~ /method/ and pass the result to the
      /formatting macro/.
        For example, ~println!("processing file: {}", path.display());~

*** DONE Formatting Numbers - 415
    CLOSED: [2018-06-18 Mon 20:10]
    - When the formatting argument has a numeric type like usize or f64 , the
      parameter's how value has the following parts, all optional:
      + A /padding and alignment/,
        which work as they do with textual types.

      + A ~+~ character, requesting that the number's sign always be shown, even
        when the argument is positive.

      + A ~#~ character, requesting an explicit radix prefix like ~0x~ or ~0b~.
        See the "notation" bullet point that concludes this list.

      + A ~0~ character, requesting that the minimum field width be satisfied by
        _including leading zeros_ in the number, instead of the usual padding
        approach.

        * When you request leading zeros, /alignment and padding characters/ are
          simply *ignored*, since the zeros expand the number to fill the entire
          field.

      + A /minimum field width/.
        If the formatted number is not at least this wide, Rust *pads* it _on the
        left (by default) with spaces (by default)_ to make a field of the given
        width.

        * This is applied to the entire number, sign, radix prefix, and all if exist.

      + A /precision/ for floating-point arguments, indicating how many digits
        Rust should include after the decimal point.

        Rust rounds or zero-extends as necessary to produce exactly this many
        fractional digits. If the precision is omitted, Rust tries to accurately
        represent the value using as few digits as possible. For arguments of
        integer type, the precision is ignored.

      + A /notation/.
        For /integer types/, this can be ~b~ for /binary/, ~o~ for /octal/, or
        ~x~ or ~X~ for hexadecimal with lower- or uppercase letters.

        If you included the ~#~ character, these include an explicit /Rust-style
        radix prefix/, ~0b~, ~0o~, ~0x~, or ~0X~. For floating-point types, a radix
        of ~e~ or ~E~ requests scientific notation, with a normalized coefficient,
        using ~e~ or ~E~ for the exponent. If you don't specify any notation, Rust
        formats numbers in decimal.

*** DONE Formatting Other Types - 417
    CLOSED: [2018-06-18 Mon 20:14]
    - Beyond /strings/ and /numbers/, you can format several other /standard library
      types/:
      + /Error types/ can all be formatted directly, making it easy to include them
        in error messages.
          Every error type should implement the ~std::error::Error~ /trait/, which
        extends the /default formatting trait/ ~std::fmt::Display~ . As a consequence,
        any type that implements ~Error~ is ready to format.

      + /Internet protocol address types/ like ~std::net::IpAddr~ and
        ~std::net::SocketAddr~, can be formatted.

      + The Boolean ~true~ and ~false~ values can be formatted,
        Although these are usually not the best strings to present directly to
        end users.

*** DONE Formatting Values for Debugging - 418
    CLOSED: [2018-06-17 Sun 20:42]
    ~{:?}~
    - You can use ~{:?}~ to inspect /vectors/, /slices/, /tuples/, /hash tables/,
      /threads/, and hundreds of other types.
      #+BEGIN_SRC rust
        use std::collections::HashMap;
        let mut map = HashMap::new();
        map.insert("Portland", (45.5237606,-122.6819273));
        map.insert("Taipei",   (25.0375167, 121.5637));
        println!("{:?}", map);

        // {"Taipei": (25.0375167, 121.5637), "Portland": (45.5237606, -122.6819273)}
      #+END_SRC

    - If you include the ~#~ character in the /format parameter/, Rust will
      _pretty-print_ the value.
      #+BEGIN_SRC text
        {
            "Taipei": (
                25.0375167,
                121.5637
            ),
            "Portland": (
                45.5237606,
                -122.6819273
            )
        }
      #+END_SRC
      *These exact forms are _NOT guaranteed_, and do sometimes _CHANGE_ from one Rust
      release to the next.*

    - You can use the ~#[derive(Debug)]~ syntax to make your own types work with ~{:?}~:
      #+BEGIN_SRC rust
        #[derive(Copy, Clone, Debug)]
        struct Complex { r: f64, i: f64 }
        let third = Complex { r: -0.5, i: f64::sqrt(0.75) };
        println!("{:?}", third);
        // Complex { r: -0.5, i: 0.8660254037844386 }
      #+END_SRC

      + This is fine for debugging,
        BUT it might be nice if ~{}~ could print them in a more traditional form,
        like =-0.5 + 0.8660254037844386i=.
        =TODO=
        In "Formatting Your Own Types" on page 421, we'll show how to do exactly
        that.

*** DONE Formatting Pointers for Debugging - 419
    CLOSED: [2018-06-17 Sun 19:03]
    Example:
    #+BEGIN_SRC rust
      use std::rc::Rc;

      let original = Rc::new("mazurka".to_string());
      let cloned = original.clone();
      let impostor = Rc::new("mazurka".to_string());
      println!("text:     {}, {}, {}",       original, cloned, imposter);
      println!("pointers: {:p}, {:p}, {:p}", original, cloned, imposter);
    #+END_SRC

    - If you pass ANY sort of /pointer/ to a /formatting macro/ -- a /reference/,
      a ~Box~, an ~Rc~ -- the /macro/ simply follows the /pointer/ and formats its
      referent; the pointer itself is not of interest.

      However, _when you're debugging_, you usually want an address served as a
      rough "name" for an individual value, which can _be illuminating when examining
      structures with cycles or sharing_.

    - You may want to find more refined visualizations rather than a hexadecimal
      soup, BUT ~{:p}~ still the simplest and the most foundamental way, though
      it is a quick-and-dirty solution.

*** DONE Referring to Arguments by Index or Name - 419
    CLOSED: [2018-06-17 Sun 20:44]
    - You can *mix* /indexed/, /named/, and /positional/ (that is, no index or name)
      parameters together in a single /formatting macro/ use.

*** DONE Dynamic Widths and Precisions - 420
    CLOSED: [2018-06-17 Sun 21:28]
    - A parameter's
      + minimum field width,
      + text length limit,
      + numeric precision

      _need NOT_ always be fixed values; you can choose them AT /runtime/.

    - Explain by examples:
      + ~format!("{:>1$}", content, get_width())~
        Use the 1st arguments (count from 0th), here is the ~get_width()~, as the
        width.

      + ~format!("{:>width$}", content, width=get_width())~
        Same as above, but refer to the argument _by name_.

      + The same approach works for the _text length limit_ as well:
        ~format!("{:>width$.limit$}", content, width=get_width(), limit=get_limit())~

      + =???=
        In place of the _text length limit_ or _floating-point precision_, you can
        also write ~*~, which says to take the _NEXT positional argument_ as the
        precision. The following clips ~content~ to at most ~get_limit()~ characters:
        ~format!("{:.*}", get_limit(), content)~

    - The argument taken as the precision *must be* a ~usize~.
      There is _NO_ corresponding syntax for the _field width_.

*** DONE Formatting Your Own Types - 421
    CLOSED: [2018-07-07 Sat 23:32]
    The /formatting macros/ use a set of /traits/ defined in the ~std::fmt~ /module/
    _to *convert* values *to* text_.
      You can make Rust's /formatting macros/ format your own types by *implementing*
    one or more of these /traits/ yourself.

    - format parameter notations and their corresponding /traits/:

      | Notations | Example     | Trait                | purpose                                       |
      |-----------+-------------+----------------------+-----------------------------------------------|
      | none      | ~{}~        | ~std::fmt::Display~  | Text, numbers, errors: the catch-all trait    |
      | ~b~       | ~{bits:#b}~ | ~std::fmt::Binary~   | Numbers in binary                             |
      | ~o~       | ~{:#5o}~    | ~std::fmt::Octal~    | Numbers in octal                              |
      | ~x~       | ~{:4x}~     | ~std::fmt::LowerHex~ | Numbers in hexadecimal, lower-case digits     |
      | ~X~       | ~{:016X}~   | ~std::fmt::UpperHex~ | Numbers in hexadecimal, upper-case digits     |
      | ~e~       | ~{:.3e}~    | ~std::fmt::LowerExp~ | Floating-point numbers in scientific notation |
      | ~E~       | ~{:.3E}~    | ~std::fmt::UpperExp~ | Same, upper-case E                            |
      | ~?~       | ~{:#?}~     | ~std::fmt::Debug~    | Debugging view, for developers                |
      | ~p~       | ~{:p}~      | ~std::fmt::Pointer~  | Pointer as address, for developers            |

    - You can ask Rust to implement ~std::fmt::Debug~ for you by using the /attribute/
      ~#[derive(Debug)]~.

    - The /formatting traits/ _ALL_ have the *SAME STRUCTURE*,

            *differing* _ONLY_ in their names.

      Use ~std::fmt::Display~ as a representative:
      #+BEGIN_SRC rust
        trait Display {
            fn fmt(&self, dest: &mut std::fmt::Formatter) -> std::fmt::Result;
        }
      #+END_SRC

      + The ~fmt~ /method/'s job is to produce a _properly formatted representation_
        of ~self~ and write its characters to ~dest~.
          In addition to serving as an /output stream/, the ~dest~ argument also
        carries details parsed from the /format parameter/, like the _alignment_
        and _minimum field width_.

        * Here is a example with ~Complex~ -- print it as the ~a \pm{} bi~ form:
          #+BEGIN_SRC rust
            use std::fmt;

            impl fmt::Display for Complex {
                fn fmt(&self, dest: &mut fmt::Formatter) -> fmt::Result {
                    let i_sign = if self.i < 0.0 { '-' } else { '+' };
                    write!(dest, "{} {} {}i", self.r, i_sign, f64::abs(self.i))
                }
            }

            // Examples:
            let one_twenty = Complex { r: -0.5, i: 0.866 };
            assert_eq!(format!("{}", one_twenty),
                       "-0.5 + 0.866i");

            let two_forty = Complex { r: -0.5, i: -0.866 };
            assert_eq!(format!("{}", two_forty),
                       "-0.5 - 0.866i");
          #+END_SRC
          This takes advantage of the fact that ~Formatter~ itself an /output stream/,
          so the ~write!~ /macro/ can do most of the work for us.

      + The ~#~ character in a format parameter typically selects some *alternative
        display form*. Here we use /polar coordinate representation/:
        #+BEGIN_SRC rust
          impl fmt::Display for Complex {
              fn fmt(&self, dest: &mut fmt::Formatter) -> fmt::Result {
                  let (r, i) = (self.r, self.i);
                  if dest.alternate() {
                      let abs = f64::sqrt(r * r + i * i);
                      let angle = f64::atan2(i, r) / std::f64::consts::PI * 180.0;
                      write!(dest, "{} ∠ {}°", abs, angle)
                  } else {
                      let i_sign = if i < 0.0 { '-' } else { '+' };
                      write!(dest, "{} {} {}i", r, i_sign, f64::abs(i))
                  }
              }
          }

          // 
          let ninety = Complex { r: 0.0, i: 2.0};
          assert_eq!(format!("{}", ninety),
                     "0 + 2i");
          assert_eq!(format!("{:#}", ninety),
                     "2 ∠ 90°");
        #+END_SRC

    - Although the /formatting traits'/ ~fmt~ /methods/ return a ~fmt::Result~
      value (a typical _module-specific_ ~Result~ type), you should *propagate*
      _failures_ *ONLY* from operations on the ~Formatter~, as the ~fmt::Display~
      implementation does with its calls to ~write!~;

      *your formatting functions _MUST NEVER originate_ errors themselves*.
      + This allows /macros/ like ~format!~ to simply return a ~String~ instead of
        a ~Result<String, ...>~, since appending the formatted text to a String
        never fails.

      + It also ensures that ANY /errors/ you do get from ~write!~ or ~writeln!~
        reflect REAL PROBLEMS from the underlying I/O stream, not formatting issues.

    - ~Formatter~ has plenty of other helpful /methods/, including some for handling
      structured data like /maps/, /lists/, and so on, which we *won't* cover here;
      consult the online documentation for the full details.
      =TODO= =TODO= =TODO=

*** DONE Using the Formatting Language in Your Own Code - 423
    CLOSED: [2018-07-07 Sat 23:23]
    You can write your own /functions/ and /macros/ that accept /format templates/
    and /arguments/ by using Rust's ~format_args!~ /macro/ and the ~std::fmt::Arguments~
    type.

    - For example, suppose your program needs to log status messages as it runs,
      and you'd like to use Rust's text formatting language to produce them.
      The following would be a start:
      #+BEGIN_SRC rust
        fn logging_enabled() -> bool {
            // ...
        }

        use std::fs::OpenOptions;
        use std::io::Write;

        fn write_log_entry(entry: std::fmt::Arguments) {
            if logging_enabled() {
                // Keep things simple for now, and just
                // open the file every time.
                let mut log_file = OpenOptions::new()
                    .append(true)
                    .create(true)
                    .open("log-file-name")
                    .expect("failed to open log file");
                log_file.write_fmt(entry)
                    .expect("failed to write to log");
            }
        }
      #+END_SRC
      + You can use it like:
        #+BEGIN_SRC rust
          write_log_entry(format_args!("Hark! {:?}\n", mysterious_value));
        #+END_SRC

      + Constructing an ~Arguments~ value is cheap (=From Jian= Details in the book
        page 424). This is important, since in this ~write_log_entry~ function, even
        if the value of ~logging_enabled()~ is ~false~, the ~entry~ will be created.

        It is obvious that if we can lazily evaluate ~entry~, we can get a BETTER
        solution.

      + The ~File~ type implements the ~std::io::Write~ /trait/, whose ~write_fmt~
        /method/ takes an ~Argument~ and does the formatting. It writes the results
        to the underlying stream.

      + The call to ~write_log_entry~ (see above) is *NOT* pretty -- you don't want
        to create an ~Arguments~ value every time you call the ~write_log_entry~
        function.

        This is where a /macro/ can help: =TODO= Chapter 20
        #+BEGIN_SRC rust
          macro_rules! log {  // no! needed after name in macro definitions
              ($format:tt, $($arg:expr),*) => (
                  write_log_entry(format_args!($format, $($arg),*))
              )
          }
        #+END_SRC

        Then you can use it like:
        #+BEGIN_SRC rust
          log!("O day and night, but this is wondrous strange! {:?}\n",
               mysterious_value);
        #+END_SRC

        * =From Jian= =TODO= =TODO= =TODO=
          I think if we embed the code of the body of the ~write_log_entry~ to the
          /macro/ directly, we can get ~entry~ _lazily evaluated_.

** DONE Regular Expressions - 424
   CLOSED: [2018-06-18 Mon 19:20]
   - The _external_ ~regex~ crate is _Rust's official regular expression library_.
     + Usage:
       1. Add a line to the =[dependencies]= section of your crate's =Cargo.toml=
          file:
          ~regex = "0.2.2"~ for example.
       2. Pace an ~extern crate regex;~ statement in your crate's root.

   - ~regex~ provides the usual searching and matching functions.
     + It has good support for /Unicode/;

     + It support search /byte strings/ as well;

     + It doesn't support some features you'll often find in other regular
       expression packages, like /backreferences/ and /look-around patterns/,
       * Rationale:
         Those simplifications allow ~regex~ to
         + *ensure that searches take time linear in the size of the expression
           and in the length of the text being searched*.
             These guarantees, among others, make regex safe to use even with
           untrusted expressions searching untrusted text.

*** DONE Basic Regex Use - 425
    CLOSED: [2018-06-18 Mon 18:20]
    - Example:
      #+BEGIN_SRC rust
        use regex::Regex;

        // A semver version number, like 0.2.1.
        // May contain a pre-release version suffix, like 0.2.1-alpha.
        // (No build metadata suffix, for brevity.)
        let semver = Regex::new(r"(\d+)\.(\d+)\.(\d+)(-[-.[:alnum:]]*)?")?;

        // Simple search, with a Boolean result.
        let haystack = r#"regex = "0.2.5""#;
        assert!(semver.is_match(haystack));
      #+END_SRC

    - The ~Regex::captures~ /method/ searches a string _for the first match_, and
      returns a ~regex::Captures~ value holding match information for each group
      in the expression:
      #+BEGIN_SRC rust
        // You can retrieve capture groups:
        let captures = semver.captures(haystack)
            .ok_or("semver regex should have matched")?;
        assert_eq!(&captures[0], "0.2.5");
        assert_eq!(&captures[1], "0");
        assert_eq!(&captures[2], "2");
        assert_eq!(&captures[3], "5");
      #+END_SRC
      + Out of bound indexing will cause to a /panic/.

      + Use the ~.get(index)~ /method/ of a ~Captures~, you can get a
        ~Option<regex::Match>~. For example,
        #+BEGIN_SRC rust
          assert_eq!(captures.get(4), None);
          assert_eq!(captures.get(3).unwrap().start(), 13);
          assert_eq!(captures.get(3).unwrap().end(), 14);
          assert_eq!(captures.get(3).unwrap().as_str(), "5");
        #+END_SRC

    - Iterate over all the matches in a string:
      #+BEGIN_SRC rust
        let haystack = "In the beginning, there was 1.0.0. \
                        For a while, we used 1.0.1-beta, \
                        but in the end, we settled on 1.2.4.";

        let matches: Vec<&str> = semver.find_iter(haystack)
            .map(|mtch| mtch.as_str())
            .collect();
        assert_eq!(matches, vec!["1.0.0", "1.0.1-beta", "1.2.4"]);
      #+END_SRC
      + The ~find_iter~ /iterator/ produces a ~Match~ value for EACH _nonoverlapping_
        match of the expression, working from the start of the string to the end.

        The ~captures_iter~ method is similar, but produces ~Captures~ values
        recording all capture groups.

      + Searching is *SLOWER* _when /capture groups/ MUST be reported_,
        so if you don't need them, it's best to use one of the methods that
        doesn't return them.

*** DONE Building Regex Values Lazily - 426
    CLOSED: [2018-06-18 Mon 19:20]
    - The ~Regex::new~ construction operation *can be expensive*:
      + Extreme cases (usually machine generated regex):
        constructing a ~Regex~ for a _1200-character_ regular expression can take
        almost a *millisecond* on a fast developer machine,

      + Trivial expression takes *microseconds*.

    - It's best to keep Regex construction out of heavy computational loops;
      instead, you should *construct your Regex once, and then reuse the same
      one*.

    - The ~lazy_static~ /crate/ provides a nice way to
      construct /static values/ LAZILY the first time they are used.
      1. Configuration:
         Add a line like ~lazy_static = "0.2.8"~ to the ~[dependencies]~ section
         of the =Cargo.toml= file.

      2. Usage:
         #+BEGIN_SRC rust
           #[macro_use]
           extern crate lazy_static;

           lazy_static! {
               static ref SEMVER: Regex
                   = Regex::new(r"(\d+)\.(\d+)\.(\d+)(-[-.[:alnum:]]*)?")
                         .expect("error parsing regex");
           }
         #+END_SRC
         + =TODO= =???= What is ~static ref~???

    - The macro expands to a declaration of a /static variable/ named ~SEMVER~,
      _BUT_ its type is a /macro-generated type/ that implements ~Deref<Target=Regex>~
      and therefore _exposes ALL the SAME methods as a ~Regex~, rather than ~Regex~._

      + The first time ~SEMVER~ is *dereferenced*, the initializer is evaluated,
        and the value saved for later use.

      + Since ~SEMVER~ is a /static variable/, NOT just a /local variable/, the
        initializer runs _at most once_ per program execution.

    - You can
      + put the ~lazy_static!~ declaration in a /module/,
        or
      + even put it inside the /function/ that uses the ~Regex~, if that's the
        most appropriate scope. The regular expression is still always compiled
        ONLY ONCE per program execution.

** DONE Normalization - 427
   CLOSED: [2018-07-06 Fri 14:50]
   - _Failure to normalize_ can even have *security consequences*.

     For example,
     if your website normalizes usernames in some cases but not others, you
     could end up with two distinct users named bananasflambé, which some parts
     of your code treat as the same user, but others distinguish, resulting in
     one’s privileges being extended incorrectly to the other.
     =TODO=
       Of course, there are many ways to avoid this sort of problem, but history
     shows there are also many ways not to.

*** TODO Normalization Forms - 428
    - Unicode defines *four* /normalized forms/, each of which is appropriate for
      different uses.

      There are two questions to answer:
      1. Q & A - 1
         + Q :: do you prefer characters to be _as COMPOSED as possible_ or
                _as DECOMPOSED as possible_?

         + A :: =Re-Do= Read book

      2. Q & A - 2
         + Q :: if two character sequences represent the same fundamental text,
                but differ in the way that text should be formatted, do you want
                to _treat them as EQUIVALENT_, or _keep them DISTINCT_?

         + A ::  =Re-Do= Read book

    - The Unicode /Normalization Form C (NFC)/ and /Normalization Form D (NFD)/ use
      the /maximally composed/ and /maximally decomposed/ forms of each character,
      but *DO NOT* try to unify compatibility equivalent sequences.

      =TODO=
      The /NFKC/ and /NFKD/ /normalization forms/ are _LIKE_ /NFC/ and /NFD/, but
      normalize all compatibility equivalent sequences to some simple representative
      of their class.

    - *The World Wide Web Consortium's “Character Model For the World Wide Web” rec-
      ommends using /NFC/ for all content.*

    - *The /Unicode Identifier and Pattern Syntax/ annex suggests using /NFKC/ for
      identifiers in programming languages*, and offers principles for adapting
      the form when necessary.

*** DONE The unicode-normalization Crate - 429
    CLOSED: [2018-07-06 Fri 14:26]
    - Add ~unicode-normalization = "0.1.7"~ o the ~[dependencies]~ section of your
      =Cargo.toml= file, and add ~extern crate unicode_normalizatoin;~ to your source
      code file.

      With these declarations in palce, a ~&str~ has *FOUR* NEW /methods/ that
      return /iterators/ over a particular /normalized form/ of the string:
      #+BEGIN_SRC rust
        use unicode_normalization::UnicodeNormalization;

        // No matter what representation the lefthand string uses
        // (you shouldn't be able to tell just by looking),
        // these assertions will hold.
        assert_eq!("Phở".nfd().collect::<String>(), "Pho\u{31b}\u{309}");
        assert_eq!("Phở".nfc().collect::<String>(), "Ph\u{1edf}");

        // The lefthand side here uses the "ffi" ligature character.
        assert_eq!("① Di\u{fb03}culty".nfkc().collect::<String>(), "1 Difficulty");
      #+END_SRC

      + Taking a /normalized string/ and *normalizing* it again in the same form
        is _guaranteed_ to return *IDENTICAL* text.

    - *ANY* /substring/ of a /normalized string/ is ITSELF /normalized/.

    - The concatenation of two /normalized strings/ is *NOT necessarily* /normalized/.

      For example, the second string might start with combining characters that should
      be placed before combining characters at the end of the first string.

    - Since 
      + /Normalized forms/ does *NOT uses* _no unassigne_ /code points/.

      + /Unicode/ *promises* that its /normalized form/ will *NOT change* in future
        versions of the standard.

      , /normalized forms/ are GENERALLY SAFE to use in /persistent storage/, EVEN
      as the Unicode standard _evolves_.

* DONE 18. Input and Output - 431
  CLOSED: [2018-06-19 Tue 22:29]
  - Rust's /standard library/ features for /input/ and /output/ are organized
    around *three* /traits/:
    + ~Read~
    + ~BufRead~
    + ~Write~

    and the various types that implement them:

    + Values that implement ~Read~ have /methods/ for *byte-oriented input*.
      They're called /readers/.

    + Values that implement ~BufRead~ have
      * all the /methods/ of ~Read~
      * (plus) /methods/ for _reading lines of text_ and so forth.

      They're called /buffered readers/.

    + Values that implement ~Write~ support _BOTH_
      * *byte-oriented output*
      * *UTF-8 text output*.

      They're called /writers/.

  - Figure 18-1. Selected /reader (bufferd or non-buffered)/ and /writer/ types
    from the Rust standard library.

** DONE Readers and Writers - 432
   CLOSED: [2018-06-19 Tue 22:29]
   - /Readers/ are values that your program can _read bytes from_.
     Examples include:
     + _Files opened_ using ~std::fs::File::open(filename)~;

     + ~std::net::TcpStream~'s, for *receiving* data over the _network_;


     + ~std::io::stdin()~, for *reading* from the /process's standard input stream/;

     + ~std::io::Cursor<&[u8]>~ values, which are /readers/ that "read" from a
       /byte array/ that's _ALREADY in memory_.

   - /Writers/ are values that your program can _write bytes to_.
     Examples include:
     + _Files opened_ using ~std::fs::File::create(filename)~;

     + ~std::net::TcpStream~'s, for *sending* data over the _network_;

     + ~std::io::stdout()~ and ~std::io:stderr()~, for *writing* to the terminal;

     + ~std::io::Cursor<&mut [u8]>~ values, which let you treat any /mutable slice
       of bytes/ *as a file* for *writing*;

     + ~Vec<u8>~, a /writer/ whose ~write~ /methods/ *append* to the vector =TODO= =???=

   - For example, here's a function that *copies all bytes* _from_ ANY /reader/
     _to_ ANY /writer/:
     #+BEGIN_SRC rust
       use std::io::{self, Read, Write, ErrorKind};

       const DEFAULT_BUF_SIZE: usize = 8 * 1024;

       pub fn copy<R: ?Size, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>
           where R: Read, W: Write
       {
           let mut buf = [0; DEFAULT_BUF_SIZE];
           let mut written = 0;
           loop {
               let len = match reader.read(&mut buf) {
                   Ok(0)                                            => return Ok(written),
                   Ok(len)                                          => len,
                   Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,
                   Err(e)                                           => return Err(e),
               };
               writer.write_all(&buf[..len])?;
               written += len as u64;
           }
       }
     #+END_SRC
     + This is the implementation of ~std::io::copy()~ from /Rust's standard
       library/.

       Since it's /generic/, you can use it to copy data from a ~File~ to a
       ~TcpStream~, from ~Stdin~ to an in-memory ~Vec<u8>~, etc.

   - The *four* ~std::io~ /traits/ ~Read~, ~BufRead~, ~Write~, and ~Seek~ are so
     commonly used that there's a /prelude module/ containing _ONLY_ those /traits/:
     ~use std::io::prelude::*;~

   - The ~self~ in the statement ~use std::io::{self, Read, Write, ErrorKind};~ is
     an alias to the ~std::io~. This means you can, for example, write ~io::Result~,
     rather than ~std::io::Result~.

*** DONE Readers - 433
    CLOSED: [2018-06-19 Tue 22:29]
    ~std::io::Read~ has several /methods/ for _reading data_.
    All of them take the /reader/ itself _by ~mut~ /reference/._

    - The main /methods/ of the ~Read~ /trait/.
      + ~reader.read(&mut buffer)~
        * Read some bytes from the data source
          and
          store them in the given ~buffer~.

        * The type of the ~buffer~ argument is ~&mut [u8]~.

        * This reads up to ~buffer.len()~ bytes.

        * The /return type/ is ~io::Result<u64>~ (an alias for ~Result<u64, io::Error>~).
          - One success, the ~u64~ value is the number of bytes read.
            ~Ok(0)~ means there is no more input to read.

        * One error, this /method/ returns ~Err(err)~, here the ~err~ is an
          ~io::Error~ value.
          - An ~io::Error~ is printable, for the benefit of humans;

          - ~io::Error~ has a ~kind()~ method that returns an error code of type
            ~io::ErrorKind~, of course, as you can guess, it is a /enum/.

          - ~io::ErrorKind~ has members like ~PermissionDenied~ and ~ConnectionReset~.

            Most of them indicate serious errors that you can't ignore,
            _BUT_ one /kind/ of error, ~io::ErrorKind::Interrupted~, should be
            handled specially -- it corresponds to the Unix error code ~EINTER~,
            which means the read happened to be interrupted by a /signal/.

            _UNLESS_ the program is designed to do something clever with /signals/,
            it SHOULD JUST RETRY the ~read~.
              The code for ~copy()~, in the preceding section, shows an example
            of this.

        * As you can see, the ~read~ /method/ is very low-level, even inheriting
          quirks of the underlying operating system
          - if you're implementing the ~Read~ /trait/ for a new type of data source,
            this gives you a lot of leeway.

          - to relif the pain of using this ~read~ /method/,
            Rust provides several *higher-level CONVENIENCE* methods. All of them
            have default implementations in terms of ~.read()~. They all handle
            ~ErrorKind::Interrupted~, so you don't have to.

      + ~reader.read_to_end(&mut byte_vec)~
        Read all _remaining input_ from this ~reader~, appending it to ~byte_vec~,
        which is a ~Vec<u8>~.

        * Return ~io::Result<()>~.

        * *CAUTION*
          There is _no limit_ on the amount of data this method will pile into
          the /vector/, so *don't use it on an UNTRUSTED SOURCE.* (You can impose
          a limit using the ~.take()~ method, described below.)

      + ~reader.read_to_string(&mut string)~
        It is similar to ~reader.read_to_end(&mut byte_vec)~,
        BUT append the data to the given ~String~.

        If the stream isn't valid UTF-8, this returns an ~ErrorKind::InvalidData~ error.

        =RE-READ= =???=
        In some languages, byte input and character input are handled by
        different types. These days, UTF-8 is so dominant that Rust acknowledges
        this de facto standard and supports UTF-8 everywhere. Other character
        sets are supported with the open source encoding crate.

      + ~reader.read_exact(&mut buf)~
        Read exactly enough data to fill the given buffer ~buf~.

        * The /argument type/ is ~&[u8]~.

        * IF the /reader/ runs out of data before reading ~buf.len()~ bytes,
          this returns an ~ErrorKind::UnexpectedEof~ error.


    - Four adapter /methods/ that take the /reader/ by value, transforming it into
      an /iterator/ or a DIFFERENT /reader/:
      + ~reader.bytes()~
        Return an /iterator/ over the bytes of the input stream.

        The item type is ~io::Result<u8>~, so _an error check is required for
        every byte_.

        Furthermore, this calls ~reader.read()~ once per byte, which will be
        very *INEFFICIENT* IF the /reader/ is *NOT buffered*.

      + ~reader.chars()~
        Similar to ~reader.bytes()~ but the item contains ~char~.
        Treat the input as UTF-8. Invalid UTF-8 causes an ~InvalidData~ error.

      + ~reader.chain(reader2)~
        Return a new /reader/ that produces all the input from /reader/,
        followed by all the input from ~reader2~.

      + ~reader.take(n)~
        Return a new /reader/ that reads from the same source as ~reader~,
        BUT is limited to ~n~ /bytes/ of input.

    - There is *NO* /method/ for _closing_ a /reader/.

      /Readers/ and /writers/ typically implement ~Drop~ so that they are
      _closed AUTOMATICALLY_.

*** DONE Buffered Readers - 435
    CLOSED: [2018-06-16 Sat 22:42]
    - For efficiency, /readers/ and /writers/ can be *buffered*,
      which simply means they have a chunk of memory (a /buffer/) that holds some
      input or output data in memory.

    - Figure 18-2   =Re-Read=

    - ~BufReader~ get a large chunk of input from the OS to its /buffer/.
      When the user use a ~BufReader~ implementation to read, it reads from the
      /buffer/.

    - The actual default size of a ~BufReader~'s /buffer/ is _several kilobytes_.

    - /Buffered readers/ implement both ~Read~ and a SECOND /trait/, ~BufRead~,
      which adds the following /methods/:
      + ~buf_reader.read_line(&mut line)~
        * Read a line of text and appends it to line, which is a ~String~.
          The /newline character/ at the end of the line is included in line.

        * The /return value/ is an ~io::Result<usize>~, _the number of bytes read,
          including the line ending, if any._

        * If the /buffered reader/ is at the end of the input, this
          1. leaves line unchanged;
          2. returns ~Ok(0)~.

      + ~buf_reader.lines()~
        Return an /iterator/ over the lines of the input.

        The /item type/ is ~io::Result<String>~.
        /Newline characters/ are _NOT included_ in the strings.

        *This /method/ is _ALMOST ALWAYS what you want for text input_.*
        =TODO= The next two sections show some examples of its use.
        
      + ~buf_reader.read_until(stop_byte, &mut byte_vec)~ and
        ~reader.split(stop_byte)~

        They are just like ~.read_line()~ and ~.lines()~, but byte-oriented, producing
        ~Vec<u8>~'s instead of ~String~'s. You choose the delimiter ~stop_byte~ .

    - ~BufRead~ also provides a pair of LOW-LEVEL /methods/, ~.fill_buf()~ and
      ~.consume(n)~, for _direct access_ to the /reader's internal buffer/.
      For more about these methods, see the online documentation. =TODO= =TODO=

    - =TODO= The next two sections cover buffered readers in more detail.

*** DONE Reading Lines - 436
    CLOSED: [2018-06-18 Mon 22:00]
    Implement a basic version of the Unix ~greap~ utility.
    - The first version, accept input from the /stdin/:
      #+BEGIN_SRC rust
        use std::io;
        use std::io::prelude::*;
  
        fn grep(target: &str) -> io::Result<()> {
            let stdin = io::stdin();
  
            for line_result in stdin.lock().lines() {
                let line = line_result?;
                if line.contains(target) {
                    println!("{}", line);
                }
            }
            Ok(())
        }
      #+END_SRC

    - The second version, also accept input from files on disk:
      #+BEGIN_SRC rust
        fn grep<R>(target: &str, reader: R) -> io::Result<()>
            where R: BufRead
        {
            for line_result in reader.lines() {
                let line = line_result?;
                if line.contains(target) {
                    println!("{}", line);
                }
            }
            Ok(())
        }

        // Now we can pass it either a `StdinLock` or a buffered `File`:
        let stdin = io::stdin();
        grep(&target, stdin.lock())?;  // ok

        let f = File::open(file)?;
        grep(&target, BufReader::new(f))?;  // also ok
      #+END_SRC
      + Caution:
        ~File~ is NOT automatically buffered (it only implements ~Read~), but it
        is easy to create a /buffered reader/ for a /reader/,the ~File~ (in our
        code, ~BufReader::new(reader)~ does this), or any other /unbuffered
        reader/.

        * To set the size of the /buffer/, use
          ~BufReader::with_capacity(size, reader)~.

      + In most languages, *files are buffered by default*, and you need to find
        a way to unbuffer them if you want.

        In Rust, ~File~ and ~BufReader~ are two separate library features,
        _BECAUSE_ sometimes you want files without buffering, and sometimes you
        want buffering without files (for example, you may want to buffer input
        from the network).

    - The FULL program, including error handling and some crude argument parsing:
      #+BEGIN_SRC rust
        // grep - Search stdin or some files for lines matching a given string.
        use std::error::Error;
        use std::io::{self, BufReader};
        use std::io::prelude::*;
        use std::fs::File;
        use std::path::PathBuf;

        fn grep<R>(target: &str, reader: R) -> io::Result<()>
            where R: BufRead
        {
            for line_result in reader.lines() {
                let line = line_result?;
                if line.contains(target) {
                    println!("{}", line);
                }
            }
            Ok(())
        }

        fn grep_main() -> Result<(), Box<Error>> {
            // Get the command-line arguments. The first argument is the
            // string to search for; the rest are filenames.
            let mut args = std::env::args().skip(1);
            let target = match args.next() {
                Some(s) => s,
                None => Err("usage: grep PATTERN FILE...")?
            };

            let files: Vec<PathBuf> = args.map(PathBuf::from).collect();

            if files.is_empty() {
                let stdin = io::stdin();
                grep(&target, stdin.lock())?;
            } else {
                for file in files {
                    let f = File::open(file)?;
                    grep(&target, BufReader::new(f))?;
                }
            }
            Ok(())
        }

        fn main() {
            let result = grep_main();
            if let Err(err) = result {
                let _ = writeln!(io::stderr(), "{}", err);
            }
        }
      #+END_SRC

*** DONE Collecting Lines - 439
    CLOSED: [2018-06-17 Sun 14:58]
    For several _reader methods_ that returns /iterators/, including ~.lines()~,
    produce ~Result~ /item values/.
      You may want to collect all the lines in to a vector. If you call the ~.collect()~
    /method/ directly, the result is NOT what you usually want -- we usually want
    a vector of string, and this vector can be wrapped by something; but what we
    get is of type ~Vec<io::Result<String>>~. Mostly, we want types like ~Vec<String>~
    or ~<io::Result<Vec<String>>>~.

    - Solution: =IMPORTANT=
      ~let lines = reader.lines().collect::<io::Result<Vec<String>>>()?;~
      The ~lines~ has type ~Vec<String>~.
      If you drop the ~?~, the type is ~<io::Result<Vec<String>>>~.

      + Q :: How does this work?

      + A :: The standard library contains an implementation of ~FromIterator~ for
             ~Result~ -- easy to overlook in the online documentation -- that makes
             this possbile:
             #+BEGIN_SRC rust
               impl<T, E C> FromIterator<Result<T, E>> for Result<C, E>
                   where C: FromIterator<T>
               {
                   // ...
               }
             #+END_SRC

        - This says:
          if you can collect items of type ~T~ into a collection of type ~C~
          (~where C: FromIterator<T>~)
          then you can collect items of type ~Result<T, E>~ into a result of type
          ~Result<C, E>~ (~FromIterator<Result<T, E>> for Result<C, E>~).

          In other words, io::Result<Vec<String>> is a collection type, so the
          ~.collect()~ /method/ can create and populate values of that type. 

*** DONE Writers - 439
    CLOSED: [2018-06-19 Tue 02:32]
    - As we've seen,
      + input is mostly done using /methods/.
      + *Output is a bit _different_.*

    - We've used ~println!()~ and ~print!()~

    - To send /output/ to a /writer/, use the ~write!()~ and ~writeln!()~ /macros/.
      Example:
      #+BEGIN_SRC rust
        writeln!(io::stderr(), "error: world not helloable")?;
        writeln!(&mut byte_vec, "The greatest common divisor of {:?} is {}", numbers, d)?;
      #+END_SRC

    - They are similar to the ~print!()~ and ~println!()~, except for two differences:
      + they take an extra first argument, a /writer/.

      + they return a ~Result~, so errors must be handled.
        (~print!()~ and ~println!()~ does NOT return ~Result~, they just panic
        if the write fails -- since they write to the terminal, this is rare.)

    - The ~Write~ /trait/ has these /methods/:
      + ~writer.write(&buf)~ *writes* some of the /bytes/ in the /slice/ ~buf~ to
        the underlying stream.
        It returns an ~io::Result<usize>~.
        On success, this gives the _number of bytes written_, which may be _less
        than_ ~buf.len()~ , at the whim of the stream.

        * *CAUTION*:
          Like ~Reader::read()~, this is a low-level /method/ that you should
          avoid using directly.

      + ~writer.write_all(&buf)~ *writes all* the /bytes/ in the /slice/ ~buf~.
        _Returns_ ~Result<()>~.

      + ~writer.flush()~ *flushes* any buffered data to the underlying stream.
        _Returns_ ~Result<()>~.

    - Just as ~BufReader::new(reader)~ adds a /buffer/ to any /reader/,
      ~BufWriter::new(writer)~ adds a /buffer/ to any /writer/.
      #+BEGIN_SRC rust
        let file = File::create("tmp.txt")?;
        let writer = BufWriter::new(file);
      #+END_SRC
      + To *set* the _size_ of the /buffer/, use ~BufWriter::with_capacity(size, writer)~.

    - To make sure your application notices all output errors,
      manually ~.flush()~ /buffered writers/ before dropping them.

      =From Jian= =IMPORTANT= =!!!=
      Can this ~.flush()~ be inserted to the source code by the compiler
      automatically??? Can we just create an /attribute/ to control this
      feature?

      + Rationale:
        When a ~BufWriter~ is /dropped/, all _REMAINING_ /buffered data/ is written
        to the underlying /writer/.
          However, if an error occurs during this write, the error is *ignored*.
        (Since this happens inside ~BufWriter~'s ~.drop()~ /method/, there is _NO_
        useful place to report the error.)

*** DONE Files - 441
    CLOSED: [2018-06-19 Tue 01:25]
    - We've already seen two ways to *open* a file:
      + ~File::open(filename)~ *opens* an existing file for reading.
        It returns an ~io::Result<File>~, and it's an error if the file doesn't exist.

      + ~File::create(filename)~ *creates* a new file for writing.
        If a file exists with the given filename, it is truncated.

    - The ~File~ type is in the filesystem module, ~std::fs~, not ~std::io~.

    - When the ~open~ and ~create~ method doesn't fit the bill,
      you can use ~OpenOptions~ to specify the exact desired behavior:
      #+BEGIN_SRC rust
        use std::fs::OpenOptions;

        let log = OpenOptions::new()
            .append(true)  // if file exists, add to the end
            .open("server.log")?;

        let file = OpenOptions::new()
            .write(true)
            .create_new(true)  // fail if file exists
            .open("new_file.txt")?;
      #+END_SRC

    - The /methods/ ~.append()~, ~.write()~, ~.create_new()~, and so on are _designed
      to be chained like this_: each one returns ~self~.

        This method-chaining design pattern is common enough to have a name in
      Rust: it's called a /builder/. ~std::process::Command~ is another example. =TODO=
      For more details on ~OpenOptions~, see the online documentation. =TODO=

    - Once a ~File~ has been opened, it behaves like any other /reader/ or /writer/.
      You can *add* a /buffer/ if needed. The ~File~ will be closed
      automatically when you drop it.

*** DONE Seeking - 441
    CLOSED: [2018-06-19 Tue 02:11]
    ~File~ also implements the ~Seek~ /trait/.
    ~Seek~ is defined like this:
    #+BEGIN_SRC rust
      pub trait Seek {
          fn seek(&mut self, pos: SeekFrom) -> io::Result<u64>;
      }

      pub enum SeekFrom {
          Start(u64),
          End(i64),
          Current(i64),
      }
    #+END_SRC
    - Usage (examples):
      + Rewind to the beginning:
        ~file.seek(SeekFrom::Start(0))~

      + Go back a few bytes:
        ~file.seek(SeekFrom::Current(-8))~

    - *Seeking within a file is _SLOW_.*
      Whether you're using a hard disk or a SSD, a /seek/ takes as long as
      reading several megabytes of data.
      =TODO= =WHY= =???=

*** DONE Other Reader and Writer Types - 442
    CLOSED: [2018-06-19 Tue 18:11]
    - ~io::stdin()~

    - ~io::stdin()~ and ~io::stderr()~
      also have /mutexes/ and ~.lock()~ /methods/.

    - ~Vec<u8>~
      implements ~Write~.
      Writing to a ~Vec<u8>~ *extends* the vector with the new data.

      (~String~ does NOT implement ~Write~.
      To build a string using ~Write~, first write to a ~Vec<u8>~, then use
      ~String::from_utf8(vec)~ to convert the vector to a string.)

    - ~Cursor::new(buf)~
      creates a ~Cursor~, a /buffered reader/ that reads from ~buf~.

      *This is how you create a /reader/ that reads from a ~String~.*

      + The argument ~buf~ can be any type that implements ~AsRef<[u8]>~, so you
        can also pass a ~&[u8]~, ~&str~, or ~Vec<u8>~.

      + ~Cursor~'s implement ~Read~, ~BufRead~, and ~Seek~.
        If the type of ~buf~ is ~&mut [u8]~ or ~Vec<u8>~, then the ~Cursor~ also
        implements ~Write~.

      + Writing to a /cursor/ *overwrites* bytes in ~buf~ starting at the current
        position.
        * If you try to write past the end of a ~&mut [u8]~, you'll get a *partial
          write* or an ~io::Error~.
          =TODO= More details! Which one???

        * Using a /cursor/ to write past the end of a ~Vec<u8>~ is *fine*, though:
          it grows the vector.

      + ~Cursor<&mut [u8]>~ and ~Cursor<Vec<u8>>~ thus *implement* _ALL_ FOUR of
        the ~std::io::prelude~ /traits/.

    - ~std::net::TcpStream~ represeents a TCP network connection.
      Since TCP enables two-way communication, it's BOTH a /reader/ and a /writer/.

      The /static method/ ~TcpStream::connect(("hostname", PORT))~ tries to connect
      to a server and returns an ~io::Result<TcpStream>~.

    - ~std::process::Command~ =TODO= =TODO= =TODO= =???=
      supports spawning a child process and piping data to its standard input.
      For example,
      #+BEGIN_SRC rust
        use std::process::{Command, Stdio};

        let mut child =
            Command::new("grep")
            .arg("-e")
            .arg("a.*e.*i.*o.*u")
            .stdin(Stdio::piped())
            .spawn()?;

        let mut to_child = child.stdin.take().unwrap();
        for word in my_words {
            writeln!(to_child, "{}", word)?;
        }
        drop(to_child);
        child.wait()?;
      #+END_SRC
      + The type of ~child.stdin~ is ~Option<std::process::ChildStdin>~; here we've
        used ~.stdin(Stdio::piped())~ when setting up the child process, so
        ~child.stdin~ is _definitely populated when_ ~.spawn()~ succeeds.
        If we hadn't, ~child.stdin~ would be ~None~.

      + ~Command~ also has similar /methods/ ~.stdout()~ and ~.stderr()~, which can be
        used to request /readers/ in ~child.stdout~ and ~child.stderr~.

    - The ~std::io~ module also offers a handful of /functions/ that return /trivial
      readers and writers/:
      + ~io::sink()~
        Returns a /writer/. All the write /methods/ return ~Ok~, butthe data is
        just discarded.

      + ~io::empty()~
        Returns a /reader/, with which reading _always succeeds_, but returns
        /end-of-input/.

      + ~io::repeat(byte)~
        returns a /reader/ that *repeats* the given ~byte~ _endlessly_.

*** DONE Binary Data, Compression, and Serialization - 444 =Re-read=
    CLOSED: [2018-06-19 Tue 22:28]
    Many _open source_ /crates/ _build on_ the ~std::io~ framework to offer
    EXTRA features:
    - The ~byteorder~ /crate/
      offers ~ReadBytesExt~ and ~WriteBytesExt~ /traits/ that ADD /methods/ to
      _ALL_ /readers/ and /writers/ *for /binary input and output/:*
      #+BEGIN_SRC rust
        use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian};

        let n = reader.read_u32::<LittleEndian>()?;
        writer.write_i64::<LittleEndian>(n as i64)?;
      #+END_SRC

    - The ~flate2~ /crate/
      provides /adapter methods/ for reading the writing ~gzipped~ data:
      #+BEGIN_SRC rust
        use flate2::FlateReadExt;

        let file = File::open("access.log.gz")?;
        let mut gzip_reader = file.gz_decode()?;
      #+END_SRC

    - The ~serde~ /crate/
      is for /serialization/ and /deserialization/: it converts back and forth
      _BETWEEN_ Rust /structs/ and /bytes/.

      We mentioned this once before, in "Traits and Other People's Types" on page 247.

      Now take a closer look.
      + Suppose we have some data -- the map for a text adventure game -- stored
        in a ~HashMap~:
        #+BEGIN_SRC rust
          type RoomId = String;                      // each room has a unique name
          type RoomExits = Vec<(char, RoomId)>;      // ...and a list of exits
          type RoomMap = HashMap<RoomId, RoomExits>; // room names and exits, simple

          // Create a simple map.
          let mut map = RoomMap::new();
          map.insert("Cobble Crawl".to_string(),
                     vec![('W', "Debris Room".to_string())]);
          map.insert("Debris Room".to_string(),
                     vec![('E', "Cobble Crawl".to_string()),
                          ('W', "Sloping Canyon".to_string())]);
          // ...
        #+END_SRC

      + Turning this data INTO JSON for output is just a few lines of code:
        #+BEGIN_SRC rust
          extern crate serde;
          use std::io;
          use serde::Serialize;
          use serde_json::Serializer;

          let mut serializer = Serializer::new(io::stdout());
          map.serialize(&mut serializer)?;
        #+END_SRC
        * This code uses the ~serialize~ /method/ of the ~serde::Serialize~ /trait/.
          *The library attaches this /trait/ to all types that it knows how to
          serialize*, and that includes all of the types that appear in our
          data: /strings/, /characters/, /tuples/, /vectors/, and ~HashMaps~.

        * ~serde~ is flexible.
          In this program, the output is JSON data, because we chose the ~serde_json~
          /serializer/. Other formats, like /MessagePack/, are also available.
            Likewise, you could send this output to a /file/, a ~Vec<u8>~, or any
          other /writer/. The code above prints the data on ~stdout~ . Here it is:
          #+BEGIN_SRC json
            {"Debris Room":[["E","Cobble Crawl"],["W","Sloping Canyon"]],"Cobble Crawl":
            [["W","Debris Room"]]}
          #+END_SRC

        * ~serde~ also includes support for *deriving* the two key ~serde~ /traits/:
          #+BEGIN_SRC rust
            #[derive(Serialize, Deserialize)]
            struct Player {
                location: String,
                items: Vec<String>,
                health: u32
            }
          #+END_SRC
          - As of Rust 1.17, this ~#[derive]~ /attribute/ requires a few extra steps
            when setting up your project.

            *We won't cover that here;* see the ~serde~ documentation for details.

            In short, the /build system/ *autogenerates implementations* of
            ~serde::Serialize~ and ~serde::Deserialize~ for ~Player~ , so that
            serializing a ~Player~ value is simple: ~player.serialize(&mut serializer)?;~

            The output looks like this:
            ~{"location":"Cobble Crawl", "items":["a wand"],"health":3}~

** DONE Files and Directories - 445
   CLOSED: [2018-06-08 Fri 22:22]
   The next few sections cover Rust's features for working with _files_ and
   _directories_, which live in the ~std::path~ and ~std::fs~ /modules/. All of
   these features involve _working with filenames_, so we'll start with the
   /filename types/.

*** DONE ~OsStr~ and ~Path~ - 445
    CLOSED: [2018-06-08 Fri 20:30]
    - Inconveniently, your operating system _does *NOT force VALID* Unicode_
      filenames.

      + Linux: 
        Any string of bytes (excluding null bytes and slashes) is an acceptable
        filename.

      + Windows: 
        ALMOST ANY (=???=) string of 16-bit "wide characters" is an acceptable
        filename, even strings the operating system handles, like /command-line
        arguments/ and /environment variables/.

    - Rust strings (~str~ and ~String~) are always *valid* Unicode.
      Rust has to cope with the rare case where the filenames are NOT Unicode.
      Rust has ~std::ffi::OsStr~ and ~OsString~.

    - =NOTE= TODO

    - ~std::path::Path~ and its /owning type/ ~PathBuf~.
      ~Path~ is purely a convenience -- it is exactly like ~OsStr~, but it _adds
      many handy /filename-related methods/._ ~Path~ is be used for both /absolute
      and relative paths/. For individual component of a /path/, use ~OsStr~.

    - Lastly, for each string type, there's a corresponding owning type:
      a ~String~ _owns_ a *heap-allocated* ~str~, a ~std::ffi::OsString~ _owns_ a
      *heap-allocated* ~OsStr~ , and a ~std::path::PathBuf~ _owns_ a *heap-allocated*
      ~Path~.
      |                                            | ~str~          | ~OsStr~           | ~Path~           |
      |--------------------------------------------+----------------+-------------------+------------------|
      | Unsized type, always passed by reference   | Yes            | Yes               | Yes              |
      | Can contain any Unicode text               | Yes            | Yes               | Yes              |
      | Looks just like UTF-8, normally            | Yes            | Yes               | Yes              |
      | Can contain non-Unicode data               | No             | Yes               | Yes              |
      | Text processing methods                    | Yes            | No                | No               |
      | Filename-related methods                   | No             | No                | Yes              |
      | Owned, growable, heap-allocated equivalent | ~String~       | ~OsString~        | ~PathBuf~        |
      | Convert to owned type                      | ~.to_string()~ | ~.to_os_string()~ | ~.to_path_buf()~ |

      =TODO= =???=
      All three of these types implement a common /trait/, ~AsRef<Path>~, so we
      can easily declare a /generic function/ that accepts "any filename type" as
      an argument. This uses a technique we showed in "AsRef and AsMut" on page 294. =TODO=
      #+BEGIN_SRC rust
        use std::path::Path;
        use std::io;

        fn swizzle_file<P>(path_arg: P) -> io::Result<()>
            where P: AsRef<Path>
        {
            let path = path_arg.as_ref();
            // ...
        }
      #+END_SRC
      =???= =TODO=
      All the standard functions and methods that take path arguments use this
      technique, so you can freely pass string literals to any of them.

*** DONE ~Path~ and ~PathBuf~ Methods - 447
    CLOSED: [2018-06-08 Fri 20:30]
    ~Path~ offers the following methods, among others:
    + ~Path::new(str)~
      Convert a ~&str~ or ~&OsStr~ to a ~&Path~.

      This does *NOT copy* the string:
      the new ~&Path~ *points to* the same bytes as the ORIGINAL ~&str~ or ~&OsStr~.

    + ~path.parent()~
      The /return type/ is ~Option<&Path>~.
      *NO string copy*, the result path just *point to* the substring of the ~path~.

      For instance, 
      ~Path::new("/home/fwolfe/program.txt").parent()~
      returns ~Path::new("/home/fwolfe")~

    + ~path.file_name()~
      Return the last component of ~path~, if any.
      The /return type/ is ~Option<&OsStr>~.

      For instance,
      * ~Path::new("/home/fwolfe/program.txt").file_name()~
        returns ~Some(OsStr::new("program.txt"))~.

      * ~Path::new("/home/fwolfe/").file_name()~
        returns ~Some(OsStr::new("fwolfe"))~.

    + ~path.is_absolute()~ and ~path.is_relative()~

    + ~path1.join(path2)~
      #+BEGIN_SRC rust
        let path1 = Path::new("/usr/share/dict");
        assert_eq!(path1.join("words"),
                   Path::new("/usr/share/dict/words"));
      #+END_SRC
      IF ~path2~ is an /absolute path/, this just returns a _copy_ of ~path2~,
      so _this /method/ can be used to *convert* ANY /path/ to an /absolute
      path/:_ ~let abs_path = std::env::current_dir()?.join(any_path);~

    + ~path1.components()~
      Returns an /iterator/ over the components of the given path, from left to
      right.

      The item type of this /iterator/ is ~std::path::Component~, and /enum/ that
      can represent all the different pieces that can appear in filenames:
      #+BEGIN_SRC rust
        pub enum Component<'a> {
            Prefix(PrefixComponent<'a>),  // Windows-only: a drive letter or share
            RootDir,                      // the root directory, `/` or `\`
            CurDir,                       // the `.` special directory
            ParentDir,                    // the `..` special directory
            Normal(&'a OsStr),            // plain file and directory names
        }
      #+END_SRC
      * For instance,
        A Windows path =\\venice\Music\A Love Supreme\04-Psalm.mp3= consists of
        1. a ~Prefix~ representing =\\venice\Music=
        2. a ~RootDir~
        3. two ~Normal~ components representing =A Love supreme= and =04-Psalm.mp3=.

    + /methods/ that query the filesystem:
      * ~.exists()~
      * ~.is_file()~
      * ~.is_dir()~
      * ~.read_dir()~
      * ~.canonicalize()~, and so on.

    + /methods/ that convert ~Path~'s to strings.
      Each one allows for the posibility of invalid UTF-8 in the ~Path~.
      * ~path.to_str()~
        Convert ~Path~ to an ~Option<&str>~.
        If the ~Path~ content isn't valid UTF-8, this returns ~None~.

      * ~path.to_string_lossy()~
        If path is _NOT valid UTF-8_, this /method/ _make a copy_, *replacing*
        each _invalid byte sequence_ with the /Unicode replacement character/,
        =U+FFFD (‘�’)=.

        The /return type/ is ~std::borrow::Cow<str>~.
        =TOOD= See "Borrow and ToOwned at Work: The Humble Cow"

      * ~path.display()~
        The value this returns is _NOT a string_, but it implements ~std::fmt::Display~,
        so it can be used with ~format!()~, ~println!()~, and friends.

        If the path is *NOT valid* UTF-8, the output may contain the ~�~ character.

*** DONE Filesystem Access Functions - 449
    CLOSED: [2018-06-08 Fri 21:38]
    - Table 18-1. Summary of filesystem access functions

    - For creating /symbolic links/, see "Platform-Specific Features" on page 451.
      =TODO=

    - NOTE ......

    - As a convenience,
      the ~Path~ type has a few of these built in as /methods/:
      ~path.metadata()~, for example, is the same thing as ~std::fs::metadata(path)~.

*** DONE Reading Directories - 450
    CLOSED: [2018-06-08 Fri 22:16]
    Use ~std::fs::read_dir(path)~ and the ~.read_dir()~ /method/ of a ~Path~:

    - Example:
      #+BEGIN_SRC rust
        for entry_result in path.read_dir()? {
            let entry = entry_result?;
            println!("{}", entry.file_name().to_string_lossy());
        }
      #+END_SRC

    - Note the *two* uses of ~?~ in this code.
      + The first line checks for errors *opening the directory*.
      + The second line checks for errors *reading the next entry*.

    - The type of ~entry~ is ~std::fs::DirEntry~, and it's a /struct/ with just a
      few /methods/:
      + ~entry.file_name()~ is the name of the file or directory, as an ~OsString~.

      + ~entry.path()~ is the same, but with the original path joined to it, producing
        a new ~PathBuf~. If the directory we're listing is =/home/jimb=, and
        ~entry.file_name()~ is =.emacs=, then ~entry.path()~ would return
        ~PathBuf::from("\slash{}home\slash{}jimb\slash{}.emacs")~.

      + ~entry.file_type()~ returns an ~io::Result<FileType>~.
        ~FileType~ has ~.is_file()~, ~.is_dir()~, and ~.is_symlink()~ /methods/.

      + ~entry.metadata()~ gets the rest of the metadata about this /entry/.

    - The special directories ~.~ and ~..~ are not listed when reading a directory.
      =TIPs=

    - Example, recursively copies a directory tree from one place to another on
      disk:
      #+BEGIN_SRC rust
        use std::fs;
        use std::io;
        use std::path::Path;

        /// Copy the existing directory `src` to the target path `dst`.
        fn copy_dir_to(src: &Path, dst: &Path) -> io::Result<()> {
            if !dst.is_dir() {
                fs::create_dir(dst)?;
            }

            for entry_result in src.read_dir()? {
                let entry = entry_result?;
                let file_type = entry.file_type()?;
                copy_to(&entry.path(), &file_type, &dst.join(entry.file_name()))?;
            }

            Ok(())
        }
      #+END_SRC

      A separate function, ~copy_to~, copies individual directory entries:

      #+BEGIN_SRC rust
        /// Copy whatever is at `src` to the target path `dst`.
        fn copy_to(src: &Path, src_type: &fs::FileType, dst: &Path) -> io::Result<()> {
            if src_type.is_file() {
                fs::copy(src, dst)?;
            } else if src_type.is_dir() {
                copy_dir_to(src, dst)?;
            } else {
                return Err(io::Error::new(io::ErrorKind::Other,
                                          format!("don't know how to copy: {}", src.display())));
            }

            Ok(())
        }
      #+END_SRC

*** TODO Platform-Specific Features - 451 =RE-READ= =TAKE NOTES=

** DONE Networking - 453
   CLOSED: [2018-06-08 Fri 23:00]
   =From Jian= I only take nots, I don't understand /network programing/.
   Re-read later when I understand.

   - For _low-level networking code_, start with the ~std::net module~, which
     provides _cross-platform_ SUPPORT _for TCP and UDP networking_.

   - Use the ~native_tls~ /crate/ for _SSL/TLS_ SUPPORT.

   - For high-performance servers, you'll need to use /ASYNCHRONOUS input and
     output/. The ~mio~ /crate/ provides the needed support.

   - There's also the EXPERIMENTAL ~tokio~ /crate/, which wraps the ~mio~ event
     loop in a futures-based API, reminiscent of JavaScript promises.

   - Higher-level protocols are supported by third-party crates.
     For example, the ~reqwest~ /crate/ offers a beautiful API for HTTP clients.

   - The ~iron~ framework for HTTP servers offers high-level touches such as the
     ~BeforeMiddleware~ and ~AfterMiddleware~ traits, which help you compose an
     app from pluggable parts.

   - The ~websocket~ /crate/ implements the _WebSocket protocol_.

   - And so on. Rust is a young language with a busy open source ecosystem. Support
     for networking is rapidly expanding.

* TODO 19. Concurrency - 457
** TODO Fork-Join Parallelism - 459
*** TODO ~spawn~ and ~join~ - 461
*** TODO Error Handling Across Threads - 463
*** TODO Sharing Immutable Data Across Threads - 464
*** TODO Rayon - 466
*** TODO Revisiting the Mandelbrot Set - 468

** TODO Channels - 470
*** TODO Sending Values - 472
*** TODO Receiving Values - 475
*** TODO Running the Pipeline - 476
*** TODO Channel Features and Performance - 478
*** TODO Thread Safety: ~Send~ and ~Sync~ - 479
*** TODO Piping Almost Any Iterator to a Channel - 482
*** TODO Beyond Pipelines - 483

** TODO Shared Mutable State - 484
*** TODO What Is a ~Mutex~? - 484
*** TODO ~Mutex<T>~ - 486
*** TODO ~mut~ and ~Mutex~ - 488
*** TODO Why Mutexes Are Not Always a Good Idea - 488
*** TODO Deadlock - 489
*** TODO Poisoned Mutexes - 490
*** TODO Multi-producer Channels Using Mutexes - 490
*** TODO Read/Write Locks (~RwLock<T>~) - 491
*** TODO Condition Variables (Condvar) - 493
*** TODO Atomics - 494
*** TODO Global Variables - 496

** TODO What Hacking Concurrent Code in Rust Is Like - 497

* TODO 20. Macros - 499
  - Rust supports /macros/,
    a way to extend the language in ways that go *beyond* what you can do with
    /functions/ ALONE.

  - Example:
    ~assert_eq!(gcd(6, 10), 2);~

    + This could have been written as a /generic function/,

      _BUT_ the ~assert_eq!~ /macro/ does several things _that /functions/ *CANNOT*
      do_.

      One is that when an assertion fails, ~assert_eq!~
      _generates an error message containing the FILENAME and LINE NUMBER of the
      assertion._

      *Functions have no way of getting that information*.
      *Macros can*, because the way they work is completely different.

  - /Macros/ are a kind of shorthand.
    During compilation,
    + _BEFORE_ types are checked
      and
    + _LONG BEFORE_ any machine code is generated, each /macro/ call is /expanded/
      -- that is, it's replaced with some Rust code.

  - The preceding /macro/ call /expands/ to this:
    #+BEGIN_SRC rust
      match (&gcd(6, 10), &2) {
          (left_val, right_val) => {
              if !(*left_val == *right_val) {
                  panic!("assertion failed: `(left == right)`, \
                          (left: `{:?}`, right: `{:?}`)", left_val, right_val);
              }
          }
      }
    #+END_SRC
    + ~panic!~ is also a /macro/, so it then expands to some more Rust code.
      That code uses TWO other /macros/, ~file!()~ and ~line!()~.

      Once every /macro/ call in the /crate/ is *FULLY* /expanded/, Rust moves on
      to the next phase of compilation.

    + At run time, an assertion failure would look like this (and would indicate
      a bug in the ~gcd()~ function, since ~2~ is the correct answer):
      #+BEGIN_SRC text
        thread 'main' panicked at 'assertion failed: `(left == right)`, (left: `17`,
        right: `2`)', gcd.rs:7
      #+END_SRC

    + Rust /macros/ NEVER insert _unmatched brackets or parentheses._

** TODO Macro Basics - 500
   - Figure 20-1 shows part of the source code for the ~assert_eq!~ /macro/.
     + /pattern/ and /template/

     + Code:
       #+BEGIN_SRC rust
         macro_rules! assert_eq {
             ($left:expr, $right:expr) => ({
                 match (&$left, &$right) {
                     if !(*left_val = *right_val) {
                         panic!("assertion failed: `(left == right)` (left: `{:?}`, right: `{:?}`)",
                                left_val, right_val)
                     }
                 }
             });
         }
       #+END_SRC


   - ~macro_rules!~ is the *MAIN* way to define /macros/ in Rust.

     Note that there is *NO* ~!~ after ~assert_eq~ in this /macro/ definition:
     the ~!~ is
     + _ONLY_ included when *calling* a /macro/,
     + NOT when *defining* it.

   - =TODO=
     We'll talk about another approach, called /procedural macros/, at the end of
     this chapter.

     But for the most part, we'll focus on ~macro_rules!~.

   - A macro defined with ~macro_rules!~ works *entirely* by /pattern matching/.
     The _body_ of a /macro/ is just *a series of RULES*:
     #+BEGIN_SRC rust
       ( pattern1 ) => ( template1 );
       ( pattern2 ) => ( template2 );
       ...
     #+END_SRC

   - Incidentally, you _can use square brackets or curly braces_ instead of parentheses
     around the pattern or the template; it makes no difference to Rust. Likewise, when
     you call a /macro/, these are all equivalent:
     #+BEGIN_SRC rust
       assert_eq!(gcd(6, 10), 2);
       assert_eq![gcd(6, 10), 2];
       assert_eq!{gcd(6, 10), 2}
     #+END_SRC

     + The only difference is that _semicolons_ are usually _optional_ after curly
       braces.

       _By convention_, we use
       * parentheses when calling ~assert_eq!~,
       * square brackets for ~vec!~,
         and
       * curly braces for ~macro_rules!~;

       but it's just a convention.

*** TODO Basics of Macro Expansion - 501
    - x

*** TODO Unintended Consequences - 503
    - x

*** TODO Repetition - 505
    | Pattern      | Meaning                                        |
    | ~$( ... )*~  | Match _0_ or more times with no separator        |
    | ~$( ... ),*~ | Match _0_ or more times, separated by commas     |
    | ~$( ... );*~ | Match _0_ or more times, separated by semicolons |
    | ~$( ... )+~  | Match _1_ or more times with no separator        |
    | ~$( ... ),+~ | Match _1_ or more times, separated by commas     |
    | ~$( ... );+~ | Match _1_ or more times, separated by semicolons |

** DONE Built-In Macros - 507
   CLOSED: [2018-06-05 Tue 22:12]
   - The Rust compiler supplies several /macros/ that are helpful when you're
     defining your own /macros/.

     *None* of these could be implemented using ~macro_rules!~ alone -- they're
     *hardcoded* in /rustc/:

     + ~file!()~ expands to a /string literal/: the _current filename_.

       ~line!()~ expand to a ~u32 literal~ giving the _current line_ (counting
       from 1).

       ~column!()~ expand to a ~u32 literal~ giving the _current column_ (counting
       from 0).

       =REMEMBER=
       If one /macro/ calls another, which calls another, _all in DIFFERENT files_,
       and the *LAST* /macro/ calls ~file!()~, ~line!()~, or ~column!()~, it will
       expand to *indicate the location of the first macro call*.

     + ~stringify!(...tokens...)~ expands to a /string literal/ containing the
       given tokens.
       =From Jian= Here ~...tokens...~ means anything in side the parentheses.
       For instance, ~stringify!(1 2 3 4)~ generates "1 2 3 4", ~stringify!(1 , 2)~
       generates "1, 2", and ~stringify!(1 + 1)~ generates "1 + 1".

       * The ~assert!~ macro uses ~stringify!~ to generate an error message that
         includes the code of the assertion.

       * /Macro calls/ in the argument are *NOT* expanded: ~stringify!(line!())~
         expands to the string ~"line!()"~ .

       * Rust constructs the string ONLY from the tokens, so there are *NO* _line
         breaks_ or _comments_ in the string.

     + ~concat!(str0, str1, ...)~ expands to a single /string literal/ made by
       concatenating its arguments.

   - Rust also defines these /macros/ for _querying the build environment_:
     + ~cfg!(...)~ expands to a Boolean constant, true if the current build
       configuration matches the condition in parentheses. For example,
       ~cfg!(debug_assertions)~ is true if you’re compiling with debug
       assertions enabled.

       This macro supports exactly the same syntax as the #[cfg(...)] attribute
       described in “Attributes” on page 175 but instead of conditional
       compilation, you get a true or false answer.

     + ~env!("VAR_NAME")~ expands to a string: the value of the specified environment
       variable at compile time. If the variable doesn’t exist, it’s a compilation error.
       This would be fairly worthless except that Cargo sets several interesting environ‐
       ment variables when it compiles a crate. For example, to get your crate’s current
       version string, you can write: ~let version = env!("CARGO_PKG_VERSION");~
       A full list of these environment variables is included in the Cargo documentation.

     + ~option_env!("VAR_NAME")~ is the same as ~env!~ except that it returns an
       ~Option<&'static str>~ that is None if the specified variable is not set.

   - Three more /built-in macros/ let you _bring in code or data from another file_.
     + ~include!("file.rs")~ expands to the contents of the specified file, which
       must be valid Rust code -- either an expression or a sequence of items.

     + ~include_str!("file.txt")~ expands to a ~&'static str~ containing the _text_
       of the specified file. You can use it like this:
       #+BEGIN_SRC rust
         const COMPOSITOR_SHADER: &str =
             include_str!("../resources/compositor.glsl");
       #+END_SRC

       If the file doesn't exist, or is not valid UTF-8, you'll get a
       _compilation error_.

     + ~include_bytes!("file.dat")~ is the same except the file is treated as _binary
       data_, NOT UTF-8 text. The result is a ~&'static [u8]~.

** DONE Debugging Macros - 508
   CLOSED: [2018-06-10 Sun 20:58]
   - Debugging a wayward /macro/ can be challenging.

     + The biggest problem is
       the lack of visibility into the process of macro expansion.

   - Rust will often *expand* all /macros/, find some kind of error, and then print
     an error message that does _NOT show the fully expanded code_ that contains
     the error!

   - Here are _THREE_ tools to help *troubleshoot* /macros/.
     (These features are ALL *unstable*,
     but since they're really designed to be used during development, not in
     code that you’d check in, that isn’t a big problem in practice.)

     + The simplest, you can ask ~rustc~ to show what your code looks like _after
       expanding_ ALL /macros/.

       Use ~cargo build --verbose~ to see how Cargo is invoking ~rustc~.
       1. Copy the ~rustc~ command line
          and
       2. add ~-Z unstable-options --pretty expanded~ as options.

       Then the _fully expanded code_ is dumped to your terminal.

       _Unfortunately, this ONLY WORKS if your code is free of syntax errors._

     + Rust provides a ~log_syntax!()~ /macro/ that simply prints its
       arguments to the terminal at /compile time/. You can use this for
       ~println!~-style debugging. This macro requires the ~#![feature(log_syntax)]~
       feature flag.
       =From Jian= Not clear! Try this!

     + You can ask the Rust compiler to _log ALL /macro/ calls_ to the terminal.
       Insert ~trace_macros!(true);~ somewhere in your code.
         From that point on, each time Rust *expands* a /macro/, it will print the
       /macro/ _name_ and _arguments_. For example, this program:
       For example:
       #+BEGIN_SRC rust
         #![feature(trace_macros)]

         fn main() {
             trace_macros!(true);
             let numbers = vec![1, 2, 3];
             trace_macros!(false);
             println!("total: {}", numbers,iter().sum::<u64>());
         }


       #+END_SRC

       Compile it

       #+BEGIN_SRC bash
         # $
         rustup override set nightly
         ## ...

         # $
         rustc trace_example.rs
         ## note: trace_macro
         ##  --> trace_example.rs:5:19
         ##   |
         ## 5 |     let numbers = vec![1, 2, 3];
         ##   |                   ^^^^^^^^^^^^^
         ##   |
         ##   = note: expanding `vec! { 1 , 2 , 3 }`
         ##   = note: to `< [ _ ] > :: into_vec ( box [ 1 , 2 , 3 ] )`
       #+END_SRC
       * The compiler shows the code of EACH /macro/ call, both *before* and
         *after* _expansion_. The line ~trace_macros!(false);~ turns tracing off
         again, so the call to ~println!()~ is not traced.

** TODO The ~json!~ Macro - 509
*** TODO Fragment Types - 510
*** TODO Recursion in Macros - 513
*** TODO Using Traits with Macros - 514
*** TODO Scoping and Hygiene - 516
*** TODO Importing and Exporting Macros - 519

** TODO Avoiding Syntax Errors During Matching - 521
** TODO Beyond ~macro_rules!~ - 522

* TODO 21. Unsafe Code - 525
  - Unsafe code lets you tell Rust, "In this case, just trust me."
    By marking off a block or function as /unsafe/, you acquire the ability to
    + call /unsafe functions/ in the standard library
    + dereference /unsafe pointers/,
    + call /functions written in other languages/ like C and C++,
    + among other powers.

    All of Rust's usual safety checks _STILL APPLY_: type checks, lifetime checks,
    and bounds checks on indices all occur normally.
      *Unsafe code just enables a small set of additional features.*

** TODO Unsafe from What? - 526
** TODO Unsafe Blocks - 527
*** TODO Example: An Efficient ASCII String Type - 529

** TODO Unsafe Functions - 531
** TODO Unsafe Block or Unsafe Function? - 533
** TODO Undefined Behavior - 533
** TODO Unsafe Traits - 536
** TODO Raw Pointers - 538
*** TODO Dereferencing Raw Pointers Safely - 540
*** TODO Example: ~RefWithFlag~ - 541
*** TODO Nullable Pointers - 544
*** TODO Type Sizes and Alignments - 544
*** TODO Pointer Arithmetic - 545
*** TODO Moving into and out of Memory - 546
*** TODO Example: ~GapBuffer~ - 550
*** TODO Panic Safety in Unsafe Code - 556

** TODO Foreign Functions: Calling C and C++ from Rust - 557
*** TODO Finding Common Data Representations - 558
*** TODO Declaring Foreign Functions and Variables - 561
*** TODO Using Functions from Libraries - 562
*** TODO A Raw Interface to libgit2 - 566
*** TODO A Safe Interface to libgit2 - 572

** TODO Conclusion - 583

* Index - 585
  
 
