#+TITLE: Mastering Functional Programming
#+SUBTITLE: Functional techniques for sequential and parallel programming with Scala
#+PUBLICATION TIME: 2018
#+AUTHOR: Anatolii Kmetiuk
#+STARTUP: overview
#+STARTUP: entitiespretty

* DONE Preface - 1
  CLOSED: [2022-06-03 Fri 17:41]
  - Functional programming languages are attracting attention as an efficient way
    to handle the new requirements for programming multi- processor and
    high-availability applications.

  - This book will teach you functional programming with the help of Scala.

  - *CONTENT*:
    We will
    1. cover the concepts of pure functions and type classes,
       1) problems they aim to solve;

       2) how to use them in practice.

    2. see how libraries can be used for _purely functional programming_, and
       look at the broad family of libraries for functional programming.
       
    3. discuss some of the more _ADVANCED patterns_ in the functional programming
       world, such as
       * Monad Transformers
       * Tagless Final.

    4. look into the subject of /parallel programming/:
       1) introduce the /Actor model/ and
       2) how it is implemented in the modern functional languages.


  - *TARGET*:
    By the end of this book,
    you will have mastered the concepts entailing functional programming
    alongside OOP to build robust applications.
    
** Who this book is for - 1
** What this book covers - 1
   - _Chapter 1, The Declarative Programming Style_,
     covers the MAIN IDEA of /declarative style/ of abstracting away repeating
     algorithmic patterns and control flows so that, with one statement, it is
     possible to describe what otherwise would have been 10 lines of imperative
     code.

     * Functional languages usually have an /elaborate infrastructure/ to make
       such an approach especially relevant and usable.
       + Compare the programming with collections in
         Java (imperative style) and Scala (functional style)

   - _Chapter 2, Functions and Lambdas_,
     1. Start with the concept familiar to an OOP programmer -- a /method/.
     2. Then explore some more advanced, functional concepts specific to functional
        programming -- things such as
        1) lambdas,
        2) currying,
        3) generic type parameters,
        4) implicit arguments,
        5) higher-order functions.
           * how higher-order functions may be useful to *abstract control flow*.
        6) concept of partial functions

   - _Chapter 3, Functional Data Structures_, explains a _functional collections
     framework_.

     1. It features a _hierarchy_ of collections data types designed for different
        scenarios.

     2. Other data types that are *NOT* part of the collections framework
        but are often used in functional programming and hence deserve our
        attention:
        * ~Option~
        * ~Either~
        * ~Try~
        
     3. How the _data structures_ *are separated from* their _behavior_
        via an _implicit mechanism_, which is present in some ADVANCED
        languages.
     
   - _Chapter 4, The Problem of Side Effects_, is about /side effects/ that are
     ubiquitous in programming.
     
     Functional programming advocates for so-called /pure functions/ --
     functions that do not produce any /side effects/, which means you can't
     write a file from such a function, or contact the network.

     This chapter explores these questions:
     * Q :: Why would functional programming advocate against functions that cause
            /side effects/?
     * Q :: Is it possible to write a useful program using /pure functions/ only?

   - _Chapter 5, Effect Types - Abstracting Away Side Effects_,
     provides *SOLUTIONS* to the problems of _working with /side effects/ in a
     pure way._

     The solution presented by _purely functional programming_ is to turn the
     /side effects/ you encounter into /functional data structures/.

     1. We will
        explore the process of identifying /side effects/ and
        turning them into such /data structures/.

     2. Then, we will quickly *realize* functions that produce /side effects/
        usually work one with another.
        
     3. We will hence explore how one can *combine* these functions using the
        concept of the ~Monad~.

   - _Chapter 6, Effect Types in Practice_,
     focuses on the material of the Chapter 3, Functional Data Structures,
     *from a new perspective.*
     
     - phenomenon :: something that happens, such as an _exception_ or a _delay_.

     =IMPORTANT=
     We will see how /functional data structures/ have a *deeper meaning* to the
     data types -- that of *representing _phenomena_ as data*.

     * By _representing it in data_
       we are able to
       _SHIELD ourselves FROM the /effects/ of the /phenomenon/
       while PRESERVING the information about it._

   - _Chapter 7, The Idea of the Type Classes_,
     explore how the /Type Class pattern/ logically emerges _from practical needs_
     encountered when working with /effect types/.

   - _Chapter 8, Basic Type Classes and Their Usage_,
     outlines
     the _MOST FREQUENTLY ENCOUNTERED_ /type classes/ and _their family_ in general.

     1. Discuss the *motivation* for the creation of /type class systems/,

     2. Proceed further to examine their structure and a few basic /type classes/
        from them.
        * /Type classes/ such as ~Monad~ and ~Applicative~ are frequently used in
          functional programming, so they deserve some special attention.

   - _Chapter 9, Libraries for Pure Functional Programming_,
     DISCUSSES HOW to use the purely functional techniques (/effect types/ and
               /type classes/)
               
     LEARNED   so far in order to develop server-side software.

     * We will learn
       1. how to write concurrent, asynchronous software for
          + responding to HTTP requests,
          + contacting the database.

     * We will also learn about
       the /concurrency model/ modern functional programming offers.

   - _Chapter 10, Patterns of Advanced Functional Programming_,
     explores how to *combine* /effect types/ to get new /effect types/.

     You will see how to leverage the power of the /compiler's type system/ to
     check guarantees about the program on compile time.

   - _Chapter 11, Introduction to the Actor Model_,
     starts with EXAMINING the _traditional model_ of /concurrent programming/
     in details.
     * This model rises *a bunch of problems*
       such as /race conditions/ and /deadlocks/, which make programming in it
       prone to ERRORS that are PARTICULARLY HARD TO DEBUG.
         This chapter presents the idea of an /Actor model/ that aims to *solve*
       these problems.

   - _Chapter 12, The Actor Model in Practice_,
     covers the /fundamentals of the framework/ and its /concepts/.

     You will proceed to
     * learn some of the patterns that emerge during actor-oriented programming
       and

     * also see how /Actors/ *interoperate with* other widespread concurrency
       primitives -- ~Future~'s.

   - _Chapter 13, Use Case - A Parallel Web Crawler_,
     examines a larger /concurrent application/ written with the Actor model.

     One good such example is a _web crawler application_. This chapter will
     examine how to implement such a larger application.

   - _Appendix A, Introduction to Scala_,
     is a short introduction to the Scala language, which is used for examples
     throughout the book.
     
** To get the most out of this book - 4
** Download the example code files - 4
** Download the color images - 5
** Conventions used - 5
** Get in touch - 6
** Reviews - 6
  
* TODO Chapter 1: The Declarative Programming Style - 7
  - /Declarative programming/ is *tightly connected to* /functional programming/.

  - =IMPORTANT=
    _Modern functional languages_ prefer to express programs
    as _ALGEBRA_ and *NOT* as _ALGORITHMS_.

    * This means that programs in functional languages are combinations of certain
      primitives with operators.

  - Declarative programming ::
    The technique where you express your programs by
    specifying _what to do_, *but NOT* _how to do it_.

    * =TODO=
      We will explore why declarative programming appeared and where it can be
      used.

  - In this chapter, we will cover the following topics:
    * *Principles* of /declarative programming/
    * Declarative versus imperative COLLECTIONS
    * Declarative programming in OTHER languages

** DONE Technical requirements - 7
   CLOSED: [2022-06-05 Sun 13:02]
   - On macOS
     1. Install Docker, and then issue the command ~sudo launchctl start docker~
        in terminal

     2. Paste the following commands in terminal:
        #+begin_src shell
          export DOCKER_BUILDKIT=0
          export COMPOSE_DOCKER_CLI_BUILD=0
        #+end_src

     3. Clone my fork, which includes fixes to the original container configurations:
        https://github.com/ShapelessCat/Mastering-Functional-Programming

     4. From the root, run ~./compose.sh~ from the terminal.

     5. Run _shell (Bash)_ on the _Docker service_ called
        ~mastering-functional-programming_backend_1~ by running the ~./start.sh~
        from a *SEPARATE* terminal window. Then you can ~cd~ to the chapter folders.
        
     6. Run the C++ examples, which are in the =cpp= folder,
        with ~./run.sh <name-of-the-source>~
        * =from Jian=
          The setup of this container is not complete, and you need
          1) ~apt update~ (you are by default the root user)
          2) ~apt install build-essential~
          3) go to a chapter folder, and ~chmod 755 run.sh~ in the =cpp= folder,
             if it exists
        
     7. Run the Java and Scala examples, which are in the =jvm= folder,
        with ~sbt run~

   - =IMPORTANT=
     The Docker is necessary, because some chapters run examples against a live
     database, which is managed by Docker.
       
** DONE Principles of declarative programming - 8
   CLOSED: [2022-06-05 Sun 14:02]
   - Q :: *WHY* /declarative programming/?
   - Q :: How did it appear?

   - How /declarative programming/ is different from /imperative programming/.


   - For a long time,
     /imperative programming/ has been a de facto industry standard.

     *What motivated people* to start switching to the /functional style/ *FROM*
     the /imperative style/?

   - In /imperative programming/,
     you _RELY ON_ *a set of primitives* that your language provides.
     You _COMBINE_ them in a certain way so as to _ACHIEVE_ a functionality that
     you need.
     _CONCLUSION_: We can understand different things under /primitives/.
     * For example,
       these can be
       + /loop control structures/, or,

       + in the case of collections,
         operations specific to collections, such as _creating_ a collection and
         _adding_ or _removing_ elements from a collection.
     
   - In /declarative programming/,
     you also rely on /primitives/. You use them to express your program.

     Yet, in /declarative programming/, these /primitives/ are *much closer to
     your domain*. They can be so close to your *domain* that the language
     itself can be regarded as a /domain-specific language (DSL)/. With
     /declarative programming/, you are able to create /primitives/ as you go.

   - In /imperative programming/, you usually do *NOT* create new /primitives/,
     BUT rely on the ones the language provides you with.
       Let's go through some examples to understand the importance of /declarative
     programming/.
     
*** DONE Example – go-to versus loops - 9
    CLOSED: [2022-06-05 Sun 13:46]
    How /imperative/ turns into /declarative/ is best understood by means of an example.

    - Q :: You have heard that using the go-to statement is bad practice. *WHY?*

    - Consider an example of a loop, which is expressed using the go-to statement:
      #+begin_src cpp
        #include <iostream>

        using namespace std;

        int main() {
         int x = 0;
         loop_start:
         ++x;
         cout << x << "\n";
         if (x < 10) goto loop_start;
         return 0;
        }
      #+end_src

    - pattern :: an arrangement of _two or more logical elements_ in your code that
                 *repeats* _in different places_ of your program.

    - A :: Why is go-to a bad style in this case?
           *A loop is a pattern.*
      * Q :: Why is it a pattern?
             First, it consists of _THREE parts_:
        1. The /label/:
           It is
           + the _entry point_ to the body of the loop
           + the point where you jump from the end of the loop to reiterate the loop.
        2. The /condition/ that must be true in order for the loop to reiterate.
        3. The third part is the statement to reiterate the fact that it is a loop.
           It is the end of the body of the loop.

    - Q :: Loops are ubiquitous in programming needs no explanation.
           *If you re-implement the loop pattern each time you need it, things
           can go wrong.* -- a pattern includes several parts, and you may misuse
           some parts when re-implementing it again and again.
      * Conclusion:
        We should avoid doing this, and create a concise and compact structure
        to represent this loop pattern is a solution.
        =from Jian=
        It seems the author want to convey the idea that
        /Structural programming/ is one step the moving forward to /declarative
        programming/ from /imperative programming/.
    
*** DONE Example – nested loop - 10
    CLOSED: [2022-06-05 Sun 13:53]
    A nested loop that is implemented in the go-to statements make the problem
    mentioned in the last section even clearer:
    #+begin_src cpp
      int main() {
        int rows = 3;
        int cols = 3;
        int matrix[rows][cols] = {
          { 1, 2, 3 },
          { 4, 5, 6 },
          { 7, 8, 9 }
        };
        int r = 0;
       row_loop:
        if (r < rows) {
          int c = 0;
        col_loop:
          if (c < cols) {
            cout << matrix[r][c] << " ";
            c++;
            goto col_loop;
          }
          cout << "\n";
          r++;
          goto row_loop;
        }
        return 0;
      }
    #+end_src
    
*** DONE Don't Repeat Yourself (DRY) - 12
    CLOSED: [2022-06-05 Sun 14:02]
    One of the _fundamental rules_ of engineering is to *create abstractions for
    logic that repeats.* -- give each ubiquitous pattern a name, and refer to them
    by their name anywhere.

    - This is why contemporary languages, such as Java or C++, have their own
      *built-in mechanisms* for /loops/. Then the compiler can help to build the
      jumps in patterns, and it is much less likely to make mistake.
      #+begin_src cpp
        #include <iostream>

        using namespace std;

        int main() {
          int rows = 3;
          int cols = 3;
          int matrix[rows][cols] = {
            { 1, 2, 3 },
            { 4, 5, 6 },
            { 7, 8, 9 }
          };
          for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) cout << matrix[r][c] << " ";
            cout << "\n";
          }
        }
      #+end_src

    - =TODO= =NEXT=
      Next, let's see how this idea develops further using the example of
      declarative collections and how they differ from imperative ones.

** DONE Declarative versus imperative collections - 13
   CLOSED: [2022-06-05 Sun 19:38]
   Another great ILLUSTRATION of how the /declarative style/ works can be seen in
   /collection frameworks/ -- compare the _Java (imperative) collections_ and
   _Scala (functional) collections_.

   - Q :: Why a collection framework?
   - A :: Collections are ubiquitous in any programming project.
     * Therefore, most modern programming languages provide you with the implementation
       of collection frameworks as part of their core library.
   
   - =TODO=
     Go into more depth about how imperative collections are different from declarative
     collections in the next chapter.
     
   - =TODO= =NEXT=
     Briefly discuss the major differences between the two approaches to collections here.
     * _Filtering_
     
*** Filtering - 14
    Create a separate collection from a collection of the names of employees, and
    only keep the names start with the letter ~'A'~.

    - Java:
      #+begin_src java
        import java.util.List;
        import java.util.ArrayList;

        class Main {
            public static void main(String[] args) {
                // Source collection
                List<String> employees = new ArrayList<>();
                employees.add("Ann");
                employees.add("John");
                employees.add("Amos");
                employees.add("Jack");

                // Those employees with their names starting with 'A'
                List<String> result = new ArrayList<>();
                for (String e: employees)
                    if (e.charAt(0) == 'A') result.add(e);

                System.out.println(result);
            }
        }
      #+end_src
      What can go wrong:
      1. If the context is complicated, you may call ~add~ on a wrong collection.
      2. You may forget the ~if (e.charAt(0) == 'A')~ check.
         
      You may not make the mistakes above, but how about in a large projects?

    - The point here is that we have the same situation as in the *loop* versus *go-to*
      example.

    - Scala:
      #+begin_src scala
        // Source collection
        val employees = List(
          "Ann",
          "John",
          "Amos",
          "Jack"
        )

        // Those employees with their names starting with 'A'
        val result = employees.filter(_.head == 'A')
        println(result)
      #+end_src
      * =from Jian=
        Here you have no chance to make mistakes that you can make in the above
        Java in any context.

      * The pattern is implemented in the _language internals_, and we do not need
        to worry about how it is done.

        In the meanwhile, we have a _precise specification of how it works and of
        what it does_, and *we can RELY ON it.*

      * The advantage here is not only that

        + the code becomes _easier to read_, and thus _easier to reason about_.

        + It also *INCREASES* _reliability_ and _runtime performance_.

          - The reason is that the /filter pattern/ here is a member of the core
            Scala library. This means that _it is well tested_.

      * Also observe that the notion of /anonymous lambdas/ gets introduced here.
          /Anonymous lambdas/ are a common feature of functional languages, as
        they *INCREASE* your _flexibility_ for *abstracting logic*.

** TODO Declarative programming in other languages - 16
   In general, you can spot whether a language is *declarative programming-friendly*
   by looking at the capabilities it provides.
   
   - Some of the features you can look for are
     * /anonymous functions/,
       =TODO= =TODO=

     * /functions as first-class citizens/, and
       =TODO= =TODO=

     * /custom operator specifications/.
       =TODO= =TODO=
     
** TODO Summary - 17
** TODO Questions - 17
   
* TODO Chapter 2: Functions and Lambdas - 18
  - The paradigm of /functional programming/ has a lot of _COMMON FEATURES_ with
    the paradigm of /declarative programming/.
    * One of the defining features of /functional languages/ and /declarative programming/
      is *the extensive use of /functions/.*

  - This chapter will *DISCUSS* in more detail
    * what /functions/ are and their meaning in different paradigms.

  - We will have a *LOOK AT*
    * how we can use /functions/ and
    * what their role is in _modern programming languages._
    
  - In this chapter, we will cover the following topics:
    * /Functions/ as _behaviors_
    * /Functions/ in functional programming
    * /Higher-order functions/
    * /Lambdas/
    * The concept of /functions/ in DIFFERENT programming languages
    
** Functions as behavior - 18
** Functions in functional programming - 19
   #+begin_src java
     public class SodaCan {
         public void drink() {
             System.out.println("You have drunk a can of soda.");
         }
     }

     public class ImperativeSodaMachine {
         private int coins = 0;
         private int cans = 0;
         public ImperativeSodaMachine(int initialCans) {
             this.cans = initialCans;
         }

         public SodaCan insertCoin() {
             if (cans > 0) {
                 --cans;
                 ++coins;
                 return new SodaCan();
             } else
                 throw new RuntimeException("Out of soda cans!");
         }
     }
   #+end_src
   
   #+begin_src scala
     case class SodaMachine(cans: Int, coins: Int = 0)

     def insertCoin(sm: SodaMachine): (SodaMachine, SoddaCan) =
       if (sm.cans > 0)
         (SodaMachine(sm.cans - 1, sm.coins + 1), new SodaCan)
       else
         throw new RuntimeException("Out of soda cans!");
   #+end_src
   
** Higher-order functions - 21
** Understanding lambda functions - 23
** DONE The concept of functions in different programming languages - 24
   CLOSED: [2022-06-06 Mon 09:57]
   /Functions/ are present in many programming languages.
   
   Some of the languages have better support for /purely functional styles/, while
   others favor /declarative styles/.
   =from Jian= From the context, it seems the last phrase should be /imperative styles/.

   - This is why, for example, using Scala over Java can give you tremendous
     leverage, because you can
     * declare functions inside other functions

     * declare functions, higher-order functions, that accept other functions more
       easily

     * declare /anonymous lambda functions/ (functionality also available in Java,
       starting from Java 8).

     This greatly increases your capacity for _ABSTRACTION_,
     creating control structures,
     and thereby enabling your application to be expressed in a more /DRY (Don't
     Repeat Yourself)/ way.

** DONE Summary - 24
   CLOSED: [2022-06-06 Mon 09:57]
   - In this chapter, we have seen _what /functions/ are_ and _how they have evolved
     from the early days of programming to today_. We have seen
     1. how functions were initially treated as abstractions of common logic.

     2. After that, in /object-oriented programming/, they represented _the *behavior*
        of certain objects._ Object-oriented programmers attempted to represent
        everything as an /object/. So it is only natural that functions started to
        be viewed in the context of a world that consists of objects. In this
        context, _/functions/ are best viewed as *behaviors* of these /objects/._

   - In /functional programming/, /functions/ can be viewed in a *DIFFERENT context*.
     Now, the best way to view /functions/ is as _mathematical computations_. They
     compute some value out of its inputs, in a pure way, which means *WITHOUT any
     /side effects/.* The idea is to view them as _mathematical functions_.

   - /Functional programming/ is close to /declarative programming/, so its
     /functions/ are also often tailored to the needs of that style.
       This way, in /functional languages/, there is a concept of /higher-order
     functions/, /anonymous lambda functions/, and /partial functions/. From an
     engineering perspective, this is useful because it greatly *enhances your
     capability for abstraction.*

   - In programming, /data structures/ are ubiquitous.
     When adopting /functional style/, sooner or later you will encounter a
     problem of *working with /data structures/ in a FUNCTIONAL WAY.*
     =TODO=
     =NEXT=
     In the next chapter, we will see how this problem is addressed.
     
** Questions - 25
  
* TODO Chapter 3: Functional Data Structures - 26
  Programming largely deals with _data manipulation_.
  Different styles of programming will treat data structures, and data itself,
  differently.

  - For example,
    /imperative programming/ treats data as _mutable information stored in
    memory_.

  - =TODO= =NEXT=
    Will see how the treeatment of /functional programming/ DIFFERS from that of
    /imperative programming/.

  - In this chapter, we will cover the following topics:
    * Collections framework
    * The algebraic approach
    * Effect types
    * Data structures in different programming languages
  
** Collections framework - 26
   When discussing /data structures/, it is *only natural to start with*
   /collections/.

   - Collections :: /data structures/ that *abstract away* /multiplicity/.

   - Because /collections/ are so UBIQUITOUS, it is only natural that _MODERN
     programming languages_ include a /collection framework/ in their /core
     library/.
     * This is *WHY* looking at a language's /collection framework/ is an easy way
       to see
       + *the philosophy of the language* and
       + *its approach to programming in general*.
   
*** Imperative collections - 28
*** Functional collections - 29
    
** Algebraic approach - 31
** Effect types - 33
*** ~Try~ - 34
*** ~Option~ - 35
    
** Data structures in different programming languages - 36
** Summary - 37
** Questions - 38
** Further reading - 38
  
* TODO Chapter 4: The Problem of Side Effects 39
  /Pure functional programming/ is all about *removing* /side effects/ and
  /mutations/.

  - We remove them for a reason.
    In this chapter, we will see
    * how /shared mutable states/ and /side-effecting functions/ can cause problems and
    * why it is best to *reduce* them.

  - The topics discussed are as follows:
    * /Side effects/
    * /Mutable states/
    * /Pure functions/
    * GENERALLY ENCOUNTERED /side effects/
    * /Pure functional paradigms/ in different programming languages


** Side effects - 39
   - Q :: WHAT exactly are /side effects/?
   - Q :: WHY should they be avoided?
     
   - For this discussion, we can define a /side effect/ as
     some instructions in a function's code that *modify* the environment
     *outside the scope* of this function.

   - The most common example of a /side effect/:
     *an /exception/ thrown by a program*.
     * REASON:
       _Throwing an exception_ is a /side effect/
       BECAUSE
       if you don't handle it, it will *disrupt* the program *outside the scope*
       of this function.
       
       So the program will break at this point and will stop its execution.

   - _Use ~try~ to handle /exception/
     puts the *BURDEN* of handling /side effects/ *on the client*,_
     which is probably not what we want to do.


   - =TODO=
     
** Mutable states - 41
** Pure functions - 43
*** Referential transparency - 45
    
** Generally encountered side effects 47
*** Error - 47
*** Absence of result - 48
*** Delay and asynchronous computations - 48
*** Logging - 49
*** Input-output operations - 50
    
** But how do we get rid of the side effects? - 51
** The pure functional paradigm in different languages - 52
** Summary - 53
** Questions - 54
  
* TODO Chapter 5: Effect Types - Abstracting Away Side Effects - 55
  - In the previous chapter, we saw why /side effects/ may be a source of trouble.

  - We also briefly discussed /effect types/.
    * /Effect types/ are _a TECHNIQUE of functional programming_ that allow for
      *the ABSTRACTION of /side effects/.*
  
  - In this chapter,
    * we will have a look at how this works.

    * We will learn the philosophy behind the pattern.

    * Also, we will see how to sequentially combine side effects trapped in /effect types/.
  
  - In this chapter, we will cover the following topics:
    * *Turning* /effects/ *INTO* _data_
    * The *sequential combination* of /effect types/ with /Monads/ – the ~map~ and
      ~flatMap~ functions


** Turning effects into data - 55
   - =TODO=

   - In this book, we will be calling the /data structures/ that *reify* the
     phenomena of the second-order reality /effect types/.

   - =TODO=
     
** The sequential combination of effects with Monads - 59
*** Introducing the ~map~ function - 60
*** Introducing the ~flatMap~ function - 61

** Summary - 63
** Questions - 64
  
* TODO Chapter 6: Effect Types in Practice - 65
  - In the previous chapters, we saw that
    the general pattern for *abstracting away* /side effects/ is to use /effect
    types/.
    * This pattern allows you to reduce the /mental load/ on your mind.

  - The pattern states that we first define an /effect type/ and then represent
    every occurrence of a particular /side effect/ with this type.

  - In this chapter, we will see
    * more examples of real world /effect types/ and
    * when to use them.

  - We will be covering the following topics:
    * ~Future~
    * ~Either~
    * ~Reader~
        
** ~Future~ - 65
   The effect ~Future~ is frequently encountered in a wide range of projects,
   even in non-functional languages (you can find it in Java).

   - Let's take a look at the _phenomenon_ that
     * _the /effect type/ abstracts_ and
     * _the MOTIVATION behind WHY such an /effect type/ may be needed._

*** Motivation and the imperative example - 65
*** Abstraction and the functional example - 68
*** Composing Futures - 69
*** ~flatMap~ generalized - 70
- 
** ~Either~ - 70
** ~Reader~ - 72
*** Functional solution - 73

** Summary - 75
** Questions - 75
  
* TODO Chapter 7: The Idea of the Type Classes - 76
** Rich Wrapper pattern - 77
   In this section, we will start our journey to understand
   _the PATTERN of /type classes/._

   We'll start by covering the idea of _the Rich Wrapper pattern._
   The pattern is *SPECIFIC to Scala,*
   =IMPORTANT=
   BUT it introduces the problem of *SEPARATING _data_ FROM _behavior_,* which
   becomes important in the /Type Class pattern/.

*** Motivation - 77
*** Implicit conversions - 77
*** Rich Wrapper - 79

** The Type Class pattern - 80
** Interpretation of the Type Class pattern - 88
*** Injectable interfaces - 88
*** Toolboxes - 89

** Type classes in different languages - 91
** Summary - 91
** Questions - 92
  
* TODO Chapter 8: Basic Type Classes and Their Usage - 93 - _START_
** A motivation for organizing type classes into systems and libraries - 93
** The Cats library for purely functional programming - 95
*** The structure of the library - 96
*** Core - 97
*** Type class hierarchy - 98
**** Abstract methods - 99
**** Concrete methods - 99
- 
*** Laws - 101
*** Syntax - 102
*** Instances - 108
*** Data - 112
*** Infrastructure synergy - 113
    
** Type classes - 113
*** ~Monad~ - 114
**** ~Writer~ effect type - 115
**** The ~tailRecM~ method - 117
     
*** ~Functor~ - 122
*** ~Applicative~ - 125
**** Motivation - 125
**** ~Applicative~ type class - 127
**** Implementation of the type class - 130
     
*** ~Monoid~ - 130
**** Implementation for ~Either~ - 134
**** ~MonoidK~ - 136
     
*** ~Traverse~ - 137
    
** Summary - 142
** Questions - 143
   
* Chapter 9: Libraries for Pure Functional Programming - 144
** Cats effect - 145
*** ProductR - 145
*** IO – the concurrence data type - 145
**** Referential transparency - 146
**** Inversion of control - 146

*** Asynchrony with IO - 147
**** Blocking example - 148
**** Concurrency infrastructure - 149
**** Running tasks in bunches - 150
**** Heavy load with blocking - 153
**** Synchronous tasks - 155
     
*** Constructing asynchronous tasks - 156
**** Asynchronous API - 160
**** Asynchronous example - 161
     
*** Fibers - 163
**** The computation - 163
**** IO combination without Fibers - 164
**** IO combination with Fibers - 166
**** Canceling Fibers - 168
     
*** Bracket - 169
    
** Server-side programming - 172
*** The architecture of a server-side application - 173
**** Communication protocol - 173
**** The software architecture of a server - 175
**** Example specification - 175

*** Orchestration and infrastructure - 176
**** Docker - 176
***** Docker-compose - 176
***** Dockerfiles - 179

*** Backend architecture - 181
**** Model - 181
**** Database layer - 182

*** Server-side programming - 197
*** Querying the server - 205

** Summary - 207
** Questions - 208
* Chapter 10: Patterns of Advanced Functional Programming - 209
** Monad Transformers - 209
*** The specialization of effect types - 210
*** An application with multiple side effects - 211
**** Asynchrony - 211
**** The side effect of errors - 214

*** Monad Transformers - 218
*** Generalizing the pattern - 220
    
** DONE Tagless Final - 221
   CLOSED: [2022-06-12 Sun 16:24]
*** Programming to capabilities - 222
    - This control over the /data structure/ we are working under gives us control
      over how we can *compose* our computation.

      * So, in the /Facade pattern/, only the _platform-specific capabilities_
        themselves *get abstracted away*, and that's it. 

      * However, in the /Tagless Final pattern/,
        + NOT ONLY do the _computations_ *get abstracted away*,

        + BUT _the way we COMPOSE our program_ *gets abstracted away*
          under _the ~F~ /effect type/._

*** Implementations - 225
*** Execution semantics abstraction - 227
*** Computation as a value - 229
*** TODO Free Monad - 230 - _RE-READ_
 
** Type-level programming - 232
*** A naive implementation of the heterogeneous list - 233
*** Type-level solution to the heterogeneous list problem - 236
*** Reclusive implicit resolution - 242
*** Debugging type-level computations - 246
*** Libraries for type-level programming - 247
    
** Summary - 247
** Questions - 248  

* Chapter 11: Introduction to the Actor Model - 249
** Overview of parallelism solutions - 249
** Traditional model synchronization on monitors - 252
*** Synchronization - 257
*** Problems with the traditional model – race conditions and deadlocks - 258
    
** The actor model as a replacement for the traditional model - 267
*** Deadlock example revisited - 268
    
** Summary - 271
** Questions - 271

* Chapter 12: The Actor Model in Practice - 272
** Akka overview - 272
*** Principles of Akka - 273
**** Encapsulation - 273
**** Messaging - 274
**** No leaking of mutable state - 274
**** Fault-tolerance and supervision - 275
**** Messaging guarantees - 275
**** Asynchrony - 276

** Defining, creating, and messaging actors - 276
*** Callbacks - 278
*** Supervision - 279
*** Context and references - 283
**** Managing the actor hierarchy - 285
**** Managing the life cycle - 287
**** Supervision - 288
     
*** Creating actors - 289
*** Actor parameters - 291

** Working with actor systems - 292
*** Task specification - 292
*** Implementation - 293
   
** Summary - 306
** Questions - 307
   
* Chapter 13: Use Case - A Parallel Web Crawler - 308
** Problem statement - 309
*** The graph structure of the web - 309
*** Collecting information from the graph - 310
*** Parallel nature of the task - 312
    
** Sequential solution - 314
** A parallel solution with Akka - 321
*** Strategy - 322
*** Implementation - 323
*** Caveats - 327
**** Visited links - 328
**** Fault tolerance - 329
**** Counting the responded actors - 330
**** Real-world side effects - 331
     
** Summary - 331
  
* DONE Appendix A: Introduction to Scala - 332
  CLOSED: [2022-06-11 Sat 22:46]
** DONE Motivation for using Scala - 332
   CLOSED: [2022-06-11 Sat 22:27]
   1. Scala is a functional language,
      which support for almost all of the functional programming styles that
      have been developed so far.

   2. Scala is designed explicitly with OOP in mind.
      This makes Scala friendly to programmers from the OOP world.
      * Scala positions itself as a mix between /object-oriented/ and
        /functional/ languages.

      * Scala is industry-oriented, and it is more production-ready than Haskell.

      * Scala can use Java libraries, and it also has its own production-ready
        native libraries, which is not only production-ready, but also can faciliate
        a /purely functional programming style/.

   3. Scala is an experimental language.
      =from Jian= This doesn't mean it is not mature or production-ready!
      This means it is often used as a playground to test new features and
      research in computer science. Some leading-edge reserch result can be available
      to Scala programmers.
      
** DONE Scala infrastructure - 333
   CLOSED: [2022-06-11 Sat 22:27]
*** TODO Scala interpreter - 333
*** TODO SBT build tool - 334
    
** DONE Variables and functions - 335
   CLOSED: [2022-06-11 Sat 22:37]
** DONE Control structures - 337
   CLOSED: [2022-06-11 Sat 22:46]
*** DONE If and While - 337
    CLOSED: [2022-06-11 Sat 22:37]
*** DONE For - 338
    CLOSED: [2022-06-11 Sat 22:46]
    The ~for~ construct is *NOT* called a /loop/ in Scala, but a Monadic flow.
    - This is due to the special meaning of the ~map~ and ~flatMap~ functions in
      functional programming.
      
*** DONE Pattern matching - 340
    CLOSED: [2022-06-11 Sat 22:36]
*** DONE Partial functions - 341
    CLOSED: [2022-06-11 Sat 22:36]
    
** DONE Inheritance model - 341
   CLOSED: [2022-06-11 Sat 22:43]
   Since Scala compiles to the JVM,
   it is *essential* that it supports the *SAME model* as Java
   _for /Java interoperability/ reasons._ =from Jian= under the hood.

*** DONE Classes - 342
    CLOSED: [2022-06-11 Sat 22:38]
    - /Case classes/ are especially useful when *modeling your domain*.
      
*** DONE Traits - 343
    CLOSED: [2022-06-11 Sat 22:41]
    In Scala, a so-called /linearization model/ is implemented.

    This means that whenever a /class/ is inherited from _MULTIPLE_ /traits/,
    they are organized into a clear sequence, which determines the priority of
    inheritance.
    
*** DONE Singleton objects - 344
    CLOSED: [2022-06-11 Sat 22:43]
    
** DONE Summary - 345
   CLOSED: [2022-06-11 Sat 22:44]
   
* TODO Assessments - 346
* TODO Other Books You May Enjoy - 352
* Index - 355
