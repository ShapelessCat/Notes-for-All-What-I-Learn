#+TITLE: Mastering Functional Programming
#+SUBTITLE: Functional techniques for sequential and parallel programming with Scala
#+PUBLICATION TIME: 2018
#+AUTHOR: Anatolii Kmetiuk
#+STARTUP: overview
#+STARTUP: entitiespretty

* Preface - 1
* Chapter 1: The Declarative Programming Style - 7
** Technical requirements - 7
** Principles of declarative programming - 8
*** Example – go-to versus loops - 9
*** Example – nested loop - 10
*** Don't Repeat Yourself (DRY) - 12

** Declarative versus imperative collections - 13
*** Filtering - 14

** Declarative programming in other languages - 16
** Summary - 17
** Questions - 17
   
* Chapter 2: Functions and Lambdas - 18
** Functions as behavior - 18
** Functions in functional programming - 19
** Higher-order functions - 21
** Understanding lambda functions - 23
** The concept of functions in different programming languages - 24
** Summary - 24
** Questions - 25
  
* Chapter 3: Functional Data Structures - 26
** Collections framework - 26
*** Imperative collections - 28
*** Functional collections - 29
    
** Algebraic approach - 31
** Effect types - 33
*** ~Try~ - 34
*** ~Option~ - 35
    
** Data structures in different programming languages - 36
** Summary - 37
** Questions - 38
** Further reading - 38
  
* Chapter 4: The Problem of Side Effects 39
** Side effects - 39
** Mutable states - 41
** Pure functions - 43
*** Referential transparency - 45
    
** Generally encountered side effects 47
*** Error - 47
*** Absence of result - 48
*** Delay and asynchronous computations - 48
*** Logging - 49
*** Input-output operations - 50
    
** But how do we get rid of the side effects? - 51
** The pure functional paradigm in different languages - 52
** Summary - 53
** Questions - 54
  
* Chapter 5: Effect Types - Abstracting Away Side Effects - 55
** Turning effects into data - 55
** The sequential combination of effects with Monads - 59
*** Introducing the ~map~ function - 60
*** Introducing the ~flatMap~ function - 61

** Summary - 63
** Questions - 64
  
* Chapter 6: Effect Types in Practice - 65
** ~Future~ - 65
*** Motivation and the imperative example - 65
*** Abstraction and the functional example - 68
*** Composing Futures - 69
*** ~flatMap~ generalized - 70
- 
** ~Either~ - 70
** ~Reader~ - 72
*** Functional solution - 73

** Summary - 75
** Questions - 75
  
* Chapter 7: The Idea of the Type Classes - 76
** Rich Wrapper pattern - 77
*** Motivation - 77
*** Implicit conversions - 77
*** Rich Wrapper - 79

** The Type Class pattern - 80
** Interpretation of the Type Class pattern - 88
*** Injectable interfaces - 88
*** Toolboxes - 89

** Type classes in different languages - 91
** Summary - 91
** Questions - 92
  
* Chapter 8: Basic Type Classes and Their Usage - 93
** A motivation for organizing type classes into systems and libraries - 93
** The Cats library for purely functional programming - 95
*** The structure of the library - 96
*** Core - 97
*** Type class hierarchy - 98
**** Abstract methods - 99
**** Concrete methods - 99
- 
*** Laws - 101
*** Syntax - 102
*** Instances - 108
*** Data - 112
*** Infrastructure synergy - 113
    
** Type classes - 113
*** ~Monad~ - 114
**** ~Writer~ effect type - 115
**** The ~tailRecM~ method - 117
     
*** ~Functor~ - 122
*** ~Applicative~ - 125
**** Motivation - 125
**** ~Applicative~ type class - 127
**** Implementation of the type class - 130
     
*** ~Monoid~ - 130
**** Implementation for ~Either~ - 134
**** ~MonoidK~ - 136
     
*** ~Traverse~ - 137
    
** Summary - 142
** Questions - 143
   
* Chapter 9: Libraries for Pure Functional Programming - 144
** Cats effect - 145
*** ProductR - 145
*** IO – the concurrence data type - 145
**** Referential transparency - 146
**** Inversion of control - 146

*** Asynchrony with IO - 147
**** Blocking example - 148
**** Concurrency infrastructure - 149
**** Running tasks in bunches - 150
**** Heavy load with blocking - 153
**** Synchronous tasks - 155
     
*** Constructing asynchronous tasks - 156
**** Asynchronous API - 160
**** Asynchronous example - 161
     
*** Fibers - 163
**** The computation - 163
**** IO combination without Fibers - 164
**** IO combination with Fibers - 166
**** Canceling Fibers - 168
     
*** Bracket - 169
** Server-side programming - 172
*** The architecture of a server-side application - 173
**** Communication protocol - 173
**** The software architecture of a server - 175
**** Example specification - 175

*** Orchestration and infrastructure - 176
**** Docker - 176
***** Docker-compose - 176
***** Dockerfiles - 179

*** Backend architecture - 181
**** Model - 181
**** Database layer - 182

*** Server-side programming - 197
*** Querying the server - 205

** Summary - 207
** Questions - 208
* Chapter 10: Patterns of Advanced Functional Programming - 209
** Monad Transformers - 209
*** The specialization of effect types - 210
*** An application with multiple side effects - 211
**** Asynchrony - 211
**** The side effect of errors - 214

*** Monad Transformers - 218
*** Generalizing the pattern - 220
    
** Tagless Final - 221
*** Programming to capabilities - 222
*** Implementations - 225
*** Execution semantics abstraction - 227
*** Computation as a value - 229
*** Free Monad - 230
 
** Type-level programming - 232
*** A naive implementation of the heterogeneous list - 233
*** Type-level solution to the heterogeneous list problem - 236
*** Reclusive implicit resolution - 242
*** Debugging type-level computations - 246
*** Libraries for type-level programming - 247
    
** Summary - 247
** Questions - 248  

* Chapter 11: Introduction to the Actor Model - 249
** Overview of parallelism solutions - 249
** Traditional model synchronization on monitors - 252
*** Synchronization - 257
*** Problems with the traditional model – race conditions and deadlocks - 258
    
** The actor model as a replacement for the traditional model - 267
*** Deadlock example revisited - 268
    
** Summary - 271
** Questions - 271
* Chapter 12: The Actor Model in Practice - 272
** Akka overview - 272
*** Principles of Akka - 273
**** Encapsulation - 273
**** Messaging - 274
**** No leaking of mutable state - 274
**** Fault-tolerance and supervision - 275
**** Messaging guarantees - 275
**** Asynchrony - 276

** Defining, creating, and messaging actors - 276
*** Callbacks - 278
*** Supervision - 279
*** Context and references - 283
**** Managing the actor hierarchy - 285
**** Managing the life cycle - 287
**** Supervision - 288
     
*** Creating actors - 289
*** Actor parameters - 291

** Working with actor systems - 292
*** Task specification - 292
*** Implementation - 293
   
** Summary - 306
** Questions - 307
   
* Chapter 13: Use Case - A Parallel Web Crawler - 308
** Problem statement - 309
*** The graph structure of the web - 309
*** Collecting information from the graph - 310
*** Parallel nature of the task - 312
    
** Sequential solution - 314
** A parallel solution with Akka - 321
*** Strategy - 322
*** Implementation - 323
*** Caveats - 327
**** Visited links - 328
**** Fault tolerance - 329
**** Counting the responded actors - 330
**** Real-world side effects - 331
     
** Summary - 331
  
* Appendix A: Introduction to Scala - 332
** Motivation for using Scala - 332
** Scala infrastructure - 333
*** Scala interpreter - 333
*** SBT build tool - 334
    
** Variables and functions - 335
** Control structures - 337
*** If and While - 337
*** For - 338
*** Pattern matching - 340
*** Partial functions - 341
    
** Inheritance model - 341
*** Classes - 342
*** Traits - 343
*** Singleton objects - 344
    
** Summary - 345
   
* Assessments - 346
* Other Books You May Enjoy - 352
* Index - 355
